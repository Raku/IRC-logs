[00:00] *** larion joined
[00:15] *** tinyblak joined
[00:21] *** roguelazer left
[00:27] <ugexe> why not capture $*IN on the main thread and do your work in the start {}?

[00:29] <ugexe> to do a progress bar i do SHOW-PROGRESS-BAR { <some logn running code> } which is basically a wrapper around capturing $*OUT and running <some logn running code> inside a start block

[00:33] <ugexe> Proc::Async lets you tap stdin as well

[00:48] <dalek> roast: cf74e36 | skids++ | / (2 files):

[00:48] <dalek> roast: Make fudge aware of some more functions from packages/Test/

[00:48] <dalek> roast: Unfudge some tests that run on JVM but not moar.

[00:48] <dalek> roast: review: https://github.com/perl6/roast/commit/cf74e36c90

[00:48] <dalek> roast: 2385c97 | skids++ | S06-currying/ (3 files):

[00:48] <dalek> roast: Add "use lib" statements for files that need Test::Assuming

[00:48] <dalek> roast: review: https://github.com/perl6/roast/commit/2385c97b5f

[00:51] *** Ben_Goldberg joined
[00:57] *** dayangkun joined
[01:02] *** gfldex left
[01:09] *** aborazmeh joined
[01:09] *** aborazmeh left
[01:09] *** aborazmeh joined
[01:10] *** yeahnoob joined
[01:14] *** rmgk_ joined
[01:14] *** rmgk is now known as Guest10940

[01:14] *** rmgk_ is now known as rmgk

[01:14] *** rurban left
[01:17] *** Guest10940 left
[01:34] *** dj_goku joined
[01:41] *** roguelazer joined
[01:41] *** TimToady left
[01:50] *** tinyblak left
[01:51] *** tinyblak joined
[01:51] *** AlexDaniel left
[01:55] *** tinyblak left
[02:00] *** vendethiel left
[02:01] <dalek> roast: c012c6f | skids++ | packages/Test/Assuming.pm:

[02:01] <dalek> roast: Re-fix priming-fails-bind-ok.  Hopefully for the last time.

[02:01] <dalek> roast: review: https://github.com/perl6/roast/commit/c012c6f32d

[02:02] *** tinyblak joined
[02:06] *** vendethiel joined
[02:06] *** telex left
[02:08] *** telex joined
[02:14] *** yeahnoob left
[02:18] *** noganex joined
[02:20] *** lolisa joined
[02:21] *** noganex_ left
[02:30] *** cognominal_ left
[02:39] *** raiph left
[02:40] *** raiph joined
[02:40] *** raiph left
[02:44] *** Sqirrel left
[02:48] *** cognominal joined
[02:57] *** roguelazer left
[03:03] *** roguelazer joined
[03:05] * [Coke] waves from NYC.

[03:06] <skids> o/

[03:08] *** roguelazer left
[03:13] *** Ben_Goldberg left
[03:27] *** Sqirrel joined
[03:32] *** vendethiel left
[03:33] *** vendethiel joined
[03:41] *** atroxaper joined
[04:02] <ugexe> perl6: class Foo { submethod BUILD { fail "doobie doobie doo" }; method bar { say 23; }; }; my $baz = Foo.new; $baz.bar

[04:02] <camelia> rakudo-jvm 389998: OUTPUT¬´23‚ê§¬ª

[04:02] <camelia> ..rakudo-moar 389998: OUTPUT¬´doobie doobie doo‚ê§  in block <unit> at /tmp/tmpfile:1‚ê§‚ê§¬ª

[04:10] *** khw left
[04:12] <ugexe> jvm/moar on windows both output 23 as well

[04:19] *** vendethiel left
[04:20] *** lolisa left
[04:21] *** vendethiel joined
[04:30] *** skids left
[04:36] *** atroxaper left
[04:39] *** kurahaupo left
[04:53] *** nys left
[04:55] <moritz> BUILD is called on an instance

[04:58] *** atroxaper joined
[04:59] *** kurahaupo joined
[05:00] <ugexe> perl6: class Foo { submethod BUILD { say 1; fail "doobie doobie doo" }; method bar { say 23; }; }; my $baz = Foo.new; $baz.bar

[05:00] <camelia> rakudo-jvm 389998: OUTPUT¬´1‚ê§23‚ê§¬ª

[05:00] <camelia> ..rakudo-moar 389998: OUTPUT¬´1‚ê§doobie doobie doo‚ê§  in block <unit> at /tmp/tmpfile:1‚ê§‚ê§¬ª

[05:01] *** diana_olhovik_ joined
[05:21] *** mattp__ joined
[05:22] *** diana_olhovik_ left
[05:28] *** atroxaper left
[05:31] *** atroxaper joined
[05:32] *** vendethiel left
[05:34] *** vendethiel joined
[05:38] *** baest_ is now known as baest

[05:44] *** kurahaupo left
[05:57] *** diana_olhovik joined
[06:04] *** kurahaupo joined
[06:09] *** mr-foobar joined
[06:30] *** FROGGS joined
[06:31] *** zacts left
[06:31] *** atroxaper left
[06:32] *** atroxaper joined
[06:36] *** kurahaupo left
[06:41] *** RabidGravy joined
[06:42] *** domidumont joined
[06:46] *** domidumont left
[06:47] *** domidumont joined
[06:56] *** dakkar joined
[07:09] *** rindolf joined
[07:14] *** darutoko joined
[07:21] *** g5 joined
[07:27] <RabidGravy> marnin! Are we all fabulous?

[07:29] *** larion left
[07:29] *** abraxxa joined
[07:31] *** anaeem1 joined
[07:35] *** kurahaupo joined
[07:36] *** FROGGS left
[07:37] *** rurban joined
[07:37] <DrForr> Well, awake.

[07:42] *** atroxaper left
[07:48] *** atroxaper joined
[07:52] *** anaeem1 left
[07:52] *** anaeem1 joined
[08:02] *** yeahnoob joined
[08:04] *** gcole left
[08:14] <RabidGravy> is there any way of finding out how many elements in a CArray?

[08:16] <moritz> you can access past the end, and observe where you segfault

[08:16] <moritz> it's just not very reliable

[08:17] <moritz> the problem is that in C, an array is just a pointer, which no extra runtime information whatsoever

[08:17] *** Foxcool_ left
[08:17] *** Foxcool joined
[08:18] *** TEttinger left
[08:19] <RabidGravy> yeah, I was just hoping that something else may have kept track of it

[08:20] <kurahaupo> moritz: well, that's the default implementation. There's nothing stopping a C implementation using "fat pointers" (aside from rotten performance, of course)

[08:21] <moritz> kurahaupo: but then it's not a CArray anymore

[08:22] <RabidGravy> so for may supplementary question would a PR that made CArray.elems fail rather than return 1 be accepted?  I keep forgetting that it doesn't work 

[08:23] <moritz> +1

[08:25] <kurahaupo> moritz: normally one wouldn't see the difference between a fat pointer and a normal point, but indexing outside a declared array invokes undefined behaviour, at which point an implementation with fat pointers could trap

[08:26] <kurahaupo> but I digress in #perl6

[08:29] *** nowan left
[08:32] *** nowan joined
[08:32] *** FROGGS joined
[08:56] *** salva left
[08:57] *** espadrine joined
[08:59] <RabidGravy> kurahaupo, the background to the above is that I'm binding an audio API that is a whole load of some "encode_something(long in_frames[], int no_frames, unsigned char *out_frames, int bufsize)" variants and knowing the size of the resulting CArrays that are getting thrown around would aid composability somewhat

[08:59] <DrForr> Oh, unsigned ints are now in?

[09:00] <RabidGravy> yeah, CArray[uint8] all over the place in this code ;-)

[09:00] <DrForr> Cool, I can finally finish up some bits of OpenCV.

[09:02] <DrForr> I've got a friend over at Drexel that uses this and its Python bindings extensively, when I get it working I'm going to badger him for some of his code and port it.

[09:04] * DrForr wonders what would be required to get 'perlbrew install perl-6.0.0' working.

[09:05] <RabidGravy> never looked in the perlbrew code

[09:05] <DrForr> Neither have I, but I suspect it's nontrivial.

[09:06] *** larion joined
[09:06] <DrForr> And possibly controversial.

[09:08] *** atroxaper left
[09:09] *** atroxaper joined
[09:16] <vendethiel> probably not as controversial as rvm (which overrides cd...).

[09:22] <DrForr> Eeh, who uses that old command? I just click and it runs.

[09:29] *** kurahaupo left
[09:30] *** rindolf left
[09:34] *** yeahnoob left
[09:36] *** virtualsue joined
[09:45] *** RabidGravy left
[09:45] <lizmat> raiph: re http://irclog.perlgeek.de/perl6/2015-07-07#i_10862254 perhaps it is good to know that at least MMD handles literal ints as native ints

[09:46] <lizmat> m: 'multi a(int $) {"int"}; multi a(Int $) {"Int"}; say a 1

[09:46] <camelia> rakudo-moar 389998: OUTPUT¬´5===SORRY!5=== Error while compiling /tmp/FUb6g9ByEj‚ê§Unable to parse expression in single quotes; couldn't find final "'" ‚ê§at /tmp/FUb6g9ByEj:1‚ê§------> 3{"int"}; multi a(Int $) {"Int"}; say a 17‚èè5<EOL>‚ê§    expecting any of:‚ê§        sing‚Ä¶¬ª

[09:46] <lizmat> m: multi a(int $) {"int"}; multi a(Int $) {"Int"}; say a 1

[09:46] <camelia> rakudo-moar 389998: OUTPUT¬´int‚ê§¬ª

[09:46] <lizmat> m: multi a(int $) {"int"}; multi a(Int $) {"Int"}; say a 0xffff_ffff_ffff_ffff

[09:46] <camelia> rakudo-moar 389998: OUTPUT¬´Int‚ê§¬ª

[09:46] <lizmat> m: multi a(int $) {"int"}; multi a(Int $) {"Int"}; say a 0xffff

[09:46] <camelia> rakudo-moar 389998: OUTPUT¬´int‚ê§¬ª

[09:46] <lizmat> m: multi a(int $) {"int"}; multi a(Int $) {"Int"}; say a 0xffff_ffff

[09:46] <camelia> rakudo-moar 389998: OUTPUT¬´Int‚ê§¬ª

[09:47] <lizmat> hmmm... no sure why *that* is happening

[09:48] <lizmat> m: multi a(int8 $) {"int8"}; multi a(Int $) {"Int"}; say a 256   # definitely some work here still

[09:48] <camelia> rakudo-moar 389998: OUTPUT¬´int8‚ê§¬ª

[09:48] <lizmat> does this warrant a rakudobug?

[09:58] *** atroxaper left
[09:59] *** stux|RC-only joined
[10:00] *** laouji joined
[10:04] <FROGGS> hmmm

[10:04] <FROGGS> good question

[10:05] <FROGGS> it surely isnt DWIM in this case

[10:05] <FROGGS> though sometimes you want to let it overflow, and not get an exception

[10:05] <FROGGS> bbiab

[10:09] <ShimmerFairy> lizmat: I want to say that integer literals should be non-native by default (since that's by far the more common use case), and thus require something like 42.int for the native version, but I can't say for sure.

[10:09] <|Tux|> lizmat, yt?

[10:09] <lizmat> ShimmerFairy: but why?  natives are much faster in most cases?  or are you afraid of unneccesary boxing/unboxing ?

[10:10] <lizmat> [Tux]: if I have time, yes, I guess...  :-)

[10:10] <|Tux|> https://gist.github.com/Tux/47d333430eb1a966ded1

[10:10] <|Tux|> gather/act miscommunication?

[10:11] *** gfldex joined
[10:11] <lizmat> I'm still investigation that...

[10:11] <ShimmerFairy> lizmat: to me, the native integer case is more likely to do native-ish things, and I don't think most Perl 6 code leans towards native stuff. That's what my reasoning is.

[10:12] <ShimmerFairy> (But I fully admit I'm not that familiar with how native types get used in Perl 6, because I've almost never needed them.)

[10:13] <lizmat> [Tux]: well, actually, atm I'm looking at masak's splice bug

[10:15] *** dayangkun left
[10:30] <dalek> rakudo/nom: 7aa070e | lizmat++ | src/core/Mu.pm:

[10:30] <dalek> rakudo/nom: Apparently, the new code doesn't like the JVM

[10:30] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/7aa070e046

[10:30] <dalek> rakudo/nom: d1e9b18 | lizmat++ | src/Perl6/Grammar.nqp:

[10:30] <dalek> rakudo/nom: Seems we *do* need worryobs somehow

[10:30] <dalek> rakudo/nom: 

[10:30] <dalek> rakudo/nom: This reverts commit eaee44f81268500c175c57566621a1cb7b7eabaa.

[10:30] <dalek> rakudo/nom: 

[10:30] <dalek> rakudo/nom:     # Expected: (X::Comp::Group)

[10:30] <dalek> rakudo/nom:     # Got:      (X::AdHoc)

[10:30] <dalek> rakudo/nom:     # Exception message: Cannot find method 'worryobs'

[10:30] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/d1e9b1879f

[10:35] <dalek> rakudo/nom: ed63b72 | lizmat++ | src/core/List.pm:

[10:35] <dalek> rakudo/nom: Part 1 of List.splice streamlining

[10:35] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/ed63b72a3a

[10:38] *** kurahaupo joined
[10:43] <dalek> Inline-Perl6: 74a7fbd | (Stefan Seifert)++ | t/lib/Perl6Test.pm:

[10:43] <dalek> Inline-Perl6: Add missing test library

[10:43] <dalek> Inline-Perl6: review: https://github.com/niner/Inline-Perl6/commit/74a7fbdded

[10:45] *** itz joined
[10:45] <itz> morning

[10:48] *** user3 joined
[10:52] *** atroxaper joined
[10:55] *** laouji left
[10:56] *** kurahaupo left
[10:57] *** user3 is now known as iH2O

[10:57] *** atroxaper left
[10:57] *** iH2O left
[11:02] *** dakkar left
[11:04] *** aborazmeh left
[11:06] <itz> how do I get access to http://examples.perl6.org/ ?

[11:08] <sjn> https://github.com/perl6/perl6-examples

[11:08] <itz> I mean shell access 

[11:09] <sjn> why do you need that?

[11:10] <itz> in order to debug why the colour syntax highlighting in p6-Text-VimColour doesn't work on that system when it works on my debian jessie system

[11:12] <sjn> do you have an url where that can be demonstrated?

[11:13] <itz> not anymore ... but just knowing whether the current version of that module is 1. installed and 2. the test passes would help me

[11:14] <dalek> rakudo/nom: 09041bc | lizmat++ | src/core/List.pm:

[11:14] <dalek> rakudo/nom: Add typechecking to List.splice, fixes #125571

[11:14] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/09041bc8e0

[11:14] <synbot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=125571

[11:16] *** anaeem1 left
[11:16] * sjn is not sure who manages that site (I'd love to know too)

[11:16] <sjn> let's find out :)

[11:17] <itz> I'm not even sure if the perl6-examples are built there or on another system .. but can wait for [ptc] anyway

[11:18] *** kurahaupo joined
[11:22] *** anaeem1 joined
[11:24] *** bin_005 joined
[11:25] *** rindolf joined
[11:28] *** lucasb joined
[11:28] *** bin_005 left
[11:30] <dalek> rakudo/nom: cac0c21 | lizmat++ | src/core/List.pm:

[11:30] <dalek> rakudo/nom: Part 2 of List.splice streamlining

[11:30] <dalek> rakudo/nom: 

[11:30] <dalek> rakudo/nom: Don't build the return value if it is not needed.

[11:30] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/cac0c2178c

[11:31] <lucasb> m: multi f(int) {'i'}; say f(42)

[11:31] <camelia> rakudo-moar ed63b7: OUTPUT¬´i‚ê§¬ª

[11:32] <lucasb> m: multi f(int) {1+2}; say f(42)

[11:32] <camelia> rakudo-moar ed63b7: OUTPUT¬´Cannot call f(Int); none of these signatures match:‚ê§    (int)‚ê§  in block <unit> at /tmp/d7kQT8Ofxq:1‚ê§‚ê§¬ª

[11:32] <lucasb> lizmat: Hi. MMD doesn't seem reliable when there is more than a simple literal on it.

[11:32] <lucasb> I don't why, in this case, it seems to upgrade the int to Int

[11:32] <lizmat> lucasb: could you rakudobug that, because that would seem essential for optimizing

[11:32] <lucasb> *idk why

[11:33] *** bin_005 joined
[11:33] <lizmat> with examples  :-)

[11:33] <lizmat> pretty please  :-)

[11:33] <lucasb> lizmat: OMG, I never rakudobuged before; I was just sayin' :)

[11:34] <lizmat> ok, could you please gist some examples then?

[11:34] <lizmat> (fwiw, rakudobugging is as simple as sending a mail to [email@hidden.address]
[11:35] <lucasb> ^^ That's the only example I have; If there was another 'multi f(Int)' it would have called that, and it would have worked, with int changed to Int

[11:35] <arnsholt> In this case, it's probably that integer literals have type Int by default

[11:37] <arnsholt> Or not. Didn't scrollback far enough

[11:37] <arnsholt> It's odd that the *body* of the multi should influence the MMD, yeah

[11:45] *** telex left
[11:46] <masak> lucasb++ # finding that bug

[11:46] *** telex joined
[11:46] <masak> ++lucasb # reporting it

[11:48] *** bin_005 left
[11:49] <lizmat> m: my @a = ^10; use nqp; nqp::bindattr(@a,List,q/$!items/,nqp::list()); say @a   # somehow I thought this would empty the array

[11:49] <camelia> rakudo-moar ed63b7: OUTPUT¬´0 1 2 3 4 5 6 7 8 9‚ê§¬ª

[11:50] <lizmat> jnthn pmichaud is this some reification thing ?

[11:53] *** skids joined
[11:54] *** anaeem1 left
[11:54] <kanl> m: say 1 <= 2 <= 3; say 1 !after 2 !after 3;

[11:54] <camelia> rakudo-moar cac0c2: OUTPUT¬´True‚ê§False‚ê§¬ª

[11:55] <moritz> m: say  !after 2

[11:55] <camelia> rakudo-moar cac0c2: OUTPUT¬´5===SORRY!5=== Error while compiling /tmp/216NZEwtx8‚ê§Undeclared routine:‚ê§    after used at line 1‚ê§‚ê§¬ª

[11:55] <moritz> m: say 1 !after 2

[11:55] <camelia> rakudo-moar cac0c2: OUTPUT¬´True‚ê§¬ª

[11:56] <kanl> so before/after can't be chained?

[11:56] *** laouji joined
[11:56] <lizmat> perhaps that is the problem

[11:56] <lizmat> m: say 3 after 2 after 1

[11:56] <camelia> rakudo-moar cac0c2: OUTPUT¬´True‚ê§¬ª

[11:56] <moritz> seems like the negation is the problem

[11:57] <lizmat> I think it's the auto-generated !after is the problem

[11:57] <lizmat> feels rakudobuggable

[11:58] *** RabidGravy joined
[11:59] <kanl> lizmat: i can do that if you'd like me to

[11:59] <lizmat> please do  :-)

[12:00] *** laouji left
[12:02] <lizmat> m: my @a = ^10; @a.gimme(*); use nqp; nqp::bindattr(@a,List,q/$!items/,nqp::list()); say @a   # is this correct?

[12:02] <camelia> rakudo-moar cac0c2: OUTPUT¬´‚ê§¬ª

[12:04] *** skids left
[12:04] *** ShimmerFairy left
[12:04] <lizmat> so it was reification related  :-)

[12:08] <moritz> lizmat: you'd have to reset $!nextiter too, I suppose (if you don't use .gimme(*))

[12:08] *** ShimmerFairy joined
[12:08] <lizmat> ah, ok.. hmm...

[12:11] <dalek> rakudo/nom: 537e90e | lizmat++ | src/core/List.pm:

[12:11] <dalek> rakudo/nom: Make @a.splice (without params) about 6x as fast

[12:11] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/537e90e3b3

[12:21] *** kurahaupo left
[12:25] <lucasb> Should after/before numify boolean literals to 0 or 1 when they appear as operands?

[12:27] <lucasb> oh, maybe it is instead boolifying the integers when there is bool/int mixed operands

[12:28] *** Ahmad joined
[12:29] <Ahmad> hello, is there a good book in market for perl6? or an opensource one for newcommers? I found only this which looks very old (2012) https://github.com/perl6/book/downloads 

[12:30] <lizmat> Ahmad: there is no (good) book yet, please check http://doc.perl6.org  and http://examples.perl6.org

[12:30] <lizmat> m: my @a = ^10; my @b = @a.splice(0,2,1..Inf); say @a   # this should either fail or hang in my book

[12:30] <camelia> rakudo-moar cac0c2: OUTPUT¬´2 3 4 5 6 7 8 9‚ê§¬ª

[12:31] <lizmat> aka splicing in an infinite list

[12:31] <lizmat> m: my @a = ^10; my @b = @a.splice(0,2,1..4); say @a   # works fine

[12:31] <camelia> rakudo-moar cac0c2: OUTPUT¬´1 2 3 4 2 3 4 5 6 7 8 9‚ê§¬ª

[12:31] <colomon> m: my @a = ^10; my @b = @a.splice(0,2,1..Inf); say @a; say @b[^10]

[12:31] <camelia> rakudo-moar cac0c2: OUTPUT¬´2 3 4 5 6 7 8 9‚ê§0 1‚ê§¬ª

[12:32] <lizmat> ranges don't auto-extend by design, colomon

[12:33] <ShimmerFairy> lizmat: I'd say fail. The only case I can think of where it could maybe make sense would be appending it to the end of a finite list, but even then I don't immediately see why that's necessary.

[12:33] <ShimmerFairy> (Also, what you just said made the appending thing sound silly :P)

[12:33] <lizmat> m: my @b = ^2; say @b[^10].perl; say @b(0,1,2,3,4,5,6,7,8,9].perl

[12:33] <camelia> rakudo-moar cac0c2: OUTPUT¬´5===SORRY!5=== Error while compiling /tmp/wE06hp7BdA‚ê§Unable to parse expression in argument list; couldn't find final ')' ‚ê§at /tmp/wE06hp7BdA:1‚ê§------> 3@b[^10].perl; say @b(0,1,2,3,4,5,6,7,8,97‚èè5].perl‚ê§¬ª

[12:33] <lizmat> m: my @b = ^2; say @b[^10].perl; say @b[0,1,2,3,4,5,6,7,8,9].perl

[12:33] <camelia> rakudo-moar cac0c2: OUTPUT¬´(0, 1)‚ê§(0, 1, Any, Any, Any, Any, Any, Any, Any, Any)‚ê§¬ª

[12:33] <lizmat> colomon: FWIW, I find it also counter-intuitive and had to adapt recent spectests for this behaviour

[12:34] *** smls joined
[12:34] * colomon is reading the docs for splice right now, and is very confused

[12:34] <lizmat> colomon: the problem is not in the splice, but in [^10] versus [0,1,2,3,4,5,6,7,8,9]

[12:34] <colomon> lizmat: huh?

[12:35] <colomon> m: my @a = ^10; my @b = @a.splice(0,2,1..Inf); say @a; say @b

[12:35] <camelia> rakudo-moar cac0c2: OUTPUT¬´2 3 4 5 6 7 8 9‚ê§0 1‚ê§¬ª

[12:35] *** Ahmad left
[12:35] <lizmat> ah, that, ok

[12:35] <lizmat> :-)

[12:35] <lizmat> yeah

[12:35] <lizmat> working on that

[12:36] <colomon> why does .splice work in place?

[12:36] <colomon> that seems very un-p6ish

[12:36] <colomon> guess it‚Äôs classed with .push?

[12:37] <lizmat> colomon: I have no idea...  

[12:37] <lizmat> I guess convenience ?

[12:37] <lizmat> Perlishness ?

[12:37] *** |Tux| left
[12:37] *** |Tux| joined
[12:38] <ShimmerFairy> Would splice make sense on a literal list? If not, I can see why you'd make it a mutating method.

[12:39] <colomon> and then yes, why isn‚Äôt the inifinite range stuck at the beginning of the list where the spliced out values were?

[12:39] <colomon> ShimmerFairy: it seems to me that splice is kind of like subst for lists/arrays, and subst doesn‚Äôt mutate.

[12:40] *** anaeem1 joined
[12:40] <smls> @a.splice-rw(0,2) = 1..Inf   would be a more Perl6ish syntax IMO

[12:40] <colomon> though I guess maybe it‚Äôs substr instead?

[12:40] <lizmat> smls colomon : I'll leave that for TimToady to decide

[12:41] <sjn> \o

[12:41] * lizmat is just the implementor being tormented :-)

[12:41] *** atroxaper joined
[12:41] <smls> lizmat++

[12:41] <kanl> m: Inf.WHAT.say

[12:41] <camelia> rakudo-moar cac0c2: OUTPUT¬´(Num)‚ê§¬ª

[12:41] <kanl> m: my Int @a = 1 .. Inf; ## dumb question, how does this work?

[12:41] <camelia> rakudo-moar cac0c2: ( no output )

[12:41] <ShimmerFairy> I don't like the -rw methods, honestly. They look kinda ugly.

[12:41] <kanl> m: my Int @a = 1 .. Inf; say @a[*-1]; ## then why not this?

[12:41] <camelia> rakudo-moar cac0c2: OUTPUT¬´Cannot coerce Inf or NaN to an Int‚ê§  in block <unit> at /tmp/EprYxqi3Tg:1‚ê§‚ê§¬ª

[12:41] <lizmat> kanl: good one

[12:41] <lizmat> please rakudobug  :-)

[12:42] <kanl> no kidding? :)

[12:42] <lizmat> the error message is LTA for sure

[12:43] <kanl> m: sub foo( Int $min, Int $max ) { $min .. $max }; foo( 1, Inf ).say;

[12:43] <camelia> rakudo-moar cac0c2: OUTPUT¬´5===SORRY!5=== Error while compiling /tmp/sTKcouwI83‚ê§Calling foo(Int, Num) will never work with declared signature (Int $min, Int $max)‚ê§at /tmp/sTKcouwI83:1‚ê§------> 3 Int $min, Int $max ) { $min .. $max }; 7‚èè5foo( 1, Inf ).say;‚ê§¬ª

[12:43] <kanl> i guess this is no surprise.

[12:43] <kanl> but it's awkward to make it foo(Int, Num)

[12:44] <dalek> rakudo/nom: 3776b7d | lizmat++ | src/core/List.pm:

[12:44] <dalek> rakudo/nom: Prevent infinite lists from being spliced in

[12:44] <dalek> rakudo/nom: 

[12:44] <dalek> rakudo/nom: This used to splice in an empty list silently.

[12:44] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/3776b7d0a4

[12:45] *** brrt joined
[12:45] <sjn> can someone here tell me who the people behind *.perl6.org are?

[12:45] <lizmat> moritz would be a good bet ?

[12:45] * sjn sees Daniel Wright owns the domain

[12:46] *** atroxaper left
[12:46] <lizmat> that's just the Perl Foundation, no?

[12:46] <sjn> right, but who actually manages it? (keeps the system alive and updated)

[12:47] <lizmat> moritz again would be a good bet

[12:47] <lizmat> FROGGS also, I guess

[12:48] <sjn> lizmat: allright, thanks, let's get some confirmation :)

[12:49] <moritz> sjn: me, mostly

[12:49] <moritz> sjn: also FROGGS++ has been doing a bit of admin work around it

[12:49] <sjn> moritz: ah, no other backups? (cue maddingue as a SPOF example for the Act sites)

[12:50] <sjn> moritz: do you handle _all_ the *.perl6.org sites?

[12:51] <timotimo> sjn: have a look at p6c.org

[12:51] <timotimo> that explains it a fair bit

[12:51] * sjn is trying to get an overview of such things for his yapc talk

[12:52] <sjn> timotimo: is that page up-to-date?

[12:53] <ribasushi> damn, sounds like an interesting talk, pity I likely won't make it

[12:53] <sjn> timotimo: I see "A third virtual machine is planned for high-risk applications [...] is planned"

[12:53] <moritz> sjn: lots of folks have root on the web server, it's just that most people don't use it

[12:53] <timotimo> yeah, that's not made yet

[12:53] <moritz> sjn: yes, still being planned

[12:53] <sjn> ok, the typo there, is it being planned to be fixed? :D

[12:54] <sjn> or is just the planning being planned ;)

[12:54] *** rarara joined
[12:54] <moritz> sjn: you can plan at fix at https://github.com/perl6/www.p6c.org

[12:54] <sjn> :D

[12:55] *** anaeem1 left
[12:55] *** anaeem1 joined
[12:57] *** anaeem1__ joined
[12:57] *** anaeem1 left
[12:58] *** colomon left
[12:59] *** Obbi left
[12:59] *** BinGOs left
[12:59] *** Obbi joined
[12:59] *** leedo joined
[12:59] <Ulti> the latest R* the start time is half a second... this is on a beefy machine with 16 cores and 80GB of RAM

[12:59] *** colomon joined
[12:59] *** yogan left
[12:59] *** timotimo left
[13:00] *** yogan joined
[13:00] <Ulti> locally on my laptop with an SSD its at 0.003s

[13:01] *** BinGOs joined
[13:01] <Ulti> which is worryingly an order of magnitude faster than Perl 5 on this laptop :Z

[13:01] <smls> 0.003s, are you sure?

[13:01] *** timotimo joined
[13:01] *** cosimo joined
[13:01] <Ulti> yeah thats what I thought

[13:01] <Ulti> doing perl6 -e ''

[13:01] <smls> for me (PC with SSD) it's 0.13 s

[13:01] *** abraxxa left
[13:02] <Ulti> did it again so now with disk cache its 0.002s lol

[13:02] <Ulti> wat

[13:02] <Ulti> ahhh there we go it was the time not to find it in the path ;)

[13:02] <smls> sounds like Perl 5

[13:02] <smls> ah

[13:03] <Ulti> but the half a second is definately not the best I've seen for Rakudo recently

[13:03] <dalek> rakudo-star-daily: b04d7dd | coke++ | log/ (9 files):

[13:03] <dalek> rakudo-star-daily: today (automated commit)

[13:03] <dalek> rakudo-star-daily: review: https://github.com/coke/rakudo-star-daily/commit/b04d7ddf82

[13:03] <lizmat> Ulti: it's caused by CURL and having a lot of modules installed

[13:03] <Ulti> 0.3 locally 

[13:03] <lizmat> actually, the CURI

[13:04] <lizmat> still, it shouldn't be that for a bare -e 1

[13:04] <lizmat> it should be for the first "use" you do, I would think

[13:04] <Ulti> and locally I have whatever head was five minutes ago

[13:05] <Ulti> yeah I thought the empty -e was before a lot of things get sucked in or deserialised... if I do -e 'say "hi"' its a bit slower

[13:06] <Ulti> but to get into the REPL its a delay that feels super slow

[13:07] <Ulti> and I only say this because its been fast for a while now normally :)

[13:07] <Ulti> with Task::Star installed

[13:09] <timotimo> hm, with the REPL it could be because we load Linenoise?

[13:10] <lizmat> yep, and that loads CURI and that deserializes

[13:10] *** dakkar joined
[13:11] *** laouji joined
[13:11] <timotimo> at least we deserialize today, instead of json-parsing :)

[13:12] <lizmat> yeah, json-parsing took 20+ seconds or so

[13:12] <lizmat> which is why we didn't have a R* for a while

[13:12] <timotimo> 20+ seconds!? for how many modules?

[13:15] <dalek> rakudo/nom: d33ece8 | lizmat++ | src/core/List.pm:

[13:15] <dalek> rakudo/nom: Allow * as size indicate in splice

[13:15] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/d33ece802f

[13:16] <lizmat> the ones that came with Rakudo*, don't know how many

[13:16] <lizmat> or maybe that was the whole ecosystem time...

[13:17] <lizmat> I remember FROGGS complaining about it  :-)

[13:17] *** espadrine left
[13:18] <moritz> sjn: thanks for the pr; you could have pushed directly though :-)

[13:19] <timotimo> mhm

[13:19] <timotimo> JSON::Fast could have possibly reduced that to ~12 seconds :\

[13:22] <moritz> how was it fixed?

[13:23] <lizmat> the database is effectively precomped

[13:23] <lizmat> afaik

[13:24] <FROGGS> it is a compilation unit containing a hash

[13:26] <FROGGS> though besides the precomp issues we had I'm not that fond of the cur-specs... they do not round-trip very well in some cases, and I wonder if we're blind to see a better option

[13:26] <FROGGS> though we have the limitation that we need to pass the cur specs around via ENV :o(

[13:27] <FROGGS> have other languages database like library storages?

[13:27] <FROGGS> of different kinds?

[13:27] <lizmat> P5 has a package list, but that's only used during installation

[13:28] <lizmat> P6 introspection and MMD on compilation units and unicode support is what makes this all less simple

[13:29] <arnsholt> Some languages have stuff like RubyGems, but that's all library-level stuff

[13:29] <arnsholt> I don't know of any languages that handle versioning and such at the level P6 does

[13:30] *** g5 left
[13:31] <FROGGS> I don't care about versioning right now... is there another language that has library storage *types*?

[13:31] <dalek> rakudo/nom: 192e89a | lizmat++ | src/core/List.pm:

[13:31] <dalek> rakudo/nom: Make sure we propegate the type of array

[13:31] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/192e89a58b

[13:31] <FROGGS> lizmat: perhaps a solution would be to only allow one cur type per path?

[13:32] <lizmat> FROGGS: isn't it that way already ???

[13:32] <FROGGS> and then have some sort of cur-magic (like mime magic) to guess the right type

[13:33] <lizmat> FROGGS: please remember that we can (and will) have CUR's that are *not* local

[13:33] <FROGGS> true

[13:33] *** VinceDee joined
[13:33] <lizmat> e.g. a distribution might decide to install precomped files on the fly from their own on-line repo

[13:35] <FROGGS> I... just like to get rid of the cur-specs I think

[13:36] <lizmat> I'm all ears  :-)

[13:36] <FROGGS> like: -I/foo/bar results in a check for /foo/bar/MANIFEST.json, and if it exists it is an CURLI, otherwise a CURLF

[13:36] <FROGGS> though, might be non trivial to guess other types, e.g. when they are non-local

[13:37] <lizmat> exactly  :-(

[13:37] <lizmat> it would only be an optimization for CURLF/CURI 

[13:37] <lizmat> which could make sense for detecting CURI and not having to prefix "inst#" for specifying CURI's

[13:40] <dalek> rakudo/nom: 3776723 | lizmat++ | docs/ChangeLog:

[13:40] <dalek> rakudo/nom: Mention List.splice fixes/improvements

[13:40] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/3776723393

[13:40] *** laouji left
[13:43] *** VinceDee left
[13:47] *** skids joined
[13:50] <lizmat> m: say Array.new.of; say Array[Mu].new.of

[13:50] <camelia> rakudo-moar 3776b7: OUTPUT¬´(Mu)‚ê§(Mu)‚ê§¬ª

[13:50] <lizmat> hmmm...

[13:51] <timotimo> hm, how does the splice candidate work that has "$size?, *@values"? we probably expect @values to be empty if $size isn't passed?

[13:51] <lizmat> m: my @a := Array.new; my @b := Array[Mu].new; dd @a.of, @b.of

[13:51] <camelia> rakudo-moar 192e89: OUTPUT¬´Mu‚ê§Mu‚ê§¬ª

[13:51] <lizmat> hmmm...

[13:52] <lizmat> size is about how many to remove

[13:52] <timotimo> also: even though there's a :range("0..^$elems") in there, we only check for $o < 0, not for $o > $elems?

[13:52] <lizmat> indeed, because you may splice into after the end

[13:52] <lizmat> I guess we should check for Inf there

[13:53] <lizmat> m: my @a = ^5; @a.splice(10,0,^10); say @a.perl'

[13:53] <camelia> rakudo-moar 192e89: OUTPUT¬´5===SORRY!5=== Error while compiling /tmp/OM_wBUVpL8‚ê§Two terms in a row‚ê§at /tmp/OM_wBUVpL8:1‚ê§------> 3a = ^5; @a.splice(10,0,^10); say @a.perl7‚èè5'‚ê§    expecting any of:‚ê§        infix‚ê§        infix stopper‚ê§        postfix‚ê§        s‚Ä¶¬ª

[13:53] <lizmat> m: my @a = ^5; @a.splice(10,0,^10); say @a.perl

[13:53] <camelia> rakudo-moar 192e89: OUTPUT¬´[0, 1, 2, 3, 4, Any, Any, Any, Any, Any, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9]<>‚ê§¬ª

[13:53] <timotimo> well, $offset is also not checked against an upper bound

[13:54] <timotimo> we may want to check $offset against the upper bound if and only if $size isn't 0

[13:54] *** notjack joined
[13:55] <lizmat> m: my @a; @a.splice(Inf,0,^10)

[13:55] <camelia> rakudo-moar 192e89: OUTPUT¬´This type cannot unbox to a native integer‚ê§  in block <unit> at /tmp/nCesICcBTv:1‚ê§‚ê§¬ª

[13:55] <lizmat> m: my @a; @a.splice(*,0,^10)

[13:55] <camelia> rakudo-moar 192e89: OUTPUT¬´This type cannot unbox to a native integer‚ê§  in block <unit> at /tmp/JCvUVc4fZF:1‚ê§‚ê§¬ª

[13:55] <lizmat> I guess the latter should DWIM to end of array

[13:55] <lizmat> the former should get a better error message

[13:58] *** novice-273C joined
[13:58] *** laouji joined
[13:59] *** eitz joined
[14:01] <novice-273C> p6:  $_="\$666";   s:g[\$ <( \d+ )> ] *= 2; .say

[14:01] <camelia> rakudo-moar 192e89: OUTPUT¬´$1332‚ê§¬ª

[14:03] <novice-273C> but oneliner perl6 -pe 's:g[\$ <( \d+ )> ] *= 2' doesn't work after entering $666. why?

[14:07] <notjack> novice-273C: Maybe the implicit say in -pe isn't doing what you want

[14:07] <notjack> novice-273C: I don't have -6 installed on this machine, but maybe try adding an explicit ;.say to your one-liner?

[14:07] <PerlJam> I don't think the say is the problem.

[14:08] <[Coke]> m: s:g[\$ <( \d+ )> ] *= 2

[14:08] <camelia> rakudo-moar 192e89: OUTPUT¬´Method 'subst-mutate' not found for invocant of class 'Any'‚ê§  in block <unit> at /tmp/PCCwifQJIP:1‚ê§‚ê§¬ª

[14:09] *** abraxxa joined
[14:10] * [Coke] tries that locally, realizes this machine has a 2014.07 install. whoops.

[14:10] *** laouji left
[14:10] <timotimo> the 2014s called, they want their rakudo back

[14:16] <[Coke]> one of our long term goals is to get rid of any #if jvm (e.g.) blocks in rakudo, yes? (these differences should already be handled by nqp in an ideal stack) Aye?

[14:16] <timotimo> in an ideal world, yeah, but it's not The Prime Directive

[14:17] <timotimo> but i think there should still be bugs filed somewhere for things that need unequal treatment

[14:20] *** espadrine joined
[14:26] *** larion_ joined
[14:32] *** aborazmeh joined
[14:32] *** aborazmeh left
[14:32] *** aborazmeh joined
[14:34] *** virtualsue left
[14:38] *** rurban left
[14:38] *** brrt left
[14:40] <ugexe> perl6.bat" -e "my $p1 = IO::Path.new-from-absolute-path('C:\Users'); my $p2 = 'Nick'; my $p3 = $p2.IO.relative($p1); say $p3" # > Nick\Documents\GitHub\zef\Nick speaking of IO::Path...

[14:48] *** lucasb left
[14:48] *** rurban joined
[14:48] *** mr-foobar left
[14:50] *** khw joined
[14:50] *** lucasb joined
[14:54] *** nowan left
[14:55] *** raiph joined
[14:57] *** nowan joined
[14:58] *** novice-273C left
[15:00] *** lucasb left
[15:06] *** nowan left
[15:07] <ugexe> my confusion appears to have stemmed from expecting it to use $p1.CWD, not $p2.CWD. i see how that could be expected to work either way now

[15:09] <ugexe> still a dream compared to using File::Spec

[15:10] <hoelzro> morning #perl6

[15:12] *** nowan joined
[15:15] *** aborazmeh left
[15:22] *** tinyblak left
[15:23] *** tinyblak joined
[15:27] <itz> DBIish seems quite "worried"

[15:27] *** tinyblak left
[15:30] *** spider-mario joined
[15:37] *** diana_olhovik left
[15:41] *** TimToady joined
[15:41] *** pecastro joined
[15:42] <PerlJam> heh ... I was confused why perl5 wasn't finding my library even though I set the environment var.   Took me a minute to realize that I'd set PERL6LIB

[15:45] *** nys joined
[15:47] *** leont joined
[15:47] <leont> How do I generate a stacktrace, like confess in p5?

[15:52] <nine> m: say Backtrace.new

[15:52] <camelia> rakudo-moar 377672: OUTPUT¬´Backtrace.new‚ê§¬ª

[15:53] <TimToady> m: say Backtrace.new.full

[15:53] <camelia> rakudo-moar 377672: OUTPUT¬´  in block  at src/gen/m-CORE.setting:15046‚ê§  in method new at src/gen/m-CORE.setting:15047‚ê§  in block <unit> at /tmp/TLtHnUmCQc:1‚ê§‚ê§¬ª

[15:53] <nine> m: say Backtrace.new.Str

[15:53] <camelia> rakudo-moar 377672: OUTPUT¬´  in block <unit> at /tmp/IV4kUylb5e:1‚ê§‚ê§¬ª

[15:54] <TimToady> that's probably deferring to .nice

[15:55] <TimToady> no, it's just a summary, I guess

[15:55] <TimToady> yes, it defers to .nice, was reading the wrong class

[15:56] *** nowan left
[15:58] *** laouji joined
[15:58] <timotimo> is there anything nice that'll remind me to update my oracle java JDK when new versions get released?

[15:59] <nwc10> an egg timer? :-)

[15:59] <nwc10> (oh no, wait, that's for *Flash* security updates)

[15:59] <timotimo> :)

[16:00] *** nowan joined
[16:01] *** Ven joined
[16:02] *** laouji left
[16:03] <itz> can someone with access to hack.p6c.org:/home/rakudobrew do a "panda install  Text::VimColour" please?

[16:05] *** larion left
[16:05] *** larion_ left
[16:06] *** virtualsue joined
[16:07] <dalek> Inline-Perl5: e314d53 | (Stefan Seifert)++ | p5helper.c:

[16:07] <dalek> Inline-Perl5: Fix loading P5 modules from P6 code run by Inline::Perl6

[16:07] <dalek> Inline-Perl5: 

[16:07] <dalek> Inline-Perl5: Add missing XS hookup when Inline::Perl5 is loaded by Inline::Perl6

[16:07] <dalek> Inline-Perl5: Fixes: $p6.run('use Foo:from<Perl5>;');

[16:07] <dalek> Inline-Perl5: review: https://github.com/niner/Inline-Perl5/commit/e314d5340d

[16:09] *** FROGGS left
[16:09] <leont> Stacktraces not showing arguments to functions is not very helpful :-/

[16:12] <TimToady> certainly not as helpful as it could be

[16:13] <nine> Especially since in Perl 6 we could see more useful arguments than just "HASH(0x1bb6e78)"

[16:17] *** atroxaper joined
[16:18] *** rindolf left
[16:19] *** andreoss joined
[16:20] *** diana_olhovik_ joined
[16:20] <dalek> perl6-roast-data: 133f61a | coke++ | / (9 files):

[16:20] <dalek> perl6-roast-data: today (automated commit)

[16:20] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/133f61a03f

[16:21] *** atroxaper left
[16:21] *** anaeem1__ left
[16:22] *** uncleyear left
[16:22] <leont> I have an array of Subs, I want to return true if calling any of them (with given arguments) return true. How do I express that most easily? ´any(@rules).($args)ª doesn't seem to work

[16:22] *** synbot6 left
[16:23] <leont> (or maybe PEBKAC)

[16:23] *** uncleyear joined
[16:24] *** itz left
[16:25] <timotimo> i think you need to |$args in any case

[16:25] <[Coke]> m: sub a($) { False } ; sub b($) { False } ; sub c($) { False } ; sub d($) { False } ; sub e($) { True } ; sub f($) { False } ; my @subs = &a, &b, &c, &d, &e, &f; say so any(@subs>>.("stuff"));

[16:25] <camelia> rakudo-moar 377672: OUTPUT¬´True‚ê§¬ª

[16:26] <timotimo> that doesn't short-circuit, though

[16:26] <timotimo> which leont may want

[16:26] <[Coke]> leont: do you want short circuiting?

[16:26] <[Coke]> (in which case, you don't want junctions)

[16:26] <leont> That would be nice

[16:27] <leont> Ah, I see

[16:27] <[Coke]> the any has to go around the whole invocation, not just the rules.

[16:28] <[Coke]> m: sub a($) { False } ; sub b($) { False } ; sub c($) { False } ; sub d($) { False } ; sub e($) { True } ; sub f($) { False } ; my @subs = &a, &b, &c, &d, &e, &f; say so [||] @subs>>.("stuff");

[16:28] <camelia> rakudo-moar 377672: OUTPUT¬´True‚ê§¬ª

[16:28] *** domidumont left
[16:28] <[Coke]> ^^ that should short circuit.

[16:29] <vendethiel> uh; why?

[16:29] <vendethiel> you're first computing the list

[16:30] <vendethiel> is >> specced to be lazy?

[16:31] <timotimo> it's the opposite of lazy, it's hyper

[16:31] <Ven> oh, wow. http://blogs.perl.org/users/will_the_chill_aka_will_braswell/2015/07/perl-5-optimizing-compiler-part-13-happy-july-4th-rperl-v10-full-release.html looks cool

[16:33] *** sjn_phone joined
[16:33] <leont> Ven: too bad it documents nothing about what it can and can not do

[16:33] <Ven> leont: yep. but apparently it's bazinga-ly fast...

[16:34] <leont> AFAIK, for a tiny feature set of perl that it can convert into C

[16:35] <Ven> well, that's already interesting :P

[16:36] <PerlJam> Ven: I dunno ... if you remove all of the Perly features everyone is used to so that you can get super fast ... why not just write in another language, like, I dunno ... C or C++?

[16:36] *** lucasb joined
[16:36] <leont> Given XS call overhead, it wouldn't matter unless you're doing something that you should have been doing in C in the first place

[16:37] <leont> Or at least I think it does that, if it's actually capable of generating custom opcodes that may be a lot better

[16:39] <[Coke]> (eager vs. lazy) whoops. 

[16:40] *** rindolf joined
[16:40] <leont> Why doesn't ´@patterns.first($value ~~ *);ª DWIM?

[16:40] * lizmat was working some more on splice and tests

[16:40] <japhb> Dear lazy-#perl6: Please make ||:= work.  I want to use the Orcish Maneuver when binding.  :-)

[16:40] <lizmat> afk for dinnr&

[16:40] <leont> Erm, because I forgot to BoolifyÖ

[16:41] <timotimo> leont: "first" already gives you smart match semantics

[16:41] <timotimo> and also: foo ~~ * doesn't create a WhateverCode IIRC

[16:42] <Ven> timotimo: wasn't it changed recently?

[16:42] <Ven> m: say (5 ~~ *)(5)

[16:42] <camelia> rakudo-moar 377672: OUTPUT¬´True‚ê§¬ª

[16:42] <timotimo> could be

[16:42] <leont> No, I think I want the opposite of first

[16:43] <leont> Or really, I want a short-cutting any

[16:43] <timotimo> so [||]?

[16:43] <timotimo> i *think* that short-circuits?

[16:43] *** spider-mario left
[16:43] <timotimo> um, no, probably not

[16:43] <leont> I wouldn't expect that to shortcut

[16:43] <leont> Even if I would expect that to be lazy

[16:44] <Ven> well, if the list is lazy, maybe?

[16:44] <timotimo> i don't understand why first isn't what you need :)

[16:45] <leont> Because "Regex object coerced to string"

[16:46] <leont> I want the left and right hand side of the smartmatch to be the other way around

[16:47] <leont> I suppose that's ´@patterns.first({ $value ~~ $_ })ª

[16:48] <Ven> leont: if your perl6 is >1month old, `x ~~ *` might mean something different

[16:48] <leont> It's two days ago

[16:48] <leont> s/ago/old/

[16:48] <leont> Anyway, in the end I'm getting a ´No such method 'match' for invocant of type 'Any'ª error that I just can't grok

[16:49] <nine> m: m: my @p = /foo/, /bar/, /baz/; say @p.first: "bar" ~~ *;

[16:49] <camelia> rakudo-moar 377672: OUTPUT¬´/bar/‚ê§¬ª

[16:50] <[Coke]> leont: code sample?

[16:50] <colomon> Hmmm‚Ä¶ @subs.first({ ?($_($args)) })  ?

[16:51] <leont> Would need to reduce, probably

[16:51] <nwc10> Ven: in addition to what leont and PerlJam said, if you look at all the things that rperl won't support, it's arguably a less powerful language than C: http://rperl.org/the_low_magic_perl_commandments.html

[16:52] <vendethiel> oh :(

[16:54] <leont> It seems I'm getting that error when boolifying the result of the first, not sure what that means

[16:54] <nwc10> Also, I think it's very hard to judge how practical a language it is, such as trade offs between desgined lack of expressiveness versus performance, until there's more than just bubblesort as an example

[16:55] <nwc10> the $1000 goal of the kickstarter is really what I'd love to see, to get a feel for it:

[16:55] <nwc10> https://www.kickstarter.com/projects/wbraswell/perl-5-optimizing-compiler-rperl-v10/description -- RPerl Application, Alioth Shootout Performance Benchmark, Released On Github Feb 01, 2014

[16:56] <nwc10> in terms of "what does coding in it look like?" and "how fast does it go?"

[16:57] <[Coke]> do they have an rperlbench or equiv?

[16:58] *** laouji joined
[16:58] <nwc10> I believe not. It would be cool if they did. Right now, I believe that most of the numbers stated are extrapolations and estimates, not measurements

[16:58] *** abraxxa left
[16:59] <nwc10> and the surrounding text is being a bit disingenuous by not mentioning this.

[16:59] <[Coke]> I am reminded to ask brrt how things are going! ;)

[17:02] *** Hor|zon joined
[17:03] *** rarara left
[17:05] <leont> What should I do to make ´sub foo(*@a) as Boolª work?

[17:06] <tony-o> what is your intention with as Bool

[17:06] <leont> I'm getting a ´Cannot call trait_mod:<as>(Sub, Bool); none of these signatures match: (Parameter:D $param, $type)ª

[17:06] <leont> I want to trigger a coercion to Bool, basically

[17:06] <leont> (of the return value)

[17:07] <tony-o> m: sub r (*@a) returns Bool { return True; }; r.say;

[17:07] <camelia> rakudo-moar 377672: OUTPUT¬´True‚ê§¬ª

[17:11] <DrForr> m: $x=3; ?^?^$x

[17:11] <camelia> rakudo-moar 377672: OUTPUT¬´5===SORRY!5=== Error while compiling /tmp/jqAb2aR8oj‚ê§Variable '$x' is not declared‚ê§at /tmp/jqAb2aR8oj:1‚ê§------> 3<BOL>7‚èè5$x=3; ?^?^$x‚ê§¬ª

[17:11] <DrForr> m: my $x=3; ?^?^$x

[17:11] <camelia> rakudo-moar 377672: ( no output )

[17:13] <tony-o> m: $x=3; say ?^?^$x

[17:13] <camelia> rakudo-moar 377672: OUTPUT¬´5===SORRY!5=== Error while compiling /tmp/vhENiCK78D‚ê§Variable '$x' is not declared‚ê§at /tmp/vhENiCK78D:1‚ê§------> 3<BOL>7‚èè5$x=3; say ?^?^$x‚ê§¬ª

[17:13] <tony-o> m: my $x=3; say ?^?^$x

[17:13] <camelia> rakudo-moar 377672: OUTPUT¬´True‚ê§¬ª

[17:16] *** pullphinger joined
[17:20] *** dakkar left
[17:22] *** gcole joined
[17:24] <lucasb> m: say -> $a,$b {}.perl

[17:24] <camelia> rakudo-moar 377672: OUTPUT¬´-> ($a, $b) { #`(Block|40320144) ... }‚ê§¬ª

[17:24] <lucasb> m: say -> ($a,$b) {}.perl

[17:24] <camelia> rakudo-moar 377672: OUTPUT¬´-> ($ ($a, $b)) { #`(Block|39674320) ... }‚ê§¬ª

[17:24] <lucasb> ^^ A tiny glitch when printing signatures for blocks. iiuc, Blocks and Subs share the same signature printing code. Unfortunately, the signature for blocks has different semantics in respect to ->$a,$b vs. ->($a,$b)

[17:24] <[Coke]> there is no mechanism to coerce an output. It's your function, you can cast it when you're done.

[17:24] <[Coke]> s/an output/a return/

[17:25] *** gcole left
[17:27] <[Coke]> if you have a complicated sub or method, you could probably do something clever with LEAVE

[17:27] <ugexe> you can even abstract that mechanism with a wrap or something

[17:27] <[Coke]> (so you don't need the cast in N places)

[17:31] *** telex left
[17:32] *** telex joined
[17:37] *** gcole joined
[17:38] *** larion_ joined
[17:38] *** larion joined
[17:45] <skids> m: say -> ($($a,$b)) {}.perl

[17:45] <camelia> rakudo-moar 377672: OUTPUT¬´5===SORRY!5=== Error while compiling /tmp/kI3TgNB2LJ‚ê§Shape declaration with () is reserved;‚ê§  please use whitespace if you meant a subsignature for unpacking,‚ê§  or use the :() form if you meant to add signature info to the function's type‚ê§at /t‚Ä¶¬ª

[17:46] <skids> m: say -> ($ ($a,$b)) {}.perl

[17:46] <camelia> rakudo-moar 377672: OUTPUT¬´-> ($ ($ ($a, $b))) { #`(Block|58221072) ... }‚ê§¬ª

[17:46] <skids> Yeah that'll need  to be fixed.

[17:47] <skids> I'll look into it when I do another round of cleanups for quirly corner cases I found while writing .assuming.

[17:48] <skids> *quirky.  Though I kindly like the sound of quirly.

[17:49] *** raiph left
[17:52] <[Coke]> like squirrely

[17:55] *** raiph joined
[17:57] <skids> IMO the biggest marketing fail of the early IT age was not getting people to pronounce SQL as "squirrel".

[17:57] <leont> Getting ´Can't use unknown trait 'is signature' in a method declaration.ª, though signature is documented in S06

[17:58] <leont> Is that NYI? Or have things changed?

[17:59] <[Coke]> assuming NYI - what are you trying to do?

[18:01] <leont> metaprogramming, really

[18:01] <leont> I have a bunch of methods, and for every method foo I want a second method not-foo with the same signature

[18:01] <skids> Hrm... actually if that were implemented and took a variable of type Signature rather than a literal, that might be one step towards an EVAL-less .assuming.

[18:02] *** FROGGS joined
[18:03] <tony-o> leont: us 'returns' instead of 'as'

[18:03] <[Coke]> tony-o: that doesn't coerce, it squawks.

[18:03] <tony-o> oops, typed that a while ago

[18:03] <skids> m: sub foo ($a, $b) { say "a$a b$b" }; my $bar = &foo.assuming(); bar(1,2); &bar.signature.say

[18:03] <camelia> rakudo-moar 377672: OUTPUT¬´5===SORRY!5=== Error while compiling /tmp/NHVhtPsmNf‚ê§Undeclared routines:‚ê§    &bar used at line 1. Did you mean '&bag'?‚ê§    bar used at line 1. Did you mean 'bag'?‚ê§‚ê§¬ª

[18:03] <skids> m: sub foo ($a, $b) { say "a$a b$b" }; my &bar = &foo.assuming(); bar(1,2); &bar.signature.say

[18:03] <camelia> rakudo-moar 377672: OUTPUT¬´a1 b2‚ê§($a, $b)‚ê§¬ª

[18:04] <skids> ^^ leont

[18:04] <[Coke]> m: sub a returns Str { 3 } ; a.WHAT.say

[18:04] <camelia> rakudo-moar 377672: OUTPUT¬´Type check failed for return value; expected 'Str' but got 'Int'‚ê§  in block <unit> at /tmp/XvQjqFGxNn:1‚ê§‚ê§¬ª

[18:04] *** cognominal left
[18:05] <skids> Though I guess it is harder with methods as you ave to install them with the MOP.

[18:05] *** laouji left
[18:07] <[Coke]> if you're dynamically installing methods, you could just use the MOP API and not the language sugar, aye?

[18:07] *** laouji joined
[18:07] <[Coke]> s/just//

[18:07] <skids> There's little MOP api in the way of creating signatures IIRC.

[18:08] * [Coke] doesn't find coercing types for argument sigs in S06

[18:09] <[Coke]> is there a get/set at least?

[18:09] <[Coke]> (if you just want something identical...)

[18:09] <leont> Now doing $package.HOW.add_method: $package, $name, method($arg) {...};

[18:09] <leont> I want to add that signature to that method

[18:10] <skids> [Coke] They are in S02.

[18:12] *** smls left
[18:13] *** Ven left
[18:24] *** uncleyear left
[18:24] *** uncleyear joined
[18:25] <skids> leont: what does the body of a not-foo look like?

[18:27] <andreoss> m: my $a = 1; say ($a.WHAT == Nil);

[18:27] <camelia> rakudo-moar 377672: OUTPUT¬´Use of uninitialized value of type Int in numeric context  in block <unit> at /tmp/2rijqmNHOx:1‚ê§Use of Nil in numeric context  in block <unit> at /tmp/2rijqmNHOx:1‚ê§True‚ê§¬ª

[18:27] <andreoss> m: my $a = 1; say ($a.WHAT == Int);

[18:27] <camelia> rakudo-moar 377672: OUTPUT¬´Invocant requires a 'Int' instance, but a type object was passed.  Did you forget a .new?‚ê§  in block <unit> at /tmp/LALPCM9_U_:1‚ê§‚ê§¬ª

[18:27] <leont> the normal one is ´method($arg) { self.bar($arg) }ª, the negative one is ´method($arg) { self.baz($arg) }ª, basically

[18:27] <andreoss> m: my $a = 1; say ($a.WHAT ~~ Int);

[18:27] <camelia> rakudo-moar 377672: OUTPUT¬´True‚ê§¬ª

[18:27] <skids> m: my $a = 1; say ($a.WHAT === Nil);

[18:27] <camelia> rakudo-moar 377672: OUTPUT¬´False‚ê§¬ª

[18:27] <skids> Also:

[18:27] <leont> ($arg being a sub itself, this is somewhat simplified))

[18:28] <skids> m: my $a = 1; say ($a.WHAT === Mu);

[18:28] <camelia> rakudo-moar 377672: OUTPUT¬´No appropriate parametric role variant available for 'Rational'‚ê§  in any specialize at src/gen/m-Metamodel.nqp:2471‚ê§  in any compose at src/gen/m-Metamodel.nqp:2781‚ê§  in any make_pun at src/gen/m-Metamodel.nqp:1642‚ê§  in any find_method at src/gen/m‚Ä¶¬ª

[18:28] <skids> m: my $a = 1; say ($a.WHICH === Mu.WHICH);

[18:28] <camelia> rakudo-moar 377672: OUTPUT¬´False‚ê§¬ª

[18:30] *** nowan left
[18:31] <skids> leont: well, in order to write the body you need stuff from the signature, so... adding a dynamic signature won't help there unless you include a capture of a known name.

[18:31] <andreoss> Cannot call factorize(967); none of these signatures match:

[18:31] <andreoss>     (Int $n)

[18:31] <andreoss>  

[18:31] <andreoss> why such thing could happen?

[18:31] <skids> m: factorize.^candidates.say

[18:31] <camelia> rakudo-moar 377672: OUTPUT¬´5===SORRY!5=== Error while compiling /tmp/TzjOqftnR0‚ê§Undeclared routine:‚ê§    factorize used at line 1‚ê§‚ê§¬ª

[18:33] <andreoss> http://paste.debian.net/280297/

[18:34] <itz_> andreoss: I think the Vim::TextColour issue was due to it not working under cron (which should now be fixed)

[18:35] *** raiph left
[18:36] <skids> andreoss: try factorize(Empty,967);  # this is why.  Add a | to your calls.

[18:40] <andreoss> itz_: the TERM variable?

[18:40] <skids> andreoss: Or, sorry, comprehension fail, anyway is it possible @primes is truning empty somehow...?

[18:41] <andreoss> Cannot call factorize(967); none of these signatures match:

[18:41] <andreoss>     (Empty, |z)

[18:41] <andreoss>  

[18:42] <itz_> andreoss: no not a missing environment variable but some more mysterious vim options discovered by actually RTFMing :)

[18:42] <skids> Really another spot where it needs to say waht you passed.

[18:42] * geekosaur would suspect isatty()...

[18:44] <skids> andreoss: I didn't mean to change factorize's signature.  I mean if you actually invoke factorize(Empty,967) you get the same error message.

[18:45] <andreoss> skids: yes, i was stupidly thinking about 2**8 as 8 digit number, 

[18:48] *** domidumont joined
[18:48] *** laouji left
[18:49] *** laouji joined
[18:52] *** nowan joined
[18:54] <leont> Is there a p6 equivalent of splitdir?

[18:54] *** laouji left
[18:55] <leont> IO::Path.parts is not as helpful as I had hoped

[18:58] *** bin_005 joined
[19:00] *** laouji joined
[19:06] <domidumont> [ptc]: now that moarvm in on Debian unstable, do you have some time to work on nqp package ?

[19:06] *** atroxaper joined
[19:09] <andreoss> m: sub x { loop { return 1 } }; say x();

[19:09] <camelia> rakudo-moar 377672: OUTPUT¬´1‚ê§¬ª

[19:09] *** beastd joined
[19:09] <andreoss> m: sub x { gather loop { return 1 } }; say x();

[19:09] <camelia> rakudo-moar 377672: OUTPUT¬´Attempt to return outside of any Routine‚ê§‚ê§¬ª

[19:09] <andreoss> why?

[19:11] <andreoss> m: say return 1

[19:11] <camelia> rakudo-moar 377672: ( no output )

[19:11] <vendethiel> andreoss: because the gather is lazy

[19:11] <andreoss> m: say { return 1 }

[19:11] <camelia> rakudo-moar 377672: OUTPUT¬´-> (;; $_? is parcel) { #`(Block|55643616) ... }‚ê§¬ª

[19:11] *** atroxaper left
[19:11] <vendethiel> m: sub x { @ = gather loop { return 1 } }; say x();

[19:11] <camelia> rakudo-moar 377672: OUTPUT¬´1‚ê§¬ª

[19:11] <vendethiel> (really, "@ =" could be any "strict" modificator; to avoid the laziness)

[19:11] *** rindolf left
[19:13] <andreoss> m: sub x { eager gather loop { return 1 } }; say x();

[19:13] <camelia> rakudo-moar 377672: OUTPUT¬´1‚ê§¬ª

[19:15] *** Alina-malina left
[19:15] *** beastd left
[19:19] *** anaeem1 joined
[19:19] *** Alina-malina joined
[19:20] <vendethiel> andreoss: basically, when you call the function, it returns the "Gather" construct itself, that did NOT iterate yet. then, when you print it, it starts iterating over it... only to find it's trying to return from outside a function

[19:20] <vendethiel> that might have a surprising behavior, though...

[19:21] <vendethiel> m: sub x { gather loop { return 1 } }; sub f { for ^3 { say x(); }}; f;

[19:21] <camelia> rakudo-moar 377672: OUTPUT¬´Attempt to return outside of any Routine‚ê§‚ê§¬ª

[19:21] <vendethiel> nah, it "correctly" crashes

[19:25] <vendethiel> (oh rather, errors)

[19:25] *** roguelazer joined
[19:25] *** beastd joined
[19:29] *** domidumont left
[19:41] *** laouji left
[19:43] *** lucasb left
[19:43] *** firefish5000 joined
[19:44] *** espadrine left
[19:44] <masak> good evening, #perl6

[19:44] <[Coke]> hio

[19:46] *** andreoss left
[19:48] <dalek> roast: 104d08f | usev6++ | S12-attributes/clone.t:

[19:48] <dalek> roast: Fudge test for RT #125577 on JVM

[19:48] <dalek> roast: review: https://github.com/perl6/roast/commit/104d08f784

[19:52] *** firefish5000 left
[19:59] *** spider-mario joined
[20:02] <hoelzro> anyone here use Inline::Perl5 (or any other modules that use a helper library) on Ubuntu?

[20:02] <hoelzro> I'm seeing a weird dynamic linker error with Xapian, and I see it in Inline::Perl5 too, but not on Arch Linux

[20:03] <hoelzro> Cannot locate native library '/tmp/8631-p5helper.so': /tmp/8631-p5helper.so: undefined symbol: boot_DynaLoader

[20:03] <hoelzro> I get a simliar error with my Xapian binding, even though libxapian is in the dependencies of my .so file

[20:05] *** Sqirrel_ joined
[20:05] *** Sqirrel left
[20:08] *** meisl joined
[20:11] *** eitz left
[20:15] *** colomon left
[20:15] *** Sqirrel_ left
[20:15] <nwc10> good UGT heresy, masak 

[20:18] *** TEttinger joined
[20:19] <masak> nwc10: when I rez in #perl6, no matter how I greet, it is always morning in my heart. :>

[20:20] <dalek> roast: 08b64b7 | usev6++ | S06-signature/arity.t:

[20:20] <dalek> roast: Add test for RT #78240

[20:20] <dalek> roast: review: https://github.com/perl6/roast/commit/08b64b732a

[20:20] <dalek> roast: 1c8e5ab | usev6++ | S06-signature/arity.t:

[20:20] <dalek> roast: Add test for RT #77744

[20:20] <dalek> roast: review: https://github.com/perl6/roast/commit/1c8e5abec0

[20:23] *** eitz joined
[20:29] *** yeltzooo joined
[20:30] *** eitz left
[20:33] *** colomon joined
[20:34] *** darutoko left
[20:42] *** laouji joined
[20:47] *** laouji left
[20:49] *** rurban left
[20:53] *** notjack left
[20:53] *** cognominal joined
[20:58] *** larion_ left
[20:58] *** larion left
[20:59] *** [particle] joined
[20:59] *** [particle]1 left
[21:00] *** kurahaupo joined
[21:03] *** FROGGS left
[21:03] *** [particle] left
[21:05] *** bin_005 left
[21:05] *** bin_005_w joined
[21:06] *** [particle] joined
[21:08] *** diana_olhovik_ left
[21:08] *** skids left
[21:10] *** larion_ joined
[21:10] *** larion joined
[21:16] *** colomon left
[21:22] *** notjack joined
[21:33] *** colomon joined
[21:35] *** larion_ left
[21:35] *** larion left
[21:43] *** notjack left
[21:46] *** beastd left
[21:48] *** kurahaupo left
[21:57] *** nowan left
[21:59] *** nowan joined
[22:01] *** nowan left
[22:02] *** espadrine joined
[22:04] *** nowan joined
[22:09] *** meisl left
[22:13] <RabidGravy> is there a more concis way of doing "for @a -> $b, $c { @b.push($b); @c.push($c); }" ?

[22:15] <masak> m: my @a = <OH HAI OH HAI>; my ($b, $c) = (@a.classify({ ++$ % 2 })).values; say $b; say $c

[22:15] <camelia> rakudo-moar 377672: OUTPUT¬´HAI HAI‚ê§OH OH‚ê§¬ª

[22:16] <masak> though that `.values` there could be refined a bit, since you'd essentially be getting something unordered.

[22:16] <masak> better to sort by key first, and then extracting the values.

[22:19] <RabidGravy> this is "de-interleaving" pcm frames I don't changing the order in any way will work ;-)

[22:19] *** sjn_phone left
[22:19] <TimToady> m: my ($a,$b); ($++ %% 2 ?? $a !! $b).push: $_ for <OH HAI OH HAI>; say $a, $b

[22:19] <camelia> rakudo-moar 377672: OUTPUT¬´OH OHHAI HAI‚ê§¬ª

[22:20] *** bin_005_w left
[22:20] <RabidGravy> ha ha brilliant

[22:22] *** pullphinger left
[22:25] *** cognominal left
[22:26] <TimToady> m: my ($a,$b); flat(($a,$b) xx *) Z[[&push]] <OH HAI OH HAI>; say $a, $b

[22:26] <camelia> rakudo-moar 377672: OUTPUT¬´OH OHHAI HAI‚ê§¬ª

[22:26] <masak> "we just zip this infinite list..."

[22:27] <masak> 'night, #perl6

[22:42] *** atroxaper joined
[22:43] *** ab6tract joined
[22:43] *** skids joined
[22:46] *** virtualsue left
[22:46] *** spider-mario left
[22:46] *** atroxaper left
[22:49] <ab6tract> m: my $d = Date.new(:year(1999)); say $d.succ # if Range uses succ for Date.new(:year(1999))^..Date.new(:year(2015)), then ^ has a not-quite-DWIMing feel to it

[22:49] <camelia> rakudo-moar 377672: OUTPUT¬´1999-01-02‚ê§¬ª

[22:50] *** kurahaupo joined
[22:50] *** laouji joined
[22:50] <ab6tract> I did not expect Date.new(:year(1999)) to become "1 January 1999"

[22:54] *** espadrine left
[22:54] *** laouji left
[22:55] *** RabidGravy left
[23:01] <leont> What did you expect?

[23:04] <TimToady> that feels a bit like expecting the successor of 1i to be 2i

[23:05] *** kaare_ left
[23:05] *** kaare_ joined
[23:10] *** tinyblak joined
[23:11] *** kaare_ left
[23:13] <ab6tract> TimToady: it's a fair point. But I'd argue that there is real value in having Date objects which can represent just a year, or just a year month.

[23:18] <ab6tract> leont: I would expect Date.new(:year(1999)) to just be '1999' . 'yyyy' and 'yyyy-mm' are also pretty common date-y things

[23:19] <leont> Would you want a different class for every level of precision? Or fat classes that are half useless half of the time?

[23:19] <lizmat> maybe Year and Month should be roles?

[23:20] <ab6tract> I don't think adding a few defined-ness checks would fatten things up too much, but I haven't looked too deeply at the Date code

[23:21] <ab6tract> But obviously a 'third way' would be ideal her

[23:21] <ab6tract> *here

[23:21] <ab6tract> because neither of your options sound very appetizing leont :)

[23:22] <TimToady> well, if something has different opertions, it's a different type, to me

[23:22] <TimToady> *rat

[23:22] <leont> lizmat: Months are truly horrible, and years are mostly just integers (except there's no year 0)

[23:22] <ab6tract> lizmat: that sounds intriguing.

[23:23] <TimToady> leont: sure there's a year 0, the idiots just call it 1 BC

[23:23] <timotimo> wait, so it goes from 1 AD to 1 BC?

[23:23] <leont> Yes

[23:24] <timotimo> i don't even know what to say about that

[23:24] <leont> I love Postgress' documentation on this: The first century starts at 0001-01-01 00:00:00 AD, although they did not know it at the time. This definition applies to all Gregorian calendar countries. There is no century number 0, you go from -1 century to 1 century. If you disagree with this, please write your complaint to: Pope, Cathedral Saint-Peter of Roma, Vatican.

[23:24] <TimToady> and -1 is 2 BC :)

[23:25] <ab6tract> leont: I'm not sure all calendars use integers, but even if so, that doesn't obviate the fact that I am operating on Years, not Ints

[23:25] <timotimo> that's as unnerving to me as the way AM and PM change over the course of the day

[23:26] <TimToady> and we should rewrite all our textbooks such that year div 100 is the century, so we're current in the 20th century

[23:26] <leont> What part of that problem isn't solved by ´subset Year of Intª?

[23:26] <TimToady> *currently

[23:27] <ab6tract> in my opinion, I should be able to have an array where .grep( * ~~ Date ) and have years and year months in there 

[23:27] <TimToady> leont: doesn't complain if you pass it to a Month parameter?

[23:27] <ab6tract> or s/Date/Dately/, I don't mind

[23:27] <TimToady> I think approximate dates should be a different type than exact dates

[23:28] <leont> Yeah

[23:28] <ab6tract> TimToady: that sounds perfectly fine to me

[23:28] <ab6tract> hence the "Dately" bit

[23:28] <TimToady> maybe you're just looking for DateInterval

[23:28] <ab6tract> because I want to keep my DateTimes too

[23:29] <TimToady> or InstantInterval, once we extend atomic time back to the beginning of time

[23:30] <ab6tract> TimToady: is DateInterval a thing already?

[23:31] <TimToady> .oO("Historians concluded today that there was a leap-second in 1066, and that is what brought on the Norman victory")

[23:31] <lizmat> sleep&

[23:33] <ab6tract> I don't see any references in the code. but I do see that Dateish is already a thing.

[23:34] <ab6tract> TimToady: if you elaborate more on what you mean, I might just end up implementing it

[23:36] *** khw left
[23:45] <ab6tract> btw, leont, poking around in Range does make me less inclined for a fat class solution to anything

[23:45] <ab6tract> though in that case I think its probably worth it

[23:47] <timotimo> i'd like to know p6ers opinions on Groovy

[23:49] <ab6tract> so sleep and +@see-you-later.grep( Dateish )

[23:53] *** ab6tract left
[23:58] *** vendethiel left
