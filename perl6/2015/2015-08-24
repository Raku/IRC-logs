[00:01] *** lichtkind left
[00:18] *** llfourn joined
[00:23] *** llfourn left
[00:27] *** raiph left
[00:27] *** cognominal joined
[00:28] *** laouji joined
[00:29] *** aborazmeh joined
[00:29] *** aborazmeh left
[00:29] *** aborazmeh joined
[00:39] *** laouji left
[00:40] *** laouji joined
[00:44] *** laouji left
[00:45] *** laouji joined
[00:54] *** yqt left
[01:19] *** AlexDaniel left
[01:22] *** vendethiel joined
[01:51] *** kaare_ joined
[02:20] *** llfourn joined
[02:22] *** noganex joined
[02:24] *** llfourn left
[02:24] *** noganex_ left
[02:32] *** llfourn joined
[02:34] <skids> m: my @a = 1,2; my \b = [3,4].flat; $b.WHAT.say; @a.push(b); my $c = [5,6].flat; @a.push($c); @a».say

[02:34] <GLRelia> rakudo-moar ef6669: OUTPUT«5===SORRY!5=== Error while compiling /tmp/RlI9M7VrGM␤Variable '$b' is not declared␤at /tmp/RlI9M7VrGM:1␤------> 3my @a = 1,2; my \b = [3,4].flat; 7⏏5$b.WHAT.say; @a.push(b); my $c = [5,6].f␤»

[02:34] <camelia> rakudo-moar d6bf55: OUTPUT«5===SORRY!5=== Error while compiling /tmp/_UTFYAxDwj␤Variable '$b' is not declared␤at /tmp/_UTFYAxDwj:1␤------> 3my @a = 1,2; my \b = [3,4].flat; 7⏏5$b.WHAT.say; @a.push(b); my $c = [5,6].f␤»

[02:35] <skids> m: my @a = 1,2; my \b = [3,4].flat; b.WHAT.say; @a.push(b); my $c = [5,6].flat; @a.push($c); @a».say

[02:35] <GLRelia> rakudo-moar ef6669: OUTPUT«(Seq)␤1␤2␤3␤4␤5 6␤»

[02:35] <camelia> rakudo-moar d6bf55: OUTPUT«(Array)␤6␤5␤3␤1␤4␤2␤»

[02:38] <skids> I guess if we are OK with having to use binding to pass Seqs around we can have $ protect against the single-arg-rule.

[02:39] *** vendethiel left
[02:39] <skids> And that seems to be how some of the first things that were implemented got done.

[02:56] <skids> But the implementation doesn't cleanly map to MMD without a way to distinguish between Scalar containers and values.

[03:04] *** Timbus left
[03:18] *** lizmat joined
[03:18] * lizmat waves from HND

[03:20] *** gagalicious left
[03:26] *** cognominal left
[03:39] *** aborazmeh left
[03:44] *** BenGoldberg left
[03:50] *** jack_rabbit joined
[03:51] *** prevost joined
[03:55] <dalek> rakudo/glr: 25a9f87 | lizmat++ | src/core/Supply.pm:

[03:55] <dalek> rakudo/glr: Get rid of one .infinite

[03:55] <dalek> rakudo/glr: 

[03:55] <dalek> rakudo/glr: Doesn't fix Supply.rotor just yet, because xx * still seems broke

[03:55] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/25a9f87503

[04:00] *** ChoHag joined
[04:00] *** Timbus joined
[04:01] <ChoHag> Why can I say my $foo = (Bar but Baz).new, but can't say my (Bar but Baz) $foo .= new?

[04:05] *** mdinger joined
[04:05] *** cognominal joined
[04:06] <lizmat> because the latter is a constraint

[04:06] <lizmat> and we don't do constraints like that (yet) ?

[04:06] *** Timbus left
[04:06] <lizmat> m: sub a($a) { .say for $a }; a( Range.new(1,4) )  # the reason Supply.minmax doesn't work

[04:06] <GLRelia> rakudo-moar 25a9f8: OUTPUT«1␤2␤3␤4␤»

[04:06] <camelia> rakudo-moar d6bf55: OUTPUT«1..4␤»

[04:07] <lizmat> m: sub a($a) { .say for $a }; a( $(Range.new(1,4)) )

[04:07] <GLRelia> rakudo-moar 25a9f8: OUTPUT«1␤2␤3␤4␤»

[04:07] <camelia> rakudo-moar d6bf55: OUTPUT«1..4␤»

[04:07] <lizmat> m: sub a($a) { .say for $a }; a( (Range.new(1,4), )

[04:07] <GLRelia> rakudo-moar 25a9f8: OUTPUT«5===SORRY!5=== Error while compiling /tmp/CW7bohr0ZT␤Unable to parse expression in argument list; couldn't find final ')' ␤at /tmp/CW7bohr0ZT:1␤------> 3) { .say for $a }; a( (Range.new(1,4), )7⏏5<EOL>␤»

[04:07] <camelia> rakudo-moar d6bf55: OUTPUT«5===SORRY!5=== Error while compiling /tmp/7NgOvuMLMm␤Unable to parse expression in argument list; couldn't find final ')' ␤at /tmp/7NgOvuMLMm:1␤------> 3) { .say for $a }; a( (Range.new(1,4), )7⏏5<EOL>␤»

[04:07] <lizmat> m: sub a($a) { .say for $a }; a( (Range.new(1,4),().slip )

[04:07] <GLRelia> rakudo-moar 25a9f8: OUTPUT«5===SORRY!5=== Error while compiling /tmp/tI5tCIOlXl␤Unable to parse expression in argument list; couldn't find final ')' ␤at /tmp/tI5tCIOlXl:1␤------> 3y for $a }; a( (Range.new(1,4),().slip )7⏏5<EOL>␤»

[04:07] <camelia> rakudo-moar d6bf55: OUTPUT«5===SORRY!5=== Error while compiling /tmp/4V2hcxPTht␤Unable to parse expression in argument list; couldn't find final ')' ␤at /tmp/4V2hcxPTht:1␤------> 3y for $a }; a( (Range.new(1,4),().slip )7⏏5<EOL>␤»

[04:07] <lizmat> m: sub a($a) { .say for $a }; a( (Range.new(1,4),().Slip )

[04:07] <GLRelia> rakudo-moar 25a9f8: OUTPUT«5===SORRY!5=== Error while compiling /tmp/WIxc25lr2M␤Unable to parse expression in argument list; couldn't find final ')' ␤at /tmp/WIxc25lr2M:1␤------> 3y for $a }; a( (Range.new(1,4),().Slip )7⏏5<EOL>␤»

[04:07] <camelia> rakudo-moar d6bf55: OUTPUT«5===SORRY!5=== Error while compiling /tmp/KmkxM78aWK␤Unable to parse expression in argument list; couldn't find final ')' ␤at /tmp/KmkxM78aWK:1␤------> 3y for $a }; a( (Range.new(1,4),().Slip )7⏏5<EOL>␤»

[04:07] *** Timbus joined
[04:07] <ChoHag> I see.

[04:08] <lizmat> m: sub a($a) { .say for $a }; a( Range.new(1,4),().Slip )

[04:08] <GLRelia> rakudo-moar 25a9f8: OUTPUT«Too many positionals passed; expected 1 argument but got 2␤  in sub a at /tmp/ZSE_o2Nt3R:1␤  in block <unit> at /tmp/ZSE_o2Nt3R:1␤␤»

[04:08] <camelia> rakudo-moar d6bf55: OUTPUT«Method 'Slip' not found for invocant of class 'Parcel'␤  in block <unit> at /tmp/4TCfr7jop8:1␤␤»

[04:08] <lizmat> m: sub a($a) { .say for $a }; a( [Range.new(1,4)] )

[04:08] <GLRelia> rakudo-moar 25a9f8: OUTPUT«1␤2␤3␤4␤»

[04:08] <camelia> rakudo-moar d6bf55: OUTPUT«1 2 3 4␤»

[04:10] <lizmat> I'm not sure the problem is with Supply.emit (having a \msg sig) or with minmax specifically

[04:24] <lizmat> .tell jnthn would be interested to know how you see Supply.emit being fixed so that it can take a single Range.new and *not* iterate over it

[04:24] <yoleaux> lizmat: I'll pass your message to jnthn.

[04:25] <lizmat> .tell jnthn *and* keep the \msg signature for so that we emit to the supply whatever is passed to the method verbatim

[04:25] <yoleaux> lizmat: I'll pass your message to jnthn.

[04:28] *** laouji left
[04:29] *** prevost left
[04:30] <ShimmerFairy> ChoHag: my first guess is that since (Bar but Baz) is a run-time mixin, having a type constraint of a run-time nature probably isn't a good idea :)

[04:31] <ChoHag> Other than prefixing the Signature with ::?CLASS:D:, how can you specify that a method is only to be called on an instance, not a type (and vice versa)?

[04:33] <ShimmerFairy> The :D smiley only allows instances, and the :U smiley only allows type objects (:_ allows either, and in most places is the default smiley)

[04:34] <ShimmerFairy> I don't think there's another way beyond :D/:U , as far as I know.

[04:35] <ChoHag> Yeah but emacs thinks ::? opens a quote so my syntax highlighting and autoindentation gets screwy.

[04:35] *** khw left
[04:36] <ShimmerFairy> ChoHag: oh, you can use the class name in place of ::?CLASS

[04:36] <ChoHag> Also it seemed like the kind of thing there'd be a syntax for.

[04:36] <ShimmerFairy> m: class Foo { method bar(Foo:D: $a) { say $a } }; Foo.new.bar(42)

[04:36] <GLRelia> rakudo-moar 25a9f8: OUTPUT«42␤»

[04:36] <camelia> rakudo-moar d6bf55: OUTPUT«42␤»

[04:36] <ShimmerFairy> m: class Foo { method bar(Foo:D: $a) { say $a } }; Foo.bar(42)

[04:36] <camelia> rakudo-moar d6bf55: OUTPUT«Invocant requires an instance of type Foo, but a type object was passed.  Did you forget a .new?␤  in method bar at /tmp/lY6ujXIhT0:1␤  in block <unit> at /tmp/lY6ujXIhT0:1␤␤»

[04:36] <GLRelia> rakudo-moar 25a9f8: OUTPUT«Invocant requires an instance of type Foo, but a type object was passed.  Did you forget a .new?␤  in method bar at /tmp/aosug2ixyb:1␤  in block <unit> at /tmp/aosug2ixyb:1␤␤»

[04:37] <ChoHag> Oh I know, but then there'd be repetition of information, and that's much worse than funny colours.

[04:38] *** gagalicious joined
[04:39] <zacts> so I've heard rumors that a first actual stable release of perl6 may happen this year?

[04:39] <zacts> and would that be the specification, or would it be the rakudo implementation of it, or both?

[04:40] <lizmat> both

[04:40] <ChoHag> Yeah but then they decided to reimplement some core features, as developers are wont to do.

[04:40] <lizmat> ETA Christmas 2015

[04:40] <zacts> nice nice

[04:40] <zacts> so perhaps I could contribute by learning perl6, and porting and writing modules

[04:40] <lizmat> zacts: that would be an excellent plan!

[04:41] <ChoHag> Christmas here happens in January, so you missed that boat.

[04:41] <ChoHag> Or looking at it the other way, you get an extra 2 weeks (Jan 7th).

[04:41] <lizmat> zacts: http://doc.perl6.org  # documentation, a work in progress

[04:42] <lizmat> boarding&

[04:42] *** lizmat left
[04:42] <ChoHag> zacts: TBD it does look from the sidelines that this year is possible.

[04:42] <ChoHag> TBH

[04:43] <ChoHag> But on the other hand, I've worked on a lot of projects of various types and I don't think one has ever met any date it scheduled.

[04:44] <ChoHag> On the gripping hand, porting wouldn't hurt.

[04:45] *** aborazmeh joined
[04:45] *** aborazmeh left
[04:45] *** aborazmeh joined
[04:46] <ShimmerFairy> Honestly, it surprised me when Larry announced specific dates for a rakudo release candidate in Sept., and the first stable release of Perl 6 + rakudo on Christmas. In some ways it's still surreal for me that there will be a point where 6.0.0 is declared "complete", and soon-ish :)

[04:57] *** [Sno] left
[05:03] *** laouji joined
[05:26] *** ggoebel left
[05:27] *** ggoebel joined
[05:27] *** ggoebel left
[05:48] <moritz> good morning

[05:49] <moritz> m: my $x = [1, 2, 3]; .say for $x

[05:49] <GLRelia> rakudo-moar 25a9f8: OUTPUT«1␤2␤3␤»

[05:49] <camelia> rakudo-moar d6bf55: OUTPUT«1 2 3␤»

[05:49] <moritz> m: my $x = [1, 2, 3]; .say for $x, 

[05:49] <GLRelia> rakudo-moar 25a9f8: OUTPUT«1 2 3␤»

[05:49] <camelia> rakudo-moar d6bf55: OUTPUT«1 2 3␤»

[05:55] *** skids left
[06:05] *** darutoko joined
[06:08] <dalek> rakudo/glr: 133b570 | (Stefan Seifert)++ | src/core/Range.pm:

[06:08] <dalek> rakudo/glr: Fix generic Range iterator assuming numeric semantics

[06:08] <dalek> rakudo/glr: 

[06:08] <dalek> rakudo/glr: Thanks to b2gills++ for spotting this!

[06:08] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/133b570b9a

[06:22] *** plicease joined
[06:23] *** telex left
[06:24] *** telex joined
[06:34] *** xfix joined
[06:34] *** Woodi left
[06:35] *** Woodi joined
[06:43] *** aborazmeh left
[06:43] *** rurban joined
[06:46] *** RabidGravy joined
[06:46] *** [Sno] joined
[06:48] *** cognominal left
[06:48] *** zakharyas joined
[06:54] *** rurban left
[06:55] <moritz> m: my @a = do for ^4 { 5 }; say @a[0]; say @a[1]

[06:55] <GLRelia> rakudo-moar 133b57: OUTPUT«5␤5␤»

[06:55] <camelia> rakudo-moar d6bf55: OUTPUT«5␤5␤»

[06:56] <moritz> m: my @a = do for ^4 { start { 5 } }; await @a; say @a[0].result; say @a[1].result

[06:56] <GLRelia> rakudo-moar 133b57: OUTPUT«5␤5␤»

[06:56] <camelia> rakudo-moar d6bf55: OUTPUT«5␤5␤»

[07:00] *** cognominal joined
[07:01] <masak> morning, #perl6

[07:01] <moritz> m: for lines() { say $*IN.ins }

[07:01] <camelia> rakudo-moar d6bf55: OUTPUT«1␤2␤3␤4␤5␤6␤7␤8␤9␤10␤11␤12␤13␤14␤15␤16␤17␤18␤19␤20␤»

[07:01] <GLRelia> rakudo-moar 133b57: OUTPUT«(timeout)»

[07:02] *** Ven joined
[07:07] <masak> by the way, now that we have labels, should there be a `LINE:` label on the -n and -p loops?

[07:08] *** domidumont joined
[07:12] *** domidumont left
[07:12] <masak> (in analogy with Perl 5, see `perldoc perlrun`)

[07:13] *** domidumont joined
[07:13] *** salv0 joined
[07:14] <FROGGS> masak: seems easily doable

[07:14] <FROGGS> morning #perl6

[07:21] *** mdinger left
[07:22] *** abraxxa joined
[07:25] <nine> Ven: regarding $i++ for (1, 2, 3).item; the expected answer for say $i is indeed 3.

[07:25] *** jack_rabbit left
[07:27] <Ven> nine: okay. I'll fix the test in that file then

[07:30] *** laben joined
[07:30] <nine> Ven: the rules are actually quite simple now: we iterate over the thingy we got passed. for $whatever { ... } will iterate over $whatever, regardless of how that thing looks, i.e. $whatever.elems iterations. for $foo, $bar { ... } will iterate over the list ($foo, $bar), i.e. two iterations.

[07:30] <laben> hello p6'ers

[07:31] <Ven> nine: seems I was getting it with http://irclog.perlgeek.de/perl6/2015-08-23#i_11103320 then. thanks

[07:32] <nine> If you really mean it, you can use for (@whatever,) { ... } to have only one iteration. Whyever you would want to do that...

[07:34] <nine> Ven: yes, indeed! And it doesn't only litterally mean .map. It _is_ map. It gets compiled to a .map call.

[07:34] <laben> nine: i think i got a working binary hyper impl that doesnt consume twice, need to test it, got some test files other than s03-metaops/hypers ?

[07:34] <ShimmerFairy> nine: I think it would also be helpful to spread the idea that  for (@whatever,) { ... }  is best spelled  given @whatever { ... }  :)

[07:35] <nine> laben: not that I'm aware of. I would love to have a look at your implementation, since I already started working on one myself.

[07:36] *** amurf left
[07:37] <laben> nine: i think i got an off by one error in here, wont be easy to spot. it's only missing the Whatever lengthening and a good round of debugging

[07:37] <nine> Can you push it somewhere?

[07:38] <ShimmerFairy> (what I mean by that is: if you insist on 'for' treating the item as one item, then you should either use 'given' to assign it to $_ like you were hoping, or assign the item to a variable yourself)

[07:38] <laben> m: dd (1,) <<~<< <A B C D>

[07:38] <GLRelia> rakudo-moar 133b57: OUTPUT«("1A", "1B", "1C", "1D")␤»

[07:38] <camelia> rakudo-moar d6bf55: OUTPUT«("1A", "1B", "1C", "1D")␤»

[07:38] <laben> dd (1,)

[07:38] <laben> m: dd (1,)

[07:38] <GLRelia> rakudo-moar 133b57: OUTPUT«(1)␤»

[07:38] <camelia> rakudo-moar d6bf55: OUTPUT«(1,)␤»

[07:38] <nine> ShimmerFairy: absolutely! That's why I can really live well with forcing the user to write (@a,). Because for is probably just the wrong tool.

[07:39] <laben> nine: should i publish a branch on github?

[07:39] <nine> laben: please

[07:40] <JimmyZ> m: for [1,2], {}

[07:40] <GLRelia> rakudo-moar 133b57: OUTPUT«5===SORRY!5===␤Expression needs parens to avoid gobbling block␤at /tmp/oNUtWgt9WV:1␤------> 3for [1,2], {}7⏏5<EOL>␤Missing block (apparently taken by expression)␤at /tmp/oNUtWgt9WV:1␤------> 3for [1,2], {}7⏏5<EOL>␤␤»

[07:40] <camelia> rakudo-moar d6bf55: OUTPUT«5===SORRY!5===␤Expression needs parens to avoid gobbling block␤at /tmp/G01wItrncD:1␤------> 3for [1,2], {}7⏏5<EOL>␤Missing block (apparently taken by expression)␤at /tmp/G01wItrncD:1␤------> 3for [1,2], {}7⏏5<EOL>␤␤»

[07:40] <ShimmerFairy> nine: does P5 tend to leave people with the idea that C<for> can automagically assign to $_ for single items? If so, the "use given instead" suggestion might be especially helpful in a 5-to-6 context. :)

[07:40] <laben> nine: need some time as i unwittingly did a git pull meanwhile

[07:41] <nine> ShimmerFairy: yes, it is sometimes indeed used for that purpose.

[07:41] <nine> laben: or just gist the code

[07:41] *** brrt joined
[07:44] <laben> nine: https://gist.github.com/laben/fdfe48a4c14ddb26e060

[07:45] <laben> nine: i think my bug is that i incremented $dwim-count with ++ instead of the safe way "$dwim-count = ($dwim-count + 1) % $elems;" written later there

[07:47] *** salv0 left
[07:47] *** salv0 joined
[07:49] *** rurban joined
[07:49] <nine> laben: I think the whole implementation could be simplified a lot by writing a special anonymous iterator class that knows how to generate more values if needed after exhaustion

[07:51] <nine> so you only need one loop in the function and it's just an until $left-ended and $right-ended {...}

[07:51] <laben> nine: well, i dunno how to do that XP, you can do the honors unless you want to concentrate on reducing test files failures

[07:51] <nine> would also get rid of a lot of the duplication

[07:52] *** salv0 is now known as salva00

[07:52] <laben> also btw i dont think there's a single test for the Whatever-lengthening stuff

[07:53] *** salva00 is now known as salva0

[07:54] <laben> i dont think you can do without the =:= IterationEnd check, else how do you know a side has ended?

[07:54] *** salv0 joined
[07:55] *** salva0 left
[07:55] <laben> maybe you can use the special iterator for the second loop

[07:57] *** salv0 left
[07:58] *** salva joined
[08:01] *** rurban left
[08:04] *** brrt left
[08:07] *** dakkar joined
[08:15] <nine> laben: incomplete and not even compile-tested, but it should illustrate what I'm imagining: https://gist.github.com/niner/b8d88fca93b77ead569f

[08:17] *** brrt joined
[08:17] *** cognominal left
[08:18] <laben> nine: i dont see any checking of correct dwimmyness combined with side lengths. where will you put it, inside the class?

[08:21] *** virtualsue joined
[08:22] *** diana_olhovik_ joined
[08:26] *** espadrine joined
[08:29] *** KCL_ joined
[08:32] *** KCL left
[08:33] *** dwarring left
[08:37] * masak enjoyed http://varlogrant.blogspot.se/2015/08/i-am-unlikely-to-move-to-perl6.html

[08:38] <masak> I think realistically, that's an attitude that Perl 6 will meet a lot in the next few years.

[08:38] <nine> laben: most probably. Those checks are what I haven't figured out yet. But I only thought about this code structure while on my bicycle, so I didn't have the current implementation at hand ;)

[08:38] *** yeahnoob joined
[08:38] *** froot joined
[08:38] <froot> Hello

[08:39] *** froot is now known as Guest46196

[08:39] <JimmyZ> hi

[08:39] <Guest46196> I am new with perl on debian

[08:39] <Guest46196> Perl 6

[08:39] <Ven> masak: yes, but the "good" part is that it isn't related to perl6 itself. just loving your current platform and wanting to stick with it

[08:40] <Guest46196> I wont to install perl 6 but have a question?

[08:42] <Guest46196> i install the build-essentials and git but after that must i be root user to install perl6 "http://rakudo.org/how-to-get-rakudo/" ?

[08:43] <laben> masak: after all this time, that's the major argument i hear for C->C++, C++->D, Python2->Python3 etc. i dont think there was an explicit need to reiterate it

[08:44] <JimmyZ> Guest46196: you don't need, Did you try rakudobrew?

[08:44] <JimmyZ> Guest46196: or the Manual installation step

[08:45] <Guest46196> ok that mean that i can install rakudobrew without root.   "http://rakudo.org/how-to-get-rakudo/" ...........To install rakudobrew on Linux:

[08:46] *** diana_olhovik__ joined
[08:47] <Guest46196> I will try manual. 

[08:47] *** diana_olhovik_ left
[08:51] <Guest46196> I am trying the rakudobrew more flexible.

[08:53] <masak> Guest46196: don't have to be root. if you don't specify anything else, rakudo will be installed into an install/ subdirectory in your rakudo directory.

[08:54] *** araujo joined
[08:55] *** Ven left
[08:55] <Guest46196> Ad the moment i see a lot off compilling flying arrounf my screen.

[08:58] <dalek> rakudo/nom: 0523c85 | labster++ | src/core/Temporal.pm:

[08:58] <dalek> rakudo/nom: fix RT#125682 and RT#125686 Date and DateTime overflows

[08:58] <dalek> rakudo/nom: 

[08:58] <dalek> rakudo/nom: reverts a portion of 5dbca1f5, adding what is now 15% time

[08:58] <dalek> rakudo/nom: to the aforementioned masak example (but a full revert would be 30% longer)

[08:58] <synbot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=125682

[08:58] <dalek> rakudo/nom: Preserved int math where I could.

[08:58] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/0523c857f9

[08:58] <dalek> rakudo/nom: b56d593 | labster++ | src/core/Temporal.pm:

[08:58] <dalek> rakudo/nom: fix RT#125872 date formatting bugs

[08:58] <synbot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=125872

[08:58] <dalek> rakudo/nom: 

[08:58] <dalek> rakudo/nom: RFC 3339: Lowercase t and z now allowed on input to DateTime,

[08:58] <dalek> rakudo/nom: ISO 8601: Output now prints 4 digit date with year outside 0..9999

[08:58] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/b56d5938f7

[08:59] <ShimmerFairy> masak: I've admittedly only skimmed that article (since I don't have the mental resources to give a putdown of P6 a deep read :P), but my takeaway of that article's opinion is "Perl 5 made me money, Perl 6 made people laugh at me(?), and I like typing a bunch of use statements for stuff that comes with the distro. Thus, I haven't even touched P6"

[09:01] <|Tux|> test             50000    42.131    42.041

[09:01] <|Tux|> test-t           50000    41.038    40.948

[09:02] *** laouji left
[09:02] *** rindolf joined
[09:03] *** laouji joined
[09:03] <ShimmerFairy> labster: is there a reason you undid the native types in Temporal? Unless $daycount is an epoch and there's a likely chance of int being 32-bit, I can't imagine why bigints would be necessary there.

[09:03] <ShimmerFairy> s/an epoch/the UNIX epoch/

[09:04] <labster> ShimmerFairy: I did it to close a couple of bugs.  We can either declare "hey, we don't want to deal with any dates above size x", or we can use the Int type.

[09:05] <jdv79> .tell FROGGS http://irclog.perlgeek.de/perl6/2015-08-23#i_11103936 ?

[09:05] <yoleaux> jdv79: I'll pass your message to FROGGS.

[09:06] <ShimmerFairy> labster: ok, fair enough :)  I will say though, that #125682 seems to be a case of GIGO, as it's presented; a more realistic example than adding an absurd number of seconds would be more convincing

[09:07] <labster> those are days, not seconds, but yeah, I hear you.

[09:07] <ShimmerFairy> oh right, they are Date objects, dur :P

[09:08] <Guest46196> Thank you Jimmyz and the community for your service and kind advice in install perl6.

[09:09] *** arnsholt joined
[09:09] *** rindolf left
[09:10] <jdv79> at least that article wasn't overtly negative or aggressive iirc - i read it a while ago

[09:12] <ShimmerFairy> jdv79: I don't think so either, it's just that an article all about why someone won't even give Perl 6 a chance isn't very useful to me, or many others here :)

[09:12] <synbot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=125682

[09:12] <jdv79> sure.  but its nice that's its largely benign.

[09:13] <ShimmerFairy> Of course. I'm glad that it's a reasonable explanation of why this one guy isn't particularly interested :)

[09:13] *** simcop2387 left
[09:13] <labster> ShimmerFairy: I tested a case where we'd use all native ints on the reasonable-sized cases, and Int outside it, but that seemed to be even slower.  If you have a better suggestion -- maybe limits to year size, I wouldn't mind hearing them.

[09:14] <ShimmerFairy> labster: I can take a look at it later, I just didn't see why the native ints were replaced at first :)

[09:14] <labster> What I got from the article was "I fell in love with Perl 5, and Perl 6 doesn't touch my feels in teh same way".

[09:14] <jdv79> i kinda saw it as:  http://www.quickmeme.com/img/dc/dc2fd6da2c741a3b2f6ae5fcf700e06fafe43267ea271579118ef4292ffb25c6.jpg

[09:15] <laben> nine: i fixed my impl, the problem was exactly what i thought. now it passes the same tests as the existing impl. there's only one other problem: when returning, it attempts to recreate the type it originally got. In case of Seq, what do we return?

[09:17] *** simcop2387 joined
[09:22] <nine> laben: in deepmap I resorted to List for that reason

[09:24] <nine> laben: would you say it makes sense to pursue my implementation further? Since your's passes all tests and fixes things, I'd say we merge your's now in any case.

[09:25] *** amurf joined
[09:26] *** rindolf joined
[09:27] <laben> nine: there's no hurry as it does not passes more tests than the existing one and i like your idea more, but i think it would be easier for you if you use the DwimIterator only for the second part, so that you can do the checks as in my impl

[09:28] <nine> Getting rid of separate parts is most of the charm of my idea :)

[09:28] <laben> nine: ofc if you prefer to progress on other glr matters, i'll continue to work on this and try to fix bugs and implement the Whatever stuff

[09:28] * jnthn wonders what on earth DwimIterator is :)

[09:28] <yoleaux> 04:24Z <lizmat> jnthn: would be interested to know how you see Supply.emit being fixed so that it can take a single Range.new and *not* iterate over it

[09:28] <yoleaux> 04:25Z <lizmat> jnthn: *and* keep the \msg signature for so that we emit to the supply whatever is passed to the method verbatim

[09:29] <nine> jnthn: it's about: 10:15 < nine> laben: incomplete and not even compile-tested, but it should illustrate what I'm imagining: https://gist.github.com/niner/b8d88fca93b77ead569f

[09:30] *** amurf left
[09:30] <timotimo> oh hey jnthn :)

[09:30] <jnthn> .tell lizmat I'd be tempted ot say that emit NEVER tries to iterate anything and just emits what it's given verbatim :)

[09:30] <yoleaux> jnthn: I'll pass your message to lizmat.

[09:30] <nine> Right now it makes Stage optimize gobble up all my RAM however :)

[09:30] <timotimo> did your flight go well?

[09:30] <jnthn> timotimo: Well, in so far as "all on time", yes, but I was heavily sleep deprived before it all so felt awful the whole way :(

[09:30] <timotimo> :(

[09:31] * jnthn just slept 11 hours and still feels tired and has black marks under his eyes :S

[09:31] <laben> m: my \a = (1..3).map(*.succ).WHAT; dd a;

[09:31] <GLRelia> rakudo-moar 133b57: OUTPUT«Seq␤»

[09:31] <camelia> rakudo-moar b56d59: OUTPUT«List␤»

[09:31] <timotimo> it's shitty that even when lseep deprived like that your body still refuses to sleep on an airplane :(

[09:31] <laben> m: my \a = (1..3).map(*.succ).WHAT; say a.name;

[09:31] <GLRelia> rakudo-moar 133b57: OUTPUT«Method 'name' not found for invocant of class 'Seq'␤  in block <unit> at /tmp/txoUkUxVYo:1␤␤»

[09:31] <camelia> rakudo-moar b56d59: OUTPUT«Method 'name' not found for invocant of class 'List'␤  in block <unit> at /tmp/qptnhedNAm:1␤␤»

[09:31] <laben> m: my \a = (1..3).map(*.succ).WHAT; say a.^name;

[09:31] <GLRelia> rakudo-moar 133b57: OUTPUT«Seq␤»

[09:31] <camelia> rakudo-moar b56d59: OUTPUT«List␤»

[09:31] *** yeahnoob left
[09:32] <jnthn> On those who are trying to figure out the single arg rule, I think you can understand it entirely in terms of "for"

[09:32] <jnthn> for X { Y } ==> X.map(Y)

[09:32] <jnthn> uh, well, with the block of course :)

[09:32] <jnthn> But the X is the single argument. How will .map interpret it? That's the answer.

[09:36] *** xinming_ joined
[09:36] *** Guest46196 left
[09:37] <timotimo> ITYM "understand it entirely in terms of “map”"

[09:37] <timotimo> do we want to finally throw out perlfoundation.org/perl6 ?

[09:39] *** xinming left
[09:41] <ShimmerFairy> timotimo: IIRC that's pretty much dead already, no?

[09:42] <timotimo> yes

[09:43] <timotimo> people can and possibly will stumble upon it still

[09:43] <_itz_> A ex co-worker liked the content at http://www.perlfoundation.org/perl6/index.cgi?perl_6_executive_summary

[09:44] <masak> _itz_: maybe put it on perl6.org, then?

[09:45] <_itz_> yes I think that would be a good idea 

[09:51] *** cognominal joined
[09:52] <laben> if you put those pages on perl6.org, it would be good to make that URL a redirect to perl6.org or at least a simple page that links there

[09:57] *** Begi joined
[09:59] *** laouji left
[10:00] <Begi> Is there a way to host a Perl6 code for free ?

[10:01] *** laouji joined
[10:01] <laben> m: -«([1, 2], [3, [4, 5]])

[10:01] <GLRelia> rakudo-moar 133b57: ( no output )

[10:01] <camelia> rakudo-moar b56d59: ( no output )

[10:01] <laben> m: dd -«([1, 2], [3, [4, 5]])

[10:01] <GLRelia> rakudo-moar 133b57: OUTPUT«(-2, -2).iterator␤»

[10:01] <camelia> rakudo-moar b56d59: OUTPUT«([-1, -2], [-3, [-4, -5]])␤»

[10:01] <laben> Begi: github?

[10:01] <jnthn> That .iterator really should be .Seq

[10:02] <laben> m: (-«([1, 2], [3, [4, 5]])).WHAT.say

[10:02] <GLRelia> rakudo-moar 133b57: OUTPUT«(Seq)␤»

[10:02] <camelia> rakudo-moar b56d59: OUTPUT«(Parcel)␤»

[10:03] <laben> jnthn: .perl of Seq has been trouble the last few days. should it consume the Seq?

[10:04] <laben> oh and i guess nom is correct here design-wise, right?

[10:04] *** pmurias joined
[10:05] <laben> m: dd ([1, 2], [3, [4, 5]]).map(-*)

[10:05] <GLRelia> rakudo-moar 133b57: OUTPUT«(-2, -2).iterator␤»

[10:05] <camelia> rakudo-moar b56d59: OUTPUT«(-2, -2)␤»

[10:05] <nine> laben: how else could .perl produce usefull output but by consuming?

[10:05] <Begi> laben: I would like to launch a small Bailador application

[10:06] <ShimmerFairy> nine: by cloning the Seq and iterating that. It's been discussed before.

[10:06] <jnthn> I don't think cloning will be enough 'cus you've got a whole evaluation chain...

[10:07] <nine> jnthn: [1, 2, 3].Seq gives "Method 'Seq' not found for invocant of class 'Array'" while .iterator gives the nearest thing to the Seq

[10:07] <nine> ShimmerFairy: how do you clone .lines?

[10:07] <jnthn> nine: That also :)

[10:08] <laben> Begi: is localhost not enough? else you need to find a host, but i doubt you could find one with perl6 installed

[10:08] <jnthn> So cloning is a non-solution.

[10:08] <JimmyZ> hmm, why (-?([1, 2], [3, [4, 5]])).WHAT.say gives me (Int) locally

[10:08] <jnthn> nine: List.Seq is an easy thing to implement though. method Seq() { Seq.new(self.iterator) } :)

[10:08] <laben> m: (-?([1, 2], [3, [4, 5]])).WHAT.say

[10:08] <camelia> rakudo-moar b56d59: OUTPUT«(Int)␤»

[10:08] <GLRelia> rakudo-moar 133b57: OUTPUT«(Int)␤»

[10:08] <TimToady> did you mean -« instead?

[10:09] <Begi> laben: yes, that's the problem

[10:09] <JimmyZ> m: (-?([1, 2], [3, [4, 5]])).WHAT.say

[10:09] <GLRelia> rakudo-moar 133b57: OUTPUT«(Int)␤»

[10:09] <camelia> rakudo-moar b56d59: OUTPUT«(Int)␤»

[10:09] *** Ven joined
[10:10] <jnthn> I think that >> and friends have to force eager evaluation even if they do returns a Seq, but a Seq is a curious choice of return type in that case... :)

[10:10] <laben> Begi: unless you find one which will make you upload a compile binary or compile it themselves, i dont think you'll have much luck. perl6 is quite unknown for now

[10:10] <pmurias> masak: it's likely better that Perl 5 people who are not enthusiastic about Perl 6 wait before trying out so they don't get burned by something that's not ready for them

[10:11] <JimmyZ> oh, I got ? without unicode

[10:11] <masak> pmurias: agree.

[10:11] <masak> pmurias: I'm also perfectly fine with some people looking at the two and deciding to go all-out with Perl 5. I have no problem with that.

[10:11] <masak> people have different needs.

[10:11] <nine> jnthn: >> returns a List now already

[10:11] <jnthn> OK, good :)

[10:12] <TimToady> well, you do the final reordering a bit lazily

[10:12] <nine> I feel like I really start to understand these things now :)

[10:12] <laben> is it ok for >> to always return a List? i mean, what if one implements the Iterable in a custom class? should you really get LIst if you pass CClass to >>?

[10:13] <jnthn> TimToady: True, and something like for @foo.hyper.map(...).grep(...) { } will already start to iterate as soon as the first batch is available

[10:13] <nine> laben: it's specced to return a Parcel for which is the closest equivalent.

[10:13] <jnthn> Yeah, Parcel is le gone :)

[10:14] <laben> so now it would be specced to return List or should it be Seq?

[10:15] <jnthn> I think List is more sensible for >>.foo

[10:16] <laben> m: dd ([1, 2], [3, [4, 5]])>>++

[10:16] <camelia> rakudo-moar b56d59: OUTPUT«([1, 2], [3, [4, 5]])␤»

[10:16] <GLRelia> rakudo-moar 133b57: OUTPUT«Method 'succ' not found for invocant of class 'Array'␤  in block <unit> at /tmp/j2yxtluiVd:1␤␤»

[10:16] <TimToady> well, it's really supposed to dup the input types

[10:16] *** Begi left
[10:16] *** dayangkun left
[10:16] <laben> m: dd ([1, 2], [3, [4, 5]])>>.++

[10:16] <camelia> rakudo-moar b56d59: OUTPUT«([1, 2], [3, [4, 5]])␤»

[10:16] <GLRelia> rakudo-moar 133b57: OUTPUT«Method 'succ' not found for invocant of class 'Array'␤  in block <unit> at /tmp/LPj9k210So:1␤␤»

[10:16] <jnthn> @a>>.foo is really then doing something like @a.hyper.map(*.foo).eager.list

[10:16] <laben> m: dd (([1, 2], [3, [4, 5]])>>.++)

[10:16] <GLRelia> rakudo-moar 133b57: OUTPUT«Method 'succ' not found for invocant of class 'Array'␤  in block <unit> at /tmp/HoVbq63yWJ:1␤␤»

[10:16] <camelia> rakudo-moar b56d59: OUTPUT«([1, 2], [3, [4, 5]])␤»

[10:16] <jnthn> But it's more like deepmap I guess

[10:18] <laben> m: my @a = [1, 2], [3, [4, 5]]; dd @a; @a>>.++; dd @a

[10:18] <GLRelia> rakudo-moar 133b57: OUTPUT«@a = [$[1, 2], $[3, $[4, 5]]]␤Method 'succ' not found for invocant of class 'Array'␤  in block <unit> at /tmp/dW1tVqiyG5:1␤␤»

[10:18] <camelia> rakudo-moar b56d59: OUTPUT«@a = [[1, 2], [3, [4, 5]]]<>␤@a = [[2, 3], [4, [5, 6]]]<>␤»

[10:18] <nine> TimToady: So many methods return seq now. If we have >> return a Seq, too, >>++ and other ops with side effects will not get a chance to run.

[10:19] <TimToady> hypers are not really intended primarily for lazy things anyway

[10:19] <TimToady> that's what X and Z are for

[10:19] <laben> m: ([1, 2], [3, [4, 5]]).WHAT.say

[10:19] <GLRelia> rakudo-moar 133b57: OUTPUT«(List)␤»

[10:19] <camelia> rakudo-moar b56d59: OUTPUT«(Parcel)␤»

[10:20] <dalek> rakudo/glr: 3c83dbc | (Stefan Seifert)++ | src/core/ (2 files):

[10:20] <dalek> rakudo/glr: Have [1, 2, 3].Seq.perl return [1, 2, 3].Seq instead of .iterator

[10:20] <dalek> rakudo/glr: 

[10:20] <dalek> rakudo/glr: Thanks to jnthn++ for noticing

[10:20] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/3c83dbc896

[10:23] * masak .oO( Thanks to jnthn++ for nothing! ) :P

[10:25] <jnthn> :P

[10:25] <nine> Well constant Empty _was_ implemented by jnthn, so indeed, thanks for nothing ;)

[10:26] <jnthn> All these Empty compliments... :P

[10:27] <TimToady> in retrospect it's rather slipshod

[10:27] <nine> That is "All these Slip() compliments..." which is "All these compliments..."

[10:27] *** TEttinger left
[10:30] <timotimo> would have to be {Slip}, no?

[10:31] <nine> I parse English sentences as a List of words with auto quoting ;)

[10:33] <timotimo> fair enough :)

[10:33] <laben> nine: i fixed it up a bit like i said, still Whatever stuff is todo https://github.com/laben/rakudo/commit/d5a314f03f1a51e9c164408b3ffb39e3d2fce42c

[10:33] <timotimo> such big code :|

[10:34] <nine> laben: if $type.^name ne "Seq"; better: if nqp::istype($type, Seq);

[10:35] <laben> nine: i knew it there was a better way :/

[10:36] <jdv79> ooc, why is panda so slow to get moving?

[10:36] <timotimo> also, don't ever .isa("Typename"), that's ridiculously slow

[10:36] <jdv79> profiling is hard cause it hangs a browser

[10:38] <timotimo> yes, if your thing is big ... :(

[10:38] <timotimo> however

[10:38] <timotimo> you can give an output filename and end it in .json

[10:38] <timotimo> then you can use tadzik's viewer that's written in C++

[10:38] <jdv79> interestingly "panda install JSON::Tiny" seems to install panda.  wut.

[10:38] <jdv79> in adddition to JSON::Tiny

[10:38] <nine> laben: we learn as we go :)

[10:38] <jdv79> oh

[10:39] <timotimo> haha, what?

[10:39] <nine> jdv79: because most modules actually depend on panda for their Build.pm6

[10:40] <jdv79> oh, rev dep rebuild

[10:40] <jdv79> meh

[10:40] <timotimo> https://github.com/tadzik/p6profiler-qt ← jdv79 

[10:41] <jdv79> so, let's say i upgrade a module that's deep in a deps hier.  will it have to rebuild all the way to the top?  seems intense.

[10:42] <jnthn> jdv79: Well, you certainly have to redo the precomps all the way to the top

[10:42] <laben> jdv79: yeah and dont forget to rebuild everything everytime you rebuild rakudo :/

[10:42] <ShimmerFairy> revdep-rebuild (at least in gentoo) is more about rebuilding things that use updated things

[10:42] <timotimo> yeah, our pre-compilations have hard dependencies on exact compilation output

[10:42] <jnthn> jdv79: The actual module fetch/test/install doesn't have to be done

[10:42] <jnthn> We'll need to de-tangle module management and pre-comp management at some point.

[10:43] <jdv79> ah.  good to know.

[10:43] <jdv79> makes sense

[10:43] *** rmgk left
[10:46] *** rmgk joined
[10:49] <nine> laben: I think my new implementation passes the same tests as the old. Updated the gist: https://gist.github.com/niner/b8d88fca93b77ead569f

[10:49] *** zakharyas left
[10:49] *** virtualsue_ joined
[10:50] *** virtualsue left
[10:50] *** virtualsue_ is now known as virtualsue

[10:51] *** integral left
[10:51] *** flussence joined
[10:51] <laben> nine: rebuilding now, will try asap

[10:53] *** garu joined
[10:55] *** zakharyas joined
[10:55] <laben> nine: did you try "say (1..3).map(*.succ) <<~>> ('B'..'H').map(*.pred)"? your impl doesnt say anything on my machine

[10:57] *** sjn joined
[10:57] *** rvchangue joined
[10:57] <nine> Ah, that's both ends are dwim. An unhandled case indeed

[11:00] *** integral joined
[11:00] *** integral left
[11:00] *** integral joined
[11:05] *** preyalone joined
[11:05] *** CQ2 joined
[11:06] *** skarn joined
[11:07] <nine> laben: HYPER really is a rat's nest of possible cases

[11:07] <timotimo> it'd be great if hyper didn't have to check which ends are DWIM every time a single value is pulled

[11:08] <timotimo> but still, you're doing good work, laben!

[11:10] <moritz> m: try { eager map { die } }; say "alive"

[11:10] <GLRelia> rakudo-moar 3c83db: OUTPUT«5===SORRY!5=== Error while compiling /tmp/bHe1pLFcsy␤Missing comma after block argument to map␤at /tmp/bHe1pLFcsy:1␤------> 3try { eager map { die } 7⏏5}; say "alive"␤»

[11:10] <camelia> rakudo-moar b56d59: OUTPUT«5===SORRY!5=== Error while compiling /tmp/Wj1UgX5F8p␤Missing comma after block argument to map␤at /tmp/Wj1UgX5F8p:1␤------> 3try { eager map { die } 7⏏5}; say "alive"␤»

[11:10] <moritz> m: try { eager map { die }, 1 }; say "alive"

[11:10] <GLRelia> rakudo-moar 3c83db: OUTPUT«Died␤  in block <unit> at /tmp/DW4VqiHMht:1␤␤»

[11:10] <camelia> rakudo-moar b56d59: OUTPUT«alive␤»

[11:11] <moritz> seems eager isn't eager enough

[11:12] <moritz> m: say map({1}, 1).eager.^name

[11:12] <GLRelia> rakudo-moar 3c83db: OUTPUT«Seq␤»

[11:12] <camelia> rakudo-moar b56d59: OUTPUT«List␤»

[11:12] <moritz> uhm, does an eager Seq make sense?

[11:12] <moritz> I'd expect it to return a list

[11:14] * moritz tries it

[11:18] <nine> laben: Updated to also pass your use-case: https://gist.github.com/niner/b8d88fca93b77ead569f Now passing 283 tests of hyper.t

[11:18] <nine> laben: I also added your special casing of Seq as results

[11:19] <moritz> ok, I have a local fix that makes try { eager map { die }, 1 }; live

[11:19] <moritz> turns out eager wasn't implemented at all (?)

[11:20] *** Ven left
[11:21] <nine> moritz: I'm not surprised :)

[11:24] <moritz> huh

[11:24] <laben> nine: rebuilding right now

[11:24] <moritz> there's a method eager() in Iterable

[11:24] <_itz_> 3/j perl6-site

[11:24] <_itz_> :)

[11:26] <moritz> m: try { (map { die }, 1).eager }; say 'alive'

[11:26] <GLRelia> rakudo-moar 3c83db: OUTPUT«Died␤  in block <unit> at /tmp/SlY0peJ0_A:1␤␤»

[11:26] <camelia> rakudo-moar b56d59: OUTPUT«alive␤»

[11:26] <nine> moritz: but Iterable.eager() only starts working once you pull at least one value

[11:27] <moritz> nine: then either the implementor misunderstood eager, or I do

[11:27] <jnthn> Well, it's intentional at least

[11:27] <jnthn> my @a = eager ...; # we don't want to immediately produce all values only to go on and copy them to @a, we'd rather produce them all direclty into @a

[11:27] <moritz> with that, the "try" in  try { eager map { die }, 1 } won't catch the exception

[11:28] <nine> Would be nice if we could detect sink context here...

[11:28] <jnthn> That should work 'cus try should force evaluation.

[11:28] <jnthn> Well, trouble is that isn't actually a sink context

[11:28] <jnthn> Because we have to return the result from try

[11:29] <laben> nine: now it's another, "say (1..3).map(*.succ) >>~<< ('B'..'H').map(*.pred)" would throw (as specced) on existing impl, yours silently does >>op>> (or equivalently <<op>>)

[11:29] <moritz> jnthn: but what forces evaluation (except for sink), if not eager?

[11:30] <moritz> maybe we should start to teach folks to write   eager my @a = ... # instead

[11:30] <moritz> and make eager actually, well, eager

[11:32] <laben> nine: btw how did you run more than 74 tests in hyper.t?

[11:33] <nine> laben: I commented out the dieing unary hyper tests

[11:34] *** CQ2 left
[11:35] *** yqt joined
[11:35] *** CQ2 joined
[11:36] *** yqt left
[11:36] *** cantaberry left
[11:36] *** yqt joined
[11:38] *** FROGGS_ joined
[11:39] <jnthn> moritz: Maybe so, yes

[11:40] <jnthn> In that case maybe eager promises a List if you do it to a Seq

[11:41] <timotimo> Die Hyper, starring Bruce Willis

[11:41] <jnthn> We'll lose the cute "lazy eager ..." trick that way though

[11:41] <jnthn> (Lazily evaluate the whole thing in one go if we ever ask for any of it)

[11:42] *** FROGGS left
[11:42] <jnthn> But maybe that is rarely wanted, and we could easily introduce it under a new name.

[11:42] <jnthn> Or even push it out to module space.

[11:42] * jnthn needs to rest a bit more

[11:42] <timotimo> good rest, jnthn!

[11:42] * TimToady also notes that 'my @a = is already eager

[11:43] <jnthn> TimToady: No, it's "mostly eager"

[11:43] <jnthn> TimToady: That is, evaluates up to the first thing that says "I'm lazy"

[11:43] <TimToady> okay, well, it's still something we can recognize at compile time

[11:43] <jnthn> my @a = 1..Inf; # OK

[11:43] <jnthn> eager my @a = 1..Inf; # hang

[11:44] <TimToady> and we should optimize away array assignment copy most of the time anyway

[11:44] <TimToady> (as P5 does already)

[11:45] <jnthn> TimToady: What do you mean by "copy"?

[11:45] <TimToady> well, the extra copy to prevent self-ref from busting, but this could do something similar

[11:46] <jnthn> Oh, I already avoid that.

[11:46] <jnthn> @a = 1, |@a; # works fine

[11:46] <jnthn> @a = 1, @a; # works fine except you just creating an infinite data strucutre :)

[11:46] <TimToady> okay, well, dinner here &

[11:46] <jnthn> o/

[11:47] * masak .oO( this could be us but you just creating an infinite data structure )

[11:47] * jnthn also bbl

[11:50] <timotimo> huh?

[11:50] <timotimo> masak: i don't get that :|

[11:51] <sjn> s/infinite/circular/ # ?

[11:52] <arnsholt> Well, circular structures are just a special case of infinite ones

[11:53] <masak> they're a very space-efficient case.

[11:53] <masak> timotimo: I was just riffing off of "this could be us but you playin", which, by the way, don't search for on Twitter :/

[11:59] <timotimo> i have never heard that phrase ... how am i supposed to understand what it is if i'm not allowed to search for it? :)

[11:59] <_itz_> is there a more perl6ish way of timing out a section of code (using a promise or whatever) than the old alarm signal (probably not win32ish)@

[12:00] *** laben left
[12:00] <timotimo> we don't give you a way to stop a running piece of code dead in its tracks; you'll still have to have some sort of stop switch that you can flip

[12:00] <timotimo> but yeah, a promise will help you there

[12:01] <timotimo> one made from Promise.in(...) and another to signify the successful execution of the task

[12:01] *** laben joined
[12:01] <timotimo> then you await for Promise.any($timeout, $completed) and if after that the state of $completed isn't Kept, you flip the "abort" switch

[12:01] <_itz_> ok thanks

[12:02] <timotimo> good luck :)

[12:03] <timotimo> if you have something that gives you a Supply, you can usually close your tap on it and that may cause a proper abort. for things like async I/O. not sure about that, though

[12:03] *** laouji left
[12:05] <masak> there are some arguments that in an async setting, the observer *shouldn't* have the privs to cancel the observable.

[12:06] <masak> though I confess to not understanding the arguments all too well yet.

[12:06] <masak> it might be they apply only to individual promises.

[12:06] <timotimo> i'd argue it's not really that

[12:07] <timotimo> if you're an async line reader for a file and your only subscriber tells you "i'm not interested any more", then it's your choice if you cancel or keep going

[12:07] *** laben left
[12:07] <timotimo> if you have multiple subscribers, they don't individually have the power to stop you in your tracks

[12:10] *** _itz joined
[12:12] *** yqt left
[12:12] *** newbie1 joined
[12:13] *** colomon joined
[12:18] *** diana_olhovik__ left
[12:18] *** colomon left
[12:18] *** colomon joined
[12:20] *** colomon left
[12:25] *** zakharyas left
[12:26] *** FROGGS_ is now known as FROGGS

[12:26] <FROGGS> jdv79: it is about the target directory for p6 dists

[12:26] <yoleaux> 09:05Z <jdv79> FROGGS: http://irclog.perlgeek.de/perl6/2015-08-23#i_11103936 ?

[12:27] *** zakharyas joined
[12:29] *** brrt left
[12:29] *** colomon joined
[12:30] <nine> It's somewhat ridiculous how hard it is to get a List with the fully reified results from an iterator.

[12:30] <masak> nine: isn't that what an eager evaluation would do?

[12:31] *** colomon left
[12:31] <nine> masak: but eager returns a Seq :)

[12:31] *** colomon joined
[12:32] <masak> oh, shucks!

[12:32] <jdv79> FROGGS: that much is clear.

[12:32] <masak> ok, so then: why do you want a List, and not a Seq?

[12:32] <jdv79> but what of the extra mucking about?

[12:34] <jdv79> in other words - why would we end up with Perl6/[pP]erl6 and, more importantly, why is that to be avoided?

[12:34] <nine> masak: because hypers are supposed to be eager

[12:35] <jdv79> i tend to get a little over eager when i'm hyper;  usually too much caffeine is the cause

[12:35] *** colomon left
[12:35] <masak> nine: I think the reason that answer confuses me is that it contains none of the words of my question.

[12:35] <masak> I know hypers are eager.

[12:36] <masak> what's the connection with List and Seq?

[12:36] <moritz> nine: IMHO eager should return a List, not a Seq

[12:38] <nine> masak: deepmap is implemented using an iterator and supposed to return the same type of object that it is iterating over (mostly List or Array). So I create a List or Array for the results using .from-iterator. But it has to eagerly process, so I .eager the List and suddenly return a Seq.

[12:39] <jdv79> doesn't .list on a Seq get you an eagerly produced List (and memoized)?

[12:40] <nine> jdv79: no, just a list but not reified

[12:40] <dalek> perl6-examples: 573df66 | (Steve Mynott)++ | categories/cookbook/16processes/16-01-operation-timeout.pl:

[12:40] <dalek> perl6-examples: import operation timeout example

[12:40] <dalek> perl6-examples: review: https://github.com/perl6/perl6-examples/commit/573df66ef7

[12:40] <masak> nine: so the problem is that .eager returns a Seq, always? not a List?

[12:40] <jdv79> yeah , that didn't feel right after i typed it.

[12:40] *** colomon joined
[12:42] <nine> masak: yes

[12:42] *** colomon left
[12:43] <masak> nine: can you make .eager return a List?

[12:47] <nine> masak: I can, but we'd still need a solution for http://irclog.perlgeek.de/perl6/2015-08-24#i_11105711

[12:51] <nine> m: deepmap(&[-], [1, [2, 3]])

[12:51] <GLRelia> rakudo-moar 3c83db: ( no output )

[12:51] <camelia> rakudo-moar b56d59: ( no output )

[12:51] <nine> m: say deepmap(&[--], [1, [2, 3]])

[12:51] <camelia> rakudo-moar b56d59: OUTPUT«5===SORRY!5=== Error while compiling /tmp/jWAaWaRYvm␤Unable to parse expression in infix noun; couldn't find final ']' ␤at /tmp/jWAaWaRYvm:1␤------> 3say deepmap(&[-7⏏5-], [1, [2, 3]])␤»

[12:51] <GLRelia> rakudo-moar 3c83db: OUTPUT«5===SORRY!5=== Error while compiling /tmp/CZDmDZpsLV␤Unable to parse expression in infix noun; couldn't find final ']' ␤at /tmp/CZDmDZpsLV:1␤------> 3say deepmap(&[-7⏏5-], [1, [2, 3]])␤»

[12:53] <nine> m: say (-<<[1, [2, 3]]).perl

[12:53] <GLRelia> rakudo-moar 3c83db: OUTPUT«(-1, -2).Seq␤»

[12:53] <camelia> rakudo-moar b56d59: OUTPUT«(-1, [-2, -3])␤»

[12:53] <dalek> rakudo/glr: f8692f1 | (Stefan Seifert)++ | src/core/metaops.pm:

[12:53] <dalek> rakudo/glr: Fix deepmap applying the op to iterables instead of their contents

[12:53] <dalek> rakudo/glr: 

[12:53] <dalek> rakudo/glr: Fixes: -<<[1, [2, 3]]

[12:53] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/f8692f1820

[12:54] * [Coke] joins #perl, briefly - now 667 nicks in the channel. :P

[12:55] <masak> neighbor of the beast

[12:55] <dalek> rakudo/glr: 65a02f4 | (Stefan Seifert)++ | src/core/metaops.pm:

[12:55] <dalek> rakudo/glr: Fix deepmap returning a Seq instead of the desired Listy type

[12:55] <dalek> rakudo/glr: 

[12:55] <dalek> rakudo/glr: If the object's type is List or a subclass of List, use the object's

[12:55] <dalek> rakudo/glr: type for the result, so deepmap(op, (1, 2, [3, 4])) will return (op(1),

[12:55] <dalek> rakudo/glr: op(2), [op(3), op(4)]). In other cases (like Seq or Range) use List.

[12:55] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/65a02f49c7

[12:56] <masak> nine++ # glr

[12:56] <nine> .tell laben I fixed unary hypers so the tests don't die anymore. Now we can play around with HYPER more easily :)

[12:56] <yoleaux> nine: I'll pass your message to laben.

[12:57] <nine> Those hypers are surprisingly difficult to get right.

[12:57] *** pmurias left
[12:59] <dalek> roast/glr: fea1d1d | (Stefan Seifert)++ | S03-metaops/hyper.t:

[12:59] <dalek> roast/glr: GLRify a hyper test

[12:59] <dalek> roast/glr: 

[12:59] <dalek> roast/glr: Need a trailing comma now to create a one-element list

[12:59] <dalek> roast/glr: review: https://github.com/perl6/roast/commit/fea1d1dff7

[12:59] *** leedo joined
[12:59] <timotimo> hypers are super useful, though

[13:01] * [Coke] wonders if b56d5938f7ee3271b59e1ebd91529024339c63c1 is going to print negative years incorrectly.

[13:01] * [Coke] realizes that it's probably fine, whoops.

[13:01] *** brrt joined
[13:02] <jdv79> [Coke]: got your list of questions set?

[13:10] <jnthn> nine: What's tricky about it, ooc? It should just be creating a fresh IterationBuffer, passing it to .push-all of the Iterator, then binding it to $!reified of a new List.

[13:13] *** rmgk_ joined
[13:13] *** rmgk left
[13:13] *** rmgk_ is now known as rmgk

[13:14] <nine> jnthn: it's tricky if you try it with high level constructs.

[13:15] <jnthn> nine: Maybe List.from-iterator(the-iter).eager should do it

[13:15] <jnthn> nine: That is, we make .eager on List and its subclasses mean "eagerify *yourself*"

[13:17] <nine> jnthn: that's what I had there originally until I discovered that the eager returns a Seq

[13:17] <jnthn> nine: Yeah, I'm thinking of chaning that

[13:17] <jnthn> *changing

[13:18] <jnthn> .sink returns Nil

[13:18] <jnthn> .hyper/.race return HyperSeq

[13:18] <jnthn> .lazy returns Seq

[13:18] <jnthn> So it's not like there ain't precedent for .eager not returning something other than Seq ;)

[13:19] <nine> That was just 4 negations in a somewhat short sentence...

[13:19] <jnthn> Sorry, still a bit tired :)

[13:20] <[Coke]> jdv79: I've had like 3 questions submitted. No, I'm not set at all.

[13:20] <pink_mist> trying to parse that: there is precedent for .eager returning Seq? :P

[13:20] <dalek> rakudo/glr: ce93835 | (Stefan Seifert)++ | src/core/metaops.pm:

[13:20] <dalek> rakudo/glr: Better way to create the Listy return value of deepmap

[13:20] <dalek> rakudo/glr: 

[13:20] <dalek> rakudo/glr: Thanks to jnthn++ for pointing this out.

[13:20] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/ce938350a7

[13:20] <[Coke]> thankfully, that's not until Friday.

[13:21] <jnthn> pink_mist: Yes :)

[13:21] <jnthn> pink_mist: no wait, there's precedent for .eager *not* returning Seq :)

[13:22] <pink_mist> I assumed that's what you meant yes, but it could be parsed the other way :P

[13:22] <jnthn> By this point I'd have been better just pushing the darn code :P

[13:22] <dalek> perl6-examples: 61df0a1 | (Steve Mynott)++ | categories/cookbook/19cgi-programming/19-01cgi-script.pl:

[13:22] <dalek> perl6-examples: import a simple CGI (PSGI) example

[13:22] <dalek> perl6-examples: review: https://github.com/perl6/perl6-examples/commit/61df0a1db7

[13:23] *** zakharyas left
[13:23] *** brrt left
[13:28] <dalek> perl6-examples: 45e72e9 | (Steve Mynott)++ | htmlify.pl:

[13:28] <dalek> perl6-examples: categories added

[13:28] <dalek> perl6-examples: review: https://github.com/perl6/perl6-examples/commit/45e72e98f9

[13:30] *** Peter_R joined
[13:31] <ChoHag> How long does the internet need to exist for before people stop taking *literally everything* it contains so seriously?

[13:32] <masak> how dare you!!

[13:32] <masak> :P

[13:33] <jnthn> I literally hate how people misuse literally... :P

[13:33] <masak> yeah, it's not very literary...

[13:33] <jdv79> never

[13:34] <jnthn> .oO( Literal programming: programming without the use of any variables, just literal data )

[13:35] <masak> that's literally what it means

[13:35] <TimToady> Hyper Text Markup Literals

[13:36] <masak> it's better than lithographic programming where, once you write a line of code, it's set in stone.

[13:37] <TimToady> in bronze age programming they invented casts

[13:38] <jnthn> And of course we got dynamic compilation in...the medieval period

[13:38] <TimToady> restricted to the scriptorium, alas

[13:39] <[Coke]> jnthn: so you get to be home for about 2 days before heading back out?

[13:39] *** zakharyas joined
[13:40] <jnthn> [Coke]: I go to Stockholm *tomorrow* to collect wife, then we come to Olten on Wed.

[13:41] <jnthn> So like 1 day

[13:41] <jnthn> The washing machine is keeping busy :)

[13:42] *** skids joined
[13:45] <moritz> tomorrow's trend: lycantrophic progamming, where every method might turn into a were on full moon

[13:51] <arnsholt> Heh. I just had to execute "grep -- --"

[13:56] <skids> So I have one remaining single-item-rule question, which is, "is $[thing] supposed to shield [thing] from first-item semantics or not?" e.g. should we be doing an nqp::iscont test before looking whether it is an Iterable?

[13:57] <jnthn> skids: Doesn't shield it

[13:57] <skids> OK, so unshift/push will have to be fixed.

[13:57] <jnthn> skids: Not unless you think $thing.map(...) also should

[13:57] <skids> No not for methods surely.

[13:57] *** khw joined
[13:57] <skids> For sub forms.

[13:58] <skids> m: my @a = 1,2; push @a, $[3,4]; # currently

[13:58] <GLRelia> rakudo-moar ce9383: ( no output )

[13:58] <camelia> rakudo-moar b56d59: ( no output )

[13:58] <skids> m: my @a = 1,2; push @a, $[3,4]; @a.say; # currently

[13:58] <GLRelia> rakudo-moar ce9383: OUTPUT«1 2 3 4␤»

[13:58] <camelia> rakudo-moar b56d59: OUTPUT«1 2 (Any) (Any)␤»

[13:59] <skids> m: my @a = 1,2; push @a, $[3,4]; @a.perl.say; # currently, sorry morning.

[13:59] <GLRelia> rakudo-moar ce9383: OUTPUT«[1, 2, $[3, 4]]␤»

[13:59] <camelia> rakudo-moar b56d59: OUTPUT«[1, 2, Any, Any]<>␤»

[14:00] *** brrt joined
[14:07] *** KotH_ joined
[14:11] *** timotimo joined
[14:12] <skids> The other thing I was noticing is that if we do have a situation where we want to pass "whether it was containerized" information on, and List immutability gets in the way of the use case, the only option is working with allcaps methods to abuse Array, since the normal methods itemize.

[14:15] *** telex left
[14:16] <skids> (For the record I do thing having $[] protect against first-element would be tenable, you'd just have to deal with explaining the difference  beween $a = iterable and $a := iterable when passed to a sub and idiomize using sigilless for the latter.)

[14:16] *** telex joined
[14:17] *** colomon joined
[14:17] <skids> Oh, also, is the join sub form going to keep flattening?  It seems obvious the grep/first/index family need to lose it.

[14:18] *** Ven joined
[14:23] *** mjgardner joined
[14:23] *** Ven left
[14:30] <skids> m: my @a = "[1,2]", "3"; @a.pop; @a .= map: { "\$($_)" }; $parms = @a.join(","); EVAL "for $parms \{ .perl.say };"; # Answer to "why would you ever 'for $ {}'?"

[14:30] <camelia> rakudo-moar b56d59: OUTPUT«5===SORRY!5=== Error while compiling /tmp/Ftalu4tSbj␤Variable '$parms' is not declared␤at /tmp/Ftalu4tSbj:1␤------> 3, "3"; @a.pop; @a .= map: { "\$($_)" }; 7⏏5$parms = @a.join(","); EVAL "for $parms ␤»

[14:30] <GLRelia> rakudo-moar ce9383: OUTPUT«5===SORRY!5=== Error while compiling /tmp/Lx6wrrtQw6␤Variable '$parms' is not declared␤at /tmp/Lx6wrrtQw6:1␤------> 3, "3"; @a.pop; @a .= map: { "\$($_)" }; 7⏏5$parms = @a.join(","); EVAL "for $parms ␤»

[14:30] *** colomon left
[14:30] *** colomon joined
[14:30] <dalek> rakudo/glr: 322e708 | (Stefan Seifert)++ | src/core/metaops.pm:

[14:30] <dalek> rakudo/glr: Fix "Seq already iterated" errors in HYPER(op, left, right)

[14:30] <dalek> rakudo/glr: 

[14:30] <dalek> rakudo/glr: Replaced the implementation by one that does not try to count the

[14:30] <dalek> rakudo/glr: elements first and now is guaranteed to iterate only once over the input

[14:30] <dalek> rakudo/glr: lists.

[14:30] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/322e708dc0

[14:31] *** brrt left
[14:31] <nine> With this we're down to 125/1047 spec test files failing :) And hopefully, hyper ops shouldn't be an issue anymore.

[14:32] <colomon> \o/

[14:32] *** Ven joined
[14:32] <jdv79> woohoo

[14:33] <moritz> nine++

[14:33] <jnthn> nine++

[14:33] <skids> It'll go up again when we start correcting *@ in signatures, FWIW.  Not to be a wet blanket.

[14:33] <skids> nine++

[14:34] <moritz> skids: maybe **@ helps?

[14:34] <moritz> m: sub f(**@x) { say @x.perl }; f 1, (2, 3), [4, 5]

[14:34] <GLRelia> rakudo-moar ce9383: OUTPUT«[1, $(2, 3), $[4, 5]]␤»

[14:34] <camelia> rakudo-moar b56d59: OUTPUT«(1; 2, 3; 4, 5)␤»

[14:34] <skids> No, **@ creates more failures overall (I've been playing with it this weekend.)

[14:37] <skids> Got a few fixes queued up and hopefully the whole thing doesn't mushroom before I can make a workable PR out of it.

[14:38] *** newbie1 left
[14:38] <nine> .tell laben I went ahead and pushed my new HYPER implemenation. hyper.t passes now completely. Your implementation was very useful for figuring out the required semantics, so thank you very much for that!

[14:38] <yoleaux> nine: I'll pass your message to laben.

[14:40] *** pyrimidine_ left
[14:46] *** pyrimidine joined
[14:47] *** pyrimidine left
[14:47] *** pyrimidine joined
[14:47] *** pyrimidine left
[14:48] *** pyrimidine joined
[14:48] *** rurban_ joined
[14:50] *** colomon left
[14:54] *** rurban joined
[15:00] *** mjgardner left
[15:00] *** KotH_ is now known as KotH

[15:04] <moritz> m: my ($type, $motivation); :(:$type, :$motivation) := (type => 'geek', motivation => '-Ofun');

[15:04] <GLRelia> rakudo-moar 322e70: OUTPUT«Too many positionals passed; expected 0 arguments but got 2␤  in block <unit> at /tmp/u0sbQfOYIr:1␤␤»

[15:04] <camelia> rakudo-moar b56d59: ( no output )

[15:07] <moritz> presumably that's because the RHS used to be a Capture, and isn't anymore

[15:07] <moritz> but beyond that, I'm at a loss

[15:09] <masak> something passes 2 (positional) arguments to something...?

[15:09] <moritz> seems it mis-classifies the arguments as positional

[15:10] <moritz> m: my ($a, $b); :($a, $b) := (1, 2); say $b

[15:10] <GLRelia> rakudo-moar 322e70: OUTPUT«2␤»

[15:10] <camelia> rakudo-moar b56d59: OUTPUT«2␤»

[15:11] <moritz> m: my ($a, $b); :($a, $b) := (1, x => 2); say $b

[15:11] <GLRelia> rakudo-moar 322e70: OUTPUT«x => 2␤»

[15:11] <camelia> rakudo-moar b56d59: OUTPUT«Too few positionals passed; expected 2 arguments but got 1␤  in block <unit> at /tmp/ZFnaTMVXMh:1␤␤»

[15:11] <moritz> yes, definitely mis-classified

[15:11] *** mjgardner joined
[15:12] <ShimmerFairy> m: say \(1, x => 2).WHAT

[15:12] <GLRelia> rakudo-moar 322e70: OUTPUT«(Capture)␤»

[15:12] <camelia> rakudo-moar b56d59: OUTPUT«(Capture)␤»

[15:12] <ShimmerFairy> not sure why you should expect a Capture where you didn't specify one :)

[15:19] <jnthn> m: (1, x => 2).Capture.perl.say

[15:19] <GLRelia> rakudo-moar 322e70: OUTPUT«\(1, :x(2))␤»

[15:19] <camelia> rakudo-moar b56d59: OUTPUT«\(1, :x(2))␤»

[15:19] <jnthn> Hm, was thinking that may show the issue, but no...

[15:19] <jnthn> m: (1, x => 2).Capture.hash.perl.say

[15:19] <GLRelia> rakudo-moar 322e70: OUTPUT«EnumMap.new()␤»

[15:19] <camelia> rakudo-moar b56d59: OUTPUT«EnumMap.new(:x(2))␤»

[15:19] <jnthn> Oh...

[15:19] <jnthn> OK, that one does :)

[15:26] *** mjgardner left
[15:30] *** laben joined
[15:33] <laben> i'm back, #perl6

[15:33] <yoleaux> 12:56Z <nine> laben: I fixed unary hypers so the tests don't die anymore. Now we can play around with HYPER more easily :)

[15:33] <yoleaux> 14:38Z <nine> laben: I went ahead and pushed my new HYPER implemenation. hyper.t passes now completely. Your implementation was very useful for figuring out the required semantics, so thank you very much for that!

[15:34] <laben> nine: very good work, nine++. i'm gonna fix up my repo and rebuild asap

[15:36] <nine> The Capture thing is one of the issues in panda

[15:37] <skids> jnthn: I have a fix for that I think as part of my flattening hunting.

[15:37] * skids extracts it from his git diff.

[15:38] *** zakharyas left
[15:38] <skids> https://gist.github.com/skids/4f6ff2e1c1e3b6855773

[15:38] *** Ven left
[15:39] <skids> Oh but, join is still flattening in mainline glr, that should only be needed in my tree.

[15:39] <skids> Weird.

[15:40] <skids> Oh, nm that was just for the gistperl.

[15:41] *** rurban left
[15:41] *** yqt joined
[15:41] *** araujo left
[15:43] *** pnu left
[15:43] *** pnu joined
[15:43] *** pnu left
[15:43] *** pnu joined
[15:44] *** araujo joined
[15:47] <laben> m: say (1..3).map(*.succ) >>~<< ('B'..'H').map(*.pred)

[15:47] <GLRelia> rakudo-moar 322e70: OUTPUT«2A 3B 4C 2D 3E 4F 2G␤»

[15:47] <camelia> rakudo-moar b56d59: OUTPUT«Lists on either side of non-dwimmy hyperop of infix:<~> are not of the same length␤left: 3 elements, right: 7 elements␤  in block <unit> at /tmp/FD1wy5YNzN:1␤␤»

[15:48] <laben> nine: ^^^

[15:48] <skids> Anyway, I updated that gist to just have the things I have patched in my tree where I found core code expecting flattening where it may go away.

[15:48] <skids> In case anyone starts playing with that.

[15:51] *** araujo_ joined
[15:52] <nine> laben: darn...there doesn't seem to be a spec test for that

[15:53] *** MilkmanDan left
[15:53] <dalek> perl6-roast-data: a558084 | coke++ | / (10 files):

[15:53] <dalek> perl6-roast-data: today (automated commit)

[15:53] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/a5580848bd

[15:53] *** araujo_ left
[15:53] <nine> Though there are spec tests for non-dwimmy hyper ops with unequal list size. They even test the elems in the exception message.

[15:53] <[Coke]> glr actually passing 5 less tests today.

[15:54] *** araujo_ joined
[15:54] <nine> [Coke]: sounds like we should start today's work for real

[15:54] *** araujo left
[15:54] <laben> nine: dont worry, i'll work on it myself, you can work on others more pressing issues

[15:54] <nine> laben: ok :)

[15:54] <nine> laben: have fun!

[15:55] *** abraxxa left
[15:56] *** araujo_ left
[15:57] *** araujo_ joined
[15:57] *** MilkmanDan joined
[15:58] *** araujo_ left
[15:59] *** araujo_ joined
[15:59] *** pnu left
[15:59] *** pnu joined
[15:59] *** pnu left
[15:59] *** pnu joined
[15:59] <b2gills> Originally I thought something like ｢A >>OP<< B｣ just stopped when the shortest of the two lists ran out of elements.

[16:01] *** araujo_ left
[16:01] <laben> b2gills: it's specced to throw if they arent of the same length. if you point the hyper to the shortest one, it will instead work until the shortest end. viceversa, you point it to the longest and it works until the longest runs out

[16:02] <b2gills> It will extend it out, which may not be what you want, and yes I know that now

[16:02] <laben> if you point to both, it will automatically do up to the longest

[16:02] <b2gills> What if you want it to not extend

[16:03] <laben> point the hyper to the shortest

[16:03] <laben> sorry i got it backwards

[16:03] *** Ven joined
[16:04] <laben> if B is shorter, A >>op>> B will lengthen B while A <<op<< B will shorten A

[16:05] <b2gills> The way it works now ｢<<OP<<｣ ｢<<OP>>｣ ｢>>OP>>｣ are quite a bit different than ｢>>OP<<｣

[16:05] <laben> >>op<< is just stricter, works only if both sides have the same length

[16:05] <b2gills> I know that, and it isn't very useful

[16:07] <b2gills> If you think of >>OP>> as *stop* when the left is out of elements  and <<OP<< as stop when the right is out of elements then >>OP<< would be stop when either is out of elements ( and would be more tenable in a lazy list world )

[16:09] <laben> m: say (1..3).map(*.succ) Z~ ('A'..'S').map(*.succ)

[16:09] <GLRelia> rakudo-moar 322e70: OUTPUT«2B 3C 4D␤»

[16:09] <camelia> rakudo-moar b56d59: OUTPUT«2B 3C 4D␤»

[16:10] <laben> b2gills: maybe, you will need to speak to jnthn or to TimToady, as we would need to change the spec

[16:12] *** AlexDaniel joined
[16:15] <moritz> m: say 1 <<+<< 4, 5, 6

[16:15] <GLRelia> rakudo-moar 322e70: OUTPUT«556␤»

[16:15] <camelia> rakudo-moar b56d59: OUTPUT«556␤»

[16:15] <moritz> m: say 1 >>+<< 4, 5, 6

[16:15] <camelia> rakudo-moar b56d59: OUTPUT«556␤»

[16:15] <GLRelia> rakudo-moar 322e70: OUTPUT«556␤»

[16:15] <moritz> m: say 1 >>+>> 4, 5, 6

[16:15] <camelia> rakudo-moar b56d59: OUTPUT«556␤»

[16:15] <GLRelia> rakudo-moar 322e70: OUTPUT«556␤»

[16:15] <moritz> m: say 1 <<+>> 4, 5, 6

[16:15] <GLRelia> rakudo-moar 322e70: OUTPUT«556␤»

[16:15] <camelia> rakudo-moar b56d59: OUTPUT«556␤»

[16:15] <moritz> oh

[16:16] <moritz> I guess I should take care of precedence :/

[16:16] <moritz> m: say 1 <<+<< (4, 5, 6)

[16:16] <GLRelia> rakudo-moar 322e70: OUTPUT«5 6 7␤»

[16:16] <camelia> rakudo-moar b56d59: OUTPUT«5 6 7␤»

[16:16] <moritz> m: say 1 <<+>> (4, 5, 6)

[16:16] <camelia> rakudo-moar b56d59: OUTPUT«5 6 7␤»

[16:16] <GLRelia> rakudo-moar 322e70: OUTPUT«5 6 7␤»

[16:16] <moritz> m: say 1 >>+>> (4, 5, 6)

[16:16] <GLRelia> rakudo-moar 322e70: OUTPUT«Lists on either side of non-dwimmy hyperop of infix:<+> are not of the same length␤left: 1 elements, right: 3 elements␤  in block <unit> at /tmp/ffZGE3c52g:1␤␤»

[16:16] <camelia> rakudo-moar b56d59: OUTPUT«Lists on either side of non-dwimmy hyperop of infix:<+> are not of the same length␤left: 1 elements, right: 3 elements␤  in block <unit> at /tmp/qexUnTzTu4:1␤␤»

[16:16] <moritz> m: say 1 >>+<< (4, 5, 6)

[16:16] <GLRelia> rakudo-moar 322e70: OUTPUT«Lists on either side of non-dwimmy hyperop of infix:<+> are not of the same length␤left: 1 elements, right: 3 elements␤  in block <unit> at /tmp/s0sLEeuXSF:1␤␤»

[16:16] <camelia> rakudo-moar b56d59: OUTPUT«Lists on either side of non-dwimmy hyperop of infix:<+> are not of the same length␤left: 1 elements, right: 3 elements␤  in block <unit> at /tmp/qO7cdPK5uv:1␤␤»

[16:18] <nine> m: my Int @a; @a[0] := "a";

[16:18] <GLRelia> rakudo-moar 322e70: ( no output )

[16:18] <camelia> rakudo-moar b56d59: ( no output )

[16:19] *** salva left
[16:20] *** hoelzro joined
[16:22] <tony-o> https://gist.github.com/tony-o/b033edd8151b92863a99

[16:22] <tony-o> oops

[16:29] *** dakkar left
[16:38] *** colomon joined
[16:39] *** yqt left
[16:40] *** salva joined
[16:40] *** araujo joined
[16:40] *** araujo left
[16:40] *** araujo joined
[16:40] *** araujo left
[16:40] *** yqt joined
[16:41] *** salva left
[16:41] *** salva joined
[16:42] *** mjgardner joined
[16:43] *** gagalicious left
[16:46] <dalek> perl6-examples: 873efab | (Steve Mynott)++ | / (3 files):

[16:46] <dalek> perl6-examples: two pattern matching examples

[16:46] <dalek> perl6-examples: review: https://github.com/perl6/perl6-examples/commit/873efabbcc

[16:49] <dalek> rakudo/glr: 9e28e48 | (Stefan Seifert)++ | src/core/Array.pm:

[16:49] <dalek> rakudo/glr: Restore type checks in Array.push

[16:49] <dalek> rakudo/glr: 

[16:49] <dalek> rakudo/glr: @a.push: 1, 2, [3] now correctly throws a type checking exception

[16:49] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/9e28e484b6

[16:49] *** araujo joined
[16:50] *** araujo left
[16:51] <dalek> rakudo/glr: 5fd43b9 | moritz++ | src/core/List.pm:

[16:51] <dalek> rakudo/glr: GLRify permutations

[16:51] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/5fd43b9a45

[16:52] <dalek> roast/glr: bfea81d | (Stefan Seifert)++ | S12-attributes/instance.t:

[16:52] <dalek> roast/glr: GLRify typed array push test

[16:52] <dalek> roast/glr: 

[16:52] <dalek> roast/glr: The array did get flattened thwarting the type checking test.

[16:52] <dalek> roast/glr: review: https://github.com/perl6/roast/commit/bfea81da97

[16:54] <masak> m: .say for "GLR".comb.permutations.map(*.join) # GLR permutations

[16:54] <GLRelia> rakudo-moar 9e28e4: ( no output )

[16:54] <camelia> rakudo-moar b56d59: OUTPUT«GLR␤GRL␤LGR␤LRG␤RGL␤RLG␤»

[16:55] * moritz likes RGL, "Really Great List" :-)

[16:56] *** araujo joined
[16:56] *** araujo left
[16:56] *** araujo joined
[16:57] *** araujo left
[16:58] <masak> or "Retired, Gleefully Lecherous"

[16:59] *** domidumont left
[16:59] *** Ven left
[17:00] <ChoHag> How often does GLRelia rebuild itself?

[17:02] <moritz> _itz should know

[17:03] <ChoHag> GLRelia: How often do you rebuild yourself?

[17:03] <_itz> it checks to see if the branch has commits every 5 

[17:04] <_itz> mins

[17:05] *** araujo joined
[17:05] *** araujo left
[17:05] *** araujo joined
[17:07] *** virtualsue left
[17:09] *** domidumont joined
[17:10] <nine> m: .say for "GLR".comb.permutations.map(*.join) # GLR permutations

[17:10] <GLRelia> rakudo-moar 5fd43b: OUTPUT«GLR␤GRL␤LGR␤LRG␤RGL␤RLG␤»

[17:10] <camelia> rakudo-moar b56d59: OUTPUT«GLR␤GRL␤LGR␤LRG␤RGL␤RLG␤»

[17:11] <moritz> m: .say for "GLR".comb.permutations>>.join

[17:11] <GLRelia> rakudo-moar 5fd43b: OUTPUT«GLR␤GRL␤LGR␤LRG␤RGL␤RLG␤»

[17:11] <camelia> rakudo-moar b56d59: OUTPUT«G␤L␤R␤G␤R␤L␤L␤G␤R␤L␤R␤G␤R␤G␤L␤R␤L␤G␤»

[17:11] <moritz> GLR++

[17:11] <dalek> rakudo/glr: 592e048 | (Stefan Seifert)++ | src/Perl6/Actions.nqp:

[17:11] <dalek> rakudo/glr: Fix perl6 -n -e

[17:11] <dalek> rakudo/glr: 

[17:11] <dalek> rakudo/glr: FOR is gone. It's just map now!

[17:11] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/592e04803f

[17:11] <moritz> nodal >> actually works

[17:11] *** Ven joined
[17:13] *** diana_olhovik_ joined
[17:13] *** MilkmanDan left
[17:14] <nine> Funny coincidence. I knew how to fix that FOR because just this morning I looked up what for compiles to when answering Ven

[17:14] <Ven> nine: I've been told my rubber ducking skills are good several times already. ;-)

[17:15] <nine> (rubber ducks)++ :)

[17:15] <Ven> (fwiw, I got that insight from ShimmerFairy++)

[17:15] <moritz> nine: fwiw the optimizer also has an occurence of the word FOR

[17:15] <moritz> might be able to change that to 'for' too, maybe

[17:15] <nine> moritz: to 'map', there is no for anymore :) It _is_ map now

[17:15] <moritz> erm, yes

[17:16] <moritz> I'll try it, but do a before/after spectest, jsut to be sure

[17:16] <nine> moritz: thanks!

[17:17] *** yqt left
[17:18] <Ven> I'm not sure how to fix the test file I had picked. I can just fix $i to be 3, but then I probably have to remove the references to the tickets? that's lost history, but since glr changes everything, does it matter?

[17:18] <moritz> Ven: what does the test do?

[17:18] <Ven> (I was about to ask "and are these tests still relevant?", but I guess the answer is always "yes" ...)

[17:18] <Ven> moritz: $i++ for $(1, 2, 3); and expect 1

[17:19] <moritz> m: my $i = 0; $i++ for $(1, 2, 3), ; say $i

[17:19] <GLRelia> rakudo-moar 592e04: OUTPUT«1␤»

[17:19] <camelia> rakudo-moar b56d59: OUTPUT«1␤»

[17:19] <moritz> Ven: ^^ that might be a way to keep the spirit of the test

[17:19] <moritz> even though the exact details are changes

[17:19] <Ven> moritz: no, because the test makes an explicit test of that .item

[17:20] <Ven> I wouldn't be testing the same thing - that's a totally different test. I mean, I can surely remove the old one and add this one

[17:20] <moritz> m: my $i = 0; $i++ for flat $(1, 2, 3), ; say $i

[17:20] <GLRelia> rakudo-moar 592e04: OUTPUT«1␤»

[17:20] <camelia> rakudo-moar b56d59: OUTPUT«1␤»

[17:21] <moritz> that's the closest you can get to observing itemization in list iteration today

[17:21] <moritz> m: my $i = 0; $i++ for flat (1, 2, 3), ; say $i

[17:21] <GLRelia> rakudo-moar 592e04: OUTPUT«3␤»

[17:21] <camelia> rakudo-moar b56d59: OUTPUT«3␤»

[17:21] <Ven> moritz: again – that's not actually what the test was meant to, imho

[17:23] <moritz> Ven: well, you can do that, or set the expectation to 3, or remove it

[17:24] <moritz> Ven: at your discretion; there's no one-size-fits-all recipe

[17:24] <Ven> moritz: I'd love your opinion... the test is t/spec/S02-types/array.rakudo.moar, 3rd test

[17:24] *** [Sno] left
[17:25] <moritz> Ven: that's already adapted.... are you in branch glr, and on the latest commit?

[17:26] <Ven> moritz: ah, I think I might've cloned a bit before your fix :-)

[17:28] *** spider-mario joined
[17:28] <moritz> Ven: git pull!

[17:28] <Ven> moritz: right :-)

[17:33] <[Coke]> I hear TimToady is going to PPW2015 - any other sixers going?

[17:34] <[Coke]> That's actually drivable for me.

[17:34] * Ven doesn't know what PPW2015 is

[17:34] <Ven> Polish Perl Workshop?

[17:35] <ugexe> pittsburgh

[17:36] <[Coke]> http://pghpw.org/ppw2015/

[17:38] *** espadrine left
[17:40] *** Ven left
[17:40] <dalek> perl6-roast-data: a1315c2 | coke++ | / (2 files):

[17:40] <dalek> perl6-roast-data: another glr run today

[17:40] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/a1315c21d3

[17:41] *** Ven joined
[17:41] <[Coke]> m: say 117267 - 117049; # since this morning.

[17:41] <GLRelia> rakudo-moar 592e04: OUTPUT«218␤»

[17:41] <camelia> rakudo-moar b56d59: OUTPUT«218␤»

[17:41] *** iGrrr joined
[17:41] <dalek> rakudo/glr: 82830e3 | moritz++ | src/Perl6/Optimizer.nqp:

[17:41] <dalek> rakudo/glr: "FOR" is gone, long live map

[17:41] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/82830e32aa

[17:41] *** MilkmanDan joined
[17:41] <moritz> [Coke]: increase in passing tests, I hope

[17:41] *** mohij joined
[17:41] *** iGrrr left
[17:43] <dalek> roast/glr: b1b1ef2 | moritz++ | integration/99problems-21-to-30.t:

[17:43] <dalek> roast/glr: Relax a type check

[17:43] <dalek> roast/glr: review: https://github.com/perl6/roast/commit/b1b1ef2b12

[17:45] <[Coke]> moritz: yes.

[17:45] <dalek> rakudo/glr: a695a58 | (Stefan Seifert)++ | src/core/Array.pm:

[17:45] <dalek> rakudo/glr: Implement type checks in Array[Type].new(...)

[17:45] <dalek> rakudo/glr: 

[17:45] <dalek> rakudo/glr: Need to create $!descriptor manually in that case as the compiler

[17:45] <dalek> rakudo/glr: doesn't seem to do it for us.

[17:45] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/a695a5888e

[17:46] <nine> powered by a really decent matcha latte

[17:46] <[Coke]> ... looks like I'll have to do another run soon. :)

[17:46] <Ven> nine++ :)

[17:46] <[Coke]> note that due to unicode shenanigans, glr is already doing better than nom-jvm. :)

[17:46] <nine> The only GLR comment in Array.pm is about method plan, and I have no idea what its purpose is.

[17:47] *** rurban joined
[17:47] <jnthn> nine: .plan should push to the end of $!future in $!todo (and if there's no todo, or no future, create it as needed)

[17:47] <jnthn> .oO( "this array has no future!" )

[17:48] <nine> I cannot find any place where this would be called?

[17:48] <laben> jnthn: what do you think about this? [18:08] <b2gills> If you think of >>OP>> as *stop* when the left is out of elements  and <<OP<< as stop when the right is out of elements then >>OP<< would be stop when either is out of elements ( and would be more tenable in a lazy list world )

[17:49] <jnthn> nine: It's a public API method

[17:50] <jnthn> laben: I think that's what Z is for :)

[17:50] <jnthn> (And Z is also lazy)

[17:50] <laben> jnthn: but Z is lazy, while >>op<< is eager

[17:51] <jnthn> Note that >>+<< on a native array will end up with a fairly different implementation eventually also, to provide access to CPU SIMD stuff

[17:51] <jnthn> And so we want semantics that'll work out well there too

[17:52] <jnthn> nine: I...hope we have tests for it ;)

[17:52] <nine> jnthn: nope, not a single one it seems

[17:52] <jnthn> eek

[17:52] <jnthn> Guess we should write some :)

[17:52] <nine> lots of hits for "plan" in t/spec, but all about test plans (or interplanetary matters)

[17:53] *** Ven left
[17:53] <nine> Folks we're down to 120 failing files

[17:53] *** TEttinger joined
[17:53] <laben> jnthn: which means? >>op<< doing the current thing (throwing if sides have different length) or the other thing (stopping at the shortest one, independent of side)?

[17:54] *** andreoss joined
[17:54] <laben> stopping at the shortest one ==> stopping when the shortest ends

[17:55] <laben> it would indeed be symmetric with <<op>> stopping when the longest one ends

[17:55] *** llfourn left
[17:56] *** andreoss left
[17:57] <jnthn> laben: I think throwing when they're not equal is the right thing here

[17:58] <jnthn> It makes you think whether the auto-exend semantics is actually the right thing

[17:58] <jnthn> *extend

[17:58] <jnthn> I guess TimToady++ will backlog this at some point and give the idea another look over though :)

[17:58] <jnthn> dinner &

[17:59] <laben> mh, but there wouldn't be an eager way to stop when the shortest one ends unless you know the side

[18:08] <masak> nine: er, can you do `next LABEL` if -n is just .map ?

[18:09] <masak> er, I mean `next LINE`

[18:17] <moritz> jnthn: the 'for range' optimization probably needs a second look; I've done s/FOR/map/, but it still looks at infix:<,> which I think we don't use anymore

[18:17] <hoelzro> o/ #perl6

[18:18] *** araujo_ joined
[18:20] *** araujo__ joined
[18:21] *** CQ2 left
[18:21] *** araujo left
[18:22] <jnthn> masak: Should work; no objections from me if you commit a patch dong that

[18:22] <jnthn> lol

[18:22] <jnthn> doing

[18:23] <jnthn> moritz: Yeah, it should be simpler :)

[18:23] *** araujo_ left
[18:23] <jnthn> I'll get to it if nobody else does :)

[18:25] <nine> masak: since for supports labels, -n should do so, too. Both are just map

[18:27] <jnthn> That said, I don't think I put labels support back into the map iterator stuff...maybe somebody else already did :)

[18:27] <jnthn> It should be an easy patch

[18:28] <nine> I think FROGGS++ did

[18:29] <nine> https://github.com/rakudo/rakudo/blob/glr/src/core/Any-iterable-methods.pm#L150

[18:30] <nine> Here: https://github.com/rakudo/rakudo/commit/0834548933cee2c835caaf0c3f850922d7463067

[18:30] <jnthn> yowser, so code duplication

[18:31] <FROGGS> nine: aye

[18:31] <jnthn> FROGGS: Is there a way we can just create a unique label that will never match and use it as the default if no label is supplied?

[18:31] <FROGGS> jnthn: do you have a better idea?

[18:31] <FROGGS> hmmm

[18:31] <jnthn> FROGGS: Or since it just compares objects, just Mu will do, no?

[18:31] <FROGGS> aye

[18:32] <jnthn> oh, and you've a nasty bug

[18:32] <FROGGS> O.o

[18:32] <jnthn> $label is a lexical

[18:32] <jnthn> And classes are not closures

[18:32] <FROGGS> ups

[18:32] <jnthn> $label needs to be given to the constructor and addressed as $!label

[18:33] <jnthn> No worries. But glad I spotted it, that woulda been a very annoying one to debug later :)

[18:33] <FROGGS> hehe, yeah :o)

[18:33] <dalek> roast/glr: 9bc2a34 | (Stefan Seifert)++ | S32-hash/perl.t:

[18:33] <dalek> roast/glr: No more <> in Hash.perl output with GLR :)

[18:33] <dalek> roast/glr: review: https://github.com/perl6/roast/commit/9bc2a343e2

[18:33] <dalek> rakudo/glr: e567788 | (Stefan Seifert)++ | src/core/EnumMap.pm:

[18:33] <dalek> rakudo/glr: Make .kv and .values on Hashes rw

[18:33] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/e567788975

[18:34] <nine> m: say (1, 2, 3) === (1, 2, 3)

[18:34] <camelia> rakudo-moar b56d59: OUTPUT«True␤»

[18:34] <GLRelia> rakudo-moar a695a5: OUTPUT«False␤»

[18:35] <nine> jnthn: is there a way to fix this? ^^^

[18:35] <jnthn> Implement WHICH in List

[18:35] <jnthn> Trouble is, it'll be inherut by Array :/

[18:36] <jnthn> Which'll then need it overriding to go on identity again

[18:36] <nine> But that would be just a couple of lines copied from Mu, wouldn't it?

[18:37] <jnthn> aye

[18:38] <jnthn> And nom branch's src/core/Parcel.pm probably has a WHICH you can draw inspiration from 

[18:38] <nine> I just copied that to start :)

[18:39] *** yqt joined
[18:39] <nine> 118 btw.

[18:39] <timotimo> so ...

[18:39] <timotimo> turns out i'm not insane

[18:39] *** araujo__ left
[18:40] <timotimo> compiling the core setting with --optimize=off gives you a core setting that explodes when loaded

[18:40] *** araujo joined
[18:40] <nine> Well, I've always heard that Perl 6 needs an optimizing compiler to really work...

[18:41] <timotimo> at least this tells me my patch towards the optimizer to get lexicalref to localref lowering back in isn't breaking that particular thing

[18:44] <nine> Wow, Parcel's implementation works unchanged! Of course, it can be optimized quite a bit.

[18:44] *** rangerprice joined
[18:44] <rangerprice> Hi

[18:48] <masak> hi, rangerprice

[18:50] <FROGGS> has somebody fixed t/spec/S16-filehandles/io.rakudo.moar?

[18:51] <dalek> rakudo/glr: acea21c | (Stefan Seifert)++ | src/ (3 files):

[18:51] <dalek> rakudo/glr: Fix (1, 2, 3) === (1, 2, 3)

[18:51] <dalek> rakudo/glr: 

[18:51] <dalek> rakudo/glr: Fixed by implementing List.WHICH. Have to override again in Array with the

[18:51] <dalek> rakudo/glr: implementation from Mu, since Array is mutable.

[18:51] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/acea21c6b5

[18:51] <nine> This fixes another 4 spec test files! Down to 114/1047 failing.

[18:51] <nine> jnthn: thanks for the hint!

[18:51] <FROGGS> \o/

[18:51] <FROGGS> nine++

[18:52] <nine> jnthn++

[18:52] *** Nlhj joined
[18:52] *** Nlhj left
[18:59] *** rangerprice left
[18:59] <nine> m: $o = 1; $o.map({ $_ = 2; }); say $o.perl;

[18:59] <GLRelia> rakudo-moar acea21: OUTPUT«5===SORRY!5=== Error while compiling /tmp/QY5zI8_ljz␤Variable '$o' is not declared␤at /tmp/QY5zI8_ljz:1␤------> 3<BOL>7⏏5$o = 1; $o.map({ $_ = 2; }); say $o.perl␤»

[18:59] <camelia> rakudo-moar b56d59: OUTPUT«5===SORRY!5=== Error while compiling /tmp/3bS1Bj_X0C␤Variable '$o' is not declared␤at /tmp/3bS1Bj_X0C:1␤------> 3<BOL>7⏏5$o = 1; $o.map({ $_ = 2; }); say $o.perl␤»

[18:59] <nine> m: my $o = 1; $o.map({ $_ = 2; }); say $o.perl;

[18:59] <GLRelia> rakudo-moar acea21: OUTPUT«Cannot assign to an immutable value␤  in block <unit> at /tmp/6G6Cj04E5u:1␤␤»

[18:59] <camelia> rakudo-moar b56d59: OUTPUT«Cannot assign to an immutable value␤  in block <unit> at /tmp/oZC3tuyipq:1␤␤»

[18:59] <nine> m: my $o = 1; $o.map(-> $i is rw { $i = 2; }); say $o.perl;

[18:59] <camelia> rakudo-moar b56d59: OUTPUT«Cannot assign to an immutable value␤  in block <unit> at /tmp/TtvMv6Z9O_:1␤␤»

[18:59] <GLRelia> rakudo-moar acea21: OUTPUT«Cannot assign to an immutable value␤  in block <unit> at /tmp/3oFcsYzjTG:1␤␤»

[19:00] <nine> m: my $pair = (a => 1); for $pair.value { $_ = 2; }; say $pair.perl;

[19:00] <camelia> rakudo-moar b56d59: OUTPUT«:a(2)␤»

[19:00] <GLRelia> rakudo-moar acea21: OUTPUT«Cannot assign to an immutable value␤  in block <unit> at /tmp/trL1nqbOOM:1␤␤»

[19:00] <moritz> my $v = 1; my $pair = (a => $v); for $pair.value { $_ = 2; }; say $pair.perl;

[19:00] <moritz> m: my $v = 1; my $pair = (a => $v); for $pair.value { $_ = 2; }; say $pair.perl;

[19:00] <GLRelia> rakudo-moar acea21: OUTPUT«Cannot assign to an immutable value␤  in block <unit> at /tmp/4sNfR3Ppeg:1␤␤»

[19:00] <camelia> rakudo-moar b56d59: OUTPUT«:a(2)␤»

[19:01] *** ChoHag left
[19:04] <nine> I'd say that's because for $pair.value is $pair.value.map which invokes Any's .list on the value which creates a List which is immutable

[19:04] <FROGGS> nine: 138 tests fail in my last spectest run

[19:04] <nine> FROGGS: that's 24 more fails than here?!

[19:05] <moritz> FROGGS: is your t/spec on the 'glr' branch?

[19:05] <FROGGS> moritz: aye

[19:06] * moritz spectests

[19:06] <FROGGS> moritz: all is on HEAD and moarvm=master,nqp=master,rakudo=glr,roast=glr

[19:06] <moritz> FROGGS: my spectest will finish soon

[19:06] <moritz> (I hope :-)

[19:06] <FROGGS> summary: https://gist.github.com/FROGGS/fe6aeb2a9cc9cd367ec6

[19:07] <moritz> yes, I also get 138 failures

[19:08] <moritz> (with recommended NQP and MoarVM versions)

[19:08] <FROGGS> t/spec/S02-literals/adverbs.rakudo.moar reveals:

[19:08] <nine>  :(

[19:08] <FROGGS> Invocant requires an instance of type List, but a type object was passed.  Did you forget a .new?

[19:08] <FROGGS>   in sub is-deeply at lib/Test.pm:454

[19:08] <FROGGS>   in block <unit> at t/spec/S02-literals/adverbs.rakudo.moar:13

[19:08] <FROGGS> nine: might just be something silly

[19:09] <nine> I'm re-running now. May have missed some when counting

[19:09] <FROGGS> Invocant requires an instance of type List, but a type object was passed.  Did you forget a .new?

[19:09] <FROGGS>    at src/gen/m-BOOTSTRAP.nqp:2961  (blib/Perl6/BOOTSTRAP.moarvm::144)

[19:09] <FROGGS>  from src/gen/m-CORE.setting:11862  (/home/froggs/dev/nqp/install/share/perl6/runtime/./CORE.setting.moarvm:WHICH:18)

[19:09] <FROGGS>  from src/gen/m-CORE.setting:2113  (/home/froggs/dev/nqp/install/share/perl6/runtime/./CORE.setting.moarvm:infix:<===>:37)

[19:09] <FROGGS> nine: ^^

[19:09] <laben> i'm getting something new from sanity tests: "t/01-sanity/99-test-basic.t" says "Parse errors: No plan found in TAP output"

[19:10] <FROGGS> seems to be List.WHICH

[19:11] <masak> a .WHICH!

[19:12] *** domidumont left
[19:12] <moritz> nine: ah, should be multi method, probably

[19:12] <nine> I get the 99-test-basic.t fail, too. Investigating...

[19:13] <moritz> m: List.WHICH

[19:13] <GLRelia> rakudo-moar acea21: OUTPUT«Invocant requires an instance of type List, but a type object was passed.  Did you forget a .new?␤  in block <unit> at /tmp/3nGARmios7:1␤␤»

[19:13] <camelia> rakudo-moar b56d59: ( no output )

[19:13] <nine> moritz: ah, of course it should be

[19:13] <FROGGS> testing...

[19:14] <dalek> rakudo/glr: 0659059 | moritz++ | src/core/List.pm:

[19:14] <dalek> rakudo/glr: make WHICH a multi method

[19:14] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/0659059cc1

[19:14] *** rangerprice joined
[19:15] <moritz> it compiles

[19:15] <FROGGS> aye, looks good

[19:15] <rangerprice> Hi

[19:15] <moritz> which means it's likely an improvement

[19:16] <moritz> the "make test" failure is now gone

[19:16] <moritz> only t/04-nativecall/16-rt125408.t remaining

[19:16] <laben> sanity fixed, confirmed

[19:17] <laben> m: List.WHICH

[19:17] <GLRelia> rakudo-moar 065905: ( no output )

[19:17] <camelia> rakudo-moar b56d59: ( no output )

[19:19] <nine> Soo...how many spec test file failures do you get with this fix?

[19:19] <nine> It's 115 here

[19:19] <moritz> still running

[19:20] <moritz> 114 here

[19:20] <moritz> probably the lock.t flapper, or something

[19:21] <nine> Yep. I've seen 114 here before

[19:21] <moritz> FROGGS++ # noticing the regression

[19:22] <nine> FROGGS++ indeed! That timely report made it quite easy to pinpoint

[19:22] <dalek> perl6-roast-data: 4e98745 | coke++ | / (2 files):

[19:22] <dalek> perl6-roast-data: another glr run for today

[19:22] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/4e987453b2

[19:22] <FROGGS> nine / moritz: down to 115 here

[19:23] *** vendethiel joined
[19:24] <laben> testing ecosystem... File::Find and Shell::Command work fine without patches for glr (i closed my PRs), panda works with patches, XML and others seem fine

[19:24] <[Coke]> https://github.com/coke/perl6-roast-data/blob/master/log/rakudo.moar-glr_summary.out has a bunch of TODO PASSED that might be unfudgeable.

[19:25] * masak .oO( [unfudge]-able )

[19:26] <[Coke]> 1668 individual test failures (not file) on the last run i did.

[19:26] *** mr-foobar joined
[19:27] <[Coke]> set, mixhash, and baghash have a large number of aborted tests.

[19:27] *** agaurav77 joined
[19:28] <[Coke]> S32-array/splice.rakudo.moar aborted 301 test(s)

[19:28] <agaurav77> Hi everyone, I'd like to contribute to Perl6, what should I do to get started?

[19:28] <moritz> agaurav77: what would you like to do? write mdoules? write docs? enhance the compiler? organize a conference?

[19:29] <[Coke]> agaurav77: do you know Perl5? C? Java?

[19:29] <masak> agaurav77: cool! my tip is to start small. do something you like. experiment. ask questions.

[19:29] <dalek> roast/glr: f2d05fa | moritz++ | S03-operators/value_equivalence.t:

[19:29] <dalek> roast/glr: unTODO a now passing test

[19:29] <dalek> roast/glr: review: https://github.com/perl6/roast/commit/f2d05fa4e1

[19:29] <masak> agaurav77: believe it or not, that will help a lot.

[19:29] <agaurav77> uhm, I'm a bit familiar with Perl5

[19:29] <masak> agaurav77: if you highlight pain points, things that are tricky to understand right now, we'd be grateful.

[19:29] <agaurav77> sure

[19:30] *** MilkmanDan left
[19:30] <agaurav77> first off, what kind of VCS do you use? git or hg?

[19:30] <laben> unfugde ==> defudge?

[19:30] <[Coke]> mostly git.

[19:30] <moritz> laben: yes

[19:30] <agaurav77> cool :)

[19:30] <[Coke]> laben: yes.

[19:30] *** MilkmanDan joined
[19:31] <agaurav77> I'd like to enhance the compiler and (maybe) write modules, though I'm unsure of the latter

[19:31] <FROGGS> moritz: is there a reason why glr-test-failures-annotated is only 107 lines long?

[19:31] <agaurav77> I had a project with NaCl about porting Perl5 to Chrome

[19:31] *** rurban_ left
[19:31] <masak> agaurav77: if you'd like to contribute to the compiler, then there's a rich ticket queue at RT to look at.

[19:31] <agaurav77> so I guess I can help wit that

[19:31] <agaurav77> oh okay

[19:32] <agaurav77> where's RT btw?

[19:32] <masak> https://rt.perl.org

[19:33] <masak> there's a perl6 queue on there. with ~1k new/open tickets.

[19:33] <agaurav77> okay, cool

[19:33] <agaurav77> thanks for the help :)

[19:34] <masak> anytime.

[19:34] <agaurav77> do you guys have an IRC channel at irc.perl.org as well?

[19:34] <laben> i would say starting with the compiler while not knowing perl6 to be a bit too hard, maybe?

[19:35] <FROGGS> agaurav77: no, only here

[19:35] <masak> agaurav77: no, it's here on freenode for historical reasons.

[19:35] <agaurav77> ah, np

[19:36] *** [Sno] joined
[19:37] <rangerprice> https://i.imgur.com/Gu6bBV1.png

[19:37] *** Ven joined
[19:38] <moritz> my @a = 1, 2, 3; say array[int].new(@a)

[19:38] <moritz> m: my @a = 1, 2, 3; say array[int].new(@a)

[19:38] <GLRelia> rakudo-moar 065905: OUTPUT«1 2 3␤»

[19:38] <camelia> rakudo-moar b56d59: OUTPUT«1 2 3␤»

[19:38] *** muraiki joined
[19:39] <dalek> rakudo/glr: 9288825 | (Stefan Seifert)++ | src/core/native_array.pm:

[19:39] <dalek> rakudo/glr: Fix endless loop trying to assign an infinite list to a native array

[19:39] <dalek> rakudo/glr: 

[19:39] <dalek> rakudo/glr: method infinite is all but gone. Check for is-lazy instead to throw an

[19:39] <dalek> rakudo/glr: appropriate exception.

[19:39] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/9288825c2c

[19:39] <dalek> roast/glr: 572075c | (Stefan Seifert)++ | S32-array/splice.t:

[19:39] <dalek> roast/glr: Unlock a whole lot of S32-array/splice.t tests

[19:39] <dalek> roast/glr: 

[19:39] <dalek> roast/glr: Just need some explicit flattening when preparing the test data.

[19:39] <dalek> roast/glr: review: https://github.com/perl6/roast/commit/572075c439

[19:39] <masak> the splice must flow!

[19:40] <DrForr> I take it $*WARNINGS from the old synopsis is gone?

[19:40] *** agaurav77 left
[19:41] <masak> DrForr: I think it's NYI, and might never be.

[19:41] <moritz> nine: there are still several remaining .infinite calls

[19:41] <DrForr> Good, happy to hear that it's deprecated with prejudice :)

[19:41] *** [Sno] left
[19:41] <moritz> I'll try to remove some

[19:42] <masak> DrForr: to be specifics, there is currently not really a -w to turn off :) nor will there ever be, probably

[19:42] <masak> specific*

[19:42] *** Ven left
[19:42] <DrForr> I believe +1 is my comment there :)

[19:42] *** [Sno] joined
[19:44] <sjn>    ^H^H^H

[19:45] <masak> sjn: 

[19:45] <sjn> ^^

[19:45] <masak> (don't mind us, we're using black ink to communicate.)

[19:45] <masak> er, transparent ink. whatever.

[19:45] <sjn> what a coincidence! I'm too! :D

[19:45] <masak> "black ink" is only funny if your terminal background is black, I guess.

[19:46] <labster> black ink with opacity: 0

[19:46] <masak> that's one of my favorite opacities

[19:47] <dalek> rakudo/glr: 1e5019c | moritz++ | src/core/ (2 files):

[19:47] <dalek> rakudo/glr: More s/infinite/is-lazy/

[19:47] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/1e5019c32c

[19:47] <sjn> Having said that,           

[19:47] <sjn> 'nuff said.

[19:47] <dalek> roast/glr: 8cf16fd | moritz++ | S09-typed-arrays/native- (2 files):

[19:47] <dalek> roast/glr: s/infinite/is-lazy/ in native array tests

[19:47] <dalek> roast/glr: review: https://github.com/perl6/roast/commit/8cf16fdbfe

[19:48] <labster> .u         

[19:48] <yoleaux> Search for a Unicode character by codepoint, name, or raw character

[19:49] <moritz> uhm, Range has an attribute(!) $.infinite that's always set to False

[19:49] <moritz> wtf?

[19:50] <jnthn> Kill it!

[19:50] <moritz> willdo

[19:51] *** llfourn joined
[19:52] <dalek> rakudo/glr: cfc79e2 | moritz++ | src/core/ (2 files):

[19:52] <dalek> rakudo/glr: Kill Range.infinite in favor of is-lazy

[19:52] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/cfc79e24ac

[19:54] <timotimo> who has articles to link to for the weekly?

[19:54] <moritz> uhm, did I just break the build?

[19:55] *** AlexDani` joined
[19:55] *** AlexDaniel left
[19:56] <dalek> rakudo/glr: 043ddc7 | moritz++ | src/core/ (2 files):

[19:56] <dalek> rakudo/glr: Revert "Kill Range.infinite in favor of is-lazy"

[19:56] <dalek> rakudo/glr: 

[19:56] <dalek> rakudo/glr: This reverts commit cfc79e24ac11e8d35d2e24a72eeb17e3b708242e.

[19:56] <dalek> rakudo/glr: Because it broke the build :(

[19:56] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/043ddc71b4

[19:56] *** llfourn left
[19:57] <moritz> oh, it wasn't always false

[19:57] <moritz> now I understand

[19:57] <_itz> timotimo: I noticed a couple of new slide decks on https://www.reddit.com/r/perl6/

[19:58] <timotimo> ah, right, YAPC::Asia was happening, right?

[19:58] <moritz> ranges .infinite is actually about infinity, not just laziness

[19:58] <moritz> I'll add is-lazy as an alias for .infinite now

[19:59] <_itz> is "Kruthik Dhillon" a pseudonym?

[20:02] *** mjgardner left
[20:04] <_itz> timotimo: you could also put my https://www.youtube.com/watch?v=BQfP5o_0YzY in the weekly

[20:04] *** mjgardner joined
[20:07] <_itz> https://twitter.com/ultimatto has a nice one liner

[20:08] <_itz> `gotty -w perl6 --setting=RESTRICTED`  with GoTTY - Share your terminal as a web application

[20:08] *** espadrine joined
[20:10] <dalek> roast/glr: 32208a6 | moritz++ | integration/99problems-11-to-20.t:

[20:10] <dalek> roast/glr: Relax a type check

[20:10] <dalek> roast/glr: review: https://github.com/perl6/roast/commit/32208a6c19

[20:10] *** xfix left
[20:10] <timotimo> _itz: the audio on that recording isn't terribly good, is it? ;_;

[20:11] <timotimo> certainly too quiet for my weaksauce laptop speakers

[20:12] <dalek> perl6-roast-data: 9daf684 | coke++ | / (2 files):

[20:12] <dalek> perl6-roast-data: another glr run for today

[20:12] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/9daf684179

[20:12] <_itz> timotimo: no it was pretty awful just done on sue's mobile

[20:14] <timotimo> damn :(

[20:14] <_itz> we tried another version at https://www.youtube.com/watch?v=BQfP5o_0YzY but it probably isn't much better

[20:14] <dalek> roast/glr: efc399f | moritz++ | integration/99problems-41-to-50.t:

[20:14] <dalek> roast/glr: Add some flattening to gray code functions

[20:14] <dalek> roast/glr: 

[20:14] <dalek> roast/glr: still does not pass, but gets fruther than before

[20:14] <dalek> roast/glr: review: https://github.com/perl6/roast/commit/efc399fb35

[20:14] <[Coke]> jnthn: btw, glr branch now at 98.69% of nom.

[20:14] <timotimo> i wonder if it would have helped any if you had been recording audio from your laptop, as it's much closer to you

[20:15] <timotimo> _itz: that's the exact same link :)

[20:15] <dalek> rakudo/glr: 7bc1a99 | moritz++ | src/core/ (4 files):

[20:15] <dalek> rakudo/glr: More thorougly replace .infinite with .is-lazy

[20:15] <dalek> rakudo/glr: 

[20:15] <dalek> rakudo/glr: only Range.infinite remains, because there it actually is about infinity

[20:15] <dalek> rakudo/glr: rather than laziness

[20:15] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/7bc1a99ad9

[20:15] *** darutoko left
[20:15] *** espadrine left
[20:15] *** brrt joined
[20:16] <_itz> sorry I meant https://www.youtube.com/watch?v=FEGKzaEhhZs

[20:16] <_itz> I did try processing the audio but you can't really make a purse from a sow's ear

[20:16] *** diana_olhovik_ left
[20:17] <masak> I imagine a sow's ear could store coins quite well

[20:18] *** amurf joined
[20:18] <_itz> actually it should have been "silk purse" :)

[20:18] <timotimo> yeah, that's much louder at least ;)

[20:19] <_itz> and http://historywired.si.edu/object.cfm?ID=535 says you can

[20:20] *** virtualsue joined
[20:21] <timotimo> i won't be giving a talk during SPW, but do we have some kind of recording setup ready to go?

[20:21] <timotimo> _itz: what kind of fixture did you use for holding the phone still?

[20:22] *** amurf left
[20:22] <timotimo> _itz: regretfully, the slides are not easy to make out once it gets to code and the video description doesn't have a link to the slide set :(

[20:23] *** nowan left
[20:23] <_itz> timotimo: ~20EU amazon iphone stand

[20:23] <timotimo> ah, hehe

[20:23] *** zakharyas joined
[20:24] <_itz> we figured (maybe wrongly) any sort of video was better than none

[20:24] <timotimo> that's right

[20:24] <_itz> and the links are in the comments

[20:24] <timotimo> oh! but only for the non-enhanced version

[20:24] <timotimo> (which is what i'm looking at now)

[20:24] <_itz> FEGKzaEhhZs has same links

[20:25] <_itz> I think you have to click more or similar

[20:25] <timotimo> my head's currently formulating an idea where you'd click the corners of the projection area and annotate the video with when exactly the slides get switched back/forth and then providing the slide set would give you a higher quality video with the slides projected into the scenery "in post" :P

[20:25] *** brrt left
[20:26] <_itz> I did think of putting the audio on video of slides but I'm not really a video editor person

[20:27] <timotimo> oh, that's not so difficult ... except the program i'd be suggesting is kdenlive which is super crashy

[20:28] *** virtualsue left
[20:28] <timotimo> if you had set the license to a CC license instead of youtube standard license, i could use their online video editor to remix it and see what that thing can do :)

[20:28] <_itz> I was pretty much swearing at iMovie and I thought the Mac was supposed to be easy with video

[20:28] *** telex left
[20:29] <timotimo> https://www.youtube.com/editor - this thing can probably help you very well

[20:29] *** KCL joined
[20:29] <timotimo> it has an "add photos" thing, there's probably some nice little tool to turn a pdf into "screen shots" of the individual pages

[20:30] *** zakharyas left
[20:30] <nine> jnthn: array.new takes *@values while Array.new takes **@values. Which one is right?

[20:30] <nine> .tell jnthn array.new takes *@values while Array.new takes **@values. Which one is right?

[20:30] <yoleaux> nine: I'll pass your message to jnthn.

[20:30] *** telex joined
[20:30] * _itz asks virtualsue to set to CC

[20:30] <jnthn> **

[20:30] <yoleaux> 20:30Z <nine> jnthn: array.new takes *@values while Array.new takes **@values. Which one is right?

[20:31] <timotimo> the youtube editor doesn't support pdf as "photos" for upload, sadly

[20:31] <moritz> is array multi-dimensional?

[20:31] <_itz> I can probably screenshot to png

[20:31] <timotimo> awesome, imagemagick can do what we want

[20:32] *** KCL_ left
[20:32] <timotimo> now i've got the png files

[20:32] <timotimo> want?

[20:33] <_itz> timotimo: she claims its CC now .. although I can't see that anywhere obviousily

[20:33] <timotimo> it's going to take a few minutes probably

[20:34] <timotimo> https://drive.google.com/folderview?id=0B8yK-7P1LN8SflBvNEMyWVlMM2djeGZTOG91S2NwQ25NVGVzRi1ZNjZjWUc1cHFsblIxMW8&usp=sharing

[20:35] <laben> nine: i think i fixed the bug with non-dwimmy hypers with this https://gist.github.com/7de488bc83a3eee77948 which passes spectest and my own test

[20:35] <laben> nine: sorry if there are some spurious changes in between

[20:35] <timotimo> there it is

[20:35] <timotimo> _itz: you can see it below the description: Creative Commons Attribution licence (reuse allowed) - directly with a "remix this video" button below

[20:35] <timotimo> you have to "show more", though

[20:36] <_itz> ah yes

[20:36] <timotimo> hum. i don't see a way to use the video as audio only

[20:37] *** virtualsue joined
[20:38] <timotimo> at least then you can zoom in on the video to the bottom right and see almost exactly when the slides move

[20:40] <_itz> grrr I probably need to use chrome this googleware never works in other browsers 100%

[20:40] <timotimo> ;(

[20:40] <pyrimidine> timotimo: are you working on the IPython kernel for perl6?

[20:40] <pyrimidine> just curious.  It's mentioned on the Jupyter page: https://github.com/ipython/ipython/wiki/IPython-kernels-for-other-languages

[20:40] <moritz> mplayer -vo null -ao pcm:file=autput.wav input.video

[20:41] <timotimo> pyrimidine: i did a long time ago and just half an hour ago i was reminded that it'd be great to work on it again now that we have proper async i/o and threads

[20:41] <timotimo> pyrimidine: are you interested in helping out?

[20:42] <pyrimidine> timotimo: np. Just happened to see it when I set up IPython locally

[20:42] <timotimo> OK

[20:42] <timotimo> ipython is fantastic, i must say

[20:42] <pyrimidine> timotimo: yes, may be.  and agreed, it is very nice :)

[20:43] <timotimo> _itz: sadly, the youtube editor isn't nonlinear which (as far as i understand it) is why it only allows one audio and one video track at a time

[20:43] <timotimo> so when you pull in the images, you'll lose the easy display of when to put the slides in >:(

[20:44] <pyrimidine> timotimo: they have noticeably split it out into it's own thing now (Jupyter), more language-agnostic (well, except the back end)

[20:44] <pyrimidine> might be able to help here and there BTW

[20:45] <timotimo> right

[20:45] *** muraiki left
[20:45] <_itz> yeah I was hoping to drop in images but can't see a way of doing that either

[20:45] <timotimo> dropping in images is easy, but it has to be before or after another object

[20:45] <timotimo> top right has a camera icon where you can upload pictures or choose from your photo albums

[20:46] <_itz> I think I'd have to break up the one video into as many as slides

[20:46] *** rangerprice left
[20:46] <_itz> I could use a stop watch and ffmpeg

[20:46] <_itz> or give up :)

[20:47] <timotimo> might as well, to be honest :|

[20:47] * timotimo resumes work on the p6weekly

[20:48] <timotimo> there's a typo in your Purl grammar :(

[20:48] <timotimo> an unmatched ")" in token TOP

[20:49] <_itz> in the src or slide? or both?

[20:51] *** llfourn joined
[20:51] <timotimo> i'm only looking at the pdf right now

[20:52] <jnthn> 'night, #perl6

[20:52] <timotimo> gnite jnthn, rest well this time! :)

[20:52] <laben> \o jnthn

[20:53] <_itz> its the slide only .. I think I generated it from a WIP rather than the original :/

[20:53] <_itz> thanks for the heads up

[20:53] <timotimo> OK

[20:54] <_itz> it was shown to work later in the video which you could see if the quality wasn't so poor ;)

[20:54] <_itz> honest

[20:54] *** AlexDani` is now known as AlexDaniel

[20:55] *** skids left
[20:56] *** llfourn left
[20:57] *** pmurias joined
[21:00] <_itz> timotimo: its corrected now anyway

[21:01] <dalek> nqp/js: ac04dbc | (Pawel Murias)++ | src/vm/js/QAST/Compiler.nqp:

[21:01] <dalek> nqp/js: Improve handling of QAST::Regex subrule nodes with the method name in a QAST::SVal.

[21:01] <dalek> nqp/js: review: https://github.com/perl6/nqp/commit/ac04dbcf53

[21:01] <dalek> nqp/js: 2607ba4 | (Pawel Murias)++ | / (2 files):

[21:01] <dalek> nqp/js: Implement and test returning from nested blocks.

[21:01] <dalek> nqp/js: review: https://github.com/perl6/nqp/commit/2607ba404b

[21:01] <dalek> nqp/js: a2b3be9 | (Pawel Murias)++ | / (2 files):

[21:01] <dalek> nqp/js: Implement and test last in for loops.

[21:01] <dalek> nqp/js: review: https://github.com/perl6/nqp/commit/a2b3be9eea

[21:01] <dalek> roast/glr: be0847f | (Stefan Seifert)++ | S32-array/splice.t:

[21:01] <dalek> roast/glr: Fix the rest of the S32-array/splice.t tests

[21:01] <dalek> roast/glr: 

[21:01] <dalek> roast/glr: Array.new is non-flattening, so we need to interpolate the argument lists manually.

[21:01] <dalek> roast/glr: review: https://github.com/perl6/roast/commit/be0847fe1f

[21:02] *** nowan joined
[21:02] <masak> 'night, #perl6

[21:02] <laben> \o masak

[21:04] <nine> laben: thanks, I'll have a closer look tomorrow

[21:07] <dalek> rakudo/glr: 582c1f7 | moritz++ | src/core/List.pm:

[21:07] <dalek> rakudo/glr: GLRify List.combinations(Range)

[21:07] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/582c1f7453

[21:09] *** kaare_ left
[21:11] <nine> moritz: do you really need the flat? ^^^ for $range should already iterate over the range

[21:12] <moritz> nine: probably not

[21:12] <nine> m: my $r = 1 .. 10; for $r.min .. ($r.max min 8) -> $i { say $i; }

[21:12] <GLRelia> rakudo-moar 582c1f: OUTPUT«1␤2␤3␤4␤5␤6␤7␤8␤»

[21:12] <camelia> rakudo-moar b56d59: OUTPUT«1␤2␤3␤4␤5␤6␤7␤8␤»

[21:12] <nine> m: my $r = 1 .. 10; for flat $r.min .. ($r.max min 8) -> $i { say $i; }

[21:12] <GLRelia> rakudo-moar 582c1f: OUTPUT«1␤2␤3␤4␤5␤6␤7␤8␤»

[21:12] <camelia> rakudo-moar b56d59: OUTPUT«1␤2␤3␤4␤5␤6␤7␤8␤»

[21:12] <nine> So, enough for today. Good night!

[21:12] <laben> \o nine

[21:12] <moritz> good night nine 

[21:13] <jdv79> nite

[21:13] <laben> it's best if i go to bed myself, good rest|work #perl6

[21:14] *** laben left
[21:14] <dalek> rakudo/glr: d7ab329 | moritz++ | src/core/List.pm:

[21:14] <dalek> rakudo/glr: Remove cargo-culted "flat", nine++

[21:14] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/d7ab329859

[21:16] <dalek> roast/glr: 6d9eef2 | moritz++ | S02-types/mixhash.t:

[21:16] <dalek> roast/glr: No need to grow a .tree here

[21:16] <dalek> roast/glr: review: https://github.com/perl6/roast/commit/6d9eef2ea4

[21:20] *** trnh joined
[21:20] *** pyrimidine left
[21:20] *** pyrimidine joined
[21:25] *** YuviPanda joined
[21:26] <YuviPanda> hello

[21:26] <YuviPanda> if I've an open socket

[21:26] <YuviPanda> how do I find the port on the client side the socket is using?

[21:29] <hoelzro> YuviPanda: hello!

[21:29] <YuviPanda> heya!

[21:29] <hoelzro> IIRC, $sock.local_address *should* work, but looks to be NYI

[21:30] * YuviPanda shared a car ride with sjn, who talked about perl6 almost the entire time. I've been a bit hooked since

[21:30] <YuviPanda> ah, damn.

[21:30] <timotimo> oh, yeah, the method "accept" of IO::Socket::INET only sets the internal PIO attribute to the received socket

[21:31] <timotimo> but it doesn't do any introspection whatsoever to make sure attributes are set up correctly

[21:31] <YuviPanda> oh well. I'll find other things to test the simple Identd client I'm building (just to play around the language)

[21:31] <YuviPanda> also, how would I have found this out?

[21:31] <YuviPanda> http://doc.perl6.org/type/IO::Socket::INET doesn't have any of this

[21:32] <hoelzro> YuviPanda: I discovered it by opening the source, but that's LTA

[21:32] <timotimo> i looked at the implementation of the socket, hold no a sec

[21:32] * hoelzro holds his no's

[21:32] <timotimo> https://github.com/rakudo/rakudo/blob/nom/src/core/IO/Socket/INET.pm#L113

[21:32] <YuviPanda> LTA?

[21:32] <hoelzro> "Less Than Awesome"

[21:32] <timotimo> method accept and the next two methods

[21:32] <YuviPanda> ah, ok :)

[21:32] <YuviPanda> ah, right. the empty bits

[21:33] <hoelzro> there should probably be logic on connect() to set the local address too

[21:33] <YuviPanda> so next time I'm curious I'll try to look at the source as well

[21:33] <hoelzro> or rather, !initialize

[21:33] <hoelzro> src/core/* is pretty friendly

[21:33] <hoelzro> not to mention authoritative =)

[21:33] <YuviPanda> right :)

[21:33] <dalek> perl6-roast-data: fdb4574 | coke++ | / (2 files):

[21:33] <dalek> perl6-roast-data: another glr run for today

[21:33] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/fdb4574af8

[21:34] <timotimo> "pretty friendly"?  ...   well, in some places

[21:34] <timotimo> it does contain a bunch of low-level operations (the ones with nqp:: in front)

[21:34] <timotimo> and many times choices were made for performance reasons

[21:34] <hoelzro> timotimo: ok, fair enough; as long as you don't have too many NQP ops

[21:34] <timotimo> hah

[21:34] <hoelzro> it's better than Perl6::Grammar, though =)

[21:34] <ShimmerFairy> P6 and NQP code is generally easier to read than VM-level code, I find :)

[21:34] <timotimo> and if you're operating very close to the beginning of the resulting core setting code, you'll have to be prepared for things just missing

[21:35] <YuviPanda> fair enough, I guess

[21:47] <timotimo> it's a surreal experience to try to define a subroutine near the beginning, but can't let it take a native int as parameter because the "int" type hasn't been defined yet

[21:49] <YuviPanda> heh, that sounds fun :)

[21:49] <YuviPanda> so when I'm setting up Actions for a Grammar

[21:49] <YuviPanda> do they need to cover all the tokens / rules?

[21:49] *** Gardner joined
[21:49] <timotimo> nope, only those that exist will be called

[21:49] *** mjgardner left
[21:49] <YuviPanda> hmm, so how is the output ast formatted?

[21:50] <timotimo> formatted?

[21:50] <YuviPanda> aaah

[21:50] <YuviPanda> so I need to call make

[21:51] <YuviPanda> constructed, even. if I don't have one for TOP

[21:51] <YuviPanda> (sorry, flaky connection)

[21:51] <timotimo> right, "make" will attach whatever you give it to the $/'s .ast attribute

[21:51] <timotimo> (alternatively accessible as .made)

[21:51] <timotimo> if you don't call make for TOP's $/, it won't have a .ast/.made

[21:51] <timotimo> but nested matches can still have an ast set on them that you can go dig up after the fact

[21:52] <YuviPanda> right, that makes sense

[21:54] <ShimmerFairy> YuviPanda: actions tend to construct larger "make"d things from what you can get from subrules. For example, if you have  token Pair { <key> " kv " <value> }  , then the resulting action method might be  method Pair($/) { my $pair = $<key>.ast => $<value>.ast; make $pair }

[21:57] <YuviPanda> right

[21:57] <YuviPanda> ShimmerFairy: so http://paste.debian.net/304642/ is a fairly decent way to write that grammar and actions?

[21:57] <YuviPanda> (first perl6 program I've ever written, be gentle... :))

[21:58] <YuviPanda> would be nice to simplify the 'payload' action

[21:59] <timotimo> you could "make $<error>.ast // $<answer>.ast i believe

[22:00] <YuviPanda> what's the // operator?

[22:00] <timotimo> defined-or

[22:00] <timotimo> it'll give you the first defined argument, or if no argument is defined the last argument

[22:01] <ShimmerFairy> YuviPanda: the only change I'd really recommend is  ~$/<username>  in method answer, if you meant to make a string

[22:01] <timotimo> oh, yes

[22:01] * YuviPanda googles

[22:02] <YuviPanda> Nice

[22:03] * YuviPanda tests

[22:04] <dalek> perl6-roast-data: d365ab7 | coke++ | bin/git.p5:

[22:04] <dalek> perl6-roast-data: stable order for fetching

[22:04] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/d365ab7630

[22:07] *** vendethiel left
[22:08] *** amurf joined
[22:10] *** khw left
[22:11] <YuviPanda> is $<X> a shortcut for $/<X>?

[22:11] <ShimmerFairy> yes :)

[22:12] *** amurf left
[22:12] <YuviPanda> sweet :)

[22:13] <ShimmerFairy> And $0 is a shortcut for $/[0] , for () captures

[22:13] <YuviPanda> right

[22:14] <YuviPanda> is it, uh, discouraged to use the shortcut vs teh more explicit $/<> version?

[22:14] <ShimmerFairy> YuviPanda: that's why action methods almost always have $/ as their parameter, so you can use those shortcuts. If you picked a different name, like  method my-token($a)  , then it'd have to be a bunch of $a<subrule>s everywhere

[22:14] <ShimmerFairy> YuviPanda: no, in fact it's more common to see people leave out the / for $<subrule> :)

[22:15] <YuviPanda> Ah I see. 

[22:15] <YuviPanda> So both of those make sense now :)

[22:18] <timotimo> i've put a $/ name on a parameter in the past just to get the nice syntax even if i'm not passing in match objects

[22:21] *** pmurias left
[22:22] *** skids joined
[22:27] *** araujo_ joined
[22:28] *** araujo_ left
[22:29] *** araujo_ joined
[22:30] *** araujo left
[22:30] *** araujo_ left
[22:31] *** araujo_ joined
[22:36] *** rindolf left
[22:39] *** salva left
[22:46] <dalek> rakudo/nom: f7cfe9d | PerlJam++ | src/core/IO/Notification.pm:

[22:46] <dalek> rakudo/nom: Use full path in IO::Notification

[22:46] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/f7cfe9d422

[22:50] *** virtualsue left
[22:51] <YuviPanda> ShimmerFairy: got it to http://paste.debian.net/304646/ which seems good except for not splitting out the parsing into a testable separate method, I guess

[22:52] *** llfourn joined
[22:53] <ShimmerFairy> YuviPanda: if you mean testing separate pieces of the grammar, you can leave out the :actions adverb (which just means .ast/.made won't do anything useful), and the :rule("request") adverb (or :rule<request> for short) would let you parse the string using the "request" rule, for example.

[22:57] *** llfourn left
[22:58] <ShimmerFairy> I should clarify, using .ast/.made on the result of Grammar.parse() won't return anything useful if you have no :actions or anything else that can 'make' in whatever :rule you use (which is by default TOP if you have no :rule in the parse call)

[23:00] <YuviPanda> right

[23:00] <YuviPanda> what do you mean by 'parse the string using the request rule'

[23:01] *** amurf joined
[23:01] <ShimmerFairy> YuviPanda: MyGrammar.parse("some string", :rule<request>)  would let you parse "some string" starting with the 'request' rule, instead of the 'TOP' rule by default. Useful for testing parts of your grammar, for example.

[23:02] *** RabidGravy left
[23:03] <ShimmerFairy> m: grammar G { token TOP { <subrule> "---" <subrule> }; token subrule { \d+ \. \d+ } }; say G.parse("1.2---2.3");  say G.parse("0.6", :rule<subrule>);

[23:03] <GLRelia> rakudo-moar d7ab32: OUTPUT«｢1.2---2.3｣␤ subrule => ｢1.2｣␤ subrule => ｢2.3｣␤｢0.6｣␤»

[23:03] <camelia> rakudo-moar b56d59: OUTPUT«｢1.2---2.3｣␤ subrule => ｢1.2｣␤ subrule => ｢2.3｣␤｢0.6｣␤»

[23:04] <YuviPanda> aaaah

[23:04] <YuviPanda> I see what you mean

[23:04] <YuviPanda> right

[23:04] <YuviPanda> so that'll let me test individual parts of the grammar

[23:04] <YuviPanda> nice!

[23:04] <YuviPanda> I was more mentioning that the query method does both the Socket stuff and the parsing, making it hard to test just the parsing with a unit test

[23:06] <ShimmerFairy> Yeah, I figured after a bit. That could be remedied by having a socket-using method that returns the string, and then a method that handles the parsing of a string, though I'm not sure if you'd want the bare string to returned to the user

[23:06] <ShimmerFairy> (but then again, there's always the possibility of a third method that neatly handles using those first two for the user ☺)

[23:07] <YuviPanda> yup, a small internal method that just does the string, and a small internal method that just does the parsing

[23:07] <YuviPanda> ShimmerFairy: so calling it 'my class ResponseParserActions' works, but not 'my class ResponseParser::Actions'

[23:08] <YuviPanda> Could not find symbol '&Actions' in method query at Client.pm6:75

[23:08] <YuviPanda> is what I get

[23:08] <YuviPanda> which sounds fairly confusing

[23:08] <YuviPanda> (perl6 hasn't been great so far in terms of error messages...)

[23:08] <ShimmerFairy> the ::Actions version should work IIRC, that's weird

[23:08] <YuviPanda> http://paste.debian.net/304656/

[23:08] <YuviPanda> is the code with ::Actions

[23:09] <ShimmerFairy> YuviPanda: the package-name error "Could not find symbol" is among one of the worse error messages, that's true :(

[23:09] <YuviPanda> should I need to Nest the ::Actions inside the ResponseParser grammar?

[23:09] <ShimmerFairy> let me check, I recall doing ::Actions and ::Grammar for stuff before without issue.

[23:11] <dalek> rakudo-star-daily: 406c50b | coke++ | log/ (9 files):

[23:11] <dalek> rakudo-star-daily: today (automated commit)

[23:11] <dalek> rakudo-star-daily: review: https://github.com/coke/rakudo-star-daily/commit/406c50b49c

[23:11] <YuviPanda> ShimmerFairy: ok!

[23:13] <dalek> perl6-roast-data: 3bef519 | coke++ | / (2 files):

[23:13] <dalek> perl6-roast-data: another glr run for today

[23:13] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/3bef519e17

[23:15] <YuviPanda> ShimmerFairy: http://paste.debian.net/304657/ works

[23:15] <YuviPanda> if I call the Grammar a ::Grammar

[23:15] <YuviPanda> so looks like the Actions class can't just nest inside the grammar?

[23:15] <ShimmerFairy> m: class C { class G::Actions { method TOP($/) { make "A-OK!" } }; my grammar G { token TOP { foobar } }; method doit {say G.parse("foobar", :actions(G::Actions)).ast} }; C.doit

[23:15] <camelia> rakudo-moar b56d59: OUTPUT«Could not find symbol '&Actions'␤  in method doit at /tmp/_5RQ7dG6Sl:1␤  in block <unit> at /tmp/_5RQ7dG6Sl:1␤␤Actually thrown at:␤  in method doit at /tmp/_5RQ7dG6Sl:1␤  in block <unit> at /tmp/_5RQ7dG6Sl:1␤␤»

[23:15] <GLRelia> rakudo-moar d7ab32: OUTPUT«Could not find symbol '&Actions'␤  in method doit at /tmp/VeG99SM_dL:1␤  in block <unit> at /tmp/VeG99SM_dL:1␤␤Actually thrown at:␤  in method doit at /tmp/VeG99SM_dL:1␤  in block <unit> at /tmp/VeG99SM_dL:1␤␤»

[23:15] <ShimmerFairy> m: class C { class G::Actions { method TOP($/) { make "A-OK!" } }; grammar G { token TOP { foobar } }; method doit {say G.parse("foobar", :actions(G::Actions)).ast} }; C.doit

[23:15] <GLRelia> rakudo-moar d7ab32: OUTPUT«A-OK!␤»

[23:15] <camelia> rakudo-moar b56d59: OUTPUT«A-OK!␤»

[23:16] <ShimmerFairy> YuviPanda: looks like the issue is having either the class or grammar declared with 'my' inside a class. Which is almost certainly a bug :)

[23:16] <YuviPanda> wheee!

[23:16] <YuviPanda> I found a perl6 bug!

[23:18] <YuviPanda> ShimmerFairy: can you report it for me? :)

[23:18] <ShimmerFairy> and yeah, it seems to have no issues with a 'my class Name' and 'my class Name::Subname' inside a class, so it's some weird package handling screw-up :)

[23:18] * YuviPanda has got to go to sleep soon

[23:18] <ShimmerFairy> m: class C { my grammar G { token TOP { foobar }; my class G::Actions { method TOP($/) { make "A-OK!" } }; }; method doit {say G.parse("foobar", :actions(G::Actions)).ast} }; C.doit

[23:18] <GLRelia> rakudo-moar d7ab32: OUTPUT«A-OK!␤»

[23:18] <camelia> rakudo-moar b56d59: OUTPUT«A-OK!␤»

[23:19] <ShimmerFairy> YuviPanda: sure :)  And note that it's apparently also cause by having the G::Actions name come first. So you managed to find the perfect combination of ingredients to cause a bug, congratulations! \o/

[23:19] <YuviPanda> :D

[23:19] <YuviPanda> Don't think I've found a language bug before!

[23:20] <ShimmerFairy> m: class C { my class D::E { method foo { "foo" } }; class D { method foo { "bar" } }; method test { say D.foo, D::E.foo } }; C.test

[23:20] <GLRelia> rakudo-moar d7ab32: OUTPUT«Could not find symbol '&E'␤  in method test at /tmp/cKgMTk4tHp:1␤  in block <unit> at /tmp/cKgMTk4tHp:1␤␤Actually thrown at:␤  in method test at /tmp/cKgMTk4tHp:1␤  in block <unit> at /tmp/cKgMTk4tHp:1␤␤»

[23:20] <camelia> rakudo-moar b56d59: OUTPUT«Could not find symbol '&E'␤  in method test at /tmp/BYpbX8RF1j:1␤  in block <unit> at /tmp/BYpbX8RF1j:1␤␤Actually thrown at:␤  in method test at /tmp/BYpbX8RF1j:1␤  in block <unit> at /tmp/BYpbX8RF1j:1␤␤»

[23:20] <ShimmerFairy> ^ ok, managed to find a simpler example, now that I realized/remembered the D::E comes first bit :)

[23:21] <ShimmerFairy> YuviPanda: Well, we ain't one of those mature compilers, so it's a bit easier to run into issues :)

[23:21] <YuviPanda> yeah, I guess that'e ok / to be expected :)

[23:21] <YuviPanda> I guess this is the first time I'm actually using and am excited by a still not mature language

[23:22] <ShimmerFairy> And on the LTA error messages: I'm working on something for rakudo on the side, and while working on it I've had to make my own new Exception types, and I've realized that our error messages could stand to be a bit more verbose. Hopefully we can do something about that :)

[23:23] <YuviPanda> nice :)

[23:24] <ShimmerFairy> The "Cannot find symbol &Thing" message is because AFAIK rakudo isn't so good at figuring out what went wrong when it comes to package-related errors (i.e. whenever you start needing :: in names and something in the lookup process goes awry)

[23:25] <ShimmerFairy> My only-slightly-educated guess is that rakudo doesn't quite realize yet that lots of people define namespaced things with  Foo::Bar::Baz  instead of  package Foo { ... }  , at least for error reporting :P

[23:26] <ShimmerFairy> m: class D::E { method foo { "foo" } }; class D { method bar { "bar" } }; say D::E.foo;  # I think that's as simple as the issue gets

[23:26] <GLRelia> rakudo-moar d7ab32: OUTPUT«foo␤»

[23:26] <camelia> rakudo-moar f7cfe9: OUTPUT«foo␤»

[23:26] <ShimmerFairy> m: my class D::E { method foo { "foo" } }; class D { method bar { "bar" } }; say D::E.foo;  # I think that's as simple as the issue gets

[23:26] <GLRelia> rakudo-moar d7ab32: OUTPUT«Could not find symbol '&E'␤  in block <unit> at /tmp/acnhQsbgoM:1␤␤Actually thrown at:␤  in block <unit> at /tmp/acnhQsbgoM:1␤␤»

[23:26] <camelia> rakudo-moar f7cfe9: OUTPUT«Could not find symbol '&E'␤  in block <unit> at /tmp/KnIVgDwj9D:1␤␤Actually thrown at:␤  in block <unit> at /tmp/KnIVgDwj9D:1␤␤»

[23:33] *** adu joined
[23:34] *** jferrero joined
[23:36] *** rurban left
[23:36] <cbk1090> What method would I use to search the contents of a text file to find multiple patterns like an URL, a regex or a grammar?

[23:37] <cbk1090> and can I use the .parse file function, to gather those matches?

[23:38] *** ggherdov left
[23:38] *** spider-mario left
[23:40] <adu> cbk1090: grep?

[23:40] <adu> o wait, I'm thinking bash

[23:41] <ShimmerFairy> depends. If you have a specific pattern you want to find all the matches of, there's  slurp("file.txt") ~~ m:g/pattern/  , which will put all the matches to the pattern in $/

[23:41] *** ggherdov joined
[23:42] <ShimmerFairy> YuviPanda++ on your first rakudobug :) Here's the link to it https://rt.perl.org/Ticket/Display.html?id=125891

[23:42] <cbk1090> Ok I think I'll try slurp.  Was really hoping to use a Grammar,  for me it is easier to read and change the patter if I have to?

[23:42] <cbk1090> thanks ShimmerFairy 

[23:44] <ShimmerFairy> cbk1090: you can of course use a Grammar, but then you'd have to parse the whole file (IIRC there are methods that don't insist on parsing the whole thing, I think, but your grammar would still have to account for the uninteresting stuff)

[23:44] <YuviPanda> ShimmerFairy: <3 thank you :)

[23:46] <cbk1090> ShimmerFairy, Yeah that was the problem I was having, the grammar really only works if there is a constant pattern to match.  The files I'm working with are really just random text with some URLs 

[23:46] <adu> I merged some C::Parser stuff

[23:46] <ShimmerFairy> YuviPanda: you're welcome. And I personally take it as a good sign of the compiler when the summary line for quickly describing the bug ends up being quite a bit long. Better than something like "Strings die on backslashes" :P

[23:47] <YuviPanda> :D

[23:47] <YuviPanda> is perl6 still on track for 'general release' by christmas?

[23:48] <ShimmerFairy> cbk1090: you could always do something like    token TOP { [<URL> | <!URL> .]+ }  (that is, match either a URL or one character of a not-URL.)

[23:48] *** adu left
[23:49] <cbk1090> But then how do I end up with a list of matching URLs?

[23:49] <ShimmerFairy> YuviPanda: yes. For years we've always said that it gets released on "Christmas", whenever that would be, so technically the answer is always "yes" :P . But the specific date of this year's literal Christmas is still the plan, so yes on that front as well :) .

[23:52] <ShimmerFairy> m: grammar G { token TOP { [<URL>|<!URL> .]+ }; token URL { "http://stuff.stuff" } }; G.parse("http://stuff.stuff lorem ipsum i don't http://stuff.stuff remember the rest of http://stuff.stuff the lorem stuff."); say $<URL>.elems

[23:52] <GLRelia> rakudo-moar d7ab32: OUTPUT«3␤»

[23:52] <camelia> rakudo-moar f7cfe9: OUTPUT«3␤»

[23:52] <ShimmerFairy> m: grammar G { token TOP { [<URL>|<!URL> .]+ }; token URL { "http://stuff.stuff" } }; G.parse("http://stuff.stuff lorem ipsum i don't http://stuff.stuff remember the rest of http://stuff.stuff the lorem stuff."); $<URL>.map: { say ~$_ }

[23:52] <GLRelia> rakudo-moar d7ab32: OUTPUT«http://stuff.stuff␤http://stuff.stuff␤http://stuff.stuff␤»

[23:52] <camelia> rakudo-moar f7cfe9: OUTPUT«http://stuff.stuff␤http://stuff.stuff␤http://stuff.stuff␤»

[23:53] <ShimmerFairy> cbk1090: ^ all the matched URLs will be available in $/<URL> after running the parse in this example

[23:54] <cbk1090> ShimmerFairy, ok I will try that method.....  thanks

[23:55] <ugexe> do actions happen *after* the grammar has been completely parsed? as in can you have actions that just emit to a supply, but also get emitted before the entire grammar is parsed?

[23:57] <ShimmerFairy> ugexe: actions happen in a "bottom up" order, as opposed to grammars' "top down" order. So the most-nested subrule in a particular chain of calls has its action method called first. Basically, it's like putting a { } block that does the action method after all the regex stuff

[23:57] <ugexe> would be cool if you could have a grammar emitting matches inside a react { }

[23:58] <ShimmerFairy> ugexe: essentially, it's like  regex foo { my regex stuff and then { the actions for this regex are at least somewhat equivalent to here } }

[23:59] *** trnh left
[23:59] <ShimmerFairy> ugexe: I'm not too clear on how the mechanism works specifically, but AFAIK you can think of actions as doing  regex foo { stuff { ActionClass.foo($/) } }  for you. :)

[23:59] <cbk1090> ShimmerFairy, ok I will try that method.....  thanks

[23:59] <cbk1090> sorry bout' that

[23:59] <ShimmerFairy> cbk1090: no worries, I accidentally up-enter'd in here the other day :P

