[00:07] *** adhoc_ is now known as adhoc

[00:08] *** aborazmeh left
[00:44] <grondilu> m: say ((1 + *) o (2 * *))(1);

[00:44] <camelia> rakudo-moar 058e71: OUTPUT«Too few positionals passed; expected 2 arguments but got 1␤  in block <unit> at /tmp/AaVatGHqN6:1␤␤»

[00:46] <grondilu> m: say ((1 + *) o (1 + *))(1);

[00:46] <camelia> rakudo-moar 058e71: OUTPUT«Too few positionals passed; expected 2 arguments but got 1␤  in block <unit> at /tmp/jVxHnY8R4K:1␤␤»

[00:46] <TimToady> o needs to be protected from priming

[00:46] <grondilu> oh

[00:46] <grondilu> looks LTA

[00:46] <TimToady> it's just a first whack at it

[00:47] <grondilu> m: say ({1 + $_} o { 2 * $_ })(1);

[00:47] <camelia> rakudo-moar 058e71: OUTPUT«3␤»

[00:47] <TimToady> that works, fo rnow

[00:47] <grondilu> ok

[00:48] <dalek> rakudo/nom: 68eed59 | TimToady++ | src/core/ (2 files):

[00:48] <dalek> rakudo/nom: GLRize the sequence operator

[00:48] <dalek> rakudo/nom: 

[00:48] <dalek> rakudo/nom: Now defaults to keeping () and [] intact as list elements.

[00:48] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/68eed5936c

[00:48] <dalek> roast: fd8d2cf | TimToady++ | S02-lexical-conventions/unspace.t:

[00:48] <dalek> roast: relax overly specific throws-like

[00:48] <dalek> roast: review: https://github.com/perl6/roast/commit/fd8d2cf07c

[00:48] <dalek> roast: 0e4f1e7 | TimToady++ | S03-sequence/ (3 files):

[00:48] <dalek> roast: sequence operators are now slippery

[00:48] <dalek> roast: 

[00:48] <dalek> roast: The sequence operator used to require itemization to hide lists and arrays

[00:48] <dalek> roast: from flattening.  Now the default is not to flatten arrays or lists,

[00:48] <dalek> roast: so you must slip in order to put multiple values into the list instead.

[00:48] <dalek> roast: review: https://github.com/perl6/roast/commit/0e4f1e7df1

[00:48] <TimToady> we can take the $ back out of our sequences now

[00:53] *** helloworldlang joined
[00:53] <Zoffix> I think I've recently read that Perl6 now supports fluent method calls, so this should work: https://gist.github.com/zoffixznet/25ae04641002f8a1fa04#file-fluent-p6-L19 I'm getting this error though: http://fpaste.scsys.co.uk/499549  what am I doing wrong?

[00:54] <Zoffix> Oh. I think I shouldn't copy/paste from Wiki and actually read the code :P

[00:54] *** kid51_ joined
[00:54] <TimToady> .tell jnthn thing is, @dest.push(@src.pop) is just wrong, wrong, wrong, because surprise; we really need to separate out the I-expect-to-push-a-list semantics to a different name, .pushem or some such

[00:54] <yoleaux> TimToady: I'll pass your message to jnthn.

[00:57] <ShimmerFairy> TimToady: could pushing a list be considered a multi-dim kind of thing? IIRC you can't push to a multidim array, but it still feels like you would want to lean towards that kind of construct if you're trying to make lists of lists.

[00:57] *** kid51 left
[00:57] <ShimmerFairy> So perhaps thinking of it as a vaguely multidim thing can help guide the design of it :)

[00:57] *** kid51_ is now known as kid51

[00:57] <TimToady> the problem is that it's not an "it", it's a "them"

[00:58] <grondilu> m: say 1 xx *

[00:58] <camelia> rakudo-moar 058e71: OUTPUT«(...)␤»

[00:58] <TimToady> people want contradictory things out of "push" currently; there are even routines in core that want it both ways

[00:58] <grondilu> m: say (1 xx *).perl

[00:58] <camelia> rakudo-moar 058e71: OUTPUT«Cannot .elems a lazy list␤  in block <unit> at /tmp/HYLkfFjdFi:1␤␤Actually thrown at:␤  in block <unit> at /tmp/HYLkfFjdFi:1␤␤»

[00:58] <grondilu> ^Not sure that's ok.  I suspect it isn't.

[00:59] <grondilu> m: say (my @ = 1 xx *).perl

[00:59] <camelia> rakudo-moar 058e71: OUTPUT«Cannot .elems a lazy list␤  in block <unit> at /tmp/filbjd2PE6:1␤␤Actually thrown at:␤  in block <unit> at /tmp/filbjd2PE6:1␤␤»

[00:59] <TimToady> well, it really is trying a bit too hard to not iterate the sequence

[00:59] <TimToady> but .gist should perhaps be considered destructive and read down the lazy list a bit

[01:00] <TimToady> m: say 1 xx 100000000

[01:00] <camelia> rakudo-moar 058e71: OUTPUT«(1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 ...)␤»

[01:01] <TimToady> but it just gives up current when .is-lazy is true

[01:01] <TimToady> *ently

[01:02] <grondilu> it's not just .perl though.  Got this while trying to golf that:

[01:03] <grondilu> m: sub CF(@a, @b) { [\o] map { @a[$_] + @b[$_] / * }, 0 .. * }; say CF((1, 2 xx *), (1 xx *))[10](Inf)

[01:03] <camelia> rakudo-moar 058e71: OUTPUT«Cannot reverse a lazy list␤  in sub CF at /tmp/42bQAACNNp:1␤  in block <unit> at /tmp/42bQAACNNp:1␤␤Actually thrown at:␤  in any  at gen/moar/m-Metamodel.nqp:2869␤  in sub CF at /tmp/42bQAACNNp:1␤  in block <unit> at /tmp/42bQAACNNp:1␤␤»

[01:04] <grondilu> which comes from http://rosettacode.org/wiki/Continued_fraction

[01:08] <TimToady> well 1, 2 xx * looks wrong

[01:09] <grondilu> m: sub CF(@a, @b) { [\o] map { @a[$_] + @b[$_] / * }, 0 .. * }; say CF((1, |(2 xx *)), (1 xx *))[10](Inf)

[01:09] <camelia> rakudo-moar 058e71: OUTPUT«Cannot reverse a lazy list␤  in sub CF at /tmp/qOUFTo1gZP:1␤  in block <unit> at /tmp/qOUFTo1gZP:1␤␤Actually thrown at:␤  in any  at gen/moar/m-Metamodel.nqp:2869␤  in sub CF at /tmp/qOUFTo1gZP:1␤  in block <unit> at /tmp/qOUFTo1gZP:1␤␤»

[01:09] <TimToady> but that's obviously not the problem here

[01:10] <TimToady> o is now right associative, hence the reverse

[01:11] <TimToady> is this a spot where it would make more sense for o to be left associative?

[01:11] <grondilu> I don't think so.  It *is* right associative, isn't it?

[01:12] *** travis-ci joined
[01:12] <travis-ci> Rakudo build passed. TimToady 'GLRize the sequence operator

[01:12] <travis-ci> https://travis-ci.org/rakudo/rakudo/builds/82849158 https://github.com/rakudo/rakudo/compare/058e713dc937...68eed5936cf5

[01:12] *** travis-ci left
[01:12] <TimToady> that's what I thought

[01:12] <TimToady> but you can't reverse an infinite list

[01:12] <grondilu> but it should not reverse the infinite version, only the finite one

[01:13] <grondilu> I mean the reverse should only occur while accessing a [$n] element, shouldn't it?

[01:14] <grondilu> m: my @f = [\o] { 2 * * } xx *;

[01:14] <camelia> rakudo-moar 058e71: OUTPUT«5===SORRY!5=== Error while compiling /tmp/g0GkBwD20k␤Malformed double closure; WhateverCode is already a closure without curlies, so either remove the curlies or use valid parameter syntax instead of *␤at /tmp/g0GkBwD20k:1␤------> 3my @f = [\o] …»

[01:14] <grondilu> m: my @f = [\o] { 2 * $_ } xx *;

[01:14] <grondilu> oops

[01:14] <camelia> rakudo-moar 058e71: OUTPUT«Cannot reverse a lazy list␤  in block <unit> at /tmp/JHZpQvmr8e:1␤␤Actually thrown at:␤  in any  at gen/moar/m-Metamodel.nqp:2869␤  in block <unit> at /tmp/JHZpQvmr8e:1␤␤»

[01:14] <grondilu> oh, weird

[01:15] <grondilu> I'd swear I successfully created an infinite [\o] earlier

[01:16] <TimToady> using the new builtin?

[01:16] *** laouji joined
[01:17] <TimToady> it was briefly left associative, I think...

[01:17] <grondilu> yes, but I just checked and it was inside a function.

[01:18] <grondilu> can't you create an infinite triangular version of a right-associative operator?

[01:18] *** aborazmeh joined
[01:18] *** aborazmeh left
[01:18] *** aborazmeh joined
[01:18] <TimToady> m: my @f = [\[[&[o]]] { 2 * $_ } xx *;

[01:18] <camelia> rakudo-moar 058e71: OUTPUT«5===SORRY!5=== Error while compiling /tmp/eEMuLuGfqc␤Unable to parse expression in bracketed infix; couldn't find final ']' ␤at /tmp/eEMuLuGfqc:1␤------> 3my @f = [\[[&7⏏5[o]]] { 2 * $_ } xx *;␤»

[01:19] <TimToady> m: my @f = [\[&[o]]] { 2 * $_ } xx *;

[01:19] <camelia> rakudo-moar 058e71: OUTPUT«5===SORRY!5=== Error while compiling /tmp/tYQCjSCRtb␤Unable to parse expression in bracketed infix; couldn't find final ']' ␤at /tmp/tYQCjSCRtb:1␤------> 3my @f = [\[&7⏏5[o]]] { 2 * $_ } xx *;␤»

[01:19] <grondilu> I mean I see the problem, but I'm not sure it's that big a problem

[01:20] <TimToady> but you can't do a right associative op on an infinite list, because you need the last two values for your first operation

[01:20] <TimToady> it's a little more obvious with [**] 1..* perhaps

[01:21] <TimToady> doesn't even matter whether it's a triangle

[01:22] <TimToady> maybe we need a re-associate-left metaoperator...

[01:23] <grondilu> but you're not supposed to access the first operation unless you reify at some point or something

[01:23] *** sufrostico left
[01:24] <grondilu> though I understand the weird ness, as the first terms depend on the length of the list, which is weird

[01:24] <grondilu> (if I'm not mistaken)

[01:24] <TimToady> it can't know the operands for previous entries until it evaluates the last one

[01:25] <grondilu> wait

[01:25] <TimToady> [**] 1,2,3  -> 1 ** 2 ** 3  so 1 doesn't know what it will have for its RHS till you evaluate 2 ** 3

[01:25] <grondilu> I think you're right

[01:26] <grondilu> something still bugs me about it though

[01:26] <BenGoldberg> m: say [**] 2..4

[01:26] <camelia> rakudo-moar 68eed5: OUTPUT«2417851639229258349412352␤»

[01:26] <TimToady> [**] 2..* is slightly larger

[01:27] <BenGoldberg> Only slightly?

[01:28] <grondilu> funnily enought [**] 1..* is 1

[01:28] <TimToady> it's only ℵ₀ or so

[01:29] <BenGoldberg> m: 0 ** 0

[01:29] <camelia> rakudo-moar 68eed5: OUTPUT«WARNINGS:␤Useless use of "**" in expression "0 ** 0" in sink context (line 1)␤»

[01:29] <BenGoldberg> m: say 0 ** 0

[01:29] <camelia> rakudo-moar 68eed5: OUTPUT«1␤»

[01:30] <ShimmerFairy> TimToady: I don't think a metaop is quite what you want in this instance, at least not without changing a fair bit about how metaops work.

[01:30] <BenGoldberg> m: https://gist.github.com/BenGoldberg1/bc39a9a31eaeb733012a

[01:30] <camelia> rakudo-moar 68eed5: OUTPUT«Attempt to return outside of any Routine␤  in block <unit> at /tmp/UnjZSOd4Ds:33␤␤»

[01:30] <ShimmerFairy> TimToady: this [**] case is calling for an "iterative" application of ** (if I may call it that), rather than reduceop's purpose of interspersing the list with the given operator

[01:31] <ShimmerFairy> (s:1st/metaop/reduceop/ , btw)

[01:31] <BenGoldberg> m: .say for \[**] 1..*

[01:31] <camelia> rakudo-moar 68eed5: OUTPUT«Cannot reverse a lazy list␤  in block <unit> at /tmp/qtzNVKanT8:1␤␤Actually thrown at:␤  in any  at gen/moar/m-Metamodel.nqp:2869␤  in block <unit> at /tmp/qtzNVKanT8:1␤␤»

[01:31] <BenGoldberg> m: .say for [\**] 1..*

[01:31] <camelia> rakudo-moar 68eed5: OUTPUT«Cannot reverse a lazy list␤  in block <unit> at /tmp/qRhP39fVPf:1␤␤Actually thrown at:␤  in any  at gen/moar/m-Metamodel.nqp:2869␤  in block <unit> at /tmp/qRhP39fVPf:1␤␤»

[01:32] <grondilu> yes, that's wht bugged me.  This should work.

[01:32] <TimToady> only if it switches to left associative

[01:32] <grondilu> [\**] 1..* is supposed to do [**] 1, then [**]1..2, then [**] 1..3 and so on

[01:33] <grondilu> and never reverse

[01:33] <grondilu> well, not *supposed to* but *could*

[01:34] <TimToady> m: say [\**] 2..4

[01:34] <camelia> rakudo-moar 68eed5: OUTPUT«(4 81 2417851639229258349412352)␤»

[01:34] <TimToady> currently it does 4, 3**4, 2**3**4

[01:34] <ShimmerFairy> m: my @a = 2..4; while +@a > 1 { @a.unshift(@a.shift ** @a.shift) }; say @a  # this does (2 ** 3) ** 4

[01:34] <camelia> rakudo-moar 68eed5: OUTPUT«[4096]␤»

[01:35] <grondilu> ah

[01:35] <BenGoldberg> m: my @a = 2..4; while +@a > 1 { @a.unshift(@a.shift ** @a.shift).say }; 

[01:35] <camelia> rakudo-moar 68eed5: OUTPUT«[8 4]␤[4096]␤»

[01:35] <BenGoldberg> m: my @a = 2..5; while +@a > 1 { @a.unshift(@a.shift ** @a.shift).say }; 

[01:35] <camelia> rakudo-moar 68eed5: OUTPUT«[8 4 5]␤[4096 5]␤[1152921504606846976]␤»

[01:37] <TimToady> m: sub infix:<***>($a,$b) is equiv(&[**]) is assoc('left') { $a ** $b }; say [\***] 2..4 

[01:37] <camelia> rakudo-moar 68eed5: OUTPUT«(2 8 4096)␤»

[01:37] *** makapa joined
[01:37] <TimToady> sure looks like what a metaop would do to me

[01:37] <grondilu> I guess you're right

[01:37] <TimToady> s/would/could/

[01:38] <Zoffix> jnthn, are you able to update your http://jnthn.net/papers/2015-spw-perl6-course.pdf ? The last line of the code example should return (Str), not (Int).

[01:38] <Zoffix> Als, jnthn++ great slideshow

[01:38] <ShimmerFairy> TimToady: would we want metaops for all the associativity, or on an as-needed basis?

[01:39] <ShimmerFairy> *tivities

[01:39] <grondilu> notice that the "graphical" meaning of the triangular operator strongly suggests left associativity, which is confusing.

[01:40] <TimToady> well, this is the first use case I've seen for wanting to violate the natural order, so maybe we've got the wrong associativity on o

[01:40] <grondilu> .oO([**/])

[01:40] <TimToady> m: say [\R**] 2..4

[01:40] <camelia> rakudo-moar 68eed5: OUTPUT«(2 9 262144)␤»

[01:41] <grondilu> this hurst my brain

[01:41] <TimToady> m: say [\R**] reverse 2..4

[01:41] <camelia> rakudo-moar 68eed5: OUTPUT«(4 81 2417851639229258349412352)␤»

[01:41] <ShimmerFairy> .oO(assoc metaops: AL, AR, AN, AC, AX, the second letters matching the table in S03.  [AL**] 2..4  :P)

[01:41] *** z8 left
[01:43] <TimToady> [AN**] doesn't make a whole buncha sense

[01:43] <TimToady> and AX doesn't make sense for operators that have no listy implementation

[01:43] <TimToady> I only see a use case for L

[01:44] <ShimmerFairy> In that case, it could be spelled L instead of AL; I put the A in front because a couple of those are already metaops without it

[01:45] <ShimmerFairy> (though I suppose some might think there's a relationship between L and R, I dunno)

[01:45] <TimToady> or [\O**] for opposite associtivity

[01:45] * BenGoldberg . o O ( [**] )

[01:46] <geekosaur> ...which then gives you a Oo

[01:46] <TimToady> yes, does it matter for anything except reductions?

[01:46] <ShimmerFairy> TimToady: maybe triangle reduce is the only case where we want to work from left-to-right, regardless of associativity? That is, triangle reduce only worries about associativity when it gets the list to apply the op to

[01:46] *** yoleaux joined
[01:46] *** ChanServ sets mode: +v yoleaux

[01:47] *** yoleaux left
[01:47] *** yoleaux joined
[01:47] *** ChanServ sets mode: +v yoleaux

[01:47] *** yoleaux left
[01:47] *** yoleaux joined
[01:47] *** ChanServ sets mode: +v yoleaux

[01:47] <ShimmerFairy> The theoretical [L**] 2..4 , which is (2 ** 3) ** 4 , might be better handled by having the user just do it manually (see my while loop above)

[01:50] <TimToady> m: say ([1], -> @a { [0, |@a Z+ |@a, 0] } ... *)[^10]

[01:50] <camelia> rakudo-moar 68eed5: OUTPUT«([1] [1 1] [1 2 1] [1 3 3 1] [1 4 6 4 1] [1 5 10 10 5 1] [1 6 15 20 15 6 1] [1 7 21 35 35 21 7 1] [1 8 28 56 70 56 28 8 1] [1 9 36 84 126 126 84 36 9 1])␤»

[01:50] <TimToady> yay, pascal is pretty again

[01:51] *** jsimonet left
[01:54] <grondilu> m: say ([1], { [0, |@_ Z+ |@_, 0] } ... *)[^10]

[01:54] <camelia> rakudo-moar 68eed5: OUTPUT«([1] [1 1] [1 3 2] [1 3 5 3] [1 3 5 7 4] [1 3 5 7 9 5] [1 3 5 7 9 11 6] [1 3 5 7 9 11 13 7] [1 3 5 7 9 11 13 15 8] [1 3 5 7 9 11 13 15 17 9])␤»

[01:55] <grondilu> (golfed it 4u)

[01:55] *** adu joined
[01:55] <TimToady> um, no

[01:55] <grondilu> oh

[01:55] <grondilu> not sure what's wrong about it

[01:56] <adu> hi all

[01:56] <Zoffix> \o\

[01:56] <grondilu> oh I see

[01:57] <grondilu> @_ really is *@a

[01:59] <grondilu> m: say ([1], { [0, |$_ Z+ |$_, 0] } ... *)[^10]

[01:59] <camelia> rakudo-moar 68eed5: OUTPUT«([1] [1 1] [1 2 1] [1 3 3 1] [1 4 6 4 1] [1 5 10 10 5 1] [1 6 15 20 15 6 1] [1 7 21 35 35 21 7 1] [1 8 28 56 70 56 28 8 1] [1 9 36 84 126 126 84 36 9 1])␤»

[02:09] *** vendethiel joined
[02:10] *** kid51 left
[02:17] *** dalek left
[02:17] *** dalek joined
[02:17] *** ChanServ sets mode: +v dalek

[02:21] *** tokuhiro_ joined
[02:23] <grondilu> you know, I wonder if we could not have two versions of the triangular metaop.  [\op] 1..3 would mean 1, 1op2, 1op2op3 and [op/] would mean 3, 2op3, 1op2op3

[02:24] <grondilu> it would behave the same regardless of the associatvity of op

[02:24] *** lolisa joined
[02:25] <grondilu> so that [\o] &f xx * would make some sense

[02:30] *** zoosha joined
[02:33] *** vendethiel left
[02:37] *** noganex_ joined
[02:37] *** AlexDaniel left
[02:40] *** noganex left
[02:41] *** makapa left
[02:45] *** jsimonet joined
[02:47] *** laouji left
[02:47] *** laouji joined
[02:55] *** kaare_ joined
[02:56] *** grondilu left
[02:57] *** grondilu joined
[03:21] *** khw joined
[03:30] *** kanishka joined
[03:41] *** kanishka left
[03:44] *** laouji left
[03:45] *** laouji joined
[03:49] *** laouji left
[03:59] *** TEttinger joined
[04:13] *** _28_ria left
[04:18] *** khw left
[04:18] *** BenGoldberg left
[04:32] *** telex left
[04:34] *** telex joined
[04:39] *** makapa joined
[04:50] *** [Sno] joined
[04:55] *** laouji joined
[04:56] *** makapa left
[04:57] *** espadrine left
[04:59] *** aborazmeh left
[04:59] *** [Sno] left
[05:01] *** bjz joined
[05:10] *** bjz left
[05:22] *** bjz joined
[05:23] *** skids left
[05:39] *** Nandi joined
[05:40] *** Nandi left
[05:42] *** adu left
[05:58] *** laouji left
[05:58] *** TEttinger left
[05:59] *** laouji joined
[06:11] *** Khisanth left
[06:12] *** abaugher left
[06:13] *** abaugher joined
[06:18] *** aborazmeh joined
[06:18] *** aborazmeh left
[06:18] *** aborazmeh joined
[06:22] *** Khisanth joined
[06:25] *** Ven joined
[06:38] <masak> morning, #perl6

[06:38] *** [Sno] joined
[06:40] <moritz> \o masak

[06:51] *** araujo_ left
[06:51] *** xfix joined
[06:53] *** lolisa left
[06:55] *** FROGGS joined
[07:04] <[Tux]> test             50000    35.926    35.807

[07:04] <[Tux]> test-t           50000    36.801    36.682

[07:11] *** eugu joined
[07:14] <Ven> o/, #perl6!

[07:14] <DrForr> \o

[07:16] <TimToady> I now have a version that now distinguishes .push from .pushem, but 'pushem' is a "You think that's cute today", so I've been trying to think up a better "plural push" word

[07:16] <TimToady> push-all is taken

[07:17] <nine> TimToady: what about append? You're appending an array to the array.

[07:17] <TimToady> thought about that...

[07:17] <TimToady> but append in FP is usually append non-destructively to a list

[07:18] <nine> Python uses append for push and extend for push-list

[07:20] <nine> @a.push-from(@b)?

[07:21] <TimToady> actually, append isn't so bad, since we might also want prepend on the unshift end

[07:22] <ShimmerFairy> postpend as a mirror to prepend, then :P

[07:22] <ShimmerFairy> TimToady: to be fair, the (un)shift names never seemed that intuitive to me, but perhaps that's just lacking the historical knowledge.

[07:23] <jdv79> i forgot my passwd on hack.  can someone reset it?

[07:23] <moritz> jdv79: yes

[07:24] <moritz> jdv79: your new password is oa1kai3Chu

[07:24] <moritz> sorry

[07:24] <moritz> that was meant to go via privms

[07:24] <moritz> password changed again :-)

[07:24] <DrForr> Should probably be removed from the channel log as well :)

[07:25] <moritz> DrForr: no, I just changed it again

[07:25] <moritz> there's no harm in having a password in the logs that was valid for all of ten seconds

[07:26] <DrForr> Oh, I know, just thinking of privacy and all that. Not really important.

[07:26] <masak> "append" sounds good to me. "non-destructive" isn't what I think when I see that word, even though I know some FP.

[07:31] <jdv79> moritz: mqybe this?:  https://wiki.debian.org/VirtualBox#Debian_8_.22Jessie.22

[07:33] *** maddingu1 is now known as maddingue

[07:35] *** FROGGS left
[07:36] *** larion left
[07:41] <moritz> jdv79: trying that now

[07:43] *** CIAvash joined
[07:50] *** CIAvash left
[07:51] *** azawawi joined
[07:51] <azawawi> hi #perl6

[07:54] *** FROGGS joined
[07:59] *** brrt joined
[07:59] <brrt> \o #perl6

[07:59] <DrForr> o/

[07:59] <azawawi> hi

[08:00] <FROGGS> o/

[08:00] <yoleaux> 29 Sep 2015 20:51Z <jnthn> FROGGS: I'm really tired and about to sleep, so I'll look at those two tomorrow

[08:00] <brrt> ohai DrForr :-) and azawawi

[08:00] <FROGGS> .tell jnthn no hurry :o)

[08:00] <yoleaux> FROGGS: I'll pass your message to jnthn.

[08:00] <brrt> i figure this is as good a place as any to ask; is there a way to convert from random unicode characters to their equivalent asscii, in java

[08:00] <azawawi> any idea why FileChangeEvent::FileRenamed is always fired even though files are deleted in a $folder monitored by IO::Notification.watch-path($folder) ?

[08:01] <brrt> e.g.  ß to ss

[08:01] *** Ven left
[08:02] <brrt> that probably depends on the underlying implementation

[08:02] * azawawi starts reading http://www.w3.org/TR/webdriver/

[08:02] <ShimmerFairy> brrt: at first guess you'd probably want NFKC or NKFD normalization; not quite ASCII, but it does do "compatibility" conversions

[08:02] <brrt> azawawi: file system monitoring is notably sensitive to superfluouus changes

[08:03] <DrForr> Very few Unicode glyphs will convert to ASCII. Normalization will probably get you close though.

[08:03] <nine> azawawi: are those files really deleted or just moved to some .trash?

[08:03] <brrt> i know fribidi has an option to match visually 'close' characters

[08:03] <azawawi> nine: let me double check :)

[08:04] <azawawi> nine: used `rm`. same behavior

[08:04] <DrForr> You could also be inspired by Lingua::Unidecode in perl5 that attempts to do just that.

[08:05] <brrt> azawwawi: i've noticed this problem before, also on other implementations, and i don't think there is a single good solution

[08:05] *** pierrot left
[08:07] <azawawi> brrt: i was surprised to find it in core to be honest :)

[08:08] <brrt> hmm yeah, i have no strong opinion about that

[08:08] <brrt> it's not a traditional core service; but 'traditional' IO is, and i see no reason to distinguish them closesly

[08:08] <azawawi> brrt: this is going to be a maintenance headache across platforms

[08:08] <brrt> well, moarvm is bound by libuv in that regards

[08:09] <brrt> so it is going to be a maintenance headache for joyent before it is a maintenance headache for us ^^

[08:09] <brrt> (or sun, in case you use jvm)

[08:09] <brrt> eh, s/sun/oracle/

[08:10] *** pierrot joined
[08:11] *** espadrine joined
[08:11] *** abraxxa joined
[08:12] <Timbus_> int flags - one of UV_RENAME or UV_CHANGE, or a bitwise OR of both.

[08:13] *** darutoko joined
[08:13] <Timbus_> uh.. i guess libuv only has two filechanged flags?

[08:14] <azawawi> Timbus_: my bad, it is already in the spec... http://doc.perl6.org/type/IO::Notification

[08:14] <Timbus_> but lame, considering inotify has a whole buncha event types

[08:14] <azawawi> Timbus_: true

[08:16] <brrt> that's the cost of being cross-platform

[08:16] <brrt> or, cross platform cheaply

[08:17] <azawawi> brrt: https://metacpan.org/source/MIYAGAWA/Filesys-Notify-Simple-0.12/lib/Filesys/Notify/Simple.pm

[08:18] <azawawi> from https://metacpan.org/pod/Win32::ChangeNotify, "...Unfortunately, the Win32 API which implements this feature does not provide any indication of what triggered the notification (as far as I know)... "

[08:22] <brrt> perl5 is not a good example of trying to achieve cross-platform compatibility on the cheap :-)

[08:26] *** Ven joined
[08:28] *** aborazmeh left
[08:30] *** dakkar joined
[08:34] *** Ven left
[08:39] *** Ven joined
[08:42] *** timbunce_ joined
[08:44] *** ifim joined
[08:45] <moritz> jdv79: virtualbox installed, btw

[08:48] *** larion joined
[08:52] <Ulti> so looks like in the latest Rakudo MAIN not getting params errors with "Invocant requires an instance of type Int, but a type object was passed.  Did you forget a .new?"  rather than giving usage

[08:53] <jdv79> moritz: cool.  i'll check it out soon.  thanks!

[08:56] <Ulti> m: sub MAIN(Int :$thing) { say $thing; }

[08:56] <camelia> rakudo-moar 68eed5: OUTPUT«(Int)␤»

[08:56] <Ulti> m: sub MAIN(Int:D :$thing) { say $thing; }

[08:56] <camelia> rakudo-moar 68eed5: OUTPUT«Usage:␤  /tmp/eLRJdQhie3 [--thing=<Int>] ␤»

[08:56] <Ulti> :/

[08:56] <dalek> rakudo/nom: 4f70652 | TimToady++ | / (20 files):

[08:56] <dalek> rakudo/nom: distinguish push/unshift from append/prepend

[08:56] <dalek> rakudo/nom: 

[08:56] <dalek> rakudo/nom: For one-arg semantics, we now use prepend and append.  The push and unshift

[08:56] <dalek> rakudo/nom: methods/subs are now designed to primarily support pushing or unshifting

[08:56] <dalek> rakudo/nom: a single item (without you having to explicitly itemize, which would

[08:56] <dalek> rakudo/nom: defeat slippage for things like the sequence operator).  So now you can

[08:56] <dalek> rakudo/nom: say @dest.push(@src.pop) without worrying about accidental flattening of

[08:56] <dalek> rakudo/nom: a single element that happens to be iterable.  Plus it will save wear and

[08:56] <dalek> rakudo/nom: tear on your $ key when you want to push a single array or list.

[08:56] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/4f7065226c

[08:56] <dalek> roast: 9970b63 | TimToady++ | / (10 files):

[08:56] <dalek> roast: catch up with push/unshift -> append/prepend

[08:56] <dalek> roast: review: https://github.com/perl6/roast/commit/9970b63d7d

[08:59] * TimToady heads for bed

[08:59] *** andreoss joined
[09:09] *** RabidGravy joined
[09:24] <dalek> ecosystem: f9741f0 | moznion++ | META.list:

[09:24] <dalek> ecosystem: Add IO::Blob

[09:24] <dalek> ecosystem: review: https://github.com/perl6/ecosystem/commit/f9741f01d0

[09:24] <dalek> ecosystem: 063421f | RabidGravy++ | META.list:

[09:24] <dalek> ecosystem: Merge pull request #61 from moznion/io-blob

[09:24] <dalek> ecosystem: 

[09:24] <dalek> ecosystem: Add IO::Blob

[09:24] <dalek> ecosystem: review: https://github.com/perl6/ecosystem/commit/063421fbc3

[09:25] *** laouji left
[09:43] *** espadrine left
[09:47] * Ven wonders why gcc -O2 -S sometimes generates -4(%rbp), sometimes -1(%rbp) in the program, for what seemed to be equivalent

[09:50] <brrt> well, they most certainly aren't

[09:58] *** laouji joined
[10:01] <abraxxa> i tried to compile 2015.09 on my raspberry pi model B yesterday, failed because it ran out of memory

[10:01] <abraxxa> anything I can do to lower the memory requirements at the parsing stage?

[10:03] *** araujo joined
[10:04] *** araujo left
[10:04] *** espadrine joined
[10:05] *** araujo joined
[10:06] *** helloworldlang left
[10:09] <lizmat> abraxxa: short of removing features from the core setting, I wouldn't know of any

[10:09] <dalek> rakudo/nom: 649dae1 | lizmat++ | src/core/Process.pm:

[10:09] <dalek> rakudo/nom: Include change in setting as well

[10:09] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/649dae1139

[10:10] <abraxxa> lizmat: i guess I have to get a model B+ for compiling then...

[10:10] <lizmat> if that has more RAM, yes  :-)

[10:14] *** Ven left
[10:20] <abraxxa> 256MB vs 128MB

[10:21] <lizmat> that feels still like way too low, hope you have a lot of swap

[10:25] <_itz> abraxxa: try adding more swap

[10:26] <abraxxa> _itz: it already killed the performance to have 128MB swap

[10:26] <_itz> you probably need 1-2GB of swap I'd guess 

[10:27] <DrForr> No way to crosscompile from another machine?

[10:29] <_itz> I keep meaning to try a qemu arm image

[10:30] <_itz> I can't build panda on 'brew as of now

[10:31] <_itz> Type check failed in binding $p; expected Panda::Project but got Seq

[10:46] *** mtj_ left
[10:49] *** Peter_R joined
[10:50] *** laouji left
[10:53] *** zakharyas joined
[10:53] *** mtj_ joined
[10:54] *** mtj_ left
[10:55] <_itz> 4f706

[10:58] *** mtj_ joined
[11:07] *** mtj_ left
[11:07] <dalek> rakudo/curli: 7598a62 | lizmat++ | src/core/ (2 files):

[11:07] <dalek> rakudo/curli: Introduce VM.precomp-dir

[11:07] <dalek> rakudo/curli: 

[11:07] <dalek> rakudo/curli: This will be the compilation-id dependent directory where rakudo

[11:07] <dalek> rakudo/curli: will store its precompiled files by default.

[11:07] <dalek> rakudo/curli: review: https://github.com/rakudo/rakudo/commit/7598a628b0

[11:07] <dalek> rakudo/curli: ff8e04d | lizmat++ | CURLI:

[11:07] <dalek> rakudo/curli: The text version of the CURLI discussion gist

[11:07] <dalek> rakudo/curli: 

[11:07] <dalek> rakudo/curli: Also lives at https://gist.github.com/lizmat/f3807956c354c14902a3

[11:07] <dalek> rakudo/curli: review: https://github.com/rakudo/rakudo/commit/ff8e04d81a

[11:07] <dalek> rakudo/curli: bedd43a | lizmat++ | src/core/CompUnit.pm:

[11:07] <dalek> rakudo/curli: Introduce CompUnit.precomp-path

[11:07] <dalek> rakudo/curli: 

[11:07] <dalek> rakudo/curli: Since the precomped files will no longer live side-by-side with

[11:07] <dalek> rakudo/curli: their associated source files, we need to keep the path separately.

[11:07] <dalek> rakudo/curli: review: https://github.com/rakudo/rakudo/commit/bedd43a454

[11:07] <lizmat> yes, this breaks some of the build at the moment, so I put it in a branch

[11:08] *** jkva joined
[11:11] *** pecastro joined
[11:13] <[Tux]> panda is broken again

[11:13] <[Tux]> Rakudo has been built and installed.

[11:13] <[Tux]> Updating panda as well

[11:13] <[Tux]> X11 forwarding request failed on channel 0

[11:13] <[Tux]> Failed to get the directory contents of '/pro/3gl/CPAN/rakudobrew/moar-nom/install/share/perl6/site/panda': chdir failed: no such file or directory

[11:13] <[Tux]>   in any  at /pro/3gl/CPAN/rakudobrew/moar-nom/install/share/perl6/runtime/CORE.setting.moarvm:1

[11:14] <_itz> [Tux]: yes I can't build with the 4f706 change try  rakudobrew  build moar 68eed5 

[11:17] *** laouji joined
[11:19] <[Tux]> ==> panda depends on File::Find, Shell::Command, JSON::Fast

[11:19] <[Tux]> ==> Shell::Command depends on File::Find

[11:19] <[Tux]> I'll just wait for the next update :)

[11:21] *** Ven joined
[11:25] <brrt> well, that doesn't look like my bug [Tux] :-)

[11:25] <brrt> (yes, i'm lousy for not having fixed it yet)

[11:27] *** azawawi left
[11:28] *** RabidGravy left
[11:33] <hahainternet> is there a timezone implementation for p6 yet? i guess i should get googling

[11:33] *** rindolf joined
[11:33] <hahainternet> aha well that was easy

[11:33] <hahainternet> i really like the docs site

[11:33] <masak> :)

[11:34] <masak> moritz++ # most likely; also, others++

[11:34] <hahainternet> i think the aesthetics probably need a bit of improvement, but honestly i'm aesthetically challenged

[11:34] <hahainternet> but the fact i can find what i'm looking for easily and they're well structured is a godsend after trying to deal with python docs

[11:35] <masak> yes, we can tweak the styles some more

[11:35] <moritz> aesthetics patches welcome :-)

[11:35] * brrt often finds python docs to be decent... enough, i guess?

[11:36] * moritz just hates docs that let you chase in superclasses' docs on your own

[11:36] <hahainternet> brrt: i find there's a lot of waffle and beginner tutorials, rather than straightforward implementation descriptions

[11:36] <brrt> well, that's a point

[11:36] <hahainternet> also moritz i've mentioned that to a designer i work with

[11:36] <brrt> that is pythons lament, i guess.

[11:37] <brrt> python is designed to be easy to learn and use.

[11:37] <brrt> hence beginners learn python

[11:37] <brrt> hence beginners use python, a lot

[11:37] <brrt> hence a lot of python is beginners' code

[11:37] <hahainternet> yeah i don't disagree with any of that

[11:38] <hahainternet> i want to say it was 'yield' that i was having the most trouble finding a succinct authoritative source on, but i might look stupid now as you pull it out of google instantly ;)

[11:38] <brrt> well, i recall struggling with the same, actually

[11:39] <brrt> so as far as i'm concerned, you're not looking stupid :-)

[11:39] <hahainternet> the conceptual model for it seems really confused, but i just went to golang instead

[11:39] <hahainternet> i would have used perl6 to be perfectly honest, but performance is a big motivator there

[11:39] <brrt> the thing about yield is that it secretly converts a function-or-method-call into a generator constructor

[11:40] <brrt> and i dislike the 'secretly' part about that

[11:40] <moritz> afaict "yield" is a bit like "take" in Perl 6, except that it's implicitly scoped to the current routine, not to a "gather" block

[11:40] <hahainternet> right, i was using it to batch up a very large gzipped file, as none of the typical patterns for that in python worked with non iterable instances

[11:40] <brrt> moritz: gather and take are exception-based, aren't they?

[11:40] <hahainternet> oh, that reminds me

[11:40] <moritz> brrt: yes, because take is dynamically scoped

[11:41] <hahainternet> so it was also hard to find the semantics for allocating an array buffer within this loop, passing off its reference and allocating a new one

[11:41] *** jkva left
[11:41] <hahainternet> in the end i just experimented until it made sense, secret pass-by-ref is quite a niggle too

[11:42] <hahainternet> s/non iterable/non indexable/ ^^

[11:43] <brrt> hahainternet: you could use the array module, perhaps?

[11:43] <brrt> not sure what you mean actually

[11:43] <hahainternet> brrt: i just gave up and used golang, so job done

[11:43] <brrt> that's actually quite clever moritz..... 

[11:44] <hahainternet> brrt: python has some weirdnesses where for example, if you pass a plain 'counter = 0' between functions, each gets a new instance, but if you use an array, the reference is passed

[11:44] <hahainternet> anyway this is #perl6, not #python, so i'll shut up and write my timezone sub, thanks again @ ++all

[11:44] <brrt> that seems like 'ordinary' call-by-ref with value-object syntax

[11:44] <brrt> eh semantics, not syntax

[11:45] <brrt> m: sub foo(Int $x) { $x++; say $x; }; my Int $y = 4; foo($y); say $y;

[11:45] <camelia> rakudo-moar 649dae: OUTPUT«Parameter '$a' expected a writable container, but got Int value␤  in sub foo at /tmp/GQvlA0xDcO:1␤  in block <unit> at /tmp/GQvlA0xDcO:1␤␤»

[11:45] <brrt> hmm, that's right

[11:46] <brrt> perl6 is more complex still :-)

[11:46] <hahainternet> indeed, but can you do 'is rw' to make that mutable?

[11:46] <hahainternet> but it's just the lack of any clear distinction i know of in python

[11:46] <ilmari> m: sub foo(Int $x is rw) { $x++; say $x; }; my Int $y = 4; foo($y); say $y;

[11:46] <camelia> rakudo-moar 649dae: OUTPUT«5␤5␤»

[11:46] <brrt> yes, but that is actually not what i want

[11:46] <ilmari> m: sub foo(Int $x is copy) { $x++; say $x; }; my Int $y = 4; foo($y); say $y;

[11:46] <camelia> rakudo-moar 649dae: OUTPUT«5␤4␤»

[11:46] <ilmari> brrt: did you want "is copy"?

[11:46] <hahainternet> ^^ is actually what i'd expect in a quality language

[11:46] <hahainternet> which is why every time i read perl6 i go a little gooey inside

[11:46] <brrt> yes, that is what i want

[11:47] <masak> moritz: one difference: since some version, Python's `yield` is *two-way* -- that is, it has a return value which is an (optional) value sent by the caller as it steps forward with iter.next(val)

[11:47] <brrt> that's a pretty recent addition iirc

[11:47] <masak> moritz: which (I think) is needed for it to be actual co-routines

[11:48] <moritz> masak: aye. Though when I want a value from my caller, I use map

[11:48] *** araujo left
[11:49] *** araujo joined
[11:50] *** co-gnome joined
[11:50] <masak> moritz: if I understand you correctly, that still requires that the map closure and the caller share some resource to communicate through

[11:50] <masak> (even if that's just a shared scope)

[11:51] <masak> in Python, they are talking through the iterator object itself

[11:51] <masak> not saying one model is better than the other, just that they are differently factored

[11:51] *** araujo left
[11:51] <moritz> masak: I agree with your analysis

[11:53] <moritz> def some_func(a): C1; b = yield x; C2  basically translates to sub some_sub($a, \input_iter) { C1; return input_iter { my $b = $_; C2; $x } }

[11:55] *** AlexDaniel joined
[11:55] <masak> yes; you just did a CPS transform there

[11:55] <masak> they keep rocking my world

[11:56] <masak> in the general case, you need a $state variable, a bunch of numbered states, a loop and a given statement

[11:56] *** co-gnome left
[11:58] <moritz> you mix them all into a big bowl, knead them for a while, and then let them rest in the fridge.

[11:58] <masak> aye

[11:59] <masak> there's a nice example culminating on page 238 of http://www.lirmm.fr/~ducour/Doc-objets/ECOOP2012/ECOOP/ecoop/233.pdf showing this

[11:59] *** araujo joined
[11:59] *** araujo left
[11:59] *** araujo joined
[12:00] *** araujo left
[12:01] *** araujo joined
[12:02] <brrt> actually, that's not really true moritz; because just calling the iterator doesn't yet cause it to be executed

[12:03] *** araujo left
[12:04] *** araujo joined
[12:04] *** co-gnome joined
[12:06] <moritz> brrt: which part?

[12:10] *** FROGGS left
[12:11] <brrt> about the transform from the python function with yield to a perl6 sub

[12:11] *** co-gnome left
[12:11] <brrt> it's more like

[12:11] <brrt> hmmm

[12:11] <brrt> not sure how to translate it, in fact

[12:14] <moritz> you mean that the python function can return its first value without an input iterator being available

[12:15] <moritz> maybe?

[12:15] <moritz> in that case, easy enough to work around by prepending a value to the return iterator

[12:16] <brrt> class some_func_iter { my $!a; my $!after-yield; sub BUILD($a) { $!a = $a; $!after-yield = false; }; submethod next($?input-arg) { if ($!after-yield) { C2; } else { C1; $!after-yield = true; return $yield-value; }}} 

[12:16] <brrt> hmm, /me wonders about that

[12:16] <brrt> it's really an function-to-object transform, is what i mean

[12:17] <brrt> it also supports a loop and stuff

[12:17] <brrt> the whole function scope becomes the object scope

[12:18] <brrt> for example:

[12:19] <brrt> def foo(x): print(x); yield x*2; print(x*4); foo(); # will not print

[12:19] <brrt> whereas next(foo()) will

[12:19] <dalek> rakudo/curli: d5583c6 | lizmat++ | src/core/CompUnit.pm:

[12:19] <dalek> rakudo/curli: Unbreak build

[12:19] <dalek> rakudo/curli: 

[12:19] <dalek> rakudo/curli: To my surprise, creating precomp files already used CompUnit objects.

[12:19] <dalek> rakudo/curli: For now, it will first see if a precomp file exists next to the original

[12:19] <dalek> rakudo/curli: source file.  If so, then it will assume that for now.

[12:19] <dalek> rakudo/curli: review: https://github.com/rakudo/rakudo/commit/d5583c6838

[12:21] *** kid51 joined
[12:24] <brrt> randomly interesting paper: http://people.csail.mit.edu/brooks/papers/fast-cheap.pdf is fascinating, particularly if you consider that the method they describe for autonomic control is pretty much precisely the strategy of biological systems

[12:27] *** co-gnome joined
[12:31] *** mtj_ joined
[12:33] <masak> brrt: wow, 1989. I wonder what's changed since then.

[12:34] *** co-gnome left
[12:37] *** makapa joined
[12:38] <dalek> rakudo/curli: 20954d7 | lizmat++ | src/core/CompUnit.pm:

[12:38] <dalek> rakudo/curli: Don't need the extension twice

[12:38] <dalek> rakudo/curli: review: https://github.com/rakudo/rakudo/commit/20954d7efb

[12:38] <brrt> microprocessors are faster and use less power ^^

[12:42] *** Ven left
[12:50] <brrt> the description of how they make ghenghis (a 6 legged robot) walk is utterly brilliant

[12:50] *** pecastro left
[12:50] *** pecastro joined
[12:52] *** tokuhiro_ left
[12:54] *** makapa left
[12:55] *** Ven joined
[13:00] *** eugu left
[13:04] <cognominal_> I have not closely followed things lately.  In a signature, what is the diff between +values and *@values    ?

[13:04] <moritz> cognominal_: *@values flattens

[13:04] <timotimo> oof, such unrestful sleep ...

[13:04] <moritz> cognominal_: whereas +values implements (non-flattening) according to the "single argument" rule

[13:05] <moritz> see http://doc.perl6.org/type/List#Items%2C_Flattening_and_Sigils

[13:06] <cognominal_> thx, moritz++

[13:11] <lizmat> moritz FROGGS is there a reason why we have all the rakudo install logic in a Makefile

[13:11] <lizmat> moritz FROGGS instead of in a Perl 6 script that runs after the core settings have been compiled ?

[13:12] <moritz> lizmat: well, it's just traditional and convenient to have a 'make install' step

[13:12] <lizmat> ah, yes, don't disagree with that

[13:12] <lizmat> but is there a reason why that should not just run a Perl 6 script ?

[13:12] <moritz> no

[13:13] <_itz> building the rakudo star tarball does have a dependency on gnu make I noticed

[13:15] *** FROGGS joined
[13:15] <FROGGS> o/

[13:15] <brrt>  lizmat: the Makefile has knowledge of the build state, a script does not

[13:16] <brrt> in fact, you can - if you'd so desire - have a Makefile that installs only the changed files

[13:16] <FROGGS> that's what my v5 did btw

[13:16] * brrt has much love for make

[13:16] <FROGGS> especially at the time where it was only usable *after* installation

[13:18] <lizmat> argh... we want ./perl6 to work *before* installing anything, right ?

[13:19] <FROGGS> aye

[13:19] <dalek> doc: cbd9403 | (Steve Mynott)++ | bin/p6doc:

[13:19] <dalek> doc: fix p6doc -f postGLR github issue #138

[13:19] <dalek> doc: review: https://github.com/perl6/doc/commit/cbd940329c

[13:19] <dalek> doc: ffd9d49 | (Steve Mynott)++ | lib/Language/nativecall.pod:

[13:19] <dalek> doc: Merge branch 'master' of github.com:perl6/doc

[13:19] <dalek> doc: review: https://github.com/perl6/doc/commit/ffd9d49f89

[13:21] <timotimo> masak, brrt, moritz: don't forget about take-rw, which also allows you to communicate between the gathering routine and the consumer :)

[13:22] <Woodi> hallo #perl6 :)

[13:22] <Woodi> anyone can tell me how to precompile a script ? on Moar

[13:23] <timotimo> precompiling scripts doesn't work terribly well

[13:23] <moritz> --target=mbc --output=script.moarvm

[13:23] <Woodi> thanx

[13:23] <moritz> except that I don't think you can execute the result

[13:23] <moritz> but you didn't ask for that, right? :-)

[13:23] <FROGGS> moritz: you kinda can

[13:23] <Woodi> err... hmm

[13:23] <FROGGS> perl6 -I. -Mscript -e""

[13:24] *** ifim left
[13:25] <moritz> except that you're now subject to module loading semantics

[13:25] <FROGGS> aye

[13:26] <FROGGS> well, -I. gives you a CURLF, which should be okay for this task

[13:26] <moritz> but still it must be called script.pm{6,}

[13:27] <masak> timotimo: that is true, about `take-rw`. in that case, the caller->callee communication kind of happens *after* the `take-rw` (and the callee doesn't await it)

[13:28] <timotimo> mhm

[13:29] <Woodi> --output part not work for me or is putting not in . 

[13:29] <moritz> define "not work", please

[13:29] <moritz> are blue flames coming out of your computer?

[13:31] <Woodi> just output=script not create file 'script' in .

[13:31] <moritz> do you get an error message?

[13:31] <moritz> did you add -- before "output"?

[13:32] <moritz> did you put it where all the options should go? (that is, before the first non-option argument)?

[13:33] <Woodi> moritz: no error, all looks correct on my side :)

[13:34] <Woodi> ok, it's need .pm :)

[13:36] <timotimo> huh, is that so?

[13:38] <FROGGS> the output must be *.pm(6).moarvm

[13:38] <lizmat> timotimo: yes, because the only way to currently load a precomp, is as a module with -M

[13:38] <lizmat> or -use-  :-)

[13:38] <Woodi> no, I put options in wrong place too :)

[13:38] <timotimo> ah, fair enough

[13:41] <jdv79> hack seems sluggish

[13:42] <jdv79> [Coke]: what are you java'ing?

[13:42] <Woodi> I was just thinking: hey, Perl5 do not have precompilation (standard) but Perl6 have ! do you run C programs *without* compilation ??

[13:42] <jdv79> my vm can't wake up

[13:43] <Woodi> but anyway I kip getting   Malformed UTF-8

[13:43] <timotimo> is some process eating up cpu endlessly again?

[13:43] *** synbot6 joined
[13:44] <Woodi> and possibly  'perl6 -I  ....' is a bug

[13:44] <AlexDaniel> m: 25 . WHAT

[13:44] <camelia> rakudo-moar 649dae: OUTPUT«===SORRY!===␤Method call must either supply a name or have a child node that evaluates to the name␤»

[13:45] <AlexDaniel> the output is not colored, there is no line number…

[13:45] *** mr_ron joined
[13:45] <AlexDaniel> .oO( and again I'm stupid enough not to understand this error )

[13:46] <lizmat> AlexDaniel: I think you stumbled on a side-effect of the recent infix:<.> addition

[13:47] <lizmat> that was not anticipated by TimToady, please rakudobug

[13:47] <AlexDaniel> lizmat: well, that's what I was testing, so…

[13:47] <timotimo> moritz: kindly help me with accessing hack? what's my user name again? the stored password i have doesn't work for either timo or timotimo :|

[13:47] <AlexDaniel> lizmat: sure :)

[13:47] <moritz> timotimo: there's a "timo" user

[13:48] <moritz> timotimo: shall I reset your password?

[13:48] <timotimo> that'd help, thanks

[13:49] <moritz> btw I highly recommend ssh-key based authentication :-)

[13:49] <jdv79> [Coke]: around?

[13:49] <timotimo> i thought i had already set that up, but it didn't trigger

[13:49] <jdv79> that takes moer effort

[13:49] <timotimo> i'm confused about the status of this, tbh

[13:50] <timotimo> now i get in via ssh id

[13:50] <moritz> fwiw ssh-copy-id is a very handy tool :-)

[13:51] <timotimo> that's what i used :)

[13:51] <mr_ron> Could somebody please help with merging perl6-community-modules/uri PR 14?  If I just sit and wait nobody seems to get to it.

[13:52] <lizmat> URL ?

[13:52] <mr_ron> URI

[13:52] <mr_ron> yes thanks.

[13:52] <moritz> mr_ron: what's your github ID?

[13:52] <lizmat> I meant, URL of the PR 

[13:52] <mr_ron> moritz: ronaldxs

[13:53] <mr_ron> https://github.com/perl6-community-modules/uri/pull/14

[13:53] *** tokuhiro_ joined
[13:53] <moritz> mr_ron: I've given you access to the perl6-community-modules org

[13:53] <lizmat> mr_ron: it seems to have conflicts ?

[13:53] *** FROGGS left
[13:55] <mr_ron> I am not familiar with resolving conflicts on github.  I suspect it is a small change made by one other person that I will be happy to integrate.

[13:55] <mr_ron> thank you moritz

[13:57] *** tokuhiro_ left
[13:59] <lizmat> .tell jnthn should a MoarVM upgrade invalidate precomps?  Should a NQP upgrade ?

[13:59] <yoleaux> lizmat: I'll pass your message to jnthn.

[13:59] <moritz> mr_ron: you can't resolve conflicts on github; you must resolve them on the command line

[13:59] <moritz> mr_ron: and then push the resolution to the branch from which you made the pull request

[14:00] <moritz> (or directly to master, now that you have direct push access)

[14:01] <mr_ron> moritz: thank you for your help.  I am trying to google how to find the conflict but if you can tell me easily I will be happy to read.

[14:02] <timotimo> lizmat: moarvm upgrade should only ever be invalidating if the serialization format used has become unsupported, which happens *very* rarely

[14:02] <moritz> mr_ron: in you git repo, do a git checkout master; git pull; git checkout yourbranch; git merge master

[14:02] <moritz> mr_ron: that should show you the conflict, and include instructions on how to resolve it

[14:02] <timotimo> lizmat: nqp upgrade on the other hand will force a rakudo upgrade as well, which means the core setting gets regenerated and no module can ever be loaded with a "new" version of rakudo again

[14:02] <mr_ron> thank you very much ... working on it now ...

[14:04] <lizmat> timotimo: so if we want any SHA indicating precomp compatibility, it would require the serialization format version to be part of it

[14:05] <timotimo> the thing is that moarvm supports multiple versions of the serialization format at the same time

[14:05] * lizmat is feeling she's getting drawn into a ever deeper rabbit hole  :-(

[14:05] <lizmat> *an

[14:06] *** pmurias joined
[14:06] <pmurias> lizmat: a NQP upgrade should invalidate precomp

[14:09] <pmurias> lizmat: I would invalidate precomp on MoarVM upgrade too

[14:09] *** Ven left
[14:10] *** jasanj` joined
[14:10] <pmurias> lizmat: it seems like it's possible to for example change an op number from MoarVM

[14:11] <jasanj`> m: <1 2 3>.WHAT

[14:11] <camelia> rakudo-moar 649dae: ( no output )

[14:11] <lizmat> I just realised that the directory layout in https://gist.github.com/lizmat/f3807956c354c14902a3 won't work  :-(

[14:11] <jasanj`> m: say <1 2 3>.WHAT

[14:11] <camelia> rakudo-moar 649dae: OUTPUT«(List)␤»

[14:11] <lizmat> so I need to look at alternatives

[14:14] <pmurias> lizmat: re CURLF not supporting precompilation don't we want to use precompilation while developing too?

[14:14] <lizmat> potentially, yes

[14:15] <lizmat> but it's going to be tricky to get all dependencies right

[14:17] <pmurias> IMHO it's really important when doing something like make test

[14:18] <lizmat> suppose we have Foo::Bar precompiled

[14:18] <lizmat> it uses Zippo, but you changed it

[14:18] <moritz> then loading Foo::Bar must load all dependencies

[14:18] <lizmat> by removing an exported sub

[14:19] <moritz> one of them has a modification timestamp newer than the precompiled file

[14:19] <lizmat> and also precomp then

[14:19] <moritz> so you have to re-precomp it, and all its reverse dependencies

[14:19] <lizmat> but can you tell from the pre-comped file what its dependencies are ?

[14:19] <timotimo> pmurias: we don't change op numbers

[14:20] <moritz> lizmat: well, that must be added if it's not there already

[14:20] <timotimo> pmurias: we've got a few numbers already in moar that just "die 'deprecated op hit'" or something like that

[14:20] <lizmat> I think you very quickly get into a situation where you would need to precomp everything you're working on

[14:20] <timotimo> and when you add new ops or change old ones, you have to get a new QASTCompiler anyway

[14:21] * lizmat goes cycling to get some fresh ideas

[14:21] <moritz> lizmat: I don't think there's a way around that

[14:21] <lizmat> moritz: so what is the use of precomp in a CURLF then ?

[14:21] <pmurias> timotimo: ok, so it seems like it's not necessary unless someone is trying to be evil on purpose

[14:21] <pmurias> lizmat: re precomp everything you'r working on, I think that's what we should be aiming for

[14:22] <timotimo> at least us moar devs wouldn't be evil like that; or letting evil commits through

[14:22] <timotimo> and in any case, there's the MOAR_REVISION in between

[14:22] <moritz> lizmat: the use is that if you you change some files once, and run 20 test files, you still need only one recompile cascade when running the first test file, and the other 19 don't need one

[14:23] <pmurias> moritz: you don't need to recompile the reverse dependencies

[14:23] <pmurias> moritz: you can just leave them invalidated and recompile as needed

[14:24] <pmurias> is there much cost for precompiling vs just compiling and not saving the bytecode?

[14:24] <moritz> pmurias: yes; I meant the reverse dependencies that made us look at the changed file in the first place

[14:25] <timotimo> i wouldn't say there's really a difference between "we have to recompile all the revdeps" and "invalidating one will cause a cascade of invalidation that'll recompile everything"

[14:27] <moritz> timotimo: the difference is that if you have A1 and A2 depend on B, B changes, and you only use A1, you don't need to recompile A2

[14:28] *** RabidGravy joined
[14:29] *** jasanj` left
[14:31] <timotimo> ah

[14:31] <timotimo> good point

[14:32] *** xinming left
[14:33] *** laouji left
[14:33] <jdv79> moritz: do you know if hack as the "Intel Virtualization" set on in the bios?

[14:34] <jdv79> *has

[14:34] <moritz> jdv79: uhm, hack itself is a virtual machine

[14:34] <jdv79> oh i thought it was hw

[14:34] <moritz> no, kvm

[14:34] <jdv79> that complicates thingss

[14:34] <jdv79> ugh

[14:35] *** brrt left
[14:35] <[Coke]> jdv79: Daily, I build nqp-j and rakudo-j, and run the full test suite on both.

[14:35] <[Coke]> (nqp-j actually gets built 2x.)

[14:35] <timotimo> jdv79: but we own the machine that hosts hack

[14:35] <timotimo> jdv79: so if you need a vm for something, you can "hoist it up", so to speak

[14:36] <[Coke]> I was going to ask why were running a virtual machine on hack. :)

[14:37] <moritz> though running docker on hack shouldn't be a problem

[14:37] <moritz> (and iirc vagrant also supports containers by now)

[14:37] <[Coke]> looks like jdv79 is running virtual box 2x.

[14:37] <jdv79> i only have the vagrant/virtualbox setup

[14:38] <[Coke]> er, on 2cpus.

[14:39] <jdv79> if you guys know how to get that running that'd be nice

[14:39] <jdv79> i know very little about such things

[14:40] <jdv79> i just want a quick and easy way to protoype the metacpan stuff

[14:47] *** Skarsnik joined
[14:48] <moritz> jdv79: sorry, I can't invest too much energy/time; loads of other unfinished construction sites :/

[14:52] <Skarsnik> Hi, I have issue installing panda. It fail on a module check it seems : http://pastebin.com/zYVt7HdD

[14:54] *** tokuhiro_ joined
[14:59] *** tokuhiro_ left
[14:59] <tony-o> did you try nuking it?

[14:59] <colomon> do we have a rakudo on Win32 MSI?

[15:00] * colomon needs to get GLR on his ancient Windows VM

[15:02] * TimToady probably borked panda last night

[15:03] <TimToady> there are several instances of push that need to be append now

[15:03] <colomon> …. append?

[15:04] <TimToady> push is now primarily for pushing a single thing, and append is for appending lists

[15:04] <moritz> we're going full python without our Array method names :-)

[15:04] <moritz> *with

[15:07] <jnthn> .tell lizmat MoarVM's backcompat should be strong enough that you don't need to invalidate on a MoarVM update. And from a development/debugging perspective, I'd really like to not cause a Moar update to invalidate also.

[15:07] <yoleaux> 29 Sep 2015 22:45Z <ShimmerFairy> jnthn: I agree with you on the exceptions, I wonder if the introduction of +args would let us roll back some of the exceptions. Needing  for @$foo { ... }  (or zen slice) for Scalar containers is particularly unfortunate to me :(

[15:07] <yoleaux> 00:54Z <TimToady> jnthn: thing is, @dest.push(@src.pop) is just wrong, wrong, wrong, because surprise; we really need to separate out the I-expect-to-push-a-list semantics to a different name, .pushem or some such

[15:07] <yoleaux> 08:00Z <FROGGS> jnthn: no hurry :o)

[15:07] <yoleaux> 13:59Z <lizmat> jnthn: should a MoarVM upgrade invalidate precomps?  Should a NQP upgrade ?

[15:07] <yoleaux> jnthn: I'll pass your message to lizmat.

[15:07] <jnthn> .tell lizmat NQP upgrade should, but that you already get for free with the compilation unit ID from in Perl6::Compiler

[15:07] <yoleaux> jnthn: I'll pass your message to lizmat.

[15:08] <jnthn> TimToady: I see you ended up with separate methods, one of which follows the one-arg rule; I guess push now only accepts a single value?

[15:08] * jnthn is fine with that, anyways...

[15:08] <TimToady> not exactly

[15:08] <TimToady> it's ** now, but mainly because we need to be able to slip on it

[15:08] <jnthn> ah

[15:09] <TimToady> seq op depends on it

[15:09] * jnthn isn't clever enough to understand the seq op implementation :)

[15:10] <TimToady> but yeah, the BDLF wasn't very B last night...

[15:11] <jnthn> I'm OK-er with us getting append/prepend that follow the single arg rule than just a .push that doesn't.

[15:11] <mr_ron> moritz and lizmat I fixed the conflicts for the pull request https://github.com/perl6-community-modules/uri/pull/14

[15:12] * jnthn wonders if unshift also got a **@a version...

[15:15] <jnthn> ah, yes

[15:15] <jnthn> though it'll want a single arg multi candidate for perf reasons

[15:15] <jnthn> As will push

[15:15] <mr_ron> moritz: sorry I hadn't accepted your invitation yet.  Now I did and I just did the merge ... thanks again

[15:18] *** dha joined
[15:21] <mr_ron> Sorry - to finish the PR on URI and keep LWP::Simple and rakudo star from breaking I need help with one more small pull request: https://github.com/cosimo/perl6-lwp-simple/pull/59

[15:22] <mr_ron> It's not a big pull request - can anyone help?

[15:26] <mr_ron> In the worst case when the user authentication test for LWP::Simple fails someone may notice my PR and merge it ...

[15:29] * TimToady is generating a pull request to fix panda

[15:30] *** Ven joined
[15:37] <TimToady> pull request generated, now someone with panda access needs to apply it

[15:40] *** zakharyas left
[15:45] *** khw joined
[15:45] *** larion left
[15:46] *** skids joined
[15:46] <jdv79> moritz: can you install and start elastic search?

[15:51] <TimToady> and one patch to rakudobrew, though it might have other deps that need fixing

[15:52] *** Ven left
[15:55] *** Ven joined
[16:00] *** lichtkind joined
[16:00] <lichtkind> good morning

[16:01] <lichtkind> is here an aadmin of the gihub group?

[16:01] *** liztormato joined
[16:03] <liztormato> TimToady: will merge the panda PR when I'm home again in about 2 hours. Unless someone beats me to it

[16:03] <jdv79> moritz: hold off - it seems latest is not good:(

[16:03] <TimToady> on those pull requests, I did s/push/append/ but if you wish to be backward compatible to older perl6es you can s/push: stuff/push: |stuff/ instead

[16:05] <lichtkind> moritz: can you create a new github prject?

[16:07] *** dha left
[16:08] <liztormato> On a similar note. I wonder whether it would be a good idea to separate map into a map and a filter function. Map guaranteeing always 1 return value. An filter

[16:08] <liztormato> And filter could return 0 or more values

[16:08] <moritz> lichtkind: yes

[16:09] <timotimo> huh, my intuition would be that filter would only ever return 1 or 0 results

[16:09] <timotimo> just from the name alone, i mean

[16:09] <lichtkind> moritz: i want to do a parallel tutorial to my already existing 9 part perl 5 tut

[16:10] <lichtkind> something like notable tutorial or something like this

[16:10] <liztormato> Well. One function guranteeing 1to1 mapping. The other 1to0+. Mapping

[16:10] <lichtkind> i man i can host it on my account but maybe better bundeld here

[16:10] <lichtkind> since i want to complete it till dezember 

[16:10] <TimToady> liztormato: one could intuit itemish return from --> Type

[16:10] *** jasanj` joined
[16:11] <liztormato> Good point. ;-)

[16:11] *** telex left
[16:11] *** Ven left
[16:11] <timotimo> oh, and depending on the return type fall back to a simpler implementation that may run faster?

[16:12] <liztormato> Yup

[16:12] *** telex joined
[16:12] <timotimo> the first time type hints (apart from native types of course) actually give a performance improvement :P

[16:15] <TimToady> er, nevermind on the rakudobrew PR, since it's P5 code...

[16:15] <jnthn> I suspect we can get the Slip check pretty fast once Moar's inlining and/or tracing is better

[16:16] <jnthn> As in, probably get it removed in a lot of cases.

[16:16] <jnthn> timotimo: Putting a Str type hint on something you interpolate into a regex also has quite drastic impact :)

[16:16] <liztormato> Slip check?

[16:16] <timotimo> oh! of course

[16:17] <jnthn> liztormato: The only case a map isn't n-to-1 is when it returns a Slip

[16:17] *** cognominal_ left
[16:17] *** schmoost1r left
[16:18] <liztormato> Ok. But a block could be returning a Slip in on iteration. Amd

[16:18] <liztormato> And something else in another

[16:18] *** schmooster joined
[16:18] *** schmooster left
[16:18] *** schmooster joined
[16:18] <jnthn> liztormato: Not if it has a return type decl saying otherwise ;)

[16:19] <jnthn> liztormato: Or if we can dynamically figure out that can't happen

[16:19] <jnthn> (At spesh time)

[16:19] <TimToady> that's part of why I wanted to make sure -> --> worked right

[16:19] <jnthn> :)

[16:20] *** rivarun joined
[16:20] <TimToady> m: say map -> $x --> True { say $x }, 1..5

[16:20] <camelia> rakudo-moar 649dae: OUTPUT«1␤2␤3␤4␤5␤(True True True True True)␤»

[16:22] <TimToady> when last I checked, -> --> didn't work, but either it fixed itself in the last month or two, or my definite return changes fixed it somehow

[16:22] <liztormato> 1m: say map -> $x --> True { say $x; 42 }, 1..5

[16:22] <tony-o>  

[16:22] <TimToady> doesn't really matter, but it works now anyway

[16:23] *** lichtkind left
[16:24] * TimToady hopes push -> append is the last major breaking change

[16:24] * jnthn also

[16:25] * jnthn was a little surprised to see the o operator sneak in too

[16:25] <TimToady> that's just more for FP cred, and wasn't breaking anything

[16:25] <jnthn> :)

[16:26] *** kid51 left
[16:26] <liztormato> 1Fluent or Functional cred?

[16:26] <TimToady> liztormato: your comments aren't coming through

[16:27] <Skarsnik> hum, it there a way to tell rakudobrew to put everything it install on another dir?

[16:28] <liztormato> ...

[16:28] <Skarsnik> I mean, without having to cp -r manually after

[16:31] *** Ven joined
[16:31] <TimToady> oh wow, it's raining, maybe we're finally getting a bit of the promised El Niño deluge

[16:32] <TimToady> I'd better go wash the Yellowstone dirt off my car, which is, like 3 months old (the dirt, not the car)

[16:33] *** captain-adequate joined
[16:34] <liztormato> Don't you have geysers for that?

[16:35] <jdv79> could someone install curl-config on hack?

[16:37] *** Ven left
[16:37] <moritz> jdv79: done

[16:38] <jdv79> thanks

[16:48] *** ilbot3 left
[16:48] *** Ven joined
[16:50] *** abraxxa left
[16:51] *** PerlJam left
[16:51] *** [Coke]_ joined
[16:51] *** ilbot3 joined
[16:51] *** sergot left
[16:51] *** [Coke] left
[16:51] *** Util left
[16:51] *** Util joined
[16:51] *** sergot joined
[16:51] *** psch left
[16:53] *** moritz joined
[16:53] *** PerlJam joined
[16:54] *** psch joined
[16:54] *** liztormato left
[16:55] *** z448 joined
[16:55] *** tokuhiro_ joined
[16:57] *** pmurias_ joined
[16:59] *** Util left
[17:00] *** tokuhiro_ left
[17:00] *** pmurias left
[17:01] *** ribasushi left
[17:07] *** Util joined
[17:09] *** ribasushi joined
[17:09] *** Ven left
[17:24] <[Coke]_> lizmat: your comments were black on black here.

[17:24] *** [Coke]_ is now known as CokeZero

[17:24] *** CokeZero is now known as [Coke]

[17:27] *** dakkar left
[17:37] *** spider-mario joined
[17:37] <jdv79> successs.  i think.  i *believe* i have a workable metacpan instance on hack.

[17:38] <jdv79> of course since the wifi on my end is a bit < a 14.4 modem i can't see it so i'll set it up when i can.

[17:38] <jdv79> thanks moritz

[17:41] *** ribasushi left
[17:45] <[Coke]> jdv79++

[17:49] *** ribasushi joined
[17:51] *** sufrostico joined
[17:55] *** espadrine left
[17:59] *** ribasushi left
[18:01] *** TEttinger joined
[18:03] *** andreoss left
[18:04] * [Coke] tries TEST_JOBS=400 make spectest.

[18:05] <[Coke]> yay, that's a bad idea. :)

[18:07] *** ribasushi joined
[18:08] <[Coke]> (surprisingly, only bad, not horrible)

[18:09] *** vendethiel joined
[18:11] * vendethiel hopes he'll be able to persuade TimToady++ to remove every kind of implicit flattening/one-arg-rule-thing in Perl7 :P

[18:11] <moritz> jdv79: fwiw hack had a bit of trouble with its uplink

[18:12] *** supernovus joined
[18:13] *** ribasushi left
[18:13] *** Hor|zon left
[18:14] <[Coke]> S06-operator-overloading/sub.t seems slow for what it's doing. adding unicode operators slow, maybe?

[18:16] *** ribasushi joined
[18:16] <[Coke]> m: END { say "hi"}; exit;

[18:16] <camelia> rakudo-moar 649dae: OUTPUT«hi␤»

[18:16] <jnthn> [Coke]: Adding operators in general is, 'cus it has to derive a new parser, and so compute a new set of LTM tables, and we're not clever enough to re-use the unaffected ones yet

[18:17] <[Coke]> jnthn: fair enough.

[18:18] <[Coke]> jnthn: OOC, did you see the ticket about ./perl6 --profile -e "exit" ?

[18:19] *** Hor|zon joined
[18:19] *** larion joined
[18:20] <jnthn> [Coke]: yeah; didn't work out what's going on yet

[18:31] *** leont joined
[18:32] *** Hor|zon left
[18:33] <lizmat> jnthn: if there is an nqp:: op that needs to be done for the profiler

[18:33] <yoleaux> 15:07Z <jnthn> lizmat: MoarVM's backcompat should be strong enough that you don't need to invalidate on a MoarVM update. And from a development/debugging perspective, I'd really like to not cause a Moar update to invalidate also.

[18:33] <yoleaux> 15:07Z <jnthn> lizmat: NQP upgrade should, but that you already get for free with the compilation unit ID from in Perl6::Compiler

[18:33] <lizmat> we could add it to sub exit ?

[18:34] <lizmat> or maybe nqp::exit should be made smarter ?

[18:34] <lizmat> nine++  # beating me to merging TimToady's panda PR

[18:36] <timotimo> hm

[18:36] *** yqt joined
[18:37] <timotimo> from nqp code, what's the easiest way to get a stack trace without causing an exception to fly?

[18:38] *** FROGGS[tab] joined
[18:38] <supernovus> Was there a bot that takes code snippets or error messages and creates a pastebin of them?

[18:38] <yoleaux> 27 Oct 2014 04:37Z <tony-o> supernovus: i'm trying to use xml::query and when i do .new(xml => $xml) i'm getting 'Cannot create an instance of that type', any clues?  Tests are now failing when I install from panda as well

[18:38] <yoleaux> 28 Oct 2014 04:36Z <tony-o> supernovus: im getting install errors only with panda  . the way it suggests testing passes if i clone your repo (just fyi)

[18:38] <yoleaux> 20 Mar 2015 08:18Z <moritz> supernovus: in HTTP::Easy and XML::Query, please replace at_pos by AT-POS

[18:38] <yoleaux> 14 Apr 2015 04:46Z <tony-o> supernovus: is supernovus

[18:40] <jdv79> moritz: ah

[18:40] <FROGGS[tab]> o/

[18:41] <lizmat> FROGGS[tab] \o

[18:42] <[Coke]> lizmat: if I read the code right, the profiler is creating an END block to get invoked. in general, exit calls END blocks.

[18:42] <lizmat> yup, it does...

[18:42] <lizmat> m: END say "goodbye"; exit

[18:42] <camelia> rakudo-moar 649dae: OUTPUT«goodbye␤»

[18:42] <supernovus> Anyway, I just tried bootstrapping panda, and got the following message: http://pastebin.com/RepEgnNL

[18:42] *** yqt left
[18:42] <Skarsnik> hm, I still can't build panda. does copy an already rakudo install work? or do I need to edit some path?

[18:43] <moritz> Skarsnik: rakudo isn't relocatable

[18:43] <moritz> Skarsnik: currently you have to recompile if you want it to run in a different location

[18:43] *** ribasushi left
[18:44] *** sufrostico left
[18:45] <Skarsnik> ok. I get this error when trying to build panda with rakudobrew http://pastebin.com/zYVt7HdD

[18:46] <supernovus> Skarsnik: looks like we both are having problems installing panda, but weirdly, they are different problems! (I'm installing with my own script which may need some updates, as it's been a while since I've been active in the Perl 6 world.)

[18:47] *** yqt joined
[18:47] <supernovus> I need to run. Be back later.

[18:47] *** supernovus left
[18:47] *** ribasushi joined
[18:49] *** rindolf left
[18:49] *** Hor|zon joined
[18:50] <dalek> rakudo/curli: 1c4fc58 | lizmat++ | CURLI:

[18:50] <dalek> rakudo/curli: Some directory layout changes (work in progress)

[18:50] <dalek> rakudo/curli: review: https://github.com/rakudo/rakudo/commit/1c4fc585c6

[18:53] *** rindolf joined
[18:55] <dalek> perl6-most-wanted: 427d731 | (Zoffix Znet)++ | most-wanted/modules.md:

[18:55] <dalek> perl6-most-wanted: Pastebin::Shadowcat for App::Nopaste

[18:55] <dalek> perl6-most-wanted: 

[18:55] <dalek> perl6-most-wanted: Mentioned Pastebin::Shadowcat for App::Nopaste entry

[18:55] <dalek> perl6-most-wanted: review: https://github.com/perl6/perl6-most-wanted/commit/427d7319b5

[18:57] *** tokuhiro_ joined
[18:58] <rindolf> Zoffix: nice!

[18:58] *** cognominal joined
[18:58] <rindolf> Zoffix++

[18:59] <TimToady> Skarsnik: your panda needs the latest panda patch that nine++ just merged

[19:00] <TimToady> dunno what's wrong with the other one

[19:00] <Skarsnik> how I do that? x)

[19:00] <TimToady> git clone?

[19:01] <TimToady> git clone https://github.com/tadzik/panda.git

[19:01] *** [Sno] left
[19:02] *** tokuhiro_ left
[19:02] <PerlJam> Skarsnik: rakudobrew nuke moar; before you rakudobrew build moar

[19:02] <TimToady> will that reclone panda?

[19:03] <PerlJam> rakudobrew build-panda should, but I've found the only way to get everything reliably up to date is to nuke first

[19:04] <Skarsnik> I rm the panda directory and relaunch rakudobrew build-panda

[19:07] <Skarsnik> ok, thx, it works now :)

[19:07] <TimToady> whew!

[19:07] <PerlJam> cool

[19:07] <TimToady> now we just have to fix Everything Else I Broke Last Night

[19:12] *** shlomif joined
[19:13] *** rindolf left
[19:13] *** shlomif is now known as rindolf

[19:14] *** araujo left
[19:15] *** araujo joined
[19:16] <[Coke]> TimToady: Or, as well call that here, Wednesdays.

[19:17] *** vendethiel left
[19:17] <geekosaur> heh

[19:19] *** larion left
[19:21] <TimToady> Trouble is, I'm getting into the habit of believing six possible things after dinner...

[19:22] <TimToady> which reminds me, lunch &

[19:23] * PerlJam notes that "after dinner" is still "before breakfast"

[19:23] <PerlJam> so all you need to do is twiddle the possibility knob and you're set!

[19:27] <colomon> Is there any difficulty in believing six *possible* things?

[19:28] <PerlJam> difficulty? no.  utility? probably not.

[19:30] <Skarsnik> ah yes LWP::Simple fail it tests like someone ention earlier x)

[19:32] *** larion joined
[19:33] <jnthn> lizmat: My first guess is that the exit op in Moar needs to get smarter

[19:37] *** darutoko left
[19:42] *** n_i_c_k left
[19:42] *** n_i_c_k joined
[19:54] *** ribasushi left
[20:00] *** ribasushi joined
[20:00] <lizmat> m: say (-> --> Int { }).returns   # shouldn't that need to say "(Int)" ?

[20:00] <camelia> rakudo-moar 649dae: OUTPUT«(Mu)␤»

[20:01] <lizmat> Ah, it seems Blocik.returns gets its .returns from Callable

[20:01] <dalek> roast: 4f47646 | usev6++ | S32-array/pop.t:

[20:01] <dalek> roast: Fudge test ('todo') for code which doesn't die, actually

[20:01] <dalek> roast: review: https://github.com/perl6/roast/commit/4f47646941

[20:01] <dalek> roast: de0e1f1 | usev6++ | S (11 files):

[20:01] <dalek> roast: Replace more eval-dies-ok with throws-like

[20:01] <dalek> roast: review: https://github.com/perl6/roast/commit/de0e1f15ac

[20:03] *** rindolf left
[20:03] <lizmat> m: say (-> --> Int { }).signature.returns

[20:03] <camelia> rakudo-moar 649dae: OUTPUT«(Int)␤»

[20:03] <lizmat> seems we need to move Routine.returns up to Block.returns

[20:03] <lizmat> or maybe even to Callable ?

[20:06] <jnthn> Block

[20:06] <jnthn> Code.returns doesn't really make sense, I don't think

[20:09] *** zoosha left
[20:09] *** zoosha joined
[20:10] <lizmat> jnthn: but Code has an $!signature attribute ?

[20:10] *** vvz joined
[20:13] <jnthn> lizmat: For now, but not sure it will forever :)

[20:13] <jnthn> lizmat: Would rather keep the option to slim thunks down a little in the future, if we can.

[20:13] <lizmat> well, if it gets moved, the methods can move as well?  Seems more logical to keep them close to the place where we can say $!signature

[20:14] <lizmat> but if you rather I put them in b

[20:14] <jnthn> lizmat: Not sure we'll be able to easily "just move methods" after 6.christmas :)

[20:14] <lizmat> Block and use nqp::getattr, that would be fine by me as well

[20:14] <lizmat> but why *is* $!signature now an attribute of Code and not of Block ?

[20:14] <jnthn> Not sure, possibly mostly historical reasons.

[20:15] *** ZoffixWork joined
[20:15] <lizmat> want me to try moving it to Block and see what breaks ?

[20:15] <jnthn> You can if you're curious enough ;)

[20:16] <ZoffixWork> Hey. What's the idiomatic way in Perl 6 to handle errors? In Perl 5, for example, it common to "return undef or an empty list". 

[20:16] <timotimo> you can throw an exception

[20:16] <jnthn> Exceptions of failures.

[20:16] <jnthn> s/of/or/

[20:16] <ZoffixWork> Thanks. I'll look that up.

[20:16] <TimToady> fail lets the caller decide how to handle things

[20:16] *** colomon left
[20:17] <jnthn> Failures are "lazy" exceptions that can be defused by testing them for definedness or truth

[20:17] <TimToady> or fatalized by 'use fatal'

[20:17] <ZoffixWork> :O Perl 6 sounds so awesome! 

[20:17] <jnthn> *nod*

[20:17] <jnthn> heh, that was to TimToady, but works for ZoffixWork's comment too :D

[20:17] <TimToady> *nod*

[20:17] <ZoffixWork> :D

[20:18] *** _dolmen_ joined
[20:19] *** [Sno] joined
[20:23] <Skarsnik> hm, how you can deference? a cpointer pointing to a struct to get its member with zavolaj? I found a self.bless : $surface on Cairo. is that the way?

[20:24] *** vendethiel joined
[20:25] <dalek> roast: c3e76c4 | usev6++ | S06-operator-overloading/imported-subs.t:

[20:25] <dalek> roast: Remove test for behavior of eval-dies-ok

[20:25] <dalek> roast: review: https://github.com/perl6/roast/commit/c3e76c4d5c

[20:25] <dalek> roast: c549562 | usev6++ | S32-str/substr.t:

[20:25] <dalek> roast: Remove fudged test, substr works with Any as argument

[20:25] <dalek> roast: 

[20:25] <dalek> roast: The removed test was based on RT #76412. Nowadays

[20:25] <synbot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=76412

[20:25] <dalek> roast: substr is implemented in src/core/Str.pm and coerces

[20:25] <dalek> roast: its argument to Str.

[20:25] <dalek> roast: review: https://github.com/perl6/roast/commit/c549562cbe

[20:26] <[Coke]> is zavolaj still a separate thing, or is that all Nativecall now?

[20:27] <Skarsnik> from https://github.com/jnthn/zavolaj Starting from 2015.02, the NativeCall module ships with the Rakudo Perl 6 compiler, so there is no need to install it separately.

[20:29] <[Coke]> That's what I thought.

[20:30] <jnthn> The repo is only there to point people at the fact they don't need to be looking at it any more :)

[20:30] <jnthn> And yeah, I guess I have to say goodbye to a cute project name :)

[20:30] *** Ven joined
[20:32] <Skarsnik> so where is the updated document if it exists? x) still here?

[20:33] <jnthn> http://doc.perl6.org/language/nativecall

[20:33] <jnthn> If you mean the docs for how to use it :)

[20:34] *** colomon joined
[20:34] <Skarsnik> too sad, searching NativeCall does not point to it x)

[20:34] <dalek> rakudo/nom: dd46c30 | TimToady++ | src/core/Junction.pm:

[20:34] <dalek> rakudo/nom: Junction ops can be pure again

[20:34] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/dd46c30b97

[20:36] <Skarsnik> TBD? To be done?

[20:37] <[Coke]> Skarsnik: good find, will open that as a bug.

[20:37] <[Coke]> to be determined, usually

[20:37] <[Coke]> S99:TBD

[20:37] <synbot6> Link: http://design.perl6.org/S99.html#TBD

[20:37] <[Coke]> ... ah well.

[20:38] <[Coke]> Skarsnik: search for "native"

[20:38] <dalek> roast: 3c166d9 | usev6++ | S12-methods/trusts.t:

[20:38] <dalek> roast: Fix test for trust relation, passed for the wrong reason

[20:38] <dalek> roast: review: https://github.com/perl6/roast/commit/3c166d9af6

[20:38] <[Coke]> but yes, we should still find nativecall

[20:40] *** larion left
[20:44] *** ribasushi left
[20:45] *** tokuhiro_ joined
[20:46] *** Ven left
[20:47] *** ribasushi joined
[20:49] <dalek> roast: f9a512e | usev6++ | S12-enums/thorough.t:

[20:49] <dalek> roast: Fudge test ('todo') which passed for the wrong reason

[20:49] <dalek> roast: review: https://github.com/perl6/roast/commit/f9a512e07d

[20:49] *** saaki joined
[20:50] <ZoffixWork> BTW, what's GLR? I keep seeing it mentioned all over the place.

[20:51] <PerlJam> Great List Refactor

[20:51] <ZoffixWork> Thanks.

[20:51] <PerlJam> The G and R words a a little fluid, but the L is always List  

[20:51] <jnthn> ZoffixWork: It was a bunch of work to improve list/iterator handling in Perl 6 that's now completed. :)

[20:52] <PerlJam> s/a a/are a/

[20:52] <lizmat> jnthn: I was curious and got this far: https://gist.github.com/lizmat/bc4111d25b34e52c5489

[20:52] <lizmat> then it became too meta for me... :-)

[20:53] <Skarsnik> jnthn, so there is no way to access member of a struct given with a cpointer?

[20:53] <jnthn> lizmat: Some of the places changing Code to Block in Actions/World look a tad suspect to me also :)

[20:54] <jnthn> Skarsnik: NativeCall has evolved a good bit since I last worked on it, but I think you would cast the CPointer to the CStruct.

[20:55] *** tokuhiro_ left
[20:57] *** xfix left
[20:59] *** kaare_ left
[20:59] <Skarsnik> cast? like my Struct $s = $pointer; ?

[20:59] *** sufrostico joined
[21:00] *** ribasushi left
[21:01] <masak> 'night, #perl6

[21:03] *** ribasushi joined
[21:03] <ZoffixWork> \o

[21:05] <dalek> roast: 0a36554 | usev6++ | S06-signature/closure-parameters.t:

[21:05] <dalek> roast: Fudge test which passed for the wrong reason

[21:05] <dalek> roast: review: https://github.com/perl6/roast/commit/0a3655493f

[21:05] <dalek> roast: 10a849d | usev6++ | S06-signature/definite-return.t:

[21:05] <dalek> roast: Replace another two eval-dies-ok with throws-like

[21:05] <dalek> roast: review: https://github.com/perl6/roast/commit/10a849d01f

[21:05] <lizmat> bartolin++  # finding tests that passed for the wrong reason

[21:07] *** supernovus joined
[21:08] <supernovus> I changed my build script so instead of using bootstrap.pl it uses rebootstrap.pl and it appears to work properly now.

[21:11] <bartolin> lizmat: speaking of those tests: there are some more in S04-statements/return.t. I made a PR for roast the other day: https://github.com/perl6/roast/pull/70

[21:12] * bartolin wonders if there is a better way to test for that error (Attempt to return outside of any Routine) than resorting to 'run'

[21:12] *** colomon left
[21:13] <bartolin> m: use Test; throws-like q[return 1], X::ControlFlow::Return  # does not die

[21:13] <camelia> rakudo-moar dd46c3: OUTPUT«    1..2␤    not ok 1 - 'return 1' died␤    ␤# Failed test ''return 1' died'␤# at /tmp/jFh3ELhGuL line 1␤    ok 2 - # SKIP Code did not die, can not check exception␤    # Looks like you failed 1 test of 2␤not ok 1 - did we throws-like X::Cont…»

[21:14] <bartolin> m: return 1

[21:14] <camelia> rakudo-moar dd46c3: ( no output )

[21:14] <bartolin> $ perl6-m -e 'return 1'

[21:14] <bartolin> Attempt to return outside of any Routine

[21:16] <jnthn> m: return 1; CATCH { defualt { say "caught $_" } }

[21:16] <camelia> rakudo-moar dd46c3: OUTPUT«5===SORRY!5=== Error while compiling /tmp/1A715f3XfY␤Undeclared routine:␤    defualt used at line 1␤␤»

[21:16] <jnthn> m: return 1; CATCH { default { say "caught $_" } }

[21:16] <camelia> rakudo-moar dd46c3: ( no output )

[21:16] <jnthn> hm, not like that :)

[21:16] <bartolin> yeah, I think i tried that :-)

[21:16] *** skids left
[21:17] <bartolin> I couldn't even catch them with 'is_run' ...

[21:17] <lizmat> even a return inside an EVAL works

[21:18] <lizmat> m: sub a { EVAL "return; say q/bar/" }; a; say "foo"   # not sure if that's ok

[21:18] <camelia> rakudo-moar dd46c3: OUTPUT«foo␤»

[21:18] <lizmat> m: sub a { EVAL "return"; say q/bar/ }; a; say "foo"   # better

[21:18] <camelia> rakudo-moar dd46c3: OUTPUT«foo␤»

[21:20] *** supernovus left
[21:23] *** vendethiel left
[21:23] *** ribasushi left
[21:26] <jnthn> Bumper catch-up progress report: https://6guts.wordpress.com/2015/09/30/those-weeks-much-progress/

[21:27] <dalek> doc: cc4d77c | (Zoffix Znet)++ | lib/Language/regexes.pod:

[21:27] <dalek> doc: Fix typo

[21:27] <dalek> doc: review: https://github.com/perl6/doc/commit/cc4d77ce15

[21:28] *** ribasushi joined
[21:32] *** colomon joined
[21:33] <bartolin> jnthn++  # very interesting progress reports (and all those other good things)

[21:34] <dalek> rakudo/nom: 83e9013 | lizmat++ | src/core/ (2 files):

[21:34] <dalek> rakudo/nom: Move Routine.of/returns to Block

[21:34] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/83e9013f79

[21:36] <dalek> roast: e3494e2 | usev6++ | S13-overloading/typecasting-long.t:

[21:36] <dalek> roast: Replace another eval-dies-ok with throws-like

[21:36] <dalek> roast: review: https://github.com/perl6/roast/commit/e3494e2c8c

[21:37] *** ribasushi left
[21:38] <jnthn> 'night, #perl6

[21:39] <bartolin> o/

[21:39] <lizmat> gnight jnthn 

[21:43] *** ribasushi joined
[21:45] <ZoffixWork> I'm having trouble finding how to do regex replacement in Perl 6. In Perl 5 it's the s/// operator, and in p5-to-6 docs, I see it's mentioned as "still exists in Perl 6", with a link to regex Adverbs, but I'm not seeing anything relevant in adverbs: http://docs.perl6.org/language/5to6-perlfunc#s%2F%2F%2F 

[21:45] <ZoffixWork> m: say 'a' ~~ s/a/A/; # and this doesn't seem to do what I think it would do

[21:45] <camelia> rakudo-moar dd46c3: OUTPUT«Parameter '$self' expected a writable container, but got Str value␤  in block <unit> at /tmp/Z2uO0hcBBa:1␤␤»

[21:46] <geekosaur> m: my $s = 'a'; $s ~~ s/a/A/;

[21:46] <camelia> rakudo-moar dd46c3: ( no output )

[21:46] <geekosaur> whoops

[21:46] <geekosaur> m: my $s = 'a'; $s ~~ s/a/A/; say $s;

[21:46] <camelia> rakudo-moar dd46c3: OUTPUT«A␤»

[21:46] <geekosaur> were you really expecting it to work on a literal/constant?

[21:47] <ZoffixWork> Is there a s///r version? Something that returns the replaced version, while keeping the original intact?

[21:47] <hoelzro> m: my $s = '

[21:47] <camelia> rakudo-moar dd46c3: OUTPUT«5===SORRY!5=== Error while compiling /tmp/TTQ8oNzYj7␤Unable to parse expression in single quotes; couldn't find final "'" ␤at /tmp/TTQ8oNzYj7:1␤------> 3my $s = '7⏏5<EOL>␤    expecting any of:␤        single quotes␤        term␤»

[21:47] <hoelzro> m: my $s = 'foo'; my $t = $s.subst(/foo/, 'bar'); say($s, $t)

[21:47] <camelia> rakudo-moar dd46c3: OUTPUT«foobar␤»

[21:48] <hoelzro> ZoffixWork: the subst method will do that

[21:48] <ZoffixWork> Thanks. geekosaur++ hoelzro++

[21:49] <geekosaur> yeh, I think smartmatch is not the right tool for that operation; you want to use the actual methods (.match or .subst) in that case

[21:51] <geekosaur> you could think of perl 5's =~ as binding $_ locally; perl 6's ~~ is an actual match operator

[21:51] <ZoffixWork> Ah

[21:54] *** ribasushi left
[21:55] *** z448 left
[21:57] *** ribasushi joined
[21:58] *** maettu1 left
[22:00] <[Coke]> I'm having trouble githubbing from hack.

[22:01] <leont> Did my/has TYPE @array change behavior recently?

[22:01] *** synbot6 left
[22:01] <_itz> hmm p6doc is broken by the changes of the last day or so

[22:01] <leont> Or am I observing fallout from the GLR change?

[22:02] <timotimo> probably the latter

[22:03] <timotimo> what's it about?

[22:04] <leont> Method 'method-from-role' must by implemented by Role because it is required by a role

[22:04] <timotimo> oh?

[22:04] <timotimo> i wonder how you got that now, but didn't get it before

[22:05] *** _dolmen_ left
[22:05] <leont> Only element in that list is certainly having that method

[22:05] <leont> I really don't get it

[22:06] <timotimo> that error happens when you compose a role into a class

[22:06] <timotimo> oh, wait

[22:07] *** kid51 joined
[22:07] <timotimo> m: role TestRole { method Foo { ... } }; my TestRole @foo;

[22:07] <camelia> rakudo-moar 83e901: ( no output )

[22:07] <timotimo> m: role TestRole { method Foo { ... } }; my TestRole @foo; @foo[0] = 1 but TestRole

[22:07] <camelia> rakudo-moar 83e901: OUTPUT«Method 'Foo' must be implemented by Int+{TestRole} because it is required by a role␤  in any compose_method_table at gen/moar/m-Metamodel.nqp:2666␤  in any apply at gen/moar/m-Metamodel.nqp:2676␤  in any compose at gen/moar/m-Metamodel.nqp:2812␤  i…»

[22:07] <timotimo> hm.

[22:07] <leont> Smells like a bug to me

[22:08] <timotimo> what does?

[22:08] <leont> Oh wait, that's a tripple dot

[22:08] <timotimo> yeah

[22:08] <leont> Interesting fact: in my case it's triggered by die @array

[22:08] *** Skarsnik_ joined
[22:09] <leont> Or actually, die @array.perl

[22:09] <timotimo> m: role TestRole { method Foo { ... } }; my TestRole @foo; say @foo.perl

[22:09] <camelia> rakudo-moar 83e901: OUTPUT«Method 'Foo' must be implemented by TestRole because it is required by a role␤  in any compose_method_table at gen/moar/m-Metamodel.nqp:2666␤  in any apply at gen/moar/m-Metamodel.nqp:2676␤  in any compose at gen/moar/m-Metamodel.nqp:2812␤  in any …»

[22:09] <timotimo> like that?

[22:12] *** Skarsnik_ left
[22:12] *** Skarsnik left
[22:12] <leont> Something like that

[22:13] <leont> Actualy code is more like:

[22:13] <leont> m: role TestRole { method Foo { ... } }; class TestClass does TestRole { method Foo { say "Awesome" } }; my TestRole @foo = TestClass.new,; say @foo.perl

[22:13] <camelia> rakudo-moar 83e901: OUTPUT«Method 'Foo' must be implemented by TestRole because it is required by a role␤  in any compose_method_table at gen/moar/m-Metamodel.nqp:2666␤  in any apply at gen/moar/m-Metamodel.nqp:2676␤  in any compose at gen/moar/m-Metamodel.nqp:2812␤  in any …»

[22:13] <timotimo> right

[22:13] <leont> but I think yours already shows the bug

[22:13] <timotimo> for some reason, the .perl is trying to pun the role

[22:13] <_itz> bdfl?

[22:13] <timotimo> benevolent dictator for life

[22:13] <lizmat> is it not the my TestRole @foo?

[22:14] <_itz> hahahaha

[22:14] <timotimo> it is not, lizmat 

[22:14] <lizmat> m: my role Foo { method a { ... } }; my Foo $a

[22:14] <camelia> rakudo-moar 83e901: ( no output )

[22:14] <timotimo> the same code without the say won't blow up

[22:14] <lizmat> indeed, I would say rakudobug

[22:16] <dalek> doc: c6bc991 | (Steve Mynott)++ | lib/Perl6/TypeGraph.pm:

[22:16] <dalek> doc: push to append

[22:16] <dalek> doc: review: https://github.com/perl6/doc/commit/c6bc991e5f

[22:16] <dalek> rakudo/nom: 329f9ec | lizmat++ | src/core/Any-iterable-methods.pm:

[22:16] <dalek> rakudo/nom: Change whitespace in sequential-map

[22:16] <dalek> rakudo/nom: 

[22:16] <dalek> rakudo/nom: For better readability / understandability for optimizations to come.

[22:16] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/329f9ecc4b

[22:25] *** oetiker joined
[22:26] *** oetiker left
[22:39] *** skids joined
[22:51] *** tokuhiro_ joined
[22:53] *** mr_ron left
[22:54] *** mr_ron joined
[22:55] *** sufrostico left
[22:56] *** tokuhiro_ left
[23:01] *** ribasushi left
[23:02] *** bjz left
[23:04] *** ribasushi joined
[23:07] *** spider-mario left
[23:10] *** RabidGravy left
[23:14] <leont> I would help too if those errors gave useful line numbers :-s

[23:17] *** erdic left
[23:19] *** erdic joined
[23:26] *** pmurias_ left
[23:27] *** pmurias joined
[23:47] *** Peter_R left
