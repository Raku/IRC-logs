[00:10] *** Ulti left
[00:10] *** Ulti joined
[00:10] *** mrf left
[00:11] *** mrf joined
[00:11] *** mst left
[00:12] *** mst joined
[00:15] *** vendethiel left
[00:17] *** ][Sno][ joined
[00:17] *** [Sno] left
[00:17] *** ][Sno][ is now known as [Sno]

[01:04] *** raiph joined
[01:06] *** cognominal left
[01:08] *** virtualsue left
[01:12] *** jordman joined
[01:13] *** rmgk_ joined
[01:13] *** rmgk left
[01:13] *** rmgk_ is now known as rmgk

[01:14] *** amurf joined
[01:18] *** amurf left
[01:20] *** colomon joined
[01:23] *** bjz joined
[01:49] *** tinyblak joined
[01:56] *** bjz left
[02:00] *** bjz joined
[02:01] *** bjz left
[02:01] *** AlexDaniel left
[02:07] *** skids joined
[02:13] *** aborazmeh joined
[02:13] *** aborazmeh left
[02:13] *** aborazmeh joined
[02:21] *** noganex_ joined
[02:24] *** noganex left
[02:34] <dalek> rakudo-star-daily: f38f36b | coke++ | log/ (9 files):

[02:34] <dalek> rakudo-star-daily: today (automated commit)

[02:34] <dalek> rakudo-star-daily: review: https://github.com/coke/rakudo-star-daily/commit/f38f36b624

[02:34] <dalek> rakudo-star-daily: f05fa8e | coke++ | log/ (9 files):

[02:34] <dalek> rakudo-star-daily: today (automated commit)

[02:34] <dalek> rakudo-star-daily: review: https://github.com/coke/rakudo-star-daily/commit/f05fa8e51d

[02:34] <dalek> rakudo-star-daily: ffe4bdb | coke++ | log/ (9 files):

[02:34] <dalek> rakudo-star-daily: today (automated commit)

[02:34] <dalek> rakudo-star-daily: review: https://github.com/coke/rakudo-star-daily/commit/ffe4bdbd96

[02:34] <dalek> perl6-roast-data: c9b7318 | coke++ | / (9 files):

[02:34] <dalek> perl6-roast-data: today (automated commit)

[02:34] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/c9b7318c4c

[02:34] <dalek> perl6-roast-data: 08c78ac | coke++ | / (9 files):

[02:34] <dalek> perl6-roast-data: today (automated commit)

[02:34] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/08c78acce6

[02:34] <dalek> perl6-roast-data: 0b7a064 | coke++ | / (9 files):

[02:34] <dalek> perl6-roast-data: today (automated commit)

[02:35] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/0b7a064a1e

[02:42] *** FROGGS joined
[02:42] *** rurban left
[03:03] *** amurf joined
[03:07] *** vendethiel joined
[03:08] *** amurf left
[03:37] *** aborazmeh left
[04:09] *** khw left
[04:19] *** bin_005_z left
[04:19] *** bin_005 joined
[04:23] *** vendethiel left
[04:24] *** kaare_ joined
[04:32] <dalek> rakudo/nom: f098e0f | lizmat++ | src/core/control.pm:

[04:32] <dalek> rakudo/nom: Make 'samewith' also work on subs, masak++

[04:32] <dalek> rakudo/nom: 

[04:32] <dalek> rakudo/nom: This fixes #125539

[04:32] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/f098e0ff6e

[04:32] <synbot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=125539

[04:33] *** raiph left
[04:41] <dalek> roast: b7acec1 | lizmat++ | S06-multi/redispatch.t:

[04:41] <dalek> roast: Add samewith tests for RT #125539

[04:41] <dalek> roast: review: https://github.com/perl6/roast/commit/b7acec1dd0

[04:41] <synbot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=125539

[04:47] <dalek> rakudo/nom: dc36c34 | lizmat++ | docs/ChangeLog:

[04:47] <dalek> rakudo/nom: Some more ChangeLog entries

[04:47] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/dc36c34d83

[05:13] *** BenGoldberg joined
[05:26] <kanl> masak: funny analogies :) i'm certain the logic is sound. the problem i have is when monitoring a set of *ephemeral* data and alerting on some conditions, i'd like to not drag people out of their beds when nothing is there, and simply that. be it common sense or logic, when it comes to that, it'd be hard to face an angry mob of sleep deprived people and calmly explain the soundness of it all :)

[05:28] <kanl> that said, i'm sure i can find ways work around that. no point tossing the baby out with the bath water :)

[05:30] *** araujo_ joined
[05:31] *** araujo left
[05:31] <ugexe> kanl: re your proc async RT (https://gist.github.com/anonymous/79a7e59cf3160f6ac09e): does this happen if you use print instead of say?

[05:34] <kanl> i've not tried that. but .print does not tag a newline to the string right? the reason for using .say there is to demonstrate that the output is not tapped in its entirety.

[05:35] <kanl> i.e. the output is broken into pieces and arrives ad-hoc. so one would have to assemble it before working on it.

[05:35] <ugexe> no

[05:40] <ugexe> you still get the newline, so it still gets printed. the only assembly is calling .lines on the final product if you want it split line by line

[05:45] <kanl> i've not tried calling .lines on the output inside the tap, either. i did call .split by newlines, but not getting expected result.

[05:47] <ugexe> you would calls .lines outside the tap on whatever your finished string with lots of newliens is

[05:47] <kanl> ah ic.

[05:48] <ugexe> and for print/say where you want to preseve order and lines you would want to use .act

[05:48] <ugexe> my $p = Proc::Async.new( | < ps waxu > ); $p.stdout.act({ $_.print }); await $p.start;

[05:48] *** araujo_ left
[05:50] <kanl> i've no problem with the doing things in order with .act. i think the problem i'm having is different.

[05:51] <kanl> prior, i suspect it wasn't really a problem but by design, that output is not tapped in its entirety.

[05:51] <ugexe> i dont know enough about threading yet but there looked to be a race condition where the very last chunk of buffer could go unread

[05:52] *** vendethiel joined
[05:52] <ugexe> is that at all consistent with the missing output?

[05:52] <kanl> not missing.

[05:52] <kanl> only broken into pieces.

[05:53] <kanl> i've not missed any output.

[05:53] <ugexe> oh. thats why you call .print

[05:53] <ugexe> or $p.stdout.lines, or $p.stdout.get

[05:55] <dalek> roast: 1c5d601 | lizmat++ | S32-array/adverbs.t:

[05:55] <dalek> roast: Comprehensive testing array slicing with adverbs

[05:55] <dalek> roast: review: https://github.com/perl6/roast/commit/1c5d6011b7

[05:56] *** skids left
[05:56] <dalek> rakudo/nom: 5919a84 | lizmat++ | t/spectest.data:

[05:56] <dalek> rakudo/nom: Comprehensive testing array slicing with adverbs

[05:56] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/5919a84679

[05:56] <lizmat> breakfast&

[05:56] <kanl> ugexe: i need to re-read the doc :)

[05:56] <kanl> i'm seeing no .lines or .get on the Supply

[05:56] <kanl> type

[05:58] <kanl> i'd apologies for any confusion i might've caused , but this could very well be the case of lacking documentatino on various things. so, simply put, i knew of no better or right way of doing something, so i tried doing the wrong thing, and getting the wrong results :p

[05:59] <kanl> apologize even.

[05:59] <ugexe> i was thinking of a channel i think. a supply has .list but thats not split on newlines

[06:00] <ugexe> anyway it sounds like you want a .tap that fires everytime a new line is reached

[06:00] <kanl> no. no. that's not what i want 

[06:00] *** araujo joined
[06:01] <kanl> like i said, it could very well be the correct behavior if buffering is done that way intentionally.

[06:02] <kanl> if it's by design, all it needs is more detailed documentation.

[06:02] *** araujo left
[06:03] *** araujo joined
[06:06] *** bin_005 left
[06:06] <ugexe> that buffer though is where the race condition might be

[06:06] <kanl> i'm not even sure how one might interpret "entirety" in the case of asynchronous I/O. i hope it does not mean the entire lifespan of the program, which could be interactive, and input and output could be interlaced.

[06:07] *** bin_005 joined
[06:08] <kanl> imagine if one were to implement Exepct with it.

[06:09] <kanl> *Expect*

[06:09] <ugexe> ive been trying to read from sterr and stdout from non-async Proc, but one always blocks the other

[06:10] <kanl> then you must've been very lucky :)

[06:12] <ugexe> https://gist.github.com/ugexe/cf047b86bfb66ada37df

[06:13] <ugexe> unfortunately reading .out and .err each in their own thread causes it to explode

[06:13] *** vendethiel left
[06:14] *** Foxcool joined
[06:18] * lizmat was just reading masak's interview (again)

[06:18] <lizmat> "In Perl (5 and 6), imports happen on the package level, and so there is a real risk of collisions"

[06:19] <lizmat> masak: I think you're wrong there: in Perl 6, imports are lexical as well

[06:19] <lizmat> m: sub ok { say "Hello" }; { use Test; ok 1 }; ok

[06:19] <camelia> rakudo-moar dc36c3: OUTPUT«ok 1 - ␤Hello␤»

[06:19] <jdv79> wasn't there an exception or two?  maybe subsets or types or somethings like that

[06:20] <lizmat> m: sub ok($a) { say "Hello" }; { use Test; ok 1 }; ok 42

[06:20] <camelia> rakudo-moar dc36c3: OUTPUT«ok 1 - ␤Hello␤»

[06:24] <lizmat> m: my @a; say @a[1,2,3].perl; say @a[1..3].perl

[06:24] <camelia> rakudo-moar 5919a8: OUTPUT«(Any, Any, Any)␤()␤»

[06:24] * lizmat thinks they should be the same ?

[06:30] <ugexe> m: my @a; say @a[1,2..4].perl;

[06:30] <camelia> rakudo-moar 5919a8: OUTPUT«(Any, Any, Any, Any)␤»

[06:31] <lizmat> thing is, if I make [1..3] return (Any,Any,Any), I break a lot of spectests

[06:31] <lizmat> (and get some todo's passing)

[06:31] <lizmat> but more breakage

[06:31] <lizmat> wonder what the GLR would mean for this

[06:33] <ugexe> must be whatever related eh

[06:33] <ugexe> m: my @a; say @a[*,1..3].perl; say @a[1,*..3].perl; say @a[1,2..*].perl

[06:33] <camelia> rakudo-moar 5919a8: OUTPUT«((), Any, Any, Any)␤()␤()␤»

[06:34] <lizmat> my head starts to hurt now

[06:35] * lizmat catches up on some sleep

[06:35] <ShimmerFairy> m: say [0,1] ~~ [0,1]; say [[0, 1]] ~~ [[0, 1]];

[06:35] <camelia> rakudo-moar 5919a8: OUTPUT«True␤False␤»

[06:35] <ShimmerFairy> Something I caught the other day; I hope this would be considered a bug

[06:38] <ugexe> m: say [[0,1]] cmp [[0,1]]

[06:38] <camelia> rakudo-moar 5919a8: OUTPUT«Same␤»

[06:38] <ShimmerFairy> Yeah, I had to resort to cmp for that, but it still seems odd that you can't smartmatch a multidim array

[06:38] <kanl> masak,moritz: while not putting at risk centries of progress on logic and mathematical truth, i've found happiness/sanity with ( Nil.any ) :)

[06:38] <kanl> m:  my @a = ( Nil.any ); say so @a.all > 0; say so @a.none > 0; say so @a.any > 0; say so @a.one > 0;

[06:38] <camelia> rakudo-moar 5919a8: OUTPUT«False␤True␤False␤False␤»

[06:39] <kanl> now there's that set of ephemeral data looking ready to be monitored

[06:40] <raydiak> .tell lizmat looks like the range slicing behavior is/was intentional: https://github.com/rakudo/rakudo/commit/a8df1c96d9baf0c0aeda4e4d3c250fe6a5c92a04

[06:40] <yoleaux> raydiak: I'll pass your message to lizmat.

[06:41] *** amurf joined
[06:44] *** TEttinger left
[06:46] *** amurf left
[06:57] *** tinyblak_ joined
[07:00] *** tinyblak left
[07:16] <masak> good morning, #perl6

[07:16] <bartolin> o/

[07:19] <dalek> roast: 3957fed | usev6++ | S (2 files):

[07:19] <dalek> roast: Add tests for RT #115390

[07:19] <dalek> roast: review: https://github.com/perl6/roast/commit/3957fed267

[07:19] <synbot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=115390

[07:19] *** BenGoldberg left
[07:26] <masak> m: say so any.all > 0

[07:26] <camelia> rakudo-moar 5919a8: OUTPUT«5===SORRY!5===␤Argument to "any" seems to be malformed␤at /tmp/zXdmCxO4lH:1␤------> 3say so any7⏏5.all > 0␤Other potential difficulties:␤    Function "any" may not be called without arguments (please use () or whitespace to denote argum…»

[07:27] <masak> m: say so any().all > 0

[07:27] <camelia> rakudo-moar 5919a8: OUTPUT«False␤»

[07:27] <masak> kanl: it might be happiness, but I'm not ready to call it "sanity" until I understand what `any().all` means :)

[07:28] <kanl> call me a lunatic, but a happy one :)

[07:28] <masak> as you wish.

[07:29] *** kanl is now known as happiloon

[07:29] <masak> I'm the other way. I can stand a little misery, as long as I understand what my program does.

[07:30] <happiloon> the world needs more programmers like you :)

[07:30] <masak> well, it's a sweet deal. usually the understanding makes me happy enough. :>

[07:32] <happiloon> i otoh, would like to get the romans off my back before going back to my geometry problems :p

[07:32] <ShimmerFairy> masak: maybe it's some kind of multiuniversal statement? "Take all of the possible anys"? :P

[07:33] *** happiloon is now known as kanl

[07:45] *** rurban joined
[07:45] *** vendethiel joined
[08:07] *** vendethiel left
[08:08] *** vendethiel joined
[08:09] *** aborazmeh joined
[08:09] *** aborazmeh left
[08:09] *** aborazmeh joined
[08:14] *** darutoko joined
[08:15] *** diana_olhovik joined
[08:17] *** RabidGravy joined
[08:19] *** mr-foobar left
[08:36] *** spider-mario joined
[08:39] *** gfldex joined
[08:47] *** mr-foobar joined
[08:53] *** rurban left
[09:00] <masak> what wouldbe a good three-letter acronym for "using tests to map out the design, before diving into the implementation"?

[09:05] <kanl> TDD => test driven design ?

[09:12] *** diana_olhovik left
[09:16] *** [TuxCM] joined
[09:17] *** voegelas joined
[09:29] *** rurban joined
[09:31] *** [Tux] left
[09:34] *** bjz joined
[09:38] *** [TuxCM] left
[09:39] *** [Tux] joined
[09:40] *** rindolf joined
[09:43] *** Peter_R joined
[09:49] *** telex left
[09:50] *** telex joined
[09:53] *** diana_olhovik joined
[10:17] *** espadrine joined
[10:18] *** amurf joined
[10:23] *** amurf left
[10:24] <moritz> TDM => Test Driven Modeling?

[10:25] *** ShimmerFairy left
[10:28] *** aditya_ joined
[10:28] *** aditya_ left
[10:34] *** virtualsue joined
[10:37] *** ShimmerFairy joined
[10:41] <masak> kanl: TDD is kinda taken, though...

[10:41] <masak> moritz: yes, something like that :)

[10:41] *** rindolf left
[10:51] *** mr-foobar left
[10:53] <ShimmerFairy> I wonder if [[0, 1], [2, 3]] ~~ [[0, 1], [2, 3]] should be True. Right now it isn't (because Array's ACCEPTS method uses !=== when comparing elements), and I'm not sure if that's intended or a bug.

[10:55] *** darutoko left
[10:57] *** darutoko joined
[11:00] *** RabidGravy left
[11:02] <bartolin> std: my $foo :a  # :a parsed as trait

[11:02] <camelia> std 28329a7: OUTPUT«ok 00:00 135m␤»

[11:03] <bartolin> m: my $foo :a # RT #119763

[11:03] <synbot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=119763

[11:03] <camelia> rakudo-moar 5919a8: OUTPUT«===SORRY!===␤Cannot invoke this object (REPR: P6opaque, cs = 0)␤»

[11:04] <bartolin> is that NYI (setting a trait with colonpair syntax)?

[11:04] <bartolin> I didn't find that syntax in roast or in the design documents, but Rakudo parses the ':a' as a trait as well

[11:08] <FROGGS> m: my $foo :rw

[11:08] <yoleaux> 2 Jul 2015 10:07Z <lizmat> FROGGS: there's something weird going on with repeated qqx[], it seems

[11:08] <yoleaux> 2 Jul 2015 10:13Z <lizmat> FROGGS: looking at failures in t/spec/S24-testing/line-numbers.t and t/spec/S32-io/IO-Socket-INET.t

[11:08] <camelia> rakudo-moar 5919a8: OUTPUT«===SORRY!===␤Cannot invoke this object (REPR: P6opaque, cs = 0)␤»

[11:08] <FROGGS> bartolin: I have no idea

[11:13] <bartolin> it seems to blow up in https://github.com/rakudo/rakudo/blob/nom/src/Perl6/Actions.nqp#L2526

[11:14] <bartolin> but I was mainly curious, because I haven't seen that syntax before ...

[11:17] *** nebuchadnezzar left
[11:18] *** rindolf joined
[11:25] *** mr-foobar joined
[11:36] *** petercommand joined
[11:39] *** cognominal joined
[11:41] *** virtualsue left
[11:41] *** virtualsue joined
[11:41] <masak> looks more like an adverb than a trait.

[11:42] <masak> question is, what is it an adverb on...?

[11:43] <masak> ShimmerFairy: I think I agree with you. I would like it if [].ACCEPT did ~~ recursively down its structure

[11:43] <masak> ShimmerFairy: in fact, I believe I once submitted an RT ticket about that

[11:43] <ShimmerFairy> masak: I changed !=== to !~~ for fun, and it did fail some tests. Not sure if that's a failure of the tests or of making the change.

[11:48] <masak> hm, or maybe I didn't. can't find it now.

[11:48] * masak searches the logs instead

[11:48] *** vendethiel left
[11:49] <masak> oh yes, here: http://irclog.perlgeek.de/perl6/2014-08-29#i_9264839

[11:49] *** RabidGravy joined
[11:49] *** vendethiel joined
[11:49] *** Akagi201 joined
[11:50] <masak> ShimmerFairy: seemed what I did was not to submit an RT ticket, but to submit a suggested change to S03

[11:50] <masak> (since stalled)

[11:53] <ShimmerFairy> Yeah, I'd like it if smartmatch was changed so [[1,2]] ~~ [[1,2]] were true, and so on. To me, smartmatch is supposed to (roughly) check the equality of two things the way a human would ("If I were to look at these two things myself, would I say they're equal?").

[11:53] *** Akagi201_ left
[11:53] <ShimmerFairy> Or to put it another way, it's the least strict check for equality we have, as I understand it :)

[11:53] <masak> ShimmerFairy: *nod*

[11:54] <masak> ShimmerFairy: good news, that particular one is already True under eqv semantics

[11:54] <masak> m: say [[1, 2]] eqv [[1, 2]]

[11:54] <camelia> rakudo-moar 5919a8: OUTPUT«True␤»

[11:54] <masak> but not all things I'd expect to be true under ~~ are true under eqv

[11:54] <masak> m: say [[1, 2]] eqv [[1.0, "2"]]

[11:54] <camelia> rakudo-moar 5919a8: OUTPUT«False␤»

[11:54] <ShimmerFairy> Huh, didn't know/forgot about eqv; I used cmp when I ran into this the other day.

[11:54] <masak> m: say 1 ~~ 1.0; say 2 ~~ "2"

[11:54] <camelia> rakudo-moar 5919a8: OUTPUT«True␤True␤»

[11:56] *** bjz left
[11:56] <ShimmerFairy> m: say [1, 2] ~~ [1.0, "2"]

[11:56] <camelia> rakudo-moar 5919a8: OUTPUT«False␤»

[12:04] *** bjz joined
[12:05] *** bjz left
[12:06] *** Akagi201 left
[12:08] <masak> ...yes, I think I would like to be using a slang that forbade `has $twigilless;` :)

[12:08] *** bjz joined
[12:08] *** amurf joined
[12:09] <masak> hm, we have comparison ops for Date objects but not for DateTime objects... this is probably an oversight.

[12:09] <masak> m: my $dt1 = DateTime.now; my $dt2 = $dt1.later(:1hour); say $dt1 < $dt2

[12:09] <camelia> rakudo-moar 5919a8: OUTPUT«Cannot call Real(DateTime: ); none of these signatures match:␤    (Mu:U \v: *%_)␤  in block <unit> at /tmp/8051nuMDbp:1␤␤»

[12:10] * masak submits NYI rakudobug

[12:12] <masak> m: my $dt1 = DateTime.now; my $dt2 = $dt1.later(:1hour); say $dt1.Instant < $dt2.Instant

[12:12] <camelia> rakudo-moar 5919a8: OUTPUT«True␤»

[12:12] <masak> seems to be a current workaround.

[12:13] *** amurf left
[12:22] *** diana_olhovik left
[12:30] <dalek> roast: 75119ec | lizmat++ | S32-array/adverbs.t:

[12:30] <dalek> roast: Apparently, ranges *always* auto-trunc, raydiak++

[12:30] <dalek> roast: review: https://github.com/perl6/roast/commit/75119ec319

[12:31] <lizmat> ^^^ still not sure that's the right thing to do, though

[12:31] <yoleaux> 06:40Z <raydiak> lizmat: looks like the range slicing behavior is/was intentional: https://github.com/rakudo/rakudo/commit/a8df1c96d9baf0c0aeda4e4d3c250fe6a5c92a04

[12:31] <lizmat> I could see this being true for any infinite list of indexes

[12:32] <lizmat> m: my @a; say @a[1,2,3].perl; say @a[1..3].perl; say @a[1,2..3].perl # these not being the same, feels odd to me

[12:32] <camelia> rakudo-moar 5919a8: OUTPUT«(Any, Any, Any)␤()␤(Any, Any, Any)␤»

[12:38] <masak> I think I'm only surprised-ish at the last line.

[12:42] *** iH2O joined
[12:43] *** iH2O left
[12:44] *** MueThoS76 joined
[12:53] *** isBEKaml joined
[12:53] *** tinyblak joined
[12:54] *** virtualsue left
[12:55] *** isBEKaml left
[12:57] *** tinyblak_ left
[13:04] *** tinyblak left
[13:05] *** domidumont joined
[13:09] *** domidumont left
[13:10] *** domidumont joined
[13:24] *** domidumont left
[13:26] *** diana_olhovik joined
[13:28] *** aborazmeh left
[13:29] *** raiph joined
[13:29] *** MueThoS76 left
[13:32] *** bin_005 left
[13:42] *** nys joined
[13:43] *** AlexDaniel joined
[13:46] *** tinyblak joined
[13:49] *** domidumont joined
[13:50] *** rmgk left
[13:55] <ShimmerFairy> Hm. This is the first time I've seen the 'unit' keyword; why is it necessary for the semicolon version of 'module' (and only the semicolon version)?

[13:55] *** BenGoldberg joined
[13:56] *** aborazmeh joined
[13:56] *** aborazmeh left
[13:56] *** aborazmeh joined
[14:07] *** raiph left
[14:08] <timotimo> because people kept writing "class foobar;" and were surprised when the rest of the file was the class body

[14:09] <dalek> specs: 66d345c | hoelzro++ | S05-regex.pod:

[14:09] <dalek> specs: Detail action methods + dynvar behavior

[14:09] <dalek> specs: review: https://github.com/perl6/specs/commit/66d345c46e

[14:09] <timotimo> i.e. they expected the behavior to be equivalent to "class foobar { ... }"

[14:09] *** raiph joined
[14:10] <ShimmerFairy> ah, so it's for a C++-ism then :)

[14:10] *** nebuchadnezzar joined
[14:12] <timotimo> oh, yeah, i remember now that that's how you stub stuff in cpp

[14:14] <ShimmerFairy> Yeah, 'unit' seemed useless to me until you brought up that people were expecting C++-ish behavior.

[14:16] *** ggoebel joined
[14:16] <timotimo> i wasn't very happy with the way we handled the move from without-unit to with-unit

[14:18] <ShimmerFairy> How was it handled?

[14:18] <timotimo> it started giving annoying deprecation messages immediately, but just putting unit into your modules would give you compilation errors with the previous version

[14:20] <colomon> timotimo: +1

[14:20] <yoleaux> 4 Jul 2015 17:34Z <hoelzro> colomon: could you have a look at https://github.com/perl6-community-modules/SmokeResults/pull/2?

[14:20] <ShimmerFairy> I think I would've preferred a disambiguation warning over a deprecation: "Use 'unit module foo;' if you mean to declare the file as a module, or 'module foo {...}' if you mean to stub the module."

[14:20] <timotimo> though i believe the deprecation warnings only actually show up if you build a non-release version

[14:22] <colomon> hoelzro++

[14:30] *** LLamaRider joined
[14:31] *** LLamaRider left
[14:45] *** diana_olhovik left
[14:53] *** VinceDee left
[14:54] *** rurban left
[15:10] *** ggoebel left
[15:23] *** khw joined
[15:23] *** aborazmeh left
[15:23] *** tinyblak left
[15:27] *** rurban joined
[15:28] *** diana_olhovik_ joined
[15:30] *** rurban left
[15:36] *** raiph left
[15:37] <masak> m: class C { has $.x = 42; method new(|) { callsame() } }; say C.new.x

[15:37] <camelia> rakudo-moar 5919a8: OUTPUT«42␤»

[15:43] <masak> m: say Date.new(2016, 1, 31).later(:1month)

[15:43] <camelia> rakudo-moar 5919a8: OUTPUT«day of 2016/2 out of range. Is: 31, should be in 1..29␤  in block <unit> at /tmp/1Md4pCV602:1␤␤»

[15:43] <masak> hm.

[15:43] <masak> not sure it should fail there...

[15:43] <masak> I'd rather it gave 2016-03-03.

[15:44] *** rindolf left
[15:45] *** amurf joined
[15:48] <ShimmerFairy> That 2016/2 looks weird at-a-glance

[15:50] *** amurf left
[15:55] *** skids joined
[16:05] *** spider-mario left
[16:13] *** xinming joined
[16:15] <ugexe> FROGGS: is your Proc shell/run work meant to accept user declared IO::Pipes for :out and :err in the future? as in, i could pass in my own stdout and stderr pipes to be redirected to?

[16:15] <ugexe> meant to in the future, that is

[16:15] *** BenGoldberg left
[16:17] <skids> .tell lizmat Re: my@a; @a[1,2..3] http://irclog.perlgeek.de/perl6/2015-06-16#i_10755209 if it helps figure out how the GLR will impact that.

[16:17] <yoleaux> skids: I'll pass your message to lizmat.

[16:17] <FROGGS> ugexe: I think so, yes

[16:19] *** voegelas left
[16:19] *** petercommand left
[16:19] <skids> (I agree with masak, I would expect the 2..3 in [1,2..3] to autotruncate if [2..3] autotruncates)

[16:20] <ugexe> i was able to merge the output of stdout and stderr using the current Procs as-is, but it blocks until the end of the program :(

[16:20] <ugexe> well, until the pipes are closed anyway

[16:21] *** petercommand joined
[16:21] *** BenGoldberg joined
[16:21] *** uncleyear left
[16:23] *** uncleyear joined
[16:26] *** petercommand left
[16:28] *** rindolf joined
[16:33] *** uncleyear left
[16:33] *** uncleyear joined
[16:33] *** lucasb joined
[16:35] <masak> ShimmerFairy: yeah, the 2016/2 isn't optimal either...

[16:37] *** petercommand joined
[16:46] <lucasb> m: my @a = 1,2,3; my $x = @a; @$x = Empty; say @a.perl  # this is ok

[16:46] <camelia> rakudo-moar 5919a8: OUTPUT«[]<>␤»

[16:46] <lucasb> m: my @a = 1,2,3; my %h = a=>@a; @(%h<a>) = Empty; say @a.perl  # this is ok

[16:46] <camelia> rakudo-moar 5919a8: OUTPUT«[]<>␤»

[16:46] <lucasb> m: my @a = 1,2,3; my @b = [@a]; @(@b[0]) = Empty; say @a.perl

[16:46] <camelia> rakudo-moar 5919a8: OUTPUT«[1, 2, 3]<>␤»

[16:47] <lucasb> ^^ I can't clear an array when it is an array element

[16:49] <lucasb> oops! sorry, my mistake

[16:49] <lucasb> m: my @a = 1,2,3; my @b = $@a; @(@b[0]) = Empty; say @a.perl

[16:49] <camelia> rakudo-moar 5919a8: OUTPUT«[]<>␤»

[16:49] <ugexe> still, this seems odd

[16:50] <lucasb> m: my @a = 1,2,3; my @b = $@a; say @b.perl

[16:50] <camelia> rakudo-moar 5919a8: OUTPUT«[[1, 2, 3]]<>␤»

[16:50] <lucasb> m: my @a = 1,2,3; my @b = [@a]; say @b.perl

[16:50] <camelia> rakudo-moar 5919a8: OUTPUT«[[1, 2, 3]]<>␤»

[16:51] <BenGoldberg> m: my @a = 1,2,3; my @b = [@a]; say @b[0].perl

[16:51] <camelia> rakudo-moar 5919a8: OUTPUT«[1, 2, 3]␤»

[16:51] <lucasb> I think it is because they have the same .perl representation, but they are not completely similar

[16:51] <BenGoldberg> m: my @a = 1,2,3; my @b = [@a]; say @a.perl

[16:51] <camelia> rakudo-moar 5919a8: OUTPUT«[1, 2, 3]<>␤»

[16:51] <ugexe> your enot binding though

[16:52] <BenGoldberg> m: my @a = (1,2,3); say @a.perl;

[16:52] <camelia> rakudo-moar 5919a8: OUTPUT«[1, 2, 3]<>␤»

[16:52] <BenGoldberg> m: my @a = (1,2,3); say +@a;

[16:52] <camelia> rakudo-moar 5919a8: OUTPUT«3␤»

[16:52] <BenGoldberg> m: my @a := (1,2,3); say +@a;

[16:52] <camelia> rakudo-moar 5919a8: OUTPUT«3␤»

[16:52] <BenGoldberg> m: my @a := (1,2,3); say @a.perl;

[16:52] <camelia> rakudo-moar 5919a8: OUTPUT«(1, 2, 3)␤»

[16:52] <ugexe> m: my @a = 1,2,3; my @b := [@a]; say @b[0].perl

[16:52] <camelia> rakudo-moar 5919a8: OUTPUT«1␤»

[16:53] <BenGoldberg> m: my @a := (1,2,3); my @b = [@a]; say @b.perl

[16:53] <camelia> rakudo-moar 5919a8: OUTPUT«[[1, 2, 3]]<>␤»

[16:53] <BenGoldberg> m: my @a := (1,2,3); my @b := ($@a); say @b.perl

[16:53] <camelia> rakudo-moar 5919a8: OUTPUT«(1, 2, 3)␤»

[16:53] <BenGoldberg> m: my @a := (1,2,3); my @b := (item $@a); say @b.perl

[16:53] <camelia> rakudo-moar 5919a8: OUTPUT«(1, 2, 3)␤»

[16:53] <BenGoldberg> m: my @a := (1,2,3); my @b := (item $@a); say +@b

[16:53] <camelia> rakudo-moar 5919a8: OUTPUT«3␤»

[16:54] <ugexe> you can /msg camelia queries as well

[17:03] <DrForr> Or even use the debugger's REPL :)

[17:06] *** rindolf left
[17:10] *** rindolf joined
[17:12] <dalek> ecosystem: aa0639d | RabidGravy++ | META.list:

[17:12] <dalek> ecosystem: Add Audio::Libshout

[17:12] <dalek> ecosystem: review: https://github.com/perl6/ecosystem/commit/aa0639d05e

[17:13] <RabidGravy> there, next up some encoding shizzle

[17:16] *** virtualsue joined
[17:23] <lucasb> My mistake was that [@a] was building an new array, since [] flattens inside (I forgot that), so the reference to @a was lost. Sorry for the noise.

[17:29] <ugexe> thanks for reminding me at least

[17:35] *** leont joined
[17:37] <BenGoldberg> m: my @a = (1,2,3); say "Whay is this " ~ @a.perl.substr(*-2) ~ " here?";

[17:37] <camelia> rakudo-moar 5919a8: OUTPUT«Whay is this <> here?␤»

[17:38] <lucasb> BenGoldberg: iiuc, It's the difference between itemized vs non-itemized arrays

[17:39] <lucasb> iirc, TT said this difference will be gone after GLR (right?)

[18:09] *** domidumont left
[18:09] *** kurahaupo joined
[18:14] <skids> So if truncation does end up applying to all ranges inside a list inside .[] maybe we should qualify that as a special flavor of flattening.

[18:14] <skids> And if we need that internally anyway, also have a Range method slice(Range $lim: *@values) is export

[18:15] <leont> Did smart-matching against a type change recently?

[18:15] <skids> There was a mod involving junctions a few weeks ago IIRC.

[18:17] <leont> This started failing: https://github.com/Leont/tap-harness6/blob/master/t/generator.t#L45

[18:17] <skids> http://irclog.perlgeek.de/perl6/2015-06-15#i_10750086 # junction mod

[18:17] <leont> Replacing $expected with $expected.WHAT seems to fix it, but feels rather counter-intuitive

[18:18] <leont> I have this feeling something else is wrong, but I'm clueless what

[18:18] <leont> Maybe the Z operator changed wrt GLR? #justaguess

[18:19] <skids> Any idea how recently it started to fail?

[18:21] <leont> No, I haven't tried running it in 2-3 months I think

[18:22] <leont> A closer look at the output suggest it's a Z problem

[18:22] <leont> It seems to try to match against another object also on the left hand side

[18:24] *** spider-mario joined
[18:27] *** brrt joined
[18:29] <skids> Try -> ($got, $expected)

[18:29] *** rindolf left
[18:30] <skids> (or "for flat")

[18:31] * lizmat is looking at the newio branch and resists the urge to zap it into oblivion

[18:31] <yoleaux> 16:17Z <skids> lizmat: Re: my@a; @a[1,2..3] http://irclog.perlgeek.de/perl6/2015-06-16#i_10755209 if it helps figure out how the GLR will impact that.

[18:32] <leont> That solved everything :-)

[18:32] <leont> Thanks

[18:33] <nine> lizmat: why would you?

[18:33] <dalek> Heuristic branch merge: pushed 140 commits to rakudo/newio by lizmat

[18:33] *** rindolf joined
[18:34] <cognominal> lizmat++

[18:34] <lizmat> because it does not have enough consensus

[18:34] <lizmat> and it is a royal pain to keep even compiling (it doesn't anymore now)

[18:35] <nine> :/

[18:35] <skids> Is there a TLDR doc of what it changes?

[18:36] *** Ben_Goldberg joined
[18:36] <cognominal> IO and GLR are the two important items impacting the language as seen by the users. I hope they will progress.

[18:36] <lizmat> skids: https://github.com/perl6/specs/blob/newio/S16-io.pod

[18:38] <cognominal> lizmat++ for the rul

[18:38] *** BenGoldberg left
[18:39] <cognominal> * url

[18:41] <skids> lizmat: I find those docs easy to read, but maybe something more side-by-side might help build consensus -- "we currently to do this and it would be this instead because"

[18:43] <dalek> doc: 5dc0865 | ugexe++ | lib/Type/IO/Path.pod:

[18:43] <dalek> doc: IO::Path.extension

[18:43] <dalek> doc: review: https://github.com/perl6/doc/commit/5dc086511e

[18:43] <dalek> doc: c754919 | ugexe++ | lib/Type/Proc (2 files):

[18:43] <dalek> doc: :$cwd param for process spawning

[18:43] <dalek> doc: review: https://github.com/perl6/doc/commit/c75491900a

[18:43] <dalek> doc: f988b2c | (Nick Logan)++ | lib/Type/ (3 files):

[18:43] <dalek> doc: Merge pull request #100 from ugexe/ugexe

[18:43] <dalek> doc: 

[18:43] <dalek> doc: IO::Path .extension, Proc[::Async] :$cwd param

[18:43] <dalek> doc: review: https://github.com/perl6/doc/commit/f988b2c3d4

[18:45] <RabidGravy> is anyone looking at doing any audio codec stuff or know of anyone who is? I'm just about to start a liblame binding and I may define a generalised interface for that kind of thing

[18:45] <cognominal> A very minor complaints about synopses. Why do we keep (always out of date) document versioning/modification date when everything is under git? This make the document looking stale when they are not.

[18:46] <skids> Frankly I've been avoiding working too much with IO, partly because of looming changes.

[18:51] *** rindolf left
[18:59] *** rindolf joined
[18:59] *** domidumont joined
[19:01] <timotimo> RabidGravy: why would you suppor such a shitty codec? ;)

[19:02] <cognominal> lizmat,  is there a device to limit l?stat system calls, like _ in Perl 5?

[19:02] <lizmat> no, there isn't

[19:03] <lizmat> in a concurrent world, I'm not sure what that would mean

[19:03] <lizmat> on the other hand, you would be looking at a snapshot state

[19:03] <lizmat> I'm not sure what would be wise in that respect

[19:04] <flussence> well, you could use a given $stat-result {} block... though if we were to have a direct equivalent to p5 I imagine it'd be called $*STAT

[19:04] <leont> Also, that has serious portability issues

[19:05] <skids> .oO(AV standards/APIs are such a thicket of madness these days.)

[19:05] <RabidGravy> timotimo, I'd rather not have to frankly, but a) it's a realpolitik and b) the libvorbis API is horrid and I want to do an easy one first ;-)

[19:05] <leont> Because Windows doesn't have a concept that maps 1:1, file-tests are much slower than they should be because _ forces it to do all the extra work always

[19:06] <timotimo> RabidGravy: i'm not proposing ogg, i'm proposing opus :)

[19:06] <timotimo> i mean vorbis vs opus

[19:08] <RabidGravy> Opus is on the list, but as it's from the same stable I would imagine the API is equally horrid

[19:11] *** brrt left
[19:13] <timotimo> what makes the libvorbis api so bad?

[19:16] *** Ben_Goldberg left
[19:17] <RabidGravy> lots of bitty, fiddly functions

[19:18] <timotimo> hm

[19:18] *** zakharyas joined
[19:19] *** BenGoldberg joined
[19:19] *** geekosaur left
[19:22] *** geekosaur joined
[19:23] *** amurf joined
[19:23] <RabidGravy> the lame API is simplicity itself, initialise it with some parameters then chuck PCM data at a function which populates a buffer of unsigned chars with the encoded stuff

[19:27] *** amurf left
[19:28] *** geekosaur left
[19:29] *** geekosaur joined
[19:34] *** geekosaur left
[19:35] *** geekosaur joined
[19:35] *** domidumont left
[19:38] *** brrt joined
[19:56] *** rindolf left
[20:00] *** colomon left
[20:04] *** diana_olhovik_ left
[20:06] *** mst left
[20:06] *** mst joined
[20:07] *** darutoko left
[20:08] *** raiph joined
[20:10] *** zakharyas left
[20:13] *** FROGGS left
[20:14] <lizmat> I'm looking at how much will break if we outlaw \$ \@ \%

[20:14] <lizmat> https://gist.github.com/lizmat/4e8ed8c56f15f3b6147f

[20:15] <lizmat> so far, there's a few specific spectests that fail

[20:15] <lizmat> and some of them I think are pretty bogus to begin with

[20:15] <lizmat> what to think of:

[20:15] <lizmat>     my @array = <a b c>;

[20:15] <lizmat>     my $ref   = \@array;

[20:15] <timotimo> we shouldn't let them bog us down so much

[20:16] <timotimo> that seems like a test that ought to be kicked out

[20:16] <lizmat> from t/spec/S02-literals/autoref.t

[20:16] <lizmat> people coming from Perl 5 are used to writing \@a to get a reference

[20:17] <lizmat> I don't think we're making it that harder on people if we would force P6ers to *always* have to use () to create a capture

[20:17] <lizmat> even it is a single parameter on

[20:17] <lizmat> e

[20:17] <lizmat> aka, if you *really* meant to do \@a., you would have to do \(@a)

[20:18] *** Begi joined
[20:18] *** VinceDee joined
[20:19] <Begi> Hey ! I've got a random string, like tkat : " tdtdttdt201678tft "

[20:19] <lucasb> your patch didn't include \&foo ?

[20:19] <Begi> How can I do to get the number in this string ?

[20:20] <lizmat> lucasb: good point  :-)

[20:20] <masak> Begi: $string ~~ /(\d+)/ or die "didn't find a number"

[20:20] <masak> Begi: say +$0

[20:22] *** xinming left
[20:22] *** xinming joined
[20:23] <lizmat> lucasb: updated the gist

[20:24] <Begi> masak : Thanks !

[20:25] *** Begi left
[20:26] *** telex left
[20:28] *** colomon joined
[20:28] *** telex joined
[20:34] *** bin_005 joined
[20:37] <dalek> roast: 038ad11 | lizmat++ | S02-literals/autoref.t:

[20:37] <dalek> roast: Remove bogus \ tests from 2008

[20:37] <dalek> roast: 

[20:37] <dalek> roast: The \ in the tests were really used in the sense they exist in Perl 5.

[20:37] <dalek> roast: review: https://github.com/perl6/roast/commit/038ad1174d

[20:46] <dalek> roast: 4d25274 | lizmat++ | S02-types/capture.t:

[20:46] <dalek> roast: Create capture with \() instead of just \

[20:46] <dalek> roast: review: https://github.com/perl6/roast/commit/4d25274c4a

[20:48] <dalek> roast: 999cf98 | lizmat++ | S02-types/flattening.t:

[20:48] <dalek> roast: Use itemizing instead of capturing

[20:48] <dalek> roast: 

[20:48] <dalek> roast: Which I think was the intent of these tests

[20:48] <dalek> roast: review: https://github.com/perl6/roast/commit/999cf98067

[20:50] <dalek> roast: b07b9a8 | lizmat++ | S02-types/lists.t:

[20:50] <dalek> roast: Create capture with \() instead of just \

[20:50] <dalek> roast: review: https://github.com/perl6/roast/commit/b07b9a8a16

[20:53] <dalek> roast: 21b7ed5 | lizmat++ | S02-types/mixed_multi_dimensional.t:

[20:53] <dalek> roast: Use itemizing instead of capturing

[20:53] <dalek> roast: review: https://github.com/perl6/roast/commit/21b7ed5ae1

[20:55] <lucasb> lizmat++; the fact theses tests using \@a, \%h were passing is funny and luck, right?

[20:55] <lizmat> yes, I think so

[20:56] <lizmat> they were using the fact making a capture on a single thing, also itemizes

[21:02] *** bin_005 left
[21:03] *** bin_005 joined
[21:07] <dalek> roast: 4705fc0 | lizmat++ | S03-operators/assign.t:

[21:07] <dalek> roast: Correct needless backslashing in interpolation

[21:07] <dalek> roast: review: https://github.com/perl6/roast/commit/4705fc0b4f

[21:07] <dalek> roast: b6d6d31 | lizmat++ | S03-operators/assign.t:

[21:07] <dalek> roast: Fix (temporarily) some tests using \@a

[21:07] <dalek> roast: 

[21:07] <dalek> roast: It feels that the capturing was a misinformed "reference" taking.

[21:07] <dalek> roast: By taking the capture out, 4 TODO's passed, and one test failed.

[21:07] <dalek> roast: This seems GLR sensitive, so I just changed the fudging to match.

[21:07] <dalek> roast: review: https://github.com/perl6/roast/commit/b6d6d3176e

[21:12] *** amurf joined
[21:15] <lucasb> m: class C is Capture {}; C.new

[21:15] <camelia> rakudo-moar 5919a8: OUTPUT«Method 'BUILD' not found for invocant of class 'C'␤  in block <unit> at /tmp/hevuso2Ren:1␤␤»

[21:15] <masak> lucasb: some classes are a bit special-cased, and have a BUILD method instead of a BUILD submethod. Capture is one of those.

[21:15] <lucasb> Capture's new is: method new(...) { nqp::create(self).BUILD(...) }

[21:16] <masak> m: class C is Capture { method BUILD() {} }; C.new

[21:16] <camelia> rakudo-moar 5919a8: ( no output )

[21:16] <masak> m: class C is Capture { method BUILD() {} }; C.new; say "alive"

[21:16] <camelia> rakudo-moar 5919a8: OUTPUT«alive␤»

[21:16] <lucasb> masak: Oh, thanks

[21:16] <lucasb> But there is a submethod BUILD in Capture

[21:17] <masak> yes, there is.

[21:17] *** amurf left
[21:18] <masak> oh, that's it then.

[21:18] <masak> if we call BUILD explicitly like that, it expects to find a BUILD in the derived class, too.

[21:19] <masak> normally, BUILD is called several times up the inheritance chain. if it doesn't exist, no biggie.

[21:19] <masak> here, it has to exist in the class being instantiated.

[21:21] *** Possum left
[21:22] <lucasb> I still must study the object creation stuff like nqp::create/bless/new. idk what calls what. I thought this was an object creation problem...

[21:22] <masak> then this is an excellent resource for you: http://perlgeek.de/blog-en/perl-6/object-construction-and-initialization.html

[21:22] <RabidGravy> so NativeCall callbacks seem to work but is one with a signature of (const char *format, va_list ap) going to fly?

[21:23] <dalek> roast: 27c655b | lizmat++ | integration/99problems-11-to-20.t:

[21:23] <dalek> roast: Use itemizing instead of capturing

[21:23] <dalek> roast: review: https://github.com/perl6/roast/commit/27c655b81e

[21:23] <lucasb> masak: thanks very much!

[21:24] <RabidGravy> I'm thinking that I'm screwed by the va_list

[21:27] <lizmat> m: my $a = \3   # would we call this a scalar *reference* ?

[21:27] <camelia> rakudo-moar 5919a8: ( no output )

[21:28] <lizmat> feels to me we have a lot of bogus tests in t/spec/S03-operators/eqv.t and t/spec/S03-operators/value_equivalence.t

[21:31] <brrt> .ask FROGGS if he cares enough about the 'system dynasm' option to object to me removing it

[21:31] <yoleaux> brrt: I'll pass your message to FROGGS.

[21:32] <brrt> oh, and that i'm removing it anyway :-P

[21:34] <timotimo> RabidGravy: in theory, dyncall has support for "..." args, but it's not hooked up to moarvm at all yet

[21:36] *** espadrine left
[21:37] <RabidGravy> timotimo, cheers. I'll wing it and see what happens and if it becomes an issue I'll pester RT ;-)

[21:41] *** Foxcool left
[21:43] <dalek> rakudo/nom: 01edd37 | lizmat++ | src/Perl6/Grammar.nqp:

[21:43] <dalek> rakudo/nom: Disallow \$ \@ \% \& to create a Capture

[21:43] <dalek> rakudo/nom: 

[21:43] <dalek> rakudo/nom: For people coming from Perl 5, it is all too common to use \@a to

[21:43] <dalek> rakudo/nom: indicate a reference to @a.  In Perl 6, we don't do references as

[21:43] *** dalek left
[21:43] *** dalek joined
[21:43] *** ChanServ sets mode: +v dalek

[21:44] <lizmat> ^^^ complete commit message: https://gist.github.com/lizmat/df26b76c8d3426191577

[21:45] <nwc10> or https://github.com/rakudo/rakudo/commit/01edd37 :-)

[21:45] <lizmat> ah, better  :-)

[21:45] <nwc10> free diff with every commit message!

[21:46] <lizmat> yeah...

[21:46] <lizmat> maybe the URL should be posted first  :-)

[21:46] <nwc10> * not actually true for merge commits

[21:47] <lucasb> Since the sigiled forms are disallowed, why not making the parentheses required in all cases?

[21:48] <lizmat> that's what this patch effectively does?

[21:48] <masak> lucasb: because there are other things besides sigils and parentheses?

[21:48] <geekosaur> lucasb, that commit was a few back

[21:48] <lizmat> ah, of course,

[21:48] <lizmat> sub a(\a) {}

[21:48] <geekosaur> [05 20:46] <dalek> roast: 4d25274 | lizmat++ | S02-types/capture.t:

[21:48] <geekosaur> [05 20:46] <dalek> roast: Create capture with \() instead of just \

[21:49] <lucasb> What? :D just a minute

[21:49] <geekosaur> and yes, my original form of that (not quite as invasive :) handled the \a type case (after I found \key in the setting)

[21:49] <geekosaur> that was the spec commit that made \() the official syntax

[21:50] <geekosaur> followed by other commits to make existing stuff follow the new spec

[21:50] <lizmat> geekosaur: which spec commit are you referring to?

[21:51] <geekosaur> [05 20:46] <dalek> roast: 4d25274 | lizmat++ | S02-types/capture.t:

[21:51] <geekosaur> [05 20:46] <dalek> roast: Create capture with \() instead of just \

[21:51] <geekosaur> ?

[21:51] <geekosaur> which I'd just pasted a few minutes ago?

[21:51] <lizmat> that was a roast commit ?

[21:51] <geekosaur> oh, sigh

[21:51] <geekosaur> right, that's a test not the actual spec

[21:51] <lizmat> yup

[21:51] <geekosaur> whoops

[21:51] <lizmat> hehe

[21:52] * geekosaur officially Having A Day :/

[21:52] <lizmat> ok, glad we're on the same page again

[21:52] <lizmat> :-(

[21:52] <geekosaur> (this follows about 6 typoed code examples in a row over in #xmonad)

[21:53] <lizmat> m: my $a = \3; my $b := 3; dd $a, $b   # and here I thought these were equivalent

[21:53] <camelia> rakudo-moar 5919a8: OUTPUT«$a = \(3)␤3␤»

[21:54] *** brrt left
[21:54] <lizmat> I guess we want to weed out \ \d as well

[21:54] <lizmat> as some P5ers might think it's a backref

[21:54] <lucasb> m: say (\42).WHAT

[21:54] <camelia> rakudo-moar 5919a8: OUTPUT«(Capture)␤»

[21:55] <lucasb> so, "\42" should be now "\(42)", right?

[21:55] <lizmat> well, it will still work now because I didn't check for \ \d, only for \$, \@, \% and \&

[21:56] <lizmat> but yeah

[21:56] <lizmat> m: say \42 eqv \(42)

[21:56] <camelia> rakudo-moar 5919a8: OUTPUT«True␤»

[21:56] <lizmat> ok, will ponder over that after some shuteye

[21:56] <lizmat> so good night, #perl6!

[22:00] *** TEttinger joined
[22:12] <RabidGravy> ttfn #perl6!

[22:13] <skids> .tell lizmat you're probably already aware of it, but PR#454 will prevent Parameter.perl from emitting "\%" and "\&"

[22:13] <yoleaux> skids: I'll pass your message to lizmat.

[22:13] <ShimmerFairy> Hm. I'm not entirely sure I agree with getting rid of \$a and such as allowed ways to create a capture. I don't mind the change itself, but I'm a bit suspicious of doing too much to make things easier for P5 users. At some point your P5 knowledge _will_ fail, so I can't help but wonder if it's worth getting rid of any particular source of failure.

[22:15] *** colomon left
[22:15] *** colomon_ joined
[22:15] <geekosaur> that was my argument for just making it a warning, with parenthesization suppressing the warning but not otherwise required

[22:16] <geekosaur> s/argument/reason/, not like I actually argued it anywhere :)

[22:16] *** RabidGravy left
[22:17] <ShimmerFairy> When it comes to stuff confusing folks used to Perl 5, I think it's worth remembering that we're specifically not an iteration of Perl 5 :)

[22:17] <geekosaur> but the p6u message that triggered it is something I've seen before, a p5 user naively translating perl 5 refs to what they thought was the p6 equivalent

[22:19] <ShimmerFairy> I'd argue it's the programmer's fault for naively translating from P5 to P6 in general, and not the fault of the language design.

[22:19] <geekosaur> (and considering it "natural", when in fact only p5 would ever make you do that. well, and C, but you don't have any other choice in C...)

[22:20] *** kaare_ left
[22:21] <ShimmerFairy> Like I said, this specific change itself doesn't bother me much, but I do hope we don't find ourselves bending over backwards to change the language to be more P5-user-friendly.

[22:22] *** bin_005 left
[22:23] <geekosaur> I don't think there will be much more like this? but there are already a lot of p5 traps in there, and this is expected because it's billed as Perl and not some new language

[22:23] <masak> 'night, #perl6

[22:23] <BenGoldberg> m: my $scalar = 42; my $ref = \$scalar; say ++{$_}(|$ref);

[22:23] <BenGoldberg>  # not as easy to dereferene as it is in p5

[22:23] <camelia> rakudo-moar 01edd3: OUTPUT«5===SORRY!5=== Error while compiling /tmp/NUnGljb4WA␤This appears to be Perl 5 code␤at /tmp/NUnGljb4WA:1␤------> 3my $scalar = 42; my $ref = \$scalar7⏏5; say ++{$_}(|$ref);␤    expecting any of:␤        postfix␤»

[22:24] <geekosaur> that said, I think there are more uses of single-element captures than I had spotted (and apparently running the spectest does not show warnings... maybe I should have made it an error for that test?)

[22:24] <geekosaur> ...

[22:24] <geekosaur> I liked my warning better :)

[22:25] <geekosaur> ftr:

[22:25] <geekosaur>         | <?before '$' | '@' | '%'> <.worry("To pass an array or hash to a function in Perl 6, just pass it as is, and for other uses of Perl 5's ref operator consider binding with ::= instead. Parenthesize as \\(...) if you intended a capture of a single variable.")> <termish>

[22:26] <BenGoldberg> m: my $scalar = 42; my $ref = \\($scalar); say ++{$_}(|$ref);

[22:26] <camelia> rakudo-moar 01edd3: OUTPUT«Method 'succ' not found for invocant of class 'Capture'␤  in block <unit> at /tmp/f_4q2ohVAE:1␤␤»

[22:26] <BenGoldberg> m: my $scalar = 42; my $ref = \($scalar); say ++{$_}(|$ref);

[22:26] <camelia> rakudo-moar 01edd3: OUTPUT«43␤»

[22:26] <ShimmerFairy> geekosaur: That's a bit too directed towards Perl 5 for my taste :)

[22:26] <geekosaur> yet it is similar to existing warnings about Perl 5

[22:26] <geekosaur> would you like to review the codebase and complain about all the other ones?

[22:27] <ShimmerFairy> I know I've complained about the octal warning when I wanted to zero-pad my numbers before.

[22:28] <b2gills> Octal goes all the way back to early assembly though so is valid for people coming from many languages

[22:28] <BenGoldberg> Maybe we should think about making warning categories, and find a way for users to disable them in a scope, a la perl5's 'no warnings qw<category>' ?

[22:29] <ShimmerFairy> It's probably because I don't know a bit of Perl 5, but I think of Perl 6 as its own thing, so I'm generally opposed to things done with P5 users in mind. (I still don't like the fact that parts of the spec have things omitted because "it's just like in P5")

[22:29] *** kanl left
[22:30] <ShimmerFairy> BenGoldberg: There have been a few times where I wanted some sort of  use I-dont-know-P5  pragma, that stopped preventing various behaviors because the compiler thinks I'm trying to write P5 :)

[22:32] *** virtualsue left
[22:32] *** bjz left
[22:32] *** virtualsue joined
[22:37] *** lucasb left
[22:39] <skids> I'd like to see that too but AFAIC it can take a back seat to more pressing matters.

[22:42] <geekosaur> the problem is that perl has a lot of history behind it, and for every person who's coming to perl 6 fresh there are dozens coming to it from perl 5 --- and previous iterations of perl have taken care to maintain compatibility (which is why perl 5 has those refs instead of something sensible)

[22:43] <geekosaur> perl 6 is a major break and either we cut the cord completely or we provide help for existing perl users to migrate to it

[22:43] <geekosaur> s/are dozens/will be dozens/

[22:44] *** spider-mario left
[22:44] <ShimmerFairy> I understand that, but as someone who came to Perl 6 with no prior experience with Perl, I'm not a fan of the parts of the language that assume I'm a P5 user.

[22:50] *** virtualsue left
[22:51] *** amurf joined
[22:54] *** davido__ joined
[22:57] *** davido_ left
[23:03] *** Foxcool joined
[23:09] *** Foxcool left
[23:12] <timotimo> ← same here

[23:13] <timotimo> i've actually got a PR for rakudo open that gives the user the ability to remove p5 warnings, but at that time i only had a single warning to remove and that seemed almost useless :)

[23:14] <skids> THATs where I remember seeing that.  I was like "don't we have that already?"

[23:15] *** Peter_R left
[23:20] <timotimo> :)

[23:21] <timotimo> feel free to improve upon it a bit more

[23:26] *** BenGoldberg left
[23:33] *** Possum joined
[23:36] *** vendethiel left
[23:45] *** vendethiel joined
[23:47] *** dayangkun joined
