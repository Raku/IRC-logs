[00:10] *** atweiden left
[00:13] <psch> j: sub f($) { }; f Junction

[00:13] <camelia> rakudo-jvm 3b212a: OUTPUT«Nominal type check failed for parameter 'null'␤  in sub f at /tmp/WF97z9OZ4p:1␤  in block <unit> at /tmp/WF97z9OZ4p:1␤␤»

[00:13] <psch> i have a patch for that, but i'm not 100% happy with it :/

[00:14] *** spider-mario left
[00:15] <psch> on the upside it puts some stuff in that could help with other things

[00:15] <psch> r: ++4 # like this one

[00:15] <camelia> rakudo-jvm 3b212a: OUTPUT«Expected a native int argument for '$a'␤  in block <unit> at /tmp/tmpfile:1␤␤»

[00:15] <camelia> ..rakudo-moar 3b212a: OUTPUT«Parameter '$a' expected a writable container, but got Int value␤  in block <unit> at /tmp/tmpfile:1␤␤»

[00:15] *** raiph left
[00:21] *** leont left
[00:23] *** skids joined
[00:25] <AlexDaniel> m: say $++; say $++;

[00:26] *** cognominal_ joined
[00:26] *** AlexDaniel left
[00:28] *** ilbot3 left
[00:28] *** gonz_ left
[00:29] *** camelia joined
[00:29] *** ilbot3 joined
[00:29] *** cognominal left
[00:29] *** gonz_ joined
[00:30] *** erxeto joined
[00:30] <camelia> rakudo-moar 3b212a: OUTPUT«0␤0␤»

[00:30] *** ChanServ sets mode: +v camelia

[00:32] <Hotkeys> that was quite the delay

[00:32] <Hotkeys> oh I see

[00:32] *** raiph joined
[00:32] <Hotkeys> it died a pingy death

[00:42] <Hotkeys> rip Template::Mustache is still angry when I try to install it

[00:45] <dalek> roast: 1c35e0f | coke++ | S04-statements/gather.t:

[00:45] <dalek> roast: used merged ticket id

[00:45] <dalek> roast: review: https://github.com/perl6/roast/commit/1c35e0fb95

[00:46] *** bjz joined
[00:46] *** sufrostico left
[00:47] *** BenGoldberg joined
[00:47] <Hotkeys> transcription section on the linguistics midterm

[00:48] <Hotkeys> I wrote the first consonant in 'circumstantial' as [k] and not [s] because my brain hates me

[00:48] <Hotkeys> i only now realized it

[00:48] <Hotkeys> rip

[00:48] <Hotkeys> prof probably thinks I'm illiterate

[00:48] <Hotkeys> oops wrong channel

[00:48] *** _dolmen_ left
[00:48] <Hotkeys> well

[00:48] <Hotkeys> I hope you guys enjoy my anecdote

[00:49] <gfldex> you need to tell your prof not us :->

[00:49] <BenGoldberg> kirkumstantial?

[00:49] <Hotkeys> yeah lol

[00:49] <Hotkeys> gfldex, too late now, midterm already submitted

[00:49] <geekosaur> neh, just greek :p

[00:50] <geekosaur> (circe...)

[00:50] *** AndyDee joined
[00:50] <Hotkeys> it was because the word before it was courage

[00:50] <Hotkeys> and I guess I automatically wrote k

[00:50] *** bjz_ joined
[00:50] <Hotkeys> because that makes sense >_>

[00:51] *** bjz left
[00:55] <dalek> roast: 9c86762 | coke++ | S32-str/comb.t:

[00:55] <dalek> roast: fudge more instances of RT #124279

[00:55] <dalek> roast: review: https://github.com/perl6/roast/commit/9c867624a9

[00:55] <synbot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=124279

[00:58] *** bjz joined
[00:58] *** bjz_ left
[00:59] *** AndyDee left
[01:06] *** yeahnoob joined
[01:07] *** rangerprice joined
[01:17] *** raiph left
[01:19] *** tokuhiro_ left
[01:21] <MadcapJake> how would i write a function that alternately returns true/false anytime you call it?  I'm thinking of JavaScript and writing a generator with a while loop that just yields true and yields false and loops back.

[01:22] <timotimo> m: sub flipper() { return state $foo = not $foo }; say flipper; say flipper; say flipper;

[01:22] <camelia> rakudo-moar 3b212a: OUTPUT«5===SORRY!5=== Error while compiling /tmp/3Wdezs1FXx␤Cannot use variable $foo in declaration to initialize itself␤at /tmp/3Wdezs1FXx:1␤------> 3ub flipper() { return state $foo = not $7⏏5foo }; say flipper; say flipper; say fli␤    expect…»

[01:22] <timotimo> m: sub flipper() { return state $foo = True; $foo = not $foo }; say flipper; say flipper; say flipper;

[01:22] <camelia> rakudo-moar 3b212a: OUTPUT«True␤True␤True␤»

[01:22] <timotimo> m: sub flipper() { state $foo = True; $foo = not $foo }; say flipper; say flipper; say flipper;

[01:22] <camelia> rakudo-moar 3b212a: OUTPUT«False␤True␤False␤»

[01:22] <timotimo> m: sub flipper() { state $foo = True; $foo = not $foo }; say flipper; say flipper; say flipper; say flipper;

[01:22] <camelia> rakudo-moar 3b212a: OUTPUT«False␤True␤False␤True␤»

[01:23] *** raiph joined
[01:23] <MadcapJake> cool, never used the `state` keyword before.

[01:24] *** Zoffix joined
[01:27] <psch> m: sub flipper() { state $a = False; $a .= not }; say flipper; say flipper # golfed \o/

[01:27] <camelia> rakudo-moar 3b212a: OUTPUT«True␤False␤»

[01:27] <psch> m: sub flipper() { state $a = 0; $a .= not }; say flipper; say flipper # golfederer \o/

[01:27] <camelia> rakudo-moar 3b212a: OUTPUT«True␤False␤»

[01:28] <psch> ...that's what happens with 90 seconds stage parse and 32 seconds stage jast

[01:30] <MadcapJake> m: sub flipper() { $ = 0; $ .= not }; say flipper; say flipper

[01:30] <camelia> rakudo-moar 3b212a: OUTPUT«True␤False␤»

[01:30] <MadcapJake> # golfedererized xD

[01:31] <psch> MadcapJake: right!

[01:31] <psch> m: sub flipper() { $ .= not }; say flipper; say flipper 

[01:31] <camelia> rakudo-moar 3b212a: OUTPUT«True␤False␤»

[01:31] <MadcapJake> lol!

[01:32] <psch> and of course, spaces

[01:32] <psch> m: sub flipper() {$.=not}; say flipper; say flipper 

[01:32] <camelia> rakudo-moar 3b212a: OUTPUT«5===SORRY!5=== Error while compiling /tmp/o1aSvZtxg0␤Unsupported use of $. variable; in Perl 6 please use the filehandle's .ins method␤at /tmp/o1aSvZtxg0:1␤------> 3sub flipper() {$.7⏏5=not}; say flipper; say flipper␤»

[01:32] <psch> :l

[01:32] <psch> m: sub flipper() {$ .=not}; say flipper; say flipper # need that one, apparently

[01:32] <camelia> rakudo-moar 3b212a: OUTPUT«True␤False␤»

[01:34] *** Ben_Goldberg joined
[01:34] <psch> although only because that perl5 warning is around

[01:35] <MadcapJake> haha wow, that's some serious golf action then :P

[01:35] <psch> don't do this in production, kids!

[01:37] *** BenGoldberg left
[01:38] <MadcapJake> i can't seme to get the golfed one to start with a false value the more explicity `state`  declarred one can start false though

[01:38] <MadcapJake> woah, super spelling errors in that sentence xO

[01:39] <MadcapJake> gotta start reading what I type...

[01:39] <psch> m: sub flipper() {!($ .=not)}; say flipper; say flipper 

[01:39] <camelia> rakudo-moar 3b212a: OUTPUT«False␤True␤»

[01:39] <psch> it's not as golfy anymore

[01:39] <psch> but $ inits as Any, which gets its own negation assigned

[01:39] <psch> so you "can't" (FSVO "can't") start with False

[01:40] <MadcapJake> ah i see

[01:42] *** Skarsnik left
[01:42] *** kid51 left
[01:50] <dalek> roast: f55436c | coke++ | S32-io/spurt.t:

[01:50] <dalek> roast: fudge jvm for RT #126495

[01:50] <dalek> roast: review: https://github.com/perl6/roast/commit/f55436ce61

[01:50] <synbot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=126495

[01:55] *** Actualeyes joined
[01:55] *** dj_goku left
[02:06] *** TEttinger left
[02:15] *** dayangkun joined
[02:15] *** tokuhiro_ joined
[02:18] *** rangerprice left
[02:20] *** tokuhiro_ left
[02:27] <ShimmerFairy> m: say { 1 => 2 } === { 1 => 2 };    say { 1 => 2 } ~~ { 1 => 2 };  # I feel like at least ~~ should say True

[02:27] <camelia> rakudo-moar 3b212a: OUTPUT«False␤False␤»

[02:29] *** raiph left
[02:30] <psch> m: say 1 ~~ { 1 => 2 }

[02:30] <camelia> rakudo-moar 3b212a: OUTPUT«True␤»

[02:31] <psch> that's a sneaky exists-key...

[02:33] *** tokuhirom joined
[02:33] <tokuhirom> in this commit https://github.com/rakudo/rakudo/commit/0cdb974ecda7893b4db02e4870f01326a731093b

[02:33] <psch> ShimmerFairy: according to synopses and roast you're right, it's underimplemented

[02:33] <tokuhirom> before: split("=", "YYY=", 2) returns 'YYY=', ''

[02:34] <psch> ShimmerFairy: the ACCEPTS(Hash:D: Hash $topic) candidate is missing

[02:34] <ShimmerFairy> psch: maybe arguably the one for Map is the one that's missing [too], but I wouldn't know :)

[02:34] <tokuhirom> after: split('=', 'YYY=', 2) returns just 'YYY'

[02:36] <ShimmerFairy> tokuhirom: seems like a bug to me

[02:36] <psch> ShimmerFairy: i don't see Map anywhere in the list in S03

[02:37] <psch> s/list/table/

[02:37] <dalek> rakudo-star-daily: 6d78ecb | coke++ | log/ (9 files):

[02:37] <dalek> rakudo-star-daily: today (automated commit)

[02:37] <dalek> rakudo-star-daily: review: https://github.com/coke/rakudo-star-daily/commit/6d78ecb85e

[02:37] <ShimmerFairy> psch: that's probably the design docs not being updated. I believe it used to be called EnumMap or such

[02:37] <psch> anyway, i'm talking about "Hash        Hash      hash mapping equivalent $_ eqv X"

[02:37] <psch> that one's definitely missing

[02:37] <psch> if it should hang from Map or Hash, i wouldn't know

[02:38] <psch> same for the Associate ~~ Hash one i guess

[02:39] <psch> they're todo NYI in S03-smartmatch/hash-hash.t

[02:40] <psch> where "they" means "8 tests that test this"

[02:40] *** tokuhirom left
[02:40] *** tokuhirom joined
[02:41] <psch> Map isn't in the table either, but that's not an argument against "out of date"

[02:41] <psch> err, EnumMap

[02:42] *** ][Sno][ joined
[02:42] <ShimmerFairy> yeah, I'm not too familiar with what exactly happened in the GMR :)

[02:44] *** [Sno] left
[02:44] *** ilbot3 left
[02:46] *** ilbot3 joined
[02:47] *** ][Sno][ left
[02:48] *** [Sno] joined
[02:49] *** aborazmeh joined
[02:49] *** aborazmeh left
[02:49] *** aborazmeh joined
[02:49] <dalek> roast: 3185bb0 | ShimmerFairy++ | S32-str/split.t:

[02:49] <dalek> roast: Add a couple tests for split

[02:49] <dalek> roast: 

[02:49] <dalek> roast: Inspired by a bug found by tokuhirom++ . Specifically not SKIPped or

[02:49] <dalek> roast: TODO'd so the issue is more visible.

[02:49] <dalek> roast: review: https://github.com/perl6/roast/commit/3185bb07aa

[02:52] *** Oatmeal left
[02:54] <skids> reading git logs GMR was:  PairMap gone, EnumMap became Map, Enum (not to be confised with enum) merged into Pair which is now shallowly immutable

[02:55] <dalek> rakudo/nom: fe5b300 | peschwa++ | src/vm/jvm/runtime/org/perl6/rakudo/ (2 files):

[02:55] <dalek> rakudo/nom: Move throwing of X::TypeCheck::Binding out of bindOneParam.

[02:55] <dalek> rakudo/nom: 

[02:55] <dalek> rakudo/nom: Previously we'd fail with "Nominal type check failed for parameter 'null'", in

[02:55] <dalek> rakudo/nom: e.g. <sub f($) { }; f Junction>, because we threw the Exception directly. This

[02:55] <dalek> rakudo/nom: patch moves the throw *after* actually failing to bind.

[02:55] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/fe5b300d47

[02:55] <psch> r: ++4 # not fixed yet, with that patch

[02:55] <camelia> rakudo-moar 3b212a: OUTPUT«Parameter '$a' expected a writable container, but got Int value␤  in block <unit> at /tmp/tmpfile:1␤␤»

[02:55] <camelia> ..rakudo-jvm 3b212a: OUTPUT«Expected a native int argument for '$a'␤  in block <unit> at /tmp/tmpfile:1␤␤»

[02:55] <psch> there's something really different between r-j and r-m wrt IntLexRef i feel

[02:55] <dalek> ecosystem: 4194889 | cygx++ | META.list:

[02:55] <dalek> ecosystem: Add Native::LibC

[02:55] <dalek> ecosystem: 

[02:55] <dalek> ecosystem: Still work in progress, but I'd like to get some more eyes on this.

[02:55] <dalek> ecosystem: review: https://github.com/perl6/ecosystem/commit/4194889086

[02:55] <psch> 'cause that's what i get, currently...

[02:56] <psch> also, horray for git add -p

[02:56] <psch> "Parameter '$a' expected a writable container, but got IntLexRef value"

[02:56] <psch> just weird :l

[02:56] <psch> but maybe i'm just sleepily confusing decont-neccessities or somesuch...

[02:58] *** Oatmeal joined
[03:07] *** chansen_ joined
[03:08] *** TEttinger joined
[03:08] *** olinkl joined
[03:08] *** kaare_ joined
[03:08] *** SmokeMachine joined
[03:10] *** Spot__ joined
[03:14] *** PotatoGim joined
[03:15] *** zemmihates joined
[03:16] *** tokuhiro_ joined
[03:17] <MadcapJake> I finished my english-to-pig-latin command line tool!  Now the world can use this to transmit totally secure encrypted english messages. https://gist.github.com/MadcapJake/2c78ea7585143298c66a

[03:20] *** tokuhiro_ left
[03:23] *** TEttinger left
[03:33] *** TEttinger joined
[03:45] *** skids left
[03:49] <colomon> m: say samecase(“hello”, “ATesT”)

[03:49] <camelia> rakudo-moar fe5b30: OUTPUT«HEllO␤»

[03:49] <colomon> m: say samecase(“hello”, “ATes”)

[03:49] <camelia> rakudo-moar fe5b30: OUTPUT«HEllo␤»

[03:49] <colomon> MadcapJake: I like your script!

[03:50] <colomon> m: say samecase(“hello”, “ATeS”)

[03:50] <camelia> rakudo-moar fe5b30: OUTPUT«HElLO␤»

[03:50] <colomon> MadcapJake: I think maybe you can replace your case logic using the samecase sub (see above examples)

[03:51] *** llfourn joined
[03:51] <colomon> m: say samecase(“itleTay”, “Title”)

[03:51] <camelia> rakudo-moar fe5b30: OUTPUT«Itletay␤»

[03:52] <colomon> …. then again, maybe not?

[03:52] <colomon> oh, that’s an I, not a capital i

[03:52] <colomon> lowercase L, I mean.  :)

[03:54] <colomon> afk # bedtime

[04:09] *** Ben_Goldberg left
[04:12] *** Alina-malina left
[04:12] *** khw left
[04:19] <zengargoyle> m: given "--phrase" { when any <-p --phrase> { say "phrase" } }

[04:19] <camelia> rakudo-moar fe5b30: OUTPUT«phrase␤»

[04:19] <zengargoyle> m: given "-p" { when any <-p --phrase> { say "phrase" } }

[04:19] <camelia> rakudo-moar fe5b30: OUTPUT«phrase␤»

[04:27] <zengargoyle> wonders if :Letter is ok with <[aeiou]>, could probably use :ignoremark (?) to treat ä as a, etc.  then again piglatin vs non-english is ...

[04:29] <zengargoyle> given @*ARGV.shift { when any <-p --phrase> { translate( @*ARGV.join(' ') ) } }

[04:55] <ShimmerFairy> Even better would be  sub MAIN(:p($phrase), :f($file)) { ... }    :)

[05:00] *** Calibellus left
[05:01] *** cognominal_ left
[05:01] *** cognominal_ joined
[05:09] <MadcapJake> colomon: thanks, i've updated the gist.  saved three lines and it cuts out some of the ugly casing noise!

[05:12] <zengargoyle> multi sub MAIN( Bool :f(:$file), *@filename where { @filename.so }  ) {         

[05:13] <zengargoyle> sadly you can't do just $filename due to it being positional.  and sadly :f(:$file)) requires ugly --file=filename

[05:14] <zengargoyle> multi sub MAIN( Bool :p(:$phrase), *@text ) { # works nicely with @text.join(' ') though

[05:15] *** geraud left
[05:17] <zengargoyle> you can also do like .match(/^<$vowels>/) and skip the $/==0 check

[05:19] *** raiph joined
[05:21] *** vendethiel joined
[05:25] *** raiph left
[05:28] <psch> MadcapJake: https://gist.github.com/peschwa/6c3521d3190c51f80eb8 # how i'd write it

[05:28] <psch> MadcapJake: note that it's not with -f/--file and -p/--path anymore, but just a single argument that gets understood as file if it is one

[05:28] <psch> MadcapJake: also i know a few more builtins :)

[05:29] <MadcapJake> sweet! so the `where *.IO.f` is where it checks to see if it's a file, then?

[05:29] <psch> MadcapJake: yeah

[05:29] *** bjz_ joined
[05:31] *** bjz left
[05:31] <MadcapJake> your @consonants declaration is really slick!

[05:31] <MadcapJake> what does the `cache` method do?

[05:31] <psch> could be slicker if i had a compose key around... :S

[05:32] <psch> cache is the cached result of a Seq

[05:32] <psch> m: my $a := ^10; say $a.WHAT

[05:32] <camelia> rakudo-moar fe5b30: OUTPUT«(Range)␤»

[05:32] <MadcapJake> oh ok gotcha

[05:32] <psch> m: my $a := 1...10; say $a.WHAT

[05:32] <camelia> rakudo-moar fe5b30: OUTPUT«(Seq)␤»

[05:32] <psch> m: my $a := 1...10; say $a; say $a

[05:32] <camelia> rakudo-moar fe5b30: OUTPUT«(1 2 3 4 5 6 7 8 9 10)␤(1 2 3 4 5 6 7 8 9 10)␤»

[05:32] <psch> hm, maybe caches already somewhere..?=

[05:32] <psch> but yeah, its one spot where the GLR feels a bit iffy to me

[05:33] <MadcapJake> how so?

[05:33] * zengargoyle now knows how to use .cache

[05:33] <zengargoyle> have had way to many Seq has already been ... lately

[05:34] <psch> hm, i can't reproduce it, maybe it went away.. :)

[05:34] <psch> MadcapJake: i used to stumble across "This Seq has already been iterated and its values consumed" quite a lot

[05:34] <MadcapJake> zengargoyle: looking back, good idea using the `^` anchor, that would clean it up a lot

[05:34] <zengargoyle> m: .say for <'a' .. 'z'> (-) <a e i o u>

[05:34] <camelia> rakudo-moar fe5b30: OUTPUT«'a' => True␤'z' => True␤.. => True␤»

[05:35] <psch> m: say (<'a' .. 'z'> (-) <a e i o u>).keys

[05:35] <camelia> rakudo-moar fe5b30: OUTPUT«('a' 'z' ..)␤»

[05:35] <psch> oh, the angles

[05:35] <MadcapJake> what does that mean for the minus to be wrapped in parentheses?

[05:35] <psch> m: say ('a' .. 'z' (-) <a e i o u>).keys

[05:35] <camelia> rakudo-moar fe5b30: OUTPUT«Method 'z' not found for invocant of class 'Str'␤  in block <unit> at /tmp/BWpwBpzFWA:1␤␤»

[05:35] <zengargoyle> yeah, could have sworn i saw it without keys and thought it worked on lists as well as Set

[05:35] <psch> m: say (('a' .. 'z') (-) <a e i o u>).keys

[05:35] <camelia> rakudo-moar fe5b30: OUTPUT«(p n k r l c q g b x s j t m y w v h z f d)␤»

[05:35] <psch> m: say (('a' .. 'z') (-) <a e i o u>).

[05:35] <camelia> rakudo-moar fe5b30: OUTPUT«5===SORRY!5=== Error while compiling /tmp/We9ILcVI9T␤Missing required term after infix␤at /tmp/We9ILcVI9T:1␤------> 3say (('a' .. 'z') (-) <a e i o u>).7⏏5<EOL>␤    expecting any of:␤        dotty method or postfix␤»

[05:35] <psch> m: say (('a' .. 'z') (-) <a e i o u>)

[05:35] <camelia> rakudo-moar fe5b30: OUTPUT«set(p, n, k, r, l, c, q, g, b, x, s, j, t, m, y, w, v, h, z, f, d)␤»

[05:35] <psch> MadcapJake: set operation

[05:36] <psch> MadcapJake: that's why i said "if i had a compose key", 'cause we of course have that in unicodey

[05:36] <zengargoyle> like that probably

[05:36] <psch> .u set substraction

[05:36] <yoleaux> No characters found

[05:36] <psch> .u set

[05:36] <yoleaux> U+0088 CHARACTER TABULATION SET [Cc] (<control>)

[05:36] <yoleaux> U+008A LINE TABULATION SET [Cc] (<control>)

[05:36] <yoleaux> U+0093 SET TRANSMIT STATE [Cc] (<control>)

[05:36] <psch> .u set minus

[05:36] <yoleaux> U+2216 SET MINUS [Sm] (∖)

[05:36] *** telex left
[05:36] <psch> there 

[05:36] <psch> (i hope, doesn't render here :) )

[05:36] <MadcapJake> oh, and the round parentheses signify a set?

[05:36] <psch> m: say ("a".."z") ∖ <a e i o u>

[05:36] <camelia> rakudo-moar fe5b30: OUTPUT«set(p, n, k, r, l, c, q, g, b, x, s, j, t, m, y, w, v, h, z, f, d)␤»

[05:37] <psch> MadcapJake: no, ("a".."z", "A".."Z") is just a List

[05:37] <MadcapJake> m: say ("a".."z").WHAT

[05:37] <camelia> rakudo-moar fe5b30: OUTPUT«(Range)␤»

[05:37] <MadcapJake> ok xD

[05:37] <psch> m: say ("a".."z", "A".."Z").WHAT

[05:37] <camelia> rakudo-moar fe5b30: OUTPUT«(List)␤»

[05:38] <MadcapJake> cool that you can just do set operations on a list

[05:38] *** telex joined
[05:38] <MadcapJake> why the call to `keys`? Isn't that just for pairs?

[05:38] <psch> m: set(1,2,3).say

[05:38] <camelia> rakudo-moar fe5b30: OUTPUT«set(3, 1, 2)␤»

[05:39] <psch> m: set(1,2,3).list.say

[05:39] <camelia> rakudo-moar fe5b30: OUTPUT«(3 => True 1 => True 2 => True)␤»

[05:39] <MadcapJake> ohhh, so the `(-)` turns it into a set?

[05:39] <psch> ^^^ that's why .keys

[05:39] <psch> yeah, the list gets promoted to a set, and the .keys call gives turns it back into a List

[05:40] <psch> i'd guess in hindsight that the .cache call in that line isn't neccessary..

[05:40] <MadcapJake> interesting, is there a situation where the value of a set pair would be `False`?

[05:40] <psch> m: my $word = "foobar"; $word.comb(/./).rotate(1).say

[05:40] <camelia> rakudo-moar fe5b30: OUTPUT«Method 'rotate' not found for invocant of class 'Seq'␤  in block <unit> at /tmp/kQUBA1oRDD:1␤␤»

[05:40] <psch> MadcapJake: well, the value means "it's in the set", afair

[05:41] <MadcapJake> oh ok, hehe, kind of tautological

[05:41] <zengargoyle> ah, when i saw it without keys it was later .pick()'d to get a value.

[05:42] <zengargoyle> so stayed a Set

[05:43] <MadcapJake> That rotated line is really spiffy.  Surprisingly readable too!

[05:43] <psch> that line definitely needs the .cache call, as shown above

[05:44] *** dayangkun_ joined
[05:44] <MadcapJake> so `comb` returns a seq then

[05:44] <psch> m: my $a = "abc".comb: /./; say $a; say $A

[05:44] <camelia> rakudo-moar fe5b30: OUTPUT«5===SORRY!5=== Error while compiling /tmp/xnQSEK7GCI␤Variable '$A' is not declared␤at /tmp/xnQSEK7GCI:1␤------> 3my $a = "abc".comb: /./; say $a; say 7⏏5$A␤»

[05:44] <psch> m: my $a = "abc".comb: /./; say $a; say $a

[05:44] <camelia> rakudo-moar fe5b30: OUTPUT«(a b c)␤(a b c)␤»

[05:44] *** vendethiel left
[05:44] <psch> m: my $a = "abc".comb: /./; say $a.WHAT

[05:44] <camelia> rakudo-moar fe5b30: OUTPUT«(Seq)␤»

[05:45] <psch> well, it seems like the already consumed stuff got hidden quite well by now

[05:45] <psch> oh wait, assignment..?

[05:45] <MadcapJake> I've got to sit down and figure out what returns a seq and what returns a list.  Is there any nice rundown of that on the internet somewhere?

[05:45] <psch> m: my $a := "abc".comb: /./; say $a; say $a

[05:45] <camelia> rakudo-moar fe5b30: OUTPUT«(a b c)␤(a b c)␤»

[05:45] <psch> MadcapJake: in general, Seq is mostly supposed to be transparent i think

[05:46] *** dayangkun left
[05:46] <psch> m: my \a := "abc".comb: /./; say a; say a

[05:46] <camelia> rakudo-moar fe5b30: OUTPUT«(a b c)␤(a b c)␤»

[05:46] <psch> vOV

[05:46] <psch> no idea where that exception still happens, if it all

[05:48] <MadcapJake> well that's good but in what situations are you going to need a `cache` method call?

[05:48] <zengargoyle> m: my $a = "abc".comb.grep: /b/; say @$a; say @$a;

[05:48] <camelia> rakudo-moar fe5b30: OUTPUT«(b)␤(b)␤»

[05:48] <zengargoyle> i think sometimes it depends on the length of the list and whether it's small enough to be done at once vs turned into a Seq

[05:49] <psch> m: my $a := "a".."z".comb; say $a; say $a

[05:49] <camelia> rakudo-moar fe5b30: OUTPUT«Seq objects are not valid endpoints for Ranges␤  in block <unit> at /tmp/Jo67DDU2ZU:1␤␤»

[05:49] <psch> m: my $a := ("a".."z").comb; say $a; say $a

[05:49] <camelia> rakudo-moar fe5b30: OUTPUT«(a   b   c   d   e   f   g   h   i   j   k   l   m   n   o   p   q   r   s   t   u   v   w   x   y   z)␤(a   b   c   d   e   f   g   h   i   j   k   l   m   n   o   p   q   r   s   t   u   v   w   x   y   z)␤»

[05:49] <psch> m: my $a := ("a".."z").comb; say $a.elems

[05:49] <camelia> rakudo-moar fe5b30: OUTPUT«51␤»

[05:49] <psch> m: my $a := ("a".."z").comb; say $a.WHAT

[05:49] <camelia> rakudo-moar fe5b30: OUTPUT«(Seq)␤»

[05:50] <psch> MadcapJake: there unfortunately i can only say "when it complains that Seq doesn't have the method you want to call" :/

[05:51] <psch> m: my $a = ("a".."z").comb(/./); $a.WHAT.say

[05:51] <camelia> rakudo-moar fe5b30: OUTPUT«(Seq)␤»

[05:51] <psch> m: my @a = ("a".."z").comb(/./); @a.WHAT.say

[05:51] <camelia> rakudo-moar fe5b30: OUTPUT«(Array)␤»

[05:53] <zengargoyle> m: my $a = 'abc'.comb; my $b = $a.grep(/b/); say $a;

[05:53] <camelia> rakudo-moar fe5b30: OUTPUT«This Seq has already been iterated, and its values consumed␤  in block <unit> at /tmp/r9YkznBiQM:1␤␤»

[05:53] <zengargoyle> BAM

[05:53] <zengargoyle> m: my $a = 'abc'.comb.cache; my $b = $a.grep(/b/); say $a;

[05:53] <camelia> rakudo-moar fe5b30: OUTPUT«(a b c)␤»

[05:54] <psch> ah, so &say doesn't consume a Seq anymore

[05:54] <psch> that seems a little bit magical, if that's really the cause

[05:54] <psch> i suppose .gist is behind that

[05:54] <zengargoyle> all i know is that it hits me when i least expect it. :P

[05:54] <psch> m: my $a = "abc".comb; print $a; print $a

[05:54] <camelia> rakudo-moar fe5b30: OUTPUT«a b ca b c»

[05:54] <psch> m: my $a = "abc".comb; .print for $a; .print for $a

[05:54] <camelia> rakudo-moar fe5b30: OUTPUT«abcThis Seq has already been iterated, and its values consumed␤  in block <unit> at /tmp/QE0ohYRYLG:1␤␤»

[05:55] <psch> mhm, it's kind of understandable to me why it happens, still a tiny bit inconvenient though

[05:55] <zengargoyle> m: my $a = ('a'..'z').comb; print $a; print $a;

[05:55] <camelia> rakudo-moar fe5b30: OUTPUT«a   b   c   d   e   f   g   h   i   j   k   l   m   n   o   p   q   r   s   t   u   v   w   x   y   za   b   c   d   e   f   g   h   i   j   k   l   m   n   o   p   q   r   s   t   u   v   w   x   y   z»

[05:56] <psch> as in, whenever you don't enforce context onto something iterate-y, you still have the Seq

[05:56] <psch> and if you iterate over a Seq more than once it complains

[05:56] <psch> where "something iterate-y" means "something that could be lazy"

[06:32] <dalek> rakudo/nom: 52e5dd2 | TimToady++ | src/Perl6/Grammar.nqp:

[06:32] <dalek> rakudo/nom: implement autogen of meta nouns

[06:32] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/52e5dd2914

[06:32] <dalek> roast: 481a9eb | TimToady++ | S03-metaops/ (6 files):

[06:32] <dalek> roast: add tests for autogen of metaops

[06:32] <dalek> roast: review: https://github.com/perl6/roast/commit/481a9eb8fe

[06:33] <TimToady> that turned out to be easier than I expected

[06:43] *** rarara joined
[06:45] <TimToady> though poking the symbol into $*UNIT is probably wrongish, now that I think about it, since a subscope could have overridden the base op, and that should not leak out to outer scopes

[06:48] <dalek> rakudo/nom: 2856ed3 | TimToady++ | src/Perl6/Grammar.nqp:

[06:48] <dalek> rakudo/nom: autogen should go into current scope, not unit

[06:48] <dalek> rakudo/nom: 

[06:48] <dalek> rakudo/nom: Since a meta depends on the current base op, and that can be shadowed inside

[06:48] <dalek> rakudo/nom: a scope, we should only install the autogen into the current lexical scope,

[06:48] <dalek> rakudo/nom: and let outer scopes do their own autogen with (presumably) different base ops.

[06:48] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/2856ed3ca9

[06:48] <rarara> Good morning

[06:49] <TimToady> it's not morning for 12 minutes yet :)

[06:49] <rarara> Good *

[06:49] <rarara> :)

[06:51] <baest> TimToady: in which timezone?

[06:51] <rarara> Also here the sky is still reddish

[06:52] <TimToady> baest: PDT, at least till Sunday

[06:53] <baest> :)

[06:53] <baest> I feel like it's morning here in CET 

[06:54] <rarara> Idem

[06:59] <rarara> Can somebody explain me the difference between the following two pieces of code?

[06:59] <rarara> my @a=(List(1,2,3), Seq(1,2,3)); for @a -> @b ($c, $d, $e) { say @b.WHAT; }

[06:59] <rarara> and my @a=(List(1,2,3), Seq(1,2,3)); for @a -> $b ($c, $d, $e) { say $b.WHAT; }

[06:59] <rarara> only the former works

[06:59] <dalek> roast: 11681b8 | TimToady++ | S03-metaops/reverse.t:

[06:59] <dalek> roast: make sure autogen scopes to current block only

[06:59] <dalek> roast: review: https://github.com/perl6/roast/commit/11681b833f

[07:02] <TimToady> @ caches the sequence automatically, $ does not

[07:03] <TimToady> the error message is a bit LTA though

[07:05] *** FROGGS joined
[07:08] <rarara> Thanks

[07:08] *** diana_olhovik_ joined
[07:13] <rarara> TimToady: wouldn' be better for the subsignature to just consume the Seq?

[07:13] <rarara> in analogy to: my @a=(List(1,2,3), Seq(4,5,6)); my ($c, $d, $e) = @a[1]; say $d;

[07:14] <rarara> well, they are not really the same (the assignment doesn't check the correct number of elements)

[07:15] <TimToady> you'd think so, but maybe jnthn++ has a good reason why not

[07:15] *** adhoc left
[07:18] <TimToady> m: my &f = &prefix:<[**]>; say f(2,3,4)

[07:18] <camelia> rakudo-moar 52e5dd: OUTPUT«2417851639229258349412352␤»

[07:18] <TimToady> m: my &f = &prefix:<[R**]>; say f(2,3,4)

[07:18] <camelia> rakudo-moar 52e5dd: OUTPUT«262144␤»

[07:18] <TimToady> m: my &f = &prefix:<[RR**]>; say f(2,3,4)

[07:18] <camelia> rakudo-moar 52e5dd: OUTPUT«2417851639229258349412352␤»

[07:19] <TimToady> m: my &f = &prefix:<[-«]>; say f(2,3,4)

[07:19] <camelia> rakudo-moar 52e5dd: OUTPUT«5===SORRY!5=== Error while compiling /tmp/cIf7c8pHCS␤Undeclared routine:␤    &prefix:<[-«]> used at line 1. Did you mean '&prefix:<~>', '&prefix:<temp>', '&prefix:<->', '&prefix:<so>', '&prefix:<+>'?␤␤»

[07:19] <TimToady> m: my &f = &prefix:<-«>; say f(2,3,4)

[07:19] <camelia> rakudo-moar 52e5dd: OUTPUT«Too many positionals passed; expected 0 or 1 arguments but got 3␤  in block <unit> at /tmp/TsYjBrT4V6:1␤␤»

[07:20] <TimToady> hmm, bug, I guess

[07:20] <ShimmerFairy> Is there a way to make enums not poison their surrounding scope? I'd prefer not seeing a screen of warnings every time, especially since I don't want unqualified enum values in the first place :)

[07:20] <TimToady> m: my &f = &prefix:<-«>; say f((2,3,4))

[07:20] <camelia> rakudo-moar 52e5dd: OUTPUT«-3␤»

[07:22] <TimToady> maybe 'quietly' will work for that?

[07:23] *** rarara left
[07:23] <TimToady> speaking of quietly, bed &

[07:24] <ShimmerFairy> Just tried it, and quietly { } does nothing :/

[07:30] *** darutoko joined
[07:42] <[Tux]> test             50000    37.186    37.074

[07:42] <[Tux]> test-t           50000    38.861    38.750

[07:45] <moritz> \o

[07:50] <[ptc]> o/

[07:58] *** rindolf joined
[07:58] *** TimToady left
[07:58] *** rarara joined
[08:00] *** TimToady joined
[08:05] *** [Sno] left
[08:06] *** [Sno] joined
[08:12] *** Actualeyes left
[08:16] *** espadrine joined
[08:22] *** ely-se joined
[08:26] *** softmoth left
[08:27] *** pollei left
[08:29] *** MARTIMM joined
[08:37] <mrf> good * #perl6

[08:39] <moritz> good morning, mrf

[08:41] <moritz> m: my constant MyEnum = anon enum <A B C>; say MyEnum::A

[08:41] <camelia> rakudo-moar 2856ed: OUTPUT«Cannot call method 'AT-KEY' on a null object␤  in block <unit> at /tmp/pJhlUnV7hk:1␤␤»

[08:41] <moritz> m: my constant MyEnum = anon enum <A B C>; say MyEnum.A

[08:41] <camelia> rakudo-moar 2856ed: OUTPUT«Method 'A' not found for invocant of class 'Map'␤  in block <unit> at /tmp/BDEEkkhsRV:1␤␤»

[08:41] <moritz> m: my constant MyEnum = anon enum MyEnum <A B C>; say MyEnum::A

[08:41] <camelia> rakudo-moar 2856ed: OUTPUT«Cannot call method 'AT-KEY' on a null object␤  in block <unit> at /tmp/S1e47506Yj:1␤␤»

[08:41] <moritz> :(

[08:47] <MARTIMM> Goodmorning to you all

[08:47] <MARTIMM> Found the following after install of the newest rakudo

[08:47] <MARTIMM> my Array $a = Buf.new(^10).list

[08:47] <MARTIMM> Type check failed in assignment to $a; expected Array but got List

[08:47] <MARTIMM>   in block <unit> at <unknown file>:1

[08:48] <MARTIMM> Previously it was alright

[08:48] <moritz> MARTIMM: well, it's called .list, so returning a List is fine

[08:48] <moritz> MARTIMM: Array is a subtype of List, so returning Array was also fine; but it was more like an implementation detail

[08:51] <MARTIMM> it is more understandable as it is now. Need to change a lot of code because of this, so just checking.

[08:52] <MARTIMM> is there a way to coerce it from Buf to Array. I can use that for time being

[08:55] <moritz> m: say Buf.new(*^10).Array

[08:55] <camelia> rakudo-moar 2856ed: OUTPUT«This type cannot unbox to a native integer␤  in any  at gen/moar/m-Metamodel.nqp:1674␤  in block <unit> at /tmp/j7m0nOsGKe:1␤␤»

[08:56] <moritz> m: say Buf.new(*^10).list.Array

[08:56] <camelia> rakudo-moar 2856ed: OUTPUT«This type cannot unbox to a native integer␤  in any  at gen/moar/m-Metamodel.nqp:1674␤  in block <unit> at /tmp/8maZQUeRqo:1␤␤»

[08:56] <moritz> m: say my @ = Buf.new(*^10).list

[08:56] <camelia> rakudo-moar 2856ed: OUTPUT«This type cannot unbox to a native integer␤  in any  at gen/moar/m-Metamodel.nqp:1674␤  in block <unit> at /tmp/sEDrfFAOPV:1␤␤»

[08:56] <moritz> m: say  Buf.new(*^10).list

[08:56] <camelia> rakudo-moar 2856ed: OUTPUT«This type cannot unbox to a native integer␤  in any  at gen/moar/m-Metamodel.nqp:1674␤  in block <unit> at /tmp/7YrOesoHmF:1␤␤»

[08:56] <moritz> eeks

[08:56] <moritz> oh

[08:56] <moritz> it's the *

[08:56] <moritz> m: say  Buf.new(^10).list

[08:56] <camelia> rakudo-moar 2856ed: OUTPUT«(0 1 2 3 4 5 6 7 8 9)␤»

[08:56] <moritz> m: say  Buf.new(^10).Array

[08:56] <camelia> rakudo-moar 2856ed: OUTPUT«[0 1 2 3 4 5 6 7 8 9]␤»

[08:56] <moritz> m: say  Buf.new(^10).Array.^name

[08:56] <camelia> rakudo-moar 2856ed: OUTPUT«Array␤»

[08:56] <moritz> MARTIMM: .Array seems to work fine

[08:57] *** ecocode joined
[08:58] *** RabidGravy joined
[09:00] *** g4 joined
[09:00] *** g4 left
[09:00] *** g4 joined
[09:04] *** ely-se left
[09:04] *** ely-se joined
[09:05] *** duncan_dmg joined
[09:06] <kmel_> m: say 'Hola';

[09:06] <camelia> rakudo-moar 2856ed: OUTPUT«Hola␤»

[09:10] <RabidGravy> yo

[09:10] <MARTIMM> Thanks very much, I've tried it and works

[09:13] *** zakharyas joined
[09:13] <MARTIMM> moritz Thanks very much, I've tried it and works(i am an irc neewbe)

[09:13] <RabidGravy> tadzik++ # JSON::Unmarshal all good now

[09:15] *** adhoc joined
[09:17] *** _mg_ joined
[09:20] <RabidGravy> who was it the other day was evincing some reluctance to learn git? http://xkcd.com/1597/

[09:25] <mrf> RabidGravy: :D

[09:26] *** Begi1115 joined
[09:27] *** espadrine_ joined
[09:27] *** espadrine left
[09:30] *** Psyche^ joined
[09:31] <mrf> m: sub foo is export (Str $string) {say $string} foo('bar')

[09:31] <camelia> rakudo-moar 2856ed: OUTPUT«5===SORRY!5=== Error while compiling /tmp/LBFizxo7C2␤Missing block␤at /tmp/LBFizxo7C2:1␤------> 3sub foo is export7⏏5 (Str $string) {say $string} foo('bar')␤    expecting any of:␤        new name to be defined␤»

[09:32] *** tokuhiro_ joined
[09:33] <RabidGravy> traits have to after the argument list

[09:34] <RabidGravy> but iit's possible the message could be a bit more awesome

[09:34] *** Psyche^_ left
[09:36] *** tokuhiro_ left
[09:36] *** kjs_ joined
[09:39] <mrf> m: sub foo (Str $string) is export { $string.say} foo('bar')

[09:39] <camelia> rakudo-moar 2856ed: OUTPUT«5===SORRY!5=== Error while compiling /tmp/Uvtsq7XNgx␤Strange text after block (missing semicolon or comma?)␤at /tmp/Uvtsq7XNgx:1␤------> 3o (Str $string) is export { $string.say}7⏏5 foo('bar')␤    expecting any of:␤        infix␤     …»

[09:39] <mrf> m: sub foo (Str $string) is export { $string.say }; foo('bar')

[09:39] <camelia> rakudo-moar 2856ed: OUTPUT«bar␤»

[09:39] <mrf> RabidGravy: Thanks

[09:40] <mrf> RabidGravy: How do I go about updating the is export docs to make that clear

[09:43] <RabidGravy> it's grab a fork of the https://github.com/perl6/doc and make a push request with the changes

[09:43] <mrf> RabidGravy++ 

[09:44] <RabidGravy> yeah the first example there doesn't even have an argument list so is rather ambiguous to say the list

[09:45] <dalek> Heuristic branch merge: pushed 43 commits to rakudo/curli by lizmat

[09:45] <lizmat> and good *, #perl6!

[09:45] <RabidGravy> "as with all traits, if applied to a routine, "is export" should be after the argyment list if one is present"

[09:46] <RabidGravy> yo lizmat

[09:46] <mrf> RabidGravy: is that your suggestion on the addition to the docs?

[09:46] *** AW3i left
[09:47] *** bjz joined
[09:47] *** brrt joined
[09:47] <RabidGravy> well and change the example, but them's my words I'm sure others would put it differently :)

[09:47] *** jkva joined
[09:48] *** softmoth joined
[09:49] <mrf> RabidGravy: They work for me as they also indicate that I should look at the Traits docs as well

[09:49] *** bjz_ left
[09:50] *** Gardner joined
[09:51] *** bjz_ joined
[09:51] *** SmokeMachine left
[09:51] *** SmokeMachine joined
[09:52] *** yeahnoob left
[09:53] *** softmoth left
[09:53] *** Actualeyes joined
[09:53] *** bjz left
[09:55] *** ely-se left
[09:56] <dalek> roast: 6170a80 | lizmat++ | S32-str/split.t:

[09:56] <dalek> roast: Correct test-count

[09:56] <dalek> roast: review: https://github.com/perl6/roast/commit/6170a806a9

[09:58] <mrf> Doc PR sent

[09:59] <dalek> doc: 19b81e8 | (Mike Francis)++ | doc/Language/modules.pod:

[09:59] <dalek> doc: Make clear that is export should appear after function args list

[09:59] <dalek> doc: review: https://github.com/perl6/doc/commit/19b81e8f70

[09:59] <dalek> doc: 459c66e | RabidGravy++ | doc/Language/modules.pod:

[09:59] <dalek> doc: Merge pull request #180 from ungrim97/master

[09:59] <dalek> doc: 

[09:59] <dalek> doc: Make clear that is export should appear after function args list

[09:59] <dalek> doc: review: https://github.com/perl6/doc/commit/459c66e1eb

[09:59] <mrf> :D ^ Makes my day :D

[09:59] <RabidGravy> :)

[09:59] *** ely-se joined
[10:00] <mrf> RabidGravy: Its always frustrating when your a newish programmer and you don't feel able to commit to projects. So its always awesome when you actually do get to

[10:01] <RabidGravy> yeah, this is relatively open in that respect and it's a good thing because all sorts of people can contribute in ways that they feel able to

[10:02] <mrf> exactly

[10:02] <RabidGravy> now back to doing stupid things with the language ;-)

[10:02] <mrf> lol

[10:04] <jnthn> morning, #perl6

[10:04] <RabidGravy> marnin

[10:08] <ely-se> hello jonathan

[10:08] <brrt> morning jnthn, RabidGravy, ely-se, mrf

[10:08] <RabidGravy> weeee!

[10:09] <timotimo> o/

[10:09] <brrt> also timotimo :-)

[10:09] *** espadrine_ left
[10:10] <ely-se> my IRC client does not highlight messages that contain "ely-se" and do not start with "ely-se"

[10:11] <ely-se> really weird

[10:11] <RabidGravy> that sucks, mind xchat will flash up a big notification, make sound  *and* highlight so it's a good thing I have a nick that's not a common word ;-)

[10:12] <mrf> morning jnthn 

[10:12] <mrf> morning brrt 

[10:12] <masak> evening, #perl6

[10:14] *** spider-mario joined
[10:14] <brrt> that is weird ely-se... all irc clients i ever used did that

[10:14] <brrt> which client is it

[10:15] <mrf> irssi has different settings for nick at start or in middle IIRC

[10:15] <ely-se> irssi

[10:17] <timotimo> right, there's "word highlights" and ... something else

[10:18] <RabidGravy> tadzik, the only thing about JSON::Unmarshal is that my stupid brane always wants to spell it unmarshall :-\

[10:18] *** g4 left
[10:18] <timotimo> you know what we could make perl6 do?

[10:18] *** g4 joined
[10:18] <timotimo> whenever a "did you mean" message appears, it could put a patch file into /tmp somewhere

[10:18] <lizmat> knit warm sweaters ?

[10:19] <timotimo> and then perl6 --apply-last-suggestion would apply that patch

[10:19] <timotimo> and re-run

[10:19] <lizmat> .oO( use auto-correct )

[10:19] <RabidGravy> timotimo++ # :)

[10:19] <timotimo> it should probably remember the PID of the "caller" of perl6, so that it will be per-shell-instance

[10:21] <timotimo> so ... who will implement that?

[10:21] <timotimo> i have a hunch that that'd be possible as a userspace module

[10:24] <tadzik> RabidGravy: I know the feeling :/

[10:24] <tadzik> RabidGravy: I would've thought about renaming it to ::Unpack, but renaming modules is not a very strong suite of mine :P

[10:24] *** FROGGS left
[10:24] <RabidGravy> :)

[10:26] *** ely-se left
[10:27] <dalek> rakudo/nom: 131af2c | lizmat++ | src/core/Str.pm:

[10:27] <dalek> rakudo/nom: Fix off-by-one error spotted by ShimmerFairy++

[10:27] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/131af2c5f7

[10:28] <lizmat> I'm getting slightly worried about one aspect of the GLR with regards to spectesting that we've possibly overlooked

[10:28] <jnthn> lizmat: Which one? :)

[10:29] <lizmat> a difference in test result when pull-one was used, or push-all, or push-exactly, or count-only

[10:30] <jnthn> BTW, from backlog: one of the assumptions of the GLR was that normal Perl 6 users will assign the results of operations that produce many results into @-sigil variables, not $-sigil ones, and those putting them into $-sigil ones would mostly be after the one-shot/pipeline semantics

[10:30] <jnthn> So if folks are hitting a lot of "already consumed", nudging them towards using @ in the appropriate places will often be helpful :)

[10:30] *** _mg_ left
[10:30] <lizmat> also, I have my doubts about the default implementation of bool-only

[10:30] <jnthn> lizmat: Ah, yes

[10:31] <jnthn> We have a bool-only? Hm :)

[10:31] <RabidGravy> tadzik, I'm wrapping it in a role for my own nefarious purposes so I won't have to type it that often ;-)

[10:31] <timotimo> the tool jnthn suggested for seeing what lines of the core setting get hit by roast

[10:31] <lizmat> yeah, I know, I invented it

[10:31] <jnthn> The things people do when I ain't watching... :P

[10:31] <lizmat> hehe

[10:32] <jnthn> But it's probably fine enough

[10:32] <lizmat> well, I either think we should force implementation of it

[10:32] <timotimo> you invented that "lines getting hit" or bool-only?

[10:32] <jnthn> I'd expect it to do pull-one and see if it gets IterationEnd or not, as a first guess

[10:32] <lizmat> or we should let it default to True

[10:32] <jnthn> Default to True sounds wrong...

[10:32] <lizmat> well, a pull-one, e.g. in the case of a grep, is no guarantee of a result 

[10:32] <timotimo> default do Die

[10:33] <lizmat> which would be the same as forcing to implement

[10:33] <jnthn> lizmat: Huh?

[10:33] <lizmat> default die is the same as forcing to implement ?

[10:33] <timotimo> default to True seems very wrong to me, too

[10:33] <jnthn> m: my \iter = <a b c>.grep(* eq 'b').iterator. say iter.pull-one

[10:33] <camelia> rakudo-moar 2856ed: OUTPUT«5===SORRY!5=== Error while compiling /tmp/y8ieOTLaa6␤Two terms in a row␤at /tmp/y8ieOTLaa6:1␤------> 3r = <a b c>.grep(* eq 'b').iterator. say7⏏5 iter.pull-one␤    expecting any of:␤        infix␤        infix stopper␤        postfi…»

[10:34] <jnthn> m: my \iter = <a b c>.grep(* eq 'b').iterator; say iter.pull-one

[10:34] <camelia> rakudo-moar 2856ed: OUTPUT«b␤»

[10:34] <jnthn> m: my \iter = <a b c>.grep(* eq 'd').iterator; say iter.pull-one =:= IterationEnd

[10:34] <camelia> rakudo-moar 2856ed: OUTPUT«True␤»

[10:34] <lizmat> ah, duh

[10:34] <jnthn> :)

[10:34] <lizmat> yes, ok

[10:34] <jnthn> (That's what the "huh" was about, btw)

[10:34] <lizmat> yeah, sorry, need more tea

[10:34] <jnthn> -1 to any more "forced" implementation besides pull-one, anyways :)

[10:34] <lizmat> ok, that's clear

[10:35] <jnthn> Waht does bool-only do now?

[10:35] <timotimo> that's fair

[10:35] <lizmat> pull one, if it's not IterationEnd, it's true

[10:35] <jnthn> OK, so what I thought. :) Where does that trip us up?

[10:35] <lizmat> well, it might set up a cache where there's none needed

[10:36] <lizmat> so, I would like to see bool-only be non-constructive, if you will  :-)

[10:36] <timotimo> you mean "destructive"?

[10:36] <lizmat> no, non-*con*structive

[10:36] <timotimo> oh

[10:36] <jnthn> Well, that's more a Seq-level decision, not an iterator API one

[10:37] <timotimo> right, because if you pull-one, you construct the first value

[10:37] <lizmat> yup

[10:37] <jnthn> Oh...you didn't mean destructive :)

[10:37] <timotimo> i thought destructive because that first value then gets unreachable

[10:37] <jnthn> yeah, me too :)

[10:37] <lizmat> ah, ok

[10:37] <timotimo> reminds me of "antonyms"

[10:37] <lizmat> that's another way of thinking about it: yes, in that view, non-destructive

[10:38] <jnthn> lizmat: Do you have any concrete situations where working out if we would produce a first element is massively cheaper than actually producing it?

[10:38] <lizmat> but we already make in non-destructive by caching it

[10:38] <timotimo> that's true

[10:38] *** kjs_ left
[10:38] <jnthn> I can't think of one off-hand...

[10:38] <lizmat> Str.split

[10:38] *** espadrine_ joined
[10:38] <jnthn> ah

[10:38] *** lolisa joined
[10:38] <lizmat> although that would probably not used often

[10:38] <jnthn> And is the current API not sufficient to just implement bool-only differently?

[10:39] <jnthn> (In the iterator for split)

[10:39] <lizmat> well, I could make a bool-only that doesn't call pull-one

[10:39] <lizmat> but I wouldn't be sure if that didn't set up the caching anyway ?

[10:39] <timotimo> i wonder if we want an iterator to have an attribute (/method) "can-cheaply-bool-only"

[10:40] <lizmat> anyways, just something that was on my mind

[10:40] <jnthn> timotimo: I prefer not; since the API here is mostly for improving performance, adding introspection isn't likely to help with that goal :)

[10:40] *** Alina-malina joined
[10:40] <jnthn> lizmat: What would set up caching? I don't think the caching actually causes any reification of elements right away anyway?

[10:41] <timotimo> that's fair

[10:42] <lizmat> jnthn: well, that's the thing, I'm not 100% sure, but it *is* another layer of indirection that may not be needed

[10:42] <lizmat> but, let me just put a stop on this right now: let it simmer more in my mind  :-)

[10:42] <jnthn> ok :)

[10:42] <lizmat> before I'm bothering you guys with it again  :)

[10:48] <ShimmerFairy> Would some kind of trait or pragma telling enums not to bother installing unqualified names be feasible at the moment? I tried using quietly { } earlier to at least suppress warnings, but that didn't work. (And besides, I don't want P6 to bother in the first place :P .)

[10:49] *** kjs_ joined
[10:50] <jnthn> ShimmerFairy: The logic to install them is in some action method in the compiler, iirc. So, not sure we can easily do that

[10:50] <jnthn> (at the moment)

[10:50] *** pdcawley joined
[10:52] <ShimmerFairy> Ah, so the only way atm would be if the core language gained the feature? Darn, I was actually kinda hoping to avoid suggesting that :P

[10:52] <timotimo> we'll just have enum and ENUM

[10:53] <ShimmerFairy> .oO( 'enum class' )

[10:58] *** kay_ joined
[11:08] *** espadrine_ is now known as espadrine

[11:12] *** ely-se joined
[11:14] <RabidGravy> I didn't know until just this minute that github created anchors for '#' headings when rendering a markdown as HTML

[11:15] *** TEttinger left
[11:16] *** MARTIMM left
[11:17] *** ely-se left
[11:22] *** andreoss joined
[11:26] *** _mg_ joined
[11:27] *** lucasb joined
[11:29] <andreoss> can i match text between pair of any matching parenthesis ?

[11:30] <timotimo> there's the ~ operator, but that has the extra effect that you're required to match the things in-between perfectly, otherwise an exception will be thrown

[11:30] <timotimo> so you can't rely on backtracking there

[11:30] <andreoss> <paren_open> % <paren_close> <text>

[11:30] <andreoss> <paren_open> ~ <paren_close> <text>

[11:31] *** brrt left
[11:31] <jnthn> You actually can rely on backtracking with it these days in a regex

[11:32] <jnthn> That changed earlier this year

[11:33] <timotimo> oh, OK

[11:35] *** kjs_ left
[11:36] *** kay_ left
[11:36] *** softmoth joined
[11:40] <lizmat> jnthn: looking at Iterable.flat, is there a reason it's not using IterationEnd ?

[11:40] *** jkva left
[11:41] *** softmoth left
[11:43] *** RabidGravy left
[11:46] <lizmat> jnthn: scratch that question

[11:47] <jnthn> :)

[11:48] *** tokuhiro_ joined
[11:49] *** ely-se joined
[11:49] <ShimmerFairy> I never use backtracking anyway, I'm quite used to specifying the stop conditions for a particular part of a match :P

[11:52] *** tokuhiro_ left
[11:56] *** jkva joined
[11:57] *** yakudza joined
[11:58] *** spider-mario left
[12:00] *** dayangkun_ left
[12:10] *** kjs_ joined
[12:19] *** xpen left
[12:21] *** kjs_ left
[12:25] *** duncan_dmg left
[12:25] *** duncan_dmg joined
[12:32] <lizmat> jnthn: I'm considering making sink-all default to { IterationEnd } and putting specific ones in places with side-effects

[12:32] <lizmat> opinion?

[12:33] <jnthn> That seems dangerous

[12:33] <jnthn> Missing side-effects that we should perform is bad

[12:33] <jnthn> Whereas doing pure work we shouldn't is just inefficient

[12:33] <lizmat> well, it *is* an efficiency consideration  :-)

[12:34] <jnthn> Yeah, but the idea is that people can achieve a *correct* iterator just my implementing pull-one.

[12:34] <jnthn> And they implement further methods to improve efficiency

[12:34] <lizmat> so you'd rather I put in sink-all { IterationEnd } in all classes that can use one ?

[12:34] <jnthn> Yes

[12:34] <lizmat> okidoki

[12:34] <jnthn> Also

[12:34] <jnthn> Some of them may warrant a warning

[12:34] <jnthn> m: 1..10

[12:34] <camelia> rakudo-moar 131af2: OUTPUT«WARNINGS:␤Useless use of ".." in expression "1..10" in sink context (line 1)␤»

[12:34] <jnthn> Ah, the optimizer gets that one

[12:34] <jnthn> m: (1..10).sink

[12:34] <camelia> rakudo-moar 131af2: OUTPUT«Method 'sink' not found for invocant of class 'Range'␤  in block <unit> at /tmp/MGpcM_isgq:1␤␤»

[12:34] <nine> optimizer++ :)

[12:34] <jnthn> m: (1..10).Sink

[12:34] <camelia> rakudo-moar 131af2: OUTPUT«Method 'Sink' not found for invocant of class 'Range'␤  in block <unit> at /tmp/k3GV6RfyHy:1␤␤»

[12:34] <lizmat> well, same for some push-all's I guess

[12:35] <jnthn> Heh :)

[12:35] *** _mg_ left
[12:35] <lizmat> like on ^Inf ?

[12:35] *** kmel_ left
[12:35] <lizmat> m: ^10 .sink-all

[12:35] <camelia> rakudo-moar 131af2: OUTPUT«Method 'sink-all' not found for invocant of class 'Range'␤  in block <unit> at /tmp/Ty0Z2PPXca:1␤␤»

[12:35] <lizmat> m: ^10 .iterator.sink-all

[12:35] <camelia> rakudo-moar 131af2: ( no output )

[12:35] <jnthn> Hm, I think I had that in the prototype

[12:35] <jnthn> Or maybe not

[12:35] <jnthn> Can't remember

[12:35] <jnthn> m: 1 xx 1

[12:35] <camelia> rakudo-moar 131af2: ( no output )

[12:36] <jnthn> Not sure. :)

[12:36] <jnthn> But yeah, we should make the defaults focus on correctness

[12:36] <jnthn> And let people override for improving performance.

[12:36] <jnthn> Fast and wrong isn't so useful :)

[12:36] <lizmat> ok

[12:37] <[Coke]> ShimmerFairy: please don't commit failing tests. (assuming 3185bb0 did that based on commit log)

[12:37] <jnthn> Well, not without fudging them...

[12:38] <nine> I for one would love to see an All tests successfull on a spectest once in a while

[12:38] <lizmat> [Coke]: FWIW, it pointed out something for me to fix this moarn

[12:38] <lizmat> All tests successful.

[12:38] <lizmat> Files=1063, Tests=48572, 234 wallclock secs (12.19 usr  3.45 sys + 1445.04 cusr 123.77 csys = 1584.45 CPU)

[12:38] <lizmat> nine: ^^^  :-)

[12:39] <jnthn> Gee, nearly 50,000 tests o.O

[12:44] <jnthn> lunch &

[12:47] <ShimmerFairy> [Coke]: I did it because 1) it was a recently-introduced bug that would've caused the test to fail if it had been there, and 2) I personally disagree with the extent to which rakudo fudges tests, and those new tests were included in that.

[12:48] *** Skarsnik joined
[12:49] *** lucasb left
[12:50] *** lucasb joined
[12:51] <[Coke]> Do not commit failing tests on purpose. Open an RT, and fudge it.

[12:51] <[Coke]> Unless you're commiting the patch that makes them run at the same time.

[12:52] <[Coke]> We need to keep roast clean.

[12:52] <nine> ShimmerFairy: those failing tests cost me a lot of time I waste on checking if failures are due to my changes or if they are in nom, too.

[12:53] <ShimmerFairy> [Coke]: I disagree; fudging to let test files run all the way through is fine, but I'm disturbed by the trend to insist on a "clean" run; aren't tests there to tell you about stuff that isn't doing the right thing?

[12:53] <ShimmerFairy> nine: that's why I always do a "before" test run, so I can compare to the "after" run :)

[12:54] <nine> ShimmerFairy: that's what everyone has to do if roast isn't kept clean. But I guess we have loads of developer time to spare.

[12:56] <[Coke]> ShimmerFairy: I can't believe I'm going to have to spend time explaining this, in addition to spending time cleaning up your commits.

[12:57] <ShimmerFairy> nine: there are lots of times I've had in the past where tests fail because of TEST_JOBS usage, or other reasons I don't know. So I guess part of the reason why I don't find it much of an issue is because I myself never trust roast to be "clean", for reasons beyond just "these tests should be fudged".

[12:58] <[Coke]> If there are jobs that fail under stress, those need to be ticketed and fixed. we are also bad about that, yes.

[12:59] <[Coke]> but every failing test that we leave out there means that we are less likely to notice when new tests start failing.

[12:59] *** tokuhiro_ joined
[12:59] <[Coke]> you make it harder on the release manager, who needs to be fudging these tests so that on release, our users don't get failing tests to run.

[13:00] <nine> lizmat: how do you do that? Right now I see the following test files failing: t/spec/S03-operators/autoincrement-range.t t/spec/S17-scheduler/at.rakudo.moar t/spec/S17-supply/throttle.t t/spec/S32-num/complex.t t/spec/S17-procasync/many-processes-no-close-stdin.t

[13:00] <lizmat> nine: they're all flaky somehow

[13:00] <lizmat> sometimes they're clean, mostly they're not

[13:01] *** duncan_dmg left
[13:01] <lizmat> in the above case, I *just* had a clean run for the first time today, so I thought I'd share that one when you said that you hadn't seen one in a while 

[13:02] <nine> lizmat: thanks! It's still a beautiful sight :)

[13:02] <lizmat> in my last run, 3 out of your set failed for me

[13:02] *** sufrostico joined
[13:03] <ShimmerFairy> .oO(by logic of the clean run, we apparently need an #?ok-to-fail fudge for the flaky tests. Can't have an unclean run that wasn't caused by your own changes, oh dear.)

[13:03] *** duncan_dmg joined
[13:03] <dalek> rakudo/nom: ba70274 | lizmat++ | src/core/Iterable.pm:

[13:03] <dalek> rakudo/nom: Put some iterator goodness in Iterable.flat

[13:03] <dalek> rakudo/nom: 

[13:03] <dalek> rakudo/nom: This should cause some performance gains in some places, hard to tell

[13:03] <dalek> rakudo/nom: where.

[13:03] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/ba7027461d

[13:05] <[Coke]> Yes, there is no fudge directive that handles the flapping tests. Snark aside, it's been a problem for years.

[13:05] <[Coke]> Please don't -add to the pile-.

[13:05] *** ely-se left
[13:07] <ShimmerFairy> [Coke]: I think part of my issue is that our current `prove` is quite black-n-white; it doesn't say "We passed the expected tests, but you're still SKIPping some" or "Good so far, but there's more TODO yet". It just claims "All test successful." when that ain't true.

[13:07] *** tokuhiro_ left
[13:07] <ShimmerFairy> Thus part of my issue is that I'm not a fan of lying about how well we're passing the spectests :)

[13:09] *** lolisa left
[13:09] <[Coke]> ShimmerFairy: that's why we have tools and reports that show you how many things are skipped and todo'd. and RT.

[13:09] <nine> ShimmerFairy: and who exactly is helped by those failing tests?

[13:09] <[Coke]> "Synopsis", "pass","fail","todo","skip","plan","spec"

[13:09] <[Coke]> "total",    120390,   312,   682,  1200,122584,121888

[13:10] <[Coke]> ^^ there's the last run of rakudo.moar with jit enabled, e.g.

[13:10] <ShimmerFairy> [Coke]: does our current `prove` show that? If not, I still contend that saying "All OK!" when that's not the case is just lying.

[13:10] <[Coke]> No, it's not prove.

[13:11] <ShimmerFairy> nine: The developers, since I'm pretty sure the point of TDD is to tell you when things are broken :P

[13:11] *** weihan joined
[13:12] *** tokuhirom_h joined
[13:13] <[Coke]> ShimmerFairy: I'm sorry you don't understand why we're doing it this way. Perhaps once I'm done going through and cleaning up roast, I'll take the time to write something up to explain it to you. in the meantime, please don't commit any more failing tests.

[13:13] <nine> ShimmerFairy: as a developer I feel not helped at all. Quite the opposite. I did miss regressions I caused because I thought those tests were already failing before.

[13:14] <[Coke]> Sorry that we haven't set a great example recently. There's a lot to do, and we appear to be spending some time on cleanup that I wish we didn't have to.

[13:15] <ShimmerFairy> [Coke]: I usually don't, fwiw. I did it in this case because I felt it was more helpful than hiding a new bug (esp. since the test also doesn't crash the rest of the file). Also, to split hairs a bit I hadn't updated my rakudo yet, so for my local copy they were passing :P

[13:16] *** weihan left
[13:16] <ShimmerFairy> nine: I get that, and it hints to me that the spectest could benefit from a different way of handling TDD (since NYI vs. "my bad" is more problematic with something like our roast/), but I have no clue what that even means :)

[13:17] *** weihan joined
[13:17] <[Coke]> obviously, your local copy doesn't matter to anyone who can't use it. you -are- hiding the new bug. Did you create an RT?

[13:17] <[Coke]> to sum up: you're not the only developer here.

[13:18] <moritz> note that roast is mostly used for regression tests, not unit testing

[13:19] <[Coke]> As fun as it's been, I have to get to $dayjob. I'll work on cleaning up roast more on my break. Adios.

[13:19] <ShimmerFairy> [Coke]: there's a reason why I didn't try using that as a serious argument, since I never believed it was one :)

[13:19] <moritz> and for regression tests it's essential to not show breakages that have nothing to do with the changes somebody is working on

[13:22] *** skids joined
[13:25] *** softmoth joined
[13:27] *** ely-se joined
[13:28] <psch> r: sub f ($) { }; f Junction # is this a reason to start testing exception messages again..?

[13:28] <camelia> rakudo-moar ba7027: OUTPUT«Type check failed in binding <anon>; expected Any but got Junction␤  in sub f at /tmp/tmpfile:1␤  in block <unit> at /tmp/tmpfile:1␤␤»

[13:28] <camelia> ..rakudo-jvm ba7027: OUTPUT«X::TypeCheck::Binding exception produced no message␤  in sub f at /tmp/tmpfile:1␤  in block <unit> at /tmp/tmpfile:1␤␤»

[13:29] *** softmoth left
[13:29] *** tokuhirom_h left
[13:30] <psch> well, in this particular case it's probably more a reason for me to continue working on it i suppose

[13:31] <skids> psch: It means that on jvm the X::TypeCheck::Binding's .message or .Str is not returning anything.

[13:31] <zostay> m: my $s = Supply.new; start { react { whenever { LAST { say "DONE" } } } }; $s.done;

[13:31] <camelia> rakudo-moar ba7027: OUTPUT«5===SORRY!5===␤Expression needs parens to avoid gobbling block␤at /tmp/OPPejwuTuZ:1␤------> 3react { whenever { LAST { say "DONE" } }7⏏5 } }; $s.done;␤Missing block (apparently taken by expression)␤at /tmp/OPPejwuTuZ:1␤------> 3eact …»

[13:31] <skids> I've seen some nasty exception loops on jvm where exceptions occur while building exceptions.

[13:31] <zostay> m: my $s = Supply.new; start { react { whenever $s { LAST { say "DONE" } } } }; $s.done;

[13:31] <camelia> rakudo-moar ba7027: ( no output )

[13:31] *** raiph joined
[13:32] <psch> skids: it probably means i'm doing the invocation of P6EX<X::TypeCheck::Binding> somewhat wrong, yeah

[13:32] <zostay> i thought the LAST phaser was triggered on done within react/supply/whenever, is that not the case?

[13:33] <skids> PR #479 mentions one place where you can aggravate such a loop if you are so inclined.

[13:33] <lizmat> zostay: not sure, jnthn might know

[13:34] <psch> skids: i've seen BUILD, BUILD-ALL, new => SOE loops as well a few times, but they seem to be on decline..

[13:34] <psch> skids: thanks, i'll have a look

[13:34] <jnthn> zostay: You've got a race condition there

[13:34] <jnthn> m: my $s = Supply.new; start { react { whenever $s { LAST { say "DONE" } } } }; sleep 1; $s.done

[13:34] <camelia> rakudo-moar ba7027: OUTPUT«DONE␤»

[13:34] <jnthn> zostay: $s is a live Supply, and you transmit the done before the whenever subscribes

[13:35] * jnthn ponders whether we should better handle such things for live supplies

[13:35] <jnthn> But that's the actual problem, not LAST failing to fire upon receicing a done.

[13:37] <zostay> ok, then my code using an on-demand supply probably has something else wrong with it that i incorrectly inferred from my little experiement there.. thx!

[13:37] <zostay> the react/supply/whenever stuff is awesome though, i really like it

[13:38] <jnthn> Me too; I want to write more stuff using it :)

[13:38] *** finanalyst joined
[13:38] <zostay> you're more than welcome to consider the problems of P6SGI, if you have any interest ;-)

[13:43] *** kjs_ joined
[13:44] <finanalyst> p6: my @files = ".".IO.dir(:test => /^^ .*\.pl $$/); @files.say;

[13:44] <camelia> rakudo-moar ba7027: OUTPUT«Too many positionals passed; expected 1 argument but got 2␤  in block <unit> at /tmp/tmpfile:1␤␤»

[13:44] <[Coke]> RT: 1029; XMAS: 66; LTA: 86; WEIRD: 11; NOM: 8; GLR: 6; TESTS: 10; JVM: 25

[13:46] <[Coke]> ah, that JVM might be 31. looks like we have tickets with [JVM] in the title that aren't marked with that VM.

[13:48] <jnthn> finanalyst: test => or :test(...)

[13:49] <[Coke]> r: constant m = month;

[13:49] <camelia> rakudo-jvm ba7027: OUTPUT«5===SORRY!5=== Error while compiling /tmp/tmpfile␤An exception occurred while evaluating a constant␤at /tmp/tmpfile:1␤Exception details:␤  5===SORRY!5=== Error while compiling ␤  Can not invoke object '&month'␤  at :␤»

[13:49] <camelia> ..rakudo-moar ba7027: OUTPUT«5===SORRY!5=== Error while compiling /tmp/tmpfile␤An exception occurred while evaluating a constant␤at /tmp/tmpfile:1␤Exception details:␤  5===SORRY!5=== Error while compiling ␤  Cannot invoke this object␤  at :␤»

[13:51] *** rindolf left
[13:51] <[Coke]> r: say "$($_ * $_ if $_ % 2 for 0..10)"

[13:51] <camelia> rakudo-moar ba7027: OUTPUT«1 9 25 49 81␤»

[13:51] <camelia> ..rakudo-jvm ba7027: OUTPUT«Use of Nil in string context  in block <unit> at /tmp/tmpfile:1␤␤»

[13:52] *** pkv left
[13:56] <lucasb> r: int.()

[13:56] <camelia> rakudo-moar ba7027: OUTPUT«Cannot invoke this object␤  in block <unit> at /tmp/tmpfile:1␤␤»

[13:56] <camelia> ..rakudo-jvm ba7027: OUTPUT«Can not invoke this object␤  in block <unit> at /tmp/tmpfile:1␤␤»

[13:56] <lucasb> ^^ one whitespace of difference

[13:56] <[Coke]> r: class Foo is repr<CStruct> { has int32 $.idontcare; has Foo $.bar }

[13:56] <camelia> rakudo-{moar,jvm} ba7027: ( no output )

[13:56] <[Coke]> r: class Foo is repr<CStruct> { has int32 $.idontcare; has Foo $.bar }; say "alive"

[13:56] <camelia> rakudo-{moar,jvm} ba7027: OUTPUT«alive␤»

[13:57] <[Coke]> r: class Foo is repr<CStruct> { has int32 $.idontcare; has Foo $.bar }; my $a = Foo.new; say 42;

[13:57] <camelia> rakudo-{moar,jvm} ba7027: OUTPUT«42␤»

[13:57] *** rindolf joined
[13:58] <[Coke]> r: my \T = ($_ for ^1); say T

[13:58] <camelia> rakudo-jvm ba7027: OUTPUT«Nil␤»

[13:58] <camelia> ..rakudo-moar ba7027: OUTPUT«(0)␤»

[14:00] *** RabidGravy joined
[14:00] <dalek> rakudo/curli: 45f457f | (Stefan Seifert)++ | src/core/CompUnit (2 files):

[14:00] <dalek> rakudo/curli: Bring back listing all repos in "Could not find" error messages

[14:00] <dalek> rakudo/curli: review: https://github.com/rakudo/rakudo/commit/45f457fcda

[14:05] <nine> jnthn: what's the plan for require $file-name? CompUnit::DependencySpecification doesn't have a $file member in your gist.

[14:05] *** tokuhirom_h joined
[14:05] <dalek> roast: 26b4dc8 | coke++ | S22-package-format/local.t:

[14:05] <dalek> roast: use merged ticket #

[14:05] <dalek> roast: review: https://github.com/perl6/roast/commit/26b4dc8f99

[14:06] <jnthn> nine: Does that need to go through the comp units at all?

[14:07] <jnthn> nine: And if so, I wonder how on earth we interpret it in the context of a CU:R:I

[14:07] *** aborazmeh left
[14:08] <dalek> roast: 5fc4c28 | coke++ | S16-filehandles/io.t:

[14:08] <dalek> roast: use merged ticket #

[14:08] <dalek> roast: review: https://github.com/perl6/roast/commit/5fc4c28ff4

[14:08] <jnthn> I could maybe live with the filename form of require just assuming it's been given a relative path to $*CWD or an absolute path.

[14:09] * jnthn wonders how much that's actually being used in the wild

[14:10] *** ely-se left
[14:10] <jnthn> DBIish uses require, but the name form, not the filename form.

[14:11] <jnthn> So it'd not be affected

[14:12] <PerlJam> Perhaps the wild isn't wild enough for people to really be using the filename form.  Once there's an influx of P5 programmers though, that's likely to increase.

[14:12] <jnthn> Well, yeah, I was mildly pondering if it's unused enough I can just say "nah, we don't do it in 6.c" and punt the issue :P

[14:12] <jnthn> That'd prevent use of it increasing too :P

[14:13] <PerlJam> yep

[14:13] <jnthn> So that'a also an option

[14:13] <jnthn> The other option would be to actually add another method to the CompUnit::Repository interface to cover this case

[14:14] <jnthn> And a CU::R::I could just say "no, I got nothing", and only a CU::R::FS would have much idea what to do about it

[14:15] <jnthn> Input welcome from anyone who is actually using require $file-name in Perl 6, anyways.

[14:15] <finanalyst> jnthn: thanks.

[14:18] <lizmat> m: my @a = "z" .. ^"a"    # huh ?

[14:18] <camelia> rakudo-moar ba7027: OUTPUT«X::Multi::NoMatch exception produced no message␤  in block <unit> at /tmp/K54hx3C758:1␤␤»

[14:18] *** softmoth joined
[14:18] <lizmat> m: my @a = "z" .. ^"a" ; dd @a

[14:18] <camelia> rakudo-moar ba7027: OUTPUT«X::Multi::NoMatch exception produced no message␤  in block <unit> at /tmp/96zpt0hnPb:1␤␤»

[14:19] *** ely-se joined
[14:19] <jnthn> lizmat: Looks like an error reporting bustage

[14:19] <lizmat> yeah... oddly enough, there's a test for it that doesn't fail

[14:20] <psch> lizmat: probably because we don't test exception messages, but type (mostly)

[14:20] *** tokuhirom left
[14:20] <lizmat> m: use Test; is ["z"..^"a"], []

[14:20] <camelia> rakudo-moar ba7027: OUTPUT«ok 1 - ␤»

[14:20] <lizmat> :-(

[14:21] <jnthn> Whtiesapce!

[14:21] <jnthn> m: say "z"..^"a"

[14:21] <camelia> rakudo-moar ba7027: OUTPUT«"z"..^"a"␤»

[14:21] <psch> oh

[14:21] <jnthn> m: say "z" ..^ "a"

[14:21] <camelia> rakudo-moar ba7027: OUTPUT«"z"..^"a"␤»

[14:21] <jnthn> m: say "z" .. ^"a"

[14:21] <camelia> rakudo-moar ba7027: OUTPUT«X::Multi::NoMatch exception produced no message␤  in block <unit> at /tmp/3y7e5TjftK:1␤␤»

[14:21] <psch> m: my @a = "z" ..\ ^"a"

[14:21] <camelia> rakudo-moar ba7027: OUTPUT«X::Multi::NoMatch exception produced no message␤  in block <unit> at /tmp/9XKGraO_VE:1␤␤»

[14:21] * psch .oO( "You can't unspace that" )

[14:21] <jnthn> Well, \ is a kind of whitespace :)

[14:22] * PerlJam is always typing $:foo when he wants a named parameter in a sig and the compiler always calls me out on it :-)

[14:22] <PerlJam> rakudo++

[14:22] <jnthn> m: sub foo($:foo) { }

[14:22] <camelia> rakudo-moar ba7027: OUTPUT«5===SORRY!5=== Error while compiling /tmp/4rIx7uVQgJ␤In signature parameter, placeholder variables like $:foo are illegal␤you probably meant a named parameter: ':$foo'␤at /tmp/4rIx7uVQgJ:1␤------> 3sub foo($:foo7⏏5) { }␤    expecting an…»

[14:22] <jnthn> cute :)

[14:22] <psch> m: ({ say $:a.perl })(:a("foo"))

[14:22] <camelia> rakudo-moar ba7027: OUTPUT«"foo"␤»

[14:23] <psch> i wasn't aware, but i'm glad that guessing worked :P

[14:24] <PerlJam> That's a hallmark of good design when you can guess at something you think should be there and you guess correctly  (IMHO)

[14:25] <timotimo> jnthn: could you outline what could/should be done where to make NativeCall more friendly to spesh and the jit?

[14:28] <nine> jnthn: I guess the require $file-name would mostly be used for something like Module::Pluggable where you just load a directory's contents

[14:28] <timotimo> it's probably a bit more than i can comfortably chew, though :\

[14:29] *** _mg_ joined
[14:30] <andreoss> m: class Foo { has %.h ; multi method add(Pair $x) { %.h ,= $x } } ; my $f = Foo.new; say $f.add(:a(2)) 

[14:30] <camelia> rakudo-moar ba7027: OUTPUT«Cannot call add(Foo: Int); none of these signatures match:␤    (Foo $: Pair $x, *%_)␤  in block <unit> at /tmp/MFkys_jHEm:1␤␤»

[14:31] <andreoss> m: class Foo { has %.h ; multi method add(Pair $x) { %.h ,= $x } } ; my $f = Foo.new; say $f.add: (:a(2)) 

[14:31] <camelia> rakudo-moar ba7027: OUTPUT«Cannot assign to an immutable value␤  in method add at /tmp/vce2xu6mCQ:1␤  in block <unit> at /tmp/vce2xu6mCQ:1␤␤»

[14:33] *** _mg_ left
[14:33] <dalek> rakudo/nom: e80eb1d | peschwa++ | src/vm/jvm/runtime/org/perl6/rakudo/Binder.java:

[14:33] <dalek> rakudo/nom: Correctly deal with anons when failing a binding type check.

[14:33] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/e80eb1deca

[14:33] <jnthn> timotimo: I didn't really figure out a good path on that yet, tbh.

[14:34] <timotimo> mhh

[14:35] <timotimo> it seems kind of like it's counterproductive to have a single method that handles every native call; similar to how we have a single method that gets used for every attribute access

[14:36] <jnthn> Indeed

[14:36] <jnthn> Well, the latter is easier to fix :)

[14:36] <masak> PerlJam: re "hallmark of good design" -- I guess it's the flip side of "make it easy for people to unintentionally do the right thing" (aka "Pit of Success"). if you realize this strongly enough on the design end of things, you will engineer for that to be possible, kind of.

[14:36] <timotimo> right; we had an idea (but not yet a design IIRC) for having some piece of rakudo code-gen attribute accessors for us

[14:37] <jnthn> aye

[14:38] <timotimo> ah, something I still had a "problem" with was that every time we invoke the compiler, we'll be getting a separate CompUnit, is that right?

[14:38] <PerlJam> masak: yes, kind of.

[14:39] <timotimo> i suppose that could be cut down to a single CompUnit for each class that gets attribute accessors generated

[14:39] <jnthn> Yeah, which means we needed to really find a way to use the currently executing compiler to ehlp us

[14:39] <PerlJam> masak: for instance, I think Matz got a free lunch there in some sense because when I was using Ruby and didn't know how to do something, I approached the problem with "How would I do this in Perl?"  and that, more often than not, led me down the right path.

[14:40] <masak> :)

[14:42] <masak> S04:46

[14:42] <masak> synbot6: chicken!

[14:42] *** synbot6 joined
[14:42] <PerlJam> S04:46

[14:42] *** synbot6 left
[14:42] <PerlJam> neat

[14:42] <masak> spec.perl6.org is still broken -- should probably redirect to design.perl6.org

[14:44] <psch> i'm confused

[14:45] <psch> the 4 in <4++> arrives in the binder as IntLexRef, which is an rw cont

[14:45] <psch> (at least isrwcont says it is)

[14:46] <jnthn> o.O

[14:46] <jnthn> m: 4++

[14:46] <camelia> rakudo-moar ba7027: OUTPUT«Parameter '$a' expected a writable container, but got Int value␤  in block <unit> at /tmp/ZOxglPVSEv:1␤␤»

[14:46] <psch> j: 4++

[14:46] <camelia> rakudo-jvm ba7027: OUTPUT«Expected a native int argument for '$a'␤  in block <unit> at /tmp/M9ELmzdoGe:1␤␤»

[14:46] <andreoss> can i have a method which accepts any number of pairs? Using hash requires extra { }  wraping. 

[14:46] <psch> ^^^ that's the earlier failure mode

[14:47] <psch> j: multi f (Int:D: $a is rw) { "Int" }; multi f (int $a is rw) { "int }; say f 4 # this also confuses me

[14:47] *** ely-se left
[14:47] <camelia> rakudo-jvm ba7027: OUTPUT«5===SORRY!5=== Error while compiling /tmp/v_2iI_2nws␤Unable to parse expression in double quotes; couldn't find final '"' ␤at /tmp/v_2iI_2nws:1␤------> 3 "int }; say f 4 # this also confuses me7⏏5<EOL>␤    expecting any of:␤        doubl…»

[14:47] <psch> j: multi f (Int:D: $a is rw) { "Int" }; multi f (int $a is rw) { "int" }; say f 4 # this also confuses me

[14:47] <camelia> rakudo-jvm ba7027: OUTPUT«int␤»

[14:47] <psch> m: multi f (Int:D: $a is rw) { "Int" }; multi f (int $a is rw) { "int" }; say f 4 # this also confuses me

[14:47] <camelia> rakudo-moar ba7027: OUTPUT«int␤»

[14:47] <andreoss> may be catch pairs in hash without considering them as named arguments

[14:47] <psch> jnthn: so, in my understand, moar shouldn't actually throw the error it throws, because the gotNative and is_rw logic is identical between the backends...

[14:48] <psch> in the corresponding binder at least

[14:48] <lizmat> m: sub a(*@a) { my % = @a }; dd a (a=>42, b=>666)   # andreoss 

[14:48] <camelia> rakudo-moar ba7027: OUTPUT«Hash $var = {:a(42), :b(666)}␤»

[14:48] <jnthn> psch: 4 is not rw, so the error you get is reasonable

[14:48] <jnthn> (from Moar)

[14:48] *** khw joined
[14:49] <psch> jnthn: right, i'll rephrase as "i don't understand how moar can throw this error" 

[14:49] <psch> because as mentioned, the checking logic for gotNative and is_rw on both backends is identical

[14:49] <jnthn> psch: uhh...something's really not right on Moar

[14:49] <jnthn> m: multi f (int $a is rw) { "int" }; say f 4

[14:49] <camelia> rakudo-moar ba7027: OUTPUT«int␤»

[14:50] <jnthn> m: multi f (int $a is rw) { $a = $a + 1 }; say f 4

[14:50] <camelia> rakudo-moar ba7027: OUTPUT«Cannot call f(Int); none of these signatures match:␤    (int $a is rw)␤  in block <unit> at /tmp/vmcmRkwC8w:1␤␤»

[14:50] <psch> uh

[14:50] <psch> inlining?

[14:50] <jnthn> Oh damn, I get the static inlining is ignoring that "is rw" constraint

[14:50] <jnthn> *bet

[14:50] <jnthn> Yeah, that's a bug alright

[14:50] <psch> heh

[14:51] <psch> who woulda thunk working on r-j shows moar bugs :P

[14:52] <RabidGravy> is there an established method for exporting a sub with a different name? Or is it provide an EXPORT and insert the new name as the original named sub

[14:53] <PerlJam> m: my $s;  $s ~~ s/foo//;  

[14:53] <camelia> rakudo-moar ba7027: OUTPUT«Method 'match' not found for invocant of class 'Any'␤  in block <unit> at /tmp/XtLJ6Xe9Kl:1␤␤»

[14:53] <jnthn> There's a few ways: BEGIN EXPORT::DEFAULT::<&new-name> := &old-name; or an EXPORT sub

[14:54] <RabidGravy> i.e. I have modules that exports sub foo, but want to be able to say "use Foo :less-classy-names" and export the names with some prefix

[14:54] <RabidGravy> clashy

[14:56] <jnthn> heh

[14:57] <jnthn> .oO( sub piquant() { }; BEGIN EXPORT::DEFAULT::<&bloody-tasty> = &piquant; )

[14:57] <RabidGravy> :)

[14:57] <andreoss> m: sub a(*@a) { my % = @a }; dd a ('?'=>42, '*'=>666);

[14:57] <camelia> rakudo-moar e80eb1: OUTPUT«Hash $var = {"*" => 666, "?" => 42}␤»

[14:57] <andreoss> m: sub a(*@a) { my % = @a }; dd a '?'=>42, '*'=>666;

[14:57] <camelia> rakudo-moar e80eb1: OUTPUT«Hash $var = {"*" => 666, "?" => 42}␤»

[14:57] * masak uses `fail X::SomeCustomException.new` for the first time and likes it

[14:58] <andreoss> http://paste.debian.net/318872/

[14:58] <andreoss> probably it doesn't work with methods

[14:59] <RabidGravy> jnthn, you are so much more delicate than I would be ;-) 

[15:00] <psch> jnthn: that inlining bug does have consequences for the binder, right?

[15:00] <andreoss> http://paste.debian.net/318874/ why the latter doesnt work?

[15:00] *** azawawi joined
[15:01] <azawawi> hi

[15:01] <yoleaux> 29 Oct 2015 15:38Z <pippo> azawawi: Is there a way to tell Selenium::Webdriver::Firefox not to look for the prefs.json in the subdir it is executed from?

[15:01] <psch> jnthn: oh, maybe not.  trialBind isn't for subs, is it..?

[15:01] *** colomon left
[15:03] <dalek> rakudo/nom: 5b3247a | lizmat++ | src/core/Range.pm:

[15:03] <dalek> rakudo/nom: Add some more Iterator goodness to Range

[15:03] <dalek> rakudo/nom: 

[15:03] <dalek> rakudo/nom: Specifically the single character string ranges are now 15x (pull-one)

[15:03] <dalek> rakudo/nom: to 25x (push-all) faster.

[15:03] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/5b3247a435

[15:03] *** colomon joined
[15:04] *** ecocode left
[15:04] <jnthn> psch: We only inline subs statically

[15:04] <jnthn> So yeah, it is for them

[15:06] <psch> jnthn: oh, right, i had it the wrong time around.  trialBind is "see if we can figure this out at compile time", not "try if it works during runtime"

[15:06] <psch> s/time/way/

[15:07] <jnthn> psch: aye

[15:07] <timotimo> jnthn: you know, we could actually just pretend we'd parsed a bunch of attribute methods when we see a class' final }

[15:07] <timotimo> as in: we could do that in the actions

[15:08] <timotimo> that'll give us "use the current compiler" for free, at least

[15:08] <timotimo> it'll also give us weird line numbers when errors happen i suppose

[15:08] <azawawi> lizmat: hi

[15:08] <timotimo> heyo azawawi 

[15:09] <azawawi> timotimo: hey

[15:09] <azawawi> lizmat: re "panda will use what rakudo provides", please see https://github.com/tadzik/panda/issues/112

[15:10] <azawawi> basically panda on windows is broken

[15:11] <andreoss> m: class F { method add(*%h) { %h.perl.say  }}; my Foo $f .=new;  $f.add: 'a'=>1;

[15:11] <camelia> rakudo-moar e80eb1: OUTPUT«5===SORRY!5===␤Type 'Foo' is not declared␤at /tmp/_4yd39GDDq:1␤------> 3ethod add(*%h) { %h.perl.say  }}; my Foo7⏏5 $f .=new;  $f.add: 'a'=>1;␤Malformed my␤at /tmp/_4yd39GDDq:1␤------> 3 { method add(*%h) { %h.perl.say  }}; my7⏏5…»

[15:11] <andreoss> m: class F { method add(*%h) { %h.perl.say  }}; my F $f .=new;  $f.add: 'a'=>1;

[15:11] <camelia> rakudo-moar e80eb1: OUTPUT«Too many positionals passed; expected 1 argument but got 2␤  in method add at /tmp/2EAd2J_3tF:1␤  in block <unit> at /tmp/2EAd2J_3tF:1␤␤»

[15:11] <azawawi> https://github.com/tadzik/panda/blob/master/lib/Panda/Installer.pm#L41  # $to.can('install') is False

[15:11] <andreoss> m: class F { method add(*%h) { %h.perl.say  }}; my F $f .=new;  $f.add: a=>1;

[15:11] <camelia> rakudo-moar e80eb1: OUTPUT«{:a(1)}␤»

[15:11] <andreoss> why?

[15:12] <lizmat> azawawi: I'm sorry to hear that, but I don't think that will be fixed until the curli branch lands

[15:12] *** ely-se joined
[15:13] <azawawi> lizmat: not a big deal but i was hoping to use rakudo at work to run selenium test suites/cases

[15:13] <azawawi> lizmat: now i have to convert it to Java instead of Perl 6...

[15:13] <lizmat> :-(

[15:14] *** rabie joined
[15:14] <azawawi> after looking at selenium bindings

[15:14] <nine> rabie: hi!

[15:14] <rabie> hi 

[15:14] <timotimo> azawawi: can you try installing with Zef instead of panda?

[15:14] <azawawi> timotimo: interesting, i will try it tomorrow

[15:15] <azawawi> on windows; python, ruby and Java selenium bindings work out of the box

[15:16] <azawawi> along with Perl

[15:16] <azawawi> i was hoping Perl 6 support to be like that

[15:16] *** rabie left
[15:16] *** rabie joined
[15:16] <azawawi> windows is a platform you would like to ignore but simply cant

[15:17] *** rabie left
[15:17] *** rabie joined
[15:17] *** rabie left
[15:18] *** rabie joined
[15:19] *** Actualeyes left
[15:19] <rabie> hi stefn

[15:20] *** rabie left
[15:20] *** tokuhirom_h left
[15:21] *** tokuhirom joined
[15:25] *** tokuhirom left
[15:28] <andreoss> m: class F { method add(*%h) { %h.perl.say  }}; my F $f .=new;  $f.add: :a(1);

[15:28] <camelia> rakudo-moar 5b3247: OUTPUT«{:a(1)}␤»

[15:29] <azawawi> .tell pippo I just fixed it in https://github.com/azawawi/perl6-selenium-webdriver/issues/9 . Thanks for your report. Please reopen if it does not work for you.

[15:29] <yoleaux> azawawi: I'll pass your message to pippo.

[15:29] <andreoss> m: my $a="a"; class F { method add(*%h) { %h.perl.say  }}; my F $f .=new;  $f.add: $a => 1;

[15:29] <camelia> rakudo-moar 5b3247: OUTPUT«Too many positionals passed; expected 1 argument but got 2␤  in method add at /tmp/zljtufkGK7:1␤  in block <unit> at /tmp/zljtufkGK7:1␤␤»

[15:29] * azawawi misses FindBin

[15:30] <ugexe> zef does work on windows

[15:30] <timotimo> of course it does

[15:30] <azawawi> ugexe: cool

[15:31] <azawawi> panda used to work until they removed .bat boilerplate

[15:31] <lizmat> m: say $*EXECUTABLE   # azawawi: you mean this ?

[15:31] <camelia> rakudo-moar 5b3247: OUTPUT«"./rakudo-inst/bin/perl6-m".IO␤»

[15:31] <lizmat> m: say $*EXECUTABLE-NAME   # or this?

[15:31] <camelia> rakudo-moar 5b3247: OUTPUT«perl6-m␤»

[15:31] <nine> For those curious: rabie is a Syrian refugee now living in Austria. He was studying CS in Syria and until he's granted asylum, he's not allowed to work. So while he's poor in posessions, he's rich in time. So I figured, I get him an old company laptop so he can get into coding again and tell him that Perl 6 is fun. So we may see him around here more often :) 

[15:32] <lizmat> .tell rabie welcome!

[15:32] <yoleaux> lizmat: I'll pass your message to rabie.

[15:32] <PerlJam> nine++

[15:32] <jnthn> nine++

[15:32] <azawawi> nine++

[15:33] <ilmari> nine++

[15:33] <ilmari> rabie++

[15:34] <azawawi> lizmat: yes along with finding resources in my module lib folders

[15:35] <timotimo> nine: very cool

[15:35] <azawawi> lizmat: like this https://github.com/azawawi/perl6-selenium-webdriver/blob/master/lib/Selenium/WebDriver/Firefox.pm6#L20

[15:36] <lizmat> https://github.com/retupmoca/P6-Find-Bundled   # something for azawawi perhaps ?

[15:37] *** weihan left
[15:37] *** MadcapJake left
[15:38] *** raiph left
[15:40] <azawawi> lizmat: thanks... Find::Bundled.find('webdriver.xpi', 'Selenium/WebDriver/Firefox/extension'); # works, although :keep-filename throws a permission exception

[15:40] <lizmat> azawawi: you will have to take that up with Andrew Egeler  :-)   or make a PR  :-)

[15:41] <azawawi> lizmat++

[15:41] <retupmoca> azawawi: :keep-filename tries to copy it to a temporary folder

[15:42] <retupmoca> right now I think you can leave that off, because we aren't using the 'store in a database with numbers as filenames' thing right now

[15:42] *** AlexDaniel joined
[15:42] <retupmoca> so the filename *should* be correct anyway

[15:43] <retupmoca> but I had to do that with bundled .dll files, because panda install would completely remove the filename, and windows doesn't like loading dll files named '37' :P

[15:43] <azawawi> retupmoca: it was so revolutionary thinking into the future that it failed :)

[15:44] <retupmoca> something like that :)

[15:44] <retupmoca> lizmat: that's something to think about for module database discussions in the future as well though - I'd rather not have to copy to a temp directory if I really need the original filename on disk

[15:45] <retupmoca> (with .dll files it's a bit of a security issue as well)

[15:45] <lizmat> azawawi: wasn't that a matter of not having the right extension, though ?

[15:46] <retupmoca> that may be - I know the extension straight up broke it

[15:46] <retupmoca> but I don't recall if there was an issue with the filename itself

[15:47] <lizmat> Another one!  Files=1063, Tests=48572, 248 wallclock secs (12.45 usr  3.52 sys + 1486.57 cusr 129.02 csys = 1631.56 CPU)

[15:47] *** gtodd joined
[15:47] <azawawi> lizmat: well it broke farabi6 badly for a while :)

[15:48] <dalek> rakudo/nom: 2b278e8 | lizmat++ | src/core/Range.pm:

[15:48] <dalek> rakudo/nom: Fix performance regression on multi-char ranges

[15:48] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/2b278e85cc

[15:49] <lizmat> FWIW, "aa" .. "zz" still suck major performance wise, but I see no easy fix

[15:49] <gtodd> how does one specifiy an input record separator in perl6 ?  I know it has sensible standard default :-)  but is it possible to set it to an arbitrary value to read data  or does one take a more sane approach to that?

[15:50] <lizmat> gtodd: you can use IO.open.split() now

[15:50] <lizmat> it will take regexes also

[15:51] <lizmat> jnthn probably will be working on getting any arbitrary string as a separator in next week

[15:51] <gtodd> ah ok ... good so there will be no proliferation of switches or special values ... you just tell perl6 what to do

[15:51] <gtodd> oh

[15:51] <lizmat> well, in the case of split: yes

[15:51] <jnthn> You can already do single char custom separator by setting nl on the handle, and I think as a named arg to open

[15:52] <jnthn> It's multi-char separators that aren't yet handled

[15:52] <lizmat> yes, you can...  but the default :chomp won't do what you want

[15:52] <jnthn> Oh, and that

[15:52] <psch> m: $*IN.nl = " "; .say for $*IN.lines

[15:52] <camelia> rakudo-moar 5b3247: OUTPUT«Céad ␤slán ␤ag ␤sléibhte ␤maorga ␤Chontae ␤Dhún ␤na ␤nGall␤Agus ␤dhá ␤chéad ␤slán ␤ag ␤an ␤Eireagal ␤ard ␤ina ␤stua ␤os ␤cionn ␤caor ␤is ␤coll;␤Nuair ␤a ␤ghluais ␤mise ␤thart ␤le ␤Loch ␤D…»

[15:52] <jnthn> Yeah. "next week" :)

[15:52] <gtodd> heheh great ... maybe there could be a switch  for one liners :-) 

[15:52] <lizmat> so it only makes sense if you also do :!chomp

[15:52] <dalek> doc: 1c79231 | (Zoffix Znet)++ | html/css/style.css:

[15:52] <dalek> doc: Set off <code> from regular text

[15:52] <dalek> doc: 

[15:52] <dalek> doc: Font family change alone is hard to spot, which makes the text harder to read when dealing with word-like <code></code> bits (e.g. "has", "keep", "result")

[15:52] <dalek> doc: review: https://github.com/perl6/doc/commit/1c792318f4

[15:52] <psch> so .chom doesn't honor Handle.nl?

[15:52] <psch> +p

[15:53] <lizmat> psch: not at the moment

[15:53] <jnthn> It can't really, it's a method on Str, and a Str has no idea where it came from

[15:53] <lizmat> if you need that *now*, look at IO::Handle.split

[15:53] <gtodd> chomping and separating on the same thing is .... consisten

[15:53] <gtodd> +t

[15:53] <jnthn> It's more that IO::Handle.lines even using Str.chomp is the wrong thing

[15:53] <lizmat> yes, and we're working on it 

[15:53] <jnthn> (Yes, will deal with that next week)

[15:55] <azawawi> retupmoca: thanks... used Find::Bundled in my selenium module :) retupmoca++

[15:56] <retupmoca> azawawi++ # for making a selenium module

[15:58] *** _mg_ joined
[15:58] <andreoss> m: my $a="a"; class F { method add(*@x) { @x.perl.say  }}; my F $f .=new;  $f.add: $a => 1;

[15:58] <camelia> rakudo-moar 5b3247: OUTPUT«[:a(1)]␤»

[15:58] <andreoss> m: my $a="a"; class F { method add(*@x) { @x.perl.say  }}; my F $f .=new;  $f.add: $a => 1, z => 10;

[15:58] <camelia> rakudo-moar 5b3247: OUTPUT«[:a(1)]␤»

[15:58] <andreoss> how can i capture :z too?

[15:59] *** kjs_ left
[15:59] <andreoss> m: my $a="a"; class F { method add(*%x) { %x.perl.say  }}; my F $f .=new;  $f.add: $a => 1, z => 10;

[15:59] <camelia> rakudo-moar 5b3247: OUTPUT«Too many positionals passed; expected 1 argument but got 2␤  in method add at /tmp/inMULRR7iP:1␤  in block <unit> at /tmp/inMULRR7iP:1␤␤»

[15:59] <gtodd> lizmat: was thinking about how perl5 splits using $RS or $/ or $INPUT_RECORD_SPEARATOR ... i.e split on empty lines and print the 4th record:  perl -00 -nE 'chomp; push @_, $_ ;}{ say $_[3]'

[16:00] *** ely-se left
[16:00] *** uruwi joined
[16:00] <gtodd> lizmat: versus akw :-D   awk -v RS= 'NR==4' 

[16:00] <uruwi> こんにちは

[16:00] <gtodd> errm awk

[16:01] <lizmat> gtodd: you mean, split on "\n\n" ?

[16:01] *** atweiden joined
[16:01] <gtodd> yes ... since the awk seems more readable *and* shorter I was wondering how perl6 would stack up

[16:02] <gtodd> not shorter (than awk anyway) but maybe more readable to rank beginners than perl5

[16:02] <psch> fwiw, -n'...}{...' is one of the weirdest one-liner hacks in p5, in my opinion...

[16:02] <psch> i mean, i get it but still

[16:03] <gtodd> psch: butterfly :-*

[16:03] <psch> »ö« is a butterfly :P

[16:03] <lizmat> $handle.split("\n\n")[3] should do it ?

[16:03] <gtodd> psch: famous people (like mst ?) say you should just use END { }   for clarity

[16:04] <lucasb> is that the eskimo kiss operator?

[16:04] <gtodd> lizmat: cool

[16:04] <masak> uruwi: こんにちは!

[16:04] <gtodd> lucasb: I think it is now known as the butterfly

[16:04] <andreoss> m: class F { method add(|z) { z.Hash.perl.say  }}; my F $f .=new; say $f.add: 'a' => 1, z => 10;

[16:04] <camelia> rakudo-moar 5b3247: OUTPUT«Memory allocation failed; could not allocate 640 bytes␤»

[16:04] <andreoss> bug?

[16:04] <gtodd> but that was before perl6 took the butterfly :-D

[16:04] *** _mg_ left
[16:05] <uruwi> Still waiting for ö to be an operator so »ö« can be used as an application of a hyper

[16:05] <masak> andreoss: looks like a bug, yes.

[16:06] <gtodd> uruwi:  cool idea

[16:06] <gtodd> uruwi:  :-D it would have to do something very special

[16:07] <TimToady> some kind of special function composition

[16:07] <azawawi> retupmoca: is this README.md worth a PR https://github.com/azawawi/P6-Compress-Zlib ? :)

[16:08] <uruwi> Kliesli?

[16:08] <jnthn> m: my $a="a"; class F { method add(*@p, *%x) { %x.push(@p); %x.perl.say  }}; my F $f .=new;  $f.add: $a => 1, z => 10;

[16:08] <camelia> rakudo-moar 5b3247: OUTPUT«{:a(1), :z(10)}␤»

[16:08] <jnthn> andreoss: ^^

[16:09] <retupmoca> azawawi: better docs are *always* worth a PR!

[16:09] <azawawi> retupmoca: then it is submitted... :)

[16:10] <retupmoca> azawawi: and merged :)

[16:10] <hoelzro> o/ #perl6

[16:10] <retupmoca> azawawi++

[16:10] *** sufrostico left
[16:10] <gtodd> lizmat: thanks ... was reading sort of discussion/response that compares regexes versus grammars (no perl6 example yet) where there is a little awk one-liner that looks so cute :-)  http://stackoverflow.com/q/33355952/2019415   perl6 is going to be the grammar master but I hope it can be a bit cute like awk too ...

[16:11] <azawawi> retupmoca: thx

[16:11] <dalek> doc: bb25905 | (Zoffix Znet)++ | doc/Language/classtut.pod:

[16:11] <dalek> doc: Fix typo

[16:11] <dalek> doc: review: https://github.com/perl6/doc/commit/bb25905bc2

[16:11] <dalek> doc: 56a4274 | (Zoffix Znet)++ | doc/Language/classtut.pod:

[16:11] <dalek> doc: Reword to avoid . twigil right before a period

[16:11] <dalek> doc: review: https://github.com/perl6/doc/commit/56a4274b07

[16:12] <azawawi> retupmoca: the header P6-Compress-Zlib was the real reason... it bugged me a lot... especially the "P6" :)

[16:12] *** diana_olhovik_ left
[16:12] <lucasb> m: Capture.new.Hash

[16:12] <camelia> rakudo-moar 5b3247: OUTPUT«Memory allocation failed; could not allocate 640 bytes␤»

[16:12] <timotimo> this memory allocation failed thing is usually a stack overflow

[16:12] <timotimo> like, an infinite recursion

[16:12] <lizmat> m: Capture.new

[16:12] <camelia> rakudo-moar 5b3247: ( no output )

[16:13] <gtodd> TimToady:  it would be the only language where the official emoticon would be "functional" as part of the language ... so then I guess  »ö« should "definitely not" be an easter egg  :-D

[16:14] *** andreoss left
[16:14] <azawawi> ugexe: i will try tomorrow Zef on windows to work on the IE selenium driver and maybe the ms edge once i get a windows 10 vm instance installed

[16:15] <timotimo> m: sub infix:<ö>($a, $b) { $a + $b }; say (1, 2, 3) »ö« (9, 9, 9)

[16:15] <camelia> rakudo-moar 5b3247: OUTPUT«(10 11 12)␤»

[16:15] * azawawi good night &

[16:15] <ugexe> azawawi: cool, if you have any problems let me know and i'll try and fix them promptly

[16:16] <azawawi> ugexe: cool thx

[16:16] <azawawi> cya

[16:16] *** azawawi left
[16:18] *** rangerprice joined
[16:22] *** sufrostico joined
[16:23] <lucasb> m: Map.Hash

[16:23] <camelia> rakudo-moar 5b3247: OUTPUT«Memory allocation failed; could not allocate 640 bytes␤»

[16:23] <lucasb> yep, this is those kind of infinite method invocation

[16:25] *** andreoss joined
[16:25] *** g4 left
[16:27] <rangerprice> Hi

[16:28] <lizmat> m: Map.hash

[16:28] <camelia> rakudo-moar 2b278e: ( no output )

[16:28] <lizmat> m: say Map.hash.WHAT

[16:28] <camelia> rakudo-moar 2b278e: OUTPUT«(Map)␤»

[16:28] <lizmat> the underlying issue, I think

[16:29] <jnthn> Map.hash returning Map is fine; I suspect Map.Hash needs implementing

[16:30] <lizmat> m: say Int.hash.WHAT

[16:30] <camelia> rakudo-moar 2b278e: OUTPUT«(Hash)␤»

[16:30] <lucasb> this method in Any: multi method Hash() { self.hash.Hash }

[16:30] <jnthn> Right. Map needs to override it

[16:30] <lizmat> m: say Capture.new.hash.WHAT

[16:30] <camelia> rakudo-moar 2b278e: OUTPUT«(Map)␤»

[16:31] <lizmat> that would solve this one as well...

[16:32] <dalek> rakudo/curli: 8f0c099 | (Stefan Seifert)++ | src/core/CompUnit (3 files):

[16:32] <dalek> rakudo/curli: Bring back require $file-name;

[16:32] <dalek> rakudo/curli: 

[16:32] <dalek> rakudo/curli: Added an extra method to CompUnit::Repository for loading a module from a given

[16:32] <dalek> rakudo/curli: file name. The exact use cases for this are unclear, but it's speced and it

[16:32] <dalek> rakudo/curli: feels like an appropriate low level tool for extreme situations.

[16:32] <dalek> rakudo/curli: 

[16:32] <dalek> rakudo/curli: In any case it's quite separate from normal module loading, so it can be removed

[16:32] <dalek> rakudo/curli: easily in case we decide that it has to go.

[16:32] <dalek> rakudo/curli: review: https://github.com/rakudo/rakudo/commit/8f0c0997df

[16:34] *** ollej joined
[16:34] <dalek> rakudo/nom: 3bc921e | lizmat++ | src/core/ (6 files):

[16:34] <dalek> rakudo/nom: Move NORMALIZE_ENCODING to Rakudo::Internals

[16:34] <dalek> rakudo/nom: 

[16:34] <dalek> rakudo/nom: Also make it a bit more efficient

[16:34] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/3bc921ef57

[16:34] *** rangerprice left
[16:35] *** duncan_dmg left
[16:35] <PerlJam> jnthn: FWIW, I wrote a program to clone all of the ecosystem module repos (which I did), then used ack to search for things that looked like require filename and what I got was https://gist.github.com/perlpilot/f7e376d18c7b2a3cdee4

[16:35] <andreoss> m: multi foo(True) { "hi" }; multi foo(False) { "bye" } ; say foo(True); say foo(!True);

[16:35] <camelia> rakudo-moar 2b278e: OUTPUT«hi␤hi␤»

[16:35] <andreoss> why?

[16:36] <PerlJam> andreoss: why what?

[16:36] <timotimo> PerlJam: hey, that's a bi tlike moritz' repository with all ecosystem things checked out as submodules :)

[16:36] *** duncan_dmg joined
[16:36] <andreoss> PerlJam: why signature foo(False) is not matched? 

[16:36] <TimToady> andreoss: smartmatching True is always True

[16:37] <TimToady> m: say False ~~ True

[16:37] <camelia> rakudo-moar 2b278e: OUTPUT«Potential difficulties:␤    Smartmatch against True always matches; if you mean to test the topic for truthiness, use :so or *.so or ?* instead␤    at /tmp/EP99UsSSZj:1␤    ------> 3say False ~~7⏏5 True␤FalseTrue␤»

[16:37] <andreoss> m: say Nil ~~ True

[16:37] <camelia> rakudo-moar 2b278e: OUTPUT«Potential difficulties:␤    Smartmatch against True always matches; if you mean to test the topic for truthiness, use :so or *.so or ?* instead␤    at /tmp/FfkkLVraJM:1␤    ------> 3say Nil ~~7⏏5 True␤Use of Nil in string context  in block <u…»

[16:38] *** finanalyst left
[16:38] <TimToady> so if you really want to write multies for an either/or case, you have to use 'where :so' or some such

[16:39] <TimToady> but why not just use an if/else when you know it's boolean?

[16:39] <PerlJam> timotimo: But part of the fun was writing the perl6 program  :)  (and I'd forgotten about moritz's repo if I ever knew about it :)

[16:39] <andreoss> okay

[16:39] <andreoss> thanks

[16:40] <andreoss> what motivation for making False ~~ True?

[16:41] <ilmari> m: say False ~~ True

[16:41] <camelia> rakudo-moar 2b278e: OUTPUT«Potential difficulties:␤    Smartmatch against True always matches; if you mean to test the topic for truthiness, use :so or *.so or ?* instead␤    at /tmp/ANEAfVu9Ew:1␤    ------> 3say False ~~7⏏5 True␤FalseTrue␤»

[16:41] <ilmari> m: say(False ~~ True)

[16:41] <camelia> rakudo-moar 2b278e: OUTPUT«Potential difficulties:␤    Smartmatch against True always matches; if you mean to test the topic for truthiness, use :so or *.so or ?* instead␤    at /tmp/5yTpYTikPM:1␤    ------> 3say(False ~~7⏏5 True)␤FalseTrue␤»

[16:42] <andreoss> ilmari: see with multies above

[16:42] <TimToady> we need special values that a smartmatch can use to indicate success vs failure; Bool/Match/Nil/List all fall into this category

[16:43] <lizmat> dinner&

[16:44] <TimToady> when you write $foo ~~ bar() we have no idea from the syntax whether bar is intended to return a value to be smartmatched against, or is itself performing the smartmatch

[16:44] <TimToady> so we distinguish some values that bar can return to indicate it has already done the smartmatch

[16:45] *** synbot6 joined
[16:46] <TimToady> my attempts to generalize this met with skepticism, so we ended up with a list :)

[16:47] <TimToady> 'course, if we had generalized it, we might've ended up with Icon...

[16:48] <TimToady> so maybe it's just as well...

[16:49] * TimToady remembers being scared of Icon because it had 3-character operators...

[16:49] <TimToady> ironic, that

[16:54] *** muraiki joined
[16:56] * masak .oO( Iconic, that )

[16:56] <dalek> ecosystem: 32ea95f | tony-o++ | META.list:

[16:56] <dalek> ecosystem: Module::Does

[16:56] <dalek> ecosystem: 

[16:56] <dalek> ecosystem: Make it easy for module authors to detect modules loaded in `global` scope that `does` whatever they're looking for (also allows defaults)

[16:56] <dalek> ecosystem: review: https://github.com/perl6/ecosystem/commit/32ea95fb19

[16:57] <masak> PerlJam: https://github.com/moritz/perl6-all-modules

[16:59] <dalek> doc: 633bb41 | (Lloyd Fournier)++ | / (2 files):

[16:59] <dalek> doc: Made headings in control.pod searchable

[16:59] <dalek> doc: 

[16:59] <dalek> doc: 1. Added X<> blocks around everything control.pod (separating via ' '

[16:59] <dalek> doc: instead of '/'. '/' conflicts with url path)

[16:59] <dalek> doc: 2. Made X<if|control flow> work as shorthand for X<if|control flow,if>

[16:59] <dalek> doc: review: https://github.com/perl6/doc/commit/633bb41346

[16:59] <dalek> doc: 3797588 | RabidGravy++ | / (2 files):

[16:59] <dalek> doc: Merge pull request #181 from LLFourn/master

[17:00] <dalek> doc: 

[17:00] <dalek> doc: Made headings in control.pod searchable

[17:00] <dalek> doc: review: https://github.com/perl6/doc/commit/379758838c

[17:01] *** vendethiel joined
[17:01] *** abraxxa left
[17:02] *** zakharyas left
[17:04] *** pmurias joined
[17:10] *** pmurias left
[17:10] <dalek> nqp: 5b5faaa | (Pawel Murias)++ | t/nqp/82-decode.t:

[17:10] <dalek> nqp: Expand the nqp::encode/nqp::decode test.

[17:10] <dalek> nqp: review: https://github.com/perl6/nqp/commit/5b5faaa3fa

[17:10] *** pmurias joined
[17:16] *** diana_olhovik joined
[17:17] <RabidGravy> I've come to the conclusion that multiple dispatch is possibly the greatest language feature for making readable software

[17:18] <dalek> perl6-roast-data: b3f1456 | coke++ | / (9 files):

[17:18] <dalek> perl6-roast-data: today (automated commit)

[17:18] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/b3f14569d5

[17:20] *** ^elyse^ joined
[17:21] *** uruwi left
[17:21] *** ^elyse^ left
[17:22] *** tokuhirom joined
[17:23] *** pmurias left
[17:24] <[Coke]> lizmat: I know you had specific ideas about what went in stress vs. what went in spec. what about S17-promise/stress.t which takes 42 seconds on my box?

[17:25] <[Coke]> (ah, it's already in stress. Thank you! ;)

[17:26] <masak> 'night, #perl6

[17:26] *** vendethiel left
[17:26] <[Coke]> ~~

[17:27] *** tokuhirom left
[17:29] *** diana_olhovik left
[17:30] *** uruwi joined
[17:33] *** telex left
[17:33] *** diana_olhovik_ joined
[17:34] <cognominal_> what is the normalization form used when serializing a string? just curious.

[17:34] *** telex joined
[17:35] <jnthn> cognominal_: In the bytecode file? Depends.

[17:36] <jnthn> Latin-1 or UTF-8 "by need"

[17:36] <jnthn> (For space saving, but also because Latin-1 is, the \r\n case aside, already in NFG, so it cuts down on checking if we need to do any normalization)

[17:37] *** jkva left
[17:39] <cognominal_> yea, I know it can't be NFG where the non precomposed characters place is process history dependant.

[17:39] <cognominal_> jnthn++

[17:41] <jnthn> Yeah, NFG is highly internal

[17:41] <jnthn> Especially 'cus we may need to change exactly how we do it in the future

[17:42] *** pmurias joined
[17:44] *** MARTIMM joined
[17:46] <japhb> jnthn: How are you handling "\r"-only line endings (pre-OS X Mac OS)?

[17:47] <cognominal_> Is this still true as said in model.h that collectables can be only ojects or stables? It seems overly restrictive.

[17:47] *** pmurias left
[17:47] <ilmari> m: say "\r" ~~ /\v/

[17:47] <camelia> rakudo-moar 2b278e: OUTPUT«｢

[17:47] <ilmari> m: say so "\r" ~~ /\v/

[17:47] <camelia> rakudo-moar 2b278e: OUTPUT«True␤»

[17:48] *** diana_olhovik_ left
[17:49] <[Coke]> java build busted again.

[17:49] <[Coke]> Error while constructing error object:Could not locate compile-time value for symbol X::Undeclared::Symbols

[17:49] <[Coke]> That might be of type X::Ironic

[17:53] <jnthn> japhb: Ain't yet, but the stuff I worked on today will let us easily add that option.

[17:53] <jnthn> japhb: That is, the default can be \n | \r\n | \r

[17:53] <jnthn> japhb: And since \r\n is one grapheme it's easy to implement :)

[17:54] *** llfourn left
[17:56] *** MARTIMM left
[17:56] <jnthn> cognominal_: What else would you want? :)

[17:56] <ilmari> Unicode considers a sequence to be (?>\x0D\x0A|\v)

[17:56] <ilmari> s/sequence/linebreak/

[17:57] <jnthn> cognominal_: Those are the only two things that we need at the moment, anyways. It's possible we'll end up with another thing, but 6model only needs the two.

[18:02] <cognominal_> jnthn, it seems that entities like entities like handles don't need MVMReprOps entries, except for gc and serialisation stuff (not even serialisation for handles). 

[18:03] <cognominal_> On the other hand, I suppose that some Occam razor is in order :)

[18:07] *** duncan_dmg left
[18:10] <jdv79> RabidGravy: how so?

[18:10] <jdv79> maybe you could do a writeup on that point?

[18:11] <jdv79> i'm mor curious that i normally would be because the other day i realized i don't really get the proto and dispatch stuff well

[18:12] <jdv79> anyone know if that stuff is doc'ed well anywhere?

[18:16] *** espadrine left
[18:17] <RabidGravy> It removes, boilerplate from code, making e.g. stuuff that recurses over a data structure beautifully simple

[18:17] <lizmat> [Coke]: probably something I did, will look into the jvm build break now

[18:19] <[Coke]> lizmat++ thanks!

[18:19] <psch> lizmat: it's in 3bc921e, according to the bisect i just finished

[18:19] <psch> (yay for bisecting across 4 commits :) )

[18:19] <[Coke]> jdv79: if you don't find something obvious on the docs site, can you add it to the wanted list?

[18:20] *** khw left
[18:20] <jdv79> sure

[18:20] <lizmat> [Coke]: found it

[18:21] <lizmat> src/vm/jvm/core/IOAsyncFile.pm  ???

[18:21] <lizmat> WTF?

[18:21] <jdv79> [Coke]: except a lart part of it is the 2nd tutorial item there anyway

[18:22] <jdv79> actually that would have to cover it all i would think

[18:22] <lizmat> I never knew we had Perl6 core files other than in src/core ???

[18:23] *** gonz_ left
[18:23] <lizmat> jnthn: mind if I rename them to something like JVM/IOAsyncFile.pm ?

[18:23] <lizmat> so that at least an ack in src/core will show them ??

[18:24] <psch> looks untouched for over a year, fwiw

[18:24] <jdv79> the docs search list is getting a bit unwiedly no?

[18:25] <jdv79> its difficult to search for something basic like the method declarator

[18:25] <lizmat> psch: problem is that these files aren't searched when I do a global core search

[18:25] <psch> ...almost two years, even

[18:25] <lizmat> which I did for NORMALIZE_ENCODING

[18:25] <psch> lizmat: i'm just wondering how useful IOAsyncFile.pm still is for jvm, and whether we could just ditch it

[18:25] <jdv79> the list is too long and some things seem are not referenced well

[18:25] <lizmat> and because I didn't know about that file, I busted the JVM build  :-(

[18:26] <lizmat> psch: well, I would at least want to move them to src/core

[18:26] <jdv79> how does "Reference: methods" mean a section in classtut

[18:26] <jdv79> needs more context and refineability maybe

[18:26] <psch> lizmat: right, that's probably the better solution.  maybe they are useful still

[18:27] <lizmat> yeah, jvm build fixed

[18:27] <skids> I assume \r\n is only "one grapheme" in utfX not when processing latin-1 or ascii, correct?

[18:28] <dalek> doc: 39db29a | jdv79++ | WANTED:

[18:28] <dalek> doc: Add dispatch related declarators.

[18:28] <dalek> doc: review: https://github.com/perl6/doc/commit/39db29a3ea

[18:28] <dalek> rakudo/nom: fb05e7d | lizmat++ | src/vm/jvm/core/IOAsyncFile.pm:

[18:28] <dalek> rakudo/nom: Fix JVM build

[18:28] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/fb05e7d1a9

[18:29] * skids is somewhat leary of combining rn to a single thing.

[18:30] *** kmel joined
[18:32] <dalek> perl6-examples: 763078f | andreoss++ | categories/interpreters/lisp.pl:

[18:32] <dalek> perl6-examples: using Grammar for building AST

[18:32] <dalek> perl6-examples: review: https://github.com/perl6/perl6-examples/commit/763078f249

[18:33] <jdv79> the crlf as one seems unnatural but kinda cool i guess

[18:33] *** s_kilk joined
[18:33] <jdv79> i look forward to confusing people with it and them using it as yet another reason p6 is crazy

[18:34] <PerlJam> .oO( crazy *AWESOME* :)

[18:35] *** rangerprice joined
[18:37] *** sufrostico left
[18:38] *** pmurias joined
[18:39] *** Begi1115 left
[18:39] <TimToady> .oO(We're crazy to go along with everything the Unicode consortium dreams up...)

[18:39] *** Begi1115 joined
[18:41] <dalek> rakudo/curli: 413b271 | lizmat++ | src/ (2 files):

[18:41] <dalek> rakudo/curli: Move IOAsyncFile under src/core

[18:41] <dalek> rakudo/curli: review: https://github.com/rakudo/rakudo/commit/413b27102a

[18:41] <dalek> rakudo/curli: 34fc505 | lizmat++ | src/ (2 files):

[18:41] <dalek> rakudo/curli: Move KeyReducer under src/core

[18:41] <dalek> rakudo/curli: review: https://github.com/rakudo/rakudo/commit/34fc50525f

[18:41] <dalek> rakudo/curli: b5646f1 | lizmat++ | tools/build/Makefile-JVM.in:

[18:41] <dalek> rakudo/curli: Adapt makefile for files moved to src/core

[18:41] <dalek> rakudo/curli: review: https://github.com/rakudo/rakudo/commit/b5646f13a3

[18:41] <lizmat> argh

[18:41] <lizmat> did it on the wrong branch  :-(

[18:42] *** pippo joined
[18:42] *** pippo left
[18:43] <dalek> rakudo/nom: 927e45f | lizmat++ | src/ (2 files):

[18:43] <dalek> rakudo/nom: Move IOAsyncFile under src/core

[18:43] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/927e45fba8

[18:43] <dalek> rakudo/nom: 7cfb834 | lizmat++ | src/ (2 files):

[18:43] <dalek> rakudo/nom: Move KeyReducer under src/core

[18:43] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/7cfb834412

[18:43] <dalek> rakudo/nom: 34c5a7a | lizmat++ | tools/build/Makefile-JVM.in:

[18:43] <dalek> rakudo/nom: Adapt makefile for files moved to src/core

[18:43] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/34c5a7a791

[18:44] <lizmat> right branch now

[18:44] <andreoss> m: \().Hash

[18:44] <camelia> rakudo-moar 2b278e: OUTPUT«Memory allocation failed; could not allocate 58256 bytes␤»

[18:45] <lizmat> andreoss: that's the same as Capture.new.Hash

[18:46] <andreoss> has it been already reported?

[18:46] *** uruwi left
[18:46] <lizmat> andreoss: not sure

[18:46] <lizmat> am looking at it though

[18:47] <andreoss> i would check it myself, but all links to the bug tracker are broken 

[18:47] <andreoss> http://rakudo.org/tickets/ here

[18:47] <[Coke]> andreoss: rt.perl.org

[18:48] <timotimo> wait ... wasn't KeyReducer supposed to disappear?

[18:49] <andreoss> [Coke]: how do i sort tickets?

[18:50] *** pippo joined
[18:50] <pippo> o/ #perl6

[18:50] <yoleaux> 15:29Z <azawawi> pippo: I just fixed it in https://github.com/azawawi/perl6-selenium-webdriver/issues/9 . Thanks for your report. Please reopen if it does not work for you.

[18:50] <lizmat> timotimo: I'm fine with it disappearing, but I wanted it to be visible first :-)

[18:50] <timotimo> right

[18:51] <pippo> .tell azawawi Thank you! And thank you for this great module. :-)) 

[18:51] <yoleaux> pippo: I'll pass your message to azawawi.

[18:51] <timotimo> jnthn: do you think it'd be sensible (possible?) to write a module that uses NativeCall guts more directly to see if a sizable performance improvement is feasible with code generation for nativecall?

[18:52] <dalek> nqp: 0b74f1a | (Pawel Murias)++ | src/vm/js/QAST/Compiler.nqp:

[18:52] <dalek> nqp: [js] Fix bug with nqp::newtype.

[18:52] <dalek> nqp: review: https://github.com/perl6/nqp/commit/0b74f1afa5

[18:52] <lizmat> m: say Map.new((:42a)).perl   # wrongish .perl representation

[18:52] <camelia> rakudo-moar 2b278e: OUTPUT«Map.new(:a(42))␤»

[18:54] <TimToady> what's wrong with it?

[18:54] <TimToady> oh, nevermind

[18:54] <lizmat> m: say Map.new(:a(42)).perl    # that's wrong

[18:54] <camelia> rakudo-moar 2b278e: OUTPUT«Map.new()␤»

[18:54] <lizmat> named / pair confusion

[18:54] * TimToady should eat lunch

[18:55] <dalek> rakudo/nom: cc9c7c1 | lizmat++ | src/core/Map.pm:

[18:55] <dalek> rakudo/nom: Fix Map.perl representation

[18:55] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/cc9c7c188e

[19:00] *** kjs_ joined
[19:04] *** andreoss left
[19:04] <AlexDaniel> m: my @test = 5, 8, 15; say @test[* - 10];

[19:04] <camelia> rakudo-moar fb05e7: OUTPUT«Index out of range. Is: -7, should be in 0..Inf␤  in block <unit> at /tmp/f2BVUVP0Kk:1␤␤Actually thrown at:␤  in block <unit> at /tmp/f2BVUVP0Kk:1␤␤»

[19:04] <AlexDaniel> 0..Inf?

[19:04] <AlexDaniel> Like, what does that mean?

[19:04] <psch> m: say [1,2,3][0..Inf]

[19:04] <camelia> rakudo-moar fb05e7: OUTPUT«(1 2 3)␤»

[19:05] <psch> m: say [1,2,3][5]

[19:05] <camelia> rakudo-moar fb05e7: OUTPUT«(Any)␤»

[19:05] *** kmel_ joined
[19:05] <lizmat> Perhaps "Effective index out of range" would be a better message

[19:06] <AlexDaniel> otherwise it makes me want to do this…

[19:06] <AlexDaniel> m: say [4,8,15,16][* + Inf];

[19:06] <camelia> rakudo-moar fb05e7: OUTPUT«Cannot coerce Inf or NaN to an Int␤  in block <unit> at /tmp/lu8XwWboc4:1␤␤Actually thrown at:␤  in block <unit> at /tmp/lu8XwWboc4:1␤␤»

[19:07] <AlexDaniel> like “go, get me this element on Inf index!”

[19:07] <zengargoyle> is there a multidimensional array index thingy yet? - @want=(1,2,4); @from[@want] === $from[@want[0]][@want[1]][@want[2]]

[19:07] *** kmel_ left
[19:07] <[Coke]> andreoss - when I go to the top level, I click on "perl6" to get all the open perl 6 tickets - then you can sort by clicking on the column headings.

[19:07] *** kmel_ joined
[19:07] <zengargoyle> like a |;@array or something?

[19:07] *** kmel_ left
[19:08] *** kmel left
[19:08] <[Coke]> andreoss - you can click on Tickets in the menu to create a query to search. If you're logged in, you can save that query

[19:09] *** kmel joined
[19:13] <dalek> rakudo/nom: 192a3ff | lizmat++ | src/core/Map.pm:

[19:13] <dalek> rakudo/nom: Fix hangs related to Map:D.Hash infinilooping

[19:13] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/192a3ff333

[19:13] <dalek> ecosystem: 2a541ff | cygx++ | META.list:

[19:13] <dalek> ecosystem: Add TinyCC again

[19:13] <dalek> ecosystem: 

[19:13] <dalek> ecosystem: The bitrot has been removed. As a bonus, the module should now be panda-friendly.

[19:13] <dalek> ecosystem: review: https://github.com/perl6/ecosystem/commit/2a541fffd1

[19:20] <dalek> ecosystem: cd36a55 | tony-o++ | META.list:

[19:20] <dalek> ecosystem: defining html::parser role

[19:20] <dalek> ecosystem: 

[19:20] <dalek> ecosystem: skarsnik++

[19:20] <dalek> ecosystem: review: https://github.com/perl6/ecosystem/commit/cd36a55b0b

[19:23] <AlexDaniel> m: say <a b c d e f g>[* % 3];

[19:23] <camelia> rakudo-moar fb05e7: OUTPUT«b␤»

[19:23] <AlexDaniel> yay for more obfuscation!

[19:23] *** pullphinger joined
[19:25] <AlexDaniel> m: say <a b c d e f g h i j k l m n o>[(*.sin + 1) * 5];

[19:25] <camelia> rakudo-moar fb05e7: OUTPUT«i␤»

[19:26] *** s_kilk left
[19:27] <lucasb> lizmat: http://irclog.perlgeek.de/perl6/2015-10-29#i_11453816

[19:28] <lizmat> m: "/dev/null".IO.lines

[19:28] <camelia> rakudo-moar fb05e7: ( no output )

[19:28] <flussence> lizmat++ # .trans(‘a’..‘z’ => (‘n’..‘z’,‘a’..‘m’)) runs 2x as fast after those Range changes

[19:29] <lizmat> m: .say for "/dev/null".IO.open

[19:29] <lizmat> lucasb: don't need no @*ARGS for that

[19:29] <camelia> rakudo-moar fb05e7: OUTPUT«Failed to write bytes to filehandle: bad file descriptor␤  in block <unit> at /tmp/dnI6mfFnjT:1␤␤»

[19:32] <psch> m: @*ARGS = '/dev/null' xx 2; .say for lines

[19:32] <camelia> rakudo-moar fb05e7: OUTPUT«Memory allocation failed; could not allocate 32768 bytes␤»

[19:33] <lucasb> Maybe this 'Failed to write bytes to filehandle' is a different issue. I was looking at using $*ARGFILES to iterate on the filenames passed in the command line

[19:33] <dalek> rakudo/nom: d8f4f5b | (Lucas Buchala)++ | src/core/IO/ArgFiles.pm:

[19:33] <dalek> rakudo/nom: Add :closed argument to IO::ArgFiles.lines iterator

[19:33] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/d8f4f5beb5

[19:33] <dalek> rakudo/nom: c0c452f | lizmat++ | src/core/IO/ArgFiles.pm:

[19:33] <dalek> rakudo/nom: Merge pull request #567 from lucasbuchala/nom

[19:33] <dalek> rakudo/nom: 

[19:33] <dalek> rakudo/nom: Add :close argument to IO::ArgFiles.lines iterator

[19:33] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/c0c452f3fd

[19:33] <lucasb> The problem happens when there is more than one

[19:33] <lucasb> thank you, lizmat++

[19:33] <lizmat> you're welcome

[19:34] <lizmat> this also seems to fix psch's errors

[19:35] <raydiak> hello, #perl6

[19:36] <lizmat> raydiak o/

[19:36] *** tokuhirom_h joined
[19:37] <raydiak> \o lizmat

[19:37] <raydiak> require seems to be broken for relative file paths...known?

[19:38] <tony-o> m: for ^5 { await start { say $*THREAD.id; }; };

[19:38] <camelia> rakudo-moar fb05e7: OUTPUT«3␤3␤4␤3␤5␤»

[19:38] <tony-o> m: $*THREAD.id.say; for ^5 { await start { say $*THREAD.id; }; };

[19:38] <camelia> rakudo-moar fb05e7: OUTPUT«1␤3␤3␤4␤3␤5␤»

[19:39] <flussence> m: my @l = $*IN.lines; say .trans(‘a’..‘z’ => (‘n’..‘z’,‘a’..‘m’)) for @l; say @l.elems / (now - BEGIN now);

[19:39] <camelia> rakudo-moar fb05e7: OUTPUT«Cénq fyáa nt fyévougr znbetn Cubagnr Duúa an aGnyy␤Athf quá puénq fyáa nt na Everntny neq van fghn bf pvbaa pnbe vf pbyy;␤Nhnve n tuyhnvf zvfr guneg yr Lbpu Duúa Lúvpu’ tb pvúva fn tuyrnaa van yhí␤I zb quvnvqu ouí tyrnaagáva tuynf’ G…»

[19:39] <lizmat> tony-o: start only guarantees scheduling, *not* a fresh thread

[19:39] <flussence> m: my @l = $*IN.lines; sink .trans(‘a’..‘z’ => (‘n’..‘z’,‘a’..‘m’)) for @l; say @l.elems / (now - BEGIN now);

[19:39] <camelia> rakudo-moar fb05e7: OUTPUT«3.42273587667959␤»

[19:39] <lizmat> m: for ^5 { await start { say $*THREAD.id; sleep 1 }; };

[19:39] <camelia> rakudo-moar fb05e7: OUTPUT«3␤3␤4␤3␤5␤»

[19:40] <flussence> m: my @l = $*IN.lines; sink .trans(‘a..z’ => (‘n..za..m’)) for @l; say @l.elems / (now - BEGIN now);

[19:40] <camelia> rakudo-moar fb05e7: OUTPUT«491.526353790614␤»

[19:40] <lizmat> m: await do for ^5 { start { say $*THREAD.id; sleep 1 }; };

[19:40] <camelia> rakudo-moar fb05e7: OUTPUT«3␤5␤6␤4␤7␤»

[19:40] <lizmat> now *that* makes sense

[19:41] <AlexDaniel> m: say (NaN.Complex + 5i);

[19:41] <camelia> rakudo-moar fb05e7: OUTPUT«NaN+5i␤»

[19:41] *** tokuhirom_h left
[19:41] <lizmat> flussence: what is your point ?

[19:42] <psch> m: sub term:<what> { NaN\i }; 

[19:42] <camelia> rakudo-moar fb05e7: ( no output )

[19:42] <timotimo> we have a tiny C Compiler written in perl6?

[19:43] <psch> m: sub term:<何> { NaN\i } 

[19:43] <camelia> rakudo-moar fb05e7: ( no output )

[19:43] <AlexDaniel> m: say i * NaN;

[19:43] <camelia> rakudo-moar fb05e7: OUTPUT«NaN+NaN\i␤»

[19:43] <flussence> no point, just wanted to make sure my local numbers weren't screwed up :)

[19:43] <lizmat> timotimo: you mean https://github.com/cygx/p6-tinycc that just got added to the ecosystem again ?

[19:44] <lizmat> flussence: that's a factor 150 difference ?

[19:44] <flussence> used to be 300!

[19:45] <lizmat> I;m not seeing the semantic difference ?

[19:45] <psch> lizmat: Makefile-JVM.in points at src/core/KeyReducer.pm, but the file actually sits in src/core/JVM/KeyReducer.pm

[19:45] <rangerprice> French hate the Perl language :'(

[19:45] <rangerprice> hates *

[19:45] <lizmat> psch: argh, you're right

[19:46] <lizmat> had started a build, but hadn't looked at the result

[19:46] *** lichtkind joined
[19:47] <flussence> lizmat: both those lines produce the same result, but either the trans stringy-range special case is really well optimized or the normal-Range case doesn't get used enough for anyone to notice

[19:47] <lizmat> so the only difference is *how* the range is specified, and not what it is ?

[19:48] <flussence> yep

[19:48] <lizmat> wow

[19:48] <lizmat> maybe I should some more at .trans then  :-)

[19:49] <psch> fwiw, tr/// uses the string-interpreted-as-range case

[19:50] <psch> m: my @l = $*IN.lines; sink tr/a..z/n..za..m/ for @l; say @l.elems / (now - BEGIN now);

[19:50] <camelia> rakudo-moar fb05e7: OUTPUT«669.874478204587␤»

[19:50] <psch> uhh

[19:50] <rangerprice> i will finish my first arp poisoning tool in perl today, if you are interested, contact me :)

[19:50] <psch> ...i don't understand the output :P

[19:50] <flussence> psch: lines per second

[19:50] <psch> ahh, of course

[19:51] <psch> curious how that's even faster than the equivalent .trans call

[19:51] <psch> tr/// builds a pair under the hood

[19:51] <psch> s/\<p/P/

[19:51] <psch> (excuse my vim-y regex syntax :P )

[19:52] <El_Che> psch: :perldo s/vim-y syntax/perl-y syntax/g

[19:52] <El_Che> :)

[19:52] <flussence> could just be measurement noise, it's a relatively tiny denominator there...

[19:52] <dalek> rakudo/nom: c34e750 | lizmat++ | tools/build/Makefile-JVM.in:

[19:52] <dalek> rakudo/nom: Unbust JVM build (again), psch++ for spotting

[19:52] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/c34e750470

[19:54] *** Begi1115 left
[19:54] *** Begi1115 joined
[19:55] <dalek> rakudo/nom: 74ff317 | TimToady++ | src/ (3 files):

[19:55] <dalek> rakudo/nom: correctly autogen prefix and postfix hypers too

[19:55] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/74ff317d66

[19:55] <dalek> roast: 3052bb6 | TimToady++ | S03-metaops/hyper.t:

[19:55] <dalek> roast: test autogen of prefix and postfix hypers

[19:55] <dalek> roast: review: https://github.com/perl6/roast/commit/3052bb6aad

[19:58] <Hotkeys> permutations is mucho slow

[19:58] <Hotkeys> m: say (1..9).permutations[*-1];

[19:59] <camelia> rakudo-moar fb05e7: OUTPUT«(timeout)»

[20:00] *** uruwi joined
[20:00] <psch> m: say [*] 1..9

[20:00] <camelia> rakudo-moar fb05e7: OUTPUT«362880␤»

[20:03] <psch> permutations itself seems pretty fast

[20:03] <psch> m: say permutations(11)

[20:03] <camelia> rakudo-moar fb05e7: OUTPUT«((0 1 2 3 4 5 6 7 8 9 10) (0 1 2 3 4 5 6 7 8 10 9) (0 1 2 3 4 5 6 7 9 8 10) (0 1 2 3 4 5 6 7 9 10 8) (0 1 2 3 4 5 6 7 10 8 9) (0 1 2 3 4 5 6 7 10 9 8) (0 1 2 3 4 5 6 8 7 9 10) (0 1 2 3 4 5 6 8 7 10 9) (0 1 2 3 4 5 6 8 9 7 10) (0 1 2 3 4 5 6 8 9 10 7) (0 1 …»

[20:04] <psch> the problem is mapping those lists over slices of the array (or range) you call the method on

[20:04] <flussence> wow, there's a lot more modules using .trans than I thought; most of the web-related ones need it for basic escaping stuff. Making that faster's going to make quite a few people happy...

[20:04] <TimToady> psch: that's not fast, that's lazy

[20:05] <TimToady> I've been calculating permutations(9).elems for several minutes now

[20:06] <psch> TimToady: oh.  yes, that makes sense

[20:06] <psch> i keep forgetting how useful laziness actually is

[20:06] <psch> FSVO "useful"

[20:07] <tony-o> lizmat: then how can i guarantee that any socket write is in the originating thread?

[20:07] <TimToady> in any case .permutations[*-1] is a really slow way to write .reverse

[20:08] <lizmat> tony-o: but using a Supply, I guess, and doing the write in an .act ?

[20:08] <lizmat> although I'm not 100% sure atm, jnthn would know for sure

[20:09] <AlexDaniel> is there any other way to insert an element into the middle besides using splice?

[20:09] <Hotkeys> TimToady: It gets the last element. Would reversing and then getting the first element be faster?

[20:10] <timotimo> splice is exactly how you do that efficiently

[20:10] <timotimo> but you can also @foo[15..*] = @foo[16..*]; foo[15] = $new_elem

[20:10] <timotimo> or something

[20:10] <timotimo> got the = the wrong way around

[20:11] <AlexDaniel> timotimo: that's ok. I'm just thinking if maybe there should be “&insert” thingy that will do exactly the same. Otherwise it is not obvious, but works for me

[20:13] <[Coke]> lizmat++ jvm build unbusted.

[20:13] <psch> AlexDaniel: &insert would presumably have a Signature like :(@list, $pos, *@newelems)

[20:13] *** spider-mario joined
[20:13] <AlexDaniel> psch: yeah

[20:14] <psch> m: my @a = ^10; splice(@a, 4, 0, [10, 11, 12]); say @a 

[20:14] <camelia> rakudo-moar fb05e7: OUTPUT«[0 1 2 3 10 11 12 4 5 6 7 8 9]␤»

[20:14] <psch> AlexDaniel: you're saving one "0, " 

[20:15] <psch> although i have to admit that the insert-y case for splice feels weird, especially considering $elems is optional, followed by a slurpy

[20:15] <AlexDaniel> psch: not only that, the code will be a bit easier to read too

[20:15] *** jkva joined
[20:15] <psch> i don't see how one can skip $elems for splice but still supply new elements...

[20:16] <Hotkeys> it seems that reversing and getting the first element is indeed faster than [*-1]

[20:16] <psch> which is probably the readability argument expanded

[20:16] <lizmat> I'd rather see an "insert" that would automagically insert into a sorted list

[20:17] <AlexDaniel> hm

[20:18] <psch> m: sub splize(@list, $start, :$elems = 0, *@replacement) { splice(@list, $start, $elems, @replacement) }; my @a = ^10; splize(@a, 4, 10, 11, 12) # i think i'd prefer this

[20:18] <camelia> rakudo-moar fb05e7: ( no output )

[20:18] <psch> m: sub splize(@list, $start, :$elems = 0, *@replacement) { splice(@list, $start, $elems, @replacement) }; my @a = ^10; say splize(@a, 4, 10, 11, 12) # without ENOSAY

[20:18] <camelia> rakudo-moar fb05e7: OUTPUT«[]␤»

[20:18] <psch> err

[20:18] <psch> andd yeah

[20:18] <TimToady> permutations(9) took more than 15 minutes to run

[20:18] <psch> m: sub splize(@list is rw, $start, :$elems = 0, *@replacement) { splice(@list, $start, $elems, @replacement) }; my @a = ^10; splize(@a, 4, 10, 11, 12); say @a

[20:18] <camelia> rakudo-moar fb05e7: OUTPUT«5===SORRY!5=== Error while compiling /tmp/CQFf24ekl7␤Can only use 'is rw' on a scalar ('$' sigil) parameter␤at /tmp/CQFf24ekl7:1␤»

[20:18] <psch> m: sub splize(@list, $start, :$elems = 0, *@replacement) { splice(@list, $start, $elems, @replacement) }; my @a = ^10; splize(@a, 4, 10, 11, 12); say @a

[20:18] <camelia> rakudo-moar fb05e7: OUTPUT«[0 1 2 3 10 11 12 4 5 6 7 8 9]␤»

[20:18] *** tokuhirom joined
[20:18] * psch sighs

[20:19] <Hotkeys> TimToady: that's quite a few minutes

[20:19] <TimToady> I'm just saying (1..9).permutations[*-1] is gonna end up with (1..9).reverse as the last element

[20:20] *** darutoko left
[20:20] <Hotkeys> ah

[20:21] <Hotkeys> I tried it with a list 10,000,000 items long and reversing and getting the first element took half the time as using [*-1]

[20:22] <Hotkeys> still, I using it to demonstrate the speed of permutations

[20:22] <Hotkeys> not slices :p

[20:23] *** tokuhirom left
[20:25] *** cygx joined
[20:25] <cygx> o/

[20:25] <AlexDaniel> m: say <a b c>.rotate(Inf);

[20:25] <camelia> rakudo-moar 74ff31: OUTPUT«X::Multi::NoMatch exception produced no message␤  in block <unit> at /tmp/wDJfhV4YbL:1␤␤»

[20:26] <AlexDaniel> interesting. I get another error

[20:26] <psch> j: say <a b c>.rotate(Inf);

[20:26] <camelia> rakudo-jvm 74ff31: OUTPUT«X::Multi::NoMatch exception produced no message␤  in block <unit> at /tmp/6IfGPWUlYG:1␤␤»

[20:27] <dalek> rakudo/nom: b855790 | lizmat++ | src/core/ (7 files):

[20:27] <dalek> rakudo/nom: Provide fix for #126503

[20:27] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/b8557900cd

[20:27] <synbot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=126503

[20:28] <cygx> Could a slurpy hash parameter be added to the proto of EVAL?

[20:28] <cygx> It would be nice to have the option for additional named parameters when adding multis...

[20:31] <lizmat> cygx: testing that

[20:31] * psch never felt like adding multis for &EVAL would solve a problem

[20:32] <psch> take that as "i'm curious to hear what makes that seem to be the right choice"

[20:32] <El_Che> I attended yesterday a python course at work. I was surprised that the big version 3 break didn't fix as many inconsistencies as I expected

[20:33] <El_Che> (yesterday and today I mean)

[20:33] <El_Che> a lot of nice stuff there, but it felt a little archaic next to perl6

[20:35] <cygx> psch: now that I fixed my TinyCC module, I can add a EVAL :lang<C>, but it's only useful if you can pass in symbols to store your results

[20:35] <lizmat> cygx: spectesting now

[20:36] <TimToady> m: my &f = &prefix:<-«>; say f((2,3,4))

[20:36] <camelia> rakudo-moar 74ff31: OUTPUT«(-2 -3 -4)␤»

[20:37] <psch> cygx: oh, of course, that's probably the obvious use-case, EVAL-ing a language outside of the current compiler

[20:37] <TimToady> m: my &f = &postfix:<»i>; say f((2,3,4))

[20:37] <camelia> rakudo-moar 74ff31: OUTPUT«(0+2i 0+3i 0+4i)␤»

[20:37] <lizmat> m: multi sub EVAL(Capture:D $a) { dd $a }; EVAL \(42)   # looks like redispatch is busted ?

[20:37] <camelia> rakudo-moar 74ff31: OUTPUT«Type check failed in binding $code; expected Cool but got Capture␤  in block <unit> at /tmp/ACcImLr4rw:1␤␤»

[20:39] <cygx> lizmat: that should be by design - the proto expects a single Cool positional, and Capture ain't

[20:40] <lizmat> ah, duh  :-)

[20:42] <lizmat> $ 6 'multi sub EVAL(Cool:D $a, :$lang where $lang eq "C", *%a) { dd %a}; EVAL 42, :lang<C>, :42a'

[20:42] <lizmat> Hash $var = {:a(42)}

[20:42] <lizmat> that looks better

[20:44] *** lucasb left
[20:45] <tony-o> lizmat: the thread id changes even when using a supply, it changes to whatever the thread 'emit'ing data is

[20:45] *** nightfrog joined
[20:45] <lizmat> :-(

[20:46] <lizmat> then maybe a Channel, and a start block with a loop and a .receive ?

[20:46] <lizmat> then send to the channel 

[20:46] <lizmat> ?

[20:47] <tony-o> can't reliably .receive on a thread that isn't the same as the thread that created the socket either

[20:47] <tony-o> nor .write 

[20:47] *** kjs_ left
[20:48] <lizmat> argh... well, perhaps using Inline::Perl5, with in there an Inline::Perl6 ?

[20:48] <lizmat> nah

[20:48] <lizmat> I guess we'll have to wait for jnthn's IO work

[20:49] <cygx> .oO(just use NativeCall to start another moarvm instance)

[20:49] <dalek> rakudo/nom: 4e45f0e | lizmat++ | src/core/control.pm:

[20:49] <dalek> rakudo/nom: EVAL passes on unknown named parameters

[20:49] <dalek> rakudo/nom: 

[20:49] <dalek> rakudo/nom: cygx++ for pointing out we need that

[20:49] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/4e45f0e2e2

[20:50] *** sufrostico joined
[20:50] <cygx> lizmat++

[20:52] *** kmel left
[20:53] <tony-o> cygx: lol.

[20:57] *** ^elyse^ joined
[20:57] <nine> Sometimes I think the hardest problems in the curli branch are finding out what the next obvious step is

[20:57] *** sufrostico left
[20:58] <lizmat> nine++  # for having the courage to work on curli branch

[20:58] *** sufrostico joined
[20:59] <nine> lizmat: you started it :) And showed me that just pasting code from jnthn++'s gist is already progress

[21:00] <[Coke]> lizmat++ nine++

[21:05] <dalek> roast: 3235bf1 | usev6++ | S06-advanced/wrap.t:

[21:05] <dalek> roast: Unfudge passing test for rakudo.jvm

[21:05] <dalek> roast: review: https://github.com/perl6/roast/commit/3235bf1466

[21:07] *** jkva_ joined
[21:09] *** jkva left
[21:12] *** skids left
[21:19] <dalek> rakudo/nom: 2e19ebe | lizmat++ | src/core/Str.pm:

[21:19] <dalek> rakudo/nom: Slightly faster Str.encode

[21:19] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/2e19ebe0f5

[21:22] *** s_kilk joined
[21:30] <lizmat> m: class A { has $.a; method gist(A:D:) { $!a } }; A.gist   # invocant smiley is ignored if not a multi   :-(

[21:30] <camelia> rakudo-moar 4e45f0: OUTPUT«Invocant requires an instance of type A, but a type object was passed.  Did you forget a .new?␤  in method gist at /tmp/jBAZ4pw7DY:1␤  in block <unit> at /tmp/jBAZ4pw7DY:1␤␤»

[21:31] <lizmat> feels like it should at least warn about the useless invocant signature

[21:35] *** leont joined
[21:38] <dalek> roast: a36a534 | lizmat++ | S02-types/WHICH.t:

[21:38] <dalek> roast: Add checks for TypeObject.perl/gist

[21:38] <dalek> roast: 

[21:38] <dalek> roast: Typically, when adding a .perl or .gist to a class, one forgets either

[21:38] <dalek> roast: to handle the :U case, or one didn't make it a multi method with the

[21:38] <dalek> roast: correct :D signature (in which case the Mu:U candidate will take care

[21:38] <dalek> roast: of it)

[21:38] <dalek> roast: review: https://github.com/perl6/roast/commit/a36a534626

[21:40] *** jkva_ left
[21:41] *** ^elyse^ left
[21:42] *** atweiden left
[21:43] <nine> Ok, I think my challenge for the weekend will be to make Perl6::ModuleLoader::load_module return a CompUnit

[21:46] <lizmat> m: say Nil.gist   # is there a specific reason why this is not (Nil) ?

[21:46] <camelia> rakudo-moar 4e45f0: OUTPUT«Nil␤»

[21:47] <lizmat> it would be more consistent with e.g.

[21:47] <lizmat> m: say Mu.gist

[21:47] <camelia> rakudo-moar 4e45f0: OUTPUT«(Mu)␤»

[21:52] *** _dolmen_ joined
[21:52] <nine> How many copies of the module loading code are there? I've found quite similar things now in CompUnitRepo, Perl6::ModuleLoader and NQP's ModuleLoader

[21:53] <nine> And NQP's is duplicated for every VM :/

[21:56] *** Zoffix left
[21:56] *** sufrostico left
[21:56] *** rindolf left
[21:56] <lizmat> nine: welcome to the hell that is loading code  :-)

[21:57] <lizmat> the ones in CompUnitRepo can go, if not used in the curli branch

[21:57] *** mattp___ joined
[21:57] <lizmat> they were my attempt at what is now being done in the curli branch

[21:58] <dalek> rakudo/nom: 94ce3cf | lizmat++ | src/core/Nil.pm:

[21:58] <dalek> rakudo/nom: Remove special casing of Nil.gist

[21:58] <dalek> rakudo/nom: 

[21:58] <dalek> rakudo/nom: This makes Nil.gist now appear as '(Nil)' instead of 'Nil', more

[21:58] <dalek> rakudo/nom: in line with all other type objects.  Also handles fallout of

[21:58] <dalek> rakudo/nom: changes to S02-types/WHICH.t tests.

[21:58] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/94ce3cf4f6

[21:58] <dalek> rakudo/nom: 36c4c6a | lizmat++ | src/core/ (2 files):

[21:58] <dalek> rakudo/nom: Fallout of additional tests in S02-types/WHICH.t

[21:58] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/36c4c6a5f0

[21:58] <dalek> roast: 4cfd974 | lizmat++ | S0 (4 files):

[21:58] <dalek> roast: Fix fallout of Nil.gist change

[21:58] <dalek> roast: review: https://github.com/perl6/roast/commit/4cfd97480f

[21:59] *** muraiki left
[21:59] <lizmat> m: class A { has $.a; method gist(Int:D:) { $!a } }; A.gist   # invocant smiley is ignored if not a multi   :-(

[21:59] <camelia> rakudo-moar 2e19eb: OUTPUT«Type check failed in binding <anon>; expected Int but got A␤  in method gist at /tmp/AfZO2yeTj7:1␤  in block <unit> at /tmp/AfZO2yeTj7:1␤␤»

[22:00] <lizmat> that should probably be a compile time error

[22:00] <lizmat> m: class A { has $.a; method gist(Int:) { $!a } }; A.gist 

[22:00] <camelia> rakudo-moar 2e19eb: OUTPUT«Type check failed in binding <anon>; expected Int but got A␤  in method gist at /tmp/ufwv1H5sTm:1␤  in block <unit> at /tmp/ufwv1H5sTm:1␤␤»

[22:01] <timotimo> 0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000       sbnmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm

[22:02] <timotimo> excuse the cat, please

[22:03] <lizmat> .botsnack

[22:03] <yoleaux> :D

[22:03] <synbot6> om nom nom

[22:03] <lizmat> excuse the bot, please  :-)

[22:03] *** mattp___ left
[22:03] <itz_stmuk> cats++ # generating PGP entropy

[22:03] *** mattp_ joined
[22:04] <lizmat> added #126506 for the only method sig issue

[22:04] <synbot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=126506

[22:08] <psch> j: m: class A { has $.a; method gist(Int:D:) { $!a } }; A.gist

[22:08] <camelia> rakudo-jvm 2e19eb: OUTPUT«Type check failed in binding <anon>; expected Int but got A␤  in method gist at /tmp/eIKNy6dY7w:1␤  in block <unit> at /tmp/eIKNy6dY7w:1␤␤»

[22:09] <psch> lizmat: isn't our MMD always runtime because of mixins all that jazz?

[22:09] <AlexDaniel> m: [4, 8, 15, 16, 23][* - 42];

[22:09] <camelia> rakudo-moar 2e19eb: OUTPUT«Effective index out of range. Is: -37, should be in 0..Inf␤  in block <unit> at /tmp/W25oE3FzzP:1␤␤Actually thrown at:␤  in block <unit> at /tmp/W25oE3FzzP:1␤␤»

[22:10] <AlexDaniel> hm, it still mentions inf

[22:10] <lizmat> yeah, but my point is that if you have an non-multi method in a class, that it will *always* be called, even if there are better matching multi's out there

[22:10] * psch is reminded of the .? discussion with zostay

[22:10] <lizmat> assuming this is intentional, then it can know at compile time the method has a sig that will never match

[22:10] <psch> lizmat: ooh, right.  if we know we have only a not-multi hanging there we could opt it, yes

[22:11] <psch> lizmat: oh, but shadowing through children..?  is that an argument against it?

[22:11] <AlexDaniel> lizmat: wait, what's the difference between "index out of range" and "effective index out of range"?

[22:11] * psch really isn't sure and will probably stop thinking about this in a bit...

[22:11] <lizmat> AlexDaniel: the word "effective" ?

[22:11] <AlexDaniel> lizmat: yeah, which means? :)

[22:12] <lizmat> well, the *-1 is a "virtual" index that translates to an effective index

[22:12] <lizmat> which is actually used to index

[22:12] <AlexDaniel> oooh

[22:12] <AlexDaniel> right!

[22:12] <AlexDaniel> ok

[22:12] <lizmat> into the array

[22:13] <lizmat> m: [4, 8, 15, 16, 23][-42];

[22:13] <camelia> rakudo-moar 2e19eb: OUTPUT«5===SORRY!5=== Error while compiling /tmp/h3lizJI0yh␤Unsupported use of a negative -42 subscript to index from the end; in Perl 6 please use a function such as *-42␤at /tmp/h3lizJI0yh:1␤------> 3[4, 8, 15, 16, 23][-42]7⏏5;␤»

[22:13] <lizmat> m: (4, 8, 15, 16, 23)[*-42];

[22:13] <camelia> rakudo-moar 2e19eb: OUTPUT«Effective index out of range. Is: -37, should be in 0..Inf␤  in block <unit> at /tmp/DyxznUcP4G:1␤␤Actually thrown at:␤  in block <unit> at /tmp/DyxznUcP4G:1␤␤»

[22:13] <lizmat> ok, in the List case, the Inf is actually wrong

[22:14] <lizmat> m: (4, 8, 15, 16, 23)[42;

[22:14] <camelia> rakudo-moar 2e19eb: OUTPUT«5===SORRY!5=== Error while compiling /tmp/ITRlueSQoT␤Unable to parse expression in subscript; couldn't find final ']' ␤at /tmp/ITRlueSQoT:1␤------> 3(4, 8, 15, 16, 23)[42;7⏏5<EOL>␤»

[22:14] <lizmat> m: (4, 8, 15, 16, 23)[42];

[22:14] <camelia> rakudo-moar 2e19eb: ( no output )

[22:14] <lizmat> hmmm... maybe not

[22:15] <lizmat> hmmm... a List being immutable, shouldn't that at least warn about accessing out of bounds elements ?

[22:15] <psch> m: class A { method f(Int:D:) { } }; class B is A { multi method f(B:D:) { } }; B.new.f # my point illustrated

[22:15] <camelia> rakudo-moar 2e19eb: ( no output )

[22:15] <psch> m: class A { method f(Int:D:) { } }; class B is A { multi method f(B:D:) { } }; B.new.f; A.can('f')[0](5) # expanded a bit

[22:15] <camelia> rakudo-moar 2e19eb: ( no output )

[22:16] *** diana_olhovik joined
[22:16] <psch> lizmat: i think that's the general reason for "no compile time opt on methods"

[22:17] <psch> lizmat: i recognize that that's the same argument from the other side, though.  for me this comes down to "people smarter than me thought about this a lot more than i did"

[22:17] <psch> so, sorry if this seems not-particularly-contributive

[22:17] <lizmat> well, you're thinking about it, that's quite a lot already!

[22:19] *** kaare_ left
[22:25] *** tokuhirom joined
[22:25] *** TEttinger joined
[22:28] *** _dolmen_ left
[22:29] *** tokuhirom left
[22:31] *** Begi1115 left
[22:31] *** rabie joined
[22:32] *** rabie left
[22:33] <dalek> ecosystem: dbeb33f | RabidGravy++ | META.list:

[22:33] <dalek> ecosystem: Add JSON::Marshal

[22:33] <dalek> ecosystem: 

[22:33] <dalek> ecosystem: https://github.com/jonathanstowe/JSON-Marshal

[22:33] <dalek> ecosystem: review: https://github.com/perl6/ecosystem/commit/dbeb33f636

[22:34] <RabidGravy> ^ so had to be done

[22:34] *** s_kilk left
[22:34] <tadzik> :D

[22:35] <raydiak> m: multi sub cross () {}

[22:35] <camelia> rakudo-moar 36c4c6: OUTPUT«(signal SEGV)»

[22:37] <raydiak> ^ was quite a golf...I'm assuming that should work and I ought to report it, yes?

[22:38] <RabidGravy> it should never segfault

[22:38] <lizmat> m: multi sub cross() {}

[22:38] <camelia> rakudo-moar 36c4c6: OUTPUT«(signal SEGV)»

[22:38] <lizmat> huh?

[22:38] <lizmat> m: multi sub cross() { ... }

[22:38] <camelia> rakudo-moar 36c4c6: OUTPUT«(signal SEGV)»

[22:38] <lizmat> m: multi sub cross { ... }

[22:38] <camelia> rakudo-moar 36c4c6: OUTPUT«(signal SEGV)»

[22:38] <lizmat> m: multi sub crosz { ... }

[22:38] <camelia> rakudo-moar 36c4c6: ( no output )

[22:38] <lizmat> m: multi sub cross { ... }

[22:38] <camelia> rakudo-moar 36c4c6: OUTPUT«(signal SEGV)»

[22:38] <lizmat> wow

[22:38] <lizmat> m: sub cross { ... }

[22:38] <camelia> rakudo-moar 36c4c6: ( no output )

[22:40] <lizmat> j: multi sub cross { ... }

[22:40] <camelia> rakudo-jvm 36c4c6: OUTPUT«===SORRY!===␤java.lang.RuntimeException: No such attribute '$!dispatchees' for this object␤»

[22:40] <lizmat> intresting

[22:42] *** diana_olhovik left
[22:45] <lizmat> good night, #perl6!

[22:50] *** pdcawley left
[22:54] *** softmoth left
[22:55] <flussence> m: multi cross{} # just for the golfing :D

[22:55] <camelia> rakudo-moar 36c4c6: OUTPUT«(signal SEGV)»

[22:57] *** pecastro_ joined
[23:00] *** Skarsnik left
[23:01] <raydiak> m: say &cross

[23:01] <camelia> rakudo-moar 36c4c6: OUTPUT«sub infix:<X> (| is raw) { #`(Sub+{<anon|57909456>}+{Precedence}|66044192) ... }␤»

[23:03] *** pmurias left
[23:03] *** kjs_ joined
[23:07] *** rangerprice left
[23:10] *** pmurias joined
[23:13] *** pippo left
[23:15] <flussence> here's a gdb bt for it, I've looked at the line it points to but it's way over my head: https://gist.github.com/flussence/fe3f1f829e3947b68d98

[23:17] <flussence> .oO( why can't gist.github use a simple, middle-click-paste-compatible *text* box instead of this js crud? sigh. )

[23:22] <AlexDaniel> flussence: yes :(

[23:25] *** pippo joined
[23:27] *** firstdayonthejob left
[23:27] *** skids joined
[23:29] <pippo> .tell azawawi Found an asymmetric line in WebElement.pm6. In method "selected". Should the "element/$.id/selected" be "element/$($.id)/selected". Did not go through the code. Only asymmetry is bugging me. o/ 

[23:29] <yoleaux> pippo: I'll pass your message to azawawi.

[23:30] *** pippo left
[23:38] *** kjs_ left
[23:43] *** vkay1 joined
[23:44] *** vkay1 left
[23:46] *** BenGoldberg joined
[23:46] <cygx> it took some fidling to make precompilation work, but here it is - EVAL :lang<C> via TinyCC: https://github.com/cygx/p6-tinycc/blob/master/t/05-eval.t

[23:48] <TimToady> cygx++

