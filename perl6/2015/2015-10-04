[00:03] *** mattprelude left
[00:03] *** tokuhiro_ left
[00:06] <timotimo> were you able to get some kind of measurement for performance?

[00:06] *** AlexDaniel joined
[00:10] <timotimo> it seems to react faster on my end

[00:22] *** timbunce_ left
[00:22] *** timbunce__ joined
[00:26] *** Dojk joined
[00:27] *** rivarun left
[00:27] *** Dojk left
[00:28] *** rivarun joined
[00:30] <atweiden> from inside a grammar's Actions class, is it possible to retroactively cause a regex match to fail?

[00:30] <atweiden> or is that only possible to do in a closure inside the regex?

[00:31] <atweiden> e.g. http://ix.io/laC

[00:31] *** bjz left
[00:42] *** leont left
[00:49] *** bjz joined
[00:52] <ShimmerFairy> atweiden: you can use <?{ ... }> inside a regex to test for a true condition (and use <!{ ... }> for a false condition)

[00:52] <ShimmerFairy> m: say "foo" ~~ /(\w+) <?{$0 ~~ "foo"}>/

[00:52] <camelia> rakudo-moar c52b0b: OUTPUT«｢foo｣␤ 0 => ｢foo｣␤»

[00:52] <ShimmerFairy> m: say "bar" ~~ /(\w+) <?{$0 ~~ "foo"}>/

[00:52] <camelia> rakudo-moar c52b0b: OUTPUT«Nil␤»

[00:53] <ShimmerFairy> I'm not entirely sure how you'd do it from within an actions method, I suspect you'd probably have to mess with the actual Cursor object at that point.

[00:56] <atweiden> ShimmerFairy: ty, what would manipulating the Cursor object look like in practice?

[00:57] <ShimmerFairy> I don't know for sure, it'd probably end up being  $/.CURSOR.'!fail_cursor'()  to cause a failure. But I've never had to manipulate the cursor directly, so I'm not a good source of info for that :)

[00:58] *** timbunce__ left
[00:58] <ShimmerFairy> atweiden: most of the time though, if your regex still has a chance to fail, there's a way to do the check inside the regex, without having to do in the actions (at least, I've never had to resort to making a cursor fail in the actions side)

[00:59] <atweiden> hmm, cursor appears undefined inside Actions class

[00:59] *** bjz left
[00:59] *** timbunce_ joined
[01:00] <ShimmerFairy> note that you get the cursor via (Match object).CURSOR, and a lot of the methods on Cursor need to be quoted to call them, due to some oddity with how !private method names are handled in NQP.

[01:00] * ShimmerFairy afk for a while

[01:01] *** vvz left
[01:04] *** adhoc left
[01:06] *** vendethiel joined
[01:07] *** abaugher left
[01:08] *** abaugher joined
[01:15] *** ggoebel2 joined
[01:16] *** ggoebel left
[01:16] *** bjz joined
[01:29] *** vendethiel left
[01:31] *** roguelazer left
[01:31] *** preyalone left
[01:31] *** chansen_ left
[01:32] *** adhoc joined
[01:32] *** avalenn_ left
[01:32] *** mephinet- left
[01:32] *** avalenn joined
[01:33] *** mprelude left
[01:33] *** mephinet joined
[01:33] *** samb1 left
[01:33] *** roguelazer joined
[01:34] *** preyalone joined
[01:34] *** chansen_ joined
[01:35] *** mprelude joined
[01:35] *** mr_ron left
[01:35] *** samb1 joined
[01:46] *** mr_ron joined
[02:00] *** dha joined
[02:00] *** obra joined
[02:01] *** rhr joined
[02:04] <dalek> doc: f5f915a | (David H. Adler)++ | lib/Type/ (2 files):

[02:04] <dalek> doc: Added usage statements to Attribute.pod and Backtrace/Frame.pod

[02:04] <dalek> doc: review: https://github.com/perl6/doc/commit/f5f915a412

[02:09] <dalek> doc: 7a5339f | (David H. Adler)++ | lib/Type/Enum.pod:

[02:09] <dalek> doc: Added usage statements to Enum.pod

[02:09] <dalek> doc: review: https://github.com/perl6/doc/commit/7a5339fa21

[02:09] <dalek> doc: 5f093cd | (David H. Adler)++ | lib/Type/Enum.pod:

[02:09] <dalek> doc: Merge branch 'usage_statements'

[02:09] <dalek> doc: 

[02:09] <dalek> doc: With usage statements for Enum.pod

[02:09] <dalek> doc: review: https://github.com/perl6/doc/commit/5f093cd0ee

[02:14] *** aborazmeh joined
[02:14] *** aborazmeh left
[02:14] *** aborazmeh joined
[02:17] <dha> So... the two signatures for C<await> in Channel.pod are "multi sub await(Channel:D)" and "multi sub await(*@)". I assume that second signature means it takes a list. Is it a list of Channels? Or could it be a list of anything?

[02:20] <dha> The following docs indicate that it takes one or more channels, but the signature seems inspecific.

[02:23] <dalek> doc/usage_statements: 7a5339f | (David H. Adler)++ | lib/Type/Enum.pod:

[02:23] <dalek> doc/usage_statements: Added usage statements to Enum.pod

[02:23] <dalek> doc/usage_statements: review: https://github.com/perl6/doc/commit/7a5339fa21

[02:23] <dalek> doc/usage_statements: 088e9a8 | (David H. Adler)++ | lib/Type/C (2 files):

[02:23] <dalek> doc/usage_statements: Added usages statements to Capture.pod and Channel.pod

[02:23] <dalek> doc/usage_statements: review: https://github.com/perl6/doc/commit/088e9a8796

[02:25] <dalek> doc: 088e9a8 | (David H. Adler)++ | lib/Type/C (2 files):

[02:25] <dalek> doc: Added usages statements to Capture.pod and Channel.pod

[02:25] <dalek> doc: review: https://github.com/perl6/doc/commit/088e9a8796

[02:25] <dalek> doc: 119dd07 | (David H. Adler)++ | lib/Type/C (2 files):

[02:25] <dalek> doc: Merge branch 'usage_statements'

[02:25] <dalek> doc: 

[02:25] <dalek> doc: Adding usage statements for Capture.pod and Channel.pod

[02:25] <dalek> doc: review: https://github.com/perl6/doc/commit/119dd07535

[02:29] *** skids joined
[02:29] *** salva left
[02:30] *** salva joined
[02:31] *** noganex_ joined
[02:34] *** noganex left
[02:35] *** dha left
[02:36] *** dha joined
[02:36] *** dha left
[02:39] <ShimmerFairy> dha: Probably because you can't currently place a type constraint on a slurpy, but I'd put it in anyway for documentation purposes :)

[02:48] *** cognominal left
[02:49] *** kid51 left
[03:00] *** aborazmeh left
[03:11] *** Xor_ joined
[03:16] *** lizmat_ joined
[03:17] *** PerlJam left
[03:18] *** rivarun left
[03:19] *** Kcop left
[03:19] *** perlpilot joined
[03:19] *** pink_mist left
[03:19] *** Exodist left
[03:19] *** BenGoldberg left
[03:19] *** lizmat left
[03:19] *** Woodi left
[03:20] *** pink_mist joined
[03:20] *** Woodi joined
[03:21] *** pink_mist left
[03:21] *** pink_mist joined
[03:21] *** raiph joined
[03:21] *** Exodist joined
[03:21] *** rivarun joined
[03:37] *** mr_ron left
[03:51] *** timbunce__ joined
[03:52] *** timbunce_ left
[03:54] *** laouji joined
[04:10] *** mr_ron joined
[04:24] *** jordman left
[04:24] *** vvz joined
[04:24] *** jordman joined
[04:53] *** khw left
[04:56] *** tokuhiro_ joined
[04:57] *** mr_ron left
[05:00] *** tokuhiro_ left
[05:04] *** mr_ron joined
[05:07] *** raiph left
[05:12] *** vvz left
[05:17] *** z448 joined
[05:21] *** z448 left
[05:26] *** kaare__ joined
[05:29] *** bjz left
[05:32] *** bjz joined
[05:48] <TimToady> m: my $s = 'o⃗'; say $s ~~ m:m/o/;

[05:48] <camelia> rakudo-moar c52b0b: OUTPUT«False␤»

[05:48] <TimToady> something busted there

[05:49] <TimToady> m: my $s = 'o⃗'; $s ~~ s:mm/o/p/; say $s

[05:49] <camelia> rakudo-moar c52b0b: OUTPUT«5===SORRY!5=== Error while compiling /tmp/yVsRpIk248␤Adverb mm not allowed on substitution␤at /tmp/yVsRpIk248:1␤------> 3my $s = 'o⃗'; $s ~~ s:mm/o/p/7⏏5; say $s␤»

[05:49] <TimToady> and very busted there

[05:49] <ShimmerFairy> star-m: my $s = 'o⃗'; say $s ~~ m:m/o/;

[05:49] <camelia> star-m 2015.03: OUTPUT«5===SORRY!5=== Error while compiling /tmp/VgyqNhZ4ud␤Adverb m not allowed on m␤at /tmp/VgyqNhZ4ud:1␤------> 3my $s = 'o⃗'; say $s ~~ m:m/o/7⏏5;␤»

[05:49] <TimToady> m: my $s = 'o⃗'; $s ~~ s:samemark/o/p/; say $s

[05:49] <camelia> rakudo-moar c52b0b: OUTPUT«5===SORRY!5=== Error while compiling /tmp/1A_uVYF5Ze␤Adverb samemark not allowed on substitution␤at /tmp/1A_uVYF5Ze:1␤------> 3my $s = 'o⃗'; $s ~~ s:samemark/o/p/7⏏5; say $s␤»

[05:51] <TimToady> m: my $s = 'o⃗'; say $s ~~ m:ignoremark/o/;

[05:51] <camelia> rakudo-moar c52b0b: OUTPUT«False␤»

[05:51] *** mr_ron left
[05:52] <ShimmerFairy> m: say "ä" ~~ m:m/a/

[05:52] *** mr_ron joined
[05:52] <camelia> rakudo-moar c52b0b: OUTPUT«｢ä｣␤»

[05:52] <ShimmerFairy> m: my $s = "ä"; $s ~~ s:mm/a/o/; say $s

[05:52] <camelia> rakudo-moar c52b0b: OUTPUT«5===SORRY!5=== Error while compiling /tmp/pXruGBiidi␤Adverb mm not allowed on substitution␤at /tmp/pXruGBiidi:1␤------> 3my $s = "ä"; $s ~~ s:mm/a/o/7⏏5; say $s␤»

[05:53] <ShimmerFairy> TimToady: for :m at least, I think it doesn't handle certain graphemes very well (I very faintly recall seeing it a while back, but I'm not sure)

[05:54] <ShimmerFairy> m: say "o".samemark("ä")

[05:54] <camelia> rakudo-moar c52b0b: OUTPUT«Method 'samemark' not found for invocant of class 'Str'␤  in block <unit> at /tmp/I5qPW4ZtBk:1␤␤»

[05:54] <ShimmerFairy> the method doesn't even exist, no wonder :mm doesn't work.

[05:56] <TimToady> coulda sworn that was implemented, but maybe it was pugs or niecza

[05:58] <ShimmerFairy> I'm kinda surprised myself. I wonder if nqp has the opcodes to make it non-painful...

[05:59] *** crux left
[06:06] <dalek> specs: 1847780 | ShimmerFairy++ | / (3 files):

[06:06] <dalek> specs: Remove contents.pod

[06:06] <dalek> specs: 

[06:06] <dalek> specs: It's been very infrequently updated, nothing on design.perl6.org links

[06:06] <dalek> specs: to it, and while syntactically valid, wasn't a usefully formatted file.

[06:06] <dalek> specs: So it's been removed, and I suspect it won't bother anyone.

[06:06] <dalek> specs: review: https://github.com/perl6/specs/commit/1847780fee

[06:07] *** atweiden left
[06:13] *** AlexDaniel left
[06:17] *** FROGGS[mobile] joined
[06:18] <FROGGS[mobile]> .tell atweiden look at method _ws in rakudo/src/Perl6/Grammar.nqp

[06:18] <yoleaux> FROGGS[mobile]: I'll pass your message to atweiden.

[06:26] *** rurban joined
[06:36] <FROGGS[mobile]> I am working on a patch that fixes 'my Int:D $foo'... should a 'Int:flubber' complain about an unknown colonpair/refinement?

[06:37] <FROGGS[mobile]> jnthn: ^^

[06:37] <ShimmerFairy> FROGGS[mobile]: I should think so, I imagine it's only ignored as a lazy way of implementing :_  :P

[06:38] *** domidumont joined
[06:39] <FROGGS[mobile]> k

[06:40] *** mr_ron left
[06:40] <ShimmerFairy> FROGGS[mobile]: or in other words, I can't imagine why silently pretending it's :_ could be useful for anyone.

[06:40] *** skids left
[06:42] *** domidumont left
[06:43] *** domidumont joined
[06:49] *** labster left
[06:50] *** labster joined
[06:53] *** labster left
[06:54] *** labster joined
[06:57] *** tokuhiro_ joined
[07:02] *** tokuhiro_ left
[07:02] *** mr_ron joined
[07:06] *** rindolf joined
[07:20] *** vendethiel joined
[07:40] <moritz> "unexpected type smiley :flubber"

[07:40] *** darutoko joined
[07:45] <ShimmerFairy> Does Perl 6 offer a way to know if a method is non-mutating? If not, then I don't really see how S26's proposed A<aliased-thing.method> can be made to work safely.

[07:45] <ShimmerFairy> (Since A<> claims to allow the calling of 'non-mutating' methods)

[07:48] <[Tux]> test             50000    35.839    35.723

[07:48] <[Tux]> test-t           50000    36.946    36.830

[07:48] <[Tux]> http://tux.nl/Talks/CSV6/test-t.jpg

[07:50] <[Tux]> http://tux.nl/Talks/CSV6/speed4.html

[07:50] *** mr_ron left
[07:50] *** mr_ron joined
[08:03] <moritz> masak: fwiw 007 is on the hackernews front page

[08:22] *** araujo left
[08:25] *** xfix joined
[08:28] *** vendethiel left
[08:36] *** mr_ron left
[08:38] *** mr_ron joined
[08:43] *** mattprelude joined
[08:49] *** rindolf left
[08:58] *** rindolf joined
[08:59] *** tokuhiro_ joined
[09:03] *** tokuhiro_ left
[09:16] <lizmat_> good *, #perl6!

[09:18] *** RabidGravy joined
[09:19] *** spider-mario joined
[09:23] *** vvz joined
[09:24] <moritz> \o lizmat_ 

[09:25] *** rurban left
[09:25] *** rurban joined
[09:26] *** mr_ron left
[09:28] *** darutoko- joined
[09:31] *** darutoko left
[09:31] *** darutoko joined
[09:32] *** darutoko- left
[09:33] *** rurban left
[09:38] *** mr_ron joined
[09:43] *** rurban joined
[10:15] *** ggoebel joined
[10:16] *** ggoebel2 left
[10:20] *** leont joined
[10:26] *** mr_ron left
[10:27] <jnthn> ShimmerFairy: The "is pure" trait could be placed on a method to indicate that

[10:29] <jnthn> FROGGS[mobile]: Are you just making `my Foo:D $x` just be a "NYI" error? But anyway, for things we don't have a clue what are I'd just have the error like "Don't understand :flubber in this context" or so

[10:29] * jnthn figures our NYI errors should get "in 6.christmas" added on to them

[10:31] <nine> For those interested in the parse time regression: https://gist.github.com/niner/a66fb2caf1f0d0fb0c6f

[10:33] <jnthn> nine++

[10:34] *** lizmat_ is now known as lizmat

[10:36] <lizmat> hmmm... seems timotimo's patch causes some serious spectest issues?

[10:39] <leont> I'm getting a «Cannot assign to a readonly variable or a value» exception on «make $/.Str.subst(/ <[\ \t]>+ $/, '');», I don't get what's going on

[10:40] <nine> m: sub foo { my $s = 0; ($s += $_ for 1..3) }; say foo()

[10:40] <camelia> rakudo-moar c52b0b: OUTPUT«(6 6 6)␤»

[10:40] <nine> m: sub foo { my $s = 0; for 1..3 { $s += $_ } }; say foo()

[10:40] <camelia> rakudo-moar c52b0b: OUTPUT«Nil␤»

[10:41] *** mr_ron joined
[10:41] <nine> m: sub foo { my $s = 0; ($s++ for 1..3) }; say foo()

[10:41] <camelia> rakudo-moar c52b0b: OUTPUT«(0 1 2)␤»

[10:48] <psch> hi #perl6 o/

[10:48] <psch> something funny about sigil'd constants: https://gist.github.com/peschwa/f07328a66ecaecb470bb

[10:49] <FROGGS[mobile]> jnthn: I'm making it work

[10:50] <psch> it still works right with BEGIN, which makes me stumble 'cause i have no idea where to look

[10:50] <psch> maybe the way i'm trying to get a compile time value is wrong, i suppose

[10:56] <psch> yeah, unbox to the rescue \o/

[10:57] <leont> Huh, now I'm really confused

[10:58] <leont> My method TOP is being run, yet parse returns a Any?

[10:59] <moritz> leont: then most likely it did not match

[10:59] <leont> Inside the method TOP, the match object is looking fine, yet next step in the debugger it's not

[11:01] *** AlexDaniel joined
[11:02] <moritz> nopaste the code?

[11:02] <leont> Ah, now I understand. It matches, but fails because parse wants to match until the end of the string

[11:04] <psch> m: sub infix:(+-) { say $^a, $^b }; 5 +- 6 # misparsed as signature..?

[11:04] <camelia> rakudo-moar c52b0b: OUTPUT«5===SORRY!5=== Error while compiling /tmp/e_YNMY6cek␤Malformed parameter␤at /tmp/e_YNMY6cek:1␤------> 3sub infix:(+7⏏5-) { say $^a, $^b }; 5 +- 6 # misparsed ␤    expecting any of:␤        constraint␤»

[11:05] *** pmurias joined
[11:06] <psch> hm, the infix:() form only appears on RT, can't find it in the specs repo

[11:06] <moritz> psch: even if it were designed and implemented, it would need tobe infix:('+-')

[11:06] <moritz> because () don't quote

[11:07] <psch> moritz: yeah, right

[11:07] <psch> moritz: well, i'll not-implement it as it's not designed... :)

[11:08] <psch> m: sub infix:('+-') { say $^a, $^b }; 5 +- 6 # probably still should complain about *something* here

[11:08] <camelia> rakudo-moar c52b0b: OUTPUT«WARNINGS:␤Useless use of "+" in expression "5 +- " in sink context (line 1)␤»

[11:09] *** ely-se joined
[11:09] *** Peter_R joined
[11:14] <psch> m: &infix:('+')(1,2).say # this also doesn't appear in specs anymore, which means #68024 can be closed (or converted to LTA if we want a different error there...)

[11:14] <camelia> rakudo-moar c52b0b: OUTPUT«5===SORRY!5=== Error while compiling /tmp/ojxvvSZuB7␤You can't adverb ␤at /tmp/ojxvvSZuB7:1␤------> 3&infix:('+')7⏏5(1,2).say # this also doesn't appear in ␤»

[11:24] *** aborazmeh joined
[11:24] *** aborazmeh left
[11:24] *** aborazmeh joined
[11:26] <leont> Is there a way to match true iff the current rule has matched >0 characters?

[11:27] <moritz> leont: .

[11:27] <moritz> leont: or .+

[11:27] <moritz> or an assertion that checks $/.chars

[11:27] <leont> $/.chars is probably what I need

[11:28] <ShimmerFairy> m: "foo" ~~ / f { say $/.chars } oo /

[11:28] <camelia> rakudo-moar c52b0b: OUTPUT«1␤»

[11:28] <ShimmerFairy> I'd be more inclined with $/.to or $¢.pos myself :)

[11:29] *** Ybro joined
[11:29] *** Ybro left
[11:29] *** mr_ron left
[11:30] <leont> ShimmerFairy: I don't think those would be correct in a multi-rule grammar

[11:30] *** mr_ron joined
[11:30] <ShimmerFairy> leont: why not?

[11:30] <leont> It'd give a non-zero position if a previous rule already has matched characters

[11:31] *** cognominal joined
[11:31] <ShimmerFairy> ah, right

[11:32] <jnthn> FROGGS[mobile]: Ah, I was gonna leave it for 6.d 'cus I wanted to do it by actually having :D/:U be first-class types. Trouble is that otherwise you end up with holes, like what happens when assigning through a pseudo-package, etc.

[11:34] <ShimmerFairy> .oO(emotypecons)

[11:41] *** patrickz joined
[11:43] <moritz> .tell colomon http://smoke.perl6.org/report shows a T for IO::Notification::Recursive, even though that repo has no tests; should that be a P instead?

[11:43] <yoleaux> moritz: I'll pass your message to colomon.

[11:44] *** raz9r joined
[11:45] *** patrickz left
[11:50] *** kid51 joined
[11:54] * leont may be observing a rules engine reentrancy bug, is such an issue recently known?

[11:56] *** kaare__ left
[11:57] <leont> Doing a subst inside of an action gives me «Cannot assign to a readonly variable or a value»

[11:57] <moritz> leont: the only gotcha that I'm aware of in that direction is that if you have a $/ declared (for example because you're in an action method), you cannot regex-match, because your $/ is read-only

[11:58] <moritz> it helps to give the parameter a different name (like $m instead of $/)

[11:59] <dalek> rakudo/nom: b06d30d | lizmat++ | src/core/ (2 files):

[11:59] <dalek> rakudo/nom: Refactor fail/die again

[11:59] <dalek> rakudo/nom: 

[11:59] <dalek> rakudo/nom: Alas, 2e92038e92c46fa7ec9e introduced quite some spectest errors.

[11:59] <dalek> rakudo/nom: This commit goes back to using CALLER::CALLER:: PseudoStash Perl6

[11:59] <dalek> rakudo/nom: objects, rather than the lowlevel NQP objects that do not support

[11:59] <dalek> rakudo/nom: things like EXISTS-KEY.  But instead of before, it will only be doing

[11:59] <dalek> rakudo/nom: a CALLER::CALLER:: once.  And to further improve performance, the

[11:59] <dalek> rakudo/nom: parameterless fail/die are not separate candidates, hopefully make it

[11:59] <dalek> rakudo/nom: easier to inline.

[11:59] <dalek> rakudo/nom: 

[11:59] <dalek> rakudo/nom: Unfortunately, this causes 3 (new) spectest failures, but all failing

[11:59] <dalek> rakudo/nom: tests seem suspect to me, so I'm putting this in rather than just

[11:59] <dalek> rakudo/nom: revert 2e92038e92c46fa7ec9e .

[11:59] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/b06d30decf

[12:00] <leont> Yes, that does seem to help

[12:02] *** pmurias_ joined
[12:03] <leont> It is a rather surprising issue though

[12:03] *** pmurias_ left
[12:03] <leont> And it did used to work until fairly recently, it doesn't make sense for me for Str.subst to populate $/

[12:04] <leont> Might just be me

[12:04] <dalek> nqp: c28a669 | (Pawel Murias)++ | / (3 files):

[12:04] <dalek> nqp: [js] Serialize variable length integers up to 32bit.

[12:04] <dalek> nqp: 

[12:04] <dalek> nqp: Add a unit test for that.

[12:04] <dalek> nqp: review: https://github.com/perl6/nqp/commit/c28a6691a2

[12:05] <jnthn> leont: I think the reason it does want to set $/ is so that .subst(/pattern/, { $0 }) works; otherwise for $0 to work you'd have to write -> $/ { $0 }

[12:05] <leont> Right

[12:06] <leont> Also, can't make sense out of an «Cannot bind attributes in a type object» error

[12:07] *** Xor_ left
[12:07] <leont> I've reduced the line it points to to «return $ret» and it still complains :-s

[12:07] *** travis-ci joined
[12:07] <travis-ci> NQP build failed. Pawel Murias '[js] Serialize variable length integers up to 32bit.

[12:07] <travis-ci> https://travis-ci.org/perl6/nqp/builds/83547070 https://github.com/perl6/nqp/compare/71dbe59947d8...c28a6691a2f2

[12:07] *** travis-ci left
[12:11] <leont> Ah, it's make that's still assuming $/, of course

[12:12] <lizmat> cycling&

[12:12] * leont doesn't like this work-around

[12:14] *** BenGoldberg joined
[12:14] *** mr_ron left
[12:29] *** diana_olhovik_ joined
[12:30] *** cognominal left
[12:30] *** aborazmeh left
[12:36] *** Xor_ joined
[12:37] <dalek> rakudo/nom: 53b8878 | peschwa++ | src/core/CompUnitRepo.pm:

[12:37] <dalek> rakudo/nom: Fix RT #126087.

[12:37] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/53b8878c95

[12:37] <dalek> rakudo/nom: d0885e5 | peschwa++ | src/ (3 files):

[12:37] <dalek> rakudo/nom: Implement bracket-delimited categorical sub declarations.

[12:37] <dalek> rakudo/nom: 

[12:37] <dalek> rakudo/nom: This fixes RT #119919. RT #117737 is related and still behaves the same, which

[12:37] <dalek> rakudo/nom: I would argue as correct in the first place - a bare regexp that matches a

[12:37] <dalek> rakudo/nom: single character is not a useful enough compile-time value to declare an

[12:37] <dalek> rakudo/nom: operator with. I've added a typed exception to be thrown in that case though.

[12:37] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/d0885e56e8

[12:37] <dalek> roast: 21a9ea0 | peschwa++ | S06-operator-overloading/sub.t:

[12:37] <dalek> roast: Add tests for RT #119919 and RT #117737.

[12:37] <dalek> roast: review: https://github.com/perl6/roast/commit/21a9ea0f2d

[12:48] *** domidumont left
[12:49] <psch> oh hrm

[12:49] <psch> that probably should've actually been two commits each

[13:00] *** araujo joined
[13:00] *** araujo left
[13:00] *** mr_ron joined
[13:03] *** pmurias_ joined
[13:05] *** Xor_ left
[13:06] <awwaiid> hm. I don't think I've ever seen infix:[something], instead always infix:<something>. Is there a doc that talks about that you can point me at?

[13:06] *** pmurias left
[13:07] <psch> awwaiid: http://design.perl6.org/S02.html#Extended_identifiers

[13:08] <psch> m: say &infix:['+'](2,3)

[13:08] <camelia> rakudo-moar d0885e: OUTPUT«5␤»

[13:09] *** Xor_ joined
[13:09] <psch> m: constant sym = "µ"; sub infix:[sym] { $^a ~ "µ" ~ $^b }; say 5 µ 5

[13:09] <camelia> rakudo-moar d0885e: OUTPUT«5µ5␤»

[13:09] <awwaiid> I get the feeling sometimes that there could secretly be a much smaller "language" that is perl6 and most things be defined inside of that. And I feel like nqp isn't quite that, but I'm pretty uneducated on nqp.

[13:09] <awwaiid> thanks psch

[13:11] <awwaiid> ahhh, I see. so the "<" and ">" in that are just like other quotelike <> things.

[13:12] <psch> m: constant sym = "µ"; sub infix:<<sym>> { $^a ~ "µ" ~ $^b }; say 5 µ 5 # this is still wrong i guess...

[13:12] <camelia> rakudo-moar d0885e: OUTPUT«5===SORRY!5=== Error while compiling /tmp/0q5U65pxNc␤Two terms in a row␤at /tmp/0q5U65pxNc:1␤------> 3infix:<<sym>> { $^a ~ "µ" ~ $^b }; say 57⏏5 µ 5 # this is still wrong i guess...␤    expecting any of:␤        infix␤        infix…»

[13:12] <psch> m: constant sym = "µ"; sub infix:<<sym>> { $^a ~ "µ" ~ $^b }; say 5 sym 5 # this is still wrong i guess...

[13:12] <camelia> rakudo-moar d0885e: OUTPUT«5µ5␤»

[13:13] <psch> m: my $a = "foo"; say <<$a>>

[13:13] <camelia> rakudo-moar d0885e: OUTPUT«(foo)␤»

[13:13] <psch> m: my $a = "foo"; say <<$a>>, <$a>

[13:13] <camelia> rakudo-moar d0885e: OUTPUT«foo$a␤»

[13:13] *** raz9r left
[13:13] <ShimmerFairy> m: constant sym = "μ"; say «sym»

[13:13] <camelia> rakudo-moar d0885e: OUTPUT«sym␤»

[13:13] <ShimmerFairy> not sure why you expected <<sym>> to work there :)

[13:13] <awwaiid> consistent at least

[13:14] <psch> huh

[13:14] <psch> m: constant $sym = "µ"; say <<$sym>>

[13:14] <camelia> rakudo-moar d0885e: OUTPUT«(µ)␤»

[13:14] <psch> m: constant $sym = "µ"; sub infix:<<$sym>> { $^a ~ "µ" ~ $^b }; say 5 µ 5 

[13:14] <camelia> rakudo-moar d0885e: OUTPUT«5===SORRY!5=== Error while compiling /tmp/flL4_S5FNd␤Colon pair value '$sym' too complex to use in name␤at /tmp/flL4_S5FNd:1␤------> 3constant $sym = "µ"; sub infix:<<$sym>>7⏏5 { $^a ~ "µ" ~ $^b }; say 5 µ 5␤    expecting any of:␤   …»

[13:15] <psch> well, something is somewhat inconsistent there i think

[13:15] <ShimmerFairy> psch: not really, how could you expect a bareword to interpolate?

[13:16] <psch> ShimmerFairy: no, that's not it.  the sigiled constant doesn't interpolate in infix:<<>>

[13:16] <psch> that is inconsistent

[13:17] <ShimmerFairy> psch: I'm not sure that's the case; I think it's complaining about the variable itself

[13:17] <psch> m: constant $sym = "µ"; sub infix:[$sym]($,$) { 42 }; say 5 µ 5

[13:17] <camelia> rakudo-moar d0885e: OUTPUT«42␤»

[13:18] *** Xor_ left
[13:18] <awwaiid> yeah, if htat works then infix:<<$sym>> should too

[13:18] *** Xor_ joined
[13:18] <ShimmerFairy> It may have something to do with the fact that «» does val() processing, but I can't be sure

[13:19] <ShimmerFairy> (since «» is a shortcut for qq:ww:v[...])

[13:19] <BenGoldberg> m: my $a = 'aaaa'; ($a ~~ s:1st:2nd:3rd /a/b/); $a.say;

[13:19] <camelia> rakudo-moar d0885e: OUTPUT«abaa␤»

[13:21] <psch> ShimmerFairy: nibble_to_str tries to handle &val, i'm checking if it maybe misses something...

[13:22] <awwaiid> ah! ok so I feel like infix should be more like s or q to be fully consistent. like infix<foo> instead of infix<foo>, just like rx<foo> or q<foo>. I think that's why I never noticed the quotelike for infix:<foo>

[13:24] <ShimmerFairy> psch: if I had to guess, it'd be someplace that chooses not to make use of nibble_to_str (ISTR some issues cropping up related to not piping nibbles through that)

[13:28] *** araujo joined
[13:29] *** araujo left
[13:31] *** raz9r joined
[13:31] *** Peter_R left
[13:31] *** raiph joined
[13:32] *** kaare__ joined
[13:32] <psch> no, nibbling is fine

[13:32] <psch> it's forbidding e.g. infx:[/./] that's a bit overzealous here

[13:32] <psch> +i

[13:32] *** araujo joined
[13:33] *** araujo left
[13:33] <psch> 'cause <<>> builds val(QAST::Var.Stringy.words.Slip)

[13:34] <psch> and atm it's implemented to only infix:<,> and &val for the QAST::Op case, which is apparently too restrictive :)

[13:36] <psch> so the question turns to "which values are obviously bogus"?

[13:36] <psch> i maintain that sub infix:[/./] { ... } is not a useful declaration, and will probably only make everything horrible if it was allowed :P

[13:36] <ShimmerFairy> I don't quite follow what the "it" is in "it's implemented to only..."

[13:37] <ShimmerFairy> and yeah, I feel a regex-y operator declaration is really begging for a slang more than a simple sub :)

[13:37] <psch> "it" is nibble_to_str

[13:37] <psch> https://github.com/rakudo/rakudo/blob/nom/src/Perl6/World.nqp#L2385 

[13:37] <ShimmerFairy> psch: ah, as I recall the &val handling was something I had to add, so it used to be just infix:<,> :P

[13:37] <psch> this else forbids infix:[/./]

[13:38] <psch> but it also forbids everything that's not infix:<,>...

[13:38] <psch> checking for specific WVals is probably overly bloat-y

[13:39] *** khw joined
[13:39] *** raz9r left
[13:40] <ShimmerFairy> psch: just to point out that the infix:<,> check has to do with how a :w-adverbed quote is constructed, which seems separate from your /./ issue

[13:40] * awwaiid re-reads about adverbial syntax and is slightly re-convinced about the : in infix:<foo>

[13:41] <psch> ShimmerFairy: https://gist.github.com/peschwa/d8bd05d9ea4f3f461d73 is $ast for infix:[/./]

[13:42] <ShimmerFairy> psch: ah, I think in that case going through nibble_to_str for the regex is wrong in the first place, unless you know how to magically convert a regex to the "correct" string :P

[13:42] <psch> ShimmerFairy: i actually want to die for things like a regex that don't have a meaningful enough compile time value... :)

[13:43] <ShimmerFairy> m: sub infix:[/./] { ... }

[13:43] <camelia> rakudo-moar d0885e: OUTPUT«5===SORRY!5=== Error while compiling /tmp/hKbOKNtWLn␤Colon pair value '/./' too complex to use in name␤at /tmp/hKbOKNtWLn:1␤------> 3sub infix:[/./]7⏏5 { ... }␤»

[13:43] <ShimmerFairy> psch: there you go, it dies already :P

[13:44] <psch> ShimmerFairy: yes, but for the wrong reason...

[13:44] <psch> m: constant $sym = "µ"; sub infix:<<$sym>> { $^a ~ "µ" ~ $^b }; say 5 µ 5 # this dies for the same reason

[13:44] <camelia> rakudo-moar d0885e: OUTPUT«5===SORRY!5=== Error while compiling /tmp/fxaM5lC3Y1␤Colon pair value '$sym' too complex to use in name␤at /tmp/fxaM5lC3Y1:1␤------> 3constant $sym = "µ"; sub infix:<<$sym>>7⏏5 { $^a ~ "µ" ~ $^b }; say 5 µ 5 # this d␤    expecting any …»

[13:44] <awwaiid> "Only identifiers that produce a list of one or more values (preferably strings) are allowed as name extensions" where it then goes on to mentioned not allowing {} blocks. So seems reasonable to not allow regex

[13:44] <psch> and that *shouldn't* die

[13:44] <ShimmerFairy> psch: I think your best bet is to stop bad values before they reach nibble_to_str, not within it (in other words, the else branch you pointed out isn't the problem directly)

[13:46] <psch> ShimmerFairy: that'd just mean looking for compile time values before nibble_to_str instead of inside it?

[13:47] <ShimmerFairy> psch: well, unless a regex object counts as a nibble, I don't think it should hit nibble_to_str in the first place

[13:47] <ShimmerFairy> psch: maybe nibble_to_str could use a "is this really a nibble?" check, though, if that were feasible

[13:47] *** vvz left
[13:48] *** mr_ron left
[13:48] <timotimo> oh, sorry for the trouble, everyone! :S

[13:50] *** TEttinger left
[13:51] <timotimo> lizmat: and thanks for building something better

[13:52] <timotimo> lizmat: though perhaps instead of .EXISTS-KEY we could use the nqp op for that

[13:53] <psch> ShimmerFairy: afaiu, every colonpair has to be nibbled

[13:53] <psch> ShimmerFairy: so, yeah, the user is probably silly to put a regex in there

[13:54] <psch> ShimmerFairy: but that's not really how we can implement it, with all the torturing around... :)

[13:54] <psch> ShimmerFairy: the problem doesn't really come from nibbling in the first place either, it's just that we want a compile time value for what we nibbled in some cases

[13:56] *** Peter_R joined
[14:01] *** diana_olhovik_ left
[14:09] <colomon> o/

[14:09] <yoleaux> 11:43Z <moritz> colomon: http://smoke.perl6.org/report shows a T for IO::Notification::Recursive, even though that repo has no tests; should that be a P instead?

[14:10] <colomon> moritz: it’s entirely possible Test failures in pre-reqs count as Test failures in the base module.  Unfortunately, IO::Notification::Recursive is working fine now, and I’m having trouble finding something to test it on.

[14:11] *** FROGGS_ joined
[14:15] *** FROGGS left
[14:16] *** aborazmeh joined
[14:16] *** aborazmeh left
[14:16] *** aborazmeh joined
[14:18] <masak> afternoon, #perl6

[14:18] *** shlomif joined
[14:18] *** rindolf left
[14:18] *** shlomif is now known as rindolf

[14:19] *** telex left
[14:21] <timotimo> lizmat: could it be that for some reason we only need one less CALLER:: now?

[14:22] *** mr_ron joined
[14:22] *** telex joined
[14:22] *** telex left
[14:23] *** aborazmeh left
[14:24] *** telex joined
[14:25] <masak> huh, 007 made Hacker News. did not expect that.

[14:26] <masak> HN seems to like the readme :>

[14:30] *** laouji left
[14:31] *** raiph left
[14:31] *** raiph joined
[14:35] *** laouji joined
[14:39] * masak added a comment: https://news.ycombinator.com/item?id=10327631

[14:39] <timotimo> you're breaking the fourth wall??

[14:40] *** laouji left
[14:41] <masak> timotimo: you mean, completely unlike the README? :P

[14:42] <timotimo> %)

[14:44] *** Xor_ left
[14:45] * timotimo re-read the ufo readme, too

[14:45] *** skids joined
[14:45] <timotimo> i hadn't remembered it to be so good :3

[14:46] *** zakharyas joined
[14:46] *** liztormato joined
[14:47] <masak> thanks :)

[14:47] <liztormato> timotimo: could well be

[14:47] <masak> heh, ufo is so old it predates me (and Github) doing Markdown ;)

[14:48] <timotimo> yeah

[14:48] <timotimo> liztormato: huh, removing one of the CALLER:: doesn't fix it; but maybe i was working on the wrong one

[14:48] <timotimo> oh, wait

[14:48] <timotimo> we generate the stack trace inside that one function where we try { die() }

[14:51] *** laouji joined
[14:52] *** tokuhiro_ joined
[14:53] *** Xor_ joined
[14:53] <timotimo> liztormato: in Backtrace.pm i was able to replace "2 + $offset" with "1 + $offset" and it fixed fail.t, probably breaks everything else, so i expect some caller should supply one less to the $offset parameter

[14:54] <liztormato> It's all relatiy :-)

[14:55] <liztormato> *relative

[14:56] *** laouji left
[14:56] <timotimo> related, too

[14:56] *** tokuhiro_ left
[14:58] *** diana_olhovik_ joined
[15:00] *** patrickz joined
[15:02] *** Xor_ left
[15:03] <timotimo> # Failed test 'When $! is set, die() is die($!).'

[15:05] <grondilu> masak++ 007 story

[15:05] <grondilu> I cracked at ""Did you know that macros allow introspection and modification of program elements from within the program itself?",

[15:06] <timotimo> liztormato: that failure is fixed by removing one CALLER:: from sub die

[15:06] <masak> grondilu: :)

[15:06] <timotimo> liztormato: maybe we accidentally made all of this a whole bunch better? we need one less lookup now :)

[15:08] <liztormato> Perhaps. :-)

[15:09] *** diana_olhovik_ left
[15:11] <jnthn> If you're going to use nqp::ctxcaller and so on, you really need to nqp::existskey on the result.

[15:12] <liztormato> Ah, duh!

[15:12] <jnthn> ;)

[15:13] * jnthn is relaxing a good bit this weekend after last week's teaching (nice course, great students, but exhausting), but will be back to Perl 6 hacking tomorrow :)

[15:14] <jnthn> (For today, just dropping by the keyboard once in a while :))

[15:14] *** ely-se left
[15:14] *** Xor_ joined
[15:14] * liztormato is also relaxing between cycling 

[15:17] <skids> timotimo: FWIW to the original patch, Failures should not say "Died" they should say "Failed"

[15:17] <masak> .u 

[15:17] <yoleaux> No characters found

[15:18] <masak> jnthn++ # relaxing

[15:22] *** Xor_ left
[15:24] *** Xor_ joined
[15:27] <leont> Great, yet another issue with :temp

[15:27] <jnthn> ...:temp?

[15:27] <leont> In rules

[15:28] <timotimo> skids: did i break that? :o

[15:28] <timotimo> oh

[15:28] <skids> Yeah just a pasto

[15:28] <timotimo> i suppose i copy-pasted it over withotu fixing it

[15:28] <leont> I'm doing <directive>\n:temp $foo = $<directive>.ast\n<bar>, but it seems the temp is executed before <directive> is matched, so it's not getting the data it needs

[15:29] <leont> Putting a code block in between seems to force things to work

[15:29] <jnthn> There's a bit in S05 about when $/ is updated and...yes, you may need to do that.

[15:30] <leont> Seems even an empty code-block fixes it

[15:31] <jnthn> Aye, that's considered a sequence point

[15:31] <jnthn> http://design.perl6.org/S05.html#When_%24%2F_is_valid

[15:36] <colomon> masak++

[15:36] *** patrickz left
[15:37] *** liztormato left
[15:39] <masak> HN wanted unquotes in 007. anyone want to send me a patch? ;)

[15:40] <timotimo> HNDD?

[15:41] *** domidumont joined
[15:42] *** ely-se joined
[15:43] *** Xor_ left
[15:43] *** Suman joined
[15:44] <Suman> I want perl 6 to be more focussed on scientific computing, data analysis, data visualisation and machine learning.

[15:45] *** jasanj``` joined
[15:45] *** mr_ron left
[15:45] <Suman> Python has grown up from a general purpose language to a language suitable for scientific computing.

[15:45] <Suman> This age is all about big data

[15:45] *** mr_ron joined
[15:46] <arnsholt> It works the other way, I think

[15:46] <arnsholt> Having good ML and such is basically a question of having a module ecosystem large enough to support bindings to BLAS and LAPACK and friends

[15:46] <Suman> We should be able to handle big big data with perl 6 (like exabytes of data)

[15:47] <arnsholt> And the stuff that goes on top of those to make working them non-annoying

[15:47] <Suman> And Apache spark is famous not because of anything but its fast distributed scalable computing

[15:48] <Suman> so fast scalable  distributed computing should be our aim too

[15:48] <leont> Suman: so what are you going to do to make that happen?

[15:49] *** jasanj`` left
[15:50] <Suman> leont Personally I am a perl fan. Currently I use R and python for my work. In fact I am consumer of such softwares. I am afraid I can't do much in writin gsoftware. However I can spread the word and support via donation. Thanks

[15:52] <timotimo> for scientific computing we're getting shaped arrays of native integers and doubles - the support is in, only the syntax for definitions isn't sugared yet

[15:52] <timotimo> that's a big part of what makes scientific computing dobale, because vectors and matrices are basically all over the place

[15:53] <timotimo> we already have arbitrary precision rational numbers on top of our regular rational numbers that overflow into doubles when it's no longer possible to hold the denominator in 64bit

[15:53] <timotimo> that ought to be a good thing for numerics, i suppose?

[15:53] <jnthn> Suman: It also can help to identify concrete things that are missing and give an idea of how much they matter. I mean, sure, we're probably missing plenty of stuff for people to be able to use Perl 6 in that area. But as somebody who works on compiler/VM level stuff for Perl 6, I just don't have the knowledge of what scientific computing folks tend to need. timotimo seems to hae more clue than me, maybe... :)

[15:54] <leont> A lot of scientific computing in higher level languages are really abstractions around highly optimized pieces of C and Fortran code

[15:54] <timotimo> handling exabytes of data is much more about what facilities we offer to directly work with operation system APIs directly, and since those are basically always doable from NativeCall, we already have that, so to speak

[15:54] <leont> R, PDL and NumPy/SciPy all do that

[15:54] <timotimo> that's right

[15:55] <leont> Science is actually keeping fortran alive that way :-o

[15:55] <Suman> timotimo true agreed but perl 6 should natively support data import (in csv, excel,hdfs,tsv,spss,sas formats), analysis(descriptive and inferential statistics)

[15:55] <leont> Suman: none of those should be particularly hard to implement, really

[15:55] <Suman> For the data visualisation part we can use python matplotlib API

[15:56] <timotimo> i don't think perl6 should support csv "natively"

[15:56] <timotimo> or excel, hdfs, tsv, spss, sas

[15:56] <timotimo> that's for modules to do

[15:57] <timotimo> just like your processor can't handle xml directly ... oh, shit, wait ... :P

[15:57] <Suman> Without having good packages for data analysis, perl 6 won't go anywhere

[15:57] <timotimo> agreed

[15:57] <leont> Suman: yes, and those will be written.

[15:57] <Suman> Rightly said data analysis is the sexiest job of 20th century

[15:57] <leont> Now is the time to start writing them, really

[15:57] *** spider-mario left
[15:57] <timotimo> also, i totally agree with what arnsholt said about BLAS and LAPACK

[15:58] *** tokuhiro_ joined
[15:58] <timotimo> also, we'll want someone to write modules that make OpenCL and friends easy to use

[15:58] *** Peter_R left
[15:58] <Suman> I am afraid that even perl 5 doesn't have good easy to use packages for data analysis like pandas, numpy in python

[15:58] <skids> Data anaysis is the sexy job that will make security continue to be the sexiest job. :-)

[15:58] <Suman> We may be able to learn something from them 

[15:58] <timotimo> … can we not use the word "sexy" for this? :\

[15:58] <Suman> we may be abe to build more powerful

[15:59] *** Xor_ joined
[16:00] <timotimo> https://gist.github.com/timo/b5e0c8c167a6079cbac6 - what controls whether or not a stack trace would show up?

[16:02] <Suman> leont "Science is actually keeping fortran alive that way :-o" Agreed fully we want perl 6 to thrive that way for next century

[16:02] *** cognominal joined
[16:02] *** tokuhiro_ left
[16:02] *** Peter_R joined
[16:04] *** vvz joined
[16:05] <skids> timotimo: around Exception.pm line 260 is where to start figuring that out.

[16:06] <timotimo> ah

[16:06] *** domidumont1 joined
[16:06] <timotimo> no, i don't think so

[16:06] <skids> The notable exception (no pun intended) to that is if you are dealing with a Failure and its double backtrace.

[16:06] <timotimo> that seems to be what's responsible for when an exception hits the top level

[16:07] <timotimo> look at the $comp.^add_method calls below that

[16:07] <timotimo> AFK for a little bit

[16:08] *** araujo joined
[16:09] *** domidumont left
[16:11] <skids> timotimo: at the top level is when the backtrace actually happens -- it has to reach there first to ensure nothing tried to handle it.  IIRC.

[16:13] <leont> What is the state of not using strings as keys for hashes?

[16:13] <skids> leont: you have to declare specially, is all.

[16:14] <skids> m: :{ 6 => 2 }.keys[0].WHAT.say

[16:14] <camelia> rakudo-moar d0885e: OUTPUT«(Int)␤»

[16:14] <psch> m: my %h{Any}; %h{5} = 5; say %h.keys[0].WHAT

[16:14] <camelia> rakudo-moar d0885e: OUTPUT«(Int)␤»

[16:17] <masak> m: say grep { /\.pl6/ },  <a.pl6 b.txt>

[16:17] <camelia> rakudo-moar d0885e: OUTPUT«Method 'match' not found for invocant of class 'Any'␤  in block <unit> at /tmp/XGpCAMzLWP:1␤␤»

[16:17] <masak> m: say grep /\.pl6/,  <a.pl6 b.txt>

[16:17] <camelia> rakudo-moar d0885e: OUTPUT«(a.pl6)␤»

[16:17] <leont> Ah! the colon is the trick is seems

[16:17] <masak> that's from p6u

[16:17] <masak> surely the block form used to work, too?

[16:17] <masak> m: say grep { $_ ~~ /\.pl6/ },  <a.pl6 b.txt>

[16:17] <camelia> rakudo-moar d0885e: OUTPUT«(a.pl6)␤»

[16:17] <masak> is this a "masak submits rakudobug" situation?

[16:19] <mr_ron> m: '123' ~~ /(123)/; say ~ $0, ' ', $0.WHAT, ' ', so $0.isa(Cool); # mighti mean documentation update

[16:19] <camelia> rakudo-moar d0885e: OUTPUT«123 (Match) True␤»

[16:20] <mr_ron> I want to add Match to the list of Cool descendants here: https://github.com/perl6/doc/edit/master/lib/Type/Cool.pod#L20

[16:20] <mr_ron> any objections?

[16:20] <skids> m: sub s1 { sub s2 { fail("foo"); }; s2()(); }; s1();

[16:20] <camelia> rakudo-moar d0885e: OUTPUT«foo␤  in sub s1 at /tmp/tJMRwF6eCx:1␤  in block <unit> at /tmp/tJMRwF6eCx:1␤␤Actually thrown at:␤  in sub s1 at /tmp/tJMRwF6eCx:1␤  in block <unit> at /tmp/tJMRwF6eCx:1␤␤»

[16:21] *** xtreak joined
[16:21] <skids> Yeah that definitely got broken.  Should report s2 in the first backtrace.

[16:21] *** xtreak left
[16:22] <AlexDaniel> NativeCall was already mentioned, but it should also be noted that all these possibilities to extend perl6 syntax should also help a lot

[16:23] <AlexDaniel> e.g. unicode operators and stuff like that

[16:23] <AlexDaniel> so, modules will happen, I don't think that there is too much stuff that is missing from perl6 core.

[16:24] <psch> masak: http://irclog.perlgeek.de/perl6/2015-09-23#i_11262003

[16:24] <leont> m: my %foo = 1 => 2; %foo.perl.WHO.say

[16:25] <camelia> rakudo-moar d0885e: OUTPUT«Method 'pull-one' must be implemented by ProcessStr because it is required by a role␤  in any compose_method_table at gen/moar/m-Metamodel.nqp:2666␤  in any apply at gen/moar/m-Metamodel.nqp:2676␤  in any compose at gen/moar/m-Metamodel.nqp:2812␤  …»

[16:25] <leont> Looks like a bug to me

[16:25] <leont> skids: how do I create that without the :{} syntax?

[16:26] <leont> Or to un-XY, I have a list of Pairs, I want to make such a hash, how I do that?

[16:28] <dalek> doc: 4055f38 | (Ronald Schmidt)++ | lib/Type/Cool.pod:

[16:28] <dalek> doc: Update Cool.pod

[16:28] <dalek> doc: 

[16:28] <dalek> doc: Add Match to list of descendants of Cool

[16:28] <dalek> doc: review: https://github.com/perl6/doc/commit/4055f38728

[16:28] <skids> Hrm good question -- does pairup stringify?

[16:29] <masak> psch: thank you.

[16:29] <psch> m: ( 5 => 5 ).key.WHAT.say

[16:29] <camelia> rakudo-moar d0885e: OUTPUT«(Int)␤»

[16:29] <skids> oh no pairup is for lists --> pairs m.

[16:30] <skids> m: (5 => 6, 7 => 8).hash.perl.say

[16:30] <camelia> rakudo-moar d0885e: OUTPUT«{"5" => 6, "7" => 8}␤»

[16:30] <psch> m: my @pairs = 1 => 2, 3 => 4; my %h{Any} = @pairs; say %h.perl

[16:30] <camelia> rakudo-moar d0885e: OUTPUT«(my Any %{Any} = 1 => 2, 3 => 4)␤»

[16:31] <psch> m: my @pairs = 1 => 2, 3 => 4; my %h{Any} = @pairs; say %h.keys[0].WHAT

[16:31] <camelia> rakudo-moar d0885e: OUTPUT«(Int)␤»

[16:32] <masak> m: my $_ = "foo"; /foo/; say so $/

[16:32] <camelia> rakudo-moar d0885e: OUTPUT«Potential difficulties:␤    Redeclaration of symbol $_␤    at /tmp/5NnB0cdYhg:1␤    ------> 3my $_7⏏5 = "foo"; /foo/; say so $/␤True␤»

[16:32] <masak> m: $_ = "foo"; /foo/; say so $/

[16:32] <camelia> rakudo-moar d0885e: OUTPUT«True␤»

[16:33] <masak> if that works, then why doesn't the .grep({ /foo/ }) thing work?

[16:33] <masak> or, more to the point -- if that works, then why *shouldn't* the grep thing work?

[16:34] <masak> I think .grep({ /foo/ }) is how many p5ers would write it, and expect it to work

[16:34] <jdv79> RabidGravy: what did you do?

[16:34] <masak> and if we break that expectation, I think there should be a good reason, more than just "it was an accident that it ever worked" or "there's an easier way, learn that"

[16:34] *** raiph left
[16:35] <RabidGravy> jdv79, I appllied your patch, it worked I pushed it :)

[16:35] *** dhj joined
[16:36] <jdv79> you also typo'ed my email addr but ok

[16:36] <jdv79> how would you test that?

[16:36] <jdv79> are we able to redefine recv?

[16:44] *** Suman left
[16:44] <skids> m: <foo bar foog>.grep({$_.WHAT.say; /foo/}).say # masak: A good reason would be "because there's no $_ in a parameterless block" but that does not seem to be the happening reason

[16:44] <camelia> rakudo-moar d0885e: OUTPUT«(Str)␤Method 'match' not found for invocant of class 'Any'␤  in block <unit> at /tmp/1wn0Il839j:1␤␤»

[16:45] *** dhj left
[16:51] *** diana_olhovik joined
[16:54] *** zakharyas left
[16:59] *** yqt joined
[17:01] <moritz> skids: no, the reason is that the grep block returns the regex

[17:01] <moritz> skids: and grep itself boolifies it

[17:01] <moritz> skids: but at that time, the block's $_ has ceased to exist

[17:02] <timotimo> leont: in case it got lost in the shuffle, the most basic thing you'll want to know is you can define a hash that won't stringify keys by default with the "my %h{Any}" syntax; the :{ ... } thing is sugar for creating such a parameterized hash literal

[17:04] <masak> moritz: outside of a .grep block, a regex in an empty statement still seems to match against $_. but maybe the difference is that that regex is in void^Wsink context, and the one in the .grep block isn't?

[17:04] <dalek> perl6.org: 2772cd4 | (Zoffix Znet)++ | / (2478 files):

[17:04] <dalek> perl6.org: Get archive out of the way

[17:04] <dalek> perl6.org: review: https://github.com/perl6/perl6.org/commit/2772cd4d1d

[17:04] <dalek> perl6.org: 244774c | (Zoffix Znet)++ | / (22 files):

[17:04] <dalek> perl6.org: First styled home page

[17:04] *** dalek left
[17:04] <moritz> masak: aye

[17:05] *** dalek joined
[17:05] *** ChanServ sets mode: +v dalek

[17:05] <skids> m: <foo bar foog>.grep({/foo/; $/;}).say # moritz is right

[17:05] <camelia> rakudo-moar d0885e: OUTPUT«(foo foog)␤»

[17:05] <cognominal> m:  say sort <== < 1 2 3 >  #  <== in term position does not work. Am I doing it wrong, or is this a known problem?

[17:05] <camelia> rakudo-moar d0885e: OUTPUT«5===SORRY!5=== Error while compiling /tmp/7QJ5Qm3IKm␤Unable to parse expression in quote words; couldn't find final '>'␤        ␤at /tmp/7QJ5Qm3IKm:1␤------> 3ng it wrong, or is this a known problem?7⏏5<EOL>␤    expecting any of:␤    …»

[17:06] <masak> moritz: the { /foo/ } device stopped working because we got better at detecting sink context?

[17:06] *** leont left
[17:06] <El_Che> something you've heard a million time: For Hash types isn't confusing to have adverbs and methods doing the same thing? Specially :delete is pretty exotic(that performs an action, something I would expect to be done by a method). Or is there something I haven't understand yet?

[17:07] *** khw left
[17:07] <El_Che> (Looking at https://perl6advent.wordpress.com/2013/12/10/day-10-adverbly-adverby-adverbs/ , https://perl6advent.wordpress.com/2013/12/12/day-12-slicing-with-adverbs-the-only-way/ and http://doc.perl6.org/type/Hash )

[17:07] <skids> std: say sort <== < 1 2 3 >

[17:07] <camelia> std 28329a7: OUTPUT«ok 00:00 135m␤»

[17:08] <skids> Well, feeds might be in flux on the backend but they should probably parse better than that.

[17:08] *** jsimonet left
[17:09] <masak> El_Che: sounds like the missing bit is that (a) it's nice/powerful to use the same .{} hash lookup even when we're deleting or checking for existence

[17:09] <timotimo> El_Che: we use an adverb for that because postcircumfix:<{ }> and postcircumfix:<[ ]> are for selecting a bunch of things, then you put the delete adverb in there to specify what happens with it

[17:10] <masak> (b) and in order to do that, we put the adverbs on the lookup itself

[17:10] <timotimo> El_Che: the other thing is we have some things that support both positional and associative access, so it would have to be .delete_key and .delete_pos methods, rather than just a .delete method

[17:10] <moritz> also, this way you can combine the auto-quoting of <...> with :delete

[17:10] <moritz> which a mere method wouldn't provide

[17:11] <masak> El_Che: maybe it's easier to think of %h{'foo'}:delete as a "destructive read"? :)

[17:11] <masak> right, in some sense we're retaining all the power of .{} and .<>

[17:11] <skids> m: {:a(1),:b(2)}<a>:kv:delete.say # and combining adverbs

[17:11] <camelia> rakudo-moar d0885e: OUTPUT«(a 1)␤»

[17:11] <El_Che> Last sentence of masak made my head explode :)

[17:11] <masak> El_Che: well, :delete *does* still return the value.

[17:12] <El_Che> that's true

[17:12] <masak> which means that *technically*, it's a kind of lookup :)

[17:12] <masak> that's all I meant

[17:13] <masak> my point is that :exists and :delete don't feel all that misplaced as adverbs. because (no matter what data structure you have) if you want to check for existence or remove something from a collection, first you have to *find* it. i.e. lookup

[17:14] <masak> having :exists and :delete as adverbs on ordinary lookup means that those two related operations benefit from all the (syntactic) power and flexibility that we already have with .[], .{} and .<>

[17:15] <masak> which doesn't mean so much when you're just deleting individual items, sure. but it pays off whenever you want to do something more than that.

[17:16] <masak> m: my %letters = "a".."z" X=> 1; my @vowels = <a e i o u>; %letters{@vowels} :delete; say %letters.keys.sort

[17:16] <camelia> rakudo-moar d0885e: OUTPUT«(b c d f g h j k l m n p q r s t v w x y z)␤»

[17:18] *** adhoc left
[17:20] *** adhoc joined
[17:23] <masak> m: my @deck = <♠ ♥ ♦ ♣> X~ flat(1..10, <j q k>); my @hand = @deck.pick(5); say @hand; @deck = (@deck (-) @hand).list; say @deck.elems

[17:23] <camelia> rakudo-moar d0885e: OUTPUT«[♣6 ♦k ♠4 ♥7 ♥10]␤47␤»

[17:23] <masak> that last one didn't lead me where I planned :) could someone re-write it to use .{} :delete, maybe?

[17:25] *** Xor_ left
[17:26] *** araujo left
[17:27] *** araujo joined
[17:28] *** Xor_ joined
[17:30] *** araujo left
[17:32] <BenGoldberg> m: my %deck = SetHash.new((<♠ ♥ ♦ ♣>) X~ flat(1..10, <j q k>)); my @hand = %deck.keys.pick(5); @hand.say; %deck{@hand}:delete; %deck.elems.say;

[17:32] <camelia> rakudo-moar d0885e: OUTPUT«[♦j ♦6 ♦4 ♦7 ♠2]␤47␤»

[17:32] <skids> m: my %deck; %deck{<♠ ♥ ♦ ♣> X~ flat(1..10, <j q k>)} = (); my %hand = %deck{%deck.keys.pick(5)}:delete:kv; say %hand.keys; say +%deck.keys

[17:32] <camelia> rakudo-moar d0885e: OUTPUT«(♥q ♣8 ♠3 ♦9 ♣7)␤47␤»

[17:33] <masak> cute. skids++

[17:33] <masak> also, BenGoldberg++

[17:34] <masak> skids: I don't think I've seen the `= ()` idiom before.

[17:34] <BenGoldberg> perl5, of course

[17:34] <skids> Oh that goes way back to P5

[17:34] <masak> oh, ok.

[17:35] <masak> I'm so used to just filling 1s in there. I'd be more likely to write `= 1 xx *`

[17:35] *** laouji joined
[17:37] *** araujo joined
[17:37] *** araujo left
[17:37] *** araujo joined
[17:40] *** laouji left
[17:40] <skids> m: my @deck = <♠ ♥ ♦ ♣> X~ flat(1..10, <j q k>); my @hand = @deck[@deck.keys.pick(5)]:delete; say @hand; say +@deck # 52?

[17:40] <camelia> rakudo-moar d0885e: OUTPUT«[♠j ♣3 ♣6 ♥j ♠5]␤52␤»

[17:41] <skids> oh right. dead slots.

[17:45] *** vendethiel joined
[17:46] *** pmurias_ is now known as pmurias

[17:46] <pmurias> are lines over 80 characters a serious problem for anybody in (the js runtime part) of nqp-js?

[17:47] <El_Che> masak: I get the reasoning (it makes sense). But you'll get a lot of confused people :)

[17:47] <pmurias> I'm making an exception to the google coding standard for the line length but if somebody is hindered by overly long lines I can shorten them

[17:48] <dalek> nqp: 5ca7473 | (Pawel Murias)++ | src/vm/js/nqp-runtime/core.js:

[17:48] <dalek> nqp: [js] remove dead commented out code

[17:48] <dalek> nqp: review: https://github.com/perl6/nqp/commit/5ca74731b8

[17:48] <dalek> nqp: 33c9123 | (Pawel Murias)++ | src/vm/js/nqp-runtime/ (12 files):

[17:48] <dalek> nqp: [js] Run fixjsstyle src/vm/js/nqp-runtime/*.js

[17:48] <dalek> nqp: review: https://github.com/perl6/nqp/commit/33c9123bd6

[17:48] <dalek> nqp: 5522fb4 | (Pawel Murias)++ | src/vm/js/nqp-runtime/ (12 files):

[17:48] <dalek> nqp: [js] Run fixjsstyle --strict src/vm/js/nqp-runtime/*.js

[17:48] <dalek> nqp: review: https://github.com/perl6/nqp/commit/5522fb4f5a

[17:48] <dalek> nqp: 779dc95 | (Pawel Murias)++ | tools/build/ (2 files):

[17:48] <dalek> nqp: [js] set the maximum line length while linting to 200

[17:48] <dalek> nqp: review: https://github.com/perl6/nqp/commit/779dc95471

[17:48] <dalek> nqp: c67d5bc | (Pawel Murias)++ | src/vm/js/nqp-runtime/ (5 files):

[17:48] <dalek> nqp: [js] Fix stuff that js-lint complains about. Comply to the google js coding (except allow longer lines).

[17:48] <dalek> nqp: review: https://github.com/perl6/nqp/commit/c67d5bc312

[17:52] *** travis-ci joined
[17:52] <travis-ci> NQP build failed. Pawel Murias '[js] Fix stuff that js-lint complains about. Comply to the google js coding (except allow longer lines).'

[17:52] <travis-ci> https://travis-ci.org/perl6/nqp/builds/83577902 https://github.com/perl6/nqp/compare/c28a6691a2f2...c67d5bc312fe

[17:52] *** travis-ci left
[17:52] *** yqt left
[17:58] *** diana_olhovik left
[18:03] *** Xor_ left
[18:07] *** rivarun left
[18:09] <dalek> perl6.org: 0d56442 | moritz++ | includes/footer:

[18:09] <dalek> perl6.org: Remove Niecza from footer

[18:09] <dalek> perl6.org: 

[18:09] <dalek> perl6.org: it is sufficiently outdated that we do not need to advertise it

[18:09] <dalek> perl6.org: on every single page

[18:09] <dalek> perl6.org: review: https://github.com/perl6/perl6.org/commit/0d56442a7e

[18:11] <dalek> perl6.org: 471fc02 | moritz++ | includes/footer:

[18:11] <dalek> perl6.org: Remove wiki link from footer

[18:11] <dalek> perl6.org: review: https://github.com/perl6/perl6.org/commit/471fc02bbd

[18:12] <dalek> perl6.org: e7ab176 | moritz++ | source/specification/index.html:

[18:12] <dalek> perl6.org: Use macros instead of concurrency as ane example of stuff in flux

[18:12] <dalek> perl6.org: 

[18:12] <dalek> perl6.org: I think concurrency is not that much in flux anymore,

[18:12] <dalek> perl6.org: in large parts thanks to jnthn++

[18:12] <dalek> perl6.org: review: https://github.com/perl6/perl6.org/commit/e7ab176b01

[18:13] <moritz> Zoffix: it seems faq.perl6.org uses the perl6.org style sheet, and now has horrible contrast. Would be nice if you could fix it

[18:14] <moritz> (if not, I'll simply copy the old perl6.org style sheet to faq.perl6.org, but that would be a less-than-awesome solution)

[18:17] <moritz> https://news.ycombinator.com/item?id=10325670 a hn discussiono without any hate

[18:18] *** Xor_ joined
[18:25] <El_Che> I heard today out of the blue how someone was impressed by Perl6 during Ovid's intro talk. Good work, p6 people!

[18:26] *** FROGGS[mobile] left
[18:29] <jdv79> how to do something like (in p5 parlance) *IO::Socket::INET::recv = sub {}?

[18:29] *** FROGGS_ is now known as FROGGS

[18:29] *** diana_olhovik joined
[18:29] <FROGGS> jnthn: what do you mean, "like what happens when assigning through a pseudo-package" ?

[18:29] <FROGGS> jnthn: can you give me an example?

[18:29] <masak> El_Che: confusing people (in the short run) if the reasoning makes sense (in the long run) sounds like a fair deal to me. :)

[18:30] *** lichtkind joined
[18:32] <El_Che> masak: expect some good trolling on that :)

[18:34] * moritz expects much more trolling in other areas

[18:35] *** BenGoldberg left
[18:35] *** BenGoldberg joined
[18:36] *** BenGoldberg left
[18:36] *** BenGoldberg joined
[18:37] <carlin> m: my $fh = '/dev/urandom'.IO.open; Thread.start({ $fh.read(16) });

[18:37] <camelia> rakudo-moar d0885e: OUTPUT«(signal SEGV)»

[18:38] <vendethiel> carlin: I'm pretty sure you can't do that in the "safemode"

[18:38] *** diana_olhovik left
[18:40] <carlin> I get a segv doing that locally too

[18:53] <FROGGS> jnthn: if you are talking about 'my Int:D $a; MY::<$a> = Int' that works, I mean fails

[18:53] <jdv79> what's a good way to get the passed args?

[18:57] <FROGGS> m: sub foo(Int:D $a?) { say $a }; foo()

[18:57] <camelia> rakudo-moar d0885e: OUTPUT«Parameter '$a' requires an instance of type Int, but a type object was passed.  Did you forget a .new?␤  in sub foo at /tmp/9XvkFVL6AM:1␤  in block <unit> at /tmp/9XvkFVL6AM:1␤␤»

[18:57] <FROGGS> jdv79: what args?

[18:58] <jdv79> passed to a routine

[18:58] <jdv79> i got it - @_ and %_ seem ok

[18:58] <jdv79> now wondering wny a wrap && callsame don't work

[18:58] <jdv79> shouldn't that?

[18:59] <FROGGS> dunno offhand

[18:59] * FROGGS is sleepy

[19:01] <jdv79> https://gist.github.com/anonymous/5fdaad8a37bae71abe8b

[19:01] <vendethiel> oooh, that new landing page is great.

[19:02] <jdv79> with the bile colored header?

[19:03] <FROGGS> jdv79: what are you trying to do? maybe augmenting IO::Socket::INET helps? or subclassing it...

[19:03] <jdv79> i want to log recev calls

[19:04] <jdv79> i can't.  the thing i'm trying to test doesn't do DI

[19:04] <jdv79> is wrapping a method not that simple ^H?

[19:04] <FROGGS> I thought it was

[19:05] <vendethiel> m: 5->6

[19:05] <camelia> rakudo-moar d0885e: OUTPUT«5===SORRY!5=== Error while compiling /tmp/lOOZ4nw9yV␤Unsupported use of -> as postfix; in Perl 6 please use either . to call a method, or whitespace to delimit a pointy block␤at /tmp/lOOZ4nw9yV:1␤------> 035->7⏏056␤    expecting any of:…»

[19:05] <FROGGS> I also cant remember when to use callsame vs. nextsame

[19:05] <jdv79> oh, i'll try that one

[19:06] <timotimo> callsame when you have code after it and want to do something with return value

[19:06] <timotimo> nextsame is more like a goto

[19:07] <jdv79> that's what i thought.  so callsame is correct here.

[19:08] <timotimo> going to see inside out now :)

[19:08] <jdv79> huh?

[19:09] *** zakharyas joined
[19:12] <masak> jdv79: http://www.imdb.com/title/tt2096673/

[19:15] <jdv79> why do i have to give a sig on the wrapper routine?

[19:26] *** domidumont joined
[19:27] *** krunen_ joined
[19:27] *** ChoHag_ joined
[19:27] *** maddingu1 joined
[19:27] *** pyrimidi_ joined
[19:27] *** apotheon_ joined
[19:28] *** pochi_ joined
[19:28] *** diego_k joined
[19:28] *** obra_ joined
[19:28] *** pink_mis1 joined
[19:28] *** carlin_ joined
[19:29] *** leedo_ joined
[19:29] *** domm_ joined
[19:29] *** ashleyde1 joined
[19:29] *** carlin_ is now known as Guest49363

[19:29] *** domidumont1 left
[19:30] *** pyrimidine left
[19:30] *** ChoHag left
[19:30] *** krunen left
[19:30] *** pochi left
[19:30] *** pink_mist left
[19:30] *** takadonet left
[19:30] *** pink_mis1 is now known as pink_mist

[19:30] *** leedo left
[19:30] *** FROGGS left
[19:30] *** prammer left
[19:31] *** domidumont left
[19:31] *** stux|RC-only joined
[19:31] *** pink_mist left
[19:31] *** pink_mist joined
[19:31] *** takadonet joined
[19:32] *** charsbar joined
[19:32] *** prammer joined
[19:32] *** carlin left
[19:32] *** maddingue left
[19:32] *** apotheon left
[19:32] *** domm left
[19:32] *** Debolaz left
[19:32] *** obra left
[19:32] *** FROGGS joined
[19:32] *** Debolaz joined
[19:33] *** LittleC47 joined
[19:33] *** lestrrat joined
[19:33] *** LittleC47 left
[19:37] *** mr_ron left
[19:37] *** yqt joined
[19:38] *** mr_ron joined
[19:55] *** zakharyas left
[19:57] <jdv79> m: my @foo = (1,2,3); @foo.perl.say; (1,2,3).perl.say;

[19:57] <camelia> rakudo-moar d0885e: OUTPUT«[1, 2, 3]␤(1, 2, 3)␤»

[19:57] <jdv79> why the diff?

[19:57] <jdv79> oh

[19:58] <FROGGS> m: my @foo = (1,2,3); @foo.WHAT.say; (1,2,3).WHAT.say;

[19:58] <camelia> rakudo-moar d0885e: OUTPUT«(Array)␤(List)␤»

[19:59] <jdv79> aw, subbuf doesn't do *-4 type stuff

[20:02] *** kaare__ left
[20:07] <masak> jdv79: sounds like a bug to me

[20:08] *** xfix left
[20:18] <FROGGS> m: class Foo { has Int:D $.bar }; say Foo.new.bar

[20:18] <camelia> rakudo-moar d0885e: OUTPUT«(Int)␤»

[20:21] <lichtkind> i had made a token but <.tokenname> didnt matched??

[20:21] <yoleaux> 3 Oct 2015 16:40Z <Ven> lichtkind: shouldn't that be a regexp? https://github.com/perl6/problem_solver_tutorial/blob/master/chapter_4/bn4.pl6#L25

[20:21] *** Psyche^ joined
[20:21] <FROGGS> m: my ($a, Int:D $b); say $b

[20:21] <camelia> rakudo-moar d0885e: OUTPUT«(Int)␤»

[20:21] <lizmat> masak: re .grep: { /foo/ }   last I checked with jnthn he said it was never supposed to work

[20:22] <lichtkind> yoleaux exactly i had pronlem there but solven jsut not comited now

[20:22] <lizmat> and yes, I broke it when I iterified .grep

[20:22] *** darutoko left
[20:23] <lichtkind> yoleaux but why isnt that a regrx in your opinion?

[20:24] <lizmat> .tell jnthn should VM supported object hashes be added to nope.md ?

[20:24] <yoleaux> lizmat: I'll pass your message to jnthn.

[20:24] <dalek> perl6.org: dd78e8a | (Zoffix Znet)++ | source/index.html:

[20:24] <dalek> perl6.org: Fix overflow on download button (Closes #23)

[20:24] <dalek> perl6.org: review: https://github.com/perl6/perl6.org/commit/dd78e8ae09

[20:24] <FROGGS> lichtkind: yoleaux is a message bot

[20:24] <lichtkind> FROGGS nobody told me :)

[20:24] *** Psyche^_ left
[20:25] <FROGGS> .botsnack

[20:25] <yoleaux> :D

[20:25] <FROGGS> :o)

[20:25] <masak> lizmat: I understand and I agree that with jnthn it's weird that it ever worked.

[20:25] <lizmat> nevertheless, it appears to be a common mistake to make

[20:25] <masak> lizmat: the question is more, what do we do now? do we make it work, or add a FAQ somewhere explaining to people why they are thinking wrong?

[20:25] <lizmat> so maybe we should have a less LTA error message ?

[20:26] <masak> specifically, this seems like something a p5er would be likely to run into

[20:26] <lichtkind> FROGGS but dont know why <.rulename> doesnt match automatically

[20:26] *** mr_ron left
[20:26] <dalek> rakudo-star-daily: 363cbfd | coke++ | log/ (8 files):

[20:26] <dalek> rakudo-star-daily: today (automated commit)

[20:26] <dalek> rakudo-star-daily: review: https://github.com/coke/rakudo-star-daily/commit/363cbfdcf8

[20:26] <lizmat> m: <a b c>.grep: { /foo/ }

[20:26] <camelia> rakudo-moar d0885e: OUTPUT«Method 'match' not found for invocant of class 'Any'␤  in block <unit> at /tmp/5yqI5GtvwG:1␤␤»

[20:26] <dalek> perl6-roast-data: 7db26a5 | coke++ | / (9 files):

[20:26] <dalek> perl6-roast-data: today (automated commit)

[20:26] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/7db26a54fe

[20:26] <masak> just as p5ers might do `$s1 . $s2`

[20:26] <lizmat> if we add a method Match to Any, we could have it suggest something sensible ?

[20:26] <FROGGS> lichtkind: because of a bug... use <&space>

[20:27] <lichtkind> so its the name , if i named it other thatn space it would work?

[20:28] <FROGGS> lichtkind: no, it would look up a method Cursor.theregexname

[20:30] <lichtkind> so just waite till fix?

[20:30] *** araujo left
[20:32] <dalek> rakudo/nom: b6247a8 | lizmat++ | src/core/Map.pm:

[20:32] <dalek> rakudo/nom: Expose MapIterator role to the world

[20:32] <dalek> rakudo/nom: 

[20:32] <dalek> rakudo/nom: We can use it in other places in the core

[20:32] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/b6247a813b

[20:32] <dalek> rakudo/nom: d2da732 | lizmat++ | src/core/Baggy.pm:

[20:32] <dalek> rakudo/nom: Iterify Baggy.pairs/keys/kv/values/antipairs/kxxv

[20:32] <dalek> rakudo/nom: 

[20:32] <dalek> rakudo/nom: I have two reasons for doing this:

[20:32] <dalek> rakudo/nom: - to make Bag/BagHash/Mix/MixHash faster

[20:32] <dalek> rakudo/nom: - *if* we don't get VM support for object hashes, this code can be

[20:32] <dalek> rakudo/nom:   put in a role and used for a single hash refactoring of object

[20:32] <dalek> rakudo/nom:   hashes in Perl 6

[20:32] <dalek> rakudo/nom: 

[20:32] <dalek> rakudo/nom: This refactor also exposed two faulty tests for Baggy.kxxv

[20:32] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/d2da732436

[20:32] *** mr_ron joined
[20:33] <lizmat> hmm.. actually faulty tests for Baggy.kv

[20:35] <lizmat> well, actually tests for Baggy.kv that depended on faulty Baggy.kv behaviour

[20:38] <dalek> roast: 778d230 | lizmat++ | S02-types/ (2 files):

[20:38] <dalek> roast: Fix faulty BagHash/MixHash.kv test

[20:38] <dalek> roast: review: https://github.com/perl6/roast/commit/778d2304a9

[20:45] *** zjmarlow joined
[20:47] <dalek> faq: ca5b7ed | (Zoffix Znet)++ | web/index.tmpl:

[20:47] <dalek> faq: Make FAQ work with new Perl6.org design

[20:47] <dalek> faq: review: https://github.com/perl6/faq/commit/ca5b7ed57a

[20:47] <Zoffix> moritz, done. 

[20:48] <Zoffix> I think this one might be outdated? https://github.com/perl6/faq/blob/master/answers.md#why-do-i-need-a-backslash-unspace-to-split-method-calls-across-multiple-lines

[20:57] *** Xor_ left
[20:57] *** Xor_ joined
[21:06] *** laouji joined
[21:11] *** laouji left
[21:11] <lizmat> m: my %h = a => 42; %h.values[0]++; dd %h  # apart from the LTA error message, we deem this to be acceptable, right ?

[21:11] <camelia> rakudo-moar d2da73: OUTPUT«Parameter '$a' expected a writable container, but got Int value␤  in block <unit> at /tmp/t9L58DdiJG:1␤␤»

[21:12] <lizmat> m: my %h = a => 42; %h.pairs[0].value++; dd %h  # but we allow this pairs to have a lvaluable Pair

[21:12] <camelia> rakudo-moar d2da73: OUTPUT«Hash %h = {:a(43)}␤»

[21:13] <lizmat> masak jnthn TimToady ^^^

[21:20] *** mr_ron left
[21:21] *** pmurias_ joined
[21:22] <masak> lizmat: let's see. S02 says that Pair is mutable in value but not in key. so your second eval seems kosher.

[21:22] <lizmat> m: my %h = a => 42; $_++ for %h.values; dd %h   #hmmmm

[21:22] <camelia> rakudo-moar d2da73: OUTPUT«Hash %h = {:a(43)}␤»

[21:22] <lizmat> so maybe subscripting .values is at fault ?

[21:22] <masak> yes, mebbe.

[21:23] <masak> maybe it should yield an array of aliased values.

[21:23] <masak> lizmat: want me to rakudobug it?

[21:23] <lizmat> masak: not yet

[21:23] <masak> hokay

[21:23] <lizmat> masak: ok, Pair.value is a left value, ok I get that

[21:23] <lizmat> but does that also mean it changes the hash ?

[21:24] *** pmurias left
[21:25] <lizmat> m: my %h = a => 42; %h.values.AT-POS(0)++; dd %h  # just testing

[21:25] <camelia> rakudo-moar d2da73: OUTPUT«Parameter '$a' expected a writable container, but got Int value␤  in block <unit> at /tmp/GaDEu6f8dz:1␤␤»

[21:25] <masak> I don't see why not. the Pair is conceptually in the hash

[21:25] <masak> making it a Pair with copied values feels counterintuitive

[21:26] <lizmat> Bag.pairs should have ro values on the Pairs

[21:26] *** rindolf left
[21:26] <lizmat> otherwise you could alter the Bag

[21:27] <masak> +1

[21:27] <masak> Bags are immutable. Hashes are mutable.

[21:28] <lizmat> so I was wondering maybe we should have a values-ro and pairs-ro method on Map

[21:28] <masak> but the choice is not the user's, it's the type's

[21:29] <masak> so a Bag would just return Enums, not Pairs

[21:29] <masak> no need for separate methods

[21:30] *** Xor_ left
[21:30] <masak> works out Liskovly and everything

[21:30] <lizmat> m: my $b = <a b c>.BagHash; $b.pairs[0].value = "foo"; dd $b   # another thing to fix :-(

[21:30] <camelia> rakudo-moar d2da73: OUTPUT«BagHash $b = ("a"=>foo,"c"=>1,"b"=>1).BagHash␤»

[21:32] <lizmat> m: my $b = <a b c>.Bag; $_++ for $b.values; dd $b  # another one

[21:32] <camelia> rakudo-moar d2da73: OUTPUT«Bag $b = ("a"=>2,"c"=>2,"b"=>2).Bag␤»

[21:34] <masak> aye

[21:34] <masak> immutability is hard :/

[21:35] <masak> I guess this is an instance of the "don't leak access rights through your getter methods" best practice

[21:40] <BenGoldberg> Just deep clone everything we return ;)

[21:40] <masak> aye

[21:40] <masak> I first learned about this in http://www.amazon.com/Effective-Java-2nd-Joshua-Bloch/dp/0321356683 -- item #39 -- "make defensive copies when needed"

[21:40] <masak> that's for the immutable types

[21:40] <masak> for the mutable types, we actually want the aliasing behavior, and so we don't copy

[21:41] <lizmat> yeah, gotcha

[21:42] <AlexDaniel> what shell does qqx// use on windows? For example, the spec says this about “shell()”: “shell goes through the system shell (cmd on windows, /bin/sh on Unixish systems), thus interpreting all the usual shell meta characters.”

[21:42] <masak> lizmat: not a criticism of you or anyone in particular. I just find this immutability stuff fascinating.

[21:42] <AlexDaniel> I can't really find any meaningful description of QX though

[21:42] <lizmat> masak :-)

[21:42] <lizmat> feels like torture to me  :-)

[21:43] *** zjmarlow left
[21:43] <masak> I sincerely believe it's one of the places in software engineering where we're "not there yet". and we'll look back in 2035 and go "how the heck did we get anything done with those paltry/wrong primitives?"

[21:43] <masak> I see early attempts at getting it right, with linear types, immutable object graphs, etc. none of the solutions are in that sweet spot of highly useful and easy yet, though.

[21:44] *** Xor_ joined
[21:45] * BenGoldberg ponders whether we should "merely" steal the 'const' keyword from C / C++

[21:45] <AlexDaniel> so, in other words, qx// is not in any way portable? (although making assumptions about the underlying shell is stupid anyway)

[21:45] <masak> in a sense, I think we need better metaphors. for example, the Pair we extract from a Hash is like an "alias" or a "remote control" of the contents of the Hash. it's like a little portable one-entry hash slice.

[21:46] <masak> BenGoldberg: the 'const' keyword in C/C++ does solve some issues, but it introduces others.

[21:47] *** alpha- joined
[21:47] <masak> BenGoldberg: for example, programmers have a hard time reasoning about the immutability of the *variable*, the *container* it refers to, and its *value* which may be an entity with properties, etc

[21:47] *** ely-se left
[21:47] *** ^elyse^ joined
[21:48] <masak> BenGoldberg: this is the problem I foresee with ES6's new `constant` keyword. people think it does one (fairly strong) thing, but it actually does another (fairly weak) thing

[21:48] <BenGoldberg> Also, if you want a container which is const, and you want to make it cache/memoize computations, it's tricky.

[21:49] * skids suspects eventual hardware ref-counting/following assist will play a role in what such things look like in a decade or two.

[21:50] <skids> When "stop the world" GC starts to chafe.

[21:50] *** bjz left
[21:50] *** ^elyse^ left
[21:51] <BenGoldberg> On a completely unrelated note...

[21:52] <BenGoldberg> m: https://gist.github.com/BenGoldberg1/bc39a9a31eaeb733012a

[21:52] <camelia> rakudo-moar d2da73: OUTPUT«Cannot send a message on a closed channel␤  in block <unit> at /tmp/JFN8o88RyH:31␤␤»

[21:52] <BenGoldberg> m: https://gist.github.com/BenGoldberg1/bc39a9a31eaeb733012a

[21:52] <camelia> rakudo-moar d2da73: OUTPUT«Cannot send a message on a closed channel␤  in block <unit> at /tmp/qiBNJLKQw7:31␤␤»

[21:52] <BenGoldberg> m: https://gist.github.com/BenGoldberg1/bc39a9a31eaeb733012a

[21:52] <camelia> rakudo-moar d2da73: OUTPUT«Attempt to return outside of any Routine␤  in block <unit> at /tmp/O3b50H1yjz:31␤␤»

[21:53] <BenGoldberg> Could someone tell me what's happening here?

[21:54] <lizmat> BenGoldberg: not sure, but if I understand jnthn's ideas correctly, earliest is not going to be much longer in this world

[21:54] <lizmat> react { } would be a better approach, I think

[21:54] <lizmat> although I must admit not seeing how you would convert your code to use react instead offhand

[21:56] <masak> yes, `earliest` is going away; what lizmat said

[21:56] *** mr_ron joined
[22:01] <dalek> rakudo/nom: efbd9ca | lizmat++ | src/core/ (2 files):

[22:01] <dalek> rakudo/nom: No need to special case Bag/Mix.antipairs

[22:01] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/efbd9ca12b

[22:01] <dalek> rakudo/nom: b14723d | lizmat++ | src/core/Exception.pm:

[22:01] <dalek> rakudo/nom: Don't mention nameless scalars

[22:01] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/b14723dfbd

[22:01] <dalek> rakudo/nom: 2765b6a | lizmat++ | src/core/ (4 files):

[22:01] <dalek> rakudo/nom: BagHash/MixHash accept values of correct type only

[22:01] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/2765b6acf2

[22:03] *** tokuhirom joined
[22:04] <dalek> perl6.org: 7973405 | (Matt Oates)++ | source/index.html:

[22:04] <dalek> perl6.org: .IO.words is a little more idiomatic

[22:04] <dalek> perl6.org: review: https://github.com/perl6/perl6.org/commit/797340535c

[22:05] <skids> m: role Foo { }; class A does Foo { }; class B is A { }; my B $b.= new; ("roles:", $b.^roles).say; $b.^role_typecheck_list.say; say B ~~ Foo; # headscratch -- what magic makes B ~~ Foo find roles from A

[22:05] <camelia> rakudo-moar d2da73: OUTPUT«(roles: ((Foo)))␤()␤True␤»

[22:07] *** tokuhirom left
[22:08] *** pmurias_ left
[22:10] *** Xor_ left
[22:12] <Ulti> Zoffix you might want to use the updated VIM markup on the P6 source on the front page it's not rendered that well atm especially the custom operators bit, then you get all the types highlighted etc. http://mattoates.co.uk/files/vim_p6_markup.html

[22:13] <BenGoldberg> lizmat, Reading about supplies hurts my head -- I'll need to see more examples before it makes sense to me.

[22:13] <Zoffix> Ulti, how did you generate that? I've used http://pygments.org/ and yeah, I noticed it didn't do it 100% correct.

[22:13] *** bjz joined
[22:13] <lizmat> BenGoldberg: have you looked at jnthn's slides of his last concurrency talk?

[22:13] <Ulti> you can use vim from the command line with the TOhtml command

[22:14] <Zoffix> Ulti, ah. Thanks. I'll look into that tomorrow.

[22:14] <_itz> Ulti: or use the perl6 module which does that

[22:14] <Ulti> or that ^

[22:14] <Zoffix> k :)

[22:14] <Ulti> need to configure vim a bit though

[22:14] <Zoffix> For the module?

[22:15] <BenGoldberg> no, googling for them now...

[22:15] <_itz> https://github.com/stmuk/p6-Text-VimColour/

[22:15] <Zoffix> Ah, I've actually tried that last night: https://github.com/stmuk/p6-Text-VimColour/issues/6

[22:15] <Ulti> for the up to date highlighting and for recognising Perl 6

[22:15] <Ulti> also not really convinced that custom operators should be one of three head line features....

[22:16] <Ulti> or infinite series

[22:16] <lizmat> BenGoldberg: http://jnthn.net/papers/2015-spw-concurrency.pdf

[22:16] <_itz> "didn't find a recent vim/ex"

[22:16] <Ulti> these are cool but not really practical every day power tools that Perl 6 brings

[22:16] <_itz> do you have vim/ex 7.4 in your path?

[22:16] * Zoffix shrugs

[22:16] <Zoffix> I don't use vim, so probably not

[22:17] <Zoffix> Ulti, custom operators is definitely something that excited me about Perl 6 :)

[22:17] *** bjz left
[22:17] <Zoffix> But I don't know Perl 6, so... yeah, my examples likely suck :)

[22:18] <Ulti> its the kind of thing that scares anyone who works in languages where normal operator overloading is abused though

[22:19] <Ulti> though I guess given slangs exist people better get used to it :)

[22:19] *** bjz joined
[22:19] <masak> 'night, #perl6

[22:19] <Zoffix> _itz, I have vim version 7.3.429, so that's likely it. I'll close that Issue

[22:19] <Zoffix> Bye

[22:19] <_itz> it probably should give a better error message

[22:27] *** vvz left
[22:29] *** bjz left
[22:38] *** TEttinger joined
[22:43] <timotimo> m: say try EVAL('my $a; $a ++');

[22:43] <camelia> rakudo-moar 2765b6: OUTPUT«Nil␤»

[22:44] <timotimo> m: say try EVAL('my $a; $a ++') orelse $!;

[22:44] <camelia> rakudo-moar 2765b6: OUTPUT«Nil␤»

[22:44] <timotimo> i think the "do_safely" thing in the FAQ is quite verbose and weird

[22:47] <skids> m: try EVAL("my \$a; \$a ++") orelse $!.say;

[22:47] <camelia> rakudo-moar 2765b6: ( no output )

[22:47] <skids> m: try EVAL("my \$a; \$a ++"); $!.say;

[22:47] <camelia> rakudo-moar 2765b6: OUTPUT«5===SORRY!5=== Error while compiling EVAL_0␤Prefix + requires an argument, but no valid term found␤at EVAL_0:1␤------> 3my $a; $a ++7⏏5<EOL>␤    expecting any of:␤        prefix␤»

[22:48] <skids> m: (try EVAL("my \$a; \$a ++")) orelse $!.say;

[22:48] <camelia> rakudo-moar 2765b6: OUTPUT«5===SORRY!5=== Error while compiling EVAL_0␤Prefix + requires an argument, but no valid term found␤at EVAL_0:1␤------> 3my $a; $a ++7⏏5<EOL>␤    expecting any of:␤        prefix␤»

[22:48] <dalek> roast: 877e74c | lizmat++ | S02-types/ (2 files):

[22:48] <dalek> roast: Add immutability tests for Bag/Mix

[22:48] <dalek> roast: review: https://github.com/perl6/roast/commit/877e74c7c2

[22:48] <dalek> roast: 44feca7 | lizmat++ | S02-types/ (2 files):

[22:48] <dalek> roast: Add typecheck tests for BagHash/MixHash

[22:48] <dalek> roast: review: https://github.com/perl6/roast/commit/44feca7c3f

[22:49] <lizmat> I will make the Mix/Bag immutability tests pass tomorrow, or mark them as todo

[22:49] <lizmat> but first I'm going to get some sleep

[22:49] <lizmat> so good night, #perl6!

[22:49] <skids> o/ lizmat

[22:51] *** laouji joined
[22:51] *** Xor_ joined
[22:55] *** laouji left
[22:58] <BenGoldberg> m: https://gist.github.com/BenGoldberg1/47b3a982b1bdd630cbbc

[22:58] <camelia> rakudo-moar 2765b6: OUTPUT«True␤0.213231999251397␤True␤0.353279550610509␤True␤0.604705458162459␤True␤0.627016712158831␤True␤0.809176592597244␤True␤0.856785885671298␤True␤0.984910784517846␤True␤»

[22:59] <BenGoldberg> I'm getting it closer to working ;)

[22:59] <BenGoldberg> m: https://gist.github.com/BenGoldberg1/47b3a982b1bdd630cbbc

[22:59] <camelia> rakudo-moar 2765b6: OUTPUT«0.0764646994813678␤0.0877851502498979␤0.205447866786057␤0.327032577604799␤0.418614171629946␤0.499468599774313␤0.572545911835536␤»

[22:59] <BenGoldberg> Yay!

[23:02] *** rurban left
[23:02] *** leont joined
[23:05] *** mattprelude left
[23:06] *** laouji joined
[23:07] <BenGoldberg> m: Supply.new.close;

[23:07] <camelia> rakudo-moar 2765b6: ( no output )

[23:07] <BenGoldberg> STD: Supply.new.close;

[23:07] <BenGoldberg> j: Supply.new.close;

[23:08] <camelia> rakudo-jvm 2765b6: ( no output )

[23:09] <BenGoldberg> According to http://doc.perl6.org/type/Supply, the only method of supply called .close must take a Tap object.  Why doesn't rakudo complain when I do that?

[23:14] <skids> rakudo has a 'multi method close(Supply:D:) { self.close($_) for self.tappers }'

[23:18] <BenGoldberg> It ought to be documented, then :P  Or perhaps, renamed to closeall, so someone rewriting code from using a Channel to using a Supply doesn't get bitten by accidentally doing .close instead of .done

[23:18] <BenGoldberg> Or renamed and documented ;)

[23:20] *** RabidGravy left
[23:22] <skids> I'm not sure what's on the way in and what's on the way out WRT concurrency so I don't know what to doc, personally.

[23:26] *** mr_ron left
[23:30] *** Xor_ left
[23:34] *** yqt left
[23:35] *** Xor_ joined
[23:40] *** Peter_R left
[23:52] *** tokuhirom joined
[23:56] *** tokuhirom left
