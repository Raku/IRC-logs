[00:05] *** TEttinger left
[00:15] <Sgeo_> m: sub plusminus($x) returns Junction { $x|-$x; }; say plusminus(1|2);

[00:15] <yoleaux> 31 Jul 2015 09:35Z <Ven> Sgeo_: you might be interested in timo's https://github.com/timo/adt , btw. The only thing missing is the ability to do multi dispatch based on that

[00:15] <camelia> rakudo-moar 5d9306: OUTPUT«any(any(1, -1), any(2, -2))␤»

[00:15] <psch> .tell ab5tract i'm unsure what classloading bit you're refering to.  classloading happens for interop and "normal" runtime in different ways (BootJavaInterop.java and LibraryLoader.java respectively)

[00:15] <yoleaux> 30 Jul 2015 15:23Z <ab6tract> psch: any clues on what might be borking module loading from non-SDK modules which also happen to be in CLASSPATH?

[00:15] <yoleaux> 30 Jul 2015 16:05Z <ab6tract> psch: the module loader code for NQP... is there no native-Java way to find a class? can't we just s/::/./ and load the class? I know that CLASSPATH issues are notoriously common in Java, but still...

[00:15] <yoleaux> 31 Jul 2015 16:20Z <ab5tract_> psch: what do you think of this approach to class loading? https://github.com/clojure/clojure/blob/41af6b24dd5be8bd62dc2b463bc53b55e18cd1e5/src/jvm/clojure/lang/DynamicClassLoader.java

[00:15] <yoleaux> 31 Jul 2015 16:22Z <ab5tract_> psch: I'm quite keen to help, but want to make sure there isn't some other consideration that made you eschew ClassLoader stuff entirely

[00:15] <yoleaux> psch: I'll pass your message to ab5tract.

[00:16] <Sgeo_> What

[00:16] <psch> .tell ab5tract nqp commit d03863352f07a05fa68892997e417b62452cb34e simplifed the former significantly, and i suspect something similar should be possible for LibraryLoader.java too, but i haven't been able to dig in yet

[00:16] <yoleaux> psch: I'll pass your message to ab5tract.

[00:16] <Sgeo_> m: sub plusminus($x) { $x|-$x; }; say plusminus(1|2);

[00:16] <camelia> rakudo-moar 5d9306: OUTPUT«any(any(1, -1), any(2, -2))␤»

[00:17] <Sgeo_> Aww would have been hilarious if return got executed twice

[00:17] <psch> .tell ab5tract as for non-jdk interop, you usually need to supply :jar<$jarfile> to the use statement

[00:17] <yoleaux> psch: I'll pass your message to ab5tract.

[00:18] <Sgeo_> I feel like only collapsing junctions into booleans is a limitation of the true power of junctions

[00:19] * psch ponders the intent behind "hilarious"

[00:20] <psch> .tell ab5tract i'm not excluding the possibility that there might be something borked in CLASSPATH handling either, though, but i've been away from that bit quite a while...

[00:20] <yoleaux> psch: I'll pass your message to ab5tract.

[00:22] <psch> Sgeo_: a Junction decides between True and False, that's the two forks of the road it has in front of itself.  mind, i'm *not* saying it's the best way to have them, just that it does make sense to me to hav'em like that

[00:23] <psch> Sgeo_: a prototype exploring different behavior might be appreciated

[00:29] *** llfourn joined
[00:31] *** gfldex left
[00:32] <vendethiel> Sgeo_: what else would you collapse them into that can't be a "for"?

[00:33] *** llfourn left
[00:34] <Sgeo_> A list or set?

[00:37] <Sgeo_> I'm thinking in analogy with Haskell's list monad

[00:39] <psch> m: say 1|2|3 ~~ 2

[00:39] <camelia> rakudo-moar 5d9306: OUTPUT«any(False, True, False)␤»

[00:39] <psch> Sgeo_: Junctions superseed that, don't they?

[00:40] <psch> as in, collapsing a Junction to a Set still gives you a Junction

[00:41] <Sgeo_> Well, if you're using it to solve problems, you probably want to get a flattened list out... grep doesn't work on junctions does it?

[00:42] <Sgeo_> m: @coins = (5, 25) X+ (5, 25); say (grep @coins: * > 40)

[00:42] <camelia> rakudo-moar 5d9306: OUTPUT«5===SORRY!5=== Error while compiling /tmp/H33vhGWua3␤Variable '@coins' is not declared␤at /tmp/H33vhGWua3:1␤------> 3<BOL>7⏏5@coins = (5, 25) X+ (5, 25); say (grep @␤»

[00:42] <Sgeo_> m:my @coins = (5, 25) X+ (5, 25); say (grep @coins: * > 40)

[00:42] <Sgeo_> m: my @coins = (5, 25) X+ (5, 25); say (grep @coins: * > 40)

[00:42] <camelia> rakudo-moar 5d9306: OUTPUT«50␤»

[00:42] <Sgeo_> m: my @coins = (5, 25) X+ (5, 25); say (grep @coins: * > 29)

[00:42] <camelia> rakudo-moar 5d9306: OUTPUT«30 30 50␤»

[00:42] <vendethiel> m: my @coins = (5, 25) X+ (5, 25); say grep @coins: * > 40 #shouldn't need the ()

[00:43] <camelia> rakudo-moar 5d9306: OUTPUT«50␤»

[00:43] <Sgeo_> Can that be expressed using Junctions and normal +?

[00:43] <vendethiel> where would junctions be used here?

[00:43] <Sgeo_> After all, a junction is a superposition of values, just like the way these lists are used here

[00:44] <psch> m: my @vals = 5|25 + 5|25; say @vals.perl

[00:44] <camelia> rakudo-moar 5d9306: OUTPUT«[any(5, 30, 25)]<>␤»

[00:44] <vendethiel> it's a superposition of *possibilities*, imho

[00:44] <psch> m: my @vals = (5|25) + (5|25); say @vals.perl

[00:44] <camelia> rakudo-moar 5d9306: OUTPUT«[any(any(10, 30), any(30, 50))]<>␤»

[00:44] <vendethiel> m: my @v = ^10; say @v.any

[00:44] <camelia> rakudo-moar 5d9306: OUTPUT«any(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)␤»

[00:44] <psch> yeah, what vendethiel++ said

[00:44] <psch> Junctions aren't values

[00:44] *** captain-adequate left
[00:45] *** mr-foobar joined
[00:45] <psch> and i'm aware that the distinction between values and possibilities is... weird

[00:45] <Sgeo_> Incidentally, why is * an Any?

[00:45] <leont> Why would it be anything else?

[00:46] <Sgeo_> It changes the meaning of calls that aren't expecting it, the way Junctions do.. is it because it only does that at compile-time?

[00:46] <leont> It doesn't do weird dispatch things like Junctions

[00:46] <vendethiel> Sgeo_: * is a Whatever

[00:46] <psch> the question is "why is Whatever below Any in the type hierarchy"?

[00:46] <Sgeo_> vendethiel, what psch said

[00:47] <vendethiel> ah, okay :)

[00:47] <psch> the default type for parameters is Any

[00:47] <psch> and we want to be able to curry core functions

[00:48] <ShimmerFairy> Sgeo_: I prefer to think of the Any type as being the parent of "Any"thing (Junctions don't count because they're a superposition of things, not a thing itself).

[00:48] <psch> (that's the best reason i can think of at the moment, although there's probably better ones)

[00:48] <Sgeo_> psch, why would Whatever not being below Any hamper that? The currying process shouldn't require sending an actual Whatever to a function

[00:49] <Sgeo_> ShimmerFairy, but a literal * in a function call for most functions isn't any thing, it's syntax sugar for a closure

[00:50] <Sgeo_> m: sub f(Any $x) { say "f()"; }; say f(*);

[00:50] <camelia> rakudo-moar 5d9306: OUTPUT«f()␤True␤»

[00:50] <Sgeo_> o.O

[00:50] <Sgeo_> m: sub f($x) { say "f()"; }; say f(*);

[00:50] <camelia> rakudo-moar 5d9306: OUTPUT«f()␤True␤»

[00:51] * vendethiel isn't sure what's surprising (knowing Whatever <: Any)

[00:51] <Sgeo_> I thought * was supposed to be syntax sugar for currying, this seems to limit when it can be used

[00:52] <vendethiel> * stops at the method call boundary

[00:52] <leont> It is, too

[00:52] <ShimmerFairy> If * is used in an expression, it generates a WhateverCode

[00:52] <vendethiel> so that a(* + 3) isn't \x => a(x + 3)

[00:53] <vendethiel> ..and, like ShimmerFairy just said, if used as a term, it's a WhateverCode object

[00:53] <vendethiel> (used for stuff like *..*)

[00:53] <leont> It's really a "make easy things easy" feature, taken to a new extreme

[00:53] <ShimmerFairy> for example, the popular  @a[*-1]  actually passes a WhateverCode object that the subscripting op gives the size of the array as an argument

[00:53] <vendethiel> m: multi infix:<..>(Whatever, Whatever){'vOv'}; multi infix:<..>(Int $a, Int $b){ "$a..$b" }; say 3..4; say *..*

[00:53] <camelia> rakudo-moar 5d9306: OUTPUT«3..4␤vOv␤»

[00:54] <Sgeo_> But then f(1, *, 3) doesn't work so that isn't making that easy thing easy

[00:54] <psch> Sgeo_: * is a shorthand for the *type* Whatever, which creeate... what ShimmerFairy++ said

[00:54] <vendethiel> Sgeo_: again -- * stops at this level. it doesn't traverse calls.

[00:54] <psch> oooh

[00:54] <psch> ~~ and * are special

[00:54] <ShimmerFairy> m: my @a = 0,1,2,3; say @a[*/2]

[00:54] <camelia> rakudo-moar 5d9306: OUTPUT«2␤»

[00:55] <psch> because Whatever is special

[00:55] <ShimmerFairy> ^ you can get the center element like that (or close to center for even-sized lists)

[00:55] <vendethiel> again -- if * didn't stop at method calls, `a(* + 2)` would be `sub ($VAL) { a($VAL + 2) }` instead of what we currently have

[00:55] <leont> Sgeo_: there are plenty of other ways to curry less simple cases

[00:55] <vendethiel> s/method //

[00:55] <psch> Sgeo_: * is *not* sugar for currying, it's creating a closure

[00:55] <psch> (in my mind those are distinct)

[00:55] <Sgeo_> psch, sorry for inaccurate terminology

[00:56] <vendethiel> [02:47] <psch> and we want to be able to curry core functions

[00:56] <psch> because the close can be handled explicitely by the operator

[00:56] <Sgeo_> (On my part I mean)

[00:56] <vendethiel> I think it's because of that :P

[00:56] <psch> vendethiel: yeah, i seem to have messed up there :)

[00:56] <psch> vendethiel++ # attentiveness

[00:56] *** raiph left
[00:56] <skids> Sgeo_: Whatever is Any specifically so you can do that.  So you can make intellginet multis with their own Whatever candidates.  See http://doc.perl6.org/type/WhateverCode

[00:57] <vendethiel> I made an example of a multi with a Whatever-only candidate 3 minutes ago :)

[00:57] <ShimmerFairy> m: sub foo(Int $a, Int $b) { $a * $b }; my &double = &foo.assuming(2); say double(4)  # Sgeo_, here's how you can have currying in P6

[00:57] <camelia> rakudo-moar 5d9306: OUTPUT«8␤»

[00:57] <Sgeo_> COuldn't you make a multi with a Mu Whatever?

[00:57] * vendethiel didn't even know Whatever was Any until now :)

[00:58] <psch> shifting Whatever higher in the type hierarchy would probably screw with Junction somehow

[00:58] <vendethiel> m: say Whatever ~~ Any; say Junction ~~ Anym

[00:58] <camelia> rakudo-moar 5d9306: OUTPUT«5===SORRY!5=== Error while compiling /tmp/COjTSdyI_y␤Undeclared name:␤    Anym used at line 1. Did you mean 'Any'?␤␤»

[00:58] <vendethiel> m: say Whatever ~~ Any; say Junction ~~ Any; # grr

[00:58] <camelia> rakudo-moar 5d9306: OUTPUT«True␤False␤»

[00:58] <psch> m: my $f = 2 * *|2; 

[00:58] <camelia> rakudo-moar 5d9306: ( no output )

[00:58] <psch> m: my $f = 2 * *|2; say $f(2)

[00:58] <camelia> rakudo-moar 5d9306: OUTPUT«Cannot find method 'postcircumfix:<( )>'␤  in block <unit> at /tmp/wP7rmrtkEY:1␤␤»

[00:58] <psch> m: my $f = 2 * (*|2); say $f(2)

[00:58] <camelia> rakudo-moar 5d9306: OUTPUT«Cannot call Numeric(Whatever: ); none of these signatures match:␤    (Mu:U \v: *%_)␤  in block <unit> at /tmp/6ly0_YJsZi:1␤␤»

[00:58] <vendethiel> psch: yeah, it very well might

[00:59] <skids> Sgeo: Yes but you'd have to explicitly Mu the parameter.

[00:59] <ShimmerFairy> Sgeo_: the way I see it, you need a special reason to have something _not_ inherit from Any. That is, you need a special reason why someone can't use the "Any" type to pick your type up as part of the normal conception of "anything"

[00:59] <psch> an Any-thing :)

[01:00] <psch> if you want a Mu-thing you have to ask for it

[01:00] <Sgeo_> ShimmerFairy, the way I thought it worked seemed a sufficient reason

[01:00] <Sgeo_> But it doesn't work that way, ok

[01:00] <psch> Sgeo_: i'm still unclear on the way you thought it worked

[01:01] <Sgeo_> vendethiel18> again -- if * didn't stop at method calls, `a(* + 2)` would be `sub ($VAL) { a($VAL + 2) }` instead of what we currently have

[01:01] <psch> Sgeo_: the one thing i distinctly picked up on is * being currying-sugar

[01:01] <Sgeo_> That way

[01:01] <ShimmerFairy> Sgeo_: fair enough. The Whatever type is just to make a number of simple things convenient, we still have closures/pointy blocks/etc. for other cases.

[01:01] <vendethiel> Sgeo_: it's the same with scala's _, say

[01:01] <vendethiel> (...though scala's has MUCH MORE COMPLEX rules)

[01:02] <ShimmerFairy> e.g. what you want for  foo(*)  is not much more verbose as  { foo($^a) }

[01:02] <psch> so, what should < my $f = * + 2; say $f(2) > do instead of what it does..?

[01:02] <psch> i'm a bit lost, i'll admit

[01:04] <ShimmerFairy> It's not so much currying as a compact way of giving an expression to something and saying "this part can be Whatever". It allows @a[*-1] to be more expressive than @a[-1] , for example.

[01:05] <psch> actually, i'm getting out of here again.  i apparently got hung up on the wrong end of the discussion just now, which is a decent hint for "you're too tired for this stuff" :)

[01:05] <psch> o/

[01:05] <ShimmerFairy> o/

[01:07] <vendethiel> Sgeo_: well, it'd be a bit unwieldly then. we'd need some kind of way to "stop it"

[01:07] <vendethiel> "don't cross THIS call!" - which would look ugly

[01:09] <TimToady> so we limit the autopriming to unary and binary operators (counting method calls a funny postfix), and otherwise a function must decide for itself what it'll do with a Whatever argument

[01:10] <TimToady> but really, the general case is handled with .assuming if you want partial function application

[01:10] * vendethiel checks for himself and sees he's speaking at the SPW2015 at 4pm

[01:11] <ShimmerFairy> (or wrapping in closures and such if you need to do partial application out of order ☺)

[01:22] *** beastd left
[01:22] *** rmgk_ joined
[01:22] *** rmgk is now known as Guest18266

[01:22] *** Guest18266 left
[01:22] *** rmgk_ is now known as rmgk

[01:31] <dalek> roast: 5151900 | skids++ | S06-multi/ (2 files):

[01:31] <dalek> roast: Rerun many multisig tests with multisigs wrapped in a capture.

[01:31] <dalek> roast: 

[01:31] <dalek> roast: Also, skip the test in by-trait.t even though it is not in

[01:31] <dalek> roast: spectest.data, for curation purposes.  Someone will need

[01:31] <dalek> roast: to add S06-multi/signature.t to spectest.data in rakudo repo

[01:31] <dalek> roast: to activate.

[01:31] <dalek> roast: review: https://github.com/perl6/roast/commit/51519002b8

[01:32] <skids> So, ironically a few small MMD things work better inside :(|c(...)) than in :(...).

[01:32] <skids> But if it is to be considered an escape hatch for implicit *%_ there is one critical thing missing.

[01:33] <skids> In that the subsigs are not a key for MMD sorting purposes.

[01:33] *** TEttinger joined
[01:33] * skids looks for an RT on that.

[01:38] <b2gills> Sgeo_: The Whatever star is used for more than just currying

[01:39] <b2gills> m: say (^5).pick(Whatever); say (^5).pick(*)

[01:39] <camelia> rakudo-moar 5d9306: OUTPUT«0 4 2 3 1␤1 0 4 2 3␤»

[01:47] <skids> Nope, close with RT#124935 and RT#76486 but needs its own RT.  So, sigh, email time.

[01:52] *** Hor|zon joined
[01:57] *** Hor|zon left
[01:58] *** vendethiel left
[02:06] *** leont left
[02:21] <dalek> roast: 4ebfad3 | skids++ | S06-multi/subsignature.t:

[02:21] <dalek> roast: Add new RT number to new tests.

[02:21] <dalek> roast: review: https://github.com/perl6/roast/commit/4ebfad3179

[02:30] *** llfourn joined
[02:32] *** bin_005 joined
[02:34] *** llfourn left
[02:43] *** bin_005 left
[02:44] *** bin_005_s joined
[02:48] *** noganex joined
[02:51] *** noganex_ left
[03:20] *** yqt left
[03:25] *** BenGoldberg left
[03:30] *** kaare_ joined
[03:53] *** Hor|zon joined
[03:58] *** Hor|zon left
[04:06] *** roguelazer joined
[04:09] *** roguelazer left
[04:17] *** ShimmerFairy left
[04:31] *** llfourn joined
[04:32] *** ShimmerFairy joined
[04:33] *** azawawi joined
[04:36] <azawawi> hi

[04:37] *** silug_ left
[04:46] *** roguelazer joined
[04:47] *** gfldex joined
[04:50] *** bin_005_s_x joined
[04:50] *** bin_005_s left
[04:51] *** silug_ joined
[05:05] *** bin_005_s_x left
[05:05] *** roguelazer left
[05:06] *** bin_005 joined
[05:10] *** virtualsue joined
[05:10] *** davido___ joined
[05:10] *** virtualsue left
[05:12] *** davido__ left
[05:15] *** azawawi left
[05:18] *** llfourn left
[05:22] *** diana_olhovik_ joined
[05:25] *** ShimmerFairy left
[05:30] *** llfourn joined
[05:35] *** virtualsue joined
[05:36] *** davido__ joined
[05:38] *** davido___ left
[05:39] *** ShimmerFairy joined
[05:54] *** Hor|zon joined
[05:59] *** Hor|zon left
[06:00] *** FROGGS joined
[06:00] *** virtualsue left
[06:01] *** skids left
[06:16] <dalek> rakudo-star-daily: 32d26fa | coke++ | log/ (9 files):

[06:16] <dalek> rakudo-star-daily: today (automated commit)

[06:16] <dalek> rakudo-star-daily: review: https://github.com/coke/rakudo-star-daily/commit/32d26fa4b7

[06:28] *** RabidGravy joined
[06:43] *** AlexDaniel left
[06:44] *** ShimmerFairy left
[06:45] *** llfourn left
[06:46] *** llfourn joined
[06:47] <Woodi> hi today :)

[06:52] *** mr-foobar left
[06:53] <Woodi> so, version control systems was lock-based - to modify file VCS locked it and then unlocked when finished. now looks merge and merge conflicts resolution is industry state of the art ;) of course int counters cannot be merged bat structures can, just "diff" them, fine grain locking is not needed :)

[06:54] <Woodi> just small and naive point of view :) but maybe something could evolve from it

[06:55] *** Hor|zon joined
[06:55] <Woodi> but probably STM and HTM by Intel tripped on this...

[06:56] *** ShimmerFairy joined
[07:00] *** Hor|zon left
[07:01] * RabidGravy shudders at the Visual Source Safe flashback

[07:17] *** darutoko joined
[07:29] <Woodi> RabidGravy: what goes wrong ? except unstability...

[07:30] <RabidGravy> it, by default, locks the respository completely while someone has it checked out

[07:33] <moritz> sounds like fun with a team of 5 or so :-)

[07:34] <moritz> (or even with > 1)

[07:36] *** llfourn left
[07:39] <Woodi> moritz: but VSS born as local thing, it support DOS :)

[07:40] *** virtualsue joined
[07:40] <Woodi> anyone can say good word about Team Foundation Server ? compared to git

[07:40] <RabidGravy> yeah, it's basically a shagged up fork of RCS at hart

[07:40] <RabidGravy> heart

[07:41] <RabidGravy> haven't done any serious windows development for ten years or so

[07:41] <Woodi> RabidGravy: but we still do not have version control thing for plain users with ability tu store blobs like mp3

[07:41] *** virtualsue_ joined
[07:42] <Woodi> but maybe mp3 not realy support versions :)

[07:42] <RabidGravy> not really

[07:43] <RabidGravy> you need a proper content management system which is aware of the structure of the data to do things like that

[07:44] <Woodi> but I mean some nice database for plain users. maybe directories are too universal, like lists :)

[07:44] <TEttinger> plasticSCM may be better for binary-heavy stuff, but not open source (free I think)

[07:45] <TEttinger> Unity almost always uses binary blobs for projects, and they recommend PlasticSCM for that stuff

[07:45] *** virtualsue left
[07:45] *** virtualsue_ is now known as virtualsue

[07:45] <RabidGravy> or a mainframe type OS where all the files are versioned by default

[07:46] <moritz> TEttinger: I've also heard good things about Perforce's ability to handle large files

[07:46] <moritz> never used it, though

[07:46] <Woodi> TEttinger: "more than 500k files", git do not support it ? what feature is responsible for that ?

[07:46] <TEttinger> I have no clue.

[07:47] <RabidGravy> but really, for structured files like music or images e.g. the thing that is managing them needs to understamd the structure, because for example a change in the metadata is different in principle to a change in the actual content

[07:47] <moritz> Woodi: in git, each commit is basically a snapshot of the whole repo (though stored in a compressed format)

[07:48] <moritz> Woodi: so that means that with 500k files, meta data size really explodes

[07:48] <Woodi> ah, I need to read sentences completly... plasticSCM claims to be fast

[07:48] <Woodi> moritz: yes, that too

[07:51] <Woodi> looks plasticSCM uses relational databases for storage. some git extension could do same thing

[07:53] <Sgeo_> m: False ~~ True

[07:53] <camelia> rakudo-moar 5d9306: OUTPUT«Potential difficulties:␤    Smartmatch against True always matches; if you mean to test the topic for truthiness, use :so or *.so or ?* instead␤    at /tmp/7CwQKcKq70:1␤    ------> 3False ~~7⏏5 True␤WARNINGS:␤Useless use of "~" in expressio…»

[07:54] <Sgeo_> m: 1 ~~ Bool

[07:54] <camelia> rakudo-moar 5d9306: ( no output )

[07:54] <Sgeo_> m: say 1 ~~ Bool

[07:54] <camelia> rakudo-moar 5d9306: OUTPUT«False␤»

[07:54] <Sgeo_> m: say 1|2 ~~ Int

[07:54] <camelia> rakudo-moar 5d9306: OUTPUT«any(True, True)␤»

[07:54] <Sgeo_> m: say 1|2 ~~ Mu

[07:54] <camelia> rakudo-moar 5d9306: OUTPUT«any(True, True)␤»

[07:55] <Sgeo_> say Junction.ACCEPTS(1|2)

[07:55] <Sgeo_> m: say Junction.ACCEPTS(1|2)

[07:55] <camelia> rakudo-moar 5d9306: OUTPUT«True␤»

[07:55] <Sgeo_> Can I private message camelia?

[07:55] <Sgeo_> Yay I can!

[07:56] *** Hor|zon joined
[07:57] <moritz> you just have to remember to use the 'm:' prefix in private message too

[07:58] <Sgeo_> m: say &say.signature

[07:58] <camelia> rakudo-moar 5d9306: OUTPUT«5===SORRY!5=== Error while compiling /tmp/rc5EYkiPk3␤Bogus postfix␤at /tmp/rc5EYkiPk3:1␤------> 3say &say.signature7⏏5␤    expecting any of:␤        infix␤        infix stopper␤        postfix␤        statement end␤        stat…»

[07:58] <Sgeo_> m: say &say.signature

[07:58] <camelia> rakudo-moar 5d9306: OUTPUT«(|)␤»

[07:59] <Sgeo_> So that | somehow means say accepts Mu?

[07:59] <RabidGravy> say is a multi, that's just the proto

[07:59] <Sgeo_> Also I have not the faintest idea how I copy/pasted that character from the other IRC tab

[08:00] <Sgeo_> HMm seems like my input was not that character, newline maybe, which got mangled?

[08:00] *** Hor|zon left
[08:02] <Sgeo_> Maybe I should try to make a Racket lang that supports Junctions natively

[08:03] <Sgeo_> Wouldn't really use it, but could be fun

[08:04] <Sgeo_> m: say map {$_ * 5}, (1|2),(3|4) 

[08:04] <camelia> rakudo-moar 5d9306: OUTPUT«any(5, 10) any(15, 20)␤»

[08:05] <Sgeo_> Wouldn't really work in Racket the way I'm envisioning because Racket's native map would not call the function with the special Junction-detection mechanism, so meh

[08:05] <Sgeo_> Racket's mechanism for redefining function application is a bit meh in that sense

[08:05] <Sgeo_> I should sleep

[08:25] *** diana_olhovik_ left
[08:39] *** mr-foobar joined
[08:50] <Sgeo_> Perl6 puts an eject symbol into its error messages?

[08:50] <Sgeo_> (Reading some slides and noticed it)

[09:02] *** llfourn joined
[09:08] *** TEttinger left
[09:08] *** vendethiel joined
[09:10] <moritz> Sgeo_: yes, it does

[09:10] <moritz> m: 1 1

[09:10] <camelia> rakudo-moar 5d9306: OUTPUT«5===SORRY!5=== Error while compiling /tmp/XpHvSvA6jp␤Two terms in a row␤at /tmp/XpHvSvA6jp:1␤------> 0317⏏5 1␤    expecting any of:␤        infix␤        infix stopper␤        statement end␤        statement modifier␤        sta…»

[09:14] *** Foxcool joined
[09:14] <vendethiel> Sgeo_: well, you decide what you want to provide with your Racket #lang, just don't re-export racket/base, right?

[09:16] *** brrt joined
[09:17] *** ShimmerFairy left
[09:17] <vendethiel> (most Racket langs do `(provide (all-from-out racket))`)

[09:19] <RabidGravy> would like to make URI mutatable like the P5 one but really don't know where to start

[09:21] *** pierrot left
[09:21] <RabidGravy> seems wrong hacking around it's inability to change the URI by string manipulation

[09:21] *** Begi joined
[09:23] <Begi> Hey ! I'm coding a little blog engine with Bailaidor. What's the best way to save my news ? 

[09:23] <Begi> JSON files in a MongoDB database ?

[09:24] <jdv79> RabidGravy: make the parts rw?

[09:24] <jdv79> text files on a filesystem work well i'm told

[09:25] *** pierrot joined
[09:27] <Begi> I've already try with text files, it was good.But is is secure ?

[09:27] <RabidGravy> jdv79, yeah, there's the problem - the attributes hold the match objects from the grammar :-\

[09:27] <jdv79> URI needs to be mutable to be useful in a few caes i've used in the past

[09:27] <jdv79> *cases

[09:27] <RabidGravy> Begi, if your filesystem permissions are secure then yes :)

[09:27] *** brrt left
[09:27] <RabidGravy> anyway off out to get mrs Gravy

[09:29] *** Foxcool left
[09:29] *** ShimmerFairy joined
[09:30] <moritz> Begi: text files are secure, as long as the file names are not user-supplied

[09:31] <moritz> Begi: if they are, you have to some heavy whiteslisting / validation front-up

[09:32] *** leont joined
[09:32] <jdv79> RabidGravy: they look like Strs to me.

[09:33] <Begi> moritz: Ok thanks. It seems good. i'll test

[09:36] *** RabidGravy left
[09:57] *** Hor|zon joined
[09:57] *** Begi1 joined
[10:00] *** Begi left
[10:01] <nine> jdv79: what are those use cases_

[10:01] *** telex left
[10:01] *** Hor|zon left
[10:02] *** telex joined
[10:03] <jdv79> generating url variants for different envs is one 

[10:04] <jdv79> generating a set of abs urls with variants for public use

[10:04] <nine> Do they really need to be mutable for that, or would it be enough to be able to easily create new ones based on an existing URI + modifications?

[10:05] <jdv79> well, only one or two parts change so that's basically down to string mangling

[10:05] <jdv79> seems kinda lame

[10:05] <jdv79> i'd rather just loop over some attr sets

[10:06] <jdv79> plus if each attr validated its part of the grammar on set it'd be cool that way 

[10:07] <jdv79> or if you could set the attrs instead of the string in the constructor that'd be closer

[10:07] <jdv79> but wasting cycles

[10:16] *** ribasushi joined
[10:17] <jdv79> is starting a match "under" TOP possible?

[10:18] <jdv79> lets say i want to use IETF::RFC_Grammar::URI::scheme to validate a standalone scheme string?

[10:18] <jnthn> IETF::RFC_Grammar::URI.parse($str, :rule<scheme>)

[10:19] <jdv79> oh, right - TOP is just the default.  thanks.

[10:20] *** Begi2 joined
[10:21] *** Begi1 left
[10:23] <nine> Non-deterministic destructors are...a challenge

[10:24] <jdv79> hmm, just read the docs for URI - i exposing the match obj like that a good idea?

[10:24] *** estrabd left
[10:24] <nine> Is there a way to force a GC run yet?

[10:25] <jdv79> strikes me as unnecessary tight coupling

[10:25] <jdv79> s/i/is

[10:25] <jdv79> i think i say a nqp op a few days ago in here

[10:33] <jdv79> nqp::force_gc() maybe

[10:43] *** abraxxa joined
[10:43] *** abraxxa left
[10:55] *** rindolf joined
[10:56] *** bin_005_b joined
[10:56] <jdv79> is there a Maybe?

[10:57] <jdv79> i have an attr that seems to want to be a subset of a str or Nil

[10:58] <timotimo> yes, nqp::force_gc(), but it will only force the gc to start, not necessarily a major collection

[10:58] *** bin_005 left
[11:01] <nine> So in other words, it may help but is in no way realiable.

[11:03] *** laouji joined
[11:04] <timotimo> right

[11:07] *** laouji left
[11:07] <jdv79> so how is /foo an absolute uri?

[11:07] <jdv79> i find the URI module disturbing

[11:07] <dalek> Inline-Perl5: eb00360 | (Stefan Seifert)++ | lib/Inline/Perl5.pm6:

[11:07] <dalek> Inline-Perl5: Don't destroy P5 objects after the P5 interpreter was shut down

[11:07] <dalek> Inline-Perl5: 

[11:07] <dalek> Inline-Perl5: We run the default_perl5 object's DESTROY method unconditionally in the END.

[11:07] <dalek> Inline-Perl5: If after that the GC runs, it may DESTROY wrapped Perl 5 objects. If we

[11:07] <dalek> Inline-Perl5: try to decrement their reference count, we're in no-mans-land and may

[11:07] <dalek> Inline-Perl5: encounter undesireable effects like segfaults. So don't do that.

[11:07] <dalek> Inline-Perl5: review: https://github.com/niner/Inline-Perl5/commit/eb00360d4f

[11:07] *** laouji joined
[11:15] <Woodi> jdv79: it is not relative, "base" or something :)

[11:15] <Woodi> also it's not URI at al ?

[11:16] <jdv79> yeah, i guess i'm mixing up uri and url

[11:19] *** xinming_ joined
[11:19] <jdv79> $!is_absolute = ?($!path || $.scheme); # seems odd

[11:20] *** xinming left
[11:23] <jdv79> Woodi: the rfc seems a bit muddled about it actually

[11:24] <jdv79> i think my intuituion is  correct

[11:24] <jdv79> there seems to be 3 forms of a uri relative reference; one of which is what i thought

[11:25] <jdv79> in any case i believe URI is incorrect

[11:25] *** Begi2 left
[11:28] *** Hor|zon joined
[11:33] *** Hor|zon left
[11:40] <dalek> Inline-Perl5: 7cc2793 | (Stefan Seifert)++ | / (2 files):

[11:40] <dalek> Inline-Perl5: Support passing named arguments to P6 class methods from P5

[11:40] <dalek> Inline-Perl5: 

[11:40] <dalek> Inline-Perl5: Named arguments can now be passed to Perl 6 class methods (e.g.

[11:40] <dalek> Inline-Perl5: constructors) using the v6::named function:

[11:40] <dalek> Inline-Perl5: 

[11:40] <dalek> Inline-Perl5: v6::invoke('MyClass', 'new', v6::named foo => 'bar', bar => 'baz');

[11:40] <dalek> Inline-Perl5: 

[11:40] <dalek> Inline-Perl5: All arguments before v6::named are considered positional:

[11:40] <dalek> Inline-Perl5: 

[11:40] <dalek> Inline-Perl5: v6::invoke('MyClass', 'do', "pos1", 2, "pos3", v6::named foo => 'bar');

[11:40] <dalek> Inline-Perl5: review: https://github.com/niner/Inline-Perl5/commit/7cc27931d3

[11:40] <nine> If someone has an idea for something shorter than v6::named, yet as descriptive, I'm all ears.

[11:41] *** diana_olhovik joined
[11:43] <jdv79> what is the p6 equiv of Moose's trigger on attr?

[11:49] *** virtualsue left
[11:51] *** virtualsue joined
[11:51] <jdv79> .tell RabidGravy maybe something like https://gist.github.com/jdv/73275880d42c7b952892 but still needs trigger mechanism to maintain other state.  not to mention the module seems messy in general.

[11:51] <yoleaux> jdv79: I'll pass your message to RabidGravy.

[11:53] <jdv79> i'm guessing a trigger is just a custom accessor that wraps and does its extra things 

[12:14] <jdv79> is there a way to get a more helpful type check failure error?

[12:15] <jnthn> What makes you consider the one you got unhelpful?

[12:16] <jnthn> They normally come with type got, type expected, what operation was going on, and where it happened...so if it's missing one of those something's up.

[12:16] *** TimToady left
[12:18] *** TimToady joined
[12:19] *** laouji left
[12:22] <jdv79> yeah, i guess its ok.  i'm just used to Moose where its overridable

[12:22] <jdv79> if you want to tweak it its nice 

[12:23] *** bin_005_b left
[12:29] *** Hor|zon joined
[12:32] *** geekosaur left
[12:33] *** geekosaur joined
[12:33] *** Hor|zon left
[12:34] *** laouji joined
[12:50] <jnthn> jdv79: We could probably work out a nice API for doing that in Perl 6

[12:51] *** laouji left
[12:51] *** laouji joined
[12:56] <mst> huh, is the http://doc.perl6.org/language/5to6 thing about unspace still a thing?

[12:56] <mst> lining up multiple method calls vertically isn't allowed?

[12:56] <timotimo> yeah, you need to put a \ before, because .foo is treated as "$_.foo" instead

[12:57] <mst> so what's the idiomatic way to split method call chains over multiple lines?

[12:57] <leont> I'm sure that's just a slang away :-p

[12:58] <timotimo> sure, i think Tuxic does it like that

[12:58] <timotimo> mst: put a \ at the end of the previous line

[12:58] <timotimo> just like it's shown in the example in 5to6

[13:04] <mst> huh

[13:04] <mst> that's ... going to take some getting used to, I suspect

[13:06] *** RabidGravy joined
[13:07] <mst> or at least it's going to require me convincing my brain that actually perl6 is a Tcl dialect

[13:09] <jnthn> m: given "foo" { say .uc } # for anyone wondering why it's not entirely trivial to "just allow whitespace before ."

[13:09] <camelia> rakudo-moar 5d9306: OUTPUT«FOO␤»

[13:10] <mst> jnthn: yeah, timotimo mentioned that and, honestly, I assumed it wasn't trivial by the fact that you hadn't done it already

[13:10] <mst> since I'm sure I'm far from the first person to go 'wha?'

[13:11] <mst> btw, we have a user over on irc.perl.org wondering: since most of the modules shipped with rakudo are .pm as an extension and don't have v6

[13:11] <mst> how exactly is synhi supposed to know it's perl6 code rather than perl5 ?

[13:13] * sjn would love to see a "perl6-lint" or somesuch easily-available tool that could be used to hint about "Kwalitee" like issues like that.

[13:16] <jnthn> mst: There are other heuristics (starts with a "module" declaration), but we probably need to do a better job of encouraging folks to do one of the two options you mentioned... Originally "the module starts with package without a block" was in the design docs as a sure-fire "this is Perl 5", but I suspect anything other than an extension or explicit v6 mention is fragile in the light of continued Perl 5 evolution.

[13:18] *** brrt joined
[13:18] <mst> right, I have at least one project where the .pm files mostly start with 'class Foo {'

[13:18] <mst> admittedly, that's me using lib::with::preamble to inject Moops implicitly via App::MyPerl

[13:18] <mst> which is hardly a central use of perl5

[13:19] *** rindolf left
[13:19] <jnthn> Aye, but if p5-mop gets done and gets in, it might make class Foo { ... } a regular thing in Perl 5 too

[13:20] <jnthn> Anyway, I'm fine with making sure the things in lib/ in Rakudo (all 4 or so of them...) get fixed up to have one of the two

[13:21] *** brrt left
[13:21] <mst> I think trying to convince everybody to use pm6 is probably the best bet

[13:21] <mst> since in both languages a single use statement can pretty much replace the compiler

[13:21] <mst> albeit in the case of perl6 that was more intentional than the ways I do it in perl5 ;)

[13:22] <RabidGravy> no quite sure why "use v6" isn't enough

[13:22] <yoleaux> 11:51Z <jdv79> RabidGravy: maybe something like https://gist.github.com/jdv/73275880d42c7b952892 but still needs trigger mechanism to maintain other state.  not to mention the module seems messy in general.

[13:24] <mst> RabidGravy: from my POV, "because it's much easier to spot one file with the wrong extension in a directory than one file where you forgot the use line"

[13:24] *** leont left
[13:24] <mst> make it easy for people to do the wrong thing without noticing, and all of them will

[13:24] <mst> and it should be considered our fault, not theirs, that that happens

[13:27] <jdv79> jnthn: yeah, i worded that poorly - meant "supply a type check failure error"

[13:29] <RabidGravy> jdv79, I think in the first instance I'm going to make a local sub-class that does just enough and think about the rest of URI later

[13:30] *** Hor|zon joined
[13:30] <jdv79> how about .p6m and .p6l?  never seen those used for anything else before.

[13:31] <nine> jdv79: what's wrong with .pm6?

[13:31] <jdv79> RabidGravy: i logged a bug on URI.  from my limited contact a valiant effort but seems buggy and messy.

[13:31] <jdv79> the internet says other things use it

[13:32] <jdv79> plus it doesn't read well - Perl Module 6 vs Perl 6 Module

[13:32] *** vendethiel left
[13:33] <nine> .pm6 seems to be used by Adobe Pagemaker 6. A product that's been superseeded by a newer version and a product line that's been cancelled more than a decade ago.

[13:33] <mst> .pl is also used by prolog, and I don't really seem to run into any trouble with that being a source of confusion

[13:34] <jdv79> that's true

[13:34] <mst> with the exception of #prolog where my personal mental parser has to do the try-catch-wtf-reparse dance occasionally

[13:34] *** Hor|zon left
[13:34] <jdv79> in any case a diff ext wrt to Perls would be a nice hint

[13:39] *** vendethiel joined
[13:43] <ribasushi> mmm there is the practical aspect of stat() not being cheap at all

[13:43] <ribasushi> when a user says `use X`

[13:44] <ribasushi> is rakudo expected to look for .pm6 *and* .pm ?

[13:44] <ribasushi> having this nailed down before 1.0 seems wise...

[13:44] <RabidGravy> currently it does yes

[13:44] <moritz> just like p5 looks for both .pm and .pmc files

[13:45] <ribasushi> moritz: yes, which is deemed a massive mistake by all involved at this point :/

[13:45] <nine> In fact, rakudo looks for .moarvm files as well

[13:46] <nine> ribasushi: I guess .pmc is out of favor not because of stat costs but because of the pretty useless precompilation support itself.

[13:46] <moritz> ribasushi: but note that looking into directories is only a fallback; normally installed modules are indexed in some sort of registry

[13:47] * jnthn away for a bit

[13:47] <mst> moritz: which is interesting because historically that's how Tcl always did it but more recently they've been moving to a .tm style that's much more like perl5's @INC

[13:48] <mst> I wonder if anybody's gone and discussed why they're doing that with them

[13:48] *** khw joined
[13:48] <moritz> mst: not that I'm aware of

[13:48] <mst> I feel like that might be an idea, for the purposes of successfully making different mistakes :)

[13:48] <moritz> aye

[13:49] <moritz> though we'd still need a concept for mapping non-ASCII modules names, :auth and :ver to file names

[13:49] <nine> Argh...now I finally got bit by Inline::Perl5 always calling P5 functions in array context.

[13:49] <mst> I'm not honestly making any comment on how best to solve the problem space

[13:50] <mst> I'm commenting they seem to be coming back the other way, so it's probably worth finding out why and trying to avoid that

[13:50] <moritz> yes, I understood that

[13:51] <mst> your "though we'd still need a concept" seemed to suggest you thought I was saying 'therefore, go back to @INC style'

[13:51] <mst> nine: if it's DBIC, we already added _rs versions of everything because TT does that :D

[13:53] <nine> mst: I know, and it is DBIC, indeed. However, I'm currently playing around with extending a Result class with Perl 6 while keeping this transparent for the application. The latter shouldn't notice that it's dealing with a P6 object now.

[13:54] <mst> ah

[13:54] <nine> And it may actually be possible to fix this, at least for method calls that are just piped through P6 space

[13:54] *** FROGGS_ joined
[13:58] *** FROGGS left
[14:00] *** llfourn left
[14:04] *** mr-foobar left
[14:05] *** Begi2 joined
[14:07] *** skids joined
[14:07] *** laouji left
[14:11] *** laouji joined
[14:13] *** lucasb joined
[14:21] *** virtualsue left
[14:25] *** virtualsue joined
[14:28] *** rindolf joined
[14:46] *** kaare_ left
[14:49] *** FatalNIX left
[14:49] *** FatalNIX joined
[14:52] <lucasb> m: sub f(| ($x)) { $x+1 }; f

[14:52] <camelia> rakudo-moar 5d9306: OUTPUT«(signal SEGV)»

[14:52] <lucasb> \o/ :D

[15:05] *** leont joined
[15:06] *** inokenty joined
[15:08] *** inokenty left
[15:08] <dalek> DBIish: 5aa551f | hoelzro++ | t/35-Pg-common.t:

[15:08] <dalek> DBIish: Fix dynamic variable typo

[15:08] <dalek> DBIish: 

[15:08] <dalek> DBIish: Without this fix, %*opts may end up undefined, depending on

[15:08] <dalek> DBIish: config_pg_connect

[15:08] <dalek> DBIish: review: https://github.com/perl6/DBIish/commit/5aa551f83a

[15:10] <skids> lucasb: yeah I dont know if unnamed captures with subsigs actually conflict with another syntax, but that's definitely LTA.

[15:11] <skids> I've just been naming them while a research the viability of the option of using them in the "implcit *%_ stays" scenario.

[15:12] <skids> s/ a / I /

[15:12] <skids> m: sub f(| ($x)) { $x+1 }; &f.signature.say; # this much works, at least.

[15:12] <camelia> rakudo-moar 5d9306: OUTPUT«(| (Any $x))␤»

[15:15] <dalek> DBIish/sqlite3-64-bit-fix: 0b45787 | hoelzro++ | t/99-common.pl6:

[15:15] <dalek> DBIish/sqlite3-64-bit-fix: Change common test table to use a bigint

[15:15] <dalek> DBIish/sqlite3-64-bit-fix: 

[15:15] <dalek> DBIish/sqlite3-64-bit-fix: This is for an upcoming test that tests how DBIish handles

[15:15] <dalek> DBIish/sqlite3-64-bit-fix: large integers

[15:15] <dalek> DBIish/sqlite3-64-bit-fix: review: https://github.com/perl6/DBIish/commit/0b4578730d

[15:15] <dalek> DBIish/sqlite3-64-bit-fix: 0d1eb2b | hoelzro++ | t/99-common.pl6:

[15:15] <dalek> DBIish/sqlite3-64-bit-fix: Test that integers >= 2**31 work with in prepared statements

[15:15] <dalek> DBIish/sqlite3-64-bit-fix: 

[15:15] <dalek> DBIish/sqlite3-64-bit-fix: The SQLite driver cannot currently handle integers in prepared

[15:15] <dalek> DBIish/sqlite3-64-bit-fix: statements greater than or equal to 2^31, so here's a test for

[15:15] <dalek> DBIish/sqlite3-64-bit-fix: that

[15:15] <dalek> DBIish/sqlite3-64-bit-fix: review: https://github.com/perl6/DBIish/commit/0d1eb2b5be

[15:15] <dalek> DBIish/sqlite3-64-bit-fix: 62063c5 | hoelzro++ | lib/DBDish/SQLite.pm6:

[15:15] <dalek> DBIish/sqlite3-64-bit-fix: Use 64-bit integers for SQLite binding

[15:15] <dalek> DBIish/sqlite3-64-bit-fix: review: https://github.com/perl6/DBIish/commit/62063c54b6

[15:17] <hoelzro> o/ #perl6

[15:18] <hoelzro> could someone look at https://github.com/perl6/DBIish/pull/15 and sanity check it for me before I merge it into master?

[15:18] <skids> m: sub f(|c ()) { 42 }; f(1); sub g(| ()) { 42 }; g(1); f(1); # also strange that g(1) does not fail.

[15:18] <camelia> rakudo-moar 5d9306: OUTPUT«Too many positionals passed; expected 0 arguments but got 1 in sub-signature of parameter c␤  in sub f at /tmp/XGlWsGLPCs:1␤  in block <unit> at /tmp/XGlWsGLPCs:1␤␤»

[15:19] <lucasb> skids: I found that segfault when I was taking a look at your RT ticket. :)

[15:20] <skids> I figured it was related.

[15:21] *** llfourn joined
[15:21] <skids> The .signature would suggest it is being parsed correctly at least.

[15:26] *** Timbus joined
[15:26] <lucasb> so, my understanding is that when the capture variable has a name, the subsignature *is* checked, but when it is nameless, the subsignature isn't checked, and the parameters inside it are never bound to anything

[15:26] <skids> ISTR noticin that.

[15:27] <mst> http://swannodette.github.io/2015/07/29/clojurescript-17/

[15:27] <mst> ok, that's really quite exciting

[15:28] *** mr-foobar joined
[15:31] *** Hor|zon joined
[15:34] *** mr-foobar left
[15:36] *** mr-foobar joined
[15:36] *** Hor|zon left
[15:37] <dalek> DBIish: 0b45787 | hoelzro++ | t/99-common.pl6:

[15:37] <dalek> DBIish: Change common test table to use a bigint

[15:37] <dalek> DBIish: 

[15:37] <dalek> DBIish: This is for an upcoming test that tests how DBIish handles

[15:37] <dalek> DBIish: large integers

[15:37] <dalek> DBIish: review: https://github.com/perl6/DBIish/commit/0b4578730d

[15:37] <dalek> DBIish: 0d1eb2b | hoelzro++ | t/99-common.pl6:

[15:37] <dalek> DBIish: Test that integers >= 2**31 work with in prepared statements

[15:37] <dalek> DBIish: 

[15:37] <dalek> DBIish: The SQLite driver cannot currently handle integers in prepared

[15:37] <dalek> DBIish: statements greater than or equal to 2^31, so here's a test for

[15:37] <dalek> DBIish: that

[15:37] <dalek> DBIish: review: https://github.com/perl6/DBIish/commit/0d1eb2b5be

[15:37] <dalek> DBIish: 62063c5 | hoelzro++ | lib/DBDish/SQLite.pm6:

[15:37] <dalek> DBIish: Use 64-bit integers for SQLite binding

[15:37] <dalek> DBIish: review: https://github.com/perl6/DBIish/commit/62063c54b6

[15:37] <dalek> DBIish: 5f7c327 | hoelzro++ | / (2 files):

[15:37] <dalek> DBIish: Merge pull request #15 from perl6/sqlite3-64-bit-fix

[15:37] <dalek> DBIish: 

[15:37] <dalek> DBIish: Sqlite3 64 bit fix

[15:37] <dalek> DBIish: review: https://github.com/perl6/DBIish/commit/5f7c3273b6

[15:40] *** FROGGS_ left
[15:41] *** mr_ron joined
[15:45] *** beastd joined
[15:46] *** laouji left
[15:51] <dalek> Inline-Perl5: ca54d43 | (Stefan Seifert)++ | / (3 files):

[15:51] <dalek> Inline-Perl5: New v6::extend helper for easier extending of P5 classes with v6-inline

[15:51] <dalek> Inline-Perl5: 

[15:51] <dalek> Inline-Perl5: use v6-inline; can be used to write part of a Perl 5 class in Perl 6. When

[15:51] <dalek> Inline-Perl5: Perl 5 code should be able to create objects of this class, a bit of a

[15:51] <dalek> Inline-Perl5: dance is necessary. A Perl 5 constructor creates the Perl 5 object and

[15:51] <dalek> Inline-Perl5: calls into Perl 6 to create the corresponding Perl 6 object. Those two

[15:51] <dalek> Inline-Perl5: are then hooked together by some reblessing.

[15:51] <dalek> Inline-Perl5: 

[15:51] <dalek> Inline-Perl5: v6::extend is the generic version of this dance, so that the typical

[15:51] <dalek> Inline-Perl5: Perl 5 construtor call can be like:

[15:51] <dalek> Inline-Perl5: sub create {

[15:51] <dalek> Inline-Perl5:     my ($class, %args) = @_;

[15:51] <dalek> Inline-Perl5:     return v6::extend($class, $class->new(%args), [], \%args);

[15:51] <dalek> Inline-Perl5: }

[15:51] <dalek> Inline-Perl5: review: https://github.com/niner/Inline-Perl5/commit/ca54d43b88

[16:01] <[TuxCM]> NICE!

[16:01] <[TuxCM]> test             50000    43.260    43.168

[16:01] <[TuxCM]> test-t           50000    42.768    42.677

[16:01] <[TuxCM]> going the right direction again

[16:01] <nine> [TuxCM]: at last :)

[16:02] *** virtualsue left
[16:05] * [TuxCM] waits for 35 to be really happy

[16:06] <nine> Looks to me like rakudo gained tons of features this year, but has not seen much performance work with everyone waiting for the GLR

[16:10] <vendethiel> nine: as someone who started with 2014.03-parrot... that's wrong :P

[16:12] <nine> vendethiel: you sure? I remember plenty of performance optimizations last year, including the ones inspired by the introduction of the profiler. But then the focus seemed to shift to the big three and 6.0.

[16:14] <vendethiel> nine: well, we probably have a few benchmarks

[16:18] *** jkva joined
[16:18] <nine> Well, there was some work spearheaded by lizmat++ to drive startup time into the ground :)

[16:18] <jnthn> We've made more progress on time/memory of late than raw speed.

[16:19] <jnthn> brrt++ is making good progress with improving the JIT code-gen though, which should offer a decent speed/memory improvement.

[16:19] *** dwarring left
[16:19] <nine> Oh yes, I'm very much looking forward to that :)

[16:19] <jnthn> And yeah, the GLR... :)

[16:20] <moritz> I mostly stopped profiling Perl 6 code, because 95% of the time it's just list iteration being slow

[16:20] <jnthn> I hope to have some initial guts prototyping work to show on Monday.

[16:20] <nine> jnthn: I wonder if I spend too much time here. I first read "a decont speed/memory improvement"

[16:20] <nine> wow, so soon!

[16:20] <jnthn> nine: hah :P

[16:21] <jnthn> You might have worked on too much guts if you see decont so often ;)

[16:21] <jnthn> (But don't stop ;))

[16:21] <nine> Well it's probably less working on and more reading

[16:22] *** jkva left
[16:32] *** Foxcool joined
[16:51] *** Thunder000 joined
[16:52] *** llfourn left
[16:52] *** kaare_ joined
[17:02] *** kaare_ left
[17:05] *** jkva joined
[17:05] *** jkva left
[17:11] *** Begi2 left
[17:12] <Sgeo_> m: say "If the quick brown fox jumps over the lazy dog, I did not break my laptop keyboard by using a disinfectant wipe on it"

[17:12] <camelia> rakudo-moar 5d9306: OUTPUT«If the quick brown fox jumps over the lazy dog, I did not break my laptop keyboard by using a disinfectant wipe on it␤»

[17:13] <Sgeo_> Mouse seems intact too, but feels really gross

[17:13] <timotimo> :|

[17:15] <vendethiel> .oO( how do you wash your Camelia? )

[17:20] *** Peter_R left
[17:21] *** Peter_R joined
[17:28] *** Thunder000 left
[17:32] *** Hor|zon joined
[17:35] *** skids left
[17:37] *** Hor|zon left
[17:38] <cognominal> vendethiel: like lotus, butterfly wings are water repellent

[17:40] *** mr_ron left
[17:40] <japhb> o/

[17:40] <yoleaux> 26 Jul 2015 13:35Z <moritz> japhb: in 2011, you added a point "Failure changes" to docs/ROADMAP; what changes are those? (If they are not needed anymore, or you forgot, please remove the TODO item)

[17:41] * japhb is back from ~a week away

[17:41] <japhb> Just looking at the last screen of text, it sounds like jnthn++ is working on the GLR core ... any other cool happenings?

[17:42] <japhb> .tell moritz I'm not sure, but I speculate the "Failure changes" were something to do with OKness or a similar idea.  At this point, I'm no longer sure.

[17:42] <yoleaux> japhb: I'll pass your message to moritz.

[17:43] *** perturbation joined
[17:45] <moritz> japhb: sounds like we can remove it from the roadmap, right?

[17:45] <yoleaux> 17:42Z <japhb> moritz: I'm not sure, but I speculate the "Failure changes" were something to do with OKness or a similar idea.  At this point, I'm no longer sure.

[17:46] <japhb> moritz: Yeah, I'd say so.

[17:47] <jnthn> japhb: I unbusted inlining regressions caused by earlier fixes I did to &?ROUTINE and fixed 10 RTs while I wasn't GLRing...

[17:47] <japhb> I might have just been sampling the air and noticed that at the time people were considering such a change.

[17:47] <japhb> jnthn: Woot!  Sounds like some good Perl 6 days then.  :-)

[17:48] <nine> I'm trying to propagate the P5 caller's context to P5 functions whose result is just passed through P6 space unmodified. How could I go on about this? I guess I'd need to pass on the information callframe by callframe without being able to make assumptions about the callee and drop it once someone in the chain does not pass it along.

[17:49] *** spider-mario joined
[17:52] *** Sgeo_ left
[17:53] <japhb> nine: Set a dynamic variable in the P5 -> P6 transition that can be examined on the P6 side to determine different returns to P5 space?  Of course, that just enables wantarray-like functionality when calling into P6.  It doesn't help with the P6 -> P5 call transition.

[17:53] <dalek> rakudo/nom: d8fa568 | moritz++ | docs/ROADMAP:

[17:53] <dalek> rakudo/nom: Remove "Failure changes" from ROADMAP

[17:53] <dalek> rakudo/nom: 

[17:53] <dalek> rakudo/nom: nobody seems to quite know anymore what it is supposed to be,

[17:53] <dalek> rakudo/nom: and our Failure looks pretty much up to spec

[17:53] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/d8fa56880d

[17:55] *** raiph joined
[17:59] <timotimo> japhb: you'll probably find azawawi's work on binding electron interesting

[18:04] <hoelzro> if an object is unreachable and the GC runs, is the object's DESTROY method guaranteed to be called (assuming it has one)?

[18:05] <hoelzro> or does DESTROY run at some time after the object is unreachable, if at all, with no guarantees on which collection?

[18:06] <hoelzro> I'm just seeing odd GC/DESTROY behavior here: https://gist.github.com/hoelzro/d140efaace0431c46512

[18:06] <japhb> timotimo: What exactly is electron?

[18:06] <timotimo> the framework that powers the atom code editor

[18:06] <timotimo> i suppose it's somewhat like adobe air?

[18:07] <japhb> Hmmm, interesting

[18:07] <japhb> Is it FOSS?

[18:08] <timotimo> i think so

[18:09] *** awwaiid left
[18:10] *** Foxcool left
[18:16] <RabidGravy> it's installable as a node app via NPM so it's definitely free and by extension "open source" dunno what the actual license is

[18:16] <RabidGravy> free as in beer anyway

[18:17] <hoelzro> perhaps I should ask in #moarvm?

[18:17] <cognominal> MIT License, see at the bottom https://github.com/logicalparadox/electron

[18:18] <cognominal> hum, maby be a different electron

[18:19] <cognominal> https://github.com/atom/electron/blob/master/LICENSE

[18:21] <cognominal> At non atomic scales, on should not confuse electrons.

[18:21] <RabidGravy> yeah that's the one http://electron.atom.io/

[18:22] <timotimo> hoelzro: the thing is: if the object is in The Old Generation, it'll take a full collection to unreach that object

[18:23] *** Begi2 joined
[18:28] <nine> japhb: a dynvar was my first idea. But that won't help me to distinguish P5 -> P6 -> P5 from P5 -> P6 -> P6 -> P5. In the latter case, I may most probably not propagate the caller context

[18:31] <mst> nine: jenga!

[18:31] <hoelzro> timotimo: does force_gc force a full collection?

[18:32] <timotimo> no

[18:32] <hoelzro> ah ha

[18:32] <timotimo> i think it just triggers the gc unconditionally

[18:33] <hoelzro> I'm wondering why having force_gc in a block vs not affects things...

[18:33] <hoelzro> I don't know if that qualifies as a "bug" though

[18:36] <timotimo> in a block vs not?

[18:36] <timotimo> how can you have it not in a block? ;)

[18:37] <timotimo> i mean, obviously having locals in scope when you run force_gc will cause more objects to be considered reachable

[18:37] <moritz> hoelzro: leaving a block doesn't trigger a GC run

[18:38] <hoelzro> timotimo, moritz: in my example, I have do { nqp::force_gc(); }, and DESTROY is not called

[18:39] <hoelzro> if I just use nqp::force_gc(), without the do { ... }, it *is* called

[18:39] <hoelzro> which is odd to me

[18:39] <timotimo> interesting

[18:39] <hoelzro> indeed =)

[18:39] <timotimo> but gc is magical anyway

[18:40] <timotimo> not terribly easy to reason about if everything in your language is managed via gc

[18:48] *** llfourn joined
[18:50] *** Foxcool joined
[18:53] *** llfourn left
[18:53] <jnthn> hoelzro: On the GC question: if we do conclude the object is unreachable, then it will bet put on a list of things to have DESTROY called on them. iirc, the scope we were in at the point of the GC being triggered has a special return handler attached, and so when we leave it the DESTROYs will be run.

[18:54] <timotimo> oh? that's interesting

[18:54] <timotimo> i never knew that

[18:55] <jnthn> Well, we have to run them at some point :)

[18:55] <timotimo> sure

[18:55] <jnthn> And somewhere somewhat safe

[18:55] <jnthn> And that place does pretty well

[18:55] <timotimo> yeah, not every place is safe

[18:56] <jnthn> As for the generations - yeah, if the object makes it to an older one we may not discover it's unreachable for a good while into the future.

[18:57] <jnthn> We're not going to make any stronger promises, I doubt, since doing so could constrain the kind of GC algos we're able to use.

[18:58] <jnthn> The GC is there to manage *memory*, not as a general resource management solution.

[18:59] <Woodi> so let's remove DESTROY! :)

[18:59] <timotimo> let's destroy REMOVE

[19:00] <jnthn> DESTROY does have some valid uses, but they're mostly for letting you write things that identify you leaked something, and maybe do some last-ditch clean-up

[19:00] <jnthn> (The leaked Failure case is one such example.)

[19:01] <Woodi> but END can do this too

[19:02] <jnthn> I...don't see it.

[19:02] *** Foxcool left
[19:02] <Woodi> hmm, right. app would be giant blob...

[19:02] <Woodi> I thinked LEAVE and END do the work

[19:03] <jnthn> LEAVE and END are good if you're wanting to do cleanup at an appropriate time, yes

[19:04] <Woodi> if I want it in not exactly specified time ? someday... :)

[19:05] <jnthn> Promise.in((^1000).pick).then({ cleanup() }); # pretty good intentional "some time" :P

[19:06] *** ribasushi left
[19:06] <Woodi> ok, so maybe LEAVE is enough to have finalization. and memory is GC problem

[19:07] <Woodi> s/\./?/

[19:08] *** Foxcool joined
[19:08] <jnthn> LEAVE (or "will leave") is where I'd tend to stick such cleanup, yes

[19:10] * TimToady just misread "undefined" as "underfed", obviously lunch time...

[19:12] <timotimo> don't underf your code!

[19:18] <moritz> let's avoid underfed behavior

[19:18] *** Begi2 left
[19:20] *** domidumont joined
[19:27] *** domidumont left
[19:30] <nine> Woodi: so where should I decrement the reference count of wrapped Perl 5 objects if not in DESTROY?

[19:31] *** Begi2 joined
[19:31] <timotimo> yeah, asking the programmer that uses Inline::Perl5 to do that would be bad

[19:33] *** Hor|zon joined
[19:36] *** davido__ left
[19:37] *** davido__ joined
[19:37] <ugexe> i just discovered a BEGIN block will be ran at different times depending on which side of a 'use XXX' statement it is on

[19:37] *** ribasushi joined
[19:38] *** Hor|zon left
[19:38] <ugexe> i understand why, just managed to trip me up :o

[19:40] *** smls joined
[19:42] *** bin_005 joined
[19:42] <TimToady> yeah, use also runs at BEGIN time

[19:42] <TimToady> likewise constant decls

[19:42] <jnthn> Everything decls, really

[19:43] <TimToady> well, I mean the initializer expression

[19:44] <jnthn> It's been something of a theme that every time Rakudo tried to put off when it had to effect a declaration or create a meta-object "'cus we don't need it yet", we did...

[19:44] <smls> m: my %a; %a{"x"; "y"} = 42; dd %a

[19:44] <camelia> rakudo-moar d8fa56: OUTPUT«%a = {:x({:y(42)})}<>␤»

[19:44] <smls> Didn't know hashes support multi-dim indexing too.

[19:44] <jnthn> Wow, me either

[19:44] *** ribasushi left
[19:45] <jnthn> Damn, I better be more careful when I refactor the slice handling for multi-dim arrays...

[19:45] <smls> http://design.perl6.org/S09.html#Hashes  <-- it seems to be by design

[19:45] <nwc10> is there a test for this?

[19:46] *** Begi2 left
[19:48] *** llfourn joined
[19:50] *** FROGGS joined
[19:53] *** llfourn left
[19:55] <smls> jnthn: Will your 'slice' refactor change the behavior of .[] for normal arrays?

[19:55] <smls> Or just add support for multi-dim arrays?

[19:57] <timotimo> the behavior? hopefully not?

[19:57] <timotimo> that wouldn't be a refactor in that case :)

[19:59] <jnthn> smls: That's not really a straight yes/no

[19:59] <jnthn> smls: If you mean "can I still use ; to dig into nested arrays", then yes.

[19:59] <jnthn> The API through which it happens will change.

[19:59] <smls> Well, there's been talk of possibly letting .[2, 4..7] truncate like .[4..7] does, for example. (Which I agreed with, but don't anymore now that I think of it as simple type-based dispatch.)

[20:00] <jnthn> Basically, all the dimensions of a ;'d thing will go to AT-POS

[20:00] <timotimo> hm, the thing i just said clashes a bit with the "great list refactor"

[20:01] <timotimo> probably would be "great list refactor + redesign"?

[20:01] <timotimo> glrr?

[20:01] <jnthn> And a fallback slurpy candidate in Any will take the first one, apply that indexing, and recurse

[20:01] *** bin_005 left
[20:01] <jnthn> And a multi-dim array will know how to take/use multiple of those indices

[20:02] <jnthn> timotimo: Yeah, it's rather dubious to call it a refactor ;)

[20:02] <jnthn> But hey, it's just words, it's not like we're doing stuff with language here. :P

[20:02] <timotimo> that slurpy fallback candidate ... i think we have something like that already and it's ridiculously slow

[20:02] <smls> jnthn: So custom AT-POS implementations will continue to work as they do now provided that they use $key rather than \key in their signature?

[20:05] *** darutoko left
[20:07] <smls> hm, I guess it would also have to be written as "multi method AT-POS" instead of "method AT-POS".

[20:08] <ShimmerFairy> .oO(Clearly, it stands for Great List Revision)

[20:08] <smls> revolution!

[20:10] <timotimo> revision, yeah, i like that

[20:11] <ShimmerFairy> smls: I had a thought about binary grammars the other day: for things like the IFF format, grammars (or something like them) would make it really nice to do something like  token TOP { <header> <chunk>+ }

[20:13] <smls> ShimmerFairy: After further reflection, I actually like skids' "structured OO" approach (https://gist.github.com/smls/bc5d0fb42f199574e339#comments) better than my grammar approach... :)

[20:13] <smls> for most use-cases anyway

[20:13] <smls> though the latter may still be needed

[20:15] *** xfix joined
[20:15] <smls> as skids wrote, it would be nice if the "structured OO" definitions could be used inside a grammar as well.

[20:16] <ShimmerFairy> smls: I'm not entirely sure I get what the structured OO approach even is, but IIUC then it feels too much like eschewing grammars for mountains of  if $part ~~ /something/ { ...  :)

[20:17] <smls> So in you example, one might define a "class IffHeader" and "class IffChunk" (with "is REPR('PointerPacker') does UnalignedStruct") or similar, and then write the whole grammar (or regex) would be /<struct(IffHeader)> <struct(IffChunk)>+/ or so

[20:19] <smls> That is, define classes with a special representation which know how to map their attributes to and from a chunk of a binary buffer.

[20:20] <ShimmerFairy> Ah, so the actual regex syntax here would be P6 objects, then? Sounds like it would get very interesting very quickly, not to imply that that would be a bad thing :) .

[20:21] <smls> of maybe even cut out the regex part completely, and have a root structure like:  class IffFile ... { has IffHeader $header; has IffChunk @chunks }

[20:22] <smls> ...and then simply "parse" by calling   IffFile.new($buffer)

[20:22] <ShimmerFairy> smls: Yeah, I was just thinking that the regex syntax thing becomes at least partially less useful

[20:22] <smls> yeah

[20:23] <smls> there are still use-cases where you need to do slightly more free-form parsing or searching in binary files, and for that having binary parsing support in grammars would still be useful.

[20:23] <smls> but for "normal" use-cases like unpacking a binary file format etc., the "structured OO" approach could probably work on its own without going through grammars.

[20:24] <ShimmerFairy> I'm thinking something tree-like perhaps:  Buf.rotor([BufPart.new(IffHeader), BufPart.new(IffChunk, :times(*))])  (misusing the term "rotor" here in the sense of "make a structure of out a flat array", wouldn't really be named that)

[20:24] *** bin_005 joined
[20:27] <smls> I think custom classes should be able to express all of that

[20:27] <ShimmerFairy> smls: I think the interesting part is that we want the flexibility that regexes give for parsing, but we don't want the same flexibility needed for textual data :)  (e.g. binary data doesn't need variable-length matching as often, but on the other hand needs to easily jump around the file)

[20:28] <smls> like   has IffChunk @chunks    would know gobble any number of chunks, while   has IffChunk @chunks[3]   would only take 3  etc.

[20:28] <ShimmerFairy> The only thing that worries me about that is that we'd be making P6 objects quite a bit more magical in just one context, and I'm not sure that's quite appropriate.

[20:29] <smls> and where the normal attribute annotation syntax is not sufficient, there could always be trait_mods, e.g.:   has $int16 $foo is endian("l");

[20:29] <ShimmerFairy> I would prefer something vaguely QAST-like in usage (that is, classes describing features of what happens), so that the special-ness isn't in the syntax so much :)

[20:30] <smls> "making P6 objects quite a bit more magical in just one context" -- All of that would be provided by the a custom REPR and role to mix into such classes

[20:31] <smls> that's what support for custom REPRs/HOWs is for, isn't it? To have classes with special behaviors in special contexts.

[20:32] <smls> I don't think it would be far off from what NativeCall already does with   class Point is repr('CStruct')  { ... } 

[20:32] <ShimmerFairy> I may be mistaken, but my understanding of REPRs deals more with how things are represented at the lower levels underneath Perl 6, not so much how it does stuff in Perl 6. (Metaobjects, however, are appropriate; cf. ClassHOW and GrammarHOW)

[20:34] <ShimmerFairy> I think it would/should be some sort of strange mixture of classes and grammars if a new metaobject were used  .oO( glass IFF_File { ... } )

[20:35] <smls> Isn't a custom HOW more for when you need method calls to do work differently than normal?

[20:35] <smls> Whereas a custom REPR is for when you need attribute storage/retrieval to be different from normal?

[20:35] <smls> (Correct me if I'm wrong.)

[20:36] <ShimmerFairy> smls: no, HOWs implement the various kinds of objects in Perl 6 (classes, grammars, subset types, etc.). A REPR is closely tied to the VM, responsible for laying out things in memory and such.

[20:36] <smls> Once could always export a custom keyword if it helps users to think of them differently from normal classes.

[20:37] <ShimmerFairy> smls: I happened to go over jnthn's NQP compiler-writing slides the other day, so this happens to be fresh in my mind :P

[20:37] <smls> well, "laying out things in memory" is what we want here isn't it?

[20:38] <smls> in this case, the memory is part of a Buf.

[20:39] <smls> (or at least constructed from it)

[20:39] <ShimmerFairy> I mean more along the lines of "OK, but I how do I, the underlying VM, actually store and use all this fancy data of yours?"

[20:39] <ShimmerFairy> (I'm sure jnthn++ could provide some clarification here if it turns out we're both confused ☺)

[20:39] <smls> :P

[20:41] <ShimmerFairy> smls: incidentally, I was looking over said slides because of my interest in writing a compiler for a pretty old language, and "should it be a REPR or a HOW or a what??" is exactly what's got me stumped on that project :P (so I'm currently trying to learn more about said language before moving on it)

[20:44] <ShimmerFairy> smls: in the case of binary parsing, at least, I suspect that by the time you get it in a Buf and want to extract info from it that messing with REPRs is the Wrong Thing™. (And an imaginary GlassHOW would just be little more than a convenience HOW, like GrammarHOW)

[20:48] *** TEttinger joined
[20:55] <lucasb> m: sub f(*%_) { say %_ }; my $c = \(:a,:b); f(|$c)

[20:55] <camelia> rakudo-moar d8fa56: OUTPUT«a => True, b => True␤»

[20:55] <lucasb> m: sub f() { say 'ok' }; my $c = \(:a,:b); f(|$c)

[20:55] <camelia> rakudo-moar d8fa56: OUTPUT«ok␤»

[20:56] <lucasb> ^^ Capture unpacking (prefix:<|>) should respect the empty signature?

[20:56] <lucasb> ...or subroutines have implicit *%_ just like methods?

[20:57] <ShimmerFairy> m: sub f() { say "ok" }; f(:a, :b)

[20:57] <camelia> rakudo-moar d8fa56: OUTPUT«Unexpected named parameter 'a' passed␤  in sub f at /tmp/Zvi3o6B8Ei:1␤  in block <unit> at /tmp/Zvi3o6B8Ei:1␤␤»

[20:59] <ShimmerFairy> lucasb: They do not have implicit *%_ . I'm not sure why that's accepted silently.

[20:59] <ShimmerFairy> m: multi sub f() { say 'ok' }; my $c = \(:a,:b); f(|$c)

[20:59] <camelia> rakudo-moar d8fa56: OUTPUT«Unexpected named parameter 'a' passed␤  in sub f at /tmp/l6aXvU3Mb4:1␤  in block <unit> at /tmp/l6aXvU3Mb4:1␤␤»

[21:00] <ShimmerFairy> When it's a multi, it appropriately dies. That might be a bug you've stumbled upon :)  (at least I would think so)

[21:00] <lucasb> ShimmerFairy: yep, agreed :)

[21:02] <ShimmerFairy> m: only sub f() { say 'ok' }; my $c = \(:a,:b); f(|$c)

[21:02] <camelia> rakudo-moar d8fa56: OUTPUT«ok␤»

[21:02] <ShimmerFairy> ^ just an explicit confirmation that non-multi (aka 'only') subs are buggy :)

[21:02] *** bin_005 left
[21:02] *** roguelazer joined
[21:04] *** bin_005 joined
[21:08] <lucasb> Just reporting another case where captures "lose" their named parameters:

[21:08] <lucasb> m: sub f(|c) { say c }; f(1,2,:a,:b)

[21:08] <camelia> rakudo-moar d8fa56: OUTPUT«\(1, 2, :a, :b)␤»

[21:08] <lucasb> m: sub f(|c) { say c }; f(1,2,:a,:b;3,4)

[21:08] <camelia> rakudo-moar d8fa56: OUTPUT«\((1, 2), (3, 4))␤»

[21:09] <ShimmerFairy> m: my $c = \(1,2,:a,:b;3,4); say $c.perl

[21:09] <camelia> rakudo-moar d8fa56: OUTPUT«\((1, 2), (3, 4))␤»

[21:09] <jnthn> smls: (custom AT-POS) actually \key works fine still because we pass multiple indexes as multiple arguments to AT-POS; and yeah, you need to write multi, but you likely already should have done that anyway to not preclude auto-viv

[21:09] <lucasb> yeah, yours is simpler, ShimmerFairy++

[21:09] <ShimmerFairy> m: my $c = \(1;2,:a,:b,3,4); say $c.perl

[21:09] <camelia> rakudo-moar d8fa56: OUTPUT«\((1,), (2, 3, 4))␤»

[21:10] <ShimmerFairy> lucasb: ^^^ looks to me like the multi-dim-ifier tosses named params, for whatever reason

[21:10] <smls> jnthn: what other -POS methods whould be multi?

[21:11] <smls> (I admit I don't understand Rakudo's auto-viv, which seems to be different from what S09 speculated.)

[21:11] <ShimmerFairy> lucasb: well, it could've been the function call specifically, I didn't know. That's why I checked just Captures :P

[21:13] <ShimmerFairy> smls: If I understand correctly, then generally, if you want to give your object the chance to move on to other possibilities, you should use 'multi' on "standard" P6 methods (e.g.  multi method perl(Foo:D:)  would allow a type object to go up the chain to a more appropriate .perl)

[21:14] <jnthn> smls: I'd make all of them be, but also constrain my only candidates the :D on the invocant. That way, you get the appropriate thing done for undefined objects on all the operations.

[21:15] <ShimmerFairy> I can still remember the time I was bit by not putting a :D on a  multi method gist :P

[21:15] <smls> ah, so the  -POS (Any:U)  candidates are what makes auto-viv work?

[21:15] <timotimo> yes

[21:15] <jnthn> (Auto-viv on AT/APPLY, False for EXISTS, etc.)

[21:15] <timotimo> well, not only those

[21:15] <jnthn> uh, apply? I meant ASSIGN

[21:16] <ShimmerFairy> Am I right in understanding auto-viv as "turn this item into a list/hash", btw?

[21:16] *** Foxcool left
[21:16] <jnthn> But yeah, the "multi method AT-POS(Any:U \SELF: int \pos) is rw {" candidate is what does it

[21:16] <jnthn> ShimmerFairy: Yes

[21:17] <jnthn> m: my %h; %h<a>[0] = 42; say %h.perl

[21:17] <camelia> rakudo-moar d8fa56: OUTPUT«{:a([42])}<>␤»

[21:17] <jnthn> It's the reason you can Just Do That

[21:17] <jnthn> While if you've written any NQP you'll have noted you have to say my %h<a> := []; first.

[21:17] <smls> are 'WHENCE' closures a thing at all in Rakudo?

[21:17] *** telex left
[21:17] <jnthn> No

[21:17] <smls> for controlling auto-viv

[21:18] <smls> ok

[21:18] <raiph> m: say :a,1,2

[21:18] <camelia> rakudo-moar d8fa56: OUTPUT«12␤»

[21:18] <raiph> m: say :a,1

[21:18] <camelia> rakudo-moar d8fa56: OUTPUT«Unexpected named parameter 'a' passed␤  in block <unit> at /tmp/aP5WyQQC_i:1␤␤»

[21:18] *** telex joined
[21:18] <jnthn> Every time I've looked at implementing what that thing wants, I've not been able to figure out how one might easily do it without impacting every method dispatch performance wise...

[21:19] <ShimmerFairy> Ah, now I recall what auto-viv was more specifically :)  (basically, implying a hash or list and having P6 understand that implication)

[21:20] <jnthn> And worse, even if I *did* implement it...I still don't see how it covers the array/hash auto-viv case.

[21:21] <lucasb> raiph++: funny case; Maybe that's because &say has multis for 1-arg only and also say(|) for more than one arg

[21:21] <lucasb> And then, the say(|) disregards the named args

[21:23] <ShimmerFairy> m: my $c = \(1,2,(:a),(:b);3,4); say $c.perl

[21:23] <camelia> rakudo-moar d8fa56: OUTPUT«\((1, 2, :a, :b), (3, 4))␤»

[21:23] <raiph> m: say \(:a;).perl

[21:23] <camelia> rakudo-moar d8fa56: OUTPUT«\((), ())␤»

[21:23] <ShimmerFairy> lucasb: ^ hey! a workaround! :)

[21:23] <raiph> m: say \((:a)).perl

[21:23] <camelia> rakudo-moar d8fa56: OUTPUT«\(:a)␤»

[21:23] <raiph> m: say \((:a);).perl

[21:23] <camelia> rakudo-moar d8fa56: OUTPUT«\((:a,), ())␤»

[21:23] <ShimmerFairy> m: only sub f() { say 'ok' }; my $c = \((:a),(:b)); f(|$c)

[21:23] <camelia> rakudo-moar d8fa56: OUTPUT«Too many positionals passed; expected 0 arguments but got 2␤  in sub f at /tmp/4eW0rANFN6:1␤  in block <unit> at /tmp/4eW0rANFN6:1␤␤»

[21:24] <lucasb> ShimmerFairy: yeah, but now they stop being named and become positionals :)

[21:25] <ShimmerFairy> lucasb: so? :P

[21:28] *** rindolf left
[21:29] *** cognominal left
[21:30] <lucasb> Should say(|) become say(*@args) and get rid of the nqp::p6argvmarray usage? Likewise for other similar subs...

[21:31] *** cognominal joined
[21:32] <ShimmerFairy> not sure, some things in the core prefer nqp:: stuff for performance reasons, I presume.

[21:32] <timotimo> yeah, it may let us generate better code

[21:32] <timotimo> say is somewhat hot

[21:33] <ShimmerFairy> In an ideal world, Perl 6 would be written in pure Perl 6 with no issues whatsoever arising :P

[21:33] <timotimo> yup

[21:34] *** Hor|zon joined
[21:35] <ShimmerFairy> At least we've stepped up from the days of having Q:PIR blocks :)  (man, now I feel like I've been here forever)

[21:35] *** xfix left
[21:35] <timotimo> yes

[21:35] <timotimo> i remember seeing a few of those

[21:36] <smls> jnthn: Also, will .[0..10] still call .list internally after your refactor? The fact that it does currently, presents an extra hurdle/complexity for custom positional types.

[21:38] <jnthn> smls: Without digging into the code, I don't know exactly where, or exactly why, it does.

[21:38] <smls> probably because infinite arrays.

[21:39] <smls> so I can't just to a check for  .elems  and then .AT-POS everything below that index.

[21:39] *** Hor|zon left
[21:39] <smls> s/I/it/

[21:40] <jnthn> What's the place the complexity actually shows up?

[21:40] <jnthn> As in, what do you have to do to make it happy?

[21:41] <jnthn> (that you'd rather not have to)

[21:41] <smls> in that one may naievely not bother to implement .list, and then wonder why certain types of indexing ops won't work correctly.

[21:41] <jnthn> Oh, it calls .list on the thing you're indexing into..

[21:41] <smls> yes.

[21:41] <ShimmerFairy> timotimo: one of my first contributions to rakudo involved Q:PIR blocks, actually :P

[21:42] <jnthn> smls: OK, I understand why its bothersome at least. Will have to look more carefully to see if there's a better solution.

[21:42] <timotimo> not sure whether to say "cool" or "my condolences"

[21:43] <timotimo> have you done much in parrot before that, i wonder?

[21:43] *** leont left
[21:45] <ShimmerFairy> timotimo: no, and my first couple contributions I recall being very hand-hold-y by nature of me asking a ton of questions :)

[21:45] <timotimo> ah

[21:45] <timotimo> well, i still need hand-holding too often for my tastes

[21:46] <ShimmerFairy> timotimo: _but_, I came to Perl 6 when Python 3 didn't give me the features I wanted to write an NES emulator, so I happened to be not scared of assembler-like stuff (never really been, but that being my most recent project before coming here probably helped)

[21:46] <timotimo> ah

[21:46] <timotimo> sadly, perl6 isn't fast enough to emulate nes, is it?

[21:48] <ShimmerFairy> timotimo: no, and probably still not. I was a just a young teenager who had a PPC Linux laptop and got burned by every emulator having x86 assembler inlined, and I developed the mistaken idea that C/C++ and such meant platform-dependent, so I was interested in writing an emulator in a scripting language to show that you can write a platform-independent one.

[21:48] <smls> jnthn: If the archaic support for "arrays with holes" didn't exist, .[$range] could probably simply do   $range.map({ last if !self.EXISTS-POS($_); self.AT-POS($_) })

[21:49] <smls> ;)

[21:49] <ShimmerFairy> timotimo: Py3 didn't have the pointers I wanted to implement mirrored memory (which I got around), and didn't have switch statements to implement the opcode-doing part (which made me give up on Py3)

[21:49] *** llfourn joined
[21:51] <ShimmerFairy> timotimo: So I found myself between P5 and P6. I initially went with P5 (since it actually had modules for GUIs and such), but trying to follow a Qt tutorial, I got thrown off by the weird -> notation and such, and within a couple minutes I decided that helping out a modern-ish language was better than learning this established weird old one :P

[21:51] <ShimmerFairy> Among the best decisions I ever made, I think :3

[21:52] <timotimo> i'm glad you decided this way :)

[21:52] <timotimo> your influence on the buf/blob situation brought the discussion forward, i believe

[21:53] <ShimmerFairy> Ah, how I didn't want to treat them as strings because they aren't? :P

[21:53] *** llfourn left
[21:54] <timotimo> i'm somewhat ashamed i don't recall the exact details of the whole discussion

[21:57] <nine> A major difference between text and binary parsing is that with binary formats, you usually exactly know how long its parts are. I.e. you have explicit length fields in your data instead of having to look for some marker.

[21:59] <ShimmerFairy> nine: yeah, I find that text has unknown sizes (and thus variable locations) but known order, while binary file formats (the sensible ones, at least) prefer known sizes and locations with less of an emphasis on order

[22:00] <ShimmerFairy> With order of things usually only mattering for sizes and offsets (or for things like a sequence of commands, though that's not usually done by "parsing" in the sense of collecting data into objects)

[22:01] *** lucasb left
[22:02] <timotimo> hm. with how i old i am now and calculating backwards ... i wasn't even an old teenager any more when i started my involvement with p6 :|

[22:05] <ShimmerFairy> timotimo: I'm weird though, the two things I'm currently (kinda) working on are related to Infocom games, which I played quite a bit of when I was young (though I read the manuals and related materials more) :P

[22:06] * timotimo remembers someone else had been working on ZSCII recently

[22:08] <ShimmerFairy> That 'nqp compiler' thing I mentioned earlier is specifically on the roughly 40 year old MDL the original Zork was written in (and one of said two things). Quite an interesting language to read up on, though how to implement the fundamental portions are what I'm stuck on :)

[22:08] <timotimo> i see

[22:09] <timotimo> i fondly remember back when i was in visual basic land and had pretty much no clue of anything complicated, i tried building my own scripting language for a role playing game (think final fantasy)

[22:09] <timotimo> i got around not knowing how tokenization would work by requiring the programmer to put everything on its own line

[22:09] <ShimmerFairy> every token, I presume?

[22:10] <timotimo> almost

[22:10] <timotimo> i don't remember the exact details any more, but i think i had a few things that'd work (or actually be required to be) on a line they'd share

[22:10] <dalek> rakudo-star-daily: 32ce6c3 | coke++ | log/ (9 files):

[22:10] <dalek> rakudo-star-daily: today (automated commit)

[22:10] <dalek> rakudo-star-daily: review: https://github.com/coke/rakudo-star-daily/commit/32ce6c3d29

[22:10] <dalek> perl6-roast-data: f9fe061 | coke++ | / (9 files):

[22:10] <dalek> perl6-roast-data: today (automated commit)

[22:10] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/f9fe06154b

[22:10] <timotimo> i had pretty much no idea of tree data structures back then, you see

[22:11] <timotimo> so i couldn't properly compile the scripts into something like QAST ... i interpreted them line-by-line each time :)

[22:12] <ShimmerFairy> I started in VB land too, just making random tiny games. I quit when VB.NET came out; I tried writing some old COM-era code, it predictably didn't work, and I just quit using VB :P

[22:13] <smls> timotimo: Some languages (like gnu makefiles) *have* to be interpreted line-by-line.

[22:13] <timotimo> fair enough

[22:13] * smls started as a kid with QBASIC

[22:14] <timotimo> QBASIC was my first, too

[22:14] <timotimo> i'm not sure if my brain is unrecoverably damaged from that

[22:14] <smls> heh ;)

[22:15] <[Coke]> is there a way to increase my irssi buffer so I don't have to use the ir clogs?

[22:16] <ShimmerFairy> I remember preferring VB 3 over VB 6 at least for the fact that you could have a button that was actually just a picture, without otherwise looking like a standard Windows button

[22:16] <timotimo> szabgab put "use lib callframe(0).file.IO.dirname ~ '/lib';" into his post about Bailador

[22:16] <timotimo> shouldn't that work better with $?FILE ?

[22:17] <ShimmerFairy> I started with a VB 6 For Dummies book and a copy of VB 3, later finding version 6 somewhere. How far I've come since then :3

[22:17] <timotimo> i think i had VB 5 from the very beginning

[22:17] *** RabidGravy left
[22:18] <timotimo> er, the beginning of my VB era, of course

[22:20] <timotimo> i wonder what decision in my life moved me towards language implementation development

[22:20] * jnthn did BBC Micro BASIC -> QBASIC -> VB4..6 :)

[22:20] *** diana_olhovik left
[22:21] <ShimmerFairy> My parents had a lot of old floppies (a lot of them copies made from whatever original floppies :P), and we had a computer for a time that could only have DOS 6.22 (IIRC) and Win 3.1 installed, so I had a weird amount of old-era stuff to play with.

[22:21] <jnthn> The found Perl and was like "oh, damn, wow" :)

[22:22] <ShimmerFairy> The computer, it should be noted, did originally run Windows 98 or such, but somehow it got ruined at some point and we only ever could manage alternate installs of DOS and Win 3.1 afterward :P

[22:23] <smls> I started learning Perl because I wanted to write a auto-responding plugin for Gaim messenger (nowadays called Pidgin) to impress my classmates with whom I chatted to discuss homework after school...

[22:23] <smls> and the only options for writing such a plugin were Perl and C

[22:23] <timotimo> someone had to free up some space and made C:\Windows a bit slimmer? :)

[22:23] <smls> so I took the easier route :P

[22:25] <jnthn> I learned it because my parents were like "get a summer job" and I didn't want to stack shelves or deliver newspapers so I decided to build websites...and folks wanted to do ecommerce and stuffs.

[22:25] <ShimmerFairy> timotimo: no clue, but it did give an interesting place to play with (also it's where my dad taught me 'cd' when we were tired of having to reinstall the Lost Treasures of Infocom every time we booted up just to play them, which never seemed right anyway)

[22:26] <timotimo> %)

[22:26] <smls> In retrospect, I could have saved myself much time/sanity trying to understand Perl references and datastructures, if i had started by reading a book or proper tutorial instead of going the trial-and-error autodidactic route :P

[22:26] <ShimmerFairy> timotimo: We also had a black-and-white laptop that ran Win 3.1 that I remember taking apart and cutting several ICs off of :P

[22:27] <timotimo> i wonder what you did that for

[22:28] *** cognominal left
[22:28] *** smls_ joined
[22:29] <ShimmerFairy> I'm sure I took apart the laptop when it was past its time, though for the life of me I cannot tell you what possessed me to 1) want to take off the various ICs, and then 2) figure out how to snap the pins off the board and/or IC

[22:29] *** cognominal joined
[22:29] * jnthn catches up a little on his weekly progress reports: https://6guts.wordpress.com/2015/08/01/368/

[22:30] <jnthn> Time for some rest...'night o/

[22:30] *** smls left
[22:31] <ShimmerFairy> g'night, jnthn++ o/

[22:33] <ShimmerFairy> timotimo: last really notable thing I remember from my childhood programming experiences would be the HTML for Dummies book I read from that talked about how those new-fangled Portable Network Graphics likely wouldn't take off, so you should only really concern yourself with gifs and jpgs :P

[22:33] <ShimmerFairy> (though when I last flipped through that book to find that passage, I couldn't find it back)

[22:34] <timotimo> oh!

[22:34] <smls_> well, if Microsoft had had it's way, that prediction might have come true...

[22:34] <timotimo> i had omething like HTML for dummies, too

[22:34] <timotimo> it taught me how to build html with a text editor rather than frontpage

[22:34] <timotimo> that blew my mind

[22:34] <ShimmerFairy> It was specifically HTML 4 for Dummies, I believe

[22:34] <timotimo> "notepad can DO THAT?!"

[22:35] <Juerd> Notepad didn't do that, you did

[22:35] <ShimmerFairy> timotimo: yes, I recall typing uppercase tags in notepad ("those guys on the web are talking about lowercase, but I want these things to stand out!" [lol what's syntax highlighting?])

[22:35] <ShimmerFairy> timotimo: but messing around in frontpage was also fun :)

[22:35] <timotimo> tee hee

[22:35] <Juerd> Ugh, uppercase html tags.

[22:36] <timotimo> it's the html4 way

[22:36] <Juerd> I still dislike <!DOCTYPE>

[22:36] <Juerd> timotimo: I typed lowercase html even with html 3!

[22:36] <timotimo> wow, you're hard core

[22:36] <Juerd> Although when I moved to a program called Homesite, it would mess that all up and rewrite my tags with the element name in uppercase and the attributes in lowercase.

[22:37] <Juerd> <A href="...">...</A>  <!-- ugly! -->

[22:37] <timotimo> d'oh

[22:37] <Juerd> timotimo: I'm so hard core, that I usually leave out optional tags, like <html>, <head> and <body>.

[22:37] <ShimmerFairy> timotimo: looking back, the "makes it stand out" rationale only makes sense if you don't have a syntax highlighter :)

[22:37] <Juerd> They've always been optional. Still are with html 5.

[22:38] <Juerd> Just like </td> and </tr>. You don't need them.

[22:38] <timotimo> yeah

[22:38] <Juerd> <!DOCTYPE html>

[22:38] <Juerd> <title>Hello</title>

[22:38] <Juerd> O hai!

[22:39] <timotimo> mhm

[22:39] <Juerd> (Although usually I add a <meta charset=UTF-8>)

[22:41] *** perturbation left
[22:42] <cognominal> jnthn++

[22:46] *** spider-mario left
[22:50] *** cognominal left
[22:51] *** BenGoldberg joined
[22:53] *** census joined
[23:07] *** ribasushi joined
[23:35] *** Hor|zon joined
[23:39] *** Hor|zon left
[23:50] *** llfourn joined
[23:55] *** llfourn left
[23:56] *** yqt joined
