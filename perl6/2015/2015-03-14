[00:01] *** Ugator1 left
[00:01] *** rurban left
[00:02] *** donaldh left
[00:09] <dalek> rakudo/nom: d4fc1f9 | jnthn++ | src/core/native_array.pm:

[00:09] <dalek> rakudo/nom: Tweak ASSIGN-POS candidates for native arrays.

[00:09] <dalek> rakudo/nom: 

[00:09] <dalek> rakudo/nom: We lost out due to some interesting sorting issues involving the Any

[00:09] <dalek> rakudo/nom: candidates. With this, we can run things like:

[00:09] <dalek> rakudo/nom: 

[00:09] <dalek> rakudo/nom:   my int @a; my int $i = 0;

[00:09] <dalek> rakudo/nom:   while $i < 1000000 { @a[$i] = 1; $i = $i + 1; }

[00:09] <dalek> rakudo/nom: 

[00:09] <dalek> rakudo/nom: And have everything fully inlined and cause no allocations once into

[00:09] <dalek> rakudo/nom: the loop (meaning no GC runs).

[00:09] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/d4fc1f9c01

[00:09] <jnthn> rest &

[00:09] <tadzik> ooooo

[00:09] <tadzik> jnthn++

[00:09] <japhb> Very nice performance, jnthn++

[00:24] *** coffee` left
[00:28] *** lichtkind_ joined
[00:28] *** beastd left
[00:30] *** lichtkind left
[00:49] *** adu joined
[00:51] *** wicope left
[00:57] *** kjs_ joined
[01:02] *** aborazmeh joined
[01:02] *** aborazmeh left
[01:02] *** aborazmeh joined
[01:03] *** skids joined
[01:05] <grondilu> '$i = $i + 1'?  why not $i++?

[01:05] <grondilu> m: my int $i = 0; say ++$i

[01:05] <camelia> rakudo-moar d4fc1f: OUTPUT«1␤»

[01:10] *** kjs_ left
[01:13] *** aborazmeh left
[01:16] *** zby_home_ left
[01:44] *** madmuid1 left
[02:05] *** raiph joined
[02:14] <skids> m: my $foo is dynamic = 3; grammar foo { regex f { :my $foo is dynamic = CALLER::CALLER::<$foo>; f { $foo++; $foo.say; CALLER::<$foo>.say; CALLER::CALLER::<$foo>.say; CALLER::CALLER::CALLER::<$foo>.say;}}}; foo.parse("f",:rule<f>);

[02:14] <camelia> rakudo-moar d4fc1f: OUTPUT«4␤4␤(Any)␤3␤»

[02:22] *** Mouq joined
[02:25] *** dustinm`_ left
[02:30] *** prime left
[02:36] *** dustinm` joined
[02:38] *** prime joined
[02:51] <b2gills> m: my multi a ( *% () ) { say 'no args' }; my multi a(*%_) { say 'args' }; a(); a(:a)

[02:51] <camelia> rakudo-moar d4fc1f: OUTPUT«no args␤args␤»

[02:51] <b2gills> lizmat: ^^

[03:09] *** raiph left
[03:21] *** noganex joined
[03:21] *** lichtkind_ left
[03:23] *** noganex_ left
[04:21] <skids> m: my $f is dynamic = Array.new; sub f ($g is rw) { CALLER::CALLER::<$f>.WHICH.say; $g.WHICH.say; say CALLER::CALLER::<$f> =:= $g}; sub g { f(CALLER::<$f>) }; g();

[04:21] <camelia> rakudo-moar d4fc1f: OUTPUT«Array|86540368␤Array|86540368␤True␤»

[04:21] <skids> m: my $f is dynamic = Array.new; sub f ($g) { CALLER::CALLER::<$f>.WHICH.say; $g.WHICH.say; say CALLER::CALLER::<$f> =:= $g}; sub g { f(CALLER::<$f>) }; g();

[04:21] <camelia> rakudo-moar d4fc1f: OUTPUT«Array|85625296␤Array|85625296␤False␤»

[04:23] <skids> m: my $f is dynamic = Array.new; sub f ($g) { CALLER::<$f>.WHICH.say; $g.WHICH.say; say CALLER::<$f> =:= $g}; f($f); # I guess the extra layer isn't needed.

[04:23] <camelia> rakudo-moar d4fc1f: OUTPUT«Array|79088896␤Array|79088896␤False␤»

[04:24] <Mouq> skids: FWIW you can just say $CALLER::f, and if there's no definition in between CALLER::…::CALLER you can just you $CALLERS::f

[04:24] <Mouq> m: my $f is dynamic = Array.new; sub f (\g) { CALLER::<$f>.WHICH.say; $g.WHICH.say; say CALLER::<$f> =:= g}; f($f);

[04:24] <camelia> rakudo-moar d4fc1f: OUTPUT«5===SORRY!5=== Error while compiling /tmp/H8Qn8lOmkT␤Variable '$g' is not declared␤at /tmp/H8Qn8lOmkT:1␤------> 3) { CALLER::<$f>.WHICH.say; $g.WHICH.say7⏏5; say CALLER::<$f> =:= g}; f($f);␤    expecting any of:␤        method arguments␤»

[04:24] <Mouq> m: my $f is dynamic = Array.new; sub f (\g) { CALLER::<$f>.WHICH.say; g.WHICH.say; say CALLER::<$f> =:= g}; f($f);

[04:24] <camelia> rakudo-moar d4fc1f: OUTPUT«Array|80771744␤Array|80771744␤True␤»

[04:24] <Mouq> =:= is container identity

[04:26] <Mouq> m: my $f is dynamic = Array.new; sub f ($g) { $CALLER::f.VAR.name.say; $g.VAR.name.say; say $CALLER::f =:= $g}; f($f);

[04:26] <camelia> rakudo-moar d4fc1f: OUTPUT«$f␤$g␤False␤»

[04:26] <Mouq> m: my $f is dynamic = Array.new; sub f (\g) { $CALLER::f.VAR.name.say; g.VAR.name.say; say $CALLER::f =:= g}; f($f);

[04:26] <camelia> rakudo-moar d4fc1f: OUTPUT«$f␤$f␤True␤»

[04:27] <Mouq> m: my $f is dynamic = Array.new; sub f ($g is rw) { $CALLER::f.VAR.name.say; $g.VAR.name.say; say $CALLER::f =:= $g}; f($f);

[04:27] <camelia> rakudo-moar d4fc1f: OUTPUT«$f␤$f␤True␤»

[04:30] <skids> m: my $f is dynamic = Array.new[1,2]; sub f { say $CALLERS::f }; f;

[04:30] <camelia> rakudo-moar d4fc1f: OUTPUT«(Any) (Any)␤»

[04:31] <Mouq> my $f is dynamic = Array.new(1,2); sub f { say $CALLERS::f }; f;

[04:31] <skids> Hrm I only get one (Any) on an older build.

[04:31] <Mouq> m: my $f is dynamic = Array.new(1,2); sub f { say $CALLERS::f }; f;

[04:31] <camelia> rakudo-moar d4fc1f: OUTPUT«1 2␤»

[04:31] <skids> oops.

[04:31] <Mouq> skids: TimToady++ added CALLERS recently

[04:31] <Mouq> So idk if that's the issue

[04:32] <skids> Yes, I was trying to show that it was NYI.  But I guess I should upgrade.

[04:53] * timotimo is happy to see the native array stuff by jnthn++ give great performance improvements already

[05:22] *** madmuid joined
[05:24] *** BenGoldberg joined
[05:49] *** mr-foobar left
[05:55] *** Vlavv_ left
[06:12] *** gtodd left
[06:13] *** gtodd joined
[06:23] *** anaeem1_ joined
[06:24] *** anaeem1_ left
[06:26] *** anaeem1_ joined
[06:29] *** gfldex joined
[06:32] <moritz> \o

[06:46] *** rindolf joined
[06:49] *** avuserow joined
[06:52] <raydiak> o/

[06:53] <avuserow> \o raydiak 

[06:56] <dalek> rakudo-star-daily: 128a568 | coke++ | log/ (9 files):

[06:56] <dalek> rakudo-star-daily: today (automated commit)

[06:56] <dalek> rakudo-star-daily: review: https://github.com/coke/rakudo-star-daily/commit/128a5680fa

[07:02] *** prime- joined
[07:03] *** prime left
[07:04] *** zby_home_ joined
[07:04] *** BenGoldberg left
[07:07] <[Coke]> jnthn++

[07:14] *** smls joined
[07:15] *** gfldex left
[07:16] *** xfix joined
[07:27] *** Akagi201 joined
[07:29] *** wicope joined
[07:36] *** rindolf left
[07:43] *** adu left
[07:44] <[Tux]> jnthn++. I::P5 meets my expectations w.r.t. IO

[07:44] <[Tux]> nine++

[07:48] <[Tux]> http://tux.nl/Files/20150314084716.png / http://tux.nl/Files/20150314084753.png was for jnthn

[07:48] <[Tux]> reify - 430000 callc

[07:50] *** darutoko joined
[07:50] <[Tux]> postcircumfix:<{ }> <= where could I find the use of that in my own code?

[07:50] <[Tux]> AT-KEY?

[07:56] <raydiak> [Tux]: likely

[07:58] *** Rounin joined
[08:00] <[Tux]> \o/ RT#122892 is fixed

[08:00] <synopsebot> Link: https://rt.perl.org/rt3//Public/Bug/Display.html?id=122892

[08:11] *** Vlavv_ joined
[08:14] *** telex left
[08:14] *** telex joined
[08:14] *** kjs_ joined
[08:19] <[Tux]> http://tux.nl/Files/20150314091845.png

[08:24] *** rurban joined
[08:28] *** FROGGS[mobile] joined
[08:29] <FROGGS[mobile]> m: my int8 $foo = 317; say $foo

[08:29] <camelia> rakudo-moar d4fc1f: OUTPUT«61␤»

[08:29] <FROGGS[mobile]> that only works for a short while now, right?

[08:30] <FROGGS[mobile]> since nativeref landed probably 

[08:41] *** diana_olhovik joined
[08:43] <Mouq> m: my int8 $foo = 31700000000; say $foo

[08:43] <camelia> rakudo-moar d4fc1f: OUTPUT«0␤»

[08:44] <TimToady> surely that should only be int8(), and bare int8 should fail

[08:45] *** diana_olhovik left
[08:45] *** Rounin left
[08:45] <TimToady> or at least we oughta have some way of saying "die if this doesn't fit"

[08:46] <TimToady> m: subset int8really of int8 where int8.Range; my int8really $foo = 31700000000; say $foo

[08:46] <camelia> rakudo-moar d4fc1f: OUTPUT«Type check failed in assignment to '$foo'; expected 'int8really' but got 'Int'␤  in block <unit> at /tmp/jwTExdGSRb:1␤␤»

[08:47] <TimToady> that seems less than optimal

[08:47] <Mouq> TimToady: Although I don't think it'll actually be an int8 in that case

[08:47] <TimToady> 'of int8'

[08:48] *** diana_olhovik joined
[08:48] <TimToady> m: say int8.Range

[08:48] <camelia> rakudo-moar d4fc1f: OUTPUT«-128..127␤»

[08:48] <TimToady> it already knows it's range, so it seems kinda silly not to have a way to enforce it

[08:48] <Mouq> Right, but I'm not sure that the Rakudo impl handles that yet… not that I know much about the natives implementation

[08:48] <TimToady> though I understand the C-think going on here

[08:49] <FROGGS[mobile]> TimToady: using a native type is explicit enough for me to allow overflow

[08:49] <Mouq> m: subset int8really of int8 where int8.Range; my int8really $foo = 317; say $foo

[08:49] <camelia> rakudo-moar d4fc1f: OUTPUT«Type check failed in assignment to '$foo'; expected 'int8really' but got 'Int'␤  in block <unit> at /tmp/aFW16uKGx7:1␤␤»

[08:49] <TimToady> well, but then I oughta be able to do the subset

[08:49] <FROGGS[mobile]> also because using a native type is mostly done for performance reasons

[08:50] <TimToady> there should be an easy way to ask for a check

[08:50] <Mouq> m: subset Int8 of Int where int8.Range; my Int8 $foo = 317; say $foo

[08:50] <camelia> rakudo-moar d4fc1f: OUTPUT«Type check failed in assignment to '$foo'; expected 'Int8' but got 'Int'␤  in block <unit> at /tmp/9dyZdDh4NU:1␤␤»

[08:50] <Mouq> Hm

[08:51] <Mouq> Oh, no, that's right :P

[08:51] <Mouq> m: subset Int8 of Int where { say int8.Range }; my Int8 $foo = 15; say $foo

[08:51] <camelia> rakudo-moar d4fc1f: OUTPUT«-128..127␤15␤»

[08:51] * Mouq &

[08:51] <TimToady> error is LTA then

[08:52] <TimToady> m: subset int8really of int8 where int8.Range; my int8really $foo = 15; say $foo

[08:52] <camelia> rakudo-moar d4fc1f: OUTPUT«Type check failed in assignment to '$foo'; expected 'int8really' but got 'Int'␤  in block <unit> at /tmp/GaHDC49EE4:1␤␤»

[08:52] <TimToady> and that should work

[08:54] *** alini left
[08:58] <TimToady> seesighting &

[09:01] <[Tux]> jnthn++; # optimizer working already made me find one (small) optimization possibility

[09:02] <moritz> http://collect.p6c.org/ # capacity management for hack (so far; maybe I'll add www too)

[09:07] *** Akagi201 left
[09:09] *** Akagi201 joined
[09:11] <itz> oh collectd looks nice 

[09:17] <raydiak> g'night #perl6

[09:18] *** Akagi201 left
[09:22] <moritz> itz: that's because I had nothing to do with its design :-)

[09:28] <[Tux]> http://tux.nl/Files/20150314102813.png <= there is no way I can find that first deoptimisation, right?

[09:30] *** zby_home_ left
[09:30] <[Tux]> most "red" seems to come from reify and gimme

[09:30] <moritz> yes, that's to be expected :(

[09:34] <nine_> What is reify anyway?

[09:35] <moritz> it's the routine that turns lazy list elements into actual elements

[09:35] <nine_> Ah, so that's the performance improvement the GLR may bring?

[09:37] * moritz hopes so

[09:38] *** coffee` joined
[09:45] *** rindolf joined
[09:51] <timotimo> we kind of bounce around between reify, gimme and whatever code may be involved, like with a GatherIter or MapIter

[09:52] <timotimo> often we do a whole lot of busywork for every individual item, too

[10:00] <dalek> roast: 3c01d70 | usev6++ | S05-modifier/ii.t:

[10:00] <dalek> roast: Add test for RT #77406

[10:00] <dalek> roast: review: https://github.com/perl6/roast/commit/3c01d7057c

[10:00] <synopsebot> Link: https://rt.perl.org/rt3//Public/Bug/Display.html?id=77406

[10:08] *** spider-mario joined
[10:08] <[Tux]> nine_, http://www.perlmonks.org/?node_id=1120037

[10:13] <dalek> roast: c4a6374 | moritz++ | S05-substitution/subst.t:

[10:13] <dalek> roast: Test non-Str replacement parts for Str.substr

[10:13] <dalek> roast: review: https://github.com/perl6/roast/commit/c4a6374de8

[10:16] <nine_> [Tux]: cool :)

[10:25] <masak> antenoon salutations, #perl6

[10:28] <[Tux]> o/

[10:29] <[Tux]> it is frightening how much enthusiasm you got awakened in me since Slang::Tuxic. Frightening indeed

[10:30] *** Akagi201 joined
[10:32] *** tgt joined
[10:34] *** Ugator joined
[10:34] <Mouq> It's so hard for me not to go off on the PerlMonks trolls (troll?). The ignorance, hypocrisy, disrespect… ugh. (people on PerlMonks who manage to deal couteously with the trolls)++

[10:38] <Mouq> I mean I don't even care personally… its mostly that you people don't deserve it

[10:38] <Mouq> So anyway…

[10:41] <vendethiel> Mouq: thinking about one instance in particular?

[10:43] <Mouq> vendethiel: No, but I'd rather not link any particular instances

[10:44] <Mouq> vendethiel: I kinda feel icky for bringing this negativity into #perl6 in the first place :P transitioning to another topic would be A-OK with me

[10:47] *** kjs_ left
[11:04] <jnthn> mor...afternoon, #perl6 :)

[11:04] *** madmuid left
[11:15] <timotimo> o/

[11:24] *** kjs_ joined
[11:28] *** anaeem1_ left
[11:29] *** anaeem1 joined
[11:31] <lizmat> good top of the afternoon, #perl6!

[11:32] <jnthn> o/ lizmat 

[11:33] *** anaeem1 left
[11:33] <lizmat> just realised we missed the ultimate pie moment: 3.14.15 9:26:53

[11:33] <lizmat> *pi  :-)

[11:35] <jnthn> Mmmm...pie...

[11:45] <lizmat> jnthn: am I correct in seeing that the roles intarray and numarray could actually be generated from a template ?

[11:46] *** diana_olhovik left
[11:48] *** eli-se joined
[11:48] *** eli-se left
[11:49] <jnthn> lizmat: Painfully maybe

[11:50] *** muraiki joined
[11:50] <lizmat> well, keeping the roles in sync feels pretty painful to me too

[11:52] *** cognominal joined
[11:52] <lizmat> m: my int @a = 0

[11:52] <camelia> rakudo-moar d4fc1f: OUTPUT«Type check failed in binding @values; expected 'Positional' but got 'Int'␤  in method STORE at src/gen/m-CORE.setting:11009␤  in block <unit> at /tmp/9Q17ZLsP2A:1␤␤»

[11:52] <lizmat> add another STORE candidate ?

[11:53] <jnthn> um, how on earth...

[11:53] <jnthn> oh duh, it was meant to be *

[11:53] <lizmat> ok, will fix

[11:53] <jnthn> well

[11:53] <lizmat> ?

[11:53] <jnthn> now you mention it, we may as well go for two candidates

[11:53] <lizmat> ok, will do

[11:53] <lizmat> :-)

[11:53] <jnthn> 'cus it avoids a level of wrapping

[11:54] <jnthn> but do ith with delegation.

[11:54] <jnthn> e.g. make it a multi

[11:54] <lizmat> ok, apart from the painfulness of the person doing the templating

[11:54] <lizmat> *for

[11:54] <lizmat> would you be against it ?

[11:54] <jnthn> Yes, for now

[11:54] <lizmat> ok

[11:55] <jnthn> I'm more wondering how we have the compiler do the work.

[11:55] * lizmat is not going to mention the magic word

[11:56] <jnthn> Well, yeah, there is that :)

[11:56] <jnthn> More the parametric role thing this time, though

[11:57] <jnthn> I ahve .gist/.Str/.perl locally for the native arrays

[11:59] <dalek> rakudo/nom: 471718b | jnthn++ | src/core/native_array.pm:

[11:59] <dalek> rakudo/nom: Must only create parameterized native array.

[11:59] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/471718b646

[12:04] <dalek> rakudo/nom: 433fb52 | jnthn++ | src/core/native_array.pm:

[12:04] <dalek> rakudo/nom: Native array .gist/.Str/.perl.

[12:04] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/433fb526e7

[12:05] <dalek> roast: 0fc0ce4 | jnthn++ | S09-typed-arrays/native.t:

[12:05] <dalek> roast: Native array .Str/.gist/.perl/.new tests.

[12:05] <dalek> roast: review: https://github.com/perl6/roast/commit/0fc0ce461d

[12:05] <dalek> rakudo/nom: 8dd4417 | lizmat++ | src/core/native_array.pm:

[12:05] <dalek> rakudo/nom: Add candidates for native_array.STORE

[12:05] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/8dd441770f

[12:06] <jnthn> lizmat: I think the *@values one should just self.STORE(@values)

[12:06] <lizmat> ah, ok

[12:06] <jnthn> lizmat: There's no need to duplicate code.

[12:06] <jnthn> lizmat: And the delegating method may in the future be inlinable anyway.

[12:06] <lizmat> okidoki

[12:07] <jnthn> lizmat++

[12:07] <jnthn> The single value candidate is tiny enough it can stay 

[12:07] *** cognominal left
[12:08] <lizmat> I could even move the delegating one into the class, as they are identical between roles

[12:08] <jnthn> Depending on use-cases we might want to have an array[int] candidate also, in that we can do the copying more cheaply. Guess we can see what kinds of programs people write.

[12:08] <lizmat> would that make sense?

[12:08] <jnthn> Yes

[12:08] <jnthn> Keep stuff that doesn't have any _i/_n into the class

[12:08] <jnthn> *in

[12:09] <jnthn> The roles are for stuff we can't make generic, or at least can't performantly make generic.

[12:11] <lizmat> would array[int] already work ?

[12:12] <jnthn> um

[12:12] <jnthn> No, given we're defining it :)

[12:12] <jnthn> Hm

[12:12] <jnthn> Maybe it's not actually worth it (more)

[12:12] <lizmat> MMD for array[int] 

[12:13] <jnthn> Thinking about what spesh will do in the existing @value case, it'd

[12:13] <jnthn> 1) inline AT_POS

[12:13] <jnthn> 2) notice the box/unbox

[12:13] <jnthn> 3) remove it, giving us the version we would hand-code

[12:14] <lizmat> something else: my int $i = 0;   

[12:14] <jnthn> So I don't think we benefit from the extra candidate.

[12:14] <lizmat> is the  = 0 needed?

[12:14] <jnthn> No

[12:14] <lizmat> but added for clarity ?

[12:14] <jnthn> Yeah.

[12:14] <lizmat> and no runtime penalty ?

[12:15] <jnthn> If yes, tiny. And again, something we can expect to have optimized out.

[12:16] <lizmat> ok

[12:16] <jnthn> I dunno quite how it works with the code Rakudo generates, but I've seen spesh toss dead initializations in NQP code.

[12:17] <jnthn> OK, what else is on the todo methods list... :)

[12:17] <jnthn> m: my int @a = 1..5; say @a.item

[12:17] <camelia> rakudo-moar 8dd441: OUTPUT«1 2 3 4 5␤»

[12:17] <jnthn> goody

[12:17] <jnthn> m: my int @a = 1..5; say @a.keys

[12:17] <camelia> rakudo-moar 8dd441: OUTPUT«Memory allocation failed; could not allocate 57248 bytes␤»

[12:17] <jnthn> yowser

[12:17] <jnthn> m: my int @a = 1..5; say @a.values

[12:17] <camelia> rakudo-moar 8dd441: OUTPUT«1 2 3 4 5␤»

[12:18] *** rindolf left
[12:18] <jnthn> Hm, where do we get that .values from :)

[12:18] <dalek> rakudo/nom: 533b24b | lizmat++ | src/core/native_array.pm:

[12:18] <dalek> rakudo/nom: Factor out STORE(*@values) case to class

[12:18] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/533b24b45d

[12:18] <jnthn> m: my int @a = 1..5; say @a.values.perl

[12:18] <camelia> rakudo-moar 8dd441: OUTPUT«array[int].new(1, 2, 3, 4, 5)␤»

[12:18] <jnthn> Hmm, is .values really meant to return identity?

[12:18] <jnthn> m: my @a = 1..5; say @a.values.perl

[12:18] <camelia> rakudo-moar 8dd441: OUTPUT«(1, 2, 3, 4, 5).list␤»

[12:18] <jnthn> No, it's not. Thought so.

[12:19] <lizmat> my $a = [1..5]; say @a.values.perl

[12:19] <lizmat> m: my $a = [1..5]; say @a.values.perl

[12:19] <camelia> rakudo-moar 8dd441: OUTPUT«5===SORRY!5=== Error while compiling /tmp/RxXkEJD_5U␤Variable '@a' is not declared. Did you mean '$a'?␤at /tmp/RxXkEJD_5U:1␤------> 3my $a = [1..5]; say @a.values.perl7⏏5<EOL>␤    expecting any of:␤        method arguments␤»

[12:19] <jnthn> undecl var :)

[12:19] <lizmat> m: my $a = [1..5]; say $a.values.perl

[12:19] <camelia> rakudo-moar 8dd441: OUTPUT«(1, 2, 3, 4, 5).list␤»

[12:19] <jnthn> method values in List does an explicit clone.

[12:21] <lizmat> and that is good or bad ?

[12:21] <jnthn> Probably fine

[12:22] <jnthn> If you write @foo.values instead of @foo then you probably did it with reason :)

[12:22] <lizmat> ah, yeah, dukh :-)

[12:22] <lizmat> *duh rather

[12:22] <jnthn> What I really do want to make sure of with TimToady is whether operations on native arrays should return native arrays

[12:23] <lizmat> TimToady is seesighting

[12:23] <jnthn> That's fine, I don't have to know it Right Now

[12:23] <jnthn> :)

[12:23] <lizmat> I see that native push/unshift don't have a candidate for @values, but they do for *@values

[12:23] <lizmat> shouldn't that get the same treatment as STORE ?

[12:24] <jnthn> Depends how common it's gonna be I guess

[12:25] *** molaf_ joined
[12:25] <jnthn> Are you going to add a test for the "assign one thing"?

[12:26] <jnthn> (if not, I will)

[12:26] <lizmat> sure, tell me which file ?

[12:26] <jnthn> S09-typed-array/native.t

[12:26] <jnthn> There's plenty of tests already for assigning to native int/num arrays.

[12:26] *** perl6_newbee joined
[12:28] <jnthn> (So it should be easy to find inspriration for adding a new one)

[12:28] *** molaf left
[12:29] <jnthn> lizmat: Thanks to inlining I think we can also shrink the roles a bit further

[12:29] <jnthn> multi method push(array:D: *@values) { # for example this could self.push($_) for @values

[12:30] <lizmat> yeah, my point

[12:30] <jnthn> And the inner .push will get inlined

[12:30] * jnthn is still getting used to writing code with a dynamic optimizer acting on it, despite having implemented much of said dynamic optimizer :)

[12:30] <lizmat> yeah, for me it was a big change too

[12:30] <dalek> perl6-examples: 794708a | paultcochrane++ | Makefile:

[12:30] <dalek> perl6-examples: Add a run-all target to the Makefile

[12:30] <dalek> perl6-examples: review: https://github.com/perl6/perl6-examples/commit/794708a536

[12:30] <dalek> perl6-examples: 8176c76 | paultcochrane++ | Makefile:

[12:30] <dalek> perl6-examples: Give the "test" target a better description

[12:30] <dalek> perl6-examples: review: https://github.com/perl6/perl6-examples/commit/8176c76f79

[12:31] <jnthn> And JVM of course knows how to inline things :)

[12:33] <lizmat> something feels wrong with this sig: method splice($offset = 0, $size?, *@values) {

[12:33] <jnthn> Oh?

[12:33] <jnthn> I didn't come up with it :)

[12:34] <jnthn> It's lifted directly from the List.splice sig

[12:34] <jnthn> What's wrong with it, ooc?

[12:34] <jnthn> It seems reasonable to me

[12:34] <lizmat> so how does it know that the first value after the offset, is not intended to be part of the slurpy ?

[12:35] <dalek> perl6-examples: 6ed0a83 | paultcochrane++ | README.md:

[12:35] <dalek> perl6-examples: Mention run-all target in README

[12:35] <dalek> perl6-examples: review: https://github.com/perl6/perl6-examples/commit/6ed0a83305

[12:35] *** zakharyas joined
[12:35] <jnthn> You have to specify a $size if you're going to specify elements to splice in too

[12:36] <lizmat> my @a = ^10; @a.splice(3,4,5,6); say @a

[12:36] <lizmat> m: my @a = ^10; @a.splice(3,4,5,6); say @a

[12:36] <camelia> rakudo-moar 8dd441: OUTPUT«0 1 2 5 6 7 8 9␤»

[12:37] <lizmat> m: my @a = ^10; @a.splice(3,*,4,5,6); say @a

[12:37] <camelia> rakudo-moar 8dd441: OUTPUT«Cannot call 'Real'; none of these signatures match:␤:(Mu:U \v: *%_)␤  in sub infix:<<> at src/gen/m-CORE.setting:5326␤  in method splice at src/gen/m-CORE.setting:10204␤  in block <unit> at /tmp/UBlzkPzFDG:1␤␤»

[12:37] <jnthn> Looks right to me. I might write it @a.splice(3, 4, (5, 6)) in that case for clarity

[12:37] <lizmat> hmmm....

[12:37] <jnthn> But more often you'd be doing @a.splice(3, 4, @replacements) or so, I think

[12:38] <lizmat> I guess

[12:41] *** FROGGS joined
[12:41] <jnthn> nqp: sub foo($a, $b) { say($a); say($b); }; my @a := nqp::list_i(1, 2); foo(|@a)

[12:41] *** camelia left
[12:41] <jnthn> ??

[12:42] <lizmat> you butterfly killer, you!  :-)

[12:43] *** camelia joined
[12:43] <jnthn> .oO( schmettodling )

[12:43] * jnthn tired it locally :)

[12:44] <jnthn> Turns out it works, and it works on JVM too, meaning implemetning native array flattening will be easy :)

[12:44] *** ChanServ sets mode: +v camelia

[12:44] <FROGGS> o/

[12:44] <jnthn> o/ FROGGS 

[12:46] <lizmat> jnthn: this candidate: multi method ASSIGN-POS(array:D: Any:D $idx, Mu \value) {

[12:46] <lizmat> wouldn't it make more sense to Int() $idx ?

[12:46] <lizmat> aka coerce in the sig ?

[12:49] <dalek> rakudo/nom: 889ce3f | jnthn++ | src/core/native_array.pm:

[12:49] <dalek> rakudo/nom: Support flattening native arrays into calls.

[12:49] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/889ce3f9b8

[12:49] <jnthn> lizmat: I don't know the definedness checks work out correctly there

[12:50] <jnthn> lizmat: I fear we'd not hit the Any:U candidate.

[12:50] <dalek> roast: 9766555 | jnthn++ | S09-typed-arrays/native.t:

[12:50] <dalek> roast: Test flattening native arrays into calls.

[12:50] <dalek> roast: review: https://github.com/perl6/roast/commit/9766555aed

[12:50] <lizmat> well, that feels correct in this context to me

[12:50] <lizmat> but ok

[12:51] <jnthn> Well, I was following the ASSIGN-POS semantics in Any.

[12:51] <dalek> rakudo/nom: 214f5a7 | lizmat++ | src/core/native_array.pm:

[12:51] <dalek> rakudo/nom: Factor out array.push/unshift into class

[12:51] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/214f5a7adb

[12:53] <jnthn> lizmat: If you're looking for another one to take on, DELETE-POS is NYI and NYT for native arrays

[12:54] <jnthn> Should be able to go in the class also

[12:54] <lizmat> DELETE-POS meaning setting to 0 ?

[12:54] <jnthn> And use nqp::deletepos(self, pos) or so

[12:54] <lizmat> ok

[12:54] <jnthn> Uh

[12:54] <lizmat> I assume native arrays are consecutive ?

[12:55] <jnthn> m: my @a = 1..10; @a[3]:delete; say @a;

[12:55] <camelia> rakudo-moar 533b24: OUTPUT«1 2 3 (Any) 5 6 7 8 9 10␤»

[12:55] <jnthn> Oh, it does that...

[12:55] <jnthn> But you have no undefined things

[12:55] <jnthn> (in natives)

[12:55] <lizmat> m: my @a = 1..10; @a[3]:delete; say @a[3]:exists;

[12:55] <camelia> rakudo-moar 533b24: OUTPUT«False␤»

[12:55] <jnthn> Maybe DELETE-POS on a native array is just a "no you can't" exception

[12:55] <lizmat> m: my @a = 1..10; @a[3]:delete; say @a[*]:exists;

[12:55] <camelia> rakudo-moar 533b24: OUTPUT«True True True False True True True True True True␤»

[12:55] <lizmat> yeah, like binding

[12:56] <jnthn> aye

[12:56] <lizmat> I can do that  :-)

[12:56] <jnthn> Yeah, I think it'll have to be that.

[12:56] <jnthn> I often forget :delete doesn't actually do a splice-y thing

[12:57] <jnthn> (Not disagreeing with the current behavior)

[12:57] <lizmat> perhaps we would need a :splce adverb

[12:57] <lizmat> :splice

[12:57] *** kaare_ left
[12:57] <jnthn> Could maybe be cute :)

[12:57] <lizmat> would be same as :delete on hashes

[12:57] <jnthn> @a[2..4]:splice = @things; # actually much easier to understand

[12:58] <jnthn> Though on hashes :splice would be a no-op or not allowed

[12:58] <jnthn> Well, not sure we should go and stick it in right now, but worth considering.

[12:58] <lizmat> :splice on hashes would need a list of pairs ?

[12:58] <jnthn> I dunno :)

[12:59] <jnthn> I don't know what on earth it'd do :)

[13:00] *** zakharyas left
[13:00] <jnthn> lizmat: Dunno if you know the answer to this, but 

[13:00] <jnthn>     multi method keys(List:D:) {

[13:00] <jnthn>         self.values.map: { (state $)++ }

[13:00] <jnthn>     }

[13:00] *** Sir_Ragnarok left
[13:00] <jnthn> Is there any reasons that isn't just (^self.elems).list

[13:00] <jnthn> ?

[13:00] <smls> how could a :splice adverb allow inserting elements without removing any?

[13:01] <lizmat> jnthn: ^self.elems on an infinite list ?

[13:01] *** anaeem1_ joined
[13:01] <jnthn> Ah

[13:01] *** FROGGS[mobile] left
[13:01] <jnthn> Yeah, that's the one.

[13:01] <jnthn> lizmat++

[13:01] *** anaeem1_ left
[13:01] <FROGGS> m: say (^Inf).list

[13:01] <camelia> rakudo-moar 533b24: OUTPUT«0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88…»

[13:02] <FROGGS> works

[13:02] <jnthn> FROGGS: yeah but .elems doesn't return Inf, it hangs :)

[13:02] <FROGGS> :/

[13:02] *** FROGGS[mobile] joined
[13:02] *** anaeem1 joined
[13:02] <jnthn> At least, on infinite-but-not-known-infinite it must.

[13:02] <jnthn> Anyway, I *can* take the shortcut on native arrays :)

[13:02] <jnthn> Because they ain't lazy.

[13:02] <lizmat> yeah

[13:02] *** FROGGS[mobile] left
[13:03] <smls> splice($pos, 0, @insertion)  # can adress offset with zero length; [] subscript can't do that

[13:03] <lizmat> also (^self.elems).list wouldn't be lazy

[13:03] <lizmat> not sure that's good or bad, but there you go

[13:03] <jnthn> lizmat: a Range is lazy, no?

[13:04] <lizmat> but .list ing it isn't ?

[13:04] <jnthn> smls: Yes, another reason it's not as cute as it may first seem...

[13:04] <jnthn> lizmat: .list just implies "put it in a List"

[13:04] <jnthn> m: (^Inf).list and say 'alive'

[13:04] <camelia> rakudo-moar 533b24: OUTPUT«alive␤»

[13:04] <lizmat> well, Range.list is defined as: method list()     { self.flat }

[13:04] *** Sir_Ragnarok joined
[13:04] <jnthn> hmm

[13:04] <lizmat> and Range.flat is defined as: method flat()     { nqp::p6list(nqp::list(self), List, Bool::True) }

[13:05] <jnthn> method flat()     { nqp::p6list(nqp::list(self), List, Bool::True) }

[13:05] <jnthn> Right :)

[13:05] <jnthn> Which does not actually evaluate

[13:05] <jnthn> Just flags that the range iteration will only ever produce readily-flattened values, iirc

[13:06] <dalek> rakudo/nom: 9b295bc | lizmat++ | src/core/native_array.pm:

[13:06] <dalek> rakudo/nom: Implement DELETE-POS, also hide BIND-POS

[13:06] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/9b295bced8

[13:06] *** anaeem1 left
[13:07] <smls> jnthn, lizmat: Also, couldn't normal array slices support splice behavior (instead of adding a new adverb)?

[13:07] <FROGGS> jnthn: so native arrays always have a known size?

[13:07] <FROGGS> (in contrast to CArrays)

[13:08] <jnthn> FROGGS: They always know their size, yes. They can grow.

[13:08] <smls> m: my @a = ^10; @a[3..4] = 10..15; say @a

[13:08] <camelia> rakudo-moar 533b24: OUTPUT«0 1 2 10 11 5 6 7 8 9␤»

[13:08] <FROGGS> jnthn: that means we often also cannot return native arrays from C functions

[13:08] <smls> ^^ could this be made to allow resizing the array?

[13:08] <FROGGS> like we cannot return buffers

[13:09] *** anaeem1 joined
[13:09] <jnthn> smls: Not by default, I don't think :)

[13:09] <lizmat> m: my int @a = ^10; say [+] @a   # twice as fast as Int @a  :-)

[13:09] <camelia> rakudo-moar 533b24: OUTPUT«45␤»

[13:09] <jnthn> FROGGS: No, they make no sense as return values

[13:09] <jnthn> FROGGS: That's why, in part, the CArray REPR exists.

[13:09] <FROGGS> jnthn: it might be more than helpful to at least allow to cast a pointer to a native array or buffer by providing the number of elements

[13:10] <smls> jnthn: Because it returns list of Scalars that don't know that they're part of an array?

[13:10] <lizmat> smls: I'm afraid it's too late for that change

[13:10] <jnthn> smls: Yes

[13:10] <jnthn> smls: Also because we probably rely on the current semantics in a lot of places

[13:10] <smls> ok, carry on then :P

[13:10] <jnthn> smls: You'd break stuff like @a[$x..$y] = 1 xx *

[13:10] *** Rounin joined
[13:11] <jnthn> FROGGS: Yes, we need a better story there. There are also issues of memory ownership.

[13:11] *** diana_olhovik_ joined
[13:12] <jnthn> FROGGS: And we shouldn't saddle our normal memory-managed REPRs with "do I even own my data"

[13:13] <lizmat> afk for a few hours&

[13:13] <jnthn> FROGGS: When you say "cast" do you mean "an efficient way to take the CArray and copy the data into a Buf"?

[13:14] <jnthn> FROGGS: Or more "take ownership of the memory"?

[13:14] <arnsholt> The latter sounds really dangerous

[13:14] <jnthn> Yeah, my thought too ;)

[13:15] <FROGGS> jnthn: depends... in most cases I mean copy I think

[13:15] <jnthn> FROGGS: OK. I think we could really do with an efficient bulk-copy op at some point that can let us handle these things in a more efficeint way.

[13:15] <FROGGS> a pointer to pointer cast does not copy for example

[13:16] <FROGGS> jnthn: something related: can I declare a (native) array if a given size? and what be the syntax to do so?

[13:16] <FROGGS> ahh nvm

[13:16] <FROGGS> std: my @a[32]

[13:16] <camelia> std 28329a7: OUTPUT«ok 00:00 137m␤»

[13:16] <jnthn> my @a[42];

[13:16] <jnthn> And no, you can't do ityet

[13:16] <jnthn> Sized/shaped things are further down my todo list

[13:17] <FROGGS> and they will be awesome to use :o)

[13:17] <jnthn> Once native arrays are getting to the point where what remains is polish and optimization, I'm planning to dig into NFG.

[13:17] <FROGGS> btw, I'd like to help out for our great TLAs... but I dunno what I could do

[13:17] <FROGGS> I guess I can hook into NFG at some point

[13:18] <FROGGS> or other minor things about NSA

[13:18] *** eli-se joined
[13:18] <jnthn> Yeah.

[13:18] <eli-se> hi

[13:18] <jnthn> o/ eli-se 

[13:18] <FROGGS> jnthn: so please, if you find anything please let me know :o)

[13:19] <FROGGS> lunch &

[13:19] <jnthn> FROGGS: Will do. :)

[13:19] <arnsholt> jnthn: OOC, how much of the NFG work is nailing down the design?

[13:20] <jnthn> arnsholt: Not too much, in so far as I think I've figured out the overall data structure stuff here.

[13:21] <arnsholt> Spiffy!

[13:22] <jnthn> Figuring out exactly how to get some of the required stuff in the UCD extracted and into a shape we can use is a bit tedious. :)

[13:23] <arnsholt> Yeah, I guess that's one of those things that's tedious (and probably a lot of work), but not necessarily very hard

[13:23] *** skids left
[13:26] *** BenGoldberg joined
[13:31] *** diana_olhovik_ left
[13:31] *** anaeem1 left
[13:34] *** diana_olhovik_ joined
[13:36] <jnthn> bbiab

[13:39] *** anaeem1 joined
[13:44] *** diana_olhovik_ left
[13:50] *** diana_olhovik_ joined
[13:52] *** anaeem1 left
[13:52] *** anaeem1 joined
[13:55] *** diana_olhovik_ left
[13:56] <moritz> Mouq: it takes time to learn how to deal with the trolls (on perlmonks, and in general). I don't think I've perfected it, but I've become better

[13:56] *** anaeem1 left
[13:57] <moritz> Mouq: one possible trick is decide in advance how many replies you'll write at most to trolls (for me typically 2), and don't go beyond

[13:58] <moritz> Mouq: the bystanders aren't dumb; the'll pick up who is trolling and who is using facts

[14:00] *** skids joined
[14:01] *** lichtkind joined
[14:01] *** raiph joined
[14:03] *** eli-se left
[14:06] *** diana_olhovik_ joined
[14:07] <timotimo> I'm considering adding a section to the weekly to post interesting things evaluated with camellia 

[14:08] <timotimo> and do that on a different day 

[14:08] <vendethiel> timotimo: that'd be very interesting :P

[14:08] <vendethiel> "the smallish calendar"

[14:09] *** kjs_ left
[14:09] <moritz> this week's butterfly

[14:12] <timotimo> I like your suggestion, moritz! 

[14:12] <timotimo> bbl

[14:17] *** adu joined
[14:18] <skids> Is there a "match only if you have progressed the cursor since the last time you ran across this element" rx metasyntax?

[14:21] <moritz> skids: I don't think so

[14:22] *** eli-se joined
[14:24] *** zakharyas joined
[14:24] <moritz> m: my int @a = 1..5; say @a.pick(3)

[14:25] <camelia> rakudo-moar 9b295b: OUTPUT«Memory allocation failed; could not allocate 656 bytes␤»

[14:25] * FROGGS still wonders why perl6-j -e 'say nqp::p6store(my $foo, (42 for ^2))' passes a type object to p6store on the rhs

[14:27] *** eli-se left
[14:34] <moritz> I wonder if methods such as pick, roll etc. could be put into role Positional, and thus not duplicated among List and array

[14:39] * moritz tries

[14:40] <moritz> m: say 42.rand.floar.^name

[14:40] <camelia> rakudo-moar 9b295b: OUTPUT«No such method 'floar' for invocant of type 'Num'␤  in block <unit> at /tmp/0POkqOZ0vj:1␤␤»

[14:40] <moritz> m: say 42.rand.floor.^name

[14:40] <camelia> rakudo-moar 9b295b: OUTPUT«Int␤»

[14:52] <moritz> it's not so easy :(

[14:53] <jnthn> moritz: Also it's not clear that the return types should be the same

[14:53] <moritz> I get ambiguous dispatch for Range.roll

[14:53] * moritz is confused about how multis and roles should interact

[14:54] <jnthn> The candidates are flatteningly composed into the class

[14:54] <moritz> jnthn: even if both the role and the class contain a proto method?

[14:55] <moritz> m: role R { proto method x(|c) {*}; multi method x() { 'R' } }; class C does R { proto method x(|) { * }; multi method x() { 'C' } }; say C.new.x

[14:55] <camelia> rakudo-moar 9b295b: OUTPUT«Ambiguous call to 'x'; these signatures all match:␤:(C $: *%_)␤:(C $: *%_)␤  in block <unit> at /tmp/9gWimGJNDo:1␤␤»

[14:55] <moritz> I'd expected that to print C

[14:56] <moritz> jnthn: well, roll is a lazy method, so I'd have to return List anyway

[14:57] <pmichaud> good morning, #perl6

[14:57] <masak> moritz: I'd expect that to print C, too. classes should get to override roles' methods.

[14:57] <masak> pmichaud! \o/

[14:58] <moritz> masak: wanna rakudobugit?

[14:58] <pmichaud> I am _finally_ free again!   Well, mostly.  :)

[14:59] * masak rakudobugsit

[14:59] <pmichaud> My (second) robotics team just advanced to their world championship.  :)

[14:59] <moritz> pmichaud: doesn't sound like too much free time to me :-)

[14:59] <moritz> pmichaud: and congratulations!

[14:59] <masak> yeah! congrats!

[14:59] <pmichaud> actually, it is.  Since we don't have to worry about advancing from the world championship, we can just polish what we already have and enjoy the event.

[15:00] <vendethiel> congrats ;-)

[15:00] <masak> I look forward to looking up from the ground at the ruins of civilization, after the robots destroyed it, raising my fist, and shouting "damn you pmichaud and your second robotics team!" :P

[15:01] <pmichaud> masak: several of the team members have world domination as their goal.

[15:01] <masak> I like them already

[15:02] <moritz> masak: my thoughts went more like "I, for one, welcome our new pmichaud-seecond-robotic overlords" :-)

[15:02] <vendethiel> *g*

[15:02] <jnthn> moritz: First off, you probably don't want the proto in both the role and the class (only the class). Second, the invocant of a role is ::?CLASS, meaning it's generic, and so by the time it gets composed into the class it's been instantiated.

[15:02] <vendethiel> .oO( the second-overlord syndrom )

[15:02] <masak> jnthn: so... no bug?

[15:02] <moritz> jnthn: I don't understand

[15:02] <jnthn> So the ambiguous dispatch is correct there.

[15:02] <masak> jnthn: could you demonstrate how to make the dispatch not ambiguous?

[15:02] <jnthn> moritz: Method in roles are *as if you wrote them in the class*.

[15:03] <moritz> jnthn: I thought if I had a proto in both, the class proto would overwrite the role proto

[15:03] <moritz> jnthn: much like the mechanism for selecting one of several conflicting methods supplied by roles

[15:04] <jnthn> moritz: Thing is that multi candidates are composed independently of protos

[15:04] <jnthn> masak: You could do it by multi foo(RoleType: ...) { }

[15:04] <jnthn> masak: Thus opting out of the genericity

[15:05] *** rindolf joined
[15:05] <masak> jnthn: that's from the perspectively of the role, though?

[15:06] <jnthn> masak: Yes

[15:07] <jnthn> Possibly the presence of a controlling proto in a role should, if there is a conflicting proto in the target class, exclude all of the multi candidates with the same short name in the role.

[15:07] <jnthn> Then what moritz originally wrote woulda worked.

[15:07] <jnthn> It may have other downsides.

[15:08] <masak> ok, I see nothing to rakudobug here.

[15:08] * masak moves along

[15:09] <moritz> I'd argue that composing role candidates independently of protos is at least questionable

[15:09] <jnthn> It's largely a consequence of multi candidate lists getting figured out entirely at composition time

[15:10] <moritz> well, my point is that the presence of a proto should make the whole collection of proto + multis be treated like a single, normal method

[15:10] <moritz> that's how we handle it for subs/lexicals

[15:11] <moritz> that is, a proto in an inner scope completely hides all candidates from an outer scope

[15:13] <moritz> OTOH I'm probably not qualified to judge the impact on the rest of the roles design

[15:13] *** [particle] joined
[15:14] <masak> m: my @a; @a or= 1, 2, 3, 4; say @a

[15:14] <camelia> rakudo-moar 9b295b: OUTPUT«1 2 3 4␤»

[15:14] <masak> \o/

[15:14] <jnthn> m: my int @a; @a or= 1, 2, 3, 4; say @a # curious :)

[15:14] <camelia> rakudo-moar 9b295b: OUTPUT«1 2 3 4␤»

[15:14] <jnthn> phew :)

[15:16] <jnthn> Hm, we get to close RT#107122 :)

[15:16] <synopsebot> Link: https://rt.perl.org/rt3//Public/Bug/Display.html?id=107122

[15:16] *** [particle]1 left
[15:25] * jnthn away for a bit

[15:25] *** anaeem1_ joined
[15:27] <moritz> ok, my attempts to move roll (at least partially) into Positional failed

[15:29] <TimToady> circularity?

[15:29] <jnthn> moritz: I'm pretty certain Positional is too general to put .roll into anyay

[15:30] <jnthn> I thought Callable/Associative/Positional were just meant to be about the sigil.

[15:30] <jnthn> I can see us wanting some role to factor some common list-y things into though

[15:31] <moritz> jnthn: I don't see why pick, roll, permutate etc. would need anything except .elems and .[] / AT-POS

[15:31] <jnthn> But again, I think we need to make some choices about return types of operations on typed things.

[15:31] <moritz> and in my humble mental model, those are exactly the operations that Positional implies

[15:31] * TimToady smells the delightful smell of competing principles here

[15:32] <jnthn> moritz: Ah, I'd had elems as being more associated with Iterable.

[15:33] <jnthn> Anyway, with the GLR ahead and the basics of native arrays landed, it's a good time to try and get these sorts of things straightened out.

[15:33] * pmichaud wonders about the relationship (if any) between Positional and Iterable

[15:34] *** Woodi joined
[15:34] <jnthn> There's all sorts of questions like what does @native-int-array.map(...) return

[15:34] <pmichaud> I'm not sure that Positional should imply .elems, though.

[15:34] <smls> List?

[15:35] <smls> (re .map)

[15:35] <jnthn> smls: So how do I ever get another native int array?

[15:35] <smls> good question

[15:35] <moritz> pmichaud: I guess Positional should imply Iterable, but not the other way round (hashes are iterable but not positional)

[15:35] <pmichaud> I mean, Positional obviously implies .[] and AT-POS, but I don't know that it should be extended to .elems

[15:36] <smls> jnthn: Maybe you'll have to modify it in-place?

[15:36] <pmichaud> and that means that .roll/.pick/.etc   really belong in the Listy things

[15:36] <jnthn> smls: That ain't what .map does though

[15:36] <smls> @native-array.map({ $_++ })

[15:36] <colomon> pmichaud: +

[15:36] <colomon> pmichaud: +1

[15:36] <jnthn> More likely is that

[15:36] <moritz> so, do we need another role?

[15:36] <TimToady> m: $_ = "abc"; say m/(.)(.)(.)/ ~~ Positional

[15:36] <camelia> rakudo-moar 9b295b: OUTPUT«False␤»

[15:36] <jnthn> @native-int-array.map(-> int $i --> int { $i + 1 })

[15:36] <colomon> pmichaud: …. errr, actually, is even Listy right for that?

[15:37] <TimToady> m: $_ = "abc"; say m/(.)(.)(.)/.roll

[15:37] <camelia> rakudo-moar 9b295b: OUTPUT«｢b｣␤»

[15:37] <jnthn> Should return another array[int]

[15:37] <pmichaud> colomon: what else would it be?   (I'm coming into this discussion late... I'm not sure of the motivation for moving .pick/.roll in the first place.)

[15:37] <smls> why Listy if Iterable already exists?

[15:37] <pmichaud> please tell me there's not already a Listy role.  I'm not proposing one.

[15:38] <colomon> pmichaud: Yeah, what smls said: there’s a sort of collision in my head between the notion of Listy and Iterable

[15:38] <jnthn> pmichaud: Mostly that yesterday I landed the first bits of native arrays, and the discussion is where code shared between them and List should be placed.

[15:38] <moritz> m: say Hash ~~ Iterable

[15:38] <camelia> rakudo-moar 9b295b: OUTPUT«True␤»

[15:38] <moritz> m: say Hash ~~ Positional

[15:38] <camelia> rakudo-moar 9b295b: OUTPUT«False␤»

[15:39] <moritz> as it currently is, Iterable is possibly used for associative stuff too

[15:39] <TimToady> m: say Match ~~ Positional

[15:39] <camelia> rakudo-moar 9b295b: OUTPUT«False␤»

[15:39] <TimToady> m: say Match ~~ Associative

[15:39] <camelia> rakudo-moar 9b295b: OUTPUT«False␤»

[15:39] <moritz> TimToady: that should probably both the True, no?

[15:39] <TimToady> ya'd think

[15:39] <pmichaud> ISTR there was a reason we ended up having Match be neither Positional nor Associative

[15:40] <jnthn> Me too, but I can't remember what on earth it was...

[15:40] <pmichaud> I don't R what that reason was, atm.  I'm still trip-lagged from yesterday's championship.

[15:40] <moritz> m: say Match ~~ Iterable

[15:40] <camelia> rakudo-moar 9b295b: OUTPUT«False␤»

[15:40] <pmichaud> I suspect it had to do with the problems of incorrectly binding Match objects into arguments.

[15:40] <moritz> ah, probably

[15:41] <moritz> sub f(@x) {}; f($/);

[15:41] <pmichaud> my sub xyz(%h) { ... };      xyz($match)    // or something like that

[15:41] <pmichaud> when/if we make that decision concrete, we should record the justification somewhere.  :)

[15:42] <TimToady> that's sort of a coercable distinction, Associative vs Associative()

[15:42] <pmichaud> I bet it's in the ir clogs somewhere.

[15:42] <pmichaud> and yes, it may be different now that we have coercers

[15:42] <TimToady> this whole Match object thing is just a pain in the patoot

[15:42] * pmichaud wonders if things that coerce to Bool can be called "socoercers"

[15:43] * TimToady is so glad we didn't go with Highlander Variables generally

[15:43] <timotimo> yay pm

[15:43] <TimToady> pmichaud: er, ow?

[15:44] <pmichaud> jnthn: with respect to   @native-int.map(...) :  It seems to me your more generic question is "how does one construct a native-int array?"

[15:44] <smls> jnthn: Is it not feasible to have the optimizer cut out the boxing/unboxing steps in:   my int @new-native-array = @native-array.map({ $_ * 2 });

[15:44] <pmichaud> I wouldn't expect @anything.map()   to return anything but some form of List.

[15:44] <pmichaud> because there's nothing about .map that implies that the types of the returned objects match the type of the invocant

[15:44] <moritz> pmichaud: same here, mostly because map is lazy, and array[int] isn't

[15:44] <timotimo> m: bag "sorcerer".comb (-) bag "socoercer".comb

[15:44] <camelia> rakudo-moar 9b295b: ( no output )

[15:45] <timotimo> damn phone keyboards 

[15:45] <TimToady> that's one of the reasons we have hypers that *do* guarantee sameness

[15:45] <timotimo> if have to type that all over again 

[15:45] <moritz> fwiw the question of how to determine the return value comes up in other places too

[15:45] <moritz> specifically what kind of Blob an IO operation (or pack) returns

[15:46] <jnthn> pmichaud: Well, my point was that if you want to get something typed back then the lambda you give to map should indicate type.

[15:46] <timotimo> remember hash classify and the other one? 

[15:46] <moritz> how can I tell it to return a buf16 instead of a buf8, for exmaple

[15:46] <smls> jnthn: After all, in Perl 5 lists are *always* transient (more of a syntax constuct than a type).

[15:46] <smls> In Perl 6 they were made to a proper type for extra flexibility/power, but couldn't the simple cases be handled similarly by the compiler?

[15:46] <pmichaud> jnthn: I wonder if .map wants to have some sort of a :return-type option.

[15:47] <pmichaud> because the lambda given to map really indicates type of the elements, not type of the list

[15:47] <jnthn> smls: I don't like designs that are inherently slow unless you have a magical optimizer that can do something clever.

[15:47] <TimToady> well, we need a typesafe mapper to implement hyper, so exposing that could be a map variant

[15:48] <TimToady> Mouq++ just did some work there, I believe

[15:48] <pmichaud> although I suppose that a lambda returning 'int'  could be assumed to mean  native-int

[15:48] <jnthn> pmichaud: Well, I was suggesting the return type of the lambda could distinguish that.

[15:48] <jnthn> Right.

[15:48] <jnthn> Because List implies boxing, and I'm not sure I see that changing.

[15:48] <pmichaud> Oh, I think List could be fixed to not imply boxing.

[15:48] <TimToady> and if we can figure out how to coerce a list of int back to whatever, we can get there

[15:49] <TimToady> note lowercase 'list'

[15:49] <pmichaud> Seems to me that the ability to have native arrays might affect List   (as part of GLR)

[15:49] <jnthn> pmichaud: Well, in previous discussions with TimToady the conclusion I'd drawn was that native array = non-lazy

[15:49] <TimToady> the question, as with the rest of GLR, is when that can be negotiated

[15:50] <smls> jnthn: Isn't that true about much of Perl 6 design though? "Torturing the implementors" and all that.

[15:50] <TimToady> some can obviously be negotiated at compile time

[15:50] <TimToady> but even with ordinary objects, we have to allow that some things have to be negotiated on first call

[15:50] <pmichaud> jnthn: yes, but we're already looking at wanting to refactor List to better handle non-laziness;  since it's subsuming Parcel

[15:50] <vendethiel> "highlander variables"?

[15:50] <pmichaud> I wonder if native-array's analogue is more Parcel-like

[15:50] <vendethiel> the ones that "auto-coerce"?

[15:51] <jnthn> pmichaud: The deeper thing going on here is that the REPR of array is *not* P6opaque

[15:51] <TimToady> vendethiel: RFC 9

[15:51] <pmichaud> jnthn: this discussion convinces me that List-as-currently-implemented is too heavyweight

[15:52] <vendethiel> TimToady: thanks :)

[15:52] <smls> .oO( List vs list )

[15:52] <TimToady> pmichaud: oh, you weren't convinced of that yet? :P

[15:52] <pmichaud> I'm more convinced now.

[15:52] <pmichaud> as in, I have an important key that will help with the Parcel severance

[15:52] <jnthn> pmichaud: Perhaps so, but to be clearer: you can't put any object attributes on array, otherwise we can't represent it directly with the VM array REPR.

[15:53] <pmichaud> jnthn: understood.

[15:53] <TimToady> I think we at minimum need a way to negotiate a pipeline on first call, and that can optionally optimize itself at compile time when we know enough

[15:53] <jnthn> pmichaud: And then we lose most of the nice performance properties we stand to get.

[15:53] <jnthn> pmichaud: Which is why array doesn't inherit from List, which is why we ended up with the "where does common stuff live" discussion :)

[15:53] <TimToady> whether we need a mechanism to renegotiate when one of the endpoints learns more, I dunno yet

[15:54] <jnthn> TimToady: I can kinda see that. 

[15:54] <pmichaud> I'm still not convinced that pipelines are the right way to go.  (But I'm not convinced they aren't, either.)

[15:54] <pmichaud> my design-intuition tells me "no".

[15:54] <TimToady> by pipeline I mean nothing more than nested function calls

[15:54] <pmichaud> in that case, "maybe".

[15:54] <TimToady> for strictly lazy, every function call returns precisely one element

[15:54] <vendethiel> TimToady: are there RFCs you'd "recommend" people to read because they've been really insightful to perl6's creation/evolution,btw? that sounds interesting

[15:55] <TimToady> so that can be as fast as possible

[15:55] <pmichaud> anyway, intuition says there's a clean answer to that (and to handling native array also)

[15:56] <TimToady> vendethiel: I can give you some info on that

[15:56] <pmichaud> TimToady/vendethiel:  +1   I'd like to see that list

[15:56] <vendethiel> .oO( or is it that Array ? )

[15:56] <jnthn> If we are in a position to know "the target of this is assignment into a native array" then I guess we can get something fairly nice in place.

[15:57] <pmichaud> jnthn: ooooh

[15:58] <pmichaud> perhaps because if we're not assigning/binding into a native array, it's going to end up boxing

[15:58] <pmichaud> that feels a bit want-ish, but I think it might be managable.

[15:58] <vendethiel> mh, is explicit derefenrece necessary in perl5 because "$foo" doesn't contain the same value as @foo?

[15:59] <jnthn> pmichaud: Yeah, it's about tyring to avoid boxing to some degree, or have boxing that can be eliminated when inlining.

[16:00] <jnthn> pmichaud: The ideal is that "my int @native-array = @another-native-array.map(-> int $a --> int { $a + 1 });" can execute without any boxing.

[16:00] <pmichaud> jnthn: I don't think I agree with that ideal.

[16:00] <pmichaud> well....

[16:00] <vendethiel> ideone has perl6 but no perl5 Oo

[16:00] <jnthn> pmichaud: In what sense? :)

[16:01] <pmichaud> in the sense of "there's a better way to write that"

[16:01] <pmichaud> my int @x = @y >>+>> 1;

[16:01] <jnthn> pmichaud: Yes, *that* one goes much more nicely as a hyper...not every example will :)

[16:01] <pmichaud> jnthn: so, I'd like to see some examples that don't.  Those are the ones that light the way to go.

[16:02] <pmichaud> because it sounds to me like we're trying to turn the DWIM knob on .map up waaaaay to high

[16:02] <pmichaud> *too

[16:04] <jnthn> Well, the alternative is that folks wanting to write fast code with native things end up writing it in the C-ish dialect of Perl 6 :)

[16:04] <dalek> perl6.org: 147f2fb | TimToady++ | source/archive/rfc/rfc-ratings. (2 files):

[16:04] <dalek> perl6.org: Some notes on how RFCs affected design of Perl 6

[16:04] <dalek> perl6.org: review: https://github.com/perl6/perl6.org/commit/147f2fbceb

[16:04] <TimToady> vendethiel: ^^

[16:04] <vendethiel> TimToady++

[16:04] <pmichaud> jnthn: that's not the only alternative at all... :)

[16:05] <TimToady> to get the coloring, edit with vim and :so vim-ratings.vim

[16:05] <TimToady> er, rfc-ratings.vim

[16:05] <pmichaud> jnthn: that's why I'm wanting to see some "code that wants to be fast" that isn't already better handled by existing constructs

[16:06] <moritz> ok, I have a working patch after all that moves some of the roll implementation into Positional, making array[int] work

[16:06] <moritz> but from our recent discussion, I kinda think it might be the wrong thing to do

[16:06] <pmichaud> I think it needs more thinking, yes.

[16:07] <moritz> so, should I push to a branch?

[16:07] <pmichaud> moving roll into Positional feels very wrong to me.

[16:07] <moritz> or should I try to move it into Iterable?

[16:07] <pmichaud> because roll is something we do on things that have bounds

[16:07] <pmichaud> and neither Positional nor Iterable imply that

[16:07] <moritz> though Iterable also feels wrong

[16:08] <pmichaud> although I suppose it's possible to do .roll on infinite things

[16:08] <moritz> List isn't bounded either

[16:08] <moritz> and still we do List.roll

[16:08] <pmichaud> yeah, I need to think about it a bit more.

[16:08] <moritz> so our current type system simply ignores the question of whether something is bounded

[16:09] <pmichaud> right, and for efficiency sake we need to figure out how to handle finite things better

[16:09] <pmichaud> such as Parcel, and native arrays, and ...

[16:09] <TimToady> and we fall into the P5ish trap of introspect everywhere all the time

[16:09] <pmichaud> moritz: if you can hold this in a branch that would be lovely

[16:09] <TimToady> it's that introspection that wants to get negotiated away

[16:09] <jnthn> pmichaud: I'll have a look at translating some $other-langauge code I have doing that kind of stuff into Perl 6, and see if I actually do come out wanting .grep/.map on native things after all :)

[16:09] <tbrowder> I want to translate one of my simple Perl 5 programs and associated modules to Perl 6.  The one of most interest at the moment uses Geo::Ellipsoid, so I plan to add it to the most wanted list (via a pull request). I also will attempt to translate it to Perl 6 and contribute it (I have checked with the author who is on board with my attempt) .  Geo::Ellipsoid, in turn, currently depends on more well-known Perl 5 modules: Math::Trig, Sc

[16:09] <pmichaud> jnthn: I think that's the best way to go.  I think it will be very illuminating

[16:10] <TimToady> .map on a native can certainl know that only the entire result needs to be boxed, at most

[16:10] <moritz> tbrowder: your line was truncated after "Math::Trig. Sc"

[16:10] <masak> tbrowder: you got cut off, at 'Math::Trig, Sc'

[16:10] <TimToady> and that returned box can then deal with further list processing

[16:10] <moritz> masak: my trusted echo :-)

[16:11] *** eli-se joined
[16:11] <TimToady> er, well, depending on the return type of the function, of course

[16:11] <eli-se> hahaha

[16:11] <pmichaud> TimToady: yeah, that's a promising approach

[16:11] <jnthn> TimToady: Yes, that's kinda my "what does .map on a native int array return" question :)

[16:11] <masak> moritz: yeah, I drew slightly slower this time :P

[16:12] <tbrowder> ...Math::Trig, Scalar::Utils, Test::Simple, and Test::Number::Delta. I have checked the known modules list and have found none of them on the list.  Should I add them to the most wanted list, or are one or more actually obsolete now or part of the Perl 6 core?

[16:12] <eli-se> jnthn: int array if the return type of the function in int, normal array otherwise!

[16:12] <moritz> tbrowder: what functions from Math::Trig do you need, for example?

[16:12] <moritz> tbrowder: most of Scalar::Utils is unnecessary in Perl 6

[16:12] <jnthn> eli-se: I suggested that as a possible answer earlier, yes ;)

[16:13] <pmichaud> TimToady: in rfc-ratings.txt does the "!" imply "with emphasis" and "with extreme prejudice"? 

[16:13] <eli-se> Scala does that, although it may be inefficient in a dynamically typed language, since you need all results first.

[16:13] <tbrowder> Um, I haven't gotten that far into it yet, but I can provide that if needed--just take a little effort.

[16:13] <eli-se> And then loop over all results to find the types.

[16:13] <dalek> rakudo/richer-positional: ec56951 | moritz++ | src/core/ (2 files):

[16:13] <dalek> rakudo/richer-positional: Move .roll into Positional

[16:13] <dalek> rakudo/richer-positional: 

[16:13] <dalek> rakudo/richer-positional: this way, native arrays automatically get a roll method.

[16:13] <dalek> rakudo/richer-positional: 

[16:13] <dalek> rakudo/richer-positional: Needs more discussion about whether this is the right approach.

[16:13] <dalek> rakudo/richer-positional: An objection was that Positional does not necessary imply .elems

[16:13] <dalek> rakudo/richer-positional: review: https://github.com/rakudo/rakudo/commit/ec56951f50

[16:13] <jnthn> eli-se: But Perl 6 is gradually typed :)

[16:13] <TimToady> pmichaud: it just meant something I might want to talk about, at the time

[16:13] <jnthn> eli-se: So you can declare on the lambda what you're giving back :)

[16:13] <eli-se> :[

[16:14] <TimToady> the funny one was that we accepted  352 Merge Perl and C#, but have default Main class for scripting.

[16:14] <pmichaud> having .map be return-type aware seems to have some promise, even beyond natives...      having   @something.map( -> $x --> Foo { ... })   be able to return List[Foo] might be worthwhile also.

[16:14] <jnthn> Looping over all results to find types is odd. By then you probably boxed them all :P

[16:15] <jnthn> pmichaud: Yes, very true :)

[16:15] <TimToady> we do need to think about the typologoy of lists if we're ever to manage typed slurpies

[16:15] *** liztormato joined
[16:15] <TimToady> *ology

[16:16] <pmichaud> at the same time, it feels to me that    @something.map( &lambda, :return-type(MyType[Foo])) is the more correct answer.

[16:16] * FROGGS .oO( *isms )

[16:16] <TimToady> yuck

[16:16] <pmichaud> I mean concept, not syntax.

[16:16] <eli-se> Clojure has into

[16:16] *** liztormato_ joined
[16:16] <pmichaud> :into  feels nice

[16:17] <TimToady> still yuck

[16:17] <eli-se> so you can use map with a starting result value

[16:17] <TimToady> at least, get rid of the Foo

[16:17] <eli-se> e.g. (into [] (map f xs)) returns a vector and (into #{1 2 3} (map f xs)) returns a set already populated with 1, 2 and 3.

[16:17] <TimToady> all you need is the container role to instantiate with the result of the function

[16:18] <liztormato_> To me this feels like an internal attribute like :$BIND

[16:18] <pmichaud> what if I wanted to coerce?

[16:18] <liztormato_> *:into I mean

[16:18] <eli-se> pmichaud: map(&coerce)

[16:19] <pmichaud> eli-se: yes, but sometimes I didn't write &coerce.  it feels funny-ish.

[16:19] <TimToady> the individual coercions are the mandate of the mapping funciton

[16:19] <TimToady> *ion

[16:19] <TimToady> if need be, you just compose two functions

[16:19] *** liztormato left
[16:19] *** liztormato_ is now known as liztormato

[16:20] <pmichaud> I still haven't reconciled myself with things like :$BIND... I need to do that.

[16:21] <moritz> on an only slightly related note, should List[Int()] DWIM?

[16:21] <moritz> that is, a list of Ints that coerces on element assignment?

[16:22] <pmichaud> moritz: I think I've somewhat assumed that it does.

[16:22] <TimToady> and if so, can we have a listop that goes before the rest of your slurped list that declares teh rest of the list is that type?

[16:22] <TimToady> (on the calling end)

[16:22] <pmichaud> I'm out of date on coercers, too.  I need to catch up on the most recent design decisions there.

[16:23] <TimToady> one assumes one could put Int() *@ints on the formal end

[16:23] *** tgt left
[16:23] * liztormato will catch up later&

[16:24] *** liztormato left
[16:24] <TimToady> but with a List[Int]: form, or so, you could tag the rest of the args as a list of Int, and bind (by name!) to Int *@ints

[16:25] <pmichaud> I'll have to bail also, my brane has reached its absorption capacity for this morning.   It's still decluttering from this week's robotics contests.

[16:25] <pmichaud> perhaps "defragmenting" is the better term :)

[16:25] <TimToady> List[Int] is kinda klunky for that, so the list bit might be factorable out

[16:25] <TimToady> see ya

[16:27] <moritz> Int[]

[16:27] <TimToady> basically a typed slurpy would not consider itself variadic, but would require a single typed list for the rest of the args

[16:27] <TimToady> and one could formally declare the type of the rest of the args with a slurpy-prep coercion of some sort

[16:28] <TimToady> some-slurpy-function $a,$b,$c, Int* 1..*

[16:28] <[Tux]> was is the most effective way to check if an array like (1,4..7,19..Inf) has $i in it? defined @x[$i] ?

[16:28] <TimToady> and some such would bind to three positionals and an Int slurpy

[16:29] <vendethiel> o_o

[16:29] <TimToady> syntax negotiable, of course

[16:29] * vendethiel wonders what's going on there

[16:30] <tbrowder> Math functions needed are: pi, cos, sin, sqrt, atan2, and abs.  All are listed in http://doc.perl6.org/routine.html so I guess I don't need Math::Trig.

[16:30] <TimToady> |Tux|: you seem to be confusing values and indices there

[16:30] <[Tux]> @x.grep($i)

[16:31] <[Tux]> yes I was

[16:31] <TimToady> yes, grep will, of course, illustrate the halting problem nicely there :)

[16:31] <[Tux]> that is what I was afraid of

[16:31] <[Tux]> that is why I ask :)

[16:31] <moritz> tbrowder: correct

[16:32] <TimToady> if you know it's monotic, then maybe .first(* >= $i)

[16:32] *** Akagi201 left
[16:33] <jnthn> m: say so (1,4..7,19..Inf).lol.first(2)

[16:33] <camelia> rakudo-moar 9b295b: OUTPUT«False␤»

[16:33] <jnthn> m: say so (1,4..7,19..Inf).lol.first(5)

[16:33] <camelia> rakudo-moar 9b295b: OUTPUT«False␤»

[16:33] <TimToady> if you know you have a finite list of (potentially infinite) ranges, you can just run down the list of ranges and smartmatch against each

[16:33] <jnthn> oh.

[16:33] <jnthn> m: say so (1,4..7,19..Inf).tree.first(5)

[16:33] *** Akagi201 joined
[16:33] <jnthn> bah

[16:33] <TimToady> that's backwards

[16:33] <jnthn> away for a bit &

[16:34] <camelia> rakudo-moar 9b295b: OUTPUT«(timeout)»

[16:34] <jnthn> Post-GLR, just .first should do it... :)

[16:34] <jnthn> really away &

[16:34] <vendethiel> TimToady: https://github.com/perl6/perl6.org/commit/147f2fbceb#diff-32594ce7e065fb0cdd6119591c0c0219R158 "printciple" :P

[16:35] <TimToady> m: say so (1,4..7,19..Inf).tree.first: { 5 ~~ $_ }

[16:35] *** muraiki left
[16:35] <camelia> rakudo-moar 9b295b: OUTPUT«(timeout)»

[16:36] <TimToady> ranges maybe don't itemize the way tree is trying to do, I guess

[16:36] <FROGGS> jnthn: I think... it might make sense to leave the digest+jvm bug (my $foo = (42 for ^2)) for post GLR?

[16:36] <TimToady> m: ((1,2),(3,4)).tree.perl

[16:36] <camelia> rakudo-moar 9b295b: ( no output )

[16:36] <TimToady> m: ((1,2),(3,4)).tree.perl.say

[16:36] <camelia> rakudo-moar 9b295b: OUTPUT«(1, 2; 3, 4).item␤»

[16:37] <TimToady> moritz: btw, a day or two in the backlog you were playing with lols, and apparently missing the semicolons there

[16:37] <TimToady> m: ((1,2),(3,4)).lol.perl.say

[16:37] <camelia> rakudo-moar 9b295b: OUTPUT«(1, 2; 3, 4)␤»

[16:37] <moritz> m: say ((1,2),(3,4)).lol[0]

[16:37] <camelia> rakudo-moar 9b295b: OUTPUT«1 2␤»

[16:37] <TimToady> m: ((1,2),(3..5)).lol.perl.say

[16:37] <camelia> rakudo-moar 9b295b: OUTPUT«(1, 2; 3, 4, 5)␤»

[16:37] <moritz> m: .say for ((1,2),(3,4)).lol

[16:37] <camelia> rakudo-moar 9b295b: OUTPUT«1 2␤3 4␤»

[16:37] <moritz> oh, seems to work better than I feared

[16:38] <moritz> thanks TimToady 

[16:38] <TimToady> what's flattening the range there?

[16:38] <TimToady> m: say (1..5).perl

[16:38] <camelia> rakudo-moar 9b295b: OUTPUT«1..5␤»

[16:38] <vendethiel> Oo TIL perl5 has an "unimport" construct

[16:38] <TimToady> our unimport is called "your lexical scope ran out"  :)

[16:39] <geekosaur> p5 unimport takes advantage of p5 import being an ugly hack

[16:39] <TimToady> though we do support the 'no' declaration to some extent

[16:40] <moritz> m: say so (1,4..7,19..Inf).lol.first: { 5 ~~ $_ }

[16:40] <camelia> rakudo-moar 9b295b: OUTPUT«True␤»

[16:40] <vendethiel> "no use;"

[16:40] <moritz> TimToady: it currently looks like .tree is an inferior subset of .lol, or so

[16:40] <TimToady> it used to be we had to use .tree to mean .lol

[16:41] <TimToady> maybe now that most of the .trees that meant .lol are being caught (are they?) we can fix .tree

[16:41] <TimToady> m: say so (1,4..7,19..Inf).lol.first: { 20 ~~ $_ }  # just checking...

[16:41] <camelia> rakudo-moar 9b295b: OUTPUT«True␤»

[16:41] <TimToady> \o/

[16:42] *** kjs_ joined
[16:42] <rindolf> what is .lol?

[16:42] <moritz> list-of-list

[16:43] <rindolf> Like [0] [0,1] [0,1,2] [0,1,2,3], etc.?

[16:43] <rindolf> And what is "so"?

[16:44] *** anaeem1_ left
[16:44] <timotimo> opposite of not 

[16:44] *** anaeem1 joined
[16:44] <moritz> rindolf: http://faq.perl6.org/#so

[16:45] <moritz> it's surprising, but we have, like, documentation :-)

[16:45] <rindolf> moritz: ah.

[16:45] <moritz> also http://doc.perl6.org/so

[16:46] <rindolf> Thanks!

[16:46] <rindolf> So what does .lol do?

[16:47] <moritz> it turns a list of otherwise potentially flattening lists or parcels into a list-of-lists

[16:47] <moritz> thereby protecting the inner structures from flattening

[16:48] *** daxim left
[16:48] <timotimo> and tree makes parcels all the way down or to the level specified 

[16:49] <moritz> m: say ((1, 2), (3, 4)).tree.perl

[16:49] <camelia> rakudo-moar 9b295b: OUTPUT«(1, 2; 3, 4).item␤»

[16:49] *** anaeem1 left
[16:49] <moritz> timotimo: except that it doesn't, right now

[16:50] <timotimo> we'll see one the glr is through 

[16:50] *** anaeem1_ joined
[16:50] <TimToady> tree is supposed to apply a mapping function to each node at each level, differentiable by level

[16:51] *** mjaggersnagger joined
[16:52] *** smls left
[16:52] <TimToady> don't really think there's all that much interaction with GLR though

[16:52] *** anaeem1__ joined
[16:52] <timotimo> Oh,  ok

[16:52] *** anaeem1_ left
[16:52] <TimToady> we could probably fix .tree right now

[16:53] <adu> parsers?

[16:53] <TimToady> what about parsers?

[16:54] <moritz> adu: parsers parse. Or at least common wisdom says so.

[16:54] <adu> that's what I'm trying to understand

[16:54] <adu> moritz: I'm quite familiar with parsers

[16:54] <TimToady> a more specific question would help ascertain a more specific answer :)

[16:54] <mjaggersnagger> hi

[16:54] <adu> I wrote C::Parser, I should know at least a little bit

[16:54] <TimToady> mjaggersnagger: howdy

[16:54] <mjaggersnagger> :) I have a question :o

[16:55] <TimToady> not yet you don't :P

[16:55] <mjaggersnagger> ooo

[16:55] *** Akagi201_ joined
[16:55] <TimToady> if you ask it, you will :)

[16:55] <mjaggersnagger> haha

[16:55] <mjaggersnagger> well basically

[16:55] <mjaggersnagger> is it mandatory that you need a grammar defined for a language?

[16:55] <mjaggersnagger> like can you not just wing it? and if so, how does it help?

[16:55] <b2gills> how else would you create it?

[16:56] <adu> mjaggersnagger: I think that's called a module

[16:56] <TimToady> well, in a sense, a recursive descent parser has no grammar

[16:56] <mjaggersnagger> yeah I've written a parser already

[16:56] <mjaggersnagger> with no like formal grammar define

[16:56] <mjaggersnagger> d

[16:56] *** anaeem1__ left
[16:57] *** anaeem1 joined
[16:57] <TimToady> so, for instance, the EXPR method in P6's parser is just a operator precedence parser, and has no formal grammar

[16:57] <TimToady> except as defined operationally by the method

[16:57] <mjaggersnagger> so it's not completely necessary?

[16:57] <eli-se> Will Perl 6 get glob?

[16:57] <adu> mjaggersnagger: oh, so a custom parse method?

[16:57] <TimToady> sure

[16:57] <mjaggersnagger> hmm

[16:57] <vendethiel> eli-se: no :P

[16:57] <eli-se> Will it allow recursion?

[16:57] <eli-se> vendethiel:  :(

[16:58] <vendethiel> wait, the glob() function?

[16:58] <eli-se> yeah for finding files

[16:58] <TimToady> well, why not have a glob?

[16:58] <vendethiel> oh, this one

[16:58] <vendethiel> I think dir(:test...) works okay-ish for now

[16:58] <mjaggersnagger> im writing a language for like no reason whatsoever, and I'm stuck at parsing expressions :(

[16:58] <TimToady> mjaggersnagger: it helps to have reasons...

[16:58] <adu> mjaggersnagger: are you using the builtin EXPR?

[16:59] <mjaggersnagger> and when I ask, people say I need a grammar defined. If I already know the kind of syntax of my grammar, does that mean that I kind of have a grammar defined

[16:59] <adu> mjaggersnagger: or from scratch?

[16:59] <mjaggersnagger> I just don't really know it?

[16:59] *** Akagi201 left
[16:59] <mjaggersnagger> built in expr?

[16:59] <mjaggersnagger> I'm writing it in C from scratch

[16:59] <TimToady> if you're writing something just as a form of abstract expressionism, I recommend acrylic or oil paints instead...

[16:59] <moritz> mjaggersnagger: and here I thought your question was about parsing with Perl 6, this being #perl6 and all :-)

[17:00] <mjaggersnagger> hahaha

[17:00] <mjaggersnagger> I bookmarked this place from r/compiler

[17:00] <mjaggersnagger> s

[17:00] <adu> mjaggersnagger: then you need to learn about LR

[17:00] <moritz> mjaggersnagger: if you want to write a parser in C, I'd very much recommend using a parser library, something like https://jeffreykegler.github.io/Marpa-web-site/ maybe

[17:00] <mjaggersnagger> sorry for being in the wrong place :o

[17:01] <adu> mjaggersnagger: https://en.wikipedia.org/wiki/Shift-reduce_parser

[17:01] *** anaeem1 left
[17:01] <mjaggersnagger> ooo but I've already written a lot of the parser

[17:01] <moritz> because just parsing from "first principles" in C simply is too much pain

[17:01] <mjaggersnagger> it's recursive descent and works, except for my hacky expressions parsing

[17:02] *** daxim joined
[17:02] <TimToady> to the first approximation, P6's compiler is recursive descent with a layer of operator precedence in the middle

[17:02] <mjaggersnagger> yeah I was going to try operator precedence parsing

[17:02] <TimToady> well, it can be many layers, but even so

[17:02] <mjaggersnagger> but it basically generates C or transcompiles or whatever

[17:02] <mjaggersnagger> so I can literally just kinda cut the expression from the source and paste it in the compiled source, so to speak

[17:03] <mjaggersnagger> hasn't worked out so well, haha

[17:03] <TimToady> you still need to recognize the end of the expression correctly

[17:03] <mjaggersnagger> yeah that's the issue, it's consuming the thing that shows when an expression ends

[17:03] <TimToady> because you can't "kinda cut", you either do, or you don't, cut

[17:04] <TimToady> and it's either right or wrong

[17:04] <mjaggersnagger> I suppose the issue is that it doesn't know where an expression ends, thats why its not cutting the expression out

[17:04] <TimToady> when you write parsers, and cheat, you always get caught eventually

[17:04] <mjaggersnagger> lol, very true

[17:04] <mjaggersnagger> I had this hacky rule that if the current token is not an operator and the next token isnt an operator, it probably isn't an expression

[17:05] <TimToady> Perl 5 cheated many ways, and got caught frequently, so it's a viable approach :)

[17:05] <mjaggersnagger> so it'd stop eating tokens

[17:05] <TimToady> but we try very hard to do things in a non-cheating way for Perl 6

[17:05] <mjaggersnagger> learn from your mistakes, eh?

[17:05] <TimToady> or at least give the appearance

[17:05] <mjaggersnagger> haha

[17:06] <mjaggersnagger> my first compiler, so I still have a lot to learn

[17:06] <TimToady> don't we all

[17:06] <mjaggersnagger> deeeep

[17:07] *** anaeem1 joined
[17:07] <mjaggersnagger> kinda weird that I've never actually written any Perl before

[17:07] <mjaggersnagger> and I'm in an IRC about perl

[17:07] <adu> mjaggersnagger: operator precedence is a PITA without LR

[17:08] *** sqirrel joined
[17:08] <TimToady> well, Perl folks tend to be pathologically helpful

[17:08] <mjaggersnagger> I think it's left to right, my theory isn't too strong

[17:08] <TimToady> except when they're not

[17:09] <TimToady> adu: how so?

[17:10] <mjaggersnagger> I should try op perc parsing, but I'm not sure how to settle on the precedence for each operator :o

[17:10] <mjaggersnagger> prec*

[17:11] <TimToady> imagine the common cases, and how to minimize the number of parentheses needed, and especially of the surprising ones.

[17:11] <TimToady> but they're no magical bullet

[17:11] <TimToady> there will be cases that surprise people always

[17:12] <TimToady> in Perl 6 the most frequent surprise is needing parens on (^10).stuff

[17:13] <mjaggersnagger> hmm

[17:13] <adu> TimToady: how would you do it?

[17:13] <TimToady> thing is, you could fix that, but then someone who wants ^(10.stuff) would be surprised

[17:13] <TimToady> how would I do what?

[17:14] <adu> TimToady: handle operator precedence and operator associativity without LR parsing methods?

[17:14] <TimToady> the way Perl 6 does

[17:14] <moritz> "magically"

[17:14] <moritz> "perly"

[17:14] <moritz> it's really the same thing :-)

[17:15] <adu> with backtracking?

[17:15] <TimToady> why would you ever need backtracking on an op prec parser?

[17:15] <TimToady> (assuming one-token lookahead is not the definition of LR here...)

[17:16] *** eli-se left
[17:16] <TimToady> you're certainly allowed to look ahead to see if there's a terminator, or an infix at some precedence

[17:16] <adu> for example, if operator and operand parsers are not mutually exclusive

[17:17] <TimToady> example?

[17:17] <adu> "minus a mod b factorial" for example

[17:18] <TimToady> well, but they are exclusive in P6, which seems like a good thing

[17:19] <adu> presumably, would parse as (-a) % (b!)

[17:19] <TimToady> the P6 parser always knows whether it's expecitng a term or an infix

[17:19] <adu> right, but you would need something other than backtracking to help parse that

[17:20] <TimToady> our term parser is recursive descent, is all

[17:21] <TimToady> so the only thing EXPR has to worry about on affixes is their order, in cases like -a!

[17:21] <TimToady> or ^10.foo

[17:22] <mjaggersnagger> guuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuys

[17:22] <mjaggersnagger> how do I tell if my parser is LL or LR? I honestly don't know myself :o

[17:23] <vendethiel> which side is it going from? :P

[17:23] <mjaggersnagger> well its like reading some text

[17:23] <mjaggersnagger> top to bottom left to right

[17:24] <mjaggersnagger> is that LR?

[17:24] <TimToady> no, see http://en.wikipedia.org/wiki/LR_parser

[17:25] <adu> mjaggersnagger: it doesn't matter which direction it's read

[17:25] <adu> mjaggersnagger: 9/10 you're dealing with LR

[17:25] <mjaggersnagger> ooo oke

[17:25] <mjaggersnagger> :D

[17:25] <mjaggersnagger> thanks for helping me out everyone :D

[17:25] <mjaggersnagger> i gotta go now, I might check back soon

[17:26] <mjaggersnagger> ciao

[17:26] <TimToady> o/

[17:26] *** mjaggersnagger left
[17:28] *** Celelibi left
[17:31] <[Tux]> I have a hard tom writing the p6 form of «my ($left, $right) = $string.split("-")»

[17:31] <vendethiel> that seems correct to me

[17:33] *** Celelibi joined
[17:33] <FROGGS> m: my ($left, $right) = "foo-bar-baz".split("-"); say $left

[17:33] <camelia> rakudo-moar 9b295b: OUTPUT«foo␤»

[17:33] <FROGGS> m: my ($left, $right) = "foo-bar-baz".split("-"); say $right

[17:33] <camelia> rakudo-moar 9b295b: OUTPUT«bar␤»

[17:33] <FROGGS> m: my ($left, $right) = "foo-bar-baz".split("-", 2); say $right

[17:33] <camelia> rakudo-moar 9b295b: OUTPUT«bar-baz␤»

[17:34] <FROGGS> [Tux]: ^^

[17:35] <TimToady> P5 actually optimizes that to .split("-",3)

[17:35] <TimToady> so it doesn't do a bunch of splitting, just to throw the rest of the list away

[17:35] <TimToady> I suppose in P6 that could just be lazy

[17:35] <mst> certainly the p5 implementation of that optimisation is not something one would particularly want to copy :)

[17:36] <TimToady> ss/of that optimisation // :P

[17:37] <TimToady> but it certain does to various sneaky clever tricks like that

[17:37] <TimToady> seems to be the specs require that a list that is too long complain there unless you end the list with *

[17:38] <TimToady> *speculations

[17:39] <TimToady> S03:2991

[17:39] <synopsebot> Link: http://design.perl6.org/S03.html#line_2991

[17:41] <TimToady> m: my ($left, $right) := "foo-bar-baz".split("-"); say $right

[17:41] <camelia> rakudo-moar 9b295b: OUTPUT«Too many positionals passed; expected 2 arguments but got 3␤  in block <unit> at /tmp/CIRhYO5JJG:1␤␤»

[17:41] <TimToady> m: my ($left, $right, *) := "foo-bar-baz".split("-"); say $right

[17:41] <camelia> rakudo-moar 9b295b: OUTPUT«5===SORRY!5=== Error while compiling /tmp/5mHltW5xb8␤Malformed parameter␤at /tmp/5mHltW5xb8:1␤------> 3my ($left, $right, *7⏏5) := "foo-bar-baz".split("-"); say $righ␤    expecting any of:␤        formal parameter␤»

[17:41] *** atta left
[17:41] <TimToady> m: my ($left, $right, *@) := "foo-bar-baz".split("-"); say $right

[17:41] *** atta joined
[17:41] <camelia> rakudo-moar 9b295b: OUTPUT«bar␤»

[17:41] <TimToady> so maybe assignment should be a little more like binding there...

[17:44] *** adu left
[17:45] *** eli-se joined
[17:45] *** itz_ joined
[17:45] *** itz left
[17:46] *** telex left
[17:48] *** telex joined
[17:49] *** sqirrel left
[17:51] <TimToady> Mouq: the problem with swapping the defaults on shapes vs subsigs is that as an rvalue in ordinary code, &foo($,$) would cause a call of foo, so the syntax there is currently &foo:($,$)

[17:52] <TimToady> so one would like to keep the same syntax for &foo:($,$) in the signature to indicate part of the type of foo, as distinct from the unpacking parens

[17:53] <TimToady> it would be lovely if there were a way that &foo($,$) could consistently be a full sub declaration, but not at the expense of our current deref system

[17:54] <eli-se> what is $,$?

[17:54] <TimToady> maybe &foo(...) could be a special form, but that's also ucky

[17:54] <eli-se> a variable named ,$ with a $ sigil? :P

[17:54] <moritz> eli-se: a list of two anonymous variables

[17:54] <eli-se> :O

[17:54] <TimToady> or in a signature, two scalar args that are not bound

[17:55] *** Ugator left
[17:55] <TimToady> think _ in Prolog and such

[17:55] <moritz> does anybody have a monitoring system that could send me an email if the load on hack goes too high?

[17:55] <TimToady> so we're talking about a function named foo that we know takes two scalar positionals

[17:55] <moritz> I'd like to be able to log in and investigate before it becomes unresponsive

[17:57] <eli-se> moritz: If you host on Rackspace then there's one. I also used Cacti but I don't know whether it can email automatically.

[17:57] *** BenGoldberg left
[17:58] <TimToady> put a temp sensor on the fan? :)

[17:58] <eli-se> Otherwise, it's simple to implement.

[17:58] <moritz> eli-se: it's not Rackspace

[17:59] <moritz> eli-se: and last I looked, cacti was more of an aggregation than a monitoring system

[17:59] *** kjs_ left
[17:59] *** tbrowder left
[17:59] <eli-se> while true; do if [ load > n ]; then email; fi; done :P

[17:59] <moritz> and I know it can be built; I just don't have a mail server running on any of my always-on hosts

[17:59] <moritz> eli-se: assuming there's a mailer running

[17:59] <eli-se> yeah

[17:59] <moritz> which is why I'm asking for somebody who already has a monitoring system running

[17:59] <TimToady> just send a UDP packet :)

[18:00] * moritz sighs

[18:00] <eli-se> or delete the website; you'll notice soon enough

[18:00] * TimToady actually does a lot with UDP packets inside his house

[18:01] <Woodi> hi everyone :)

[18:01] <Woodi> moritz: "systems" usualy include web interface... but also have sensors that could be reused

[18:02] <moritz> Woodi: thank you the unnecessary lecture on "systems"

[18:02] <Woodi> moritz: I used "mon" years ago, and later hear about "nagios"

[18:02] <moritz> Woodi: that's not what I was asking for

[18:04] <eli-se> hire someone to continuously cat /proc/loadavg

[18:04] *** molaf_ left
[18:04] <vendethiel> *g*

[18:05] <moritz> this channel is becoming more and more like p6l

[18:05] <bartolin> moritz: I could help with that. I've got a nagios instance running on a virtual server

[18:06] <eli-se> I'd take that job, automate it and then make lots of money.

[18:06] <moritz> bartolin: that would be great. What do I have to do to make it happen?

[18:06] <vendethiel> moritz: p6l?

[18:06] <vendethiel> perl6-language mailing list?

[18:07] <moritz> vendethiel: the very same

[18:07] <bartolin> moritz: you'd need to run nagios-nrep-server locally and allow access from my ip

[18:07] <hahainternet> moritz: what's up

[18:07] <TimToady> that's what he's trying to figure out :)

[18:07] <hahainternet> ah you want a monitoring system that is open and accessible

[18:07] <moritz> vendethiel: where asking about the naming of a certain method brought up suggestions for a major rewamp of the whole object system

[18:07] <hahainternet> sorry i can't do that :(

[18:07] <jnthn> FROGGS: Yes, agree leave the digest bug until post-GLR if it's turning out to be non-obvious.

[18:08] <vendethiel> moritz: got any link for me :P?

[18:08] <moritz> bartolin: installing now

[18:11] <FROGGS> jnthn: it would probably mean I have to understand iterators or something...

[18:12] <masak> TimToady++ # https://github.com/perl6/perl6.org/commit/147f2fbceb

[18:12] *** eli-se left
[18:13] <TimToady> it needs a modeline to automatically apply the colorings somehow

[18:14] *** eli-se joined
[18:14] <TimToady> if such a thing is possible

[18:15] <TimToady> of course, I'm using the colorings from murphy, so maybe this is the wrong approach entirely...

[18:15] <TimToady> but the letters are supposed to pun to the color names

[18:20] *** vendethiel left
[18:27] *** ash_gti joined
[18:45] <ash_gti> https://github.com/github/linguist/pull/2229 was merged into github/linguist so (perl6|nqp) should start having some basic syntax support on github, I am working on more comprhensive matchers though, like for instance, method names and variables are only the simplest cases

[18:46] *** cognominal joined
[18:51] *** bayprogrammer joined
[18:53] *** kjs_ joined
[18:53] *** eli-se left
[18:54] <flussence> as far as monitoring load goes, having the system you're checking for signs of life responsible for sending the email when it falls over is probably not the best idea...

[18:54] <TimToady> .oO(dead man's switch)

[18:55] <moritz> flussence: aye; bartolin++ kindly volunteered a nagios instance he runs on a different host

[18:55] <flussence> bartolin++ :)

[18:56] *** kaare_ joined
[18:57] *** eli-se joined
[18:58] <flussence> (I made the same mistake myself for a while: having a remote server try to email my home server to tell it when dyndns needs kicking...)

[18:59] *** zakharyas left
[19:00] <TimToady> dinner &

[19:02] *** vendethiel joined
[19:02] *** LonelyGM joined
[19:06] *** LonelyGM left
[19:08] <moritz> it's fascinating to see how many of those RFCs dealt with lvalue subs

[19:10] <moritz> 5, actually

[19:10] *** perl6_newbee left
[19:20] *** zakharyas joined
[19:29] *** dpuu left
[19:30] *** J-L left
[19:32] *** LonelyGM joined
[19:34] <LonelyGM> Hey everyone

[19:36] <vendethiel> o/

[19:38] *** zakharyas left
[19:39] *** zakharyas joined
[19:42] *** eli-se left
[19:45] <LonelyGM> I'm live with Larry from SoulFood Budapest getting some ribs :)

[19:45] <vendethiel> nice :D

[19:48] *** grondilu left
[19:49] *** eli-se joined
[19:50] *** LonelyGM left
[19:52] <timotimo> bon appetit

[19:58] <moritz> why did I read "getting some rjbs"? :-)

[19:59] <FROGGS> moritz: I thought the same :o)

[20:00] <moritz> FROGGS: good, I'm not the only one who's insane :-)

[20:03] <mst> moritz: because when it comes to innuendos you have an overactive gag reflex

[20:05] <masak> :P

[20:06] *** LonelyGM joined
[20:11] *** eli-se left
[20:13] *** bayprogrammer left
[20:14] *** ash_gti left
[20:14] *** Vlavv_ left
[20:16] * flussence figures out where the sound's hiding in those fosdem videos, and gets to watching them

[20:16] *** LonelyGM left
[20:16] <timotimo> i want to see the froggs talk :(

[20:16] <vendethiel> flussence: tell us!

[20:17] *** LonelyGM joined
[20:17] <flussence> adding about 20-30dB to the audio seems to work...

[20:17] *** Vlavv_ joined
[20:18] *** darutoko left
[20:18] <flussence> (I've run them through replaygain stuff, and it tells me peak +24.45dB for jnthn's video and +33.03dB for tadzik's video)

[20:20] <FROGGS> timotimo: :/

[20:20] <LonelyGM> :/

[20:21] <flussence> (I haven't got to tadzik's one yet though, it might turn out to be static with those levels...)

[20:21] <LonelyGM> 15Is creating a working Perl 6 compiler harder than creating a compiler for any of the above languages?

[20:22] <LonelyGM> I mean any other :)

[20:22] *** japhb left
[20:23] *** japhb joined
[20:23] <moritz> LonelyGM: it's considerably harder than many for many other languages

[20:25] <LonelyGM> And what do you think what is the main reason behind it?

[20:25] <moritz> LonelyGM: I should blog about that :-)

[20:26] *** grondilu joined
[20:26] <LonelyGM> moritz: you have your first subscriber ;)

[20:26] <vendethiel> oooh, could it be possible to write pod blocks just before a function to have executable specs?

[20:26] <moritz> some aspects: mutable grammar, gradual typing, sophisticated OO system

[20:27] <moritz> then the exploratory nature of the project

[20:27] <moritz> our MOP

[20:28] <grondilu> Hello.  I was reading stuff about Monte-Carlo methods and how they can be seen as a way to perform numerical integration.  So I look at an example to test in http://rosettacode.org/wiki/Numerical_integration#Perl_6, and pick x**3 from 0 to 1.  Then I write:  .say for ([\+] rand**3 xx *) Z/ 1 .. *, and I was happy with it, but then I notice it is not stable in terms of memory usage.  Shouldn't the for loop 

[20:28] <grondilu> empty the array as it is consummed?

[20:31] *** zakharyas left
[20:32] <moritz> LonelyGM: watch http://perlgeek.de/blog-en/ for updates :-)

[20:32] <LonelyGM> moritz: wow dankeschön

[20:35] <grondilu> on the other hand I notice that even:

[20:35] <grondilu> my @a := ([\+] rand ** 3 xx *) Z/ 1 .. *; loop { say @a.shift }'

[20:35] <grondilu> is not memory stable.  I guess I must be missing something.

[20:35] <moritz> grondilu: why would you expect it to be stable in memory?

[20:35] <moritz> grondilu: it produces objects that are GCed whenever there is a GC run

[20:36] *** eli-se joined
[20:36] <moritz> so basically any Perl 6 program at all that allocates objects somewhere isn't memory stable

[20:36] *** LonelyGM left
[20:37] <grondilu> just to be clear : by memory stable I mean "RAM usage does not keep increasing"

[20:37] <moritz> oh

[20:37] <moritz> well, it should go down too occasionally

[20:37] <grondilu> I'm running the program and watch it with htop

[20:37] <moritz> if not, it's most likely a bug

[20:38] <grondilu> I'll keep it running and see how high it gets.

[20:42] <grondilu> so far I'm at 35% RAM, still increasing.

[20:44] * grondilu stops it as it really does not seem to be willing to stop

[20:45] * grondilu tries a simpler example : .say for [+] rand xx * and notices its RAM usage also steadily increases. 

[20:46] *** lichtkind left
[20:47] * grondilu tries the even simpler '.say for rand xx *' and notices again an increasing RAM usage.  He thinks that's LTA

[20:50] *** diana_olhovik_ left
[20:51] *** diana_olhovik_ joined
[20:53] *** rindolf left
[20:53] * grondilu notices that '.say for 1..*' also has its RAM usage fly away.  That seems dumb if you ask him.

[20:54] *** eli-se left
[20:54] *** japhb left
[20:55] *** japhb joined
[20:55] <bartolin> it doesn't even need the .say, does it? 'for 1..* {  }'

[20:56] <grondilu> yeah but I'm not sure the optimizer would not do something to an empty loop.

[20:57] <grondilu> like turning it into loop { }  or something.

[20:57] <bartolin> ahh, I see

[20:58] <grondilu> (also I like to display stuff to see what's going on)

[20:59] <bartolin> well, looking at the ram usage, it isn't optimized to 'loop { }' :-/

[21:02] *** lichtkind joined
[21:03] <Mouq> moritz: Hah, good tip. Thanks :)

[21:04] <Mouq> I'm still catching up on backlog, but it seems like a lot of the GLR issues stem from the intentional conflation of lazy and not-lazy. I think it might be a better direction if we seperated these things in a way that they were both as easy to use, but the programmer always knew which was which.

[21:05] <Mouq> At the same time I'm not sure that's a very Perlish approach

[21:06] <itz_> I just had t/spec/S09-typed-arrays/native.t using much memory and so slow

[21:06] <itz_> probably a work-in-progress :)

[21:09] <Mouq> Also, very tangential, when I implemented .tree I had it apply to the outermost list (which is why ((1,2),(3,4)).tree ends up as (1, 2; 3, 4).item). I'm thinking now that that's incorrect behavior

[21:09] <Mouq> itz_: Latest Rakudo+NQP+Moar?

[21:09] <itz_> Mouq: as built via rakudobrew

[21:11] <Mouq> Ah… no clue :P But that is something that was added very recently. What are you running on?

[21:11] <itz_> this was a NetBSD VM .. just trying linux

[21:13] *** beastd joined
[21:14] <Mouq> grondilu: I think that's an established pre-GLR fail. Definitely LTA that we accumulate the elements of the iterator there (at least I'm pretty sure that's what's going on)

[21:15] *** BenGoldberg joined
[21:16] <Mouq> itz_: After test 94 appears to hang? That's what I'm getting on OS X

[21:18] <Mouq> Though I'm not on NQP- and MoarVM-HEAD yet

[21:18] <flussence> aw, the video of tadzik's talk was working up to 12 minutes in then the sound died completely :(

[21:19] <itz_> I was getting it after the first test of S09-typed-arrays/native.t but the system had little VM

[21:19] *** gfldex joined
[21:20] <itz_> in the sense of virtual memory inside a qemu instance

[21:21] *** LonelyGM joined
[21:22] <jnthn> itz_: Odd, here that tests runs in 1.1s.

[21:23] <jnthn> *test

[21:23] * jnthn builds latest just in case

[21:24] <jnthn> Nope, still good for me on latest.

[21:24] <LonelyGM> For loops dont consumes arrays do they

[21:26] <moritz> https://github.com/moritz/perlgeek.de/blob/master/source/blog-source-en/perl-6/2015-why-hard.txt blog post draft (for LonelyGM, among others :-)

[21:26] <moritz> feedback welcome

[21:26] <LonelyGM> Thx :))

[21:27] <LonelyGM> Gonna check when i get home, btw I think Larry is gonna be around soon ;)

[21:28] <vendethiel> moritz++

[21:29] *** xfix left
[21:30] *** LonelyGM left
[21:30] <vendethiel> moritz: "lated bound"

[21:30] <grondilu> Mouq: pre-GLR fail.  OK, noted.  Looking forward to this GLR thing.

[21:32] <Mouq> Oh, no the S09-typed-arrays/native.t runs fine. I had updated everything except Rakudo itself :B

[21:32] <Mouq> moritz++

[21:32] <Mouq> grondilu: Same :)

[21:32] * Mouq &

[21:32] *** Rounin left
[21:33] *** LonelyGM joined
[21:34] <moritz> vendethiel: fixed, thanks

[21:34] <itz_> jnthnL works fine on linux .. maybe some oddity of the platform

[21:34] <itz_> I will try again

[21:36] *** LonelyGM left
[21:37] <itz_> running that test on its own on NetBSD I see the same hang after 94 as Mouq on OS X

[21:41] *** raiph left
[21:43] * TimToady is around soon :)

[21:43] <itz_> hmmm I'll try deleting everything

[21:48] *** lichtkind_ joined
[21:49] <[Tux]> m: "19-*" ~~ m/^ (<[0..9]>+)["-"[(<[0..9]>+)||("*")]]? /;$0.say

[21:49] <camelia> rakudo-moar 9b295b: OUTPUT«｢19｣␤»

[21:49] <[Tux]> m: "19-*" ~~ m/^ (<[0..9]>+)["-"[(<[0..9]>+)||("*")]]? /;$0.perl.say

[21:49] <camelia> rakudo-moar 9b295b: OUTPUT«Match.new(orig => "19-*", from => 0, to => 2, ast => Any, list => ().list, hash => EnumMap.new())␤»

[21:50] <lizmat> jnthn: looking at array.pop/shift: is the die there because we return int, so that a fail will die for the wrong reason ?

[21:50] <[Tux]> how do I get 19 (not the Match) out of the match? There is no .value or something like that

[21:51] *** kjs_ left
[21:51] <TimToady> moritz: looks good

[21:51] <jnthn> lizmat: Correct

[21:52] <moritz> TimToady: thanks

[21:53] <jnthn> lizmat: It seemed like the sensible thing to do

[21:53] <lizmat> and I guess the return type is necessary to avoid boxing atm ?

[21:53] *** lichtkind left
[21:54] *** lichtkind_ left
[21:55] <jnthn> lizmat: Well, it does, but that is also the case because there's a good chance you may assign the value into a native int also

[21:55] <jnthn> m: sub foo() { fail "omg" }; my int $x = foo();

[21:55] <camelia> rakudo-moar 9b295b: OUTPUT«This type cannot unbox to a native integer␤  in block <unit> at /tmp/Z1X2vkmavu:1␤␤»

[21:55] <jnthn> And that is not so helpful to get :)

[21:55] <jnthn> Granted we'll eventually s/This type/Failure/

[21:56] <lizmat> is there a way to get at the value that cannot be unboxed to a native int?

[21:56] <lizmat> if so, then maybe we need to make that exception smarter ?

[21:56] <raydiak> m: "19-*" ~~ m/^ (<[0..9]>+)["-"[(<[0..9]>+)||("*")]]? /;$0.Str.say # [Tux] 

[21:56] <camelia> rakudo-moar 9b295b: OUTPUT«19␤»

[21:56] <lizmat> jnthn: aka, throw the Failure instead of the unbox failure

[21:57] <jnthn> That's quite a kettle of fish.

[21:58] <lizmat> ok, was just a thought

[21:59] <jnthn> Might be do-able

[21:59] <jnthn> But...hmm.

[21:59] <lizmat> then we wouldn't have to special case Failure in type checking

[21:59] <jnthn> Natives generally can't store undefineds, though.

[22:00] <lizmat> I'm not asking for that, just a better error message when it can't  :-)

[22:00] <vendethiel> m: use less memory;

[22:00] <jnthn> *nod*

[22:00] <camelia> rakudo-moar 9b295b: OUTPUT«===SORRY!===␤Cannot invoke this object (REPR: Null, cs = 0)␤»

[22:00] <lizmat> specially when the problem is storing an error message

[22:00] <vendethiel> nice.

[22:01] <vendethiel> this was the most random crash I ever encountered :D

[22:01] <lizmat> m: useless memory

[22:01] <camelia> rakudo-moar 9b295b: OUTPUT«5===SORRY!5=== Error while compiling /tmp/NlrfGn9a7m␤Undeclared routines:␤    memory used at line 1␤    useless used at line 1␤␤»

[22:01] <lizmat> :-)

[22:01] <itz_> S09-typed-arrays/native.t is fine .. I assume rakudobrew got confused

[22:01] <jnthn> vendethiel: Think I saw that one in RT already, though less amusingly stated. :)

[22:01] <vendethiel> Literally just going through https://github.com/perl6/perl6.org/commit/147f2fbceb, I saw "use less" in there, wanted to try it... Null!

[22:02] *** LonelyGM joined
[22:06] *** LonelyGM left
[22:08] *** anaeem1 left
[22:08] *** anaeem1__ joined
[22:09] *** sqirrel joined
[22:11] *** petercommand left
[22:12] *** petercommand joined
[22:24] *** LonelyGM joined
[22:28] *** LonelyGM left
[22:36] <dalek> rakudo/nom: 1ab902e | lizmat++ | src/core/Exception.pm:

[22:36] <dalek> rakudo/nom: Add X::Cannot::Infinite|Empty exceptions

[22:36] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/1ab902e3aa

[22:36] <dalek> rakudo/nom: 400a7e3 | lizmat++ | src/core/ (4 files):

[22:36] <dalek> rakudo/nom: Use typed exceptions for push/unshift/pop/shift

[22:36] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/400a7e35ac

[22:37] <lizmat> m: 1 ... ()  # test for this is now broken, will look at tomorrow

[22:37] <camelia> rakudo-moar 9b295b: OUTPUT«Unhandled exception: Element shifted from empty list␤   at <unknown>:1  (/home/camelia/rakudo-inst-1/languages/perl6/runtime/CORE.setting.moarvm:throw:4294967295)␤ from src/gen/m-CORE.setting:15694  (/home/camelia/rakudo-inst-1/languages/perl6/runtime/…»

[22:37] <lizmat> sleep&

[22:42] *** telex left
[22:48] *** LonelyGM joined
[22:49] <dalek> rakudo-star-daily: 8d95584 | coke++ | log/ (9 files):

[22:49] <dalek> rakudo-star-daily: today (automated commit)

[22:49] <dalek> rakudo-star-daily: review: https://github.com/coke/rakudo-star-daily/commit/8d95584690

[22:49] <dalek> perl6-roast-data: 22075ad | coke++ | / (9 files):

[22:49] <dalek> perl6-roast-data: today (automated commit)

[22:49] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/22075ad19d

[22:49] *** telex joined
[22:54] *** LonelyGM left
[22:55] *** telex left
[22:55] *** sqirrel left
[22:56] *** diana_olhovik_ left
[22:56] *** LonelyGM joined
[22:56] *** telex joined
[22:56] *** cognominal left
[22:58] <masak> 'night, #perl6

[22:58] <jnthn> o/ masak

[23:01] *** LonelyGM left
[23:01] *** telex left
[23:08] *** telex joined
[23:09] *** Akagi201_ left
[23:10] *** Ven joined
[23:10] *** Akagi201 joined
[23:14] *** telex left
[23:16] *** telex joined
[23:20] *** rurban left
[23:21] *** LonelyGM joined
[23:25] *** LonelyGM left
[23:25] *** Ven left
[23:44] *** anaeem1__ left
[23:44] *** anaeem1 joined
[23:48] *** anaeem1_ joined
[23:49] *** anaeem1 left
[23:52] *** anaeem1_ left
[23:57] *** mr-foobar joined
