[00:06] *** mr-foobar left
[00:13] *** Hor|zon joined
[00:17] <japhb> Well, there's already ecosystem fallout from TimToady's ~~ change: in particular, Debugger::UI::CommandLine will no longer compile

[00:17] *** Hor|zon left
[00:33] *** mr-foobar joined
[00:36] <AlexDaniel> m: say DateTime.new('1970-01-01T00:00:00').Instant;

[00:36] <camelia> rakudo-moar cf30a7: OUTPUT«Instant:10␤»

[00:36] <AlexDaniel> what's up with these 10 seconds?

[00:37] *** cognominal left
[00:43] <b2gills> .oO( how many leap seconds have there been )

[00:45] <AlexDaniel> b2gills: none?

[00:45] <AlexDaniel> b2gills: leap seconds were implemented in 1972, right?

[00:49] <b2gills> according to Wikipedia there were 9 from 1972-1979 https://en.wikipedia.org/wiki/Leap_second

[00:52] *** llfourn joined
[00:53] <AlexDaniel> b2gills: hm, how does that matter?

[00:56] <AlexDaniel> I mean, leap seconds should not affect stuff in the past, right?

[00:59] <dalek> roast: 29aa880 | skids++ | integration/error-reporting.t:

[00:59] <dalek> roast: Test error and presence of backtrace for return in mainline

[00:59] <dalek> roast: review: https://github.com/perl6/roast/commit/29aa8802da

[01:13] *** BenGoldberg joined
[01:18] *** vendethiel joined
[01:19] *** rmgk_ joined
[01:19] *** rmgk left
[01:19] *** rmgk_ is now known as rmgk

[01:27] *** rangerprice left
[01:29] *** llfourn left
[01:32] *** tinyblak joined
[01:33] *** tinyblak left
[01:34] *** tinyblak joined
[01:43] *** amurf joined
[02:05] <b2gills> Is there any way to bring the following sentence around to talking about multiple dispatch?  "Perl 6 like its brethren before it, likes to take ideas from other languages and tries to extend them as far as possible."

[02:13] *** Hor|zon joined
[02:18] *** Hor|zon left
[02:20] *** bjz joined
[02:31] *** cognominal joined
[02:32] <skids> "Perl 6, like its brethren before it, likes to take proven ideas from other languages, and type systems have shown themselves to offer compelling advantages in compiler-side code analysis and powerful user-side semantics via multiple dispatch."

[02:35] *** isBEKaml_ left
[02:38] *** JimmyZ_ left
[02:44] *** colomon left
[02:44] *** colomon joined
[02:47] <japhb> Proposal: No pushing incompatible changes *right* after a release.  Because then a point release will include the incompatible change.  Which happened today.

[02:57] *** noganex joined
[02:58] <colomon> Shouldn’t we be branching from the release tag to do a point release?

[02:59] *** noganex_ left
[03:10] <b2gills> m:m: multi example ( Int $ where 1 ){ say 1 }; multi example ( Int $ where 2 ){ say 2; samewith 1 }; multi example ( Int $ ){ say 3 }; example 2

[03:10] <b2gills> m: multi example ( Int $ where 1 ){ say 1 }; multi example ( Int $ where 2 ){ say 2; samewith 1 }; multi example ( Int $ ){ say 3 }; example 2

[03:10] <camelia> rakudo-moar cf30a7: OUTPUT«2␤1␤»

[03:10] <b2gills> m: multi example ( Int $ where 1 ){ say 1 }; multi example ( Int $ where 2 ){ say 2; nextwith 1 }; multi example ( Int $ ){ say 3 }; example 2

[03:10] <camelia> rakudo-moar cf30a7: OUTPUT«2␤3␤»

[03:10] <b2gills> skids++: thanks

[03:11] *** ggoebel left
[03:24] *** vendethiel left
[03:25] <b2gills> Let's see if my change stays on https://en.wikipedia.org/wiki/Multiple_dispatch#Perl_6

[03:29] <skids> b2gills++

[03:30] *** llfourn joined
[03:30] <b2gills> I had to mark the source as "perl" instead of "perl6" to get decent code highlighting

[03:34] *** itz_ joined
[03:35] *** cognominal left
[03:37] *** itz left
[03:37] *** tinyblak left
[03:38] *** tinyblak joined
[03:41] *** yqt left
[03:42] *** tinyblak left
[03:55] *** tinyblak joined
[03:56] *** gfldex left
[04:01] *** tinyblak left
[04:01] *** tinyblak joined
[04:04] *** eternaleye left
[04:04] *** konsolebox joined
[04:05] *** eternaleye joined
[04:06] *** tinyblak left
[04:12] *** TEttinger left
[04:14] *** Hor|zon joined
[04:19] *** Hor|zon left
[04:24] *** tinyblak joined
[04:26] <ugexe> more CLI-janitoring blog posting http://ugexe.com/create-a-perl6-terminal-progress-bar/

[04:59] *** khw left
[05:16] <[Coke]> in backscroll, I also would like consistency in naming. At least something that can be explained (this kind uses camelcase. This kind uses kebob. This has underscores. And the fewer the rules, the better.)

[05:17] <labster> m: my $x = 15;  $x.sprintf("%04d");

[05:17] <camelia> rakudo-moar cf30a7: OUTPUT«Directives specify 0 arguments, but 1 argument was supplied␤␤»

[05:17] <smls> m: my $x = 15;  say $x.fmt("%04d");

[05:17] <camelia> rakudo-moar cf30a7: OUTPUT«0015␤»

[05:18] <labster> ah, reverse, thanks.

[05:18] <[Coke]> (branching from release tag). yes. post birthday, I hope we pick a git branching strategy that avoids that problem.

[05:19] <labster> m: my $x = 15;  "%04d".sprintf($x);

[05:19] <camelia> rakudo-moar cf30a7: ( no output )

[05:20] *** tinyblak left
[05:21] <smls> branching strategy: How about a crazy one like the Qt project, with like 5 layers of branches for different levels of stability/release-proximity, and complicated rules backporting commits upwards/downwards :P

[05:22] <ShimmerFairy> [Coke]: As a semi-random first pick, how's about "Type names are CamelCase (native types camelCase), lower-case function/variable/etc. names are kebab-case, upper-case function/variable/etc. names are UNDERSCORE_CASE" ?

[05:23] <smls> except for that last one, that already seems to be the convention

[05:23] *** BenGoldberg left
[05:24] <ShimmerFairy> And internal/lower-level stuff stays purposefully deviant from whatever rules are picked :P

[05:24] <smls> it's just that not all (older?) names have been brought in line with it

[05:24] <AlexDaniel> even if there are lots of complicatd rules, these should be documented somewhere

[05:24] <AlexDaniel> e

[05:24] <smls> and in case of internal / MOP ones, jnthn might be right that it's not worth changing them

[05:25] <ShimmerFairy> smls: I like the idea that the more internal stuff has abnormal conventions; it'll make it feel weird if you find yourself using it :)

[05:25] <ShimmerFairy> .oO(Wait, why am I using is_type and AT-KEY ??)

[05:27] <smls> ShimmerFairy: At one point not too long ago, a whole bunch of UNDERSCORE_CASE uppercase methods were changed to KEBAP-CASE

[05:27] <smls> so I don't  think it's realistic to expect them to change in the opposite direction

[05:27] *** mr-foobar left
[05:27] <ShimmerFairy> smls: I'm well aware, and I will oppose the idiotic change to YELLING-KEBAB to the death :)

[05:29] * smls doesn't mind much either way

[05:35] <ShimmerFairy> I do think we need a set naming convention. Even if everyone else agrees on YELLING-KEBAB, at least then I can grumble at the set standard instead of at random unwarranted changes and deprecations :P

[05:36] *** mr-foobar joined
[05:57] * skids agrees about YELLING_KEBAB/thought the whole reason lc-kebab was popular was because you didn't have to toggle shift.

[05:57] <skids> erm, yeah see I didn't even manage to toggle shoft there :-)

[05:58] <skids> But what's done is done AFAIC.

[05:59] <ShimmerFairy> skids: yeah, after I got used to - in identifiers, I've basically treated _ as an uppercase - (that's even true, on a US keyboard: Shift+- -> _)

[06:01] <skids> I guess it is immune to capslock though.

[06:02] <skids> (a key which I should really retask to something even more useless since it is in the way so much)

[06:03] <ShimmerFairy> skids: Yeah, that's true, though since I always use shift and caps lock sits there dead that doesn't apply to me. (I remember one night translating a grammar to P6 grammar that had uppercase rule names, and having a sore pinky from holding shift by the end :P)

[06:05] *** AlexDaniel left
[06:05] <ShimmerFairy> I do find it really interesting how, in programming, _ basically _is_ a letter by now. Makes me wonder what kind of linguistic perspective you can put on the matter... :)

[06:15] *** domidumont joined
[06:15] *** Hor|zon joined
[06:19] *** domidumont left
[06:19] *** Woodi left
[06:20] *** Woodi joined
[06:20] *** domidumont joined
[06:20] <skids> Well it is basically a heirarchal space, on the other sideof space from , ; and … so my perspective is we crashed the linguistic stack.

[06:20] *** Hor|zon left
[06:21] <Woodi> hi #perl6 :)

[06:22] <ShimmerFairy> skids: I'm sure a linguistic study of programming languages would be quite interesting...

[06:22] * ShimmerFairy quickly glances over at TimToady

[06:23] <skids> o/ Woodi

[06:23] <ShimmerFairy> o/

[06:26] *** domidumont left
[06:29] *** jack_rabbit joined
[06:31] <Woodi> so what a lists, arrays, hashes, sets, etc. are ? categories, shapes, solids ?

[06:34] <Woodi> TimToady: maybe we want some positional in one direction "solid" ? prev positions can be forgetted. such distinction would allow to have simple array/lists implementation

[06:34] <Woodi> "streams" ?

[06:35] <skids> streams has too much association with characters/bytes.

[06:35] <Woodi> yes, but it's like river, you can't enter into same two times :)

[06:37] <smls> .tell masak You offered to discuss parsing binary blobs, right? I wrote down some thoughts on it here: https://gist.github.com/smls/bc5d0fb42f199574e339

[06:37] <yoleaux> smls: I'll pass your message to masak.

[06:41] <ShimmerFairy> smls: I've not yet read past the table of contents, but I thought I'd let you know that I've always thought it'd be better to design a binary parsing thing without worrying about how to cram it into the existing regex language. Not that it can't be done, but ignoring the suggestion that regexes should do it would likely open more possible solutions :)

[06:42] <smls> but also more reinventing of wheels I suspect

[06:42] *** TEttinger joined
[06:42] <smls> although yes, exploring other avenues would be interesting too

[06:43] <skids> Personally I think regex is very capable of the parse side of things, but the Grammar::Generative side of things and the memory management issues make write access a bit dodgy.

[06:44] <skids> If I were to pursue a different avenue it would be structured OO wih some MOP suger to make the REPRs handle thins like TLV fields and endianness nicely.

[06:45] <Woodi> Perl5 'pack's was nice for geting hunks of binary data, some "templates" could be standarized into \T form :)

[06:46] <ShimmerFairy> I'm not familiar with P5, but from what I've seen "pack" was a nice tool. Even though a lot of it can be done with other existing Perl 6 things, a more readable (and potentially expressive) form of its syntax would be something to consider.

[06:47] <Woodi> it's a bit like fread(3), it takes how much to read and how big each hunk is

[06:48] <ShimmerFairy> The regex modifiers like :bytes are pre-NFG I believe (and _definitely_ pre-S15), and part of the long-overdue changes I should've made ages ago :)

[06:48] <smls> at the very bottom of the gist, there's an example of how the regex-based thing could potentially be used as an 'unpack' alternative

[06:48] <smls> but that just covers 'unpack', not 'pack'

[06:50] <Woodi> yes, unpack have *more* sense with reading data :)

[06:51] *** skids left
[06:54] *** kaare_ joined
[06:59] *** gfldex joined
[07:03] <itz_> twitter++ # image caption "C++ The Good Parts", image K&R

[07:05] *** mr-foobar left
[07:07] <ShimmerFairy> smls: As a note, I don't envision the :bytes modifier existing much longer, as that comes from an earlier conception of how to do the different levels of Unicode in strings. (I expect :bytes to end up just like the Str.bytes method as seen in S32::Str, in other words)

[07:08] <smls> How do you think it will be handled then?

[07:08] <ShimmerFairy> smls: If regexes are still meant to handle binary parsing, I expect the adverb would be called :bin or :binary (like the :bin adverb in IO.open)

[07:09] *** [Tux] joined
[07:09] <smls> makes sense

[07:09] <ShimmerFairy> A more general name like :bin would incidentally not restrict you to 8-bit (or more generally 1-byte) units of data, as a bonus :)

[07:12] *** darutoko joined
[07:14] <ShimmerFairy> smls: I actually like the rule for handling Pairs. It sounds weird at first but it quickly reminds one of tr/// (if not outright is tr///)

[07:15] <smls> is was somewhat inspired by http://doc.perl6.org/routine/rotor :)

[07:16] <smls> But those details are not important; I just tried to develop *one* possible API for it, to bring to light potential edge cases / problems

[07:16] <ShimmerFairy> If I could come with a binary equivalent for the word "grammar" ("grammar" is to "text parsing" as ??? is to "bit/byte/* parsing"), I'd suggest using it as a keyword for the binary version of grammars :P

[07:18] <ShimmerFairy> *come up with

[07:20] *** RabidGravy joined
[07:22] *** bjz left
[07:31] *** Hor|zon joined
[07:36] *** Hor|zon left
[07:42] <Woodi> ShimmerFairy: I was thinking: it could be somename from electronics but only found that that damn they have 40Gb/s network in 40km cables!

[07:43] *** brrt joined
[07:43] <Woodi> over here 2km from "cental" ppls do not pay for internet via cable...

[07:45] <brrt> \o

[07:46] *** smls left
[07:48] *** bin_005 left
[07:49] *** bin_005 joined
[07:51] <Woodi> hi brrt 

[07:52] <brrt> fwiw, the algorithm i needed looks like this https://gist.github.com/anonymous/19228f32eaf1fb4c6802

[07:52] <brrt> i need it to generate all rulesets possible for a given rule head

[07:53] <brrt> i.e. all states in the state machine

[07:53] <RabidGravy> morning

[07:53] <brrt> morning Woodi, RabidGravy

[07:53] <RabidGravy> Rarr!

[07:56] * brrt likes how you can write perl (5) code like it's C or scheme or anything-you-like

[08:01] <RabidGravy> dear c++, I hate you : "no known conversion for argument 1 from ‘const SAMPLETYPE* {aka const short int*}’ to ‘const SAMPLETYPE* {aka const float*}’"

[08:01] <RabidGravy> how? how does it even think that?

[08:04] <ShimmerFairy> unions?

[08:04] *** Averna joined
[08:11] *** brrt left
[08:11] <RabidGravy> it's a method with a single argument which is an array the type of which is supposed to be in the SAMPLETYPE define, this is set in the includes

[08:14] *** kaare__ joined
[08:15] *** kaare_ left
[08:17] <cdc> ugexe++ # bloging

[08:22] <cdc> smls++ # bloging (in a gist)

[08:25] *** telex left
[08:26] *** telex joined
[08:27] *** brrt joined
[08:41] *** vendethiel joined
[08:47] *** brrt left
[08:47] *** ShimmerFairy joined
[08:47] *** espadrine_ joined
[08:54] *** mr-foobar joined
[09:01] <RabidGravy> gave in and manually added the appropriate typedef, which is odd as the include file is supposed to do it

[09:03] <[ptc]> m: class A { has $.a }; say A.new(a => 5) eqv A.new(a => 5);

[09:03] <[ptc]> botsnack

[09:03] <[ptc]> hi everyone :-)

[09:04] <[ptc]> where have all the bots gone?

[09:04] <moritz> .tell masak the rakudo+nqp 2015.07.1 releases don't work for a star release: "The nqp-m binary is too old" (probably due to the missed version bumb

[09:04] <yoleaux> moritz: I'll pass your message to masak.

[09:04] <moritz> \o [ptc]; humansnack

[09:04] *** dalek left
[09:04] *** dalek joined
[09:04] *** ChanServ sets mode: +v dalek

[09:04] <camelia> rakudo-moar cf30a7: OUTPUT«False␤»

[09:04] <synbot6> om nom nom

[09:04] <[ptc]> moritz: om nom nom

[09:05] <[ptc]> moritz: thanks!

[09:05] <[ptc]> does anyone know why class A { has $.a }; say A.new(a => 5) eqv A.new(a => 5);  returns False?  One would think that the two objects would be equivalent

[09:05] <moritz> [ptc]: because the fallback for eqv is ===

[09:06] <[ptc]> ... and if there isn't a way to canonically compare the objects, then === is used?

[09:07] *** bjz joined
[09:07] <moritz> well, currently it's just a bunch of multis

[09:07] <moritz> and the Any, Any multi uses ===

[09:08] <[ptc]> shouldn't fall back to something along the lines of comparing the equivalence of the .perl of the two objects?

[09:08] <moritz> and there more specialized variants for "interesting" types

[09:08] <moritz> [ptc]: well, .perl omits private attributes

[09:09] <moritz> m: class B { has $!a; submethod BUILD(:$a!) { } }; say B.new(a => 1).perl eq B.new(a => 2).perl

[09:09] <camelia> rakudo-moar cf30a7: OUTPUT«True␤»

[09:09] * [ptc] is now really confused

[09:10] <[ptc]> why are two objects which have different contents now equal?

[09:10] <[ptc]> m: class B { has $!a; submethod BUILD(:$a!) { } }; say B.new(a => 1).perl eqv B.new(a => 2).perl

[09:10] <camelia> rakudo-moar cf30a7: OUTPUT«True␤»

[09:10] <moritz> I never said the objects are equal

[09:10] <moritz> just their .perl output

[09:10] <[ptc]> ah

[09:10] <moritz> and .perl omits private attributes, becuase in general, you can't initialize them by passing them to .new anyway

[09:10] <moritz> and to not break encapsulation

[09:11] <moritz> so it'd be kinda dangerous to use .perl for eqv semantics

[09:11] <[ptc]> ok.  That makes sense

[09:12] <[ptc]> am trying to understand what's going on in order to make the docs for eqv a bit clearer

[09:12] *** bjz left
[09:13] <moritz> other languages have the concept of "hashable"

[09:13] <moritz> and you can only use stuff as hash keys or for eqv comparisons if they are hashable

[09:14] <[ptc]> ok.  that makes sense too

[09:14] <moritz> I'd very much like Perl 6 to take that route

[09:15] <[ptc]> so is there an easy way to explain why two instances of `class A { has $.a };` each instantiated with the same value don't evaluate as being equivalent?  I know you said eqv falls back to ===, but I'm not 100% clear about all implications of what that means

[09:16] <Woodi> hash works like separate guid in every object or as hash function result from object ?

[09:17] <Woodi> or some attributes equality ?

[09:17] <ShimmerFairy> I forget if there was a better method, but I _think_ you have to implement a new infix:<eqv> multi to have a working eqv (like e.g.  multi infix:<eqv>(A $l, A $r) { $l.a eqv $r.a }  )

[09:17] <[ptc]> or is it simply not possible to compare objects?  And that eqv is best thought of when one compares basic data structures such as hashes, lists etc?

[09:17] *** bjz joined
[09:18] <ShimmerFairy> "working" as in "not a synonym for ==="

[09:18] <Woodi> eg. if you cache objects you want sometimes to compare them

[09:18] <[ptc]> ShimmerFairy: right, ok.  Now I just need to work out how to explain that that doesn't come "out of the box"

[09:19] <Woodi> [ptc]: there is few way to compare, wrote about one implemented :)

[09:20] *** bjz left
[09:20] *** mr-foobar left
[09:20] <[ptc]> Woodi: really?  where did you write about it?

[09:20] <[ptc]> Woodi: do you have a link?

[09:20] <ShimmerFairy> [ptc]: I'd guess because it's too hard for a compiler to determine the best way to compare objects (e.g. do you compare private attributes? Are they always to be compared? What if some public attributes don't matter? What if equivalence for the object is more complex?)

[09:20] *** mr-foobar joined
[09:20] <Woodi> no, my English is too bad ;)

[09:21] <[ptc]> Woodi: that's ok! :-)

[09:21] <[ptc]> ShimmerFairy: true.  That's probably the best way to explain things

[09:21] <[ptc]> it just needs to be noted in the docs, so that it doesn't trip up others in the future

[09:22] * [ptc] starts hacking the docs again

[09:22] *** brrt joined
[09:23] *** Begi joined
[09:23] <ShimmerFairy> moritz: I think I'd like a hashable concept (though not with that name, I think it gives off the wrong connotation wrt %hashes). I like how smartmatch can be extended by implementing your own ACCEPTS method, and I'd like the same for  eqv  and other builtin ops.

[09:23] <[ptc]> thanks everyone for the explanations :-)

[09:23] <masak> good antenoon, #perl6

[09:23] <yoleaux> 06:37Z <smls> masak: You offered to discuss parsing binary blobs, right? I wrote down some thoughts on it here: https://gist.github.com/smls/bc5d0fb42f199574e339

[09:23] <yoleaux> 09:04Z <moritz> masak: the rakudo+nqp 2015.07.1 releases don't work for a star release: "The nqp-m binary is too old" (probably due to the missed version bumb

[09:24] <masak> moritz: aww

[09:24] <masak> that sounds like cause for a 2015.07.2, then.

[09:25] <jdv79> that eqv fallsback to === seems like a bug

[09:26] <jdv79> === is not a "snapshot" cmp 

[09:26] <jdv79> maybe kick an exception if snapshotting is not possible?

[09:26] <jdv79> or somehow fix that it is possible in some generic default way

[09:27] <jdv79> just my naive take

[09:27] <ShimmerFairy> Also, you _can_ define your own === behavior by defining your own WHICH. Seems only fair for  eqv  to get a method too

[09:27] <jdv79> my main point is that the definition of eqv is not === so why the link?

[09:27] <jdv79> super confusing for newbies i'd think

[09:28] <moritz> jdv79: what would you do instead? die with "Cannot compare two objects of type $typename"?

[09:29] <ShimmerFairy> jdv79: I'm guessing the idea is that === is the most basic and only guaranteed way of checking if two objects of a type are the same. Non-fallback 'eqv' defines a more human comparison of objects (though not as human as ~~)

[09:29] <jdv79> that's lame but better than a snapshot comp all of the sudden becoming and ident cmp.  how does that even make sense?

[09:30] <jdv79> unless you really want to explain that in here 10 million times;)

[09:31] <Woodi> for me basic equality is if objects *are* the same memory location...

[09:31] <Woodi> maybe not only...

[09:31] <Woodi> probably identity is not the same as equality...

[09:32] * Woodi afks

[09:32] *** Hor|zon joined
[09:33] <ShimmerFairy> I notice that current C<eqv> does effectively a P6 version of C<===>'s NQP-based implementation. It'd be nice if eqv compared on a different method than .WHICH :)

[09:34] <jdv79> ShimmerFairy: that's not the ways its spec'd

[09:34] <jdv79> *way =

[09:36] <ShimmerFairy> S03 says on eqv: For object types, compares current contents according to some scheme of canonicalization.

[09:36] <ShimmerFairy> I'm sure you could argue .WHICH to be some scheme of canonicalization, though in my opinion a poor one.

[09:37] *** Hor|zon left
[09:38] <jdv79> yeah.  if this goes out for 6.0 then not sure you could ever change it.  that's one concern maybe.

[09:38] <dalek> doc: 4c57c15 | paultcochrane++ | lib/Language/operators.pod:

[09:38] <dalek> doc: Explain that eqv doesn't work for arbitrary objects

[09:38] <dalek> doc: 

[09:38] <dalek> doc: And add a note about how to implement `eqv` if one needs this behaviour.

[09:38] <dalek> doc: This should address the issue raised in #81.

[09:38] <dalek> doc: review: https://github.com/perl6/doc/commit/4c57c157e4

[09:38] <jdv79> but time constraints i guess

[09:39] <ShimmerFairy> moritz: considering S03 calls it "canonical equivalence", how about a multi method CANONICAL() for eqv ? (You could even define the default CANONICAL to just return WHICH, if there's not a better choice of default)

[09:40] <[ptc]> jdv79: I'm guessing perl6/doc #81 is your ticket?

[09:41] <moritz> ShimmerFairy: manybe

[09:41] <jdv79> i knew the issue sounded familiar

[09:42] * [ptc] feels he understands the issue a bit better now

[09:42] <jdv79> i was hoping for a lang fix - i think TimToady mentioned it might warrant attention if it was avail

[09:43] <jdv79> thanks 

[09:43] *** diana_olhovik_ joined
[09:43] <[ptc]> jdv79: if the explanation in the docs is still not clear, let me know and I'll try and improve it as best I can

[09:44] <jdv79> i have to run but i'll look later

[09:44] <ShimmerFairy> yeah, I personally think it'd be helpful for many, if not all of the "complex" comparison ops to call a particular method on the object. That would make it easier to support them, I think. (Esp. if you need to compare private attributes or something similarly better off within the class)

[09:44] <[ptc]> jdv79: ok

[09:45] <masak> ShimmerFairy: what you're suggesting will late-bind (and pessimise) everything, though.

[09:45] <jdv79> even a recursive ident cmp would be better to me than just a single top level ===

[09:46] <ShimmerFairy> masak: well, ~~ uses ACCEPTS and === uses WHICH (as well as eqv, currently). What would be different about adding CANONICAL?

[09:46] <moritz> masak: fwiw you could still export infix:<eqv> multis for your types

[09:49] <masak> smls: https://gist.github.com/smls/bc5d0fb42f199574e339 looks great.

[09:51] <vendethiel> ShimmerFairy: what's supposed to be the diff. between CANONICAL and WHICH?

[09:51] <vendethiel> value vs reference equality?

[09:52] <ShimmerFairy> vendethiel:  A.new(5) eqv A.new(5)  should be true, while  A.new(5) === A.new(5)   typically shouldn't be

[09:52] *** bjz joined
[09:52] <vendethiel> yeah, right.

[09:52] <vendethiel> seems like "class" vs "data class" in 

[09:52] <vendethiel> Scala, say*.

[09:52] <ShimmerFairy> m: say [1,2,3] === [1,2,3]; say [1,2,3] eqv [1,2,3]  # easy example

[09:52] <camelia> rakudo-moar cf30a7: OUTPUT«False␤True␤»

[09:53] * vendethiel would prefer structural equality everywhere anyway :P

[09:53] <masak> won't CANONICAL just end up being Perl 6's hashCode method?

[09:53] <ShimmerFairy> What hashCode method?

[09:54] <masak> of Java fame.

[09:55] <masak> hashCode is used to hash things for HashMap entries.

[09:55] <masak> or hash() from Python, same thing.

[09:55] <ShimmerFairy> there's no hashCode in src/core

[09:55] <masak> I guess what I mean is, how do you envision implementing a typical CANONICAL method? it will have to do recursive CANONICAL calls on any elements/members the object has, yes?

[09:56] <masak> and you combine all those results in some clever way to make one entire CANONICAL result, yes?

[09:56] <vendethiel> masak: isn't hashCode our WHICH, kinda?

[09:56] * vendethiel thinks he wouldn't like to have both WHICH and CANONICAL, mmh..

[09:56] <masak> vendethiel: modulo that we haven't gotten it quite right yet, yes.

[09:57] <ShimmerFairy> masak: That's how I imagine it'd be done. I think I just don't like much how 'eqv' will do the wrong thing by default, though admittedly CANONICAL probably wouldn't help that much :)

[09:57] <masak> by the way, I would prepare a 2015.07.2 release, but I'm a little afraid I'll mess it up again :(

[09:57] *** rindolf joined
[09:58] <brrt> no, WHICH is equal to id() in python iirc

[09:58] <masak> brrt: WHICH tries to do the job both for reference types and value types presently.

[09:58] <brrt> aha

[09:58] <dalek> doc: a6dbcf1 | paultcochrane++ | lib/Type/Cool.pod:

[09:58] <dalek> doc: Mention line-by-line processing in Cool.lines()

[09:58] <dalek> doc: 

[09:58] <dalek> doc: This addresses the point made in #83.

[09:58] <dalek> doc: review: https://github.com/perl6/doc/commit/a6dbcf16bc

[09:58] <ShimmerFairy> masak: I just think it's LTA that by default something like  CustomInt.new(42) eqv CustomInt.new(42)  would return False.

[09:59] <masak> ShimmerFairy: I don't think that's unreasonable, though.

[09:59] <masak> ShimmerFairy: just like you can't auto-deliver deep cloning because you don't know enough about the insides of the user's objects, you also can't auto-deliver eqv.

[10:00] <masak> ShimmerFairy: conceptually, it means that a new class is a black box until its implementor decides otherwise. which feels like a fair/safe deal to me.

[10:01] <ShimmerFairy> m: class A { has $.b }; say A.new(:b(42)) === A.new(:b(42)); say A.new(:b(42)) eqv A.new(:b(42)); say A.new(:b(42)) ~~ A.new(:b(42));

[10:01] <camelia> rakudo-moar cf30a7: OUTPUT«False␤False␤False␤»

[10:01] <ShimmerFairy> masak: I can see that, but it feels like an abnormally low-level thing for Perl 6 to do. Like with the above snippet I ran, I can't help but feel that _at least_ ~~ shouldn't force you to implement something to work right.

[10:02] *** TEttinger left
[10:02] <masak> I think defaulting to descending into the user's object isn't a good default.

[10:03] <ShimmerFairy> And I just realized I could probably use your opinion to argue against a default BUILD, if I felt like trying :P

[10:03] <masak> I don't see how my argument applies to that. deep cloning and eqv are *recursive* in nature.

[10:04] <masak> they traverse an object graph, which has all kinds of interesting issues. (cycles being one)

[10:04] <masak> BUILD happens once and touches one object.

[10:04] <ShimmerFairy> What about the attributes that need to be constructed? Which have attributes that need to be constructed? Which...  is that not recursive in the same sort of way?

[10:04] <masak> ShimmerFairy: answer me this: would your default implementation of eqv for custom objects (a) blow the stack on cycles in the object graph, or (b) be very complicated?

[10:05] <ShimmerFairy> I honestly can't answer that, because I have zero clue what (a) is saying.

[10:06] <masak> structurally the choice feels a bit like the choice we're making for `is readonly` for parameters to routines.

[10:06] <ShimmerFairy> masak: I think the current behavior is acceptable, just weirdly low-level for something like P6. It'd be nice if it weren't so, in my opinion.

[10:06] <vendethiel> masak:...my opinion on that is that I'd love a "data class" macro that generates WHICH and al

[10:06] <masak> that is, we're making the safe/boring choice, because people who care will override it in one of the many possible ways anyway.

[10:06] <masak> and people who don't care will get the safe/boring choice.

[10:06] <masak> vendethiel: sounds fine to me.

[10:07] * masak adds that to his ever-growing list of use cases

[10:07] <ShimmerFairy> I'd argue that it's safe, boring, and highly inaccurate :P

[10:07] <RabidGravy> also, I'd suggest the determination whether two objects are actually equivalent things is properly application logic

[10:07] <masak> RabidGravy: that, too.

[10:08] <masak> ShimmerFairy: I'm arguing that you want too much magic, in this case, and you seem unaware of the risks of that.

[10:09] <ShimmerFairy> masak: On the one hand I do see how it's too magical for the compiler to do automatically. On the other hand I get the feeling that there will be a lot of basically the same definitions of  eqv  and the like as it stands, which feels unfortunate.

[10:09] <vendethiel> ShimmerFairy: I think I can write a MOP trait that auto-generates it :)

[10:10] <ShimmerFairy> But I don't think you can dispute that it's highly inaccurate for an operator labeled as "canonical equivalence" to think that, by default, canonical equivalence only occurs when you have the exact same object.

[10:11] <masak> I think that's a good, safe default.

[10:12] <RabidGravy> but it's documented like that.  "For arbitrary objects this is not possible with the default eqv operator. E.g., eqv will not consider two instances of the same object as being structurally equivalent:"

[10:12] <masak> I don't dispute that it will be wrong in many cases. that's why we allow eqv to be overridden.

[10:12] <ShimmerFairy> RabidGravy: in the doc, or the specs?

[10:12] <RabidGravy> the doc

[10:13] <ShimmerFairy> RabidGravy: that's just describing current behavior. I tend to check the specs for how things should be. (S03 leaves it up to the compiler to decide how "object types" are compared canonically)

[10:15] <RabidGravy> but "structural equivalence" is only something that the implementor of a class can decide, having an overly clever default for arbitrary objects would almost certainly be wrong for a lot of people

[10:15] <ShimmerFairy> masak: An analogy I came up with to describe how I see it would be a default implementation of multiplication as  multi sub infix:<*>($a, $b) { 0 }  . It's sure true for an infinite number of cases, but it's wrong for an infinite number of cases too. Hence inaccurate.

[10:15] <vendethiel> not sure how I can introspect a class' attributes, looking at ClassHOW

[10:15] <vendethiel> I should look at AttributeContainer I guess

[10:16] <masak> ShimmerFairy: multiplication also doesn't have to tackle the problem of cycles in the graph and un-canonicalizable objects in the general case.

[10:16] <ShimmerFairy> masak: Like I said, I'm OK with how things stand, I just personally think it's LTA. Not that I think there's a clean or easy solution, I just think it's LTA. :)

[10:16] <masak> ShimmerFairy: your analogies keep being compelling only to the extent that they fail to see the depth of the problem.

[10:17] <ShimmerFairy> masak: I didn't claim it was an analogy for how I see the problem, just to show in a more simple form why I call it "inaccurate"

[10:17] <masak> ShimmerFairy: I don't like us providing a default that essentially enables very bad failure modes.

[10:17] <ShimmerFairy> (Although looking back I don't think I made that clear.)

[10:17] <masak> ShimmerFairy: I prefer the implementor of the class to *stop* and *think* in those cases, as they provide their own implementation.

[10:18] <ShimmerFairy> masak: I see something like <eqv> as being in the unfortunate middle area where the compiler can't automatically pick a very good default, but a lot of people will write essentially the same code when overriding it.

[10:19] <masak> vendethiel is right -- we should use the MOP and macros to ameliorate that.

[10:19] <masak> not dangerous defaults.

[10:19] <vendethiel> m: multi trait_mod:<is>(Mu:U $type, :$data!){ say $type.attributes; say 1 }; class X is data { has $.a; }; say X.WHAT.perl

[10:19] <camelia> rakudo-moar cf30a7: OUTPUT«X␤»

[10:19] <vendethiel> I'm not sure why my multi isn't picked up?

[10:20] <masak> m: class X is data {}

[10:20] <camelia> rakudo-moar cf30a7: ( no output )

[10:20] <moritz> m: class X is nosuchtrait { }

[10:20] <camelia> rakudo-moar cf30a7: ( no output )

[10:20] <masak> m: class X is aloogabooga {}

[10:20] <camelia> rakudo-moar cf30a7: ( no output )

[10:20] <moritz> bug!

[10:20] <vendethiel> uh.

[10:20] * masak submits it

[10:20] <vendethiel> well, seems like I found something.

[10:23] <masak> m: class C is aloogabooga {}

[10:23] <camelia> rakudo-moar cf30a7: OUTPUT«5===SORRY!5=== Error while compiling /tmp/UXeCmKzq6m␤'C' cannot inherit from 'aloogabooga' because it is unknown.␤at /tmp/UXeCmKzq6m:1␤»

[10:23] <masak> hah!

[10:23] <masak> this time I caught it before hitting "Send" :P

[10:23] <masak> people, do *not* use `X` as the name of an "example class" when testing things on camelia.

[10:24] <masak> use `A` or `C` or some other letter early in the alphabet.

[10:24] <masak> I'm still going to submit this, because *something* is wrong, clearly.

[10:24] <masak> but it involves using `X`.

[10:24] <vendethiel> not sure where "is repr" is defined for nativecall? in rakudo?

[10:25] <vendethiel> m: multi trait_mod:<is>(Mu:U $type, :$data!){ say $type.attributes; say 1 }; class Foo is data { has $.a; }; say Foo.WHAT.perl

[10:25] <camelia> rakudo-moar cf30a7: OUTPUT«5===SORRY!5=== Error while compiling /tmp/swQ_emSAPp␤Method 'attributes' not found for invocant of class 'Foo'␤at /tmp/swQ_emSAPp:1␤»

[10:25] <vendethiel> m: multi trait_mod:<is>(Mu:U $type, :$data!){ say $type.^attributes; say 1 }; class Foo is data { has $.a; }; say Foo.WHAT.perl

[10:25] <camelia> rakudo-moar cf30a7: OUTPUT«␤1␤Foo␤»

[10:27] <vendethiel> I guess that's too early

[10:28] *** llfourn left
[10:29] <masak> it happens right as it parses it, so yes.

[10:30] <ShimmerFairy> I was envisioning some kind of DATAMETHODS() macro that you put in the class, that would supply the appropriate methods, but I'm not sure how possible/sane that is.

[10:31] *** TEttinger joined
[10:38] <Woodi> so object equality is about objec value... if two cars in some point of time drive 100km/h and in that moment we compare them then do they are equal ?

[10:39] <masak> Woodi: it's useful to distinguish "reference comparison" and "value comparison" for exactly that reason.

[10:40] <masak> Woodi: entity objects tend to very much want to do reference comparison.

[10:40] <masak> Woodi: (at least until you start doing things like serialization, at which point you probably want to abandon comparing the object system's reference, and instead compare something like an id attribute)

[10:41] <Woodi> I hoped we could implement default comparision based on plain attributes like strings and numbers

[10:41] *** brrt left
[10:42] <masak> I see there is a great temptation today to provide this dangerous default :)

[10:42] <masak> Woodi: and it's surprising you say that after giving your example with two cars.

[10:43] <masak> since two cars with the same driving speed are *not* necessarily the same car.

[10:43] <Woodi> masak: there is moritz++ question :) : do you want to say: Can't compare two object of class "Cls". so looking for default thing for simple situations

[10:44] <masak> I don't want us to add a default that only works in "simple situations".

[10:44] <vendethiel> m: class Foo{}; class Foo is bar {};

[10:44] <camelia> rakudo-moar cf30a7: OUTPUT«5===SORRY!5=== Error while compiling /tmp/lY0VVmXPMR␤Redeclaration of symbol Foo␤at /tmp/lY0VVmXPMR:1␤------> 3class Foo{}; class Foo is bar7⏏5 {};␤»

[10:44] <vendethiel> m: class List is bar {};

[10:44] <camelia> rakudo-moar cf30a7: OUTPUT«5===SORRY!5=== Error while compiling /tmp/Ft8f95oemx␤'List' cannot inherit from 'bar' because it is unknown.␤at /tmp/Ft8f95oemx:1␤»

[10:44] <masak> that would be like looking at half the problem and saying "eeh, good enough".

[10:44] <vendethiel> m: module Foo {}; class Foo is bar {};

[10:45] <camelia> rakudo-moar cf30a7: OUTPUT«5===SORRY!5=== Error while compiling /tmp/OqSAraPlMk␤Redeclaration of symbol Foo␤at /tmp/OqSAraPlMk:1␤------> 3module Foo {}; class Foo is bar7⏏5 {};␤»

[10:45] <vendethiel> X is *really* special

[10:45] <vendethiel> .oO( Xspecial )

[10:45] <masak> m: say X.HOW

[10:45] <camelia> rakudo-moar cf30a7: OUTPUT«Perl6::Metamodel::PackageHOW.new␤»

[10:45] <masak> vendethiel: that's why, I think.

[10:45] <vendethiel> m: package Foo {}; class Foo is bar {};

[10:45] <camelia> rakudo-moar cf30a7: OUTPUT«5===SORRY!5=== Error while compiling /tmp/XzvcBngaPs␤'Foo' cannot inherit from 'bar' because it is unknown.␤at /tmp/XzvcBngaPs:1␤»

[10:45] <vendethiel> masak: why isn't this silent then?

[10:46] <masak> m: package Foo::Yay {}; class Foo is bar {}

[10:46] <camelia> rakudo-moar cf30a7: OUTPUT«5===SORRY!5=== Error while compiling /tmp/4818O_LhZd␤'Foo' cannot inherit from 'bar' because it is unknown.␤at /tmp/4818O_LhZd:1␤»

[10:46] <masak> vendethiel: no idea.

[10:54] <jnthn> X is the package where all the exceptions live.

[10:55] <masak> jnthn: yes, but people seem to forget that when testing something on camelia.

[10:55] <jnthn> masak: They seem to be quickly reminded :P

[10:55] <vendethiel> I sure as hell always do. :)

[10:56] <jnthn> masak: I actually patched the compiler to only look for errors it throws in SETTING:: a while ago

[10:56] <masak> jnthn: not always. there are a couple of RT tickets filed because people didn't realize.

[10:56] <jnthn> masak: They realized something was wrong enough to file an RT :P

[10:57] <masak> troo

[10:57] <jnthn> I'm not sure what we can easily do about it.

[10:57] <jnthn> Getting the compiler to only look for compile-time exceptions in the setting rather than anything the user has declared got rid of one set of ways to get confused.

[10:57] <jnthn> m: class X { }; omg wtf bbq

[10:57] <camelia> rakudo-moar cf30a7: OUTPUT«5===SORRY!5=== Error while compiling /tmp/er6FsXMftg␤Undeclared routines:␤    bbq used at line 1␤    omg used at line 1␤    wtf used at line 1␤␤»

[10:58] <jnthn> star: class X { }; omg wtf bbq

[10:58] <camelia> star-m 2015.03: OUTPUT«===SORRY!===␤Error while compiling, type X::Undeclared::Symbols␤  post_types: (unstringifiable object)␤  unk_types: (unstringifiable object)␤  unk_routines: (unstringifiable object)␤  routine_suggestion: (unstringifiable object)␤  type_suggestion: …»

[10:58] <jnthn> Which fixed things like htat

[10:58] <jnthn> m: class X { }; omg wtf!!!

[10:58] <camelia> rakudo-moar cf30a7: OUTPUT«5===SORRY!5=== Error while compiling /tmp/QZ8ZMX_K9X␤Bogus postfix␤at /tmp/QZ8ZMX_K9X:1␤------> 3class X { }; omg wtf7⏏5!!!␤    expecting any of:␤        infix␤        infix stopper␤        postfix␤        statement end␤        …»

[10:58] <jnthn> star: class X { }; omg wtf!!!

[10:58] <camelia> star-m 2015.03: OUTPUT«===SORRY!===␤Error while compiling, type X::Syntax::Confused␤  reason: Confused␤ at line 2, near "!!!"␤Error while constructing error object:Could not locate compile-time value for symbol Syntax::Confused␤»

[10:58] <jnthn> That's a better example.

[10:58] <masak> heh. "confused. reason: confused" :P

[10:58] <jnthn> It'd be good to see if any other the other RTs about it are covered by the fix I already did.

[11:02] <jnthn> On the eqv default thing and avoiding a dangerous-but-tempting result, I agree with masak++

[11:02] <jnthn> uh, s/result/default/

[11:03] <ShimmerFairy> m: package S { }; class S is foobar { }

[11:03] <camelia> rakudo-moar cf30a7: OUTPUT«5===SORRY!5=== Error while compiling /tmp/hTH67oTftq␤'S' cannot inherit from 'foobar' because it is unknown.␤at /tmp/hTH67oTftq:1␤»

[11:03] <ShimmerFairy> ^ only doesn't error with the "X" package, AFAICT

[11:09] *** rindolf left
[11:09] *** darutoko left
[11:09] *** darutoko joined
[11:11] <dalek> doc: 12b62f0 | paultcochrane++ | lib/Language/functions.pod:

[11:11] <dalek> doc: Indent subroutine example code consistently with rest of text

[11:11] <dalek> doc: review: https://github.com/perl6/doc/commit/12b62f0eb5

[11:11] <dalek> doc: a34c050 | paultcochrane++ | lib/ (2 files):

[11:11] <dalek> doc: Indent IO.lines examples consistently

[11:11] <dalek> doc: review: https://github.com/perl6/doc/commit/a34c050c21

[11:11] *** TEttinger left
[11:11] *** jack_rabbit left
[11:13] *** lizmat left
[11:15] *** yakudza left
[11:15] *** rindolf joined
[11:16] *** itz joined
[11:17] *** llfourn joined
[11:19] *** itz_ left
[11:20] <dalek> doc: a404865 | paultcochrane++ | lib/Type/IO/ArgFiles.pm:

[11:20] <dalek> doc: Add docs for IO::ArgFiles

[11:20] <dalek> doc: review: https://github.com/perl6/doc/commit/a404865bce

[11:28] *** mr-foobar left
[11:29] *** mr-foobar joined
[11:33] *** Hor|zon joined
[11:37] *** Hor|zon left
[11:44] *** araujo left
[11:46] *** Alina-malina left
[12:00] *** Averna left
[12:14] *** bin_005 left
[12:17] *** AlexDaniel joined
[12:21] *** colomon left
[12:29] *** diana_olhovik_ left
[12:34] *** Hor|zon joined
[12:38] *** Hor|zon left
[12:39] <RabidGravy> If I wrap a C++ class to make a C interface so I can use it with NativeCall and one of the underlying methods throws an exception, that exception can't be cauught in perl space can it?

[12:43] <jnthn> RabidGravy: No, that's required quite some magic. Maybe FROGGS++'s nativecall C++ work will be able to do that at some point

[12:43] <jnthn> But it's probably highly non-trivial

[12:52] <RabidGravy> yeah that's what I thought,  liberally sprinkly try catch all over the place then

[13:10] *** Alina-malina joined
[13:21] *** rindolf left
[13:23] *** rindolf joined
[13:38] <moritz> masak: are you doing the .2 releases, or should I?

[13:47] *** lizmat joined
[13:50] *** rindolf left
[13:52] *** llfourn left
[13:53] *** FROGGS_ joined
[13:57] *** FROGGS left
[14:00] <dalek> nqp: a4fcfa7 | moritz++ | VERSION:

[14:00] <dalek> nqp: Version 2015.07.2

[14:00] <dalek> nqp: 

[14:00] <dalek> nqp: this time with the correct VERSION number

[14:00] <dalek> nqp: review: https://github.com/perl6/nqp/commit/a4fcfa7b66

[14:08] *** rindolf joined
[14:10] *** Mhoram left
[14:11] *** Mhoram joined
[14:14] *** lucasb joined
[14:16] *** llfourn joined
[14:18] *** vendethiel left
[14:25] *** JimmyZ_ joined
[14:26] *** cognominal joined
[14:27] *** brrt joined
[14:35] *** Hor|zon joined
[14:37] <dalek> rakudo/nom: 42a3314 | moritz++ | / (2 files):

[14:37] <dalek> rakudo/nom: Bump NQP revision and VERSION to 2015.07.2

[14:37] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/42a3314efb

[14:37] <dalek> rakudo/nom: 7664529 | moritz++ | tools/build/Makefile-Moar.in:

[14:37] <dalek> rakudo/nom: Build: add sanity check that version in VERSION and tarball version are the same

[14:37] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/76645294c2

[14:37] <dalek> rakudo/nom: 6bbb56f | moritz++ | docs/release_guide.pod:

[14:37] <dalek> rakudo/nom: Note 2014.07.2 release in release guide

[14:37] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/6bbb56f4c5

[14:38] <moritz> running final (I hope) spectest with 2015.07.2

[14:38] <moritz> oh, and typo in previous commit message :(

[14:39] *** Hor|zon left
[14:45] <dalek> nqp: 16bee5d | moritz++ | tools/build/Makefile-Moar.in:

[14:45] <dalek> nqp: Build: catch differing versions between tarball and VERSION file

[14:45] <dalek> nqp: review: https://github.com/perl6/nqp/commit/16bee5da6c

[14:46] <lucasb> it will ship with the '~~' change?

[14:53] *** dolmen joined
[14:54] *** skids joined
[15:01] *** brrt left
[15:04] *** mr-foobar left
[15:13] *** [Tux] left
[15:25] *** brrt joined
[15:26] *** [Tux] joined
[15:35] *** dolmen left
[15:37] <lizmat> lucasb: it looks like it

[15:37] <brrt> \o

[15:39] <timotimo> ugexe: an animated gif wouldn't have gone amiss for your progress bar example

[15:40] <timotimo> alternatively, re-implement the animation in javascript

[15:40] <timotimo> :P

[15:40] <lizmat> timotimo brrt  o/

[15:42] <brrt> hmm, i'm puzzling on how to make the final ruleset table, and how to represent it in memory

[15:43] <brrt> option one: nested binary trees; option two, hash tables

[15:43] <lizmat> moritz: did you upload 2015.07.2 already ?

[15:43] <brrt> oh, and it has to work as a linear compiled array, please :-)

[15:44] <lizmat> brrt: I'm afraid nothing comes to mind at this early hour

[15:44] <brrt> hmm

[15:44] <lizmat> (08:45am)

[15:44] <brrt> that's ok, of course:-)

[15:44] <brrt> 17:45 :-P

[15:45] <moritz> lizmat: only nqp

[15:45] <lizmat> ok, so we *could* revert the ~~ chaining change for the 2015.07.2 still ?

[15:46] *** Averna joined
[15:46] <moritz> lizmat: yes; should we?

[15:46] <ugexe> timotimo: is there a suggested tool for creating such a gif?

[15:46] <lizmat> as that seems to have some ecosystem fallout

[15:46] <moritz> ok

[15:46] <moritz> should I revert it on nom, or in a release branch?

[15:47] <lizmat> not sure at this messy point  :-)

[15:47] <moritz> I tend towards a release branch

[15:47] <brrt> probably release branch

[15:47] <lizmat> there you go!

[15:47] <lizmat> :-)

[15:47] <brrt> i mean, the change was probably introduced with Good Reason

[15:47] <lizmat> yeah, but we want an easy rakudo star release  :-)

[15:48] <moritz> thus, release branch

[15:48] <dalek> rakudo/release/2015.07.2: 06fc07e | moritz++ | src/Perl6/Grammar.nqp:

[15:48] <dalek> rakudo/release/2015.07.2: Revert "move ~~ from chaining to structural"

[15:48] <dalek> rakudo/release/2015.07.2: 

[15:48] <dalek> rakudo/release/2015.07.2: This reverts commit 81ad2c0db9910fe7093c1db1d0e25e4710f3e67e.

[15:48] <dalek> rakudo/release/2015.07.2: 

[15:48] <dalek> rakudo/release/2015.07.2: This change was introduced too short before a release

[15:48] <dalek> rakudo/release/2015.07.2: to deal with the ecosystem fallout in time for R*

[15:48] <dalek> rakudo/release/2015.07.2: review: https://github.com/rakudo/rakudo/commit/06fc07e598

[15:48] <moritz> t/spec/S12-attributes/mutators.t aborts here

[15:49] * brrt is not currently on a sufficiently fast computer to test it

[15:49] * hahainternet has a ludicrously fast computer should you require it

[15:49] <lizmat> moritz: it has skips in it, did you run the .t with perl6 ?

[15:49] <moritz> lizmat: I just ran 'make spectest' and later 'make t/spec/S12-attributes/mutators.t'

[15:50] <lizmat> moritz: make runs fine for me

[15:50] <lizmat> (on OS X)

[15:51] *** Hor|zon joined
[15:51] <moritz> http://perlpunks.de/paste/show/55b3b06c.54a2.91

[15:51] <moritz> oh wait, I have local modifications in that file

[15:51] <moritz> never mind me.

[15:52] <brrt> be back much later

[15:53] <hahainternet> brrt: what do you need?

[15:53] <hahainternet> oh ok

[15:53] <brrt> moritz++ needs a spectest run ;-)

[15:53] * brrt needs time to think

[15:53] <hahainternet> well i have some overclocked i7

[15:53] *** brrt left
[15:53] <hahainternet> so shout me if you need it

[15:53] <moritz> 2015.07.2 uploaded

[15:53] <moritz> hahainternet: I'm fine, thanks

[15:55] <moritz> release tagged and pushed

[15:55] *** Hor|zon left
[15:59] <lizmat> moritz++

[16:00] *** grondilu joined
[16:00] <grondilu> can someone give me an ELI5 about this:  https://github.com/azawawi/perl6-atom-electron

[16:01] *** xinming left
[16:01] <timotimo> ugexe: no clue :\

[16:01] <timotimo> i bet vlc can do it :P

[16:02] <tadzik> I don't know, but it looks awesome

[16:02] * grondilu guesses he should check http://electron.atom.io/ out

[16:11] *** lolisa joined
[16:12] <lizmat> decommute, see you on the flipside&

[16:12] *** lizmat left
[16:23] *** llfourn left
[16:27] * moritz just tried to do a star, and Bailador fails (wants Template::Mustach), DBIish fails a test (30-Pg.t), and doc needs File::Temp in a test

[16:34] *** jkva joined
[16:35] <jkva> Good localtime. I'm experiencing a build fail during installation of Task::Star. Is this an appropriate channel to ask for assistance?

[16:37] <ugexe> added a gif, good suggestion

[16:37] *** skids left
[16:40] <RabidGravy> jkva, could be. Ask the question and we'll let you know ;-)

[16:41] *** Begi left
[16:41] <jkva> RabidGravy: Gotcha :) I'm running Debian Squeeze, just finished installing rakudobrew, moarvm and panda. When running "panda install Task::Star" as per the directions, I eventually get:

[16:42] <jkva> the following build error - http://pastie.org/10311742

[16:42] <TimToady> ShimmerFairy: the problem with defining a CANONICAL is that eqv really wants to compare subparts lazily, so that if the first subpart doesn't match, you never have to canonicalize the rest of the object

[16:46] <ShimmerFairy> TimToady: interesting. How would laziness be ensured by an object who defines eqv as basically  $a.A eqv $b.A && $a.B eqv $b.B && ...  (assuming a non-shortcircuiting version of the example I typed)

[16:46] <TimToady> I think a HOP solution would be better, where the class can return a function that can do the comparison

[16:46] <ShimmerFairy> Unless each attribute comparison isn't considered a subpart, in which case I'm not quite clear on what "subpart" means :)

[16:47] <ShimmerFairy> HOP = Higher Order Perl [5] ?

[16:47] <TimToady> Programming

[16:48] <RabidGravy> jkva, I believe that is caused by a very rcent change in rakudo.  It will  be fixed in the modules

[16:49] <TimToady> attribute by attribute, yes, but that could also be broken down if there were, say, a hash value on an attribute to do a fast rejection before doing the harder slow path

[16:49] <jkva> RabidGravy: Too bad. If I want to play with Perl6, do I have any other means at this point? Use an older version?

[16:49] *** AlexDaniel left
[16:50] <TimToady> there's a .2 release that addresses that

[16:51] <TimToady> though it's in a branch

[16:51] <ShimmerFairy> TimToady: when you say "a function that can do the comparison", are you referring to an ACCEPTS-like function? And would that solution require changes to the current core, or could it be done entirely within user code?

[16:52] <RabidGravy> jkva, https://github.com/rakudo/rakudo/tree/release/2015.07.2 specifically

[16:53] <jkva> Ah, excellent. Thank you very much, I will try my luck with that one.

[16:53] <TimToady> at the moment you'd have to call that from your own multi, so there's not much point, but if there were a way that built-in eqv could defer to your EQV function, then you wouldn't have to write a multi

[16:56] <TimToady> I think the built-in eqv should guarantee that the type is the same before delegating, so we don't give the class the option of defining a non-symmetric eqv

[16:56] <RabidGravy> sounds perfect to me

[16:56] <ShimmerFairy> TimToady: so basically "just like ~~ and ACCEPTS", instead of my less-sensible idea of "just like === WHICH", right? :)

[16:56] <ShimmerFairy> TimToady: I recall a syntax for ensuring that, I used it in my old S32::Stringy gist...

[16:56] <TimToady> well, though ACCEPTS is far from symmetrical

[16:58] <ShimmerFairy> Sure, I just mean "calling a function with arguments" vs. "calling a function that returns a string of info"

[16:58] <TimToady> and ACCEPTS is a direct action, whereas I was thinking more of a method to be called at compile time that returns a function that performs the action so we get compile-time dispatch

[16:59] <nine> my $foo = sub { ... }; gives me an anonymous sub. How can I create a named sub?

[16:59] <TimToady> where do you want to put the name?

[17:00] <ShimmerFairy> m: sub foo(Any ::T $a, T $b) { $a ~~ $b }; say foo(1, 1); say foo(1, "1");  # how you would ensure the same type in a signature, for reference

[17:00] <camelia> rakudo-moar 6bbb56: OUTPUT«True␤Type check failed in binding $b; expected 'Int' but got 'Str'␤  in sub foo at /tmp/KVrwhme2xn:1␤  in block <unit> at /tmp/KVrwhme2xn:1␤␤»

[17:01] <nine> TimToady: I'm binding the thus created sub using ::($module).WHO{"&$name"} := sub ... I'd like ::($module).new.^methods to give better answers than a long list of <anon> <anon>

[17:01] <TimToady> you don't want to use ~~ for eqv

[17:01] <jnthn> nine: .set_name on the sub

[17:02] <TimToady> but ^methods won't get the name

[17:02] <ShimmerFairy> TimToady: sure, that was just a silly example sub, the point was demonstrating ::T (admittedly I should've used an irrelevant-to-the-discussion op there, instead of ~~)

[17:02] <TimToady> why I asked where the name is supposed to go

[17:02] *** llfourn joined
[17:02] *** telex left
[17:02] <TimToady> ShimmerFairy: you'd also have to catch the bind error and return false instead

[17:03] <nine> Unfortunately TimToady seems to be right. Still getting <anon>

[17:03] <TimToady> nine: note that P6 does not store method names in packages anymore, is what we're trying to say

[17:03] <ShimmerFairy> You could do that with a multi sub with arguments (Any $a, Any $b), right?

[17:03] <TimToady> so you'd have to do an add_method somewhere to put it into the metaobject

[17:03] <jnthn> walk &

[17:04] *** vendethiel joined
[17:04] <ShimmerFairy> m: multi sub foo(Any ::T $a, T $b) { True }; multi sub foo(Any $a, Any $b) { False }; say foo(1, 1); say foo(1, "1");

[17:04] <camelia> rakudo-moar 6bbb56: OUTPUT«True␤False␤»

[17:04] *** telex joined
[17:05] <ShimmerFairy> Unless that's suboptimal in some way for eqv , that looks like it would work (it _might_ be useful to make eqv do that now anyway, since I don't think it does)

[17:06] *** llfourn left
[17:07] <TimToady> seems to me that it would be better to factor out the type test to before we ever dispatch to any submatchers, rather than scattering the test to every type, and allowing the possibility that someone could write one without the type test accidentally or on purpose

[17:07] <TimToady> that seems like a worthwhile invariant to enforce

[17:08] <RabidGravy> yes

[17:24] <jkva> Unfortunately I am still experiencing the same error when installing Task::Star - I checked out release 2015.07.02 and built rakudo, moarvm and panda manually. "This is perl6 version 2015.07.1-3-g6bbb56f built on MoarVM version 2015.07"

[17:25] <jkva> Although the perl6 version does not seem to match the release number. Perhaps I made a mistake somewhere?

[17:26] <TimToady> it's in a branch, did you checkout?

[17:27] <jkva> TimToady: Most likely I errored there, I'll retry.

[17:31] *** lolisa left
[17:32] <TimToady> masak: we have to solve the cycles problem for serialization anyway, so the correct default is probably just to call a cycle-aware serializer on both objects and compare the resulting buffers; a default clone should probably be using the same default definition via serialize/deserialize

[17:32] <TimToady> then eqv optimizations are just short-circuiting "would these objects serialize the same if we tried"

[17:33] <TimToady> and deepclone optimization is bypassing the actual construction/deconstruction of the serialized form

[17:34] <TimToady> but the definition of what is serializable stays the same, abstracted to one spot

[17:34] <TimToady> I'd rather have a slow correct eqv and deepclone that for it to default to the wrong sematics

[17:34] <TimToady> *than

[17:35] <TimToady> then "can I call eqv/deepclone?" semantically reduces to "are these serializable?"

[17:40] *** rangerprice joined
[17:40] *** konsolebox left
[17:48] <TimToady> and standard policies for detecting cycles also need to be available to people writing their own eqv, so that they can behave as if a massive serialization were being done by the top-level eqv, without actually doing the massive serialzation

[17:48] <TimToady> which implies we know how to detect a top-level eqv and distinguish it from eqv helpers

[17:49] <jkva> Got past the error, excellent. I made a mistake checking out the release. Thanks!

[17:50] <TimToady> yer welkum

[17:52] *** Hor|zon joined
[17:56] *** Hor|zon left
[17:56] <jkva> Wth? DBDish expects me to have mysql running for its test?

[17:58] <jkva> Shouldn't that be mocked?

[18:01] <jkva> Ah, I see on github it's on the agenda. Nvm.

[18:05] <jkva> x§

[18:12] *** zakharyas joined
[18:24] *** zakharyas left
[18:29] <moritz> jkva: DBIish comes with the sqlite, mysql and postgres backends

[18:30] <moritz> jkva: and it tries to run all of its tests, but skip those tests that it can't run due to missing libs

[18:32] *** apejens left
[18:33] *** apejens joined
[18:40] *** jkva left
[18:42] *** zakharyas joined
[18:45] *** cognominal left
[18:45] *** cognominal joined
[18:55] <lucasb> m: BEGIN $_ = 1

[18:55] <camelia> rakudo-moar 6bbb56: ( no output )

[18:56] <lucasb> m: BEGIN { $_ = 1 }

[18:56] <camelia> rakudo-moar 6bbb56: OUTPUT«5===SORRY!5=== Error while compiling /tmp/tpGfrQflqt␤An exception occurred while evaluating a BEGIN␤at /tmp/tpGfrQflqt:1␤Exception details:␤  5===SORRY!5=== Error while compiling ␤  Cannot assign to an immutable value␤  at :␤»

[18:56] <dalek> DBIish: cc432b0 | moritz++ | lib/DBDish/Pg.pm6:

[18:56] <dalek> DBIish: Fix test failure in t/30-Pg.t

[18:56] <dalek> DBIish: 

[18:56] <dalek> DBIish: I think this is a workaround for a recently-ish rakudobug

[18:56] <dalek> DBIish: review: https://github.com/perl6/DBIish/commit/cc432b0fb4

[18:59] <lucasb> m: INIT $_ := 1; .say

[18:59] <camelia> rakudo-moar 6bbb56: OUTPUT«1␤»

[18:59] <lucasb> m: INIT { $_ := 1 }; .say

[18:59] <camelia> rakudo-moar 6bbb56: OUTPUT«(Any)␤»

[19:01] <moritz> a block has its own $_

[19:02] <nine> m: my $name = "Foo"; my $class := Metamodel::ClassHOW.new_type(name => $name); ::($name) := $class;

[19:02] <camelia> rakudo-moar 6bbb56: OUTPUT«5===SORRY!5=== Error while compiling /tmp/4ZSHivYBNG␤Cannot use bind operator with this left-hand side␤at /tmp/4ZSHivYBNG:1␤------> 3type(name => $name); ::($name) := $class7⏏5;␤»

[19:02] <nine> That's an LTA error message. It explains neither why I cannot use the bind operator, nor what an alternative could be.

[19:02] <lucasb> moritz: So it would never work? Well, that explains it. thanks.

[19:04] <TimToady> m: INIT { OUTER::<$_> := 1 }; .say

[19:05] <camelia> rakudo-moar 6bbb56: OUTPUT«1␤»

[19:05] <TimToady> m: INIT { UNIT::<$_> := 1 }; .say

[19:05] <camelia> rakudo-moar 6bbb56: OUTPUT«1␤»

[19:05] *** AlexDaniel joined
[19:06] <TimToady> m: BEGIN { OUTER::<$_> = 1 }; .say

[19:06] <moritz> nine: it's hard make that error better

[19:06] <camelia> rakudo-moar 6bbb56: OUTPUT«5===SORRY!5=== Error while compiling /tmp/r34LRgQ9JY␤An exception occurred while evaluating a BEGIN␤at /tmp/r34LRgQ9JY:1␤Exception details:␤  Cannot modify an immutable Mu␤    in block  at /tmp/r34LRgQ9JY:1␤␤»

[19:06] <nine> So what's wrong with this? ::($name) := $class Or rather, what would be the real way to make a class accessible through its name?

[19:06] <moritz> nine: you cannot add stuff to lexpads at run time

[19:07] <nine> moritz: I can if I use EVAL, so I figured that there should be some MOP way, too?

[19:07] <moritz> nine: with EVAL you can only add it to the lexpad inside the EVAL

[19:07] <TimToady> you can only add it to EVAL's lexical scope, not its OUTER

[19:08] <moritz> nine: if you want to install it as an our-symbol, you can assing to GLOBAL::($name), I think

[19:08] <moritz> or was it GLOBAL::{$name}?

[19:09] <moritz> tadzik: currently Bailador depends on both Template::Mustache and Template::Mojo, forcing Star to include both. Is that intentional?

[19:10] <nine> Indeed I use GLOBAL:: in the EVAL: https://github.com/niner/Inline-Perl5/blob/master/lib/Inline/Perl5.pm6#L698

[19:10] <nine> m: my $name = "Foo"; my $class := Metamodel::ClassHOW.new_type(name => $name); GLOBAL::($name) := $class;

[19:10] <camelia> rakudo-moar 6bbb56: OUTPUT«5===SORRY!5=== Error while compiling /tmp/0K_Y18FfpL␤Cannot use bind operator with this left-hand side␤at /tmp/0K_Y18FfpL:1␤------> 3ame => $name); GLOBAL::($name) := $class7⏏5;␤»

[19:10] <nine> Unfortunately still the same error

[19:10] <moritz> m: GLOBAL::{'Foo'} := class { };

[19:10] <camelia> rakudo-moar 6bbb56: ( no output )

[19:10] <moritz> nine: works with {}

[19:12] <TimToady> ::() is just symbolic lookup, ::{} is actually using the Stash as a hash, so it can give you a bindable

[19:12] <dalek> star: 814f76b | moritz++ | / (3 files):

[19:12] <dalek> star: Initial preparations for 2015.07

[19:12] <dalek> star: review: https://github.com/rakudo/star/commit/814f76b7d7

[19:12] <nine> moritz: thanks! One step further.

[19:12] <nine> m: BEGIN { my $name = "Foo::Bar"; my $class := Metamodel::ClassHOW.new_type(name => $name); $class.^compose; GLOBAL::{$name} := $class; }; Foo::Bar.new;

[19:12] <camelia> rakudo-moar 6bbb56: OUTPUT«Could not find symbol '&Bar'␤  in block <unit> at /tmp/Kol65Ba5qQ:1␤␤Actually thrown at:␤  in block <unit> at /tmp/Kol65Ba5qQ:1␤␤»

[19:12] <dalek> star: 098e45e | moritz++ | modules/ (10 files):

[19:12] <dalek> star: Update submodules

[19:12] <dalek> star: review: https://github.com/rakudo/star/commit/098e45e662

[19:13] <moritz> nine: probably need to split on :: yourself, and plot your way through GLOBAL::{$first}::{$second}

[19:14] <tadzik> moritz: hmm, possibly. I guess it could be made an optional dependency

[19:15] <nine> moritz: yep. I seem to remember having written such code, came across some problem and frustratedly giving up and use EVAL instead

[19:19] <dalek> star: a383d29 | moritz++ | modules/ (3 files):

[19:19] <dalek> star: Remove deleted subodules more thoroughly

[19:19] <dalek> star: review: https://github.com/rakudo/star/commit/a383d29320

[19:22] <RabidGravy> I'm quite liking subodules

[19:23] <moritz> RabidGravy: I hate them

[19:23] <RabidGravy> :)

[19:23] <moritz> the submodules are constantly in "detached HEAD" state, which makes working in them a PITA

[19:24] <moritz> they have multiple redundant locations for meta data; changing only one of them leaves them in inconsistent state

[19:24] <moritz> 'git archive', 'git grep' et al ignore submodules

[19:24] <moritz> the list goes on.

[19:28] <flussence> moritz: you're not the only one; I've noticed most projects that use submodules wrap them in a ton of scripting so nobody has to touch git for them directly...

[19:28] <moritz> ok, star-m now passes all tests

[19:29] <moritz> flussence: I know; #git recommends not using them either, mostly

[19:29] *** ggoebel joined
[19:32] <flussence> I'm hoping somewhere down the line an alternative idea'll pop up that people agree on being good enough, sort of like Moose did for p5

[19:32] *** darutoko left
[19:32] <flussence> git's really-simple-core design seems like it'll leave space for that to happen

[19:33] <moritz> well, subtree exists, for cases where size isn't a problem

[19:34] *** jkva joined
[19:35] <jkva> moritz: For me the mysql test failed, and stopped Task::Star from going on to the next module. I resorted to using -notests, but would rather not have.

[19:35] <jkva> moritz: ah, I understand. I have libraries installed, but not MySQL itself. So this is an error on my part. Apologies, I was mistaken.

[19:35] <moritz> jkva: no, souldn't fail in that case either

[19:36] <jkva> moritz: Would you like me to file an issue?

[19:36] <moritz> jkva: yes please

[19:36] <jkva> moritz: will do.

[19:36] <moritz> jkva++

[19:38] *** ggoebel left
[19:48] *** yqt joined
[19:51] <jkva> moritz: I've opened https://github.com/perl6/DBIish/issues/14 - keep in mind I am really new to Perl6, the problem might very well be on my end. Please let me know if you need more info.

[19:52] *** Hor|zon joined
[19:53] <moritz> jkva: ah, it's actually t/30-Pg.t that fails

[19:53] <moritz> jkva: the mysql tests spew out error messages, but don't fail

[19:53] <jkva> d'oh

[19:54] <moritz> jkva: and the failure in 30-Pg.t should be fixed by https://github.com/perl6/DBIish/commit/cc432b0fb49e7a9c485e3b8d379f26186fe3086c (from an hour ago, roughly)

[19:54] <jkva> Ha, no way

[19:54] <jkva> Awesome

[19:55] <jkva> Right, the mysql errors were a red herring. Thanks!

[19:55] <dalek> DBIish: 7cf60c4 | moritz++ | lib/DBDish/Pg.pm6:

[19:55] <dalek> DBIish: Fix a build failure with rakudo-2015.07, jkva++

[19:55] <dalek> DBIish: 

[19:55] <dalek> DBIish: closes #14

[19:55] <dalek> DBIish: review: https://github.com/perl6/DBIish/commit/7cf60c4669

[19:55] <jkva> Whelp, that one was quickly sorted :P

[19:56] <moritz> jkva: but the end of your paste also include an error that I hadn't seen before, which the commit above should have fixed

[19:56] <jkva> moritz: glad to hear - I figured it couldn't hurt

[19:57] *** Hor|zon left
[20:11] *** bin_005 joined
[20:11] <moritz> jkva: anyway, hope it's all good now

[20:13] <jkva> moritz: I expect it to be - I'm going to make a fresh install of Task::Star later. Do you know of a preferred way of reinstalling already installed modules with panda?

[20:15] <moritz> jkva: no idea

[20:15] <jkva> moritz: No probs - I'll figure things out. Thanks for the quick fixes, moritz++

[20:21] <RabidGravy> jkva, if you do "panda install <module>" it usually just reinstalls it

[20:21] <jkva> RabidGravy: thanks, worth a shot :)

[20:24] <jkva> RabidGravy: you are correct. moritz: all good now!

[20:25] <RabidGravy> for reference if you want to reinstall *all* modules, reinstalling panda will cause that

[20:25] *** zakharyas left
[20:25] <moritz> \o/

[20:26] *** rindolf left
[20:26] <jkva> RabidGravy: Yeah, although I'd rather avoid that :)

[20:40] *** lucasb left
[20:55] *** jkva_ joined
[20:57] *** jkva left
[21:00] *** kaare__ left
[21:06] *** rangerprice left
[21:08] *** jkva_ left
[21:16] *** yqt left
[21:19] *** yqt joined
[21:33] *** Begi joined
[21:38] *** mdinger joined
[21:48] *** jkva joined
[21:53] *** Hor|zon joined
[21:58] *** jkva left
[21:58] *** Hor|zon left
[21:58] *** jkva joined
[22:04] <dalek> roast: f4caecb | PerlJam++ | S32-array/splice.t:

[22:04] <dalek> roast: Add test for RT#119913

[22:04] <dalek> roast: review: https://github.com/perl6/roast/commit/f4caecb87e

[22:04] <synbot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=119913

[22:08] <RabidGravy> (more tests)++

[22:21] *** perturbation joined
[22:25] *** Begi left
[22:32] <mdinger> Is there a reason lookaround uses really weird ordering? For example: `rx{ <?after foo> bar <?before baz> }` has `after` before `bar` and `before` after `baz`...reading it is pretty awkward. Shouldn't it be backwards?

[22:34] <vendethiel> m: say 'foobarbaz' ~~ /<?after foo>bar<?before baz>/; # mdinger

[22:34] <camelia> rakudo-moar 6bbb56: OUTPUT«｢bar｣␤»

[22:35] <vendethiel> mdinger: basically, the first "after" says "what i just saw contained foo". then, the before says "what i WILL see will be baz"

[22:38] <mdinger> vendethiel: okay. It does make sense and I wasn't questioning if it worked.

[22:38] *** jkva left
[22:39] <mdinger> vendethiel: It just seems weird. Is it written from the perspective of the parser?

[22:41] <vendethiel> mdinger: no, it's written in the order I expect. It's not "surrounding" bar.

[22:41] <vendethiel> "my content is right AFTER what I just saw" (after). "you see bar" (bar) "my content must be BEFORE what I will see" (<before>)

[22:49] *** TEttinger joined
[22:50] <mdinger> vendethiel: okay. This'll take some work I guess. I really really want to read it like this I guess: `/<?before foo>bar<?after baz>/` foo is before bar. baz is after bar.

[22:52] <mdinger> I can read it as you showed I just have to be really careful...maybe it'll come with time

[22:52] <dalek> roast: e8821d1 | PerlJam++ | S16-filehandles/io.t:

[22:52] <dalek> roast: Add some tests for RT#113100

[22:52] <dalek> roast: review: https://github.com/perl6/roast/commit/e8821d1f73

[22:52] <synbot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=113100

[23:05] <dalek> doc: 6b4f45c | mdinger++ | lib/Language/regexes.pod:

[23:05] <dalek> doc: Document lookahead assertions

[23:05] <dalek> doc: review: https://github.com/perl6/doc/commit/6b4f45c5f2

[23:05] <dalek> doc: a186323 | RabidGravy++ | lib/Language/regexes.pod:

[23:05] <dalek> doc: Merge pull request #106 from mdinger/lookahead

[23:05] <dalek> doc: 

[23:05] <dalek> doc: Document lookahead assertions

[23:05] <dalek> doc: review: https://github.com/perl6/doc/commit/a186323d2d

[23:06] <RabidGravy> there you go :)

[23:08] <mdinger> thanks guys

[23:08] *** mdinger left
[23:08] *** mr-foobar joined
[23:12] <dalek> roast: 8c8efe8 | PerlJam++ | S02-types/bool.t:

[23:12] <dalek> roast: Add a couple of todo tests for RT#72580

[23:12] <dalek> roast: review: https://github.com/perl6/roast/commit/8c8efe8b3b

[23:12] <synbot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=72580

[23:13] *** [Tux] left
[23:15] *** JimmyZ_ left
[23:33] *** BenGoldberg joined
[23:35] *** TimToady left
[23:37] *** TimToady joined
[23:38] <RabidGravy> nighty night

[23:38] <timotimo> nn

[23:42] *** RabidGravy left
[23:54] *** Hor|zon joined
[23:59] *** Hor|zon left
