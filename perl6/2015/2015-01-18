[00:01] <lue> "half stumbles to the place on the floor here the gun is."  missing 'w' in 'where'

[00:02] *** BenGoldberg_ joined
[00:02] <masak> lue: fixed. lue++

[00:03] *** eternaleye left
[00:04] *** dj_goku joined
[00:04] *** dj_goku left
[00:04] *** dj_goku joined
[00:05] <lue> "the aim is to produce something a Perlish macro system"  did you mean "something of a" ?

[00:06] <masak> removing the "something".

[00:06] <geekosaur> or something resembling...

[00:06] *** Ben_Goldberg left
[00:08] <lue> masak++  I love how it starts out as perfectly serious, then halfway through instantly breaks down into something silly :)

[00:08] <masak> \o/

[00:08] * timotimo just watched Airplane! with friends

[00:08] <timotimo> good times

[00:10] *** eternaleye joined
[00:13] <b2gills> m: say 5 ~~ Int:D; say 5 ~~ Int:U; # I wonder if this can be easily made to work by adding adverbs to &infix:<~~>

[00:13] <camelia> rakudo-moar e37eb0: OUTPUT«True␤True␤»

[00:13] <masak> b2gills: that... seems like an odd way to implement it...

[00:14] <masak> b2gills: what about `my $t = Int:U; say 5 ~~ $t;` ?

[00:22] *** rurban left
[00:23] <masak> b2gills: also, what about all the places where smartmatching is used, but not infix:<~~>? where clauses, when statements...?

[00:34] *** virtualsue joined
[00:43] *** tgt left
[01:02] <masak> 'night, #perl6

[01:02] *** Ben_Goldberg joined
[01:03] *** eternaleye left
[01:03] <dalek> rakudo/nom: 285435e | TimToady++ | src/core/Any.pm:

[01:03] <dalek> rakudo/nom: use object hashes for .classify and .categorize

[01:03] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/285435eff6

[01:03] <dalek> rakudo/nom: 20c0958 | TimToady++ | src/core/Signature.pm:

[01:03] <dalek> rakudo/nom: internal use of .classify needs object semantics

[01:03] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/20c0958890

[01:03] <dalek> rakudo/nom: 949d82c | TimToady++ | src/ (2 files):

[01:03] <dalek> rakudo/nom: make :{} mean object hash

[01:03] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/949d82cd48

[01:06] *** BenGoldberg_ left
[01:09] *** eternaleye joined
[01:17] <dalek> specs: 1159122 | TimToady++ | S03-operators.pod:

[01:17] <dalek> specs: describe :{} object hash composer

[01:17] <dalek> specs: review: https://github.com/perl6/specs/commit/115912267b

[01:22] *** Mso150 joined
[01:24] <dalek> rakudo/nom: 989bb60 | TimToady++ | src/core/Hash.pm:

[01:24] <dalek> rakudo/nom: make :{} symbol available to rest of setting

[01:24] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/989bb605c0

[01:25] <vendethiel> seems useful :D

[01:41] <TimToady> m: say :{}.perl

[01:41] <camelia> rakudo-moar 949d82: OUTPUT«:{}␤»

[01:41] *** virtualsue left
[01:42] <TimToady> m: say :{ 0 => 42, 1 => 43 }{0}

[01:42] <camelia> rakudo-moar 949d82: OUTPUT«42␤»

[01:42] <TimToady> m: say :{ 0 => 42, 1 => 43 }<0>

[01:42] <camelia> rakudo-moar 949d82: OUTPUT«(Any)␤»

[01:43] <vendethiel> is "custom indexing" implemented in rakudo?

[01:43] <TimToady> m: say (^100).classify(* % 7).perl

[01:43] <camelia> rakudo-moar 949d82: OUTPUT«Hash[Any,Any].new(2 => [2, 9, 16, 23, 30, 37, 44, 51, 58, 65, 72, 79, 86, 93], 5 => [5, 12, 19, 26, 33, 40, 47, 54, 61, 68, 75, 82, 89, 96], 0 => [0, 7, 14, 21, 28, 35, 42, 49, 56, 63, 70, 77, 84, 91, 98], 4 => [4, 11, 18, 25, 32, 39, 46, 53, 60, 67, 74, 8…»

[01:43] <TimToady> not yet

[01:44] <TimToady> hmm

[01:44] <TimToady> m: say (^100).classify(* % 7).item.perl

[01:44] <camelia> rakudo-moar 949d82: OUTPUT«:{4 => [4, 11, 18, 25, 32, 39, 46, 53, 60, 67, 74, 81, 88, 95], 3 => [3, 10, 17, 24, 31, 38, 45, 52, 59, 66, 73, 80, 87, 94], 0 => [0, 7, 14, 21, 28, 35, 42, 49, 56, 63, 70, 77, 84, 91, 98], 1 => [1, 8, 15, 22, 29, 36, 43, 50, 57, 64, 71, 78, 85, 92, 99], …»

[01:48] <TimToady> yeah, has to be item to get :{} form back out of it

[01:50] <TimToady> m: .say for (^100).classify(* % 12).sort

[01:50] <camelia> rakudo-moar 949d82: OUTPUT«0 => 0 12 24 36 48 60 72 84 96␤1 => 1 13 25 37 49 61 73 85 97␤2 => 2 14 26 38 50 62 74 86 98␤3 => 3 15 27 39 51 63 75 87 99␤4 => 4 16 28 40 52 64 76 88␤5 => 5 17 29 41 53 65 77 89␤6 => 6 18 30 42 54 66 78 90␤7 => 7 19 31 43 55 67 79 91␤8 =>…»

[01:50] <TimToady> \o/ (numeric sort)

[01:52] *** kaare__ left
[01:57] <timotimo> i don't really know what an object hash is?

[02:00] <TimToady> a hash of objects rather than strings

[02:00] <TimToady> Any --> Any rather than Str --> Any

[02:02] *** BenGoldberg_ joined
[02:04] *** eternaleye left
[02:06] *** Ben_Goldberg left
[02:10] <timotimo> oh

[02:11] <timotimo> of course

[02:11] <timotimo> these are useful very often

[02:16] *** eternaleye joined
[02:16] *** tinyblak joined
[02:39] <JimmyZ> moritz: Thanks :)

[02:57] *** kjs_ joined
[03:01] *** Sqirrel left
[03:02] *** Sqirrel joined
[03:02] <dalek> roast: b5e1723 | TimToady++ | S32-list/categorize.t:

[03:02] <dalek> roast: update to use new :{} notation

[03:02] <dalek> roast: review: https://github.com/perl6/roast/commit/b5e17233b3

[03:02] <TimToady> forgot to check that one in...

[03:03] *** Ben_Goldberg joined
[03:03] *** eternaleye left
[03:06] *** BenGoldberg_ left
[03:09] *** erdic left
[03:10] *** erdic joined
[03:17] *** eternaleye joined
[03:18] *** Patterner joined
[03:19] *** gfldex left
[03:22] *** Psyche^ left
[03:43] *** leont left
[03:48] <novice777> Does anyone knows best(good?) TrueType Unicode font for Windows console with the wide range  support of  character code tables?

[03:54] *** kjs_ left
[03:54] <TimToady> dunno about windows; on linux I use the font 'Monospace' augmented with Aegean.ttf Aegyptus_B.ttf Aegyptus_R.ttf Akkadian.ttf Analecta.ttf Anatolian.ttf Gardiner.ttf HAN NOM A.ttf HAN NOM B.ttf Maya.ttf Musica.ttf Symbola.ttf Unidings.ttf

[03:58] *** noganex_ joined
[04:01] *** noganex left
[04:02] *** eternaleye left
[04:12] *** Mso150 left
[04:13] *** eternaleye joined
[04:15] <raydiak> iirc dejavu mono has above-average unicode coverage...download is a ttf, iirc that installs just fine in windows

[04:18] *** telex left
[04:20] *** telex joined
[04:22] <raydiak> I think "Monospace" means "use the system's default mono font" usually

[04:53] <geekosaur> yes, it's a font alias and usually mapped to bitstream vera mono or dejavu mono

[04:56] *** Rounin joined
[04:56] <geekosaur> vera sans mono that is

[05:00] <raydiak> panda doesn't work on rakudo more than a few months old since the reporter branch merge

[05:02] <raydiak> wonder if rakudobrew build-panda should at least take an optional arg for a commit so you can build older pandas with older rakudos

[05:04] *** eternaleye left
[05:08] *** KCL_ joined
[05:10] *** eternaleye joined
[05:21] *** kurahaupo1 joined
[05:43] *** eternaleye left
[05:43] *** eternaleye joined
[05:45] *** Ben_Goldberg left
[05:52] *** novice777 left
[06:03] *** rindolf joined
[06:05] *** eternaleye left
[06:06] *** eternaleye joined
[06:10] <japhb> masak++  # https://github.com/masak/007/blob/master/README.md

[06:15] *** Rounin left
[06:21] *** booly-yam-4706 left
[06:24] *** Rounin joined
[06:30] *** tinyblak left
[06:30] *** tinyblak joined
[06:55] *** keyle joined
[06:56] *** Akagi201 joined
[06:58] *** keyle left
[06:58] *** tinyblak_ joined
[07:01] *** booly-yam-4706 joined
[07:01] *** tinyblak left
[07:06] <dalek> doc: 5be61c2 | skids++ | lib/Type/EnumMap.pod:

[07:06] <dalek> doc: Remove old caveat about operator adverbs

[07:06] <dalek> doc: 

[07:06] <dalek> doc: .{}:exists has worked in rakudo for some time now

[07:06] <dalek> doc: review: https://github.com/perl6/doc/commit/5be61c2dda

[07:12] *** booly-yam-4706 left
[07:15] *** darutoko joined
[07:15] *** Rounin left
[07:25] *** xfix joined
[07:39] *** kaare__ joined
[07:50] <moritz> m: enum A <b c>; say A.^mro; say b.^mro

[07:50] <camelia> rakudo-moar 989bb6: OUTPUT«(A) (Int) (Cool) (Any) (Mu)␤(A) (Int) (Cool) (Any) (Mu)␤»

[07:51] <moritz> m: enum A <b c>; say A.^roles; say b.^roles

[07:51] <camelia> rakudo-moar 989bb6: OUTPUT«No such method 'roles' for invocant of type 'Perl6::Metamodel::EnumHOW'␤  in block <unit> at /tmp/uGmEMJDYcU:1␤␤»

[07:51] <moritz> m: enum A <b c>; say b.^roles

[07:51] <camelia> rakudo-moar 989bb6: OUTPUT«No such method 'roles' for invocant of type 'Perl6::Metamodel::EnumHOW'␤  in block <unit> at /tmp/QynMOU3Zr_:1␤␤»

[07:51] <moritz> m: enum A <b c>; say $_ ~~ Enumeration for A, b

[07:51] <camelia> rakudo-moar 989bb6: OUTPUT«False␤False␤»

[07:52] *** rindolf left
[07:54] *** kurahaupo1 left
[08:01] <moritz> masak++ # 007 REAMDE

[08:05] *** prime left
[08:06] *** prime joined
[08:09] <moritz> m: enum A <b c>; say b.pick

[08:09] <camelia> rakudo-moar 989bb6: OUTPUT«b␤»

[08:09] <moritz> m: enum A <b c>; say A.pick

[08:09] <camelia> rakudo-moar 989bb6: OUTPUT«c␤»

[08:23] *** kurahaupo1 joined
[08:24] <dalek> doc: ea577db | moritz++ | lib/Type/Supply.pod:

[08:24] <dalek> doc: Document Supply.from-list

[08:24] <dalek> doc: review: https://github.com/perl6/doc/commit/ea577db7b5

[08:34] *** booly-yam-4706 joined
[08:35] *** vendethiel left
[08:36] *** vendethiel joined
[08:38] <dalek> faq: bb96233 | moritz++ | answers.md:

[08:38] <dalek> faq: Expand a bit on private attributes set from a constructor

[08:38] <dalek> faq: review: https://github.com/perl6/faq/commit/bb96233ded

[08:38] <dalek> faq: 5aecccd | moritz++ | answers.md:

[08:38] <dalek> faq: Explain numierc types, and which ones to use as type constraints

[08:38] <dalek> faq: review: https://github.com/perl6/faq/commit/5aecccdd12

[08:45] *** gfldex joined
[08:46] *** booly-yam-4706 left
[08:49] <dalek> faq: bb42933 | moritz++ | answers.md:

[08:49] <dalek> faq: Linkify some types

[08:49] <dalek> faq: review: https://github.com/perl6/faq/commit/bb4293317a

[08:52] <dalek> faq: e0a4272 | moritz++ | answers.md:

[08:52] <dalek> faq: Link to container docs

[08:52] <dalek> faq: review: https://github.com/perl6/faq/commit/e0a42725d0

[08:57] *** kurahaupo1 left
[09:14] *** booly-yam-4706 joined
[09:22] *** Rounin joined
[09:24] *** kurahaupo1 joined
[09:24] *** rurban joined
[09:26] *** molaf__ joined
[09:30] *** molaf_ left
[09:34] *** adu joined
[09:48] *** kurahaupo1 left
[09:55] *** Alina-malina left
[09:58] <dalek> faq: 9c47517 | moritz++ | answers.md:

[09:58] <dalek> faq: Mention gradual typing

[09:58] <dalek> faq: review: https://github.com/perl6/faq/commit/9c47517748

[10:01] *** booly-yam-4706_ joined
[10:02] *** booly-yam-4706 left
[10:08] *** adu left
[10:12] *** Alina-malina joined
[10:14] *** tinyblak_ left
[10:14] *** tinyblak joined
[10:20] *** spider-mario joined
[10:30] *** FROGGS joined
[10:30] *** anaeem1 joined
[10:34] *** espadrine joined
[10:57] <FROGGS> moritz: I get a service timeout for the dalek webhook :o(

[10:57] <FROGGS> moritz: is this the correct url? http://hack.p6c.org/dalek?t=freenode,perl6-lwp-gsoc

[11:03] *** jluis_ joined
[11:08] <FROGGS> ohh, found it at: https://github.com/perl6/mu/blob/master/misc/dalek-push.txt

[11:09] <moritz> \o/ docs++

[11:11] <FROGGS> indeed :o)

[11:13] *** anaeem1 left
[11:14] *** denis_boyun_ joined
[11:15] *** anaeem1 joined
[11:24] <jnthn> afternoon, #perl6

[11:25] <FROGGS> hi jnthn 

[11:29] <lizmat> FROGGS jnthn  o/

[11:30] *** pmurias joined
[11:31] <FROGGS> hi lizmat 

[11:32] * jnthn is well rested and mostly free of cold o/

[11:32] <jnthn> ...and still has a BS bug /o\

[11:33] <dalek> rakudo/nom: 20d5ef3 | lizmat++ | / (4 files):

[11:33] <dalek> rakudo/nom: Introduce Rangeint: simple integer ranges like ^10

[11:33] <dalek> rakudo/nom: 

[11:33] <dalek> rakudo/nom: Is not used in the core (yet).  The idea being that the whole range machinery

[11:33] <dalek> rakudo/nom: is not needed for simpel integer ranges like ^10 or 200..500.  Bolting on will

[11:33] <dalek> rakudo/nom: need to wait until some bugs are fixed.

[11:33] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/20d5ef3e53

[11:34] <lizmat> jnthn FROGGS: need some nqp:: functions related help

[11:34] <lizmat> do you see anything obviously wrong in Rangeint.BUILD ?

[11:36] <jnthn> Not immediately.

[11:37] <jnthn> Other than it's one of the unsubclassable ones 'cus it breaks the normal contract.

[11:37] *** denis_boyun_ left
[11:37] <lizmat> well, it's supposed to be an internal class, to be used only if Range.new sees it's possble to use

[11:37] <jnthn> For these cheating ones it may be better to write them as !BUILD

[11:38] <lizmat> ok

[11:38] <jnthn> Ah, then fair enough...but it will leak out due to .WHAT of course. 

[11:38] <lizmat> $ 6 'my $r = Rangeint.new(0,9); say $r.flat.perl'

[11:38] <lizmat> This type does not support positional operations

[11:38] <lizmat> jnthn: yes, but ~~ Range should be True

[11:38] <jnthn> $!list := nqp::null();

[11:38] <jnthn> null doesn't support positional operations...

[11:38] <jnthn> :P

[11:39] <jnthn> I wonder if there's a missing guard...

[11:39] <lizmat> so, I want $!list to be populated only when needed

[11:40] <FROGGS> --ll-exception will at least point you to the offending line...

[11:40] <jnthn> yeah, I can see...I'm not sure where it's not being done

[11:40] *** booly-yam-4706_ left
[11:41] <jnthn> lizmat: How much overhead does the "is this an Int range" stuff actually have?

[11:41] <jnthn> I thought we already special-cased this inside of Range.

[11:41] <lizmat> not much, really

[11:42] <lizmat> and there's all the include/exclude min checks

[11:42] <lizmat> that Rangeint doesn't have

[11:42] <lizmat> reification

[11:43] <lizmat> at_pos wouldn't need to reify, e.g.

[11:43] <jnthn> Yes, your class missed reify

[11:43] <jnthn> *misses

[11:43] <lizmat> nope, it has one

[11:43] <lizmat> self.flat

[11:43] <jnthn> ah, I see

[11:44] <lizmat> but I'm not sure that just shouldn't return anything

[11:44] <lizmat> especially since we don't need reification for at_pos

[11:44] <jnthn> Still, I don't know we should be handling this with type explosion.

[11:45] <jnthn> Rather than the "stash a closure that knows how to reify" approach we're looking at for the GLR.

[11:45] <lizmat> at startup, already 6 Range objects are created, all that could be handled by this class

[11:45] <jnthn> Yes, but at startup 50% of our time is spent deserializing.

[11:45] <jnthn> Well, 50% of our CPU cycles.

[11:45] <jnthn> And adding more types/methods doesn't help that, if we're looking at startup cost.

[11:46] <lizmat> so you're saying this is a bad idea?

[11:46] *** rindolf joined
[11:46] <lizmat> any slice with a range should become much faster with this as well

[11:47] <jnthn> Yeah,b ut when do we slice integer ranges?

[11:47] <jnthn> *but

[11:48] <jnthn> The really simple iteration cases like "for ^1000 { }" should already be getting re-written by the optimizer to while loops.

[11:48] <lizmat> in the core, in Termporal

[11:48] <jnthn> Line?

[11:48] <lizmat> 198, 206, 215

[11:49] <lizmat> but I'm more thinking about ecosystem doing @a[^10] and stuff

[11:49] <lizmat> ok, that's for the exception

[11:49] <jnthn> Yes, those are for exceptions

[11:50] <jnthn> For ^10 note that if we were a little smarter we could constant-fold ^10

[11:50] <jnthn> But now I see you meant slicing *with* a range, not slicing the range itself.

[11:50] <lizmat> ah, yes, sorry for the unclarity

[11:50] <jnthn> np

[11:51] <lizmat> anyway, doing an at_pos on a range like this wouldn't need reification

[11:51] <jnthn> But don't we .at_pos($_) for @the-param-that-has-the-range ?

[11:52] <lizmat> there's quite a lot ^$var in the core

[11:53] <jnthn> multi sub postcircumfix:<[ ]>( \SELF, Positional:D \pos ) is rw {

[11:53] <jnthn>     nqp::iscont(pos)

[11:53] <jnthn>       ?? SELF.at_pos(pos.Int)

[11:53] <jnthn>       !! POSITIONS(SELF,pos).map({ SELF[$_] }).eager.Parcel;

[11:53] <jnthn> }So the range is passed to POSITIONS

[11:54] <jnthn> And overload of POSITIONS on Range might be the easier place to get a win?

[11:55] <lizmat> well, that would be the next step: if pos is a Rangint

[11:55] <jnthn> The whole POSITIONS mechanism - introducing a chain of 2 maps once you include the one in the postcircumfix:<[ ]> method - looks not entirely cheap

[11:55] <lizmat> I'm open to suggestions :-)

[11:56] <lizmat> remember, it also needs to handle nested arrays / hashes and attributes

[11:56] *** tgt joined
[11:56] <lizmat> the fact that we need to make so many different MMD candidates is also something that may need some scrutiny

[11:57] *** kjs_ joined
[11:59] <jnthn> Attributes?

[11:59] <lizmat> yup

[11:59] <FROGGS> in case I have an xml attribute: <foo:bar xmlns:foo="http://kungfoo"/> - what should be the .name?

[12:00] <FROGGS> I'd tend to "bar", but I dunno is that's too lax

[12:00] <jnthn> lizmat: Example?

[12:01] <lizmat> multi sub postcircumfix:<[ ]>( \SELF, int $pos, :$delete!, *%other ) is rw {

[12:01] <moritz> FROGGS: it could be 'bar' or 'foo:bar'

[12:01] <jnthn> lizmat: Adverbs?

[12:01] <lizmat> multi sub postcircumfix:<[ ]>( \SELF, int $pos, :$exists!, *%other ) is rw {

[12:01] <lizmat> multi sub postcircumfix:<[ ]>( \SELF, int $pos, :$kv!, *%other ) is rw {

[12:01] <FROGGS> moritz: yes, the question is: "foo:bar" to be more strict by default, or should it be "bar" ?

[12:01] <arnsholt> FROGGS: Isn't there an answer to that in the XML standards?

[12:01] <lizmat> jnthn: etc etc 

[12:02] <FROGGS> moritz: and... in case it is "bar", what's the long form? .fq-name? .longname? ...

[12:02] <jnthn> Right, but I see no attributes there...I can only guess you are talking about the adverbs. In which case, yes.

[12:02] <FROGGS> arnsholt: no idea

[12:02] <lizmat> sorry, yes, adverbs

[12:02] <lizmat> *sigh*  :-(

[12:02] <FROGGS> the P5 lib has .name as "foo:bar", and "bar" is .localname

[12:03] <jnthn> FROGGS: And presumably .namespace or so for getting the foo?

[12:03] <FROGGS> .ns, aye

[12:03] <FROGGS> there is .ns.prefix (will change it to .ns.name probably), and .ns.uri and some more

[12:03] <jnthn> lizmat: On the upside, each of the multi candidates is quite short and isn't doing much in the way of introspection.

[12:03] <arnsholt> Yeah, I think that's the correct way

[12:04] <FROGGS> arnsholt: with .localname?

[12:04] <lizmat> jnthn: yes, that's why it's that way

[12:04] <lizmat> otherwise a lot of checks would need to be done inside a single candidate

[12:05] <FROGGS> arnsholt: the naming in libxml2 is quite inconsistent and weird btw...

[12:05] <lizmat> jnthn: re code size: Range could become smaller, as no special casing for Int would be needed there anymore

[12:07] <lizmat> I also wonder whether adding MMD for infix:<..> and friends would help

[12:07] <FROGGS> arnsholt: do you have any resources at that about a good naming scheme?

[12:07] <arnsholt> Don't have any good references, sorry

[12:08] <arnsholt> But "local name" sounds familiar

[12:08] <FROGGS> yeah, it sounds sane in some way

[12:10] *** KCL joined
[12:11] *** denis_boyun_ joined
[12:12] <moritz> can somebody recommend a book on evidence-based software engineering practices?

[12:12] <moritz> I've come across " Making Software: What Really Works, and Why We Believe It" by Andy Oram and Greg Wilson

[12:13] <moritz> it looks interesting, but also pretty heterogenous (many authors) and rather thick

[12:13] *** KCL_ left
[12:13] <moritz> something more condensed would be very welcome

[12:13] <moritz> (unless you all recommend it very highly)

[12:14] <FROGGS> I can't recommend anything

[12:19] <pmurias> masak: 007 will only have integers?

[12:22] <masak> good afternoon, #perl6

[12:22] <masak> pmurias: I imagine so, yes.

[12:22] <masak> I'm glad y'all like the README.md :)

[12:23] <masak> it was fun to write.

[12:23] <masak> here it is again for those who missed it: https://github.com/masak/007/blob/master/README.md

[12:25] <masak> pmurias: floats and complex numbers are not really on the critical path to exploring macros ;)

[12:26] *** Rounin left
[12:27] <arnsholt> +1 to that =)

[12:27] <pmurias> adding float support with macros could prove informative ;)

[12:31] *** kjs_ left
[12:36] <masak> well, there's a thought there that I keep returning to: "adding support for [data type X], using macros"

[12:36] <masak> but I usually reach the conclusion that it's not that feasible. and probably the wrong tool for the job.

[12:36] <masak> macros are good for adding syntax, keywords, and influencing control flow.

[12:37] <masak> they're not that good at runtime things, like values and their types.

[12:37] *** pmurias left
[12:40] <moritz> well, maybe for floating point literals

[12:43] <arnsholt> Yeah. You can add pretty much whatever you want with macros (cf. TeX), but it might not always be the best way to go about it (cf. TeX, again =)

[12:44] *** zakharyas joined
[12:45] <masak> moritz: literals should be fine, as long as I implement macro term:<...>

[12:46] <masak> moritz: the problem is more on the other end: what should such a macro emit?

[12:47] *** mr-foobar left
[12:47] <arnsholt> Same thing as an expression macro, no?

[12:47] <masak> it seems reasonable to reply "sign, mantissa, and exponent, encapsulated in a suitable data structure". in 007, arrays could do that, but then you'd have to somehow distinguish a "normal" array value from one that pretends to encode a float.

[12:48] <arnsholt> Oh, that kind of "what should it emit". Never mind me

[12:48] <masak> and (crucially) the whole runtime has to make that distinction, which turns the change into a nastily global one.

[12:48] <masak> hence "not that feasible".

[12:48] <moritz> well, just add (primitive) custom types to the language

[12:50] <arnsholt> Well, you could always ignore that particular aspect of the problem

[12:50] <moritz> round to the nearest integer :-)

[12:51] <arnsholt> In Perl 6 a new literal would for example create an instance of a class, but 007 can very well choose to ignore problems of typing

[12:51] <arnsholt> New datatypes simply being lists under the hood is very much in the Lisp tradition, after all =)

[12:52] *** Rounin joined
[12:56] <moritz> how does lisp folks distinguish the various data types that are all implemented as lists?

[12:57] <arnsholt> They don't, necessarily

[12:58] <arnsholt> My thought is that 007 can just ignore typing concerns like that. In Perl 6 the existing type system should be fine, I think

[13:01] *** zakharyas left
[13:03] *** denis_boyun_ left
[13:03] <moritz> https://news.ycombinator.com/item?id=8906331 another discussion about the "Why Perl Didn't Win" article from last year

[13:08] *** kjs_ joined
[13:09] *** Ben_Goldberg joined
[13:10] *** Ben_Goldberg left
[13:11] *** Ben_Goldberg joined
[13:17] <rurban> moritz: Just an old rehash from the typical perl6 killed perl5 mindset

[13:18] <rurban> not a really original and educated post

[13:21] *** booly-yam-4706_ joined
[13:23] <woolfy> moritz: what rurban said, plus, please don't read that shit, it is what makes me depressed every so often, and makes me unfriend people on Facebook and ignore people on irc...

[13:23] <woolfy> moritz: I will not ignore you, just be clear!

[13:24] <moritz> woolfy: now I'm glad

[13:31] <jnthn> Well, it seems the thing I ran into with the mixin stuff has been discovered by lizmat++ before...

[13:31] <jnthn> http://irclog.perlgeek.de/perl6/2014-06-26#i_8936466 and http://irclog.perlgeek.de/perl6/2013-08-30#i_7523993

[13:32] <jnthn> Took me multiple hours to get to the bottom of what I think is going on...

[13:32] <jnthn> And now I want lunch. But at least we might get a fix for a more general issue out of this, even if it's blocking the stuff I actually want to be doing. :)

[13:32] <lizmat> that's always good  :-)

[13:33] <jnthn> Aye. Will see if I can fix it post-eating. :)

[13:33] *** denis_boyun_ joined
[13:35] <rurban> t/spectest.data seems to be not adjusted yet: Missing test file: t/spec/S32-list/uniq.t

[13:36] <rurban> woolfy: It's not shit. that's the bad reality out there. we need to educate the people

[13:37] * JimmyZ we will keep silent on that

[13:37] <woolfy> rurban: it becomes shit when Perl-people start believing that they are working in a dead or dying language, and start iterating it to other Perl-people, utterly de-motivating developers on the way...

[13:37] <JimmyZ> *hopes we

[13:38] <lizmat> rurban: you need a more recent rakudo then

[13:38] <lizmat> it *is* in there now

[13:38] <moritz> it's unique.t now

[13:38] <lizmat> if you want a quick fix, symlink it locally to unique.t

[13:41] <rurban> I've got the new test, saw it. just got this warning also

[13:44] *** leont joined
[13:48] <moritz> lizmat: S17-lowlevel/lock.t is commented out in t/spectest.data -- is that as a flapper?

[13:48] <lizmat> yes

[13:54] *** virtualsue joined
[13:55] <masak> arnsholt: you opened my eyes a bit. if I just give up and accept that (a) my float is an array, (b) if people want to misuse it, they can -- then I can basically have macros implement floats.

[13:56] <masak> even better, that works for any data type. I could even build a MOP that way.

[13:56] <vendethiel> *g*

[13:56] <arnsholt> Welcome to Lisp! ;)

[13:57] * masak attempts to implement custom operators, which are all but switched on in 007 already

[13:59] <masak> how does one say "commit to this rule" again? was that `::` ?

[14:01] <masak> m: grammar G { rule foo { OH :: HAI } }; say "alive"

[14:01] <camelia> rakudo-moar 20d5ef: OUTPUT«===SORRY!=== Error while compiling /tmp/SkWOK0AkRH␤:: not yet implemented␤at /tmp/SkWOK0AkRH:1␤------> grammar G { rule foo { OH ::⏏ HAI } }; say "alive"␤»

[14:01] <masak> oh, you've got to be *kidding* me.

[14:02] * masak adds a bunch of red cells to http://perl6.org/compilers/features

[14:02] <masak> n: grammar G { rule foo { OH :: HAI } }; say "alive"

[14:02] <camelia> niecza v24-109-g48a8de3: OUTPUT«(signal ABRT)Stacktrace:␤␤  at <unknown> <0xffffffff>␤  at (wrapper managed-to-native) object.__icall_wrapper_mono_gc_alloc_string (intptr,intptr,int) <0xffffffff>␤  at (wrapper alloc) object.AllocString (intptr,int) <0xffffffff>␤  at string…»

[14:03] <masak> Niecza is feeling a bit under the weather. but I bet it implements `::`.

[14:07] *** beastd joined
[14:08] <dalek> features: a807c94 | masak++ | features.json:

[14:08] <dalek> features: [features.json] add "::"

[14:08] <dalek> features: 

[14:08] <dalek> features: Currently NYI in Rakudo (though I think we had it before, sometime pre-ng).

[14:08] <dalek> features: review: https://github.com/perl6/features/commit/a807c94b9b

[14:09] <nwc10> Double colon LTA? stopper

[14:10] <masak> nwc10: see evals above.

[14:10] <masak> oh, "LTA". hm.

[14:10] <masak> "LTM", hold on :)

[14:10] <masak> it would be nice if we could stop LTA sometimes...

[14:10] <jnthn> masak: You can use {} to terminate LTM.

[14:11] <dalek> features: 06ae482 | masak++ | features.json:

[14:11] <dalek> features: [features.json] s/LTA/LTM/ typo

[14:11] <dalek> features: 

[14:11] <dalek> features: nwc10++

[14:11] <dalek> features: review: https://github.com/perl6/features/commit/06ae482345

[14:11] <masak> jnthn: thanks. I'll try that.

[14:11] <masak> jnthn: is the behavior *exactly* identical? can we use the `{}` semantics to implement `::` ?

[14:12] <jnthn> masak: I don't think it's identical, no, it's just that they are equally good at LTM termination and that's what, afaik, STD relies on it for.

[14:12] <lizmat> m: say 1.5 ~~ 1^..^2   # this is a bit of a WAT to me

[14:12] <camelia> rakudo-moar 20d5ef: OUTPUT«True␤»

[14:12] <FROGGS> no, it differs wrt backtracking IIRC

[14:13] <jnthn> masak: Which is largely why it didn't get implemented yet, I guess; there's a workaround that's usually good enough. :)

[14:13] <jnthn> lizmat: Why?

[14:13] <masak> lizmat: then we have different understandings of what 1^..^2 means.

[14:13] <jnthn> m: say 1 ~~ 1^..^2

[14:13] <camelia> rakudo-moar 20d5ef: OUTPUT«False␤»

[14:13] <jnthn> m: say 1 ~~ 1..^2

[14:13] <camelia> rakudo-moar 20d5ef: OUTPUT«True␤»

[14:13] <masak> lizmat: does it help if you think of it as an intercal on the real line?

[14:13] <jnthn> Looks like it does what I want.

[14:13] <jnthn> *I'd

[14:13] <masak> interval*

[14:14] <lizmat> I guess I'm thinking too much int  :-)

[14:14] <jnthn> .oO( COME FROM the_real_line )

[14:14] <masak> lizmat: with the ^ thingies excluding *only* one real number.

[14:14] <lizmat> yeah, gotcha

[14:15] <masak> jnthn: my reason for adding it to the compiler comparison table is *purely* to shame us all into implementing it. the fact that we once had the feature only makes it more depressing that we don't now.

[14:15] *** eternaleye left
[14:17] <jnthn> masak: I don't remember us having it, tbh.

[14:17] <jnthn> masak: It hasn't been there so long as I've been aware of the regex engine internals, at least.

[14:23] <nwc10> masak: so I guessed right that there was someting LTA with the "LTA"? :-)

[14:26] *** spider-mario left
[14:29] *** tinyblak_ joined
[14:32] *** anaeem1 left
[14:33] *** tinyblak left
[14:33] <FROGGS> masak: btw, I was thinking about implementing ::, :::, ::::, <cut> and <commit>... but after reading the spec carefully I shuddered

[14:33] <FROGGS> my regex engine backtracking foo is not good enough

[14:37] *** anaeem1_ joined
[14:53] <masak> "fu".

[14:55] <jnthn> "fu2!" :P

[14:56] * jnthn has sorted out his flights for FOSDEM o/

[14:56] *** denis_boyun_ left
[14:56] <lizmat> ;-)

[14:56] *** kurahaupo joined
[14:56] <jnthn> Arrive (well, plane lands) at 1pm on the 30th

[14:58] <lizmat> well in time for delirium tremens

[14:58] <jnthn> ;)

[14:59] <jnthn> Only if I finished writing my talk!

[14:59] <lizmat> :-)

[15:00] *** BenGoldberg joined
[15:02] *** zakharyas joined
[15:05] * masak .oO( sorry about slides 26..51 being all shaky-like. that's as far as I got before the delirium tremens )

[15:07] *** kjs_ left
[15:08] <masak> m: grammar G { regex TOP { <foo> }; proto rule foo {*}; rule foo:one { sub {} foo }; rule foo:two { \w+ \w+ } }; say ?G.parse("sub bar")

[15:08] <camelia> rakudo-moar 20d5ef: OUTPUT«True␤»

[15:08] <itz> delirium tremens? that's a cafe in Belgium isn't it? :)

[15:08] <yoleaux> 17 Jan 2015 20:24Z <lizmat> itz: what happened to szabgab's post on pl6anet.org ?

[15:08] <masak> if the `{}` commits the parse to foo:one, shouldn't the above parse fail?

[15:08] <itz> lizmat: it came back

[15:08] <masak> itz: it's also a beer. http://www.ratebeer.com/beer/delirium-tremens/1039/

[15:14] *** kurahaupo left
[15:15] <lizmat> itz: I'm not seeing any of them?

[15:16] <jnthn> masak: I didn't say it commits, I said it terminates LTM.

[15:16] <jnthn> masak: As in, ends, the declarative prefix

[15:16] <lizmat> itz: Delirium is the bar where people hang out the night before FOSDEM

[15:16] <masak> jnthn: hm. ok.

[15:16] <masak> how do I make a rule commit at some point, and fail the whole parse if the rule fails?

[15:17] <lizmat> itz: http://deliriumcafe.be

[15:17] <jnthn> The Perl 6 grammar usually does something like 'sub' [ ...what we want... || <.panic: 'OH NOES'> ] }

[15:17] <masak> ok, that works, I guess.

[15:17] <jnthn> Well, it also means you get a good error. :)

[15:18] <masak> right.

[15:21] *** rurban left
[15:22] <dalek> rakudo/6pe-mop: f21a64c | jnthn++ | src/Perl6/ (2 files):

[15:22] <dalek> rakudo/6pe-mop: Keep compiler callbacks in place during optimizer.

[15:22] <dalek> rakudo/6pe-mop: 

[15:22] <dalek> rakudo/6pe-mop: The optimizer may trigger compilation of things that it calls - in

[15:22] <dalek> rakudo/6pe-mop: the setting because it defines many built-ins, but also in normal

[15:22] <dalek> rakudo/6pe-mop: code that uses, for example, 'is pure'. This prevents us from

[15:22] <dalek> rakudo/6pe-mop: removing fixup infrastructure too early. A pre-requisite for fixing

[15:22] <dalek> rakudo/6pe-mop: problems with multis that get run during compilation when a subclass

[15:22] <dalek> rakudo/6pe-mop: has derived the proto.

[15:22] <dalek> rakudo/6pe-mop: review: https://github.com/rakudo/rakudo/commit/f21a64c2a4

[15:24] *** brrt joined
[15:24] <brrt> (i suppose most of you have seen the 'why perl didn't win' article now)

[15:25] <brrt> does it make sense to even write and post a counterargument?

[15:25] <lizmat> brrt: it's old news

[15:25] <lizmat> but feel free to  :-)

[15:25] <brrt> :-)

[15:25] *** rurban joined
[15:25] <moritz> brrt: it's from Aug 2014

[15:25] <brrt> o really?

[15:25] <itz> lizmat: I'm seeing szabgab's feed now .. I assume his server was down at some point yesterday since it wasn't displayed then

[15:25] <moritz> brrt: just now on hackernews again

[15:26] <itz> I've found avoiding perl postings on mainstream tech sites a good idea particularly if it's "old news" from last year

[15:27] <brrt> i'll brb. the weakness of that argument is that it focuses only on the programmers, as if they're making the decisions

[15:27] <brrt> :-)

[15:28] *** denis_boyun_ joined
[15:28] *** kurahaupo joined
[15:31] *** brrt left
[15:34] *** denis_boyun_ left
[15:36] <lizmat> jnthn: what's the 2nd parameter to p6parcel for ?

[15:36] <lizmat> ENODOC  :-(

[15:36] <jnthn> lizmat: "Replace nulls with this value", iirc

[15:36] <lizmat> ah, ok

[15:38] *** denis_boyun joined
[15:45] <lizmat> m: class A is Range { has int $.a }; nqp::getattr(A.new(0,10),A,q/$!a/)   # sort of expect this to work

[15:45] <camelia> rakudo-moar 20d5ef: OUTPUT«No such method 'BUILD' for invocant of type 'A'␤  in method new at src/gen/m-CORE.setting:8278␤  in block <unit> at /tmp/f5MACDNJqR:1␤␤»

[15:46] <lizmat> oops

[15:46] *** BenGoldberg left
[15:46] <jnthn> Yes, that's the danger of non-standard new, BUILD, etc.

[15:47] <lizmat> no, locally I get another error

[15:47] <lizmat> P6opaque: no such attribute '$!a'

[15:49] <JimmyZ> I think somewhere is using = for nqp:create, it want :=

[15:49] <jnthn> Hm, mixin caching helps a bit. 100,000 mixins benchmark now runs in a tenth of the time it used to. :)

[15:49] <lizmat> :)

[15:51] <lizmat> JimmyZ: hmmm....

[15:52] *** denis_boyun left
[15:54] *** grondilu joined
[15:56] <jnthn> m: say 13866276 - 12781785

[15:56] <camelia> rakudo-moar 20d5ef: OUTPUT«1084491␤»

[15:56] <jnthn> Wow, 1MB off CORE.setting from the mix-in re-use too

[15:56] <jnthn> Turns out we generated a LOAD of them.

[15:57] <jnthn> Because of using them to add precedence info.

[15:57] *** booly-yam-4706_ left
[15:58] *** leont left
[15:58] <jnthn> And a bit more than 3MB off the process base memory.

[16:00] <jnthn> And some spectest fails. Aww.

[16:01] <arnsholt> jnthn++ # smo-pe

[16:02] <dalek> rakudo/6pe-mop: aa14b2a | jnthn++ | src/Perl6/World.nqp:

[16:02] <dalek> rakudo/6pe-mop: Track and update clones of uncompiled coderefs.

[16:02] <dalek> rakudo/6pe-mop: 

[16:02] <dalek> rakudo/6pe-mop: This happens if a proto method in a base class is cloned as part of

[16:02] <dalek> rakudo/6pe-mop: deriving a proto for a subclass, and afterwards the proto in the

[16:02] <dalek> rakudo/6pe-mop: base class was invoked before the compilation process was over. The

[16:02] <dalek> rakudo/6pe-mop: lack of update led to a problem locating the appropriate static code

[16:02] <dalek> rakudo/6pe-mop: object during serialization.

[16:02] <dalek> rakudo/6pe-mop: review: https://github.com/rakudo/rakudo/commit/aa14b2ae20

[16:06] <dalek> rakudo/6pe-mop: 4c52df6 | jnthn++ | src/Perl6/Metamodel/ (2 files):

[16:06] <dalek> rakudo/6pe-mop: Implement per-class mixin cache.

[16:06] <dalek> rakudo/6pe-mop: 

[16:06] <dalek> rakudo/6pe-mop: Uses the 6model parametric extensions to handle the interning of them.

[16:06] <dalek> rakudo/6pe-mop: We get some spectest failures out of this, though they may be showing

[16:06] <dalek> rakudo/6pe-mop: up an existing, somewhat hiding, bug. On the upside: 100,000 mixins

[16:06] <dalek> rakudo/6pe-mop: benchmark runs in 10% of the time, CORE.setting shrinks by 1MB, and

[16:06] <dalek> rakudo/6pe-mop: perl6 -e "loop { }" has over 3MB knocked off it too.

[16:06] <dalek> rakudo/6pe-mop: review: https://github.com/rakudo/rakudo/commit/4c52df6f88

[16:13] <jnthn> Hm, curious.

[16:13] <jnthn> role R { }; class C { }; for ^100000 { C.new.^mixin(R) } # runs in 0.93s, including startup

[16:14] <jnthn> role R { }; class C { }; for ^100000 { C.new does R }; # 4.78s

[16:14] <timotimo> "does" causes global deopt, but ^mixin doesn't?

[16:14] <jnthn> What does does do?

[16:14] <jnthn> timotimo: Nope.

[16:14] *** xfix left
[16:14] <jnthn> It's the VM-level changetype op that triggers it.

[16:15] <timotimo> mhm

[16:15] <timotimo> is 6pe-mop at spectest success again? :)

[16:15] <jnthn> No.

[16:16] <jnthn> But it's not going to be a merge candidate for a while.

[16:16] <timotimo> oh

[16:16] <timotimo> OK

[16:17] <jnthn> Since 6pe will need to be up to scratch on Moar and JVM, and at least not regression-inducing on Parrot.

[16:18] <jnthn> Plus the mixin cache thing is just the easiest thing I could do to start giving it some exercise.

[16:21] <jnthn> Other things I'll be doing with it include coercion types, typed array/hash improvements, and it's also one ingredient for native arrays.

[16:22] <jnthn> And hopefully fixing various role-related pre-comp bugs along the way. :)

[16:22] * jnthn away for a bit

[16:23] <timotimo> ah, yes of course

[16:23] <timotimo> i'm only interested in the moar aspect at the moment :P

[16:23] <timotimo> because i'm also interested in what can possibly be achieved with spesh

[16:27] *** pmurias joined
[16:27] <pmurias> jnthn: is 6pe something that I should be concered about for nqp-js?

[16:30] *** KCL left
[16:33] *** jluis_ left
[16:37] *** KCL_ joined
[16:38] *** mr-foobar joined
[16:47] *** virtualsue_ joined
[16:49] *** virtualsue left
[16:49] *** virtualsue_ is now known as virtualsue

[16:49] <psch> hi #perl6 \o

[16:50] *** telex left
[16:50] *** salv0 left
[16:52] <psch> FROGGS: i had had a look at the composetype op a bit ago, but i don't quite see how to work that into what i have

[16:52] *** telex joined
[16:52] <FROGGS> well, I don't know what you have :o)

[16:54] <psch> https://github.com/peschwa/rakudo/blob/javahow-in-p6/src/vm/jvm/core/JavaHOW.pm

[16:54] <psch> although that's probably the wrong-ish aproach in at least one other aspect - namely the new op near the bottom

[16:54] <psch> should probably do that similar to how we do other types, i.e. declare them in BOOTSTRAP

[16:55] <psch> i've tried throwing more MOP-roles at it and that didn't help... :P

[16:57] <arnsholt> The composetype op is basically to send information from Perl 6 land to the REPR instance. Not sure if that's what you need or not

[16:57] <psch> basically, what i'm trying is to write the JavaHOW in Perl6 instead of NQP, so i can access other Perl6-level types to automatically get accessors to native fields

[16:58] <psch> and do this automatically: https://gist.github.com/peschwa/0f8830ba3c6a2eb852ba

[16:59] <psch> for which the first step is having JavaHOW in the CORE.setting instead of inside the Metamodel, if i understood jnthn++ correctly

[16:59] <masak> "What does does do?" is a screwey sentence. :)

[17:00] <arnsholt> Use-mention is always a bit weird =)

[17:01] <arnsholt> psch: Right. Not really composetype, I agree

[17:02] <arnsholt> I'm not really familiar with what is required for a HOW in Perl 6, but probably a liberal application of nqp::ops and a certain amount of care in whether the objects you're working with are NQP or Perl 6 objects

[17:02] <masak> arnsholt: speaking of use-mention: https://twitter.com/wokingwriter/status/555839797844271105 (#autopun)

[17:04] <vendethiel> psch: "@methods[+@methods] =" isn't there a .push?

[17:05] <psch> vendethiel: yes, there is, but that's a VMArray iirc

[17:05] <vendethiel> makes sense, noted

[17:05] <FROGGS> psch: look at this example: https://github.com/perl6/nqp/blob/master/t/serialization/02-types.t#L115

[17:05] <arnsholt> masak: Oooh, I love it!

[17:05] <FROGGS> psch: forget about the serialization bit... but line 132 is rather important I bet

[17:06] <psch> FROGGS: so compose attaches the Method to the type and makes it invokable?

[17:06] <psch> (among other things)

[17:07] <FROGGS> psch: I think so.... you can test what happens if you comment out that line and runt the test

[17:07] <arnsholt> Not quite, I think

[17:08] <arnsholt> The call to HOW.compose isn't the composetype

[17:08] <FROGGS> ohh

[17:08] <arnsholt> Grep for composetype in src/Perl6/Metamodel for examples

[17:08] <FROGGS> I thought so and that's why I mentioned composetype in the first place

[17:09] <arnsholt> Also: https://github.com/perl6/nqp/blob/master/docs/6model/repr-compose-protocol.markdown

[17:09] <psch> that's another thing, JavaHOW.nqp has "method is_composed($obj) { 1 }", and .^add_method works

[17:09] <FROGGS> (on an unrelated note, XML::LibXML now has working xpaths...)

[17:09] <psch> simply running the same code in CORE.setting instead of from the Metamodel gives me the mentioned "no such postcircumfix:<( )> for type 'Method'"

[17:09] *** salv0 joined
[17:09] <arnsholt> Those are the things the standard 6model REPRs understand. You are of course free to add new things to your own REPR

[17:09] <psch> which also means there's no .invoke

[17:10] <psch> *on Method

[17:15] *** booly-yam-4706_ joined
[17:21] <psch> i now wonder if i actually was justified in writing add_method myself in the JavaHOW instead of does'ing MethodContainer... currently running build will tell i suppose

[17:27] <lizmat> .oO( what does does and but do? )

[17:27] <lizmat> masak: ^^^

[17:28] <moritz> m: say Submethod ~~ Method

[17:28] <camelia> rakudo-moar 20d5ef: OUTPUT«False␤»

[17:29] *** booly-yam-4706_ left
[17:31] * masak just saw http://whiteknight.github.io/2015/01/15/parrottheend.html

[17:31] <masak> haven't read it yet.

[17:31] <moritz> m: class A { submethod x() { say 42 } }; say A.^can("x").perl

[17:31] <camelia> rakudo-moar 20d5ef: OUTPUT«()␤»

[17:31] <moritz> is that correct?

[17:31] <masak> m: class A { submethod x { say 42 } }; A.new.x

[17:32] <camelia> rakudo-moar 20d5ef: OUTPUT«42␤»

[17:32] <masak> moritz: I'd say "no", since you can call it.

[17:32] <vendethiel> should "can" take another parameter, for private method, or for walking the inheritance chain?

[17:32] *** anaeem1_ left
[17:33] <masak> is that a separate question? submethods are not private.

[17:33] *** anaeem1 joined
[17:33] <vendethiel> that's an idea

[17:33] <masak> if you ask me, it makes little sense to ask .can questions about the non-public interface of an object.

[17:34] <moritz> vendethiel: there are ways to walk private methods through the MOP if you really want/need to

[17:35] <moritz> like .^find_private_method($name) and .^private_method_table

[17:35] <moritz> walking the MRO makes little sense for that, because they aren't inherited

[17:35] *** spider-mario joined
[17:37] *** kjs_ joined
[17:37] *** anaeem1 left
[17:40] *** mvuets joined
[17:43] *** rmgk is now known as Guest85303

[17:43] *** rmgk_ joined
[17:43] *** Guest85303 left
[17:43] *** rmgk_ is now known as rmgk

[17:46] *** Vlavv_ joined
[17:48] *** anaeem1_ joined
[17:50] *** Rounin left
[18:00] <dalek> doc: 91e654e | moritz++ | type-graph.txt:

[18:00] <dalek> doc: type graph: s:g/"Perl6::Metamodel"/Metamodel/

[18:00] <dalek> doc: review: https://github.com/perl6/doc/commit/91e654eca3

[18:06] *** anaeem1_ left
[18:06] *** booly-yam-4706_ joined
[18:06] <dalek> doc: 2c651c3 | moritz++ | lib/Type/Metamodel/ClassHOW.pod:

[18:06] <dalek> doc: more s:g/"Perl6::Metamodel"/Metamodel/

[18:06] <dalek> doc: review: https://github.com/perl6/doc/commit/2c651c38f2

[18:06] *** anaeem1 joined
[18:07] *** anaeem1 left
[18:08] *** anaeem1 joined
[18:08] <jnthn> pmurias: (6pe) Yes, but you may want to wait for the dust to settle a bit more before porting it.

[18:11] *** booly-yam-4706_ left
[18:11] *** pnu left
[18:12] *** araujo joined
[18:12] *** araujo left
[18:12] *** araujo joined
[18:12] *** clkao_ left
[18:12] *** pnu joined
[18:12] *** booly-yam-4366 joined
[18:12] *** clkao joined
[18:13] <jnthn> About

[18:13] <jnthn>  m: class A { submethod x() { say 42 } }; say A.^can("x").perl

[18:13] <camelia> rakudo-moar 20d5ef: OUTPUT«()␤»

[18:13] <jnthn> Pretty sure that one has to be a bug.

[18:13] <jnthn> I can easily imagine how it'd happen too :)

[18:13] <jnthn> RT it; it's likely a very easy fix.

[18:13] <jnthn> cooking &

[18:13] * masak RTs it

[18:16] <masak> did Parrot "kick [Rakudo] out" of the Parrot repo? that's not quite how I remember it.

[18:16] <lizmat> context?

[18:17] <lizmat> ah, I see it

[18:19] *** Sqirrel left
[18:20] <masak> reading the postmortem of a Parrot developer is a little bit like reading something from a mirror world.

[18:20] <masak> because I'm so squarely placed in the Perl 6 side of things.

[18:21] *** regreg joined
[18:21] <masak> as Perl 6 people we can say "oh well, things might not always have evolved as quickly or as successfully as we hoped/planned -- but at least we're not Parrot"

[18:22] <masak> lizmat++ # "Edsel" meme, "everything to everybody"

[18:22] *** Sir_Ragnarok left
[18:25] <masak> another thought: many in the Parrot project saw the benefit that could have been gained by re-hosting on top of 6model. they didn't have the skills to invent 6model (or similar) in the first place, but they saw the advantages of it. but even as they wanted to move to it, *they were unable to do so* -- due to some unknown mix of technical debt and lack of tuits.

[18:25] *** booly-yam-4366 left
[18:26] <masak> I also note that WhiteKnight's Parrot postmortem has basically the same dark shade of grey background as does Dan's Parrot postmortem :)

[18:26] <masak> apparently, that's the background to do it in.

[18:27] *** Akagi201_ joined
[18:28] <timotimo> i'm not sure i remember dan's parrot postmortem

[18:28] *** Akagi201 left
[18:31] <skids> That's just the background for the site.  I actually wish liht text on dark was more popular I find it better on my eyes.

[18:32] <timotimo> skids: i recommend "hacker vision" chrome plugin

[18:33] <skids> Maybe I'll give that a spin.  Certainly we are long past the day when you can just set browser colors and expect anything functional to happen.

[18:33] *** FROGGS_ joined
[18:33] *** grondilu left
[18:33] <masak> skids: I know it's the background for the site. I still thought it was a weird coincidence.

[18:33] <masak> skids: maybe Parrot bloggers like that background color.

[18:35] *** kurahaupo left
[18:35] *** booly-yam-4366 joined
[18:35] <masak> "What I do know is that we *did have the good ideas*, we just weren’t able to implement them correctly or quickly enough." -- I think this sums it up. all of it.

[18:36] *** FROGGS left
[18:37] <masak> I said something similar back in 2011. http://irclog.perlgeek.de/perl6/2011-08-23#i_4316480

[18:37] <masak> I *think* M0 was their 6model effort? don't recall exactly. it had something to do with a very small core.

[18:40] <vendethiel> masak: I actually first thought it was the same post :P (I never read whiteknight's)

[18:40] <lizmat> timotimo: dan's post mortem was about PONIE: http://www.sidhe.org/~dan/blog/archives/000435.html

[18:41] <lizmat> or not?  hmmm..  apparently it *was* about parrot

[18:41] <masak> it was about Parrot.

[18:42] *** Sqirrel joined
[18:42] <lizmat> this was the PONIE one, by Jesse Vincent: http://www.nntp.perl.org/group/perl.ponie.dev/2006/08/msg487.html

[18:43] <masak> by the way... assume the Parrot people at some (surely distant) moment wishes to announce the end of the Parrot project. how *do* they do that, given that the project has that name and, yes, is based on that sketch? it'd have to be a helluva convincing announcement.

[18:43] <TimToady> they obviously would have to do it on April 1st

[18:44] <TimToady> pity we probably can't get to beta by then...

[18:44] <pmurias> rurban is still working on parrot...

[18:45] <skids> I'm sure that was just a funny hypothetical.

[18:46] <TimToady> well, we're not really into shooting our wounded, more like "them's as falls behind, gets left behind"

[18:47] <rurban> Mo or lorito is a llvm-like bytecode project, small core, based on the assumption that parrot is fast and c not. ha!

[18:49] <rurban> And the parrot people who destroyed it already left, So they cannot announce anymore that they failed.

[18:49] <rurban> But there still good stuff in it, which can be revived. Esp. threads are good. Better than moar, the rest is better in moar

[18:49] *** adu joined
[18:52] <masak> rurban: I keep seeing absolutely zero evidence that Parrot threads are better in any way at anything.

[18:52] <timotimo> i'm looking forward to a demonstration :)

[18:53] <rurban> masak: maybe you should about it then?

[18:53] <rurban> the demos are out there since 2012, showing linear, lockfree performance. show me that in another vm.

[18:56] <rurban> esp for arrays and hashes

[18:56] <adu> "about it"?

[18:57] <adu> rurban: is "about" a verb?

[18:57] <rurban> read about it

[18:57] <adu> ah

[18:58] <rurban> "Those who cannot read need to walk"

[18:58] <adu> writing is good too

[18:59] <masak> rurban: can you link me to some Perl 6 code running on Parrot showing off this nice threading?

[18:59] <masak> rurban: I'll happily look at any URL you give me.

[19:00] <rurban> Perl6 does not yet support parrot threading

[19:01] <rurban> And I don't know enough nqp to write it by myself

[19:01] <adu> http://blog.klocwork.com/user-documentation/if-you-want-users-to-rtfm-write-a-better-fm/

[19:03] <rurban> The easy to read part is this one: https://perl6advent.wordpress.com/2012/12/11/day-11-parrot-threads/

[19:03] <rurban> with winxed and pir samples

[19:04] <masak> rurban: there is *no* Perl 6 code making use of Parrot's allegedly awesome threading!?

[19:05] <rurban> you are the perl 6 coders. I'm just maintaining parrot

[19:05] <masak> rurban: all this time since 2012, no-one has bothered to show off the fantastically impressive threading *on Parrot* by making it work on Perl 6?

[19:05] <rurban> nobody cared

[19:06] <rurban> and I doubt that perl6 has enough competence in this field to see the bigger picture

[19:06] <rurban> there was a famous flamefest initiated by diakopter when we added native threads

[19:06] <masak> what language is threading awesome in, then? PIR?

[19:06] <timotimo> froggs tried at one point to make something work with parrot threading, was it hypers and math or something?

[19:07] *** booly-yam-4366 left
[19:07] <rurban> and the original author never defended his work, so it stayed

[19:07] *** anaeem1 left
[19:07] <rurban> in parrot of course, not comparable to moars' locked, conservative threading. moar locks on everything

[19:07] <adu> rurban: I care

[19:07] <rurban> so add it

[19:08] <adu> I'm busy working on slangs

[19:08] <pmurias> masak: from an outsider perspective a lot of the parrot folk loved pir

[19:08] *** anaeem1_ joined
[19:09] <rurban> but it's a bit tricky, because you need to track the owner and schedule writer tasks for all updates, if you are not the owner. only owner may write

[19:09] <rurban> all clients who want to write need to do it via little updaters

[19:10] <rurban> so it's basically lockfree but not wait free.

[19:12] *** booly-yam-4366 joined
[19:14] *** zakharyas left
[19:14] <timotimo> so it's basically asynchronous?

[19:15] <masak> rurban: "I am the best chess player in the world. it's just that I don't want to play with other chess players."

[19:17] <pmurias> isn't it a crude for of software transactional memory

[19:17] <masak> rurban: if Parrot has super-awesome threading, and Rakudo is arguably the only client that ever gained any foothold to speak of on Parrot, and Rakudo can't exploit Parrot's threading model, then Parrot effectively doesn't have super-awesome threading.

[19:21] *** kjs_ left
[19:22] <skids> Is it that Rakudo "can't" or that it "hasn't"?

[19:22] <masak> the latter, surely.

[19:22] *** booly-yam-4366 left
[19:22] <lizmat> jnthn: I'm trying to establish whether the ^100 -> while $i  optimization is being done

[19:22] <lizmat> but apparently it doesn't even enter "optimize_for_range" in Optimizer.nqp ?

[19:23] <pmurias> masak: pir is also a parrot client

[19:23] <FROGGS_> my parrot threading tests in nqp resulted in a single cpu core use... because lexical access is only possible from the main thread

[19:23] <rurban> because nqp uses its own broken lexpad implementation

[19:24] <FROGGS_> you can use more cores, but that only works for operations that can be done without lexicals (and adding two bigints uses the lexical &infix:<+>)

[19:24] <masak> pmurias: from my perspective, PIR seems to me to be pessimal for both human authoring and code generation. it might be the single biggest concrete mistake that got perpetuated as a component of Parrot.

[19:24] <masak> pmurias: and no, I do not consider it a client. I consider it technical debt.

[19:24] <timotimo> lizmat: --target=ast and --target=optimize should be a good entry point to figuring out if/whether an optimization is happening

[19:25] <timotimo> though i'd say a tool that can diff trees like that more "prettily" or "domain-knowledgingly" would be helpful

[19:25] <pmurias> rurban: have you looked at STM (software transactional memory)?

[19:27] *** booly-yam-4366 joined
[19:27] <rurban> we looked into it some decades ago, yes.

[19:27] <lizmat> timotimo: if I do an "nqp::say" in optimize_for_range, it should show up when optimizing, no ?

[19:27] <rurban> it's documented in the threads pdd somewhere

[19:28] <timotimo> it should, aye

[19:28] <lizmat> it doesn't  :-(

[19:28] <timotimo> but that requires a full core setting recompile, which takes about 5 minutes. oh wait, we have 2015 now :)

[19:28] <lizmat> yeah, <1minute now

[19:29] <lizmat> $ time perl6 -e 'for ^5000000 { 1 }'   # with optimizing: real	0m3.521s

[19:30] <lizmat> $ time perl6 --optimize=off -e 'for ^5000000 { 1 }'  # without: real	0m4.739s

[19:30] <lizmat> so it *is* optimizing, but apparently not where I think it is  :-(

[19:31] <pmurias> rurban: it seems what you are proposing is a subset of STM

[19:34] <pmurias> rurban: if I remember correctly it adresses one of the best cases for STM

[19:34] <pmurias> it should have excelent peformance

[19:35] <rurban> pmurias: I'm proposing nothing. parrot has excellent threads and nqp does not use it. Not my problem really.

[19:35] <rurban> all the other things are better in moar, but I will catch up sooner or later

[19:37] <pmurias> rurban: do you think parrot threads are enough for all uses?

[19:38] <lizmat> timotimo: ok, it looks to me that if I disable SPESH, there is no difference between using --profile or not

[19:38] <lizmat> *--optimize=off

[19:38] *** regreg left
[19:38] *** Sqirrel left
[19:38] <lizmat> which leads me to think that the difference we see is purely caused by SPESH/JIT

[19:40] *** brrt joined
[19:44] *** Mso150 joined
[19:48] *** davercc`` left
[19:49] *** adu left
[19:49] *** Bucciarati left
[19:51] *** rindolf left
[19:51] <masak> I think my personal conclusion from this discussion is that Parrot people and Perl 6 people are no longer actively communicating across the two communities. nor does there seem to exist much interest in such communication. for some time now -- maybe two-three years.

[19:54] <FROGGS_> that meets my perception

[19:54] <masak> if Parrot's only edge over other established VMs out there is threading, and Rakudo doesn't use it and hasn't since it was built in 2012, then... it's because the communities are no longer in an ongoing relationship.

[19:54] <masak> Perl 6/Rakudo is busy courting MoarVM and (to a lesser extent) the JVM.

[19:55] <masak> Parrot is busy doing who-knows-what.

[19:55] <skids> The impression I get is that there is a hole where an nqp/parrot-focused dev needs to be.

[19:55] *** Bucciarati joined
[19:55] <FROGGS_> solving existing github issues

[19:55] *** Sqirrel joined
[19:56] *** LLamaRider joined
[19:57] * masak read that as "rearranging deck chairs on the Titanic"

[19:57] <FROGGS_> one problem (for me) is the development turn-around for perl6-p is quite huge... it takes a while to recompile nqp-p + rakudo+p, not to mention parrot

[19:59] <FROGGS_> I mean, you can recompile moarvm without needing to touch nqp or rakudo... you can play with the .java files in nqp and you can test perl6-j just like that...

[19:59] <FROGGS_> nothing like that works for parrot/nqp-p

[19:59] <moritz> rurban, masak: iirc somebody did try to use parrot threads with rakudo (maybe FROGGS_++?), and failed, because access to lexicals from threads caused segfaults, or something

[20:00] <moritz> no idea where that idea went

[20:00] <FROGGS_> moritz: yes, and when it did not segfault it was limited to one core...

[20:00] <masak> moritz: ok, that's like half of a data point, then. I remain unimpressed by Parrot's threads.

[20:00] <FROGGS_> and since nobody helped me (from neither side), I left it at that state - sleeping in a github issue

[20:01] <moritz> masak: not trying to prove anything, except that there *was* at least one attempt to use parrot threads from rakudo

[20:01] <masak> FROGGS_: was the github issue ever resolved?

[20:02] <masak> moritz: one attempt, which didn't prove Parrot's threads' superiority, but dug up some segfaults instead.

[20:02] <moritz> and the "nqp uses its own broken lexpads" argument is moot, because parrot's lexpads didn't provide the necessary functionality, so there was a *need* to reinvent them

[20:02] <moritz> masak: yes, we're in violent agreement here

[20:02] *** brrt left
[20:03] <pmurias> the moarvm and parrot threads would have different apis

[20:03] <pmurias> even if Rakudo used the parrot ones

[20:03] <moritz> pmurias: that's fine; the JVM threads have another different API, presumably

[20:04] <pmurias> moritz: why?

[20:04] <moritz> pmurias: why what?

[20:04] <skids> Well, that depends on exactly why nqp lexpads were broken.  Is it just bitrot?

[20:05] <FROGGS_> masak: no, not resolved: https://github.com/parrot/parrot/issues/889

[20:05] <pmurias> moritz: why does Rakudo on JVM expose threading differently than on MoarVM?

[20:05] <dalek> rakudo/nom: b76f601 | lizmat++ | src/Perl6/Optimizer.nqp:

[20:05] <dalek> rakudo/nom: Fix broken for ^1000 -> while $i < 1000 opt

[20:05] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/b76f601a1c

[20:05] <moritz> skids: I see no evidence that they are, except rurban's comment about them being broken in context of parrot threads

[20:05] <moritz> pmurias: it doesn't. JVM and MoarVM presumably have different thread APIs

[20:06] <moritz> pmurias: but nqp + rakudo unify them

[20:06] <pmurias> but it won't be possible on Parrot threads

[20:06] <FROGGS_> pmurias: why not?

[20:06] <moritz> pmurias: which is why I meant it's fine that parrot has another different API - as long as it's powerful enough for rakudo + nqp to unify it with the others

[20:06] <masak> FROGGS_: that github issue is like a parody of the broken communication between Perl 6 and Parrot.

[20:06] <FROGGS_> masak: :o)

[20:07] <moritz> m: say nqp::null().perl

[20:07] <camelia> rakudo-moar 20d5ef: OUTPUT«Cannot call method 'perl' on a null object␤  in block <unit> at /tmp/uYMkPpdZBq:1␤␤»

[20:07] <pmurias> FROGGS_: I can't imagine how to unify their api

[20:07] *** rmgk left
[20:07] <masak> "If we can't compute in parallel when lexicals are involved, then I'm not sure how usable it is."

[20:07] <pmurias> FROGGS_: they parrot threads are a stripped down STM

[20:08] <masak> when *lexicals* are involved.

[20:08] <masak> well, good thing not much of my everyday code uses *lexicals*.

[20:08] <dalek> rakudo/nom: 6279e12 | moritz++ | t/spectest.data:

[20:08] <dalek> rakudo/nom: Run S16-io/print.t

[20:08] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/6279e12cb1

[20:09] <masak> rurban: yeah, it's not looking good for Parrot threads. :(

[20:09] *** kjs_ joined
[20:09] <moritz> masak: be careful with sarcasm on the Internet

[20:09] * pmurias is not sure what mocking rurban is trying to accomplish

[20:10] *** rmgk joined
[20:10] <FROGGS_> masak: well, you should in general try to avoid accessing lexicals, or rather avoid to share variables between threads...

[20:10] *** zakharyas joined
[20:10] <FROGGS_> masak: the problem is more that our routines are lexicals too

[20:11] <dalek> doc: 397e0c0 | moritz++ | lib/Type/Metamodel/PrivateMethodContainer.pod:

[20:11] <dalek> doc: Document Metamodel::PrivateMethodContainer

[20:11] <dalek> doc: review: https://github.com/perl6/doc/commit/397e0c0c90

[20:11] *** darutoko left
[20:12] <moritz> let's ask a different question: what advantages does rakudo-parrot offer over rakudo-moar *right now*?

[20:12] <lizmat> https://www.youtube.com/watch?v=Iu7vySQbgXI

[20:13] <FROGGS_> lizmat: :o)

[20:16] <skids> So OOC, if OSthread M owns X, OSthread A tells M to write X, OSthread B tells M to write X, and thread A reads X, how does A know to use B's value for X and desist using the value it wrote, under the "lock-free" model?

[20:16] *** brrt joined
[20:23] *** denis_boyun_ joined
[20:26] <FROGGS_> skids: good question

[20:28] <lizmat> skids: how does OSthread M "own" X ???

[20:28] <skids> Just on a surface level the parrot model has advantages with 2-thread sharing, and possibly a downside of more bookeeping vs locking.

[20:28] <lizmat> skids: or was that about the parrot model?

[20:28] <skids> lizmat: according to the parrot model only one OS thread has write access to any particular var.

[20:28] <lizmat> ah, ok

[20:34] *** denis_boyun_ left
[20:34] *** adu joined
[20:36] *** denis_boyun_ joined
[20:38] <masak> pmurias: I would be delighted if Parrot threads were useful enough to be measurable against anything else. unfortunately, they seem several steps away from that. this makes me sad, especially if it's true as several people claim that threads is the only remaining edge Parrot has on other VMs.

[20:40] <pmurias> masak: they are usable from winxed

[20:43] <masak> moritz: thanks for the warning about sarcasm. that was very helpful.

[20:44] <masak> pmurias: does winxed have a community where I could discuss their experience of the Parrot threads?

[20:44] *** adu left
[20:45] <pmurias> masak: you can ask the stm community how they feel about not using any reads in their transactions

[20:45] <pmurias> masak: parrot threads are a stm subset

[20:46] <pmurias> so we could sort of fake using them on top of pugs

[20:47] *** anaeem1_ left
[20:52] *** denis_boyun_ left
[20:52] *** LLamaRider left
[20:54] <FROGGS_> huh "Streaming decode NYI for encoding 4"

[20:54] <FROGGS_> I tried to: "example/utf-16-2.xml".IO.slurp( :enc<utf-16> )

[20:55] <FROGGS_> :o(

[21:00] *** Mso150_o joined
[21:04] *** Mso150 left
[21:09] *** jakesyl joined
[21:11] *** Mso150_o left
[21:11] *** zakharyas left
[21:11] *** Mso150 joined
[21:12] <masak> I think the consensus in the Perl 6 universe is that (a) STM is an interesting solution to apply in some cases, a bit like Prolog is, but it's not universal, and (b) where the composability of STM really shines is with fully immutable runtime models, which figure heavily in languages like Haskell, but basically not at all in Perl 6.

[21:12] <masak> at least that's what I've come to understand. I picked up (a) during the Pugs days, and (b) in the past few years.

[21:13] *** KCL_ left
[21:14] *** Ovid joined
[21:14] *** Ovid is now known as Guest12460

[21:15] *** Guest12460 is now known as CurtisOvidPoe

[21:15] <CurtisOvidPoe> m: class Point { has $.x; has $.y; multi method set(:$x = $.x) { $!x = $x }; multi method set(:$y = $.y) { $!y = $y } }; my $p = Point.new( x => 5, y => 2 ); $p.set( y => -3 ); say $p.y;

[21:15] <camelia> rakudo-moar b76f60: OUTPUT«2␤»

[21:16] <CurtisOvidPoe> I’ve created a point object, trying to use named multi methods and tried to set y to -3, but it still says that it’s 2.

[21:16] <masak> CurtisOvidPoe: named params are optional by default.

[21:16] <masak> CurtisOvidPoe: try adding !

[21:17] <masak> also, you could get away with writing just `:$!x!`, etc

[21:17] <CurtisOvidPoe> masak: I don’t understand that comment. 

[21:17] <CurtisOvidPoe> If my code is wrong, how is it wrong?

[21:17] <masak> m: class Point { has $.x; has $.y; multi method set(:$x! = $.x) { $!x = $x }; multi method set(:$y! = $.y) { $!y = $y } }; my $p = Point.new( x => 5, y => 2 ); $p.set( y => -3 ); say $p.y

[21:17] <camelia> rakudo-moar b76f60: OUTPUT«===SORRY!===␤Cannot put default on required parameter $x␤at /tmp/xzGarl9Sr8:1␤------> .x; has $.y; multi method set(:$x! = $.x⏏) { $!x = $x }; multi method set(:$y! = ␤Cannot put default on required parameter …»

[21:17] <masak> m: class Point { has $.x; has $.y; multi method set(:$x!) { $!x = $x }; multi method set(:$y!) { $!y = $y } }; my $p = Point.new( x => 5, y => 2 ); $p.set( y => -3 ); say $p.y

[21:17] <camelia> rakudo-moar b76f60: OUTPUT«-3␤»

[21:18] <masak> there.

[21:18] <masak> CurtisOvidPoe: hope my comment makes sense now.

[21:18] <masak> m: class Point { has $.x; has $.y; multi method set(:$!x!) {}; multi method set(:$!y!) {} }; my $p = Point.new( x => 5, y => 2 ); $p.set( y => -3 ); say $p.y

[21:18] <camelia> rakudo-moar b76f60: OUTPUT«-3␤»

[21:18] <masak> and that was my other comment.

[21:18] <FROGGS_> which works but might be kinda awkward :o)

[21:19] <masak> the `:$!x!` pill looks kind confusing at first, yes.

[21:19] <jnthn> FROGGS_: It means what it says; there's an NYI.

[21:19] <masak> one has to mentally disambiguate the first `!` (private attr) from the second (mandatory parameter).

[21:20] <FROGGS_> jnthn: yes, but... 

[21:20] <CurtisOvidPoe> masak: I agree that my code doesn’t make sense, but nonetheless, it doesn’t appear to be dispatching properly.

[21:20] <FROGGS_> I don't want to ó.ò

[21:20] <moritz> or

[21:20] <jnthn> FROGGS_: Then write a MoarVM ticket and I'll look at it in the next days.

[21:20] <moritz> method set(:$!x, :$!y) { }

[21:20] <masak> CurtisOvidPoe: unless it's clear already, you also fell prey to several matching candidates picking the first one in text order.

[21:20] <FROGGS_> jnthn: no, I won't distract you from doing 6pe :o)

[21:20] <masak> CurtisOvidPoe: also, what moritz++ just said.

[21:21] <moritz> m: class Point { has ($.x, $.y); method set(:$!x, :$!y) { } }; my $p = Point.new( x => 5, y => 2; $p.set( y => -3 ); say $p.y

[21:21] <camelia> rakudo-moar b76f60: OUTPUT«===SORRY!=== Error while compiling /tmp/4O83QGu8LO␤Unable to parse expression in argument list; couldn't find final ')' ␤at /tmp/4O83QGu8LO:1␤------> > 5, y => 2; $p.set( y => -3 ); say $p.y⏏<EOL>␤    expectin…»

[21:21] <CurtisOvidPoe> masak: actually, I didn’t fall prey to several candidates picking the first one because *neither* value is changed.

[21:21] <CurtisOvidPoe> m: class Point { has $.x; has $.y; multi method set(:$x = $.x) { $!x = $x }; multi method set(:$y = $.y) { $!y = $y } }; my $p = Point.new( x => 5, y => 2); $p.set( y => -3 ); say $p.y;say $p.x;

[21:21] <camelia> rakudo-moar b76f60: OUTPUT«2␤5␤»

[21:21] <masak> CurtisOvidPoe: that's because it dispatched to the first one.

[21:21] <masak> CurtisOvidPoe: which doesn't care about $.y

[21:22] <CurtisOvidPoe> No, as you can see from the above, $p.x isn’t changed, either.

[21:22] <masak> I didn't say it was.

[21:22] <masak> I just said it dispatched to the first one.

[21:22] <masak> which doesn't care about $.y, and defaults $x to $.x

[21:22] <masak> so you've successfully changed $.x to $.x

[21:23] <FROGGS_> CurtisOvidPoe: is this about chowing multi methods or about setting attributes?

[21:23] <CurtisOvidPoe> So that means that multi foo(:$x) can take multiple named arguments and ignores those which do not show up?

[21:23] <FROGGS_> CurtisOvidPoe: yes

[21:23] <CurtisOvidPoe> (ignores those which don’t match $x)

[21:23] <masak> CurtisOvidPoe: yes, that's what "not mandatory" means.

[21:23] <moritz> m: class Point { has ($.x, $.y); method set(:$!x, :$!y) { } }; my $p = Point.new( x => 5, y => 2); $p.set( y => -3 ); say $p.y

[21:23] <camelia> rakudo-moar b76f60: OUTPUT«-3␤»

[21:23] <jnthn> To be clear, the 3 things going on here are 1) Methods happily accept any unexpected named parameters for reasons of interface consistency, 2) named parameters are optional by default, 3) named parameters don't affect candidate sorting, but required ones can serve as a constraint.

[21:24] <FROGGS_> there is an implicit *%_ on methods

[21:24] <masak> jnthn++

[21:24] *** denis_boyun_ joined
[21:24] <CurtisOvidPoe> Thanks, jnthn! I expect that this ties in with the multi method ambiguity issue and is going to cause confusion.

[21:24] <moritz> http://design.perl6.org/S12.html#Interface_Consistency

[21:24] <masak> I think we all hate interface consistency with some degree of passion -- but no-one seems keen on arguing against it either, as it makes some amount of sense.

[21:24] <CurtisOvidPoe> In short, $p.set( y => -2 ) being a no-op is very confusing.

[21:25] <ab5tract> FROGGS_: that's a useful note to make, but not entirely fitting with CurtisOvidPoe's talk which aims at mere mortals

[21:25] *** rurban left
[21:25] <ab5tract> CurtisOvidPoe: sure, but then again so is the mechanism through which you have set it up

[21:25] <masak> CurtisOvidPoe: your original code is not very idiomatic.

[21:25] <CurtisOvidPoe> Agreed!

[21:26] <masak> CurtisOvidPoe: so while I agree that it being a no-op is very confusing, it's not a path that I would expect people to follow and not a trap I would expect people to land in.

[21:26] <FROGGS_> m: class Point { has $.x is rw; has $.y is rw }; my $p = Point.new( x => 5, y => 2 ); $p.y = -3; say $p.y;

[21:26] <camelia> rakudo-moar b76f60: OUTPUT«-3␤»

[21:26] <FROGGS_> that's idiomatic but does not show MMD of course

[21:26] <ab5tract> MMD is not necessary where named parameters are concerned

[21:26] <masak> CurtisOvidPoe: moritz++' suggestion is more idiomatic.

[21:26] <masak> and shorter.

[21:26] <CurtisOvidPoe> Confised the case of Perl 5: new programmers usually don’t write “idiomatic” Perl code.

[21:26] <masak> *nod*

[21:26] <CurtisOvidPoe> moritz’s suggestion is pretty much what I already have in my talk :)

[21:27] <masak> \o/

[21:27] <jnthn> Also, why a set method at all?

[21:27] <skids> When I was first learning P6 that (named parm dispatch) did manage to snag me once.  It's just one of those things to be pointed out to beginners 

[21:27] <ab5tract> jnthn: excellent point

[21:27] <jnthn> "is rw" is the (not hard to understand) way to get a public accessor

[21:27] <FROGGS_> is what I showed, aye

[21:28] <CurtisOvidPoe> jnthn: I don’t have a set() method the final Point class I show. I was using one as an example of “you really don’t need this after all”

[21:28] <CurtisOvidPoe> And I throw a subset on $.x and $.y to make it clear we can safely expose them.

[21:28] <FROGGS_> m: class Point { has $.x is rw; has $.y is rw }; my $p = Point.new( :5x, :2y ); $p.y = -3; say $p # :o)

[21:28] <camelia> rakudo-moar b76f60: OUTPUT«Point.new(x => 5, y => -3)␤»

[21:29] <ab5tract> CurtisOvidPoe: for MMD (and doing more than necessary) you could create PosX and PosY classes

[21:29] <FROGGS_> (or roles)

[21:29] <ab5tract> .... :5x ?

[21:29] <jnthn> CurtisOvidPoe: Ah, OK, then fair enough.

[21:29] <ab5tract> do we really need more ways to frame a pair?

[21:29] <FROGGS_> ab5tract: is meant when you have units.... $date.add( :24hours )

[21:29] <ab5tract> ah

[21:30] <ab5tract> ok

[21:30] <ab5tract> i guess :.

[21:30] <ab5tract> :/

[21:30] <jnthn> Well, the reason we got it is because :2nd, :3rd, etc. as a regex modifier.

[21:30] <FROGGS_> jnthn: but it is awesome for datetime math :o)

[21:30] <jnthn> FROGGS_: Opinions vary ;) 

[21:31] <FROGGS_> jnthn: that's your opinion :P

[21:31] * jnthn implemented it and remembers the mixed reactions of "way cool" and "omfg WHY" :)

[21:31] <FROGGS_> yeah

[21:31] <FROGGS_> "Every DWIM comes with a WAT"

[21:32] <ab5tract> i assume that is only ever possible with numeric values?

[21:32] <pmurias> masak: I haven't used STM at all so I don't have any opinions about it, I just read the rurban blog post and it reminded me of STM

[21:32] <FROGGS_> ab5tract: aye

[21:32] <masak> pmurias: url?

[21:33] <ab5tract> i was reading the backlog on the train

[21:33] <pmurias> masak: the advent one

[21:33] * pmurias hasn't figured out how to copy & paste stuff into an xterm without a mouse

[21:33] <ab5tract> a data point i had was at YAPC::EU 2012, after the guy who implemented it (name escapes) how well it was working with P6

[21:33] <masak> ok, I might be able to find it. hold on.

[21:33] <pmurias> (it's in the irc log)

[21:34] <ab5tract> he simply looked at me like i was insane and replied "don't care"

[21:34] <masak> got it. https://perl6advent.wordpress.com/2012/12/11/day-11-parrot-threads/

[21:34] <FROGGS_> ab5tract: what are you talking about?

[21:35] <masak> ab5tract: maybe "Nat Tucks"?

[21:35] <ab5tract> FROGGS_: parrot threads

[21:35] <FROGGS_> ab5tract: ahh

[21:35] <masak> ab5tract: that's what the p6advent post says.

[21:35] <geekosaur> pmurias, http://blog.ssokolow.com/archives/2011/05/01/modernizing-xterms-paste/ ?

[21:35] <FROGGS_> nine++ implemented it and gave that talk

[21:35] <FROGGS_> ab5tract^^

[21:35] <masak> or it was nine, yes.

[21:35] <ab5tract> ok

[21:36] <ab5tract> wish that didn't make things even more confusing

[21:36] <CurtisOvidPoe> m: say .3.^methods

[21:36] <camelia> rakudo-moar 6279e1: OUTPUT«Rat FatRat new nude Num floor ceiling Int Bridge base succ pred norm narrow abs sign conj sqrt rand sin asin cos acos tan atan atan2 sec asec cosec acosec cotan acotan sinh asinh cosh acosh tanh atanh sech asech cosech acosech cotanh acotanh round unpolar …»

[21:36] <CurtisOvidPoe> m: say .3.HOW.methods

[21:36] <camelia> rakudo-moar 6279e1: OUTPUT«Too few positionals passed; expected 2 arguments but got 1␤  in any methods at src/gen/m-Metamodel.nqp:453␤  in block <unit> at /tmp/dI37LKjaUr:1␤␤»

[21:36] *** kurahaupo joined
[21:37] <pmurias> masak: "wait" from the blog post is just atomic (thread_has_ended_flag == 1) {}

[21:37] <CurtisOvidPoe> ^ and HOW aren’t the same thing?

[21:37] <jnthn> CurtisOvidPoe: No

[21:37] <masak> m: say .3.HOW.methods(.3)

[21:37] <camelia> rakudo-moar 6279e1: OUTPUT«Rat FatRat new nude Num floor ceiling Int Bridge base succ pred norm narrow abs sign conj sqrt rand sin asin cos acos tan atan atan2 sec asec cosec acosec cotan acotan sinh asinh cosh acosh tanh atanh sech asech cosech acosech cotanh acotanh round unpolar …»

[21:37] <jnthn> CurtisOvidPoe: Meta-methods take the object being operated on as a first argument

[21:37] <pmurias> masak: and each parrot thread starts a transaction for each write

[21:37] <jnthn> a.^foo(b) is a.HOW.foo(a, b) but without re-evaluating a

[21:37] <vendethiel>  "Every DWIM comes with a WAT" <- this is so well said, FROGGS_

[21:37] <CurtisOvidPoe> jnthn: cheers!

[21:38] <pmurias> masak: and the transactions don't contain any reads so they always succeed

[21:39] * moritz guesses it's time to write perlmop.pod instead of j API documentation for the MOP

[21:39] <jnthn> moritz: I suspect the latter is more useful with the former :)

[21:40] <masak> I think both are useful. it's just, I would look for the former first.

[21:41] * ab5tract agrees

[21:41] <jnthn> Right, that's a better way of saying what I was trying to :)

[21:41] <moritz> it's also that writing the API documentation gives man anoverview over the available MOP functionality

[21:41] <CurtisOvidPoe> Night all.

[21:41] <jnthn> 'night

[21:41] <masak> jnthn: oh you said *with* the former. I read *than* the former. sorry :)

[21:41] <masak> 'night, Ovid

[21:41] *** denis_boyun_ left
[21:42] <jnthn> masak: I wondered why you were seeming disagreeable :P

[21:42] * jnthn goes hunting a basic block eliminator bug...

[21:42] <masak> jnthn: I seem to do that a lot tonight ;)

[21:42] <masak> rawr!

[21:42] <FROGGS_> *g*

[21:42] <moritz> basic blog alligator bug!

[21:43] <masak> seen on Twitter: "Someone once said I was fun and easy-going. I laughed so hard I accidantally ate them."

[21:43] <ab5tract> moritz: my miscomprehension matrix is missing, can i have it back please? :)

[21:43] <pmurias> masak: the more I think about the parrot threads the more crazy they seem

[21:43] <masak> pmurias: whee!

[21:43] <moritz> ab5tract: sorry, I already diagnolized it

[21:43] <masak> pmurias: crazy *awesome*, right?

[21:47] <masak> "The solution for these problems implemented in hybrid threads is to sidestep them altogether by disallowing write access to shared variables." -- you what?

[21:48] <masak> that's not a solution. that's avoiding the problem.

[21:48] <vendethiel> I strongly believe that's a solution :P

[21:48] <moritz> .oO( you communicate between threads over avian carriers)

[21:48] <vendethiel> to a different problem, through

[21:48] <vendethiel> which happens to fix gracefully both...

[21:48] <masak> vendethiel: heh :)

[21:50] <masak> if I am reading this post right, it's saying that if I have a program with an array `@results`, then I am allowed to fork 100 threads to compute results in parallel -- as long as I don't push the results to the `@results` array from any of the threads.

[21:50] <dalek> doc: bebee61 | moritz++ | lib/Type/Submethod.pod:

[21:50] <dalek> doc: document type Submethod

[21:50] <dalek> doc: review: https://github.com/perl6/doc/commit/bebee61481

[21:51] <masak> "In other words, all data is owned by the thread creating it and only the owner may write to it. Other threads have only read access." -- yeah, I'm sorry, that's not awesome.

[21:51] <masak> that sucks.

[21:52] *** raiph joined
[21:52] * lizmat is looking at a segfault and decides to sleep on it

[21:52] <ab5tract> masak: your disagreeable threads are showing quite plainly today ;)

[21:52] <masak> ab5tract: I'll bet.

[21:53] <masak> I take full responsibility. I clearly should be doing something fun and constructive instead.

[21:53] <masak> I don't even care that much about Parrot.

[21:53] <ab5tract> that said, it was really interesting to see the linear performance increases from the (admittedly arbitrary) mandelbrot test

[21:54] <jnthn> lizmat: Hah, you've just made me wnat a pillow with SEGV written on it :P

[21:54] <ab5tract> and in practice, i haven't gotten any shared array code working in moar threads either

[21:55] <ab5tract> which is what i understand we need Supply.act for

[21:55] <masak> ab5tract: ooh, I should totally try that.

[21:55] <masak> std: our enum day of int <Sun Mon Tue Wed>

[21:55] <camelia> std f9b7f55: OUTPUT«ok 00:00 135m␤»

[21:55] <masak> m: our enum day of int <Sun Mon Tue Wed>

[21:56] <camelia> rakudo-moar 6279e1: OUTPUT«===SORRY!=== Error while compiling /tmp/QEVPGELusO␤Method 'set_of' not found for invocant of class 'Perl6::Metamodel::EnumHOW'␤at /tmp/QEVPGELusO:1␤------> ␤»

[21:56] <masak> NYI?

[21:56] * ab5tract cannot tell if masak is being sarcastic

[21:56] <masak> ab5tract: I'm not.

[21:56] <masak> ab5tract: trying it now.

[21:57] <ab5tract> i have about zero experience with concurrent programming

[21:57] <jnthn> If you're going to have multiple threads producing results to a common consumption point, you either want a Channel or a Supply, or sometimes just to solve the problem more functionally. :)

[21:57] <FROGGS_> jnthn: you can get such a pillow if that helps :o)

[21:58] <jnthn> FROGGS_: I'm not sure it'd *help*... :)

[21:58] <FROGGS_> *g*

[21:58] <masak> m: my @results; for (1..20).pick(*) -> $n { $*SCHEDULER.cue: { @results.push($n) } }; say @results.perl; say @results.elems

[21:58] <camelia> rakudo-moar 6279e1: OUTPUT«Could not spawn thread: errorcode -1␤»

[21:58] <masak> hm. this works locally.

[21:58] <jnthn> Odd

[21:58] <ab5tract> but when i read/heard that constraint, it didn't seem like a big deal at all because my limited uynderstanding was "yeah, you can't push onto a common array from threads anyway"

[21:58] <masak> maybe some restriction put on camelia?

[21:59] <jnthn> Maybe

[21:59] <masak> anyway, I got twenty elements at home.

[21:59] <hobbs> masak: yeah, a process/thread rlimit wouldn't be surprising for an IRC bot :)

[21:59] <ab5tract> at least without some sort of arbiter, as jnthn points out with Channel or Supply

[21:59] <masak> if this way is dangerous, then I seem to have been lucky.

[21:59] <jnthn> masak: You shouldn't get it to SEGV, but it's NOT a good idea

[21:59] <masak> I'd be happy to learn how to do the above code with a Channel or Supply.

[22:00] <ab5tract> masak: why not use start?

[22:00] <pmurias> masak: you are free to fork off 100 threads which modify @results in parallel

[22:01] <pmurias> masak: their modifications will trickle down to your thread in random order

[22:01] <jnthn> m: my @results = await do for (1..20).pick(*) -> $n { start { $n } }; say @results;

[22:01] <camelia> rakudo-moar 6279e1: OUTPUT«Could not spawn thread: errorcode -1␤»

[22:01] <jnthn> Yeah, must be some restriction.

[22:01] <pmurias> masak: and you can call wait for all the modifications to trickle down

[22:01] <jnthn> m: Thread.start({ sleep 1 })

[22:01] <camelia> rakudo-moar 6279e1: ( no output )

[22:01] <jnthn> m: Thread.start({ sleep 1 }) xx 10

[22:01] <camelia> rakudo-moar 6279e1: ( no output )

[22:01] <jnthn> m: Thread.start({ sleep 1 }) xx 20

[22:01] <camelia> rakudo-moar 6279e1: OUTPUT«Could not spawn thread: errorcode -1␤»

[22:01] <jnthn> m: Thread.start({ sleep 1 }) xx 16

[22:01] <camelia> rakudo-moar 6279e1: OUTPUT«Could not spawn thread: errorcode -1␤»

[22:02] <ab5tract> poor camelia

[22:02] <jnthn> 16 is the maximum thread poo size by the dfault, iirc

[22:02] <ab5tract> :)

[22:02] <jnthn> uh, pool

[22:02] <FROGGS_> hehe

[22:02] <FROGGS_> +1

[22:02] <jnthn> As in, Rakudo won't spawn more than 16

[22:02] <jnthn> But Camelia won't handle that it seems

[22:02] <masak> pmurias: ok, that sounds saner than how I understood it.

[22:03] <ab5tract> jnthn: is maximum thread pool size a compile time or run time switch for rakudo?

[22:03] <jnthn> ab5tract: If you change $*SCHEDULER you can control it at runtime.

[22:04] <ab5tract> ok

[22:04] <jnthn> ab5tract: In the future it will look at the hardware you have and factor in throughput etc.

[22:04] <ab5tract> sweet!

[22:05] <ab5tract> the concurrency bits are one thing i would really love to see both ironed out *and* fully documented for 6.0

[22:05] <masak> +1

[22:05] <ab5tract> jnthn: i can still make moar segfault by calling say

[22:05] <jnthn> masak: A better example of the restriction: you have a monitor or actor (using OO::Monitor or OO::Actor modules I hacked up). Under the Moar/JVM model you have in Perl 6, any thread can modify them, but an ordering (one at a time) is imposed on the method calls, giving safety.

[22:06] <masak> jnthn: cool.

[22:06] <jnthn> masak: So your concurrent web app can process requests that work against those objects over a bunch of threads, and whichever thread wants can modify it - but only one at a time.

[22:06] <masak> jnthn: are there any guarantees given about reads not seeing intermediate states?

[22:07] <jnthn> masak: As I understand the Parrot model, all changes to an object have to go to the thread that creates it, meaning if that thread is busy doing something else, the first has to block.

[22:08] <jnthn> masak: (intermediate states) monitors/actors are object with state, and you can only be inside a method call on a particular instance in one thread at a time.

[22:08] <masak> m: my enum CoinFace <Heads Tails>; say CoinFace.mapping # NYI?

[22:08] <camelia> rakudo-moar 6279e1: OUTPUT«No such method 'mapping' for invocant of type 'CoinFace'␤  in block <unit> at /tmp/5dauX1OCWv:1␤␤»

[22:08] <masak> jnthn: ah; got it.

[22:08] <jnthn> masak: So, provided you don't do something crazy with your OO design, no :)

[22:09] <jnthn> masak: Ain't that method called .enums

[22:09] <masak> oh, possible. I'm reading an old spec commit.

[22:09] <jnthn> m: my enum CoinFace <Heads Tails>; say CoinFace.enums

[22:09] <camelia> rakudo-moar 6279e1: OUTPUT«Heads => 0, Tails => 1␤»

[22:10] <masak> m: my enum CoinFace <Heads Tails>; say CoinFace.enums.^name

[22:10] <camelia> rakudo-moar 6279e1: OUTPUT«Hash␤»

[22:10] <masak> heh -- the old spec commit had the type as "PairValSet" :P

[22:10] <jnthn> Such enterprisey :P

[22:12] <jnthn> m: say &die.WHAT

[22:12] <camelia> rakudo-moar 6279e1: OUTPUT«(Sub+{<anon>})␤»

[22:12] <jnthn> m: say &die.^roles

[22:12] <camelia> rakudo-moar 6279e1: OUTPUT«(<anon>) (Callable)␤»

[22:12] <jnthn> m: say &die ~~ Callable

[22:12] <camelia> rakudo-moar 6279e1: OUTPUT«False␤»

[22:12] <jnthn> m: say nqp::istype(&die, Callable)

[22:12] <camelia> rakudo-moar 6279e1: OUTPUT«0␤»

[22:13] * masak guesses jnthn is fixing some RT ticket or other

[22:13] <jnthn> m: &die.^compose; say nqp::istype(&die, Callable)

[22:13] <camelia> rakudo-moar 6279e1: OUTPUT«1␤»

[22:13] <jnthn> masak: Well, it probably exists.

[22:13] <FROGGS_> m: say nqp::istype(&fail, Callable)

[22:13] <camelia> rakudo-moar 6279e1: OUTPUT«1␤»

[22:14] <jnthn> masak: It's just that what once was an obscure bug that showed up in the case of some setting built-ins is now a bug causing spectest fails in my branch that caches mixins.

[22:15] <jnthn> m: class A { ... }; class A does Rational { ... }; class A { method omg() { } }; say A.omg; say A.^roles; say A ~~ Rational

[22:15] <camelia> rakudo-moar 6279e1: OUTPUT«===SORRY!===␤None of the parametric role variants for 'Rational' matched the arguments supplied.␤Cannot call ''; none of these signatures match:␤:(::$?CLASS ::::?CLASS $, ::NuT $, ::DeT $)␤»

[22:15] <jnthn> oh... :)

[22:15] <jnthn> m: class A { ... }; class A does Positional { ... }; class A { method omg() { } }; say A.omg; say A.^roles; say A ~~ Rational

[22:15] <camelia> rakudo-moar 6279e1: OUTPUT«Nil␤(Positional)␤False␤»

[22:15] <jnthn> m: class A { ... }; class A does Positional { ... }; class A { method omg() { } }; say A.omg; say A.^roles; say A ~~ Positional

[22:15] <camelia> rakudo-moar 6279e1: OUTPUT«Nil␤(Positional)␤True␤»

[22:15] <jnthn> OK, good...it won't be a horrid fix :)

[22:19] *** Mso150 left
[22:22] *** mvuets left
[22:22] *** kjs_ left
[22:23] <jnthn> Aww, nah, it will be.

[22:24] <jnthn> Guess that can be my problem to sleep on tonight :)

[22:25] *** leont joined
[22:25] * masak embroiders "horrid fix" on a pillow for jnthn

[22:26] <jnthn> m: package Foo { }; sub x(Foo) { }

[22:26] <camelia> rakudo-moar 6279e1: OUTPUT«===SORRY!=== Error while compiling /tmp/oSrLMcGBow␤Foo cannot be used as a nominal type on a parameter␤at /tmp/oSrLMcGBow:1␤------> package Foo { }; sub x(Foo⏏) { }␤»

[22:26] <jnthn> m: package Foo { }; my Foo $x = 42;

[22:26] <camelia> rakudo-moar 6279e1: OUTPUT«Type check failed in assignment to '$x'; expected 'Foo' but got 'Int'␤  in block <unit> at /tmp/5PVuLGRbHg:1␤␤»

[22:40] *** tgt left
[22:42] <dalek> rakudo/6pe-mop: e6a6677 | jnthn++ | src/Perl6/Actions.nqp:

[22:42] <dalek> rakudo/6pe-mop: Only allow appropriate types on variables.

[22:42] <dalek> rakudo/6pe-mop: review: https://github.com/rakudo/rakudo/commit/e6a6677c68

[22:42] *** FROGGS_ left
[22:43] *** espadrine left
[22:53] <timotimo> lizmat++ # fixing the for -> while opt

[22:58] <masak> I was thinking earlier today -- would it be feasible/worthwhile to have a special test suite for optimizations? maybe something that mocked certain parts of the compiler stack to be able to check whether an optimization triggered?

[23:05] *** beastd left
[23:06] <tadzik> hello hello!

[23:06] <yoleaux> 17 Jan 2015 19:36Z <raydiak> tadzik: noticed I can't "rakudobrew switch moar-2014.12" :) https://github.com/tadzik/rakudobrew/pull/25

[23:06] <tadzik> oh :)

[23:06] <tadzik> raydiak++ colomon 

[23:06] <tadzik> colomon++

[23:09] <pmurias> masak: it seems like something that would be worthwhile, especially if we introduce better and more complex optimalisations

[23:10] <pmurias> masak: the hard part is how to test for correctness without hardcoding resulting qast?

[23:11] <masak> pmurias: that's what the mocks could do. there could be a mock for the `for --> while` optimization; the test would check that it set a bit somewhere, indicating "the optimization triggered".

[23:18] *** telex left
[23:20] *** telex joined
[23:24] *** spider-mario left
[23:25] *** Ben_Goldberg left
[23:25] *** raiph left
[23:25] <pmurias> masak: that sort of makes hardcoding qast input and output seem a good option :/

[23:25] *** Ben_Goldberg joined
[23:25] <timotimo> i wonder how much faster spesh_diff would run if i turned it from a line-by-line thing into a grammar instead that does a whole bunch of work in the actions

[23:26] <timotimo> that could also very well make the source code simpler, as i don't have to keep an "accumulator" object around that gets stashed into a storage hash and replaced by a new empty one at a somewhat arbitrary looking point

[23:26] <masak> pmurias: I don't see why you think so. hardcoding qast output seems brittle, if what we care about is that an optimization is done for a certain input.

[23:27] <timotimo> it's also very hard to compare 1:1 qast outputs

[23:27] <timotimo> as soon as something else changes, your matcher for "success of optimization" vs "failure to optimize" must be looked at again

[23:27] <jnthn> I think that already each optimization is separated out into a method that does the transform

[23:27] <jnthn> So there's analysis methods, and then if they decide to do something they call a transform

[23:28] *** Ben_Goldberg left
[23:28] <jnthn> So if you can intercept those calls (like by subclassing) and record them, you have a way to test it.

[23:28] *** Ben_Goldberg joined
[23:30] *** KCL_ joined
[23:31] *** Ben_Goldberg is now known as BenGoldberg

[23:32] <jnthn> Time for some rest...'night

[23:32] <masak> 'night, jnthn

[23:33] *** brrt left
[23:33] <BenGoldberg> On the subject of creating a test for whether an optimization is being done, how about compiling with optimizations turned off, then again with them turned on, and see if there's *any* differences between the qasts?

[23:34] <masak> <timotimo> it's also very hard to compare 1:1 qast outputs

[23:35] *** kjs_ joined
[23:35] *** tangentstorm joined
[23:36] <BenGoldberg> But at least it's future proof, so if something else changes (some new optimization is done), the test can still say, "something was optimized", even though it might not know precisely which optmization triggered.

[23:37] <masak> right, but you're assuming that any difference between two QAST output is significant, which it may not be.

[23:38] *** kjs_ left
[23:39] *** gfldex left
[23:50] *** Alina-malina left
[23:56] *** Alina-malina joined
[23:58] *** pmurias left
