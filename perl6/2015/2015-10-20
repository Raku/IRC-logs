[00:00] *** salva joined
[00:02] *** psch joined
[00:02] *** llfourn joined
[00:03] <psch> m: my $rx = / foobar /; say "foobar".match($rx)

[00:03] <camelia> rakudo-moar 46874f: OUTPUT«｢foobar｣␤»

[00:03] <psch> m: Str.^can('submatch').perl.say

[00:03] <camelia> rakudo-moar 46874f: OUTPUT«()␤»

[00:04] <psch> timotimo: the Str is what allows the matching to happen (which is another notch on my "something is the wrong way around with '$str ~~ $rx' log), and i don't know if a Str wants to support a submatch

[00:05] <psch> it doesn't seem particularly valuable, from a "what do we use these constructs for" point of view

[00:06] <psch> there's probably more than one angle to argue from here.  something like "Grammars should have an ACCEPTS" on one hand, "it should be $rx ~~ $str" on the other hand

[00:06] <psch> m: say "foo" ~~ /foo/

[00:06] <camelia> rakudo-moar 46874f: OUTPUT«｢foo｣␤»

[00:06] <psch> m: my $rx = /foo/; say $rx.ACCEPTS("foo")

[00:06] <camelia> rakudo-moar 46874f: OUTPUT«｢foo｣␤»

[00:07] *** Ben_Goldberg left
[00:07] <psch> m: say /foo/.match("foo")

[00:07] <camelia> rakudo-moar 46874f: OUTPUT«Method 'match' not found for invocant of class 'Regex'␤  in block <unit> at /tmp/x1rhiS9nfZ:1␤␤»

[00:07] <psch> it's just odd

[00:07] *** Ben_Goldberg joined
[00:07] *** llfourn left
[00:07] <psch> i mean, from a "what can objects do" perspective it seems fitting enough - a string can match against a regex or not

[00:07] <psch> but a regex ACCEPTS a string feels kind of off there

[00:08] *** Ben_Goldberg left
[00:08] * psch probably starts sounding a bit ranty there...

[00:08] *** Ben_Goldberg joined
[00:10] *** regreg joined
[00:10] <ShimmerFairy> The problem with the idea of Regex.match is that there's already a Str.match, and I don't think it's a good idea to mix meanings like that. If anything, it should be called Regex.parse (and thus also Regex.subparse)

[00:14] *** mantovani left
[00:18] *** tokuhiro_ joined
[00:21] *** Hor|zon joined
[00:23] *** tokuhiro_ left
[00:25] *** [Coke] joined
[00:26] *** Hor|zon left
[00:27] *** rurban1 left
[00:28] *** Akagi201 joined
[00:29] *** tokuhirom_ joined
[00:33] *** Akagi201 left
[00:34] *** tokuhirom_ left
[00:40] *** leont left
[00:40] *** raiph left
[00:42] *** sufrostico left
[00:42] *** uberbaud joined
[00:44] *** Akagi201 joined
[00:47] *** uberbaud left
[00:47] *** uberbaud joined
[00:48] *** uberbaud left
[00:49] *** uberbaud joined
[01:06] *** retupmoca left
[01:21] *** uberbaud left
[01:22] *** uberbaud joined
[01:22] *** Hor|zon joined
[01:26] *** Hor|zon left
[01:30] *** kalkin-_ joined
[01:32] *** yeahnoob joined
[01:34] *** kalkin- left
[01:35] *** danstone1 is now known as danstoner

[01:44] *** kid51 left
[01:48] *** uberbaud_ joined
[01:49] *** uberbaud left
[01:51] *** uberbaud_ left
[01:53] *** cognominal joined
[01:55] *** kaare_ joined
[01:59] *** hoelzro left
[02:00] *** n_i_c_k_ left
[02:03] *** uberbaud joined
[02:05] *** llfourn joined
[02:05] *** aborazmeh joined
[02:05] *** aborazmeh left
[02:05] *** aborazmeh joined
[02:11] *** llfourn left
[02:12] *** noganex_ joined
[02:15] *** noganex left
[02:17] *** zakharyas left
[02:20] *** adu joined
[02:20] *** tokuhiro_ joined
[02:23] *** Hor|zon joined
[02:24] *** tokuhiro_ left
[02:28] *** Hor|zon left
[02:30] *** tokuhirom_ joined
[02:33] *** uberbaud left
[02:34] *** Akagi201_ joined
[02:34] *** tokuhirom_ left
[02:37] *** adu left
[02:38] *** Akagi201 left
[02:38] *** uberbaud joined
[02:43] *** SqrtNegInf left
[02:52] *** adu joined
[02:53] *** softmoth joined
[03:01] *** zostay left
[03:02] *** mantovani joined
[03:08] *** adu left
[03:18] *** adu joined
[03:24] *** Hor|zon joined
[03:29] *** llfourn joined
[03:29] *** Hor|zon left
[03:30] *** tokuhiro_ joined
[03:41] *** hoelzro joined
[03:45] <softmoth> I'm not finding the right way to try using a module, and recover if it doesn't exist

[03:46] <softmoth> like try { use Foo; CATCH { default { say "no Foo?" } } }

[03:47] *** Ben_Goldberg left
[03:47] *** Ben_Goldberg joined
[03:48] *** Ben_Goldberg left
[03:48] *** Ben_Goldberg joined
[04:01] <llfourn> m: BEGIN { require Foo; CATCH { default { say 'no Foo' } } }

[04:01] <camelia> rakudo-moar 46874f: OUTPUT«no Foo␤»

[04:01] <llfourn> softmoth: that works I'm not sure how well it will import from Foo if it exists

[04:06] <softmoth> ok. I found some possible workaround at https://github.com/supernovus/flower/blob/master/lib/Flower/TAL/TALES.pm6#L36

[04:07] *** |Tux| left
[04:07] <softmoth> I hope it is is something that is on the Rakudo roadmap for the near future

[04:08] <llfourn> softmoth: that comment is old. it does work now

[04:08] <llfourn> you have to do require ::($plugname)

[04:09] *** |Tux| joined
[04:13] <softmoth> OK. It doesn't do imports right though, I guess. I'm trying to make crustup (from p6-Crust) work with more Handler types, and not have to add 'use HTTP::Server::Tiny' at the top. If I take out 'use HTTP::Server::Tiny;' from the top of crustup, the require of the handler works, but code that it needs doesn't get loaded. It works if I replace 'use HTTP::Server::Tiny;' with 'use IO::Blob;', so that's the bit that

[04:13] <softmoth> isn't loaded.

[04:13] *** lizmat_ joined
[04:13] <softmoth> But when I try to use a different Handler, then some other dependency isn't loaded right

[04:14] *** et09 left
[04:14] <softmoth> I thought maybe if I could do a conditional 'use' at the top of crustup, I could get things to work with a wider range of installed (or not) handler modules.

[04:14] <llfourn> softmoth: I could probably help you easier if you put it into a gist

[04:15] <llfourn> softmoth: are you trying to load + import or just load dynamically?

[04:15] <llfourn> softmoth: I'm not really familiar with those modules unfortunetly :/

[04:16] *** lizmat left
[04:16] <softmoth> I'm not sure what I'm trying to do, either, really :-/

[04:16] <llfourn> hehe I know that feels

[04:16] <softmoth> I'll try to get something simplified to ask a proper question.

[04:17] <llfourn> sure there is some docs here if that helps: http://docs.perl6.org/language/modules#Loading_and_Basic_Importing

[04:17] <softmoth> Although, it appears that the Crust devs have changed the code I was hacking on, now that I look at it.

[04:17] *** nightfrog left
[04:18] <softmoth> So I'll look into that; they've made it require ::($_) for @!modules, and maybe have some way of getting the needed modules in there.

[04:18] <llfourn> good luck :)

[04:18] <softmoth> thanks!  :-)

[04:22] <moznion> Some modules looks like they don't have `updated` column http://modules.perl6.org/

[04:22] <moznion> Is this why?

[04:25] *** Hor|zon joined
[04:26] *** Ben_Goldberg left
[04:30] *** Hor|zon left
[04:37] <softmoth> The solution they've used is to be able to pass needed modules (e.g., -MFastCGI::NativeCall -MFastCGI::NativeCall::PSGI in my case) to crustup, and it does require ::($_) on those.

[04:38] <softmoth> It would be nice for 'require ::(Module::That::Uses::FastCGI::NativeCall)' to handle that dependency automatically, but maybe there's something else going on that I'm not aware of

[04:39] <softmoth> Anyways, the current solution seems to work as long as I know what dependencies need to be added

[04:39] *** llfourn left
[04:39] <softmoth> I'm curious if someone who actually knows how this should work would say if it's correct or not.

[04:44] *** adu left
[05:12] *** aborazmeh left
[05:20] *** AlexDaniel left
[05:21] <ugexe> personally i think that type of stuff should go into some sort of compunitrepo specific to the application. then it can autoload all the modules (middleware) itself

[05:25] *** khw left
[05:26] *** Hor|zon joined
[05:28] <ugexe> as far as whats going on it sounds like its due to lexical scoping

[05:31] *** Hor|zon left
[05:56] *** FROGGS joined
[06:06] <softmoth> ugexe: any pointers to code that does this the right way?

[06:10] *** apotheon_ joined
[06:10] *** diana_olhovik joined
[06:10] *** domidumont joined
[06:12] *** apotheon left
[06:15] *** domidumont left
[06:15] <softmoth> I'm not sure where the compunitrepo would live. Defining it in Crust would be brittle; every time FastCGI::NativeCall (for example) changes what modules it uses, Crust would have to make a change. Defining it in FastCGI::NativeCall doesn't make sense, since its author doesn't know that someone may want to require it at runtime.

[06:15] *** domidumont joined
[06:15] *** darutoko joined
[06:16] *** tokuhirom_ joined
[06:17] <softmoth> Explicitly specifying modules (what looks like Crust::Runner's current approach) puts the burden on the end user, which is also brittle and tedious, but it works and puts the solution at the same level as the error will show up.

[06:20] *** tokuhirom_ left
[06:23] *** hajimushu joined
[06:26] *** hajimushu left
[06:27] *** Hor|zon joined
[06:28] *** llfourn joined
[06:32] *** Hor|zon left
[06:36] *** bjz joined
[06:42] <[Tux]> test             50000    38.519    38.405

[06:42] <[Tux]> test-t           50000    39.674    39.560

[06:42] *** bjz left
[06:44] *** Khisanth left
[06:45] *** Ven joined
[06:45] *** Khisanth joined
[06:45] *** kjs_ joined
[06:47] *** firstdayonthejob joined
[06:54] *** azawawi joined
[06:54] *** kjs_ left
[06:54] <azawawi> hi #perl6

[07:02] *** bjz joined
[07:04] *** lea left
[07:07] *** espadrine_ joined
[07:11] *** _28_ria left
[07:13] *** Ven left
[07:15] *** Ven joined
[07:18] *** lea joined
[07:20] <DrForr> Morning. or UGT.

[07:21] *** rindolf joined
[07:24] *** firstdayonthejob left
[07:24] <ugexe> softmoth: the CUR can live anywhere. we have a hacky CUR for $work that autoloads modules this way but its definately a hack due to the lagging CUR situation in general

[07:25] *** bjz_ joined
[07:25] *** Ven left
[07:26] *** bjz left
[07:26] *** rurban joined
[07:27] <ugexe> the idea appears to be you will define it from the command line like -M, but you'd only have to define a single repo instead of a path/name for each plugin

[07:28] *** Hor|zon joined
[07:29] *** ely-se joined
[07:31] *** bjz joined
[07:31] <azawawi> is there a Perl 6 syntax to return an Array[SomeObject] or Hash[Something]?

[07:31] <lizmat_> m: say Array[my Int $ = 42]

[07:31] <camelia> rakudo-moar 46874f: OUTPUT«Parameter 't' requires a type object of type Int, but an object instance was passed.  Did you forget a 'multi'?␤  in block <unit> at /tmp/0jfDGAwMgT:1␤␤»

[07:32] <lizmat_> azawawi: is that what you want ?

[07:32] <lizmat_> m: say Array[(my Int $ = 42).WHAT]

[07:32] <camelia> rakudo-moar 46874f: OUTPUT«(Array[Int])␤»

[07:32] *** bjz_ left
[07:32] <azawawi> i meant like sub foo() returns Array[Int]?

[07:33] *** Hor|zon left
[07:34] *** bjz_ joined
[07:35] <azawawi> m: sub foo { [1] } returns Array[Int]

[07:35] <camelia> rakudo-moar 46874f: OUTPUT«5===SORRY!5=== Error while compiling /tmp/or9bKha4L5␤Strange text after block (missing semicolon or comma?)␤at /tmp/or9bKha4L5:1␤------> 3sub foo { [1] }7⏏5 returns Array[Int]␤    expecting any of:␤        infix␤        infix stopper…»

[07:35] <azawawi> m: sub foo() { [1] } returns Array[Int]

[07:35] <camelia> rakudo-moar 46874f: OUTPUT«5===SORRY!5=== Error while compiling /tmp/SXH_cejOdU␤Strange text after block (missing semicolon or comma?)␤at /tmp/SXH_cejOdU:1␤------> 3sub foo() { [1] }7⏏5 returns Array[Int]␤    expecting any of:␤        infix␤        infix stoppe…»

[07:35] <azawawi> m: sub foo() { [1] } returns Array

[07:35] <camelia> rakudo-moar 46874f: OUTPUT«5===SORRY!5=== Error while compiling /tmp/2kzi3TV2PN␤Strange text after block (missing semicolon or comma?)␤at /tmp/2kzi3TV2PN:1␤------> 3sub foo() { [1] }7⏏5 returns Array␤    expecting any of:␤        infix␤        infix stopper␤ …»

[07:36] *** bjz left
[07:36] <azawawi> lizmat_: got it. thanks :)

[07:37] *** lizmat_ is now known as lizmat

[07:38] <dalek> rakudo/curli: 4b1df7b | FROGGS++ | src/Perl6/Grammar.nqp:

[07:38] <dalek> rakudo/curli: allow whitestape in ::( "&foo"), RT #126385

[07:38] <dalek> rakudo/curli: review: https://github.com/rakudo/rakudo/commit/4b1df7b018

[07:38] <dalek> rakudo/curli: 42e55ec | lizmat++ | src/Perl6/World.nqp:

[07:38] <dalek> rakudo/curli: Make sure use invocant/parameters throw an NYI

[07:38] *** dalek left
[07:38] <synbot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=126385

[07:38] <lizmat> sorry dalek

[07:38] *** dalek joined
[07:38] *** ChanServ sets mode: +v dalek

[07:44] *** lea left
[07:45] *** rurban1 joined
[07:46] <azawawi> lizmat: is there a reason why perl6 process startup is a bit slow. I remember it was faster before.

[07:47] *** pmurias joined
[07:47] <lizmat> I see it at 110 msecs at the moment, I've seen it below 100 in the past yes

[07:47] *** rurban left
[07:47] <lizmat> azawawi: are those the numbers you're referring to ?

[07:47] <FROGGS> we don't know exactly why it is slower right now, right?

[07:47] <lizmat> or do you see much larger delays ?

[07:48] <lizmat> FROGGS: my guess would be that we're missing a lot of optimizations post GLR

[07:48] <azawawi> FROGGS: i will benchmark and report back

[07:48] <FROGGS> that's also my guess, but it is hard to guess the things

[07:49] <azawawi> mainly with the Selenium::WebDriver test suite 01-load.t (which does basically a use XYZ;)

[07:49] <FROGGS> azawawi: well, keep in mind that also precomp is gone atm

[07:50] <azawawi> FROGGS: aha

[07:50] <FROGGS> that probably has the biggest impact there

[07:50] <azawawi> FROGGS: so basically we're faster on the panda module installation but slower on the runtime?

[07:51] *** milton joined
[07:51] <FROGGS> yes

[07:52] <FROGGS> though it was not about speeding up panda, it was about getting that fragile thing out of panda

[07:52] <azawawi> interesting... time perl6 -MHTTP::UserAgent -e 'say "Hello world"'   => real 0m5.916s

[07:52] <tadzik> not that bad :)

[07:52] <FROGGS> heh

[07:55] <azawawi> tadzik: true, 5  seconds times 20 to 30 runs each day is not that bad :)

[07:55] *** lea joined
[07:56] <nine> tadzik: indeed, not that bad if you're used to loading programs from floppy disk

[07:57] <azawawi> nine: the old days :)

[07:57] <azawawi> nine: the floppy loading sound made it bearable though lol

[07:57] <nine> azawawi: yes, you always knew when it was doing sometihng :)

[07:57] *** Ven joined
[07:58] *** softmoth left
[07:58] <azawawi> tadzik: what do you think is slowing down HTTP::UserAgent loading?

[07:59] *** sergot joined
[08:00] *** virtualsue joined
[08:02] *** tokuhirom_ joined
[08:02] <FROGGS> I get there will be SSDs soon with a sound module, so you get more feedback when working...

[08:02] <FROGGS> like you've got force feedback in your steering wheel nowadays

[08:02] <tadzik> azawawi: the sheer amount of code that has to be precompiled

[08:02] <FROGGS> (in your car)

[08:03] <tadzik> nine: or if you remember rakudo pre-nom :P

[08:06] *** tokuhirom_ left
[08:09] *** Akagi201 joined
[08:10] *** Akagi201_ left
[08:10] *** espadrine_ left
[08:12] *** dakkar joined
[08:12] *** Hor|zon joined
[08:13] *** azawawi left
[08:13] *** rarara_ left
[08:13] *** RabidGravy joined
[08:22] *** leont joined
[08:23] *** g4 joined
[08:23] *** g4 left
[08:23] *** g4 joined
[08:25] *** lea left
[08:26] *** telex left
[08:26] *** Ven left
[08:26] *** Ven joined
[08:27] *** Ven left
[08:28] *** telex joined
[08:30] *** andreoss joined
[08:32] <dalek> nqp: 750f859 | (Pawel Murias)++ | src/vm/js/QAST/Compiler.nqp:

[08:32] <dalek> nqp: [js] Implement nqp::mod_i.

[08:32] <dalek> nqp: review: https://github.com/perl6/nqp/commit/750f85926a

[08:32] <dalek> nqp: cdf1f6b | (Pawel Murias)++ | t/nqp/59-nqpop.t:

[08:32] <dalek> nqp: [js] Test nqp::mod_i.

[08:32] <dalek> nqp: review: https://github.com/perl6/nqp/commit/cdf1f6b913

[08:32] <dalek> nqp: 2dfdbc1 | (Pawel Murias)++ | docs/HACKING-js:

[08:32] <dalek> nqp: [js] update test list path in docs/HACKING-js.

[08:32] <dalek> nqp: review: https://github.com/perl6/nqp/commit/2dfdbc1bbd

[08:32] <dalek> nqp: 0b106de | (Pawel Murias)++ | src/vm/js/nqp-runtime/reprs.js:

[08:32] <dalek> nqp: [js] Set native int attributes to zero when constructing a P6opaque object.

[08:32] <dalek> nqp: review: https://github.com/perl6/nqp/commit/0b106de7f4

[08:32] <dalek> nqp: f49d614 | (Pawel Murias)++ | src/vm/js/ (2 files):

[08:32] <dalek> nqp: [js] Fix a bug in nqp::bindpos, make it work for negative indexes.

[08:32] <dalek> nqp: review: https://github.com/perl6/nqp/commit/f49d614956

[08:32] <dalek> nqp: fc21e43 | (Pawel Murias)++ | tools/build/ (2 files):

[08:32] <dalek> nqp: [js] correct the autogenerated message on top of Makefile-JS.in

[08:32] <dalek> nqp: review: https://github.com/perl6/nqp/commit/fc21e43a62

[08:32] <dalek> nqp: 5a5939a | (Pawel Murias)++ | src/vm/js/ (2 files):

[08:32] <dalek> nqp: [js] Stub nqp::objprimspec.

[08:32] <dalek> nqp: review: https://github.com/perl6/nqp/commit/5a5939ac9f

[08:34] *** Ven joined
[08:34] *** lea joined
[08:36] *** andreoss` joined
[08:37] *** andreoss left
[08:41] <tokuhiro_> how do i include pod in synopsis section?

[08:42] <tokuhiro_> Ah, i should use '=begin code'.

[08:43] <ShimmerFairy> tokuhiro_: if you meant a =SYNOPSIS block, it'll have to be =begin SYNOPSIS ... =end SYNOPSIS for multiple paragraph (unlike in POD from Perl 5, Perl 6's Pod doesn't run until a =cut appears)

[08:44] *** ely-se left
[08:44] <tokuhiro_> o

[08:46] *** leont left
[08:51] <dalek> ecosystem: 1ebb389 | (Tokuhiro Matsuno)++ | META.list:

[08:51] <dalek> ecosystem: Added Test::Base

[08:51] <dalek> ecosystem: review: https://github.com/perl6/ecosystem/commit/1ebb389243

[08:55] *** rurban1 left
[08:58] *** Akagi201_ joined
[08:59] *** broquaint left
[09:00] *** rurban joined
[09:00] *** lea left
[09:01] *** Akagi201 left
[09:04] *** espadrine_ joined
[09:11] *** Ven left
[09:12] *** Ven joined
[09:13] *** broquaint joined
[09:14] *** ely-se joined
[09:15] *** ugo joined
[09:18] *** lea joined
[09:25] *** kjs_ joined
[09:26] *** yeahnoob left
[09:35] *** softmoth joined
[09:36] *** ely-se left
[09:40] *** softmoth left
[09:42] *** spider-mario joined
[09:43] *** ely-se joined
[09:47] *** milton left
[09:59] *** lea left
[10:00] *** adhoc left
[10:00] *** jercos left
[10:06] *** virtualsue left
[10:07] *** Ven left
[10:07] *** Ven joined
[10:07] *** ely-se left
[10:09] *** Ven left
[10:11] <llfourn> m: say Date.new

[10:11] <camelia> rakudo-moar 46874f: OUTPUT«2015-12-24␤»

[10:11] <llfourn> ....wut

[10:12] <moritz> you didn't tell it which day you wanted, so it gave you Christmas

[10:13] <gfldex> m: say now;

[10:13] <camelia> rakudo-moar 46874f: OUTPUT«Instant:1445336024.609831␤»

[10:13] <llfourn> moritz: cool so will date give today after the release date?

[10:13] <gfldex> m: say Date.new(now);

[10:13] <camelia> rakudo-moar 46874f: OUTPUT«2015-10-20␤»

[10:13] <moritz> m: say Date.today

[10:13] <camelia> rakudo-moar 46874f: OUTPUT«2015-10-20␤»

[10:14] <FROGGS> llfourn: no, it will probably give you the Christmas after that

[10:15] <llfourn> FROGGS: ok well I guess at least that will make my christmas involved coding a bit easier

[10:15] <FROGGS> :D

[10:15] *** rindolf left
[10:15] <llfourn> s/christmas/season's greetings/

[10:16] *** Ven joined
[10:17] *** rurban left
[10:18] *** flaviusb joined
[10:19] *** rurban joined
[10:20] *** ely-se joined
[10:26] *** Ven left
[10:31] <dalek> rakudo/nom: be14c49 | lizmat++ | src/core/Exception.pm:

[10:31] <dalek> rakudo/nom: X::Pragma::CannotNo -> CannotWhat

[10:31] <dalek> rakudo/nom: 

[10:31] <dalek> rakudo/nom: For more general applicability

[10:31] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/be14c49528

[10:31] <dalek> rakudo/nom: 56dbb06 | lizmat++ | src/Perl6/World.nqp:

[10:31] <dalek> rakudo/nom: Make pragma handling a little more manageable

[10:31] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/56dbb06ecb

[10:39] *** dayangkun joined
[10:41] <dalek> roast: f331fd6 | lizmat++ | S (4 files):

[10:41] <dalek> roast: Fix X::Pragma::CannotNo -> CannotWhat breakage

[10:41] <dalek> roast: review: https://github.com/perl6/roast/commit/f331fd6811

[10:42] <dalek> rakudo/curli: be14c49 | lizmat++ | src/core/Exception.pm:

[10:42] <dalek> rakudo/curli: X::Pragma::CannotNo -> CannotWhat

[10:42] <dalek> rakudo/curli: 

[10:42] <dalek> rakudo/curli: For more general applicability

[10:42] <dalek> rakudo/curli: review: https://github.com/rakudo/rakudo/commit/be14c49528

[10:42] <dalek> rakudo/curli: 56dbb06 | lizmat++ | src/Perl6/World.nqp:

[10:42] <dalek> rakudo/curli: Make pragma handling a little more manageable

[10:42] <dalek> rakudo/curli: review: https://github.com/rakudo/rakudo/commit/56dbb06ecb

[10:42] <dalek> rakudo/curli: 546cf76 | lizmat++ | src/ (2 files):

[10:42] <dalek> rakudo/curli: Merge branch 'nom' into curli

[10:42] <dalek> rakudo/curli: review: https://github.com/rakudo/rakudo/commit/546cf7635d

[10:45] *** ely-se left
[10:47] <mrf> ugexe: Is there any merit to moving the various RFCs for HTTP/MIME/URI ect into a seperate repo (Grammar::RFC::*) and just use them in the Grammar::HTTP. Would be nice to have an Email::Address parse for example without using the HTTP repo....Maybe I am overthinking things. Any thoughts.

[10:48] <mrf> ugexe: also I have forked you repo and am going to add RFC5234 which replaces 4234 FYI. Will throw back a PR when I am done.

[10:48] *** dayangkun left
[10:49] *** kjs_ left
[10:49] <nine> mrf: +1 on splitting independent parts

[10:49] *** Zoffix joined
[10:51] <ShimmerFairy> mrf: I think it'd be cool to have a dedicated space for various IETF RFCs :)    If you wanted to be a bit more specific, then I'd suggest Grammar::IETF::RFC  (e.g. Grammar::IETF::RFC::_5234).

[10:51] <ShimmerFairy> Or IETF::RFC::Grammar , depending on how you want to organize things :)

[10:52] <ShimmerFairy> (you could also do RFC_5234 instead of RFC::_5234 if you'd prefer, of course)

[10:54] <pmurias> moritz: (Date.new defaulting to christmas)--

[10:54] <mrf> Either is fine. I like the idea of having top level Grammar namespace for things like this and other standardised grammars. (CSS, XML, Email, Date) etc

[10:54] <ShimmerFairy> pmurias: why is it bad? You didn't say what date you wanted? Could be February 32nd for all the info you didn't give :P

[10:55] <ShimmerFairy> s:2nd/\?/./

[10:55] <mrf> ShimmerFairy: Not sure really how to namespace that much. Several RFCs like 5234 are around how to write RFCs which seems like they should have a separate namespace. but not sure

[10:55] <moritz> pmurias: I know, we're becoming Enterprise and all, no place for fun anymore

[10:57] <ShimmerFairy> mrf: the IETF::RFC::Grammar idea I gave is if your intention was more towards supporting a variety of RFCs in general. As always, TIMTOWTDI :)

[10:57] *** kjs_ joined
[10:57] <mrf> ShimmerFairy: Are there any RFCs outside of the IETF?

[10:58] <ShimmerFairy> mrf: sure, notably the RFC process that started Perl 6 :)

[10:59] <nine> moritz: it fun when you do it and the rare times one discovers it, but negative fun for those who are bitten by the surprising behavior... I guess the latter group is larger.

[10:59] <mrf> ShimmerFairy: that makes sense. 

[10:59] <ShimmerFairy> mrf: even though I suspect most would first think of the IETF when it comes to 'RFC', I personally would clarify that it's about IETF RFCs somewhere, just to minimize any potential confusion :)

[10:59] <ShimmerFairy> nine: what surprising behavior? I don't understand what people expect an unspecified date to turn out as.

[11:00] <nine> ShimmerFairy: it's the worst kind of error. The one that doesn't explode loudly but seems to work at first glance but silently returns wrong results because someone forgot to type the argument.

[11:00] <mrf> ShimmerFairy: Yeah. I was initially leaning towards Grammar::IETF::RFC::* then you can have Grammar::IETF::* for the various actual top level uses of the RFCs like HTTP/MIME/Email/Date. Especially if the RFC's are just roles.

[11:01] <mrf> which is what ugexe has done at the mo. Just need spliting

[11:01] <hoelzro> o/ #perl6

[11:01] <ShimmerFairy> mrf: the only thing is, if you plan on doing more than just grammars, you'd probably want the IETF::RFC::Grammar ordering (thus IETF::RFC_1923::Grammar or IETF::RFC::_1923::Grammar)

[11:01] <dalek> rakudo/curli: b154c49 | lizmat++ | src/ (2 files):

[11:01] <dalek> rakudo/curli: Implement 'no precompilation'

[11:01] <dalek> rakudo/curli: review: https://github.com/rakudo/rakudo/commit/b154c49d52

[11:02] <nine> m: my @ymd; say Date.new(|@ymd)

[11:02] <camelia> rakudo-moar 56dbb0: OUTPUT«2015-12-24␤»

[11:02] <nine> ShimmerFairy: ^^^ this kind of surprise

[11:02] <ShimmerFairy> and then you can do things like IETF::RFC_1923::Client, IETF::RFC_1923::Generator, and so on

[11:03] <lizmat> m: say 'Life, the Universe, and Everything'.WHY   # another surprise, but less dangerous  :-)

[11:03] <camelia> rakudo-moar 56dbb0: OUTPUT«42␤»

[11:03] <ShimmerFairy> nine: I don't think that surprise is more special than any other time you'll try to slip an empty array

[11:03] <lizmat> fwiw, I think a date should at least be given a year

[11:04] <nine> ShimmerFairy: without the little joke it would explode loudly, would therefore be easy to discover and easy to debug.

[11:04] *** weihan joined
[11:04] <ShimmerFairy> nine: not necessarily. If Date defaulted to something more boring like 'today', would you still argue against it?

[11:04] <mrf> ShimmerFairy: hmm. I am not sure what none grammar things would exist in the namespace. 

[11:04] <hoelzro> I was looking at S17-procasync/kill.t last night after fixing the bug that prevents Proc::Async.kill from working, and it seems that that test enumerates over all signals defined by the OS and throws each at a separate child process

[11:05] <hoelzro> since not all signals are equal (ex. SIGTERM vs SIGTSTP vs SIGKILL), I am wondering if that's such a good idea

[11:05] <llfourn> m: wait 1 { say "worked" } # how I get this to work

[11:05] <camelia> rakudo-moar 56dbb0: ( no output )

[11:05] *** ely-se joined
[11:07] <llfourn> or what is the equiv of Mojo::IOLoop->timer( 1 => sub { say "worked" }) in p6

[11:07] <dalek> roast/curli: 1451c65 | lizmat++ | S02-types/WHICH.t:

[11:07] <dalek> roast/curli: Add test for new X::Pragma::CannotPrecomp class

[11:07] <dalek> roast/curli: review: https://github.com/perl6/roast/commit/1451c6536b

[11:07] <nine> ShimmerFairy: would it be documented? The christmas joke isn't. In any case I'd still be against it, even if not as strong. But we do have a Date.today method that makes it explicit, so there's no need for Date.new to do the same. So Date.new can be more strict and catch more bugs before they hurt anyone.

[11:07] <llfourn> and how do I make it wait...?

[11:07] <mrf> So you might have a IETF::HTTP module that uses Grammar::IETF::HTTP which does a whole slew of Grammar::IETF::RFC::*. The name space of the Action object seems sane to place separate from the Grammars. Having Grammars separate seems sane in my brain. But I am usually wrong

[11:08] <lizmat> hoelzro: please adapt test as you see fit... it was just a brute force approach to test what *could* work

[11:08] <hoelzro> alright, will do!

[11:09] <ShimmerFairy> nine: The only reason I'm a bit against your example is that it feels a bit unlikely. I don't feel like you'd often pass an array that's supposed to contain a year, month, and date, and have it accidentally be empty.

[11:10] <lizmat> m: my $i = Supply.interval(1); $i.tap: { .say }; $i.wait   # llfourn 

[11:11] *** rindolf joined
[11:11] <camelia> rakudo-moar 56dbb0: OUTPUT«(timeout)0␤1␤2␤3␤4␤5␤6␤7␤8␤9␤10␤11␤12␤13␤14␤15␤16␤17␤18␤19␤20␤21␤»

[11:11] <nine> ShimmerFairy: parse some strange date format using a regex, pass the capture groups to Date.new. Something goes wrong and the regex doesn't match -> empty result -> no arguments for Date.new. Something along those lines.

[11:11] <lizmat> hmmm... wonder how long camelia will run this

[11:11] <llfourn> lizmat: thanks!

[11:11] <ShimmerFairy> nine: hm. I'd of course say "check if your match was successful", but that does seem possible.

[11:13] *** Ven joined
[11:13] <nine> ShimmerFairy: of course! But people write imperfect code. And error paths are notoriously badly tested. I'd expect a bug like that when I write some one-off tool to get some information for a report out of a log file. And due to the wrongly parsed dates our average reaction time is an ok 3 months while in reality it isn't or something like that.

[11:13] <llfourn> lizmat: so there's no once off?

[11:14] <nine> ShimmerFairy: torture the implementors for the sake of the users, not implementors have fun at the expense of the users.

[11:14] <lizmat> llfourn: ah, you want to execute it once a second from now?   

[11:14] <llfourn> lizmat: yep

[11:14] <lizmat> m: await start { sleep 1; say "hello world" }

[11:14] <camelia> rakudo-moar 56dbb0: OUTPUT«hello world␤»

[11:14] <ShimmerFairy> nine: I think we can live with Date dying in the same way DateTime does without a year. I just don't like the "I don't like fun" argument, that's not a very good one by itself :)

[11:15] <llfourn> lizmat: interesting... is sleep blocking the thread (or am I not meant to think about that as a p6 programmer)?

[11:15] <nine> ShimmerFairy: oh I love fun! Just not when it's gonna hurt users more than it's fun for us.

[11:16] <lizmat> llfourn: sleep is not taking up any CPU or a thread

[11:16] <lizmat> I think it is implemented as a timed cue internally

[11:17] <llfourn> lizmat: so p6 is not necessarily creating a new thread with "start"?

[11:17] <lizmat> indeed: it is just scheduling the task to be done

[11:17] <llfourn> lizmat: that's cool!

[11:17] <lizmat> as soon as a thread is available, it will execute it

[11:19] <ShimmerFairy> nine: I still don't think it's that problematic (esp. since it doesn't come up all that often), but like I said I'd be fine if it went otherwise :)

[11:19] *** Ven left
[11:19] *** Ven joined
[11:20] *** wtw left
[11:21] *** Ven left
[11:21] *** wtw joined
[11:21] *** ely-se left
[11:21] *** Ven joined
[11:23] *** Ven left
[11:23] *** softmoth joined
[11:23] *** Ven joined
[11:23] *** ely-se joined
[11:24] *** BenGoldberg joined
[11:27] <lizmat> hmmm... it looks rather trivial to add :at and/or :in parameters to Promise.start (the underlying logic of start {})

[11:27] *** masak joined
[11:27] <masak> evenin', #perl6

[11:27] <lizmat> masak o/   # cn time

[11:27] <sergot> hi masak \o

[11:27] * masak .oO( I cn haz time )

[11:28] *** softmoth left
[11:31] <BenGoldberg> There already exists a method Promise.start

[11:31] <BenGoldberg> err

[11:31] <llfourn> m: Promise.in(2).then: { say "win" }

[11:31] <BenGoldberg> Promise.in

[11:31] <camelia> rakudo-moar 56dbb0: ( no output )

[11:32] <llfourn> m: await Promise.in(2).then: { say "win" }

[11:32] <camelia> rakudo-moar 56dbb0: OUTPUT«win␤»

[11:32] <llfourn> lizmat: that what you mean?

[11:32] *** tokuhirom_ joined
[11:33] <lizmat> BenGoldberg: Promise.in returns a promise that is kept in X seconds

[11:33] <lizmat> it does not execute any given code

[11:33] <lizmat> ah, but with the then, you're in.... :-)

[11:33] <lizmat> yup

[11:33] <llfourn> :D

[11:34] <BenGoldberg> m: Promise.in(1).then: { say "win" }; sleep 2

[11:34] <lizmat> TIMTOWTDI  :-)

[11:34] <camelia> rakudo-moar 56dbb0: OUTPUT«win␤»

[11:34] <lizmat> m: await Promise.in(1).then: { say "win" }

[11:34] <camelia> rakudo-moar 56dbb0: OUTPUT«win␤»

[11:34] <lizmat> no need for sleep, just await the Promise

[11:35] <pink_mist> lizmat: I think he wanted to see if the promise would have started without needing to await

[11:35] <BenGoldberg> Yup :)

[11:35] <lizmat> ah, ok... yes  :-)

[11:35] <llfourn> mm yes just shows that sleep is not like perl5 sleep

[11:36] <lizmat> perl 5 sleep doesn't take any CPU either

[11:36] <BenGoldberg> As for a :at or .at, most event systems have either absolute clock timing or relative timing, not both.

[11:36] <llfourn> lizmat: but it will block your process

[11:36] <pmurias> moritz: I find the christmas joke about as funny as digging a hole and hoping someone falls in ;)

[11:36] <BenGoldberg> There's a complicated reason why, but I forget what it was ;)

[11:37] *** tokuhirom_ left
[11:37] *** bjz_ left
[11:37] <lizmat> BenGoldberg: the :at would just be a front-end fro calculating an :in, really

[11:37] <lizmat> *for

[11:38] <pmurias> moritz: plus there is a 'new Date()' in javascript

[11:39] <llfourn> lizmat: if you were to say use Mojo::IOLoop->timer(1, sub { say "hello" } ); sleep 10; you would not see your "hello" until after 10 secs I think.

[11:39] *** kid51 joined
[11:39] <lizmat> llfourn: well, that's sub-optimal  :-)

[11:40] <masak> pmurias: re hiding private attributes in Perl 6 -- note that I was arguing for *not* hiding them (from .new/.perl)

[11:41] <llfourn> lizmat: yes which is why you would always have to write a lot of messy callback type code to DWIM. but in p6 you can just sleep 10 the main block and still see your "hello" after 2 secs.

[11:42] *** kjs_ left
[11:42] <llfourn> \o/

[11:42] <lizmat> llfourn: yes, that works in P6  :-)

[11:42] <masak> pmurias: re "destroyed CPAN" -- I think you should consider taking me way less seriously :)

[11:42] *** TEttinger left
[11:44] <masak> pmurias: I don't *really* think that there would be any utility in destroying CPAN. I was mostly sick of people who took the stance that promoting Inline::Perl5 too much would hinder Perl 6 development, and I wanted to satirize that.

[11:44] *** bjz joined
[11:44] *** BenGoldberg left
[11:47] <masak> I've heard next to no reactions on http://strangelyconsistent.org/blog/macros-your-macro-has-been-put-on-hold , btw -- except I seem to have gotten szabgab++'s head spinning: "It's unclear to me what a quasi block is, but it seems it can somehow hold its breath"

[11:51] <pmurias> masak: re .new setting private attributes wouldn't that break encapsulation?

[11:52] <moritz> it would; which is why it doesn't, right now

[11:52] *** kid51 left
[11:52] <moritz> (it used to)

[11:52] <pmurias> masak: for debugging purposes .perl could just have them commented out

[11:53] <ShimmerFairy> masak: despite the fact that you don't take it seriously, I still think it's possible for a too-eager promotion of I::P5 to slow down the development of pure-P6 modules.

[11:54] <moritz> ShimmerFairy: my experience is that people port Perl 5 modules to Perl 6 because they want to improve them in the progress

[11:55] <masak> ShimmerFairy: I think the opposite would happen. Inline::Perl5 would make Perl 6 more attractive today, which would pull in more people, create more contributors, a bigger gravitational pull around Perl 6, and more reason to build pure Perl 6 modules

[11:56] <ShimmerFairy> To be fair, I don't think it would be a very significant slowdown, but I still worry that being too quick to suggest it would temporarily divert the attention of people who're more than happy to write the P6 version :)

[11:56] <masak> ShimmerFairy: I dislike almost all kinds of zero-sum either/or arguing around programming languages, and I would much more like to ride nine++'s happy have-cake/eat-cake train.

[11:57] <masak> ShimmerFairy: you're arguing for limiting the options of people so that they are forced to make Perl 6 better.

[11:57] <lizmat> fwiw, I was first apprehensive of a fully functional Inline::Perl5 as well...

[11:57] *** bjz left
[11:58] <lizmat> but if we can PR it like any of the other Inline:: modules, like Inline::Python, it only becomes more interesting, I think

[11:58] <lizmat> aka: not the best of Both worlds, but the best of All worlds  :-)

[11:58] <lizmat> (especially with NativeCall now also supporting C++  :-)

[11:58] <ShimmerFairy> masak: thinking about it, I suppose at least part of my concern is just because I::P5 would never be something I'd use, so it's just weird for me to see it recommended so much.

[11:59] <nine> I have sometimes wondered if Inline::Python (the Perl 5 version) may actually harm Perl by making it easier for people to migrate from Perl to Python. I've come to the conclusion, that if people want to migrate to Python, they are no happy and productive members of the community anyway. They have their reasons to go and if I help them, so be it. At the end of the day I'd rather help people than force them.

[11:59] <jdv79> it would be neat if .perl could optionally include privates maybe

[12:00] <ShimmerFairy> On .perl, I 

[12:00] <jdv79> otherwise there would have to be some other dumper that poked at hte mop to do it

[12:00] <masak> I'm more concerned with .new than with .perl, to be honest

[12:00] <ShimmerFairy> On .perl, I'll point out that .gist has been conjectured to have various adverbs on it, so adverbs on .perl wouldn't be an issue methinks :)

[12:00] <jdv79> and not sure keeping dumping in .perl totally or having it split it up...

[12:00] <lizmat> jdv79: simple, write your own .perl in a role, and does that in your class 

[12:00] <masak> it feels weird to talk about encapsulation from the creator of the object

[12:00] <lizmat> ?

[12:00] <jdv79> yes. i know.

[12:01] <jdv79> lizmat: but sometimes i'm using something else and i want to see it

[12:01] <pmurias> masak: creator of the object - you mean the guy calling .new?

[12:01] <ShimmerFairy> masak: that's what I pointed out last time, construction doesn't feel like it "counts" as normal object usage.

[12:01] <masak> pmurias: right

[12:01] <jdv79> so, idk, i'm more about whether .perl should be the uber does it all dumper or not

[12:01] <jdv79> which includes pretty, privates, code, etc...

[12:01] <ShimmerFairy> (after all, you have no real 'self' in .new, at least usually)

[12:01] *** bjz joined
[12:02] <masak> ShimmerFairy: arguably when constructing an object, it's still "open" and hence not encapsulated

[12:02] <nine> Rather than Perl having a reputation of "the legacy language that's hard to migrate from", I'd like it to be "The language, that never lets you down. Even if you have to move away from it."

[12:02] <masak> I feel we're upholding the privacy barrier during .new/.bless for academic reasons that end up being of no use and just obstacles in practice

[12:02] <masak> nine: never gonna give you up

[12:03] <jdv79> all the hub bub around I::P5 seems silly and petty esp since its a done deal;)

[12:03] <nine> jdv79: oh I'm not done yet!

[12:03] <ShimmerFairy> jdv79: there's a spot in the specs that mentions .gist having things like :oneline and such. Whether those should be there, or the fact that it's still NYI is a sign .gist and .perl shouldn't be "do-everything", who can say? :)

[12:03] <masak> nine: never gonna run around and desert you

[12:03] <pmurias> masak: if we thing about it in terms of protecting the data it's still "open"

[12:03] *** Ven left
[12:04] *** adhoc joined
[12:04] <nine> Oh, speaking of it. I have a bootleg video of my YAPC::EU talk! http://niner.name/talks/YAPC2015-Granada-Nines_Talk-HD720.m4v

[12:04] <pmurias> masak: but if we thing it in terms of having a private/public API, .new is still part of the public API

[12:04] <masak> re .perl -- maybe an `is perlable` on private attributes could work?

[12:04] <nine> For those who missed the early Friday morning slot

[12:05] <masak> pmurias: yeah, but that argument does nothing for me when I feel annoyed that I can't init my private attrs through .new/.bless

[12:05] <tadzik> Oh, bootleg:)

[12:05] <masak> I can heartily recommend nine's talk. it was one of the best on the conference.

[12:05] * nine blushes

[12:05] <nine> thank you masak

[12:06] *** andreoss` left
[12:06] <llfourn> masak: ....and `is paramable` to allow the private attribute to be set by bless?

[12:06] <ShimmerFairy> pmurias: I'm not sure if you saw, but my contention was that all attributes are private really, and  has $.foo;  just is nice sugar for creating a getter (and maybe setter) method for you. So the restrictions in .bless and so on feel more arbitrary (or, as masak++ put it, academic) than useful.

[12:06] <llfourn> masak: or you think it should be default accessible?

[12:06] <pmurias> ShimmerFairy: you repeated it multiple times and was wrong all of them

[12:07] *** weihan left
[12:08] *** rurban left
[12:08] <masak> llfourn: the latter.

[12:09] <pmurias> masak: the question is do you want to set private attributes through .new/.bless or do you want public attributes without an accessor?

[12:09] <llfourn> masak: but what if you really don't want it to be able to be set?

[12:10] <pmurias> masak: if you can access them using a public method (new) it feels like they are really public attributes

[12:11] <nine> Why should a class' method not be able to access the object's properties?

[12:12] <pmurias> nine: the user external to the class is accessing them through .new

[12:12] <pmurias> nine: so they are visible to him

[12:12] <ShimmerFairy> pmurias: I don't think .new setting attributes can really be called "access", at least not in the intuitive sense of "access" meaning "get something"

[12:13] <moritz> ShimmerFairy: writing is just a valid an access as reading

[12:13] <llfourn> as far as I understand the proposal is to give `bless` special access to privates not `new`..right?

[12:13] <moritz> llfourn: but .new delegates to .bless

[12:13] <moritz> llfourn: so the point is moot

[12:14] *** tokuhirom_ joined
[12:14] <llfourn> lizmat: 

[12:14] <llfourn> moritz: very well :)

[12:14] *** ely-se left
[12:17] *** BenGoldberg joined
[12:18] *** [Sno] left
[12:19] <llfourn> Moose let you opt out of having your attribute (private or not) be able to be set by the constructor: https://metacpan.org/pod/distribution/Moose/lib/Moose/Manual/Attributes.pod#Constructor-parameters-init_arg

[12:20] <llfourn> init_arg => undef did that... (of course privates were only adhoc with _attr)

[12:20] <llfourn> it was a useful feature from time to time when you really wanted to have your default value be the starting value for your attribute

[12:21] *** flaviusb left
[12:21] *** lea joined
[12:21] <llfourn> and didn't want to person .new -ing it to be able to change that

[12:21] *** BenGoldberg left
[12:21] *** kjs_ joined
[12:22] *** lea left
[12:23] *** azawawi joined
[12:24] <azawawi> hi

[12:24] <azawawi> for some reason I cant use http://webchat.freenode.net/

[12:25] * llfourn tries to go to http://webchat.freenode.net/ but it doesn't load

[12:25] <moritz> azawawi: for some reason, this isn't even a useful bug report :-)

[12:25] <azawawi> :)

[12:25] <dalek> rakudo/curli: 4ac23d1 | lizmat++ | src/core/Compiler.pm:

[12:25] <dalek> rakudo/curli: Implement $*PERL.compiler.id

[12:25] <dalek> rakudo/curli: review: https://github.com/rakudo/rakudo/commit/4ac23d1fb6

[12:25] <moritz> maybe ask #freenode?

[12:25] *** bjz_ joined
[12:26] <azawawi> https://github.com/azawawi/perl6-selenium-webdriver/issues/2   # Selenium WebDriver protocol client implemented in Perl 6 :)

[12:26] *** bjz left
[12:26] *** Ven joined
[12:28] *** telex left
[12:29] *** telex joined
[12:29] <azawawi> now off to writing doc.perl6.org ui tests :)

[12:30] <azawawi> what sort of functionality in our documentation website needs to be tested all the time?

[12:31] *** Hor|zon left
[12:31] *** lea joined
[12:33] <moritz> searching for stuff

[12:33] <llfourn> azawawi: I guess the search bar is the most dynamic part that would benefit from selenium?

[12:34] <azawawi> maybe also testing sample links for content etc

[12:35] *** Jaglor joined
[12:35] <azawawi> the thing is that with selenium you could test X browser types against your website

[12:36] <azawawi> phantomjs is the headless one ofcourse

[12:36] <azawawi> the others will launch a browser process and automate it

[12:37] <dj_goku> azawawi: I saw in p6 weekly about Selenium::Webdriver in P6. thanks!

[12:40] <azawawi> dj_goku: thanks. Really? I did not see it :)

[12:40] * llfourn realises that nine++'s talk is 2.6gb in size :S

[12:41] <moritz> quite a lot of talking, eh? :-)

[12:41] <azawawi> compress it :)

[12:41] <llfourn> moritz: it must be intense high fidelity talking

[12:43] <azawawi> coming to you in 4K and Dolby Surround 7.1 :)

[12:44] <nine> Feel free to re-encode the video and maybe upload somewhere else!

[12:44] <llfourn> azawawi: it's probably 3D

[12:45] *** Ven left
[12:45] <llfourn> nine: ok!

[12:45] <azawawi> selenium has a firefox IDE addon to record UI actions/assertion. Now with Parse::Selenese grammar (DONE) we could parse selenese commands and convert them into Perl 6 Selenium::WebDriver tests :)

[12:46] <masak> I guess the argument that can be made for allowing .new/.bless write access to private attrs is this: the object is not formed yet, or is under construction, so normal expectations on invariants and encapsulation are not in force yet.

[12:47] <azawawi> so you record them, save them as HTML (via Firefox addon) and then convert and run them via Perl 6.

[12:47] <ShimmerFairy> masak: first analogy that pops up in my head is electrical wiring in a house; very much something you need to mess with during construction, but after you're done you do not want to mess with that, least of all by accident :)

[12:50] <pmurias> masak: the counter argument would be that if you create the object with stuff that's not part of the part of the public API the expectations will never be in force

[12:50] <moritz> masak: that feels like an excuse. The "can I rename a private attribute without anything breaking?"-test still fails if .new is allowed to write to rpivate attributes

[12:52] * llfourn feels that both behaviours are useful but you need to be able to opt in or out of them

[12:53] *** Ven joined
[12:54] <masak> moritz: good point.

[12:54] <azawawi> https://letsencrypt.org/ # cool

[12:55] <masak> moritz: though that could equally well be called the fault of *%_

[12:55] <nine> moritz: why is the .new method seen as something external that has to go through the public API? It is part of the Class, isn't it?

[12:55] <llfourn> moritz: why is it better that new is not allowed and submethod BUILD is allowed?

[12:55] <pmurias> nine: it's not

[12:55] <pmurias> the .new method is part of the public API

[12:55] *** sufrostico joined
[12:56] <ShimmerFairy> fwiw, .bless is part of the public API, but I'm sure just about everyone doesn't see it as such :)

[12:56] * ShimmerFairy guesses .bless would be a 'protected' method, if we had that level of access in P6

[12:57] <pmurias> nine: so if you create an object using Foo.new(private_attr=>234) you are exposed to the fact that private_attr exists

[12:57] <moritz> nine: I don't care which API .new uses

[12:58] <moritz> nine: I care about whether the default behavior of a public constructor is to allow setting private data

[12:58] <moritz> nine: if we end up with something where that isn't the case, I'm fine with custom .new methods being allowed

[12:58] <moritz> ... to do whatever they please

[12:59] <pmurias> masak: would having a convinient way to just mark some attributes as settable by the constructor solve your problem?

[12:59] <moritz> llfourn: .new is inherited from Mu; submethods aren't inherited

[12:59] <llfourn> moritz: ok :)

[13:00] *** krunen joined
[13:00] * llfourn will think over that one

[13:01] <moritz> https://www.reddit.com/r/perl/comments/3phfx3/is_there_will_there_be_a_perl6_equivalent_to_the/

[13:01] <moritz> "Is there / will there be a Perl6 equivalent to the Camel Book?"

[13:02] <nine> moritz: just this morning I tried to turn Instant.from-posix into a constructor that set 2 private attributes. I had to write a very boring private method because the constructor couldn't just initialize them with bless.

[13:03] <moritz> nine: I'm fine with .bless initialzing private attributes, as long as the public API doesn't

[13:03] <ShimmerFairy> moritz: but .bless is part of the public API

[13:03] <ShimmerFairy> m: class A { has $.b }; say A.bless(:b(42));

[13:03] <camelia> rakudo-moar 56dbb0: OUTPUT«A.new(b => 42)␤»

[13:03] * llfourn thinks mortiz means default constructor by public API

[13:03] <nine> moritz: if we make the default .new set private attributes using named arguments, those named arguments are part of the method's API. Not necessarily internals of your class. One can still change the private attribute's names for example while keeping method new's argument names the same.

[13:04] <masak> pmurias: I dunno -- I feel slightly swayed by moritz++' argument right now.

[13:04] <moritz> ShimmerFairy: maybe it shouldn't be

[13:04] * azawawi &

[13:05] *** azawawi left
[13:05] <moritz> or maybe it should have a switch to initialize private attributes that requires trust (that is, either called from within the same class, or one that's explicitly trusted)

[13:06] <ShimmerFairy> moritz: the problem is, if .bless was in fact  method !bless  , then how could subclasses have a .bless to use? We'd need a 'protected' level of access for that, methinks.

[13:06] <moritz> ShimmerFairy: I'm not sure; I'll think a bit about it

[13:07] *** ponzellus joined
[13:07] <ShimmerFairy> moritz: I do agree that I shouldn't be able to call .bless on a object, in case that wasn't clear. Just pointing out the surprising fact that you can right now :)

[13:07] <masak> in unrelated but happy news, 007 doesn't have a public/private distinction on the object level ;)

[13:08] <ShimmerFairy> nor does NQP :P

[13:10] *** blackcat joined
[13:10] *** blackcat is now known as loren

[13:11] *** softmoth joined
[13:12] <llfourn> the way things are now make sense to me but: class A { has $!a; submethod BUILD(:$!a) { }; } # is quite ugly for such a simple task

[13:13] <ShimmerFairy> llfourn: especially since you'd be required to handle all the public attributes you have too, unless I'm mistaken.

[13:14] <llfourn> ShimmerFairy: let's see

[13:14] <llfourn> ShimmerFairy: you're right o.O

[13:15] <llfourn> m: class A { has $!a; has $.b; submethod BUILD(:$!a,|) { }; }; say A.new(a => 42,b => 42);

[13:15] <camelia> rakudo-moar 56dbb0: OUTPUT«A.new(b => Any)␤»

[13:16] *** CQ joined
[13:16] *** softmoth left
[13:18] *** rudi_s_ left
[13:19] *** petercommand left
[13:20] *** aborazmeh joined
[13:20] *** aborazmeh left
[13:20] *** aborazmeh joined
[13:25] *** Ven left
[13:25] <dalek> rakudo/curli: 2daba3e | lizmat++ | src/core/Exception.pm:

[13:25] <dalek> rakudo/curli: X::Pragma::CannotPrecomp more generally useful

[13:25] <dalek> rakudo/curli: review: https://github.com/rakudo/rakudo/commit/2daba3e64c

[13:27] *** et09 joined
[13:30] *** bjz_ left
[13:32] *** Ven joined
[13:32] <dalek> rakudo/curli: b14e925 | lizmat++ | src/Perl6/World.nqp:

[13:32] <dalek> rakudo/curli: Disallow precompilation of "use lib"

[13:32] <dalek> rakudo/curli: 

[13:32] <dalek> rakudo/curli: For Perl 6.Christmas, we're going to disallow changing repo's from

[13:32] <dalek> rakudo/curli: inside a module.  Since we don't have that concept yet, but generally

[13:32] <dalek> rakudo/curli: only precomp modules (and no scripts), disallowing precomping is a

[13:32] <dalek> rakudo/curli: way to catch this at least at this point in the module development cycle.

[13:32] <dalek> rakudo/curli: review: https://github.com/rakudo/rakudo/commit/b14e9259bd

[13:34] <FROGGS> lizmat: so one is not allowed to precompile something that contains a 'use lib'?

[13:35] <lizmat> well, it's more general, really

[13:35] <FROGGS> it is how I read it

[13:35] <lizmat> modules may not have a "use lib" in it, at least not for 6.c

[13:35] <lizmat> and modules get precomped

[13:36] <FROGGS> ohh

[13:36] <lizmat> even better would be if "use lib" would blow up when inside a module

[13:36] <lizmat> at parse time, but I haven't gotten to that yet

[13:36] *** ely-se joined
[13:37] *** bjz joined
[13:38] *** azawawi joined
[13:38] <nine> lizmat, FROGGS: what do you think about jnthn++'s gist regarding module installation? Anything we can start to implement?

[13:38] *** pierrot_ left
[13:38] *** pierrot joined
[13:38] <lizmat> nine: that's what I'm doing  :-)

[13:39] <FROGGS> ohh, I did not even know there is one!

[13:39] <FROGGS> link?

[13:39] <lizmat> FROGGS does not read P6W ?

[13:40] <lizmat> https://gist.github.com/jnthn/47a42b2e86e7e552b2e2

[13:40] <FROGGS> I did...

[13:40] <FROGGS> hh, under blog posts

[13:40] <FROGGS> ahh*

[13:40] <azawawi> https://github.com/SeleniumHQ/www.seleniumhq.org/pull/48/  # How Perl 6 is initially perceived...

[13:41] <lizmat> :-)

[13:42] *** bjz_ joined
[13:42] *** bjz left
[13:42] *** d^_^b joined
[13:45] <dalek> roast/kill-t-fixes: fe064dc | hoelzro++ | S17-procasync/kill.t:

[13:45] <dalek> roast/kill-t-fixes: kill.t: Only test SIGINT

[13:45] <dalek> roast/kill-t-fixes: 

[13:45] <dalek> roast/kill-t-fixes: SIGINT is available on all of our target operating systems, and it has

[13:45] <dalek> roast/kill-t-fixes: consistent semantics among them.  We shouldn't try every signal

[13:45] <dalek> roast/kill-t-fixes: available to us, because some of them are unblocked (ex. SIGKILL,

[13:45] <dalek> roast/kill-t-fixes: SIGSTOP), and others have different semantics than "normal" (ex.

[13:45] <dalek> roast/kill-t-fixes: SIGTSTP)

[13:45] <dalek> roast/kill-t-fixes: review: https://github.com/perl6/roast/commit/fe064dcb4b

[13:45] <dalek> roast/kill-t-fixes: cc5583c | hoelzro++ | S17-procasync/kill.t:

[13:45] <dalek> roast/kill-t-fixes: kill.t: Exit after handling signal in child

[13:45] <dalek> roast/kill-t-fixes: 

[13:45] <dalek> roast/kill-t-fixes: The default behavior after handling a signal is to carry on; we

[13:45] <dalek> roast/kill-t-fixes: want our child to exit early

[13:45] <dalek> roast/kill-t-fixes: review: https://github.com/perl6/roast/commit/cc5583cf3b

[13:45] <dalek> roast/kill-t-fixes: 9a2db9a | hoelzro++ | S17-procasync/kill.t:

[13:45] <dalek> roast/kill-t-fixes: kill.t: Give the child some time to start up

[13:45] <dalek> roast/kill-t-fixes: 

[13:45] <dalek> roast/kill-t-fixes: Currently (on MoarVM), calls to kill() are immediate and not enqueued for

[13:45] <dalek> roast/kill-t-fixes: running after the child has had a chance to start up.  So we introduce

[13:45] <dalek> roast/kill-t-fixes: an artificial delay to make sure the child has had a chance to start

[13:45] <dalek> roast/kill-t-fixes: review: https://github.com/perl6/roast/commit/9a2db9af9e

[13:45] <dalek> roast/kill-t-fixes: 051ca2b | hoelzro++ | S17-procasync/kill.t:

[13:45] <dalek> roast/kill-t-fixes: kill.t: reenable actual sending of signals to child

[13:45] <dalek> roast/kill-t-fixes: review: https://github.com/perl6/roast/commit/051ca2b720

[13:47] *** Ven left
[13:47] *** weihan joined
[13:49] <azawawi> my $username-element = $driver.find-element-by-id("username")     # any ideas how to make it more Perl6ish?

[13:49] <dj_goku> azawawi: https://p6weekly.wordpress.com under Ecosystem Additions

[13:49] <azawawi> dj_goku: thx

[13:50] <[Coke]> azawawi: that line seems fine to me.

[13:50] <dalek> rakudo/curli: f8e7eb1 | lizmat++ | src/core/Exception.pm:

[13:50] <dalek> rakudo/curli: Add X::Package::UseLib exception

[13:50] <dalek> rakudo/curli: review: https://github.com/rakudo/rakudo/commit/f8e7eb1dd8

[13:50] <dalek> rakudo/curli: 9986c52 | lizmat++ | src/Perl6/World.nqp:

[13:50] <dalek> rakudo/curli: Disallow use lib inside any package declaration

[13:50] <dalek> rakudo/curli: review: https://github.com/rakudo/rakudo/commit/9986c52f19

[13:50] <dalek> roast/curli: 05a31b0 | lizmat++ | S02-types/WHICH.t:

[13:50] <dalek> roast/curli: Add X::Package::UseLib

[13:50] <dalek> roast/curli: review: https://github.com/perl6/roast/commit/05a31b08d7

[13:51] <PerlJam> azawawi: $driver.find-element("username", :by<id>);  # maybe more 6y along a certain dimension

[13:51] <azawawi> i was also thinking $driver.element( :id('username') )  # more jQuery-like

[13:52] <PerlJam> aye, that one is nice too

[13:52] <azawawi> or .element-by(...) that is

[13:53] <nine> .element-by-id would be my choice, since it not only finds the element, it also returns it. And by-id is a bit of a special case, because there may only be one element with a given id.

[13:53] <nine> Other find-* methods have to deal with multiple results.

[13:54] <PerlJam> 1 is just a special case of many  :)

[13:54] <nine> Good rule of thumb: a method should do one and only one thing

[13:54] <azawawi> nine: also auto-completion friendly

[13:54] <FROGGS> lizmat: you need to change some packages in t/spec/packages... some of them contain a 'use lib'

[13:54] <nine> azawawi: jQuery is the last place where I would look for API design inspiration :)

[13:55] <azawawi> nine: true but it is easy to remember lol

[13:56] <lizmat> FROGGS: indeed...  but fortunately (?) the use is not inside the package, and the module is not precomped

[13:56] <lizmat> so, atm, they're just considered script with a package in it, right ?

[13:56] <dj_goku> azawawi: is the idea to add tests here: https://github.com/perl6/doc ?

[13:57] <lizmat> I had some fallout in the spectest related to precomp, but I thought that was related to some other work I'd done earlier

[13:57] <lizmat> based on my CURLI gist

[13:57] <azawawi> nine: https://github.com/azawawi/perl6-selenium-webdriver/issues/4 :)

[13:58] *** sufrostico left
[13:58] <azawawi> dj_goku: im tracking it here https://github.com/azawawi/perl6-selenium-webdriver/issues/1

[13:58] <nine> azawawi: shouldn't it be the other way round?

[13:59] <lizmat> nine FROGGS I intend to work on jnthn's gist in the coming days, see how far I can get before he returns

[13:59] <azawawi> nine: fixed :)

[13:59] *** CQ left
[13:59] <lizmat> first thing I'm going to focus on is CompUnit::Loader

[14:00] <lizmat> BTW, all work is done in the "curli" branch

[14:01] * PerlJam checks to see if we also have mo and larri branches

[14:02] <lizmat> :-)

[14:02] * azawawi home &

[14:02] *** azawawi left
[14:03] *** ely-se left
[14:04] *** aborazmeh left
[14:06] *** tokuhiro_ left
[14:06] <nine> lizmat: maybe I can contribute something, too :)

[14:07] <lizmat> that would be excellent!

[14:08] <lizmat> do you have questions about jnthn's gist ?

[14:09] <nine> lizmat: none that I remember. I read it at the weekend and I'm gonna read it again this evening

[14:09] <lizmat> ok

[14:10] <lizmat> this evening I'll be at the Niederrhein PM meeting, so probably won't be able to do much

[14:10] <lizmat> I'll try to be on channel though, to answer any questions

[14:11] <itz_stmuk> is a heisenbug in rakudo likely to be a bug at a lower level like nqp?

[14:12] <nine> itz_stmuk: it's at least not unlikely

[14:15] <dalek> rakudo/curli: 062e778 | lizmat++ | / (4 files):

[14:15] <dalek> rakudo/curli: Add stubs for CompUnit::Handle/Loader

[14:15] <dalek> rakudo/curli: 

[14:15] <dalek> rakudo/curli: copy-pasted from jnthn's gist + added to setting creation spec

[14:15] <dalek> rakudo/curli: review: https://github.com/rakudo/rakudo/commit/062e7786a2

[14:17] *** spider-mario left
[14:18] *** n0tjack joined
[14:19] *** simcop2387 left
[14:20] *** simcop2387 joined
[14:20] *** ely-se joined
[14:21] *** AlexDaniel joined
[14:27] *** perigrin joined
[14:27] *** Ven joined
[14:33] <itz_stmuk> didn't [ptc] run coverity?

[14:33] <lizmat> commute to NR.pm

[14:33] *** lizmat left
[14:33] <FROGGS> lizmat: I'll also read the gist this evening... ohh well :o)

[14:34] <FROGGS> itz_stmuk: I think so, yes

[14:35] *** jlb333333 joined
[14:35] <jlb333333> join

[14:36] <masak> jlb333333: join in! welcome! :D

[14:39] <Ven> oi, oy

[14:39] <ugexe> mrf: you can use any of the individual rfcs in grammar::http, you just create your grammar and `does Grammar::HTTP::RFCxxxx` to it

[14:39] <ugexe> the reason the rfcs aren't individual distros is because 7230-7235 all need each other, and all the other grammars are of trivial length that they aren't worth adding external dependency (4647 is 2 lines for instance)

[14:39] <ely-se> Ven: vei, vey

[14:39] *** ugo left
[14:39] <Ven> ely-se: well met

[14:39] *** jlb333333_ joined
[14:39] <Ven> ely-se: i thought you didn't like perl6, yet you're still around :P

[14:40] <Ven> .oO( by the power of the nice community, I compel you! )

[14:40] *** jlb333333 left
[14:40] <ugexe> i dont like brushing my teeth but i still do it

[14:40] <Ven> ugexe: do you go to #toothbruth on IRC? :P

[14:40] *** softmoth joined
[14:40] <ugexe> just #toothbruh

[14:40] <ely-se> #toothbrush is my favourite channel

[14:41] <n0tjack> I like #payingtaxes

[14:41] <mrf> ugexe: I was thinking more of placing all IETF RFCs into a single repo as they are used in more than HTTP. 

[14:41] <|Tux|> http://www.perlmonks.org/?node_id=1145436 <= whose fault? Can someone else help?

[14:41] <mrf> ugexe: I spent time writing them myself becuase I didn't think of looking in Grammer::HTTP for them.

[14:42] <mrf> I would likely have looked in Grammer::RFC or the like

[14:42] *** skids joined
[14:42] <n0tjack> |Tux|: I believe that means your panda (and probably Rakudo) are out of date

[14:43] <n0tjack> huh, panda doesn't have a --version flag. that's a bit silly.

[14:43] <|Tux|> it is not me: my panda workes like a charm

[14:44] * |Tux| feeds it enough bamboo to keep it satisfied

[14:44] <n0tjack> Well, the guy who has the problem then.

[14:44] <n0tjack> You might ask him to do perl6 --version, and/or panda update

[14:44] <ugexe> mrf: right, believe me i considered it enough that the repo was originall called Perl6-IETC--RFC_Grammar--HTTP

[14:44] <mrf> ugexe: though I accept that this would add additional dependencies that might be undesirable. 

[14:44] <mrf> ugexe: why the link to HTTP

[14:45] * n0tjack once saw a panda poop on another panda in the san diego zoo. to all appearances, panda #2 was unfazed.

[14:45] <ugexe> well when i search for something to parse http, the first thing i look for isnt some cryptic rfc

[14:45] <mrf> ugexe: I think teh idea I have is more to seperate the Grammars that implement the RFC from the Grammars that use them to implement something specific

[14:46] <ugexe> you can't piece together grammars like that very well yet

[14:46] <ugexe> thats why all the rfcs are roles in grammar::http

[14:46] <mrf> ugexe: indeed. So I would expect a HTTP::Message module that uses a HTTP::Message grammar which does a whole bunch of Grammars.

[14:46] <ugexe> and there is a single centralized grammar that doesnt do anything but `does RFCxxx RFCyyy`

[14:47] <ugexe> i think a better module search would take `provides` into consideration, so searching for rfc7230 would turn up Grammar::HTTP's lib/Grammar/HTTP/RFC7230.pm6

[14:47] <dalek> specs: 93d6e5f | (Nova Patch)++ | S05-regex.pod:

[14:47] <dalek> specs: tcuc() was removed two years ago

[14:47] <dalek> specs: 

[14:47] <dalek> specs: reference: d1f9930373d9aa92dd24df24212cb3cbd74f4de6

[14:47] <dalek> specs: review: https://github.com/perl6/specs/commit/93d6e5f207

[14:48] *** g4 left
[14:49] <n0tjack> m: o.WHAT;

[14:49] <camelia> rakudo-moar 56dbb0: OUTPUT«5===SORRY!5=== Error while compiling /tmp/VIl41OkcxJ␤Undeclared routine:␤    o used at line 1␤␤»

[14:49] <n0tjack> m: sqrt o +;

[14:49] <camelia> rakudo-moar 56dbb0: OUTPUT«5===SORRY!5=== Error while compiling /tmp/44mBXFRF22␤Prefix + requires an argument, but no valid term found␤at /tmp/44mBXFRF22:1␤------> 3sqrt o +7⏏5;␤    expecting any of:␤        prefix␤»

[14:49] <mrf> ugexe: so for context I came at this wanting an Email::Address style parser that could validate etc email address. I didn't even think of looking in *HTTP* for the Grammars.

[14:50] <mrf> modules like Email::Address and HTTP::Message would likely share a whole bunch of grammars yes? 

[14:52] <mrf> ugexe: Am I making any sense. Or am I just talking bollocks?

[14:53] <ilmari> m: &sqrt o &infix:<+>

[14:53] <camelia> rakudo-moar 56dbb0: ( no output )

[14:53] <ilmari> m: say &sqrt o &infix:<+>

[14:53] <camelia> rakudo-moar 56dbb0: OUTPUT«-> |args is raw { #`(Block|51403952) ... }␤»

[14:53] *** ely-se left
[14:54] <ilmari> m: say &infix:<o>.WHAT

[14:54] <camelia> rakudo-moar 56dbb0: OUTPUT«(Sub)␤»

[14:54] <n0tjack> what are the semantics for  %hash1 ~~ %hash2 ? Identical keys and match-y values?

[14:54] <ilmari> n0tjack: operators have funny names

[14:54] <n0tjack> ilmari: thanks

[14:54] <n0tjack> I do overlook the use/mention distinction for subs in P6 a lot

[14:55] <n0tjack> that's one place p6 has traded off DWIMminess for consistency

[14:55] <n0tjack> or, rather, workability :)

[14:55] <ilmari> s/subs/operators/

[14:55] <ugexe> mrf: it makes sense, but pulling it off leads to its own problems. that is how i originally tried to design it but with things like 7230-7235 you would have circular dependencies

[14:55] <n0tjack> well, for subs too

[14:55] <grondilu> m: say { foo => "bar" } ~~ { foo => "bar" }

[14:55] <camelia> rakudo-moar 56dbb0: OUTPUT«False␤»

[14:56] <n0tjack> yikes

[14:56] <n0tjack> me no likey

[14:56] <ilmari> m: say { foo => "bar" }.WHAT

[14:56] <camelia> rakudo-moar 56dbb0: OUTPUT«(Hash)␤»

[14:56] *** ely-se joined
[14:56] <grondilu> looks LTA indeed

[14:56] <n0tjack> LTA?

[14:57] <n0tjack> ah

[14:57] <grondilu> "Less Then Awesome".  See S99

[14:57] <grondilu> *Than

[14:57] <n0tjack> yeah, just did

[14:57] <n0tjack> thanks

[14:58] <mrf> ugexe: could you not split *all* the roles into one repo and leave Grammer::HTTP.pm6 in the current repo (I realise this leaves one tiny repo but it makes semantic sense)

[14:58] *** Ven left
[14:58] <ugexe> not really, because it makes testing almost impossible

[14:58] <n0tjack> m: say 1000.WHAT; say 1e3.WHAT; say (10**3).WHAT;

[14:58] <camelia> rakudo-moar 56dbb0: OUTPUT«(Int)␤(Num)␤(Int)␤»

[14:58] <mrf> ugexe: Why?

[14:59] <grondilu> m: say { foo => "bar" } === { foo => "bar" }

[14:59] <camelia> rakudo-moar 56dbb0: OUTPUT«False␤»

[14:59] <mrf> SUrely just a dummy class that tests a specific grammar.

[14:59] <ugexe> because then you have dependencies, and you will have circular dependencies

[14:59] <ilmari> there is no Map.ACCEPTS(Map $)

[14:59] <ilmari> http://docs.perl6.org/routine/ACCEPTS#class_Map

[15:00] *** FROGGS left
[15:00] <ilmari> m: say { foo => "bar" } == { foo => "bar" }

[15:00] <camelia> rakudo-moar 56dbb0: OUTPUT«True␤»

[15:00] <n0tjack> m: say { foo => 12, bar = 13 } == {bar => , foo => 12};

[15:01] <camelia> rakudo-moar 56dbb0: OUTPUT«5===SORRY!5=== Error while compiling /tmp/nE0ceogkVP␤Preceding context expects a term, but found infix = instead␤at /tmp/nE0ceogkVP:1␤------> 3say { foo => 12, bar =7⏏5 13 } == {bar => , foo => 12};␤»

[15:01] <n0tjack> m: say { foo => 12, bar = 13 } == {bar => 13, foo => 12};

[15:01] <camelia> rakudo-moar 56dbb0: OUTPUT«5===SORRY!5=== Error while compiling /tmp/oZ3ZxSLNkq␤Preceding context expects a term, but found infix = instead␤at /tmp/oZ3ZxSLNkq:1␤------> 3say { foo => 12, bar =7⏏5 13 } == {bar => 13, foo => 12};␤»

[15:01] <n0tjack> m: say { foo => 12, bar => 13 } == {bar => 13, foo => 12};

[15:01] <camelia> rakudo-moar 56dbb0: OUTPUT«True␤»

[15:01] *** khw joined
[15:02] *** ely-se left
[15:02] <ugexe> mrf: once a grammar can `does OtherGrammar` it might be possible

[15:03] <mrf> ugexe: I thought that was possible. That kind of sucks.

[15:04] <ShimmerFairy> m: role G { token foo { foo } }; grammar H does G { }; say H.parse("foo", :rule<foo>)    # you can certainly compose a Grammar-ish role, however

[15:04] <camelia> rakudo-moar 56dbb0: OUTPUT«｢foo｣␤»

[15:04] <ugexe> yes, thats how http::grammar is setup

[15:05] <ShimmerFairy> you can also 'is' a grammar, I don't know if that's acceptable in this case though.

[15:06] <ugexe> not usually, because rfcs have tokens that will conflict

[15:07] <mrf> ugexe: because all rfcs use localised rules?

[15:07] *** tokuhiro_ joined
[15:07] <ShimmerFairy> any reason  role G is Grammar  isn't acceptable as a composeable Grammar? Unless I've forgotten something grammars are just classes with a default parent of Grammar instead of the more usual one.

[15:07] <ugexe> because the token `time` might mean a different format of timestamp depending on the rfc

[15:08] *** rarara_ joined
[15:08] <mrf> ugexe: but shouldn't the tokens be localised to the RFC anyway. 

[15:09] <ugexe> no, because the rfcs say stuff like `<.FWS>` that other rfcs use

[15:09] *** shlomif joined
[15:10] *** rindolf left
[15:10] *** shlomif is now known as rindolf

[15:10] <mrf> ugexe: There are only a few special common rules that I have seen. Can you give an example of any outside those declared in RFC4234.5234

[15:11] <ugexe> 5322 has like 30 rules

[15:11] *** tokuhiro_ left
[15:12] <rarara_> Hello, with hashes it is possible to do things like %hash<first second>.join(" ")    ....   is there a similar construct for calsses? something like $class{.first .second}.join(" ") ?

[15:12] <ugexe> about half are localized, the others no (because they are used by other rfcs)

[15:12] *** Ven joined
[15:13] <n0tjack> rarara_: you could try something like [.first, .second].join(" ") given Foo.new("one", "two");

[15:13] <n0tjack> might have to fiddle the syntax a bit

[15:14] *** telex left
[15:14] *** rindolf left
[15:15] <mrf> ugexe: hmm ok. That kinda sucks

[15:15] <rarara_> n0tjack : Thank you

[15:15] *** kst` is now known as kst

[15:15] *** tokuhirom_ left
[15:16] *** virtualsue joined
[15:16] *** telex joined
[15:16] <rarara_> works also with normal parenthesis (vs squared ones)

[15:16] <rarara_> But I don't know which one would be more performant

[15:17] <n0tjack> rarara_: Round parens () make an Array, Square bracket [] make a List

[15:18] *** n0tjack_ joined
[15:18] *** n0tjack left
[15:18] <rarara_> n0tjack it is the opposite here

[15:19] <n0tjack_> I'd say at this point in p6's development, learning the language will be a better use of your time than worrying about performance

[15:19] <n0tjack_> there's a lot of work to do yet in the compiler that will have a bigger impact on performance than stuff you do in your own code

[15:19] *** jlb333333_ left
[15:19] <n0tjack_> rarara_: I might have gotten that mixed up. But one is a list, the other an array.

[15:19] <ugexe> i dunno, i can write some pretty bad code

[15:20] <rarara_> I agree, but I was thinking that list might make more sense since we use the data immediately in join

[15:20] <rarara_> while Array seems to me more suited for storing modifiable things

[15:20] <n0tjack_> that's the general idea, yes

[15:21] <n0tjack_> but it's a small piece of code and I don't imagine the choice will have much impact on the overall application

[15:21] <n0tjack_> alright, have to go visit a customer

[15:21] <rarara_> n0tjack good luck!

[15:22] *** rindolf joined
[15:22] <ugexe> mrf: if you find a way to split them apart where they are still testable i would be open to it. its just when i tried this like a year ago i had problems (and maybe they are resolved these days)

[15:23] <ugexe> i have no problem dropping 20-some modules and making dalek earn his bones lol

[15:23] <mrf> ugexe: I will see what I can do. 

[15:24] <mrf> ugexe: however I suspect that if you couldn't manage it I won't either, but you never know

[15:25] <ugexe> well, i couldnt manage it *6+ months ago*. lots has changed

[15:25] <mrf> ugexe: that sounds like something a go developer would say

[15:25] <ugexe> it took me this long to split the grammar out from zef

[15:26] <ugexe> golang changes have nothing on perl6 changes heh

[15:26] *** raiph joined
[15:28] *** n0tjack_ left
[15:28] <ugexe> personally i'd prefer to drop the pointless namespace and just call them `RFCxxx` instead of IETF_Grammar::RFC[\d+ | "::RFC" \d+]

[15:30] <ugexe> that way you can mix in a lot of rfcs without huge swaths of `IETF_Grammar::`

[15:31] <mrf> ugexe: how would you then distinguish between IETF RFCs from not IETF ones.

[15:31] *** CIAvash joined
[15:32] <PerlJam> mrf: call the non-IETF ones something else  :)

[15:32] *** diana_olhovik left
[15:33] <mrf> PerlJam: true. 

[15:33] <ugexe> as long as they dont share the same names i dont think it will confuse anyone

[15:34] <PerlJam> What non-IETF RFCs are there in potential module space anyway?

[15:34] <mrf> ugexe: so as a (top of the head) example Grammar::Perl6::RFC111 

[15:35] <mrf> PerlJam: That was the question I asked and the Perl6 rfcs were the example ShimmerFairy gave

[15:35] *** mullagainn joined
[15:35] <PerlJam> ah, those should clearly live in a Perl6 space of some sort.

[15:35] <mrf> PerlJam: I suspect that its not a large use case but I like to be specifc.

[15:36] <masak> 'night, #perl6

[15:37] <PerlJam> btw, why do people put "Grammar" somewhere in the namespace of a grammar?

[15:37] <PerlJam> masak: good night.  sleep well!

[15:37] <PerlJam> I mean, is "Grammar" meant to give a hint as to how the name should be used?

[15:37] <mrf> PerlJam: example?

[15:38] <PerlJam> you just gave one  :)   Grammar::PErl6::RFC111 

[15:38] <PerlJam> Foo::Grammar.parse($string)

[15:38] <mrf> Grammar gives a namespace for modules that are just Grammars.

[15:38] <PerlJam> Why mention that it's a grammar?

[15:38] <PerlJam> mrf: sure, but ... why?

[15:39] <mrf> PerlJam: So I can find them.

[15:39] <ugexe> well, grammars will be slower than some string index type stuff

[15:39] <mrf> If I want to find a grammar for parsing XML. I would want to look for something like Grammar::XML or some such

[15:39] <ugexe> it also suggests you can pass in an action

[15:40] <PerlJam> ugexe: could you expand on that please?

[15:41] <PerlJam> you mean that other classes may have a .parse() method, but they may not take :action ?  But if you know it's a Grammar, you know that .parse will take an :aciton ?

[15:41] <ugexe> well to me something with Grammar:: suggests you are meant to work with the match object or can pass in $actions to the parse call. I would expect something like HTTP::Parser to just give me a perl6 object, not a match from a grammar

[15:42] <PerlJam> er, I guess it's :actions  (I always get that mixed up)

[15:43] *** spollei joined
[15:44] *** apotheon_ is now known as apotheon

[15:45] <ugexe> take for instance this (not in the ecosystem): Perl6-Grammar--XQuery It is useless without any :actions, but it can (used to?) kinda parse it. calling it XQuery would not be correct here

[15:45] *** apotheon left
[15:45] *** apotheon joined
[15:47] <mrf> PerlJam: A good example for me is the difference between JSON::Tiny and JSON::Tiny::Grammar. As an end user I would not expect to go anywhere near the ::Grammar module and would only use JSON::Tiny as the interface. In fact the ::Grammar module could be then extracted out for others who wanted to implement JSON parsers

[15:50] <mrf> moritz: as a point is there any worth putting JSON::Tiny::Grammar into the Grammar:: namespace. Assuming its a complete JSON grammar (which it appears to be) other JSON::* implementations could make use of it (With say different action objects)

[15:50] *** domidumont left
[15:53] <ugexe> URI bothers me like that. URI.new() doesnt seem like it should be returning a big ol' match object

[15:54] <ugexe> which just led me to this bug

[15:54] <ugexe> star: use URI; my $x = URI.new("http://www.google.com"); say $x.WHAT

[15:54] <camelia> star-m 2015.09: OUTPUT«Cannot look up attributes in a type object␤  in method scheme at /home/camelia/star-2015.09/share/perl6/lib/URI.pm:137␤  in method gist at /home/camelia/star-2015.09/share/perl6/lib/URI.pm:204␤  in block <unit> at /tmp/Cz8uGTbsuh:1␤␤»

[15:54] <jdv79> yeah, i did a rewrite of URI but never polished and pushed it

[15:54] <jdv79> it could be a lot better

[15:54] *** kjs_ left
[15:55] <moritz> mrf: fwiw I want JSON::Tiny to stay without dependencies

[15:55] <moritz> mrf: but afaict you can already use the grammar from elsewhere

[15:55] *** loren left
[15:56] *** retupmoca joined
[15:56] <mrf> moritz: yeah sure. Just my pigeonholing brain wanting a separation from the Grammars (the definition of something) from the thing that uses that Grammar (the parser)

[15:57] <moritz> mrf: but isn't it separated already?

[15:57] <mrf> I am aware that I could 'panda JSON::Tiny' and then 'use JSON::Tiny::Grammar' but that just seems weird in my brain. Its not a Grammar for JSON Tiny. Its a JSON Grammar.

[15:57] <mrf> I would have liked to install Grammar::JSON (or likewise) without installing JSON::Tiny.

[15:57] <RabidGravy> well it's the JSON grammar that JSON::Tiny uses

[15:58] <RabidGravy> other grammars are possible I guess

[15:59] <mrf> true enough. I think I am just being pedantic

[16:00] <PerlJam> I wouldn't say "pedantic"

[16:00] <PerlJam> I think you're trying to fit your brain to the world and vice versa.   

[16:00] <moritz> mrf: you're welcome to write a Grammar::JSON that does a "use JSON::Tiny::Grammar; constant Grammar::JSON = JSON::Tiny::Grammar" :-)

[16:00] <RabidGravy> I could see there being some virtue in there being a standalone JSON grammar, nothing precludes taking the best one around and forking it to a separate distribution

[16:00] <PerlJam> much the same reason I was asking why people put Grammar in the namespace

[16:00] <mrf> See that the URI module has its own Grammar for IETF when it could use Grammar::HTTP to get that

[16:01] <mrf> moritz: :D

[16:01] <mrf> moritz: I had one problem then I linked one Grammar to another now I have a recursive problem

[16:02] *** FROGGS joined
[16:02] *** yop joined
[16:02] *** yop left
[16:03] <RabidGravy> PerlJam, I could see a top-level Grammar:: for pure grammars (with no actions or other code) for people to use for their own purposes, but yup

[16:03] <moritz> I think you're idealizing the usefulness of a grammar

[16:03] <mrf> RabidGravy++ # Yes this

[16:03] <moritz> actions are rather tightly coupled to the structure of a grammar

[16:03] <PerlJam> indeed

[16:03] <moritz> so code reuse is far from trivial

[16:04] <RabidGravy> oh for sure

[16:05] <PerlJam> even with no actions, if you're going to use the grammar for anything, you need to be highly familiar with the rules used within the grammar and their relationships

[16:08] <mrf> PerlJam: true but that can be mitigated by documenting the rules/tokens ect

[16:10] <RabidGravy> mrf, I think at least part of the thing here is, if you want things in the ecosystem at this stage in the game, just do it

[16:10] <RabidGravy> :)

[16:11] *** pmurias left
[16:14] <mrf> RabidGravy: true.

[16:15] <moritz> mrf: the problem is that changes / bug fixes quickly become backwards incompataible, because the distinction between implementation and API basically doesn't exist

[16:15] *** ^elyse^ joined
[16:15] *** kmel joined
[16:16] *** tokuhirom_ joined
[16:16] <kmel> m: say 'hello'

[16:16] <camelia> rakudo-moar 56dbb0: OUTPUT«hello␤»

[16:20] <mrf> moritz: Because action object methods are tied to rules in the grammar?

[16:20] *** tokuhirom_ left
[16:22] <RabidGravy> yeah

[16:22] *** ^elyse^ left
[16:23] <RabidGravy> to be honest the only example I have found where the grammar could be used in a different way than the author intended is in Router::Boost where the basic grammar could be alternatively used in a URI template thingy

[16:25] <PerlJam> Because grammars need to be designed with sharing in mind for that to happen (usually)

[16:25] *** [Sno] joined
[16:26] <RabidGravy> yeah, and I think in that case an eventual design would bend it out of shape from the original purpose

[16:27] <PerlJam> and then readability/maintainability/understandability probably suffer

[16:27] <mrf> I can certainly see pitfalls in sharing of grammars but really want to avoid a situation were every single Email/HTTP/URI module defines the same RFC grammar. Which seems like wasted effort.

[16:27] <RabidGravy> on the other hand, and I am rambling here, there may well be things for which a standalone grammar can answer "is this this a valid $foo" when you don't want to do a full parse

[16:30] <RabidGravy> mrf, only if it's your effort or effort that would otherwise be doing something else and I think the reasons people make the modules the latter is unlikely

[16:31] <ugexe> grammar::http can be passed actions that turn the parse into a deep data structure, or handle things like closing a socket when it hits certain parts of a header. with rfc grammars the definitions and shareability are mostly solved

[16:32] *** weihan left
[16:33] *** weihan joined
[16:35] <mrf> maybe that is where my blind spot is coming from . The kind of things I am focusing on right now have very stong specifications (RFC's) and define syntaxt used by a huge swath of things I use daily which makes their Utility greater.

[16:35] <mrf> I think in the end I will just need to implement something and see where it breaks.

[16:35] <mrf> Thanks people you have all been awesomely helpful

[16:36] <mrf> -> Home time

[16:36] <RabidGravy> :)

[16:37] *** mprelude joined
[16:37] *** kjs_ joined
[16:37] *** gonz_ left
[16:37] *** weihan left
[16:38] *** diana_olhovik joined
[16:38] *** grondilu left
[16:39] *** mprelude left
[16:39] *** ^elyse^ joined
[16:40] *** grondilu joined
[16:40] *** LosFrijoles joined
[16:41] *** LosFrijoles left
[16:42] *** Juerd left
[16:43] *** spider-mario joined
[16:44] *** gonz_ joined
[16:45] *** dakkar left
[16:45] *** mprelude joined
[16:47] *** Juerd joined
[16:51] *** kjs_ left
[16:53] *** revdiablo left
[16:54] *** zakharyas joined
[16:55] *** lizmat joined
[16:57] *** Ven left
[16:58] *** mprelude left
[16:58] * lizmat waves from Cologne

[16:59] <moritz> }o Cologne

[17:01] *** sufrostico joined
[17:02] *** firstdayonthejob joined
[17:02] <[ptc]> o/

[17:03] <jdv79> one random thing on the grammar discussion - it might be hard when people are optimizing grammars

[17:03] <jdv79> what i mean is, for instance, shortcutting or not capturing in the name of perf

[17:04] <jdv79> [ptc]: hey

[17:04] <[ptc]> jdv79: hi!

[17:06] *** xpen joined
[17:07] *** revdiablo joined
[17:19] *** espadrine_ left
[17:20] *** Begi119 joined
[17:25] *** xpen left
[17:28] * [Coke] is tied to a work project where "/" is a special character. wtf.

[17:28] <dalek> doc: 9320442 | (Nova Patch)++ | doc/Type/Str.pod:

[17:28] <dalek> doc: remove Str.tcuc

[17:28] <dalek> doc: 

[17:28] <dalek> doc: which was never implemented in rakudo and was removed from the spec in perl6/spec@d1f9930

[17:28] <dalek> doc: review: https://github.com/perl6/doc/commit/9320442b15

[17:28] <[Coke]> is nova here in channel?

[17:29] <[Coke]> Nova++

[17:35] *** xfix joined
[17:39] *** Begi119 left
[17:39] *** petercommand joined
[17:41] *** Begi119 joined
[17:43] *** diana_olhovik left
[17:44] <FROGGS> lizmat: would be nice to perhaps do TDD now (I'm just reading jnthn++'s gist)

[17:44] <lizmat> FROGGS: that's why I also created a curli branch in roast

[17:44] <nine> FROGGS: where would the tests live?

[17:45] <FROGGS> nine: in roast :o)

[17:45] <nine> That's mildly helpful ;)

[17:46] <nine> S11-modules?

[17:46] <lizmat> if they are deemed not to be part of the Perl 6 definition, then we can always move them somewhere else

[17:46] <FROGGS> S11-precomp?

[17:46] *** diana_olhovik joined
[17:46] <nine> Precomp is only a part. How about S11-compunit?

[17:47] <FROGGS> I think there are enough precomp tests to create a new dir for it

[17:47] <lizmat> S11-compunit is fine by me

[17:47] <FROGGS> okay

[17:48] <FROGGS> one test would be to ask for precompilation on A.pm, but this will trigger precomp of C.pm and and B.pm

[17:48] <lizmat> indeed...

[17:48] <lizmat> and the idea is that that would happen transparently

[17:48] *** sufrostico left
[17:49] <lizmat> as in: while precompiling A.pm, the "use B" is encountered

[17:49] <nine> I'm adding CompUnit::DependencySpecification

[17:49] <FROGGS> another test would be have a lax use statement, do precomp, then add another dist that would have been preferred to a cur, then run the precomped code...

[17:49] <lizmat> at that point, precomp of A should be halted, and B should be precomped first

[17:49] <FROGGS> lizmat: aye

[17:49] <lizmat> then, when B is precomped, precomp of A should continue

[17:50] <FROGGS> same should probably happen if the cache of B is invalidated

[17:50] *** kjs_ joined
[17:50] <FROGGS> but, that is another test :o)

[17:51] <lizmat> nine: CU::DependencySpecification probably also needs an api-matcher  :-)

[17:51] <rindolf> m: 0b1000 ~& 0b1010

[17:51] <camelia> rakudo-moar 56dbb0: OUTPUT«WARNINGS:␤Useless use of "~&" in expression "0b1000 ~& 0b1010" in sink context (line 1)␤»

[17:51] <rindolf> m: say (0b1000 ~& 0b1010)

[17:51] <camelia> rakudo-moar 56dbb0: OUTPUT«0␤»

[17:52] <rindolf> This seems wrong.

[17:52] *** Peter_R joined
[17:53] <rindolf> <rindolf> perlbot: eval: [0b1010 & 0b1000]

[17:53] <rindolf> <perlbot> rindolf: [8]  

[17:53] <FROGGS> rindolf: depends how that op is meant to work :o)

[17:53] *** kjs_ left
[17:53] <FROGGS> m: say (0b1000 +& 0b1010)

[17:53] <camelia> rakudo-moar 56dbb0: OUTPUT«8␤»

[17:53] *** llfourn left
[17:53] <rindolf> FROGGS: isn't it bitwise or?

[17:53] <rindolf> Ah, so it's +& ?

[17:53] <FROGGS> rindolf: I think there is some sort of consensus that ~& should work on blobs only

[17:54] <rindolf> btw, this search returns junk - https://duckduckgo.com/?q=perl%206%20bitwise%20operations

[17:54] <FROGGS> rindolf: numeric is +&, stringy is ~&

[17:55] <rindolf> FROGGS: ah.

[17:56] <nine> Is the has $version-matcher on purpose or should it be has $.version-matcher?

[17:58] <[Coke]> rindolf: try searching on doc.perl6.org ... though you may have no better luck, we actually control that.

[17:58] <rindolf> [Coke]: ok.

[17:58] <rindolf> [Coke]: Google gave me this - http://doc.perl6.org/language/operators

[17:59] <[Coke]> that works.

[17:59] <FROGGS> ahh, I like the linked list design in jnthn's gist

[17:59] <lizmat> nine: not sure

[18:00] <FROGGS> use lib "Foo"; will then build down to: PROCESS::<$REPO> = NewCur.new( "Foo", :next(PROCESS::<$REPO>) ) # more or less

[18:01] <nine> FROGGS: yes

[18:04] <lizmat> wouldn't that be: my $*REPO = NewCur.new("Foo", :next($*REPO) ) ?

[18:04] <lizmat> nine FROGGS ^^^

[18:05] <FROGGS> lizmat: that doesnt work

[18:05] <nine> There's also $?REPO

[18:05] <FROGGS> if you declare something, you shadow the old value

[18:05] <lizmat> hmmm....

[18:06] *** Begi119 left
[18:06] *** Begi119 joined
[18:07] <dalek> roast/curli: f3eb270 | (Stefan Seifert)++ | S11-compunit/compunit-dependencyspecification.t:

[18:07] <dalek> roast/curli: Test CompUnit::DependencySpecification

[18:07] <dalek> roast/curli: review: https://github.com/perl6/roast/commit/f3eb270dcc

[18:07] <dalek> rakudo/curli: 771c4cf | (Stefan Seifert)++ | / (7 files):

[18:07] <dalek> rakudo/curli: Add CompUnit::DependencySpecification

[18:07] <dalek> rakudo/curli: review: https://github.com/rakudo/rakudo/commit/771c4cf25f

[18:10] <rindolf> How do I put a reference to a subroutine as a value in a hash?

[18:11] <moritz> %h{$key} = &yoursub;

[18:11] <gfldex> m: sub f(){ say 'i haz a f' }; my %h; %h = f => &f; %h<f>.();

[18:11] <lizmat> rindolf: why a reference>

[18:11] <camelia> rakudo-moar 56dbb0: OUTPUT«i haz a f␤»

[18:12] <lizmat> m: %h<a> = { say "foo" }; %h<a>()  # no need to make a sub

[18:12] <camelia> rakudo-moar 56dbb0: OUTPUT«5===SORRY!5=== Error while compiling /tmp/Qbi0B_asYb␤Variable '%h' is not declared␤at /tmp/Qbi0B_asYb:1␤------> 3<BOL>7⏏5%h<a> = { say "foo" }; %h<a>()  # no nee␤»

[18:12] <lizmat> m: my %h; %h<a> = { say "foo" }; %h<a>()  # do need to make a hash :-)

[18:12] <camelia> rakudo-moar 56dbb0: OUTPUT«foo␤»

[18:12] <rindolf> lizmat: well, it's kinda long.

[18:14] *** tokuhirom_ joined
[18:15] <kmel> hello everyone

[18:16] <nine> hello kmel 

[18:17] <kmel> if i want to play a bit with Perl 6 oriented towards web development. What options do i have?

[18:18] <DrForr> Bailador comes to mind.

[18:18] <kmel> i found bailador but thought i'd ask before delving in

[18:18] *** tokuhirom_ left
[18:19] <kmel> thanks DrForr

[18:19] <nine> I hear good things about Mojomojo

[18:19] <DrForr> I haven't checked into what's in modules.perl6.org lately :/

[18:20] <nine> no, not Mojomojo....curse you brain

[18:20] <nine> I meant Mojolicious

[18:20] <kmel> nine isn't mojolicious Perl 5?

[18:21] <FROGGS> it is

[18:21] <FROGGS> it will be usable with Inline::Perl5 of course but its interface won't be Perl 6-ish I fear

[18:23] <kmel> so from a Perl 6 point of view there's only bailador?

[18:23] <rindolf> http://paste.debian.net/317172/ - this code gives me an error - «Missing infix inside []» - how can I fix it and what does it mean?

[18:25] <FROGGS> kmel: you can also search for 'server' here: http://modules.perl6.org/

[18:25] <moritz> rindolf: I can't parse your code either

[18:25] <moritz>                 ((@new_rec[$old_digits_sum + $new_digit]

[18:25] <moritz>                 [($old_mod + $BASE_MOD * $new_digit) % $BASE]

[18:26] <AlexDaniel> I feel like there was an attempt to port Mojolicious

[18:26] <AlexDaniel> https://github.com/coke/mojo6

[18:26] <moritz> rindolf: what should the second pair of brackets introduce?

[18:26] <AlexDaniel> this one

[18:26] <moritz> rindolf: is it supposed to be a subscript?

[18:26] <rindolf> moritz: an array dereference.

[18:26] <rindolf> moritz: yes.

[18:26] <rindolf> moritz: a subscript.

[18:26] <moritz> rindolf: can't have whitespace between two subscripts

[18:27] <FROGGS> unspace missing?

[18:27] <rindolf> Like $x->[6]->[100] in Perl 5 or arr[5][100] in Python.

[18:27] <rindolf> moritz: ah.

[18:27] <FROGGS> m: my @a; @a[0]␤[0] = 42

[18:27] <camelia> rakudo-moar 56dbb0: OUTPUT«5===SORRY!5=== Error while compiling /tmp/d7IKaf95Tk␤Missing infix inside []␤at /tmp/d7IKaf95Tk:2␤------> 3[7⏏050] = 42␤    expecting any of:␤        bracketed infix␤        infix␤        infix stopper␤»

[18:27] <FROGGS> m: my @a; @a[0]\␤[0] = 42

[18:27] <camelia> rakudo-moar 56dbb0: ( no output )

[18:27] <moritz> rindolf: return (0 .. $DIGITS_SUM).map, { [(0) x $BASE] };

[18:27] <FROGGS> there you go

[18:27] <moritz> rindolf: that looks like a 5ism

[18:27] <AlexDaniel> .oO( What about using CGI.pm with Inline::Perl5? Ha-ha-ha )

[18:27] <moritz> rindolf: in Perl 6, xx is the list repetition operator

[18:28] <FROGGS> rindolf: add a backslash before the newline

[18:28] <moritz> and that map call is also weird

[18:28] <moritz> maybe you want [0 xx $BASE] xx ($DIGITS_SUM + 1) or so?

[18:29] <itz_stmuk> the cool kids don't use CGI.pm anymore :)

[18:29] <kmel> AlexDaniel I am trying to go for a pure 6 module

[18:31] <AlexDaniel> kmel: I think that even if you find one, it seems like you will have to become an active contributor to get your stuff going. Which is good, in some sense…

[18:31] *** Sqirrel joined
[18:31] <AlexDaniel> kmel: However, Bailador seems to be pretty active

[18:32] <AlexDaniel> not sure how usable it is, but try it?

[18:32] <DrForr> There's Perl::ToPerl6 in the Perl5 space that might help :)

[18:32] *** [Sno] left
[18:32] *** [Sno] joined
[18:33] <kmel> AlexDaniel I am not looking for something sophisticated, just something i can test the waters with

[18:33] <kmel> i think i'll try bailador

[18:33] <ugexe> grammar::http can be passed actions that turn the parse into a deep data structure, or handle things like closing a socket when it hits certain parts of a header. with rfc grammars the definitions and shareability are mostly solved

[18:33] <ugexe> oops

[18:36] *** n0tjack joined
[18:37] *** takadonet left
[18:42] *** kjs_ joined
[18:44] <[Coke]> mojo jojo! ... I need to get back to that

[18:44] <RabidGravy> ugexe, so good you had to send it twice ;-)

[18:46] <rindolf> «Method 'eval' not found for invocant of class 'Str'» - how do I do string eval in rakudo-moar?

[18:46] *** firstdayonthejob left
[18:47] <pink_mist> EVAL "string here"

[18:48] *** firstdayonthejob joined
[18:48] <rindolf> pink_mist: in all caps?

[18:48] <pink_mist> as far as I understand it, yes

[18:48] *** CIAvash left
[18:49] <rindolf> pink_mist: thanks!

[18:49] <rindolf> pink_mist: what's up, BTW?

[18:49] <lizmat> yes, all caps, because you probably SHOULD NOT DO THAT  -)

[18:49] <pink_mist> rindolf: np ... and I'm busy busy busy =) in fact gotta go right now :P

[18:50] <AlexDaniel> lizmat: are you saying that I should not any phasers at all?

[18:50] <AlexDaniel> should not use*

[18:50] <lizmat> AlexDaniel:  hehe  :-)

[18:50] <rindolf> pink_mist: bye.

[18:50] <lizmat> okokok...

[18:50] <lizmat> basically, all caps means it draws attention for something special happening

[18:50] *** kmel left
[18:51] <AlexDaniel> ok :)

[18:51] <rindolf> OK, my Euler program seems much slower in p6 than it is in p5.

[18:51] *** spollei left
[18:51] <AlexDaniel> but I always felt that all caps were used just to distinguish it from other stuff

[18:51] *** kjs_ left
[18:52] *** zakharyas left
[18:52] <lizmat> AlexDaniel: yeah, you're right

[18:52] <lizmat> originally, eval was just eval and not EVAL  :-)

[18:54] <n0tjack> back then, it was primeval

[18:55] <lizmat> .oO( the best of times )

[18:55] * AlexDaniel votes for universal prefix for potentially unsafe operations – ☠. That is, ☠EVAL, ☠qqx//, etc…

[18:56] <lizmat> use Slang::Unsafe  :-)

[18:58] <AlexDaniel> well, I doubt anybody will add a dependency just to protect him from himself.

[18:59] <lizmat> could be a Company Best Practice :-)

[18:59] <[Coke]> rindolf: feel free to post source - we might be able to suggest improvements.

[18:59] <[Coke]> (gist it)

[19:02] *** kjs_ joined
[19:03] <rindolf> [Coke]: oh, I see - I used & instead of +&

[19:05] *** khw left
[19:07] *** vendethiel joined
[19:08] *** Hor|zon joined
[19:08] <dalek> ecosystem: 9de12e6 | (Shoichi Kaji)++ | META.list:

[19:08] <dalek> ecosystem: Add Data::Section::Simple to ecosystem

[19:08] <dalek> ecosystem: 

[19:08] <dalek> ecosystem: See https://github.com/shoichikaji/Data-Section-Simple

[19:08] <dalek> ecosystem: review: https://github.com/perl6/ecosystem/commit/9de12e6518

[19:08] <dalek> ecosystem: decc31c | (Zoffix Znet)++ | META.list:

[19:08] <dalek> ecosystem: Merge pull request #82 from shoichikaji/Data-Section-Simple

[19:08] <dalek> ecosystem: 

[19:08] <dalek> ecosystem: Add Data::Section::Simple to ecosystem: https://github.com/shoichikaji/Data-Section-Simple

[19:08] <dalek> ecosystem: review: https://github.com/perl6/ecosystem/commit/decc31cd90

[19:09] <dalek> roast/curli: 4e223c5 | (Stefan Seifert)++ | S11-compunit/compunit-repository.t:

[19:09] <dalek> roast/curli: First tests for CompUnit::Repository

[19:09] <dalek> roast/curli: review: https://github.com/perl6/roast/commit/4e223c58d0

[19:09] <dalek> rakudo/curli: 53da925 | (Stefan Seifert)++ | / (4 files):

[19:09] <dalek> rakudo/curli: Add CompUnit::Repository role

[19:09] <dalek> rakudo/curli: review: https://github.com/rakudo/rakudo/commit/53da925146

[19:09] <vendethiel> amazingly enough, nine++ took a liking to core hacking :P

[19:14] *** tokuhirom_ joined
[19:16] <rindolf> [Coke]: here is the source - https://bitbucket.org/shlomif/project-euler/src/c6b71e189fc43fc515aedac060028b5c0ec987b6/project-euler/294/euler-294-v1.p6?at=default&fileviewer=file-view-default

[19:16] *** diana_olhovik left
[19:19] *** tokuhirom_ left
[19:20] *** ZoffixW joined
[19:21] <n0tjack> I need something to code up in p6

[19:21] <ZoffixW> Hey. Is it valid to have "authors" field in META.info instead of singular "author"? I'm just looking at this: https://raw.githubusercontent.com/shoichikaji/Data-Section-Simple/master/META6.json

[19:21] <n0tjack> hmm, maybe project euler

[19:21] <ZoffixW> n0tjack, go nuts: https://github.com/perl6/perl6-most-wanted/blob/master/most-wanted/modules.md

[19:21] <ZoffixW> :D

[19:21] <n0tjack> .... I'm not sure you want me to write code other ppl are expected to use :)

[19:22] <Ulti> n0tjack: https://www.reddit.com/r/perl6/comments/3pdqsj/come_join_me_in_rdailyprogrammer_and_show_off/

[19:23] <ZoffixW> n0tjack, I'd not worry too much about that. Just write good tests and you should be fine :)

[19:23] <Ulti> yeah its more motivational if people do use your code... which reminds me I was meant to finish the histogram stuff in Stats

[19:24] *** mspo joined
[19:24] <Ulti> maybe if I wait long enough there will be a PR waiting instead....

[19:24] <RabidGravy> n0tjack, plus if people really want it and they want it better they can pitch in and fix it ;-)

[19:27] <flussence> m: my @a; @a[0]␤.[0] = 42; say @a

[19:27] <camelia> rakudo-moar 56dbb0: OUTPUT«5===SORRY!5=== Error while compiling /tmp/X51OdAaiwf␤Unsupported use of . to concatenate strings; in Perl 6 please use ~␤at /tmp/X51OdAaiwf:2␤------> 3.[7⏏050] = 42; say @a␤»

[19:27] <flussence> std: my @a; @a[0]␤.[0] = 42; say @a

[19:27] <camelia> std 28329a7: OUTPUT«5===SORRY!5===␤Method call found where infix expected (change whitespace?) at /tmp/K8ucLWJlGv line 2:␤------> 3<BOL>7⏏5.[0] = 42; say @a␤    expecting any of:␤     POST␤   infix or meta-infix␤    infixed function␤       postcircumfix␤  postfix␤        postfi…»

[19:32] <FROGGS> m: my @a; @a[0] . [0] = 42; say @a

[19:32] <camelia> rakudo-moar 56dbb0: OUTPUT«5===SORRY!5=== Error while compiling /tmp/lC7p29Bb01␤Unsupported use of . to concatenate strings; in Perl 6 please use ~␤at /tmp/lC7p29Bb01:1␤------> 3my @a; @a[0] . [7⏏050] = 42; say @a␤»

[19:32] <FROGGS> hmmm, sad

[19:32] <FROGGS> but only a little

[19:33] *** Begi119 left
[19:35] *** diana_olhovik_ joined
[19:36] <n0tjack> is roast the general testing framework for p6?

[19:37] <n0tjack> as in, how do I write my own tests?

[19:37] <moritz> it's not a framework

[19:37] <nine> n0tjack: use Test;

[19:37] <moritz> it's a test suite

[19:37] <moritz> n0tjack: http://doc.perl6.org/language/testing.html

[19:37] <n0tjack> thanks nine, moritz 

[19:38] *** zakharyas joined
[19:38] <FROGGS> m: say $*KERNEL ~~ 'linux'

[19:38] <camelia> rakudo-moar 56dbb0: OUTPUT«True␤»

[19:39] <FROGGS> wow, that documentation is very good

[19:41] <lizmat> FROGGS: re [] . []  I tried exactly the same thing   :-)  

[19:42] <vendethiel> "is($womble->location" probably should be "."

[19:42] <vendethiel> the link at the bottom is down

[19:42] <FROGGS> :o)

[19:43] <dalek> doc: 229c4f9 | ven++ | doc/Language/testing.pod:

[19:43] <dalek> doc: Fix P5ism '->' in language/testing

[19:43] <dalek> doc: review: https://github.com/perl6/doc/commit/229c4f9a7c

[19:43] *** rindolf left
[19:49] <n0tjack> sorry for the silly question, is  use  some-other-file-in-this-dir.pl6  the way to import a script into a test?

[19:51] *** ZoffixW left
[19:51] <lizmat> there's also EVALFILE ?

[19:51] *** diana_olhovik_ left
[19:53] <n0tjack> :4

[19:53] <n0tjack> ugh, too many terminals

[19:55] <dalek> rakudo/nom: 5d83db3 | FROGGS++ | src/core/Regex.pm:

[19:55] <dalek> rakudo/nom: handle junction on LHS of regex correctly

[19:55] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/5d83db3d01

[19:56] <dalek> roast: 51d1a48 | FROGGS++ | S03-junctions/misc.t:

[19:56] <dalek> roast: unfudge/add junction ~~ regex tests

[19:56] <dalek> roast: review: https://github.com/perl6/roast/commit/51d1a4835f

[19:56] *** llfourn joined
[19:58] *** jevin left
[20:00] *** sufrostico joined
[20:00] *** kjs_ left
[20:02] <FROGGS> gnight

[20:02] *** FROGGS left
[20:02] *** llfourn left
[20:07] *** jevin joined
[20:10] *** darutoko left
[20:12] <[Coke]> .ask rindolf - the description says S(1112), but you're looking at 11**12?

[20:12] <yoleaux> [Coke]: I'll pass your message to rindolf.

[20:13] <[Coke]> that code looks some gnarly perl4 code.

[20:20] <RabidGravy> gnarly dude

[20:21] <[Coke]> Does anyone else follow his code? I am having a hard time seeing how it's doing what's asked in the description.

[20:22] *** tokuhiro_ joined
[20:24] <[Coke]> m: say int.max;

[20:24] <camelia> rakudo-moar 5d83db: OUTPUT«-Inf␤»

[20:25] *** ponzellus left
[20:26] <TimToady> m: say int.range

[20:26] <camelia> rakudo-moar 5d83db: OUTPUT«Method 'range' not found for invocant of class 'int'␤  in block <unit> at /tmp/briVW7t5yx:1␤␤»

[20:26] <TimToady> m: say int.Range

[20:26] <camelia> rakudo-moar 5d83db: OUTPUT«-9223372036854775808..9223372036854775807␤»

[20:27] *** tokuhiro_ left
[20:27] *** ^elyse^ left
[20:27] *** leont joined
[20:27] *** aindilis joined
[20:27] *** zakharyas left
[20:28] <[Coke]> m: say [+] 12345.split

[20:28] <camelia> rakudo-moar 5d83db: OUTPUT«Cannot call split(Int: ); none of these signatures match:␤    (Cool $: Regex $pat, $limit = { ... };; :$all, *%_)␤    (Cool $: Cool $pat, $limit = { ... };; :$all, *%_)␤  in block <unit> at /tmp/Estzn2AtWw:1␤␤»

[20:28] <[Coke]> m: say [+] 12345.split('')

[20:28] <camelia> rakudo-moar 5d83db: OUTPUT«15␤»

[20:29] <PerlJam> m: say [+] 12345.comb;

[20:29] <camelia> rakudo-moar 5d83db: OUTPUT«15␤»

[20:29] <n0tjack> now do it in base 8 :)

[20:29] <moritz> base 8 is just like base 10, really, if you're missing two fingers

[20:30] <moritz> (a Tom Lehrer quote, iirc)

[20:30] <PerlJam> moritz: nah, you just count the spaces between the fingers instead.

[20:30] <n0tjack> all bases are base 10

[20:30] <n0tjack> that came as a huge relevation to me when i was a kid

[20:31] <n0tjack> m: say ox30071; say :8[3,0,0,7,1];

[20:31] <camelia> rakudo-moar 5d83db: OUTPUT«5===SORRY!5=== Error while compiling /tmp/lu_QdwQ5ja␤Undeclared routine:␤    ox30071 used at line 1␤␤»

[20:31] <n0tjack> I forget the notation for octal

[20:31] <TimToady> 0o

[20:32] <n0tjack> m: say 0o30071; say :8[3,0,0,7,1];

[20:32] <camelia> rakudo-moar 5d83db: OUTPUT«12345␤12345␤»

[20:33] <n0tjack> I wrote an "antibase" function that will take (12345,8) and produce (3,0,0,7,1), but is there a native way in p6?

[20:33] * PerlJam is having deja vu right now

[20:33] <gfldex> m: say 12345.base(8)

[20:33] *** zakharyas joined
[20:33] <camelia> rakudo-moar 5d83db: OUTPUT«30071␤»

[20:33] <n0tjack> gfldex++

[20:33] <gfldex> http://doc.perl6.org/routine/base#role_Real ++

[20:34] <n0tjack> m: say 12345.base(8).comb;

[20:34] <camelia> rakudo-moar 5d83db: OUTPUT«(3 0 0 7 1)␤»

[20:34] <n0tjack> heh!

[20:34] <[Coke]> .tell rindolf - oh, because your copy of the problem statement is missing formatting.

[20:34] <yoleaux> [Coke]: I'll pass your message to rindolf.

[20:34] <n0tjack> m: say :8[3,0,0,7,1].base(8).comb;

[20:34] <camelia> rakudo-moar 5d83db: OUTPUT«(3 0 0 7 1)␤»

[20:35] <n0tjack> I'm never 100% sure when I need to parenthesize the LHA to . but it doesn't seem mandatory very often

[20:36] <TimToady> well, terms are the only thing tighter than methods and method-like postfixes

[20:37] <n0tjack> terms as in pi, i, e, * ?

[20:37] <TimToady> or :8[3,0,0,7,1]

[20:37] *** virtualsue left
[20:37] <n0tjack> yeah I'm not sure whether :8[3, 0, 0,7, 1] is atomic or composite syntax

[20:38] <n0tjack> to me it lookes like a weird Pair followed by an Array

[20:38] <PerlJam> it's covalent

[20:38] <n0tjack> Can you elaborate on that? In J terms, covalent means "can take one argument, or two arguments"

[20:38] <TimToady> even if it were a pair, pair terms include their brackets

[20:38] <TimToady> I think it was a chemistry joke

[20:39] <n0tjack> ah, got it

[20:39] <PerlJam> it was (sorta)

[20:39] <skids> m: say 12345.polymod(8 xx *).reverse

[20:39] <camelia> rakudo-moar 5d83db: OUTPUT«(3 0 0 7 1)␤»

[20:40] <n0tjack> m: say :8[1;2;3]; # multidim indexing

[20:40] <camelia> rakudo-moar 5d83db: OUTPUT«83␤»

[20:40] <n0tjack> whoa!

[20:40] <n0tjack> someone needs to explain that one to me

[20:40] <TimToady> m: say [1;2;3]

[20:40] <camelia> rakudo-moar 5d83db: OUTPUT«[1 2 3]␤»

[20:40] <TimToady> it's just taking them as commas there, I suspect

[20:40] <TimToady> it's not a subscript

[20:40] <n0tjack> m: say :8[1;*;3]; #...

[20:40] <camelia> rakudo-moar 5d83db: OUTPUT«Inf␤»

[20:41] <TimToady> remember :foo[1,2,3] is really short for foo => [1,2,3]

[20:41] <TimToady> so it's a circumfix in it's parsing

[20:41] <n0tjack> and how does :8 with postcirumfix [1,2,3] produce 83?

[20:42] <TimToady> m: say (*).Num

[20:42] <camelia> rakudo-moar 5d83db: OUTPUT«WhateverCode.new␤»

[20:42] <TimToady> m: say Numeric(*)

[20:42] <camelia> rakudo-moar 5d83db: OUTPUT«Cannot invoke this object␤  in block <unit> at /tmp/rcY42ElJbv:1␤␤»

[20:42] <TimToady> m: say Num(*)

[20:42] <camelia> rakudo-moar 5d83db: OUTPUT«Cannot find method 'Num'␤  in block <unit> at /tmp/brpvyH0LHf:1␤␤»

[20:43] <TimToady> hmm

[20:43] *** araujo_ joined
[20:43] <TimToady> some in there * is numifying to Inf

[20:43] <TimToady> *somewhere

[20:43] <TimToady> haven't decided yet whether I like that...

[20:43] <n0tjack> what is being expressed by :number[some array of ints] ?

[20:44] <n0tjack> as opposed to the normal base syntax

[20:44] <skids> m: say 3 * 1 + 2 * 8 + 1 * 64

[20:44] <camelia> rakudo-moar 5d83db: OUTPUT«83␤»

[20:44] <PerlJam> normal?

[20:44] <TimToady> it's just an escape valve for bases larger than 36

[20:44] <n0tjack> skids: I see, it's the same as the normal syntax

[20:44] <TimToady> m: say :60[24,59,59]

[20:44] <camelia> rakudo-moar 5d83db: OUTPUT«89999␤»

[20:44] <TimToady> m: say :60[23,59,59]

[20:44] <camelia> rakudo-moar 5d83db: OUTPUT«86399␤»

[20:44] <n0tjack> TimToady: No, I got that, I was confused by the , means ; thing

[20:44] <n0tjack> uh, ; means , thing

[20:45] <n0tjack> we have a builtin for that kinda calculation too (spelled #. and its inverse #:)

[20:45] <TimToady> we used to turn those into LoLs, but I'm not sure why ; is turning into , these days

[20:45] <n0tjack> S99: LoL

[20:46] <TimToady> we should probably reserve ; in those situations for more monadish notations

[20:46] <TimToady> m: say (1,2;3).perl

[20:46] <camelia> rakudo-moar 5d83db: OUTPUT«((1, 2), 3)␤»

[20:46] *** araujo left
[20:46] <n0tjack> that notation makes sense to me

[20:46] <TimToady> m: say [1,2; 3].perl

[20:46] <camelia> rakudo-moar 5d83db: OUTPUT«[(1, 2), 3]␤»

[20:47] <n0tjack> esp. as it pertains to multidim indexing

[20:47] <TimToady> m: say [1;2;3].perl

[20:47] <camelia> rakudo-moar 5d83db: OUTPUT«[1, 2, 3]␤»

[20:47] <TimToady> it's proably just doing single-arg rule on each dimension there

[20:47] <n0tjack> m: say [(1);(2);(3)].perl;

[20:47] <camelia> rakudo-moar 5d83db: OUTPUT«[1, 2, 3]␤»

[20:47] <TimToady> m: say [1,;2,;3,].perl

[20:47] <camelia> rakudo-moar 5d83db: OUTPUT«[(1,), (2,), (3,)]␤»

[20:47] <TimToady> but again, that's an array, not a subscript

[20:48] <skids> m: say :8[1;1,1;1,1,1]

[20:48] <camelia> rakudo-moar 5d83db: OUTPUT«83␤»

[20:48] <n0tjack> yeah but notionally the selection of indices along each dimension is itself an array

[20:48] <n0tjack> so having the notation for LoLs and multidim subscripts be similar is sensible

[20:49] <TimToady> they don't really map 1:1 though since slicing adds a dimension in subscripting

[20:49] <n0tjack> [1..2;3..4] can be thought of as a LoL or a 2D array slice

[20:50] <n0tjack> rows 1 and 2, cols 3 and 4

[20:50] <PerlJam> n0tjack: Do you use J in your day to day life?

[20:50] <n0tjack> yes

[20:50] <n0tjack> every day

[20:50] *** BenGoldberg joined
[20:50] <PerlJam> for what exactly?

[20:50] <dalek> rakudo/curli: f293126 | (Stefan Seifert)++ | src/core/CompUnit (4 files):

[20:50] <dalek> rakudo/curli: Add $.repo attribute to CompUnit

[20:50] <dalek> rakudo/curli: 

[20:50] <dalek> rakudo/curli: Start morphing CURLI and CURLF into CompUnit::Repositorys.

[20:50] <dalek> rakudo/curli: review: https://github.com/rakudo/rakudo/commit/f293126556

[20:50] <n0tjack> everything you use perl for, I imagine

[20:50] <n0tjack> mostly one-off scripts to accomplish a particular task

[20:51] <PerlJam> more math oriented or no?

[20:51] <n0tjack> As a concrete example: I'm in sales, and I sell a lot of heavy/complex software to Wall St firms.  We often to proofs-of-concept, where the customer sends us some data, adn we get it into the product to show them how they could use it

[20:52] <n0tjack> today, I took a bunch of order and trade files from a customer, parse them, interpolated some series, and converted them into the neccesary format

[20:53] <n0tjack> wow my spelling is horrible

[20:53] <vendethiel> .oO( write a Inline::R, or Inline::J, or Inline::APL module :P )

[20:53] <PerlJam> yes, that sounds exactly what i would use Perl for.  All your mentions of J though remind me of PDL or R 

[20:54] <n0tjack> vendethiel: I am indeed! Though I'm patiently waiting for shaped arrays before I progress with it.

[20:54] <vendethiel> that makes sense :-)

[20:55] <n0tjack> PerlJam: It is more R-like. R's syntax is an abomination, but it's much more popular and you can find an off-the-shelf script for anything

[20:55] *** spider-mario left
[20:55] <vendethiel> n0tjack: isn't J code terser than R code?

[20:56] <TimToady> Both of them are pretty terse; I can see where doing some of those things in a language like Perl 6 would make the non-J/R people you show the programs to think they know what's going on a little more than J or R would :)

[20:56] <TimToady> because we've tried very hard to make different things look different

[20:57] <n0tjack> vendethiel: Ɐlang is-terser(J, lang)

[20:57] *** Begi119 joined
[20:57] <TimToady> yes, J usually wins the Shortest Entry Award on rosettacode :)

[20:57] <vendethiel> *g*

[20:57] <vendethiel> the best award of them all ;-)

[20:57] <TimToady> and Perl 6 is often 2nd

[20:58] <n0tjack> TimToady: Yeah, J is pretty impenetrable from an outsider's perspective. Not too dissimilar to regexen.  But that doesn't bother me.  Chinese looks impenetrable to me too, but over a billion people seem to get some use out of it :)

[20:58] <n0tjack> TimToady: Welll... the RC thing is probably my own personal fault :)

[20:58] *** bjz joined
[20:58] *** xfix left
[20:58] <vendethiel> n0tjack++ # Rosetta Code Driver Development everywhere

[20:59] <vendethiel> n0tjack: were one to pick up J; where would one start?

[20:59] <vendethiel> s:2nd/one/they/

[20:59] *** bjz_ left
[20:59] <n0tjack> vendethiel: our answer to #perl6 is the J Forum mailing lists.

[21:00] <n0tjack> vendethiel: if you know C or C-like languages, Henry Rich's J for C Programmers is a great bootstrap

[21:00] <n0tjack> http://www.jsoftware.com/help/jforc/contents.htm

[21:00] <PerlJam> n0tjack++

[21:00] <vendethiel> n0tjack: thanks :-). will read that

[21:00] <PerlJam> me too

[21:01] *** confused_as_usal joined
[21:01] <PerlJam> n0tjack: you may have just instigated some new J programmers :)

[21:01] *** skids left
[21:01] *** ^elyse^ joined
[21:01] <confused_as_usal> multi method pairs(Set:D:) 

[21:02] <confused_as_usal> Could somebody explain what's the colon after Set:D: does 

[21:02] <vendethiel> confused_as_usal: defines the invocant (self, or this in other languages)

[21:03] <vendethiel> which means self is a defined Set (as given by Set.new, or set())

[21:03] <n0tjack> PerlJam: I wonder if that gets me any extra years in Purgatory :)

[21:03] <confused_as_usal> I get the defined part which is Set:D

[21:04] *** Begi119 left
[21:04] <confused_as_usal> but why there is another ":" after that tacked on

[21:04] <vendethiel> confused_as_usal: because it's not a parameter -- it's a constraint on self

[21:04] <PerlJam> confused_as_usal: to say that the first arg is the invocant

[21:04] *** kaare_ left
[21:04] <vendethiel> m: $a.foo(); <- $a is what's before said colon

[21:04] <camelia> rakudo-moar 5d83db: OUTPUT«5===SORRY!5=== Error while compiling /tmp/bQyUi47YeU␤Variable '$a' is not declared␤at /tmp/bQyUi47YeU:1␤------> 3<BOL>7⏏5$a.foo(); <- $a is what's before said co␤»

[21:07] <confused_as_usal> so, every method must start with this invocant?

[21:07] <PerlJam> no

[21:08] <confused_as_usal> if not, would it then become a class method?

[21:08] <PerlJam> nope

[21:09] <confused_as_usal> appreciate if you point me to any doc I can read.. thx

[21:09] <PerlJam> confused_as_usal: methods /may/ list constraints on the invocant as the first parameter

[21:09] <gfldex> m: class C { method foo($c where $c ~~ C:){ say 'I\'m fooing!' } }; C.new.foo;

[21:09] <camelia> rakudo-moar 5d83db: OUTPUT«I'm fooing!␤»

[21:09] <confused_as_usal> so, if unconstrained, there is no need to mention it?

[21:10] <PerlJam> confused_as_usal: if you omit the invocant constraint, you still get an invocant, but it's called "self" instead of $whatever-you-define

[21:10] <PerlJam> confused_as_usal: usually you list the invocant if you want to rename it or constrain it

[21:10] <PerlJam> s/rename/give it an explicit name/ 

[21:11] *** regreg left
[21:11] <confused_as_usal> cool, that makes sense now.. thanks

[21:11] <PerlJam> confused_as_usal: but you can also end up with some weird stuff like   class A { };  class B { method m(A:D $self) { } }

[21:12] <n0tjack> m: #`(this is cool comment syntax I'd never noticed before)

[21:12] <camelia> rakudo-moar 5d83db: ( no output )

[21:12] <PerlJam> er, with the other colon after $self

[21:15] *** espadrine_ joined
[21:21] <tony-o> grammar tracer borken :-(

[21:23] *** Ben_Goldberg joined
[21:24] *** BenGoldberg left
[21:30] *** zakharyas left
[21:31] <Ulti> pull-one gen/moar/m-CORE.setting:2926 is mega slow for the following code my @a = (^1000000).map({("hello")});

[21:31] <tony-o> .tell jnthn i've submitted a PR for Grammar::Debugger to fix Grammar::Tracer for most recent rakudo build

[21:31] <yoleaux> tony-o: I'll pass your message to jnthn.

[21:31] <Ulti> takes up 60% of the runtime which on my laptop is 6s

[21:32] <Ulti> http://mattoates.co.uk/files/perl6/mapmillionhello.html#/routines

[21:32] *** _28_ria joined
[21:34] <lizmat> decommute&

[21:34] *** lizmat left
[21:35] *** mst left
[21:35] *** mst joined
[21:36] *** integral left
[21:38] *** n0tjack left
[21:46] *** ^elyse^ left
[21:46] *** bjz left
[21:50] *** llfourn joined
[21:56] *** llfourn left
[22:02] *** TEttinger joined
[22:07] *** vendethiel left
[22:07] *** confused_as_usal left
[22:08] *** tokuhirom_ joined
[22:16] *** eliasr joined
[22:20] *** Sgeo__ joined
[22:22] *** Sgeo_ left
[22:23] *** tokuhiro_ joined
[22:24] *** telex left
[22:26] *** telex joined
[22:28] *** tokuhiro_ left
[22:28] *** firstdayonthejob left
[22:44] *** [Sno] left
[22:49] <flussence> m: my $c = “{say ‘hi’}”; /<$c>/ # arbitrary string execution with no EVAL in sight, something to pay attention to

[22:49] <camelia> rakudo-moar 5d83db: OUTPUT«hi␤Method 'match' not found for invocant of class 'Any'␤  in block <unit> at /tmp/na66lpgcv7:1␤␤»

[22:51] *** Zoffix left
[22:53] *** abaugher joined
[22:54] <RabidGravy> m: $_ = 'foo'; my $c = “{say ‘hi’}”; /<$c>/

[22:54] <camelia> rakudo-moar 5d83db: OUTPUT«hi␤»

[22:56] <flussence> (1 char shorter than .EVAL too!)

[22:57] *** raiph left
[22:58] <RabidGravy> m: $_ = 'foo'; my $b = “{say ‘hi’}”; my $c = $b; /<$c>/

[22:58] <camelia> rakudo-moar 5d83db: OUTPUT«hi␤»

[22:58] <RabidGravy> m: $_ = 'foo'; my $b = “{say ‘hi’}”; my $c = $b; 

[22:58] <camelia> rakudo-moar 5d83db: OUTPUT«hi␤»

[22:58] <RabidGravy> m: $_ = 'foo'; my $b = “{say ‘hi’}”;

[22:58] <camelia> rakudo-moar 5d83db: OUTPUT«hi␤»

[22:58] <flussence> hm, maybe I should've used single outer quotes...

[22:59] <RabidGravy> m:  my $b = “{say ‘hi’}”;

[22:59] <camelia> rakudo-moar 5d83db: OUTPUT«hi␤»

[22:59] <flussence> m: my $b = '{say “hi”}'; 'foo' ~~ /<$b>/

[22:59] <camelia> rakudo-moar 5d83db: OUTPUT«hi␤»

[22:59] <RabidGravy> ah

[23:00] *** nick25 joined
[23:01] <flussence> maybe rx// needs to borrow some of the q:qcv{} modifiers... or...

[23:01] <flussence> m: my $b = '{say “hi”}'; 'foo' ~~ rx'<$b>'

[23:01] <camelia> rakudo-moar 5d83db: OUTPUT«hi␤»

[23:02] <flussence> looks like there's no way to do safe-ish interpolation there.

[23:02] *** boggard left
[23:02] *** boggard joined
[23:03] <nick25> Hi! Why are parentheses kept mandatory around the signature (parameter list) of functions definitions? Couldn't this requirement be relaxed to be in line with other places of the language where parentheses are optional, e.g. w.r.t. if-statements, "pointy blocks", function calls? At first glance, this looks syntactically plausible to me as well: (*) sub add $x, $y { $x + $y; }. Are there technical/syntactical reasons behind this

[23:03] <nick25> requirement?

[23:04] <RabidGravy> flussence, I'd go bug on that, I can see why one might want to if I squint at it, but it should require some flag

[23:05] <grondilu> what could I put in $bar so that f is called with no argument?   f($test ?? $foo !! $bar)

[23:05] <RabidGravy> Empty?

[23:06] <RabidGravy> Nil?

[23:06] <grondilu> m: sub f($a?) { say $a.perl }; f(Empty)

[23:06] <camelia> rakudo-moar 5d83db: OUTPUT«$()␤»

[23:06] <RabidGravy> one of those things

[23:06] <grondilu> m: sub f($a?) { say $a.perl }; f(Nil)

[23:06] <camelia> rakudo-moar 5d83db: OUTPUT«Nil␤»

[23:06] <grondilu> m: class Foo {}; say Foo.new: Empty

[23:06] <camelia> rakudo-moar 5d83db: OUTPUT«Default constructor for 'Foo' only takes named arguments␤  in block <unit> at /tmp/QasFhCv99F:1␤␤»

[23:07] <flussence> m: multi sub f() { say False }; multi sub f($a) { say True }; f(Empty); f(Nil);

[23:07] <camelia> rakudo-moar 5d83db: OUTPUT«True␤True␤»

[23:07] <flussence> m: multi sub f() { say False }; multi sub f($a) { say True }; my $bar = (); f($bar);

[23:07] <camelia> rakudo-moar 5d83db: OUTPUT«True␤»

[23:07] <RabidGravy> so nothing

[23:08] <flussence> m: multi sub f() { say False }; multi sub f($a) { say True }; my $bar = slip(); f($bar);

[23:08] <camelia> rakudo-moar 5d83db: OUTPUT«True␤»

[23:08] *** raiph joined
[23:08] <flussence> kinda hard... you could check for definedness in the signature instead

[23:09] <grondilu> the thing is I wanted to factorize Foo.new in an expression like $some-arg ?? Foo.new($some-arg) !! Foo.new()

[23:10] *** espadrine_ left
[23:10] *** khw joined
[23:10] <grondilu> and write Foo.new: $some-arg ?? $some-arg !! $something-corresponding-to-no-arg

[23:10] <flussence> m: multi sub f() { say False }; multi sub f($a) { say True }; my $bar = Empty; f($_ ?? 'arg' !! |$bar) for True, False;

[23:10] <camelia> rakudo-moar 5d83db: OUTPUT«True␤True␤»

[23:11] <flussence> m: multi sub f() { say False }; multi sub f($a) { say True }; my $bar = Empty; f |($_ ?? 'arg' !! $bar) for True, False;

[23:11] <camelia> rakudo-moar 5d83db: OUTPUT«True␤False␤»

[23:11] *** nick25 left
[23:11] <flussence> there you go, just cheat a little :)

[23:12] <grondilu> m: multi sub f() { say False }; multi sub f($a) { say True }; f |($_ ?? 'arg' !! Empty) for True, False;

[23:12] <camelia> rakudo-moar 5d83db: OUTPUT«True␤False␤»

[23:12] <grondilu> flussence++

[23:12] <grondilu> m: class A {}; A.new: |Empty

[23:12] <camelia> rakudo-moar 5d83db: ( no output )

[23:12] <grondilu> nice

[23:13] <flussence> «f |($_ with $some-arg)» may work too

[23:14] <grondilu> I no nothing about this 'with' keyword.  Need to get up-to-date I guess.

[23:14] <flussence> s/with/for/

[23:14] <flussence> "with" is like "if" but tests .defined instead of .so

[23:14] <grondilu> ok

[23:15] <flussence> it gets a bit hard to remember all the if/given/for/with details sometimes :)

[23:15] <flussence> but yeah, I'm pretty sure one of those should work there.

[23:15] <flussence> m: say $_ if 5

[23:15] <camelia> rakudo-moar 5d83db: OUTPUT«(Any)␤»

[23:16] <flussence> kinda odd that the others topicalize but that one doesn't.

[23:16] <grondilu> it's in S04 I suppose?

[23:19] *** raiph left
[23:19] * grondilu fount it in S04 indeed

[23:21] <dalek> ecosystem: 91c6fc1 | (Andy Weidenbaum)++ | META.list:

[23:21] <dalek> ecosystem: add Digest::xxHash

[23:21] <dalek> ecosystem: review: https://github.com/perl6/ecosystem/commit/91c6fc1553

[23:21] <dalek> ecosystem: 9aeae98 | RabidGravy++ | META.list:

[23:21] <dalek> ecosystem: Merge pull request #83 from atweiden/digest-xxhash

[23:21] <dalek> ecosystem: 

[23:21] <dalek> ecosystem: add Digest::xxHash

[23:21] <dalek> ecosystem: review: https://github.com/perl6/ecosystem/commit/9aeae98489

[23:23] <Ben_Goldberg> m: multi sub f() { say False }; multi sub f($a) { say True }; my $bar = slip(); f(|$bar);

[23:23] <camelia> rakudo-moar 5d83db: OUTPUT«False␤»

[23:24] <RabidGravy> ooh didn't realise it was tomorrow, catch you all later

[23:24] <Ben_Goldberg> m: multi sub f() { say False }; multi sub f($a) { say True }; my $bar = slip(); f(|[]);

[23:24] <camelia> rakudo-moar 5d83db: OUTPUT«False␤»

[23:24] <Ben_Goldberg> m: multi sub f() { say False }; multi sub f($a) { say True }; f(|Slip);

[23:24] <camelia> rakudo-moar 5d83db: OUTPUT«Cannot look up attributes in a type object␤  in block <unit> at /tmp/DM5HBD7QhR:1␤␤»

[23:24] <Ben_Goldberg> m: multi sub f() { say False }; multi sub f($a) { say True }; f(|Slip.new);

[23:24] <camelia> rakudo-moar 5d83db: OUTPUT«False␤»

[23:24] <Ben_Goldberg> m: multi sub f() { say False }; multi sub f($a) { say True }; f(|{});

[23:24] <camelia> rakudo-moar 5d83db: OUTPUT«False␤»

[23:27] *** lizmat joined
[23:27] *** [Sno] joined
[23:29] *** RabidGravy left
[23:42] *** Peter_R left
[23:47] *** BenGoldberg joined
[23:49] *** Ben_Goldberg left
[23:55] *** skids joined
