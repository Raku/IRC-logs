[00:15] *** Peter_R left
[00:21] <ShimmerFairy> m: sub foo(int $a) { say "OK! $a" }; foo(42)

[00:21] <camelia> rakudo-moar 631ac4: OUTPUT«OK! 42␤»

[00:21] <ShimmerFairy> m: sub foo(int $a) { say "OK! $a" }; foo(val("42"))

[00:21] <camelia> rakudo-moar 631ac4: OUTPUT«Failed to unbox object to integer␤  in sub foo at /tmp/Z7ps_bteHQ:1␤  in block <unit> at /tmp/Z7ps_bteHQ:1␤␤»

[00:21] <ShimmerFairy> Util, timotimo: ^^^ that's the basic issue

[00:25] <ShimmerFairy> binding an allomorph to a natively-typed parameter, apparently

[00:30] *** leont left
[00:52] *** sufrostico left
[01:00] <TimToady> m: my @v := [1, 2]; my \step1 = 8 X* ^4; my \step2 = @v X+> step1; say step2 X% 256;

[01:00] <camelia> rakudo-moar 631ac4: OUTPUT«===SORRY!===␤Cannot invoke this object (REPR: Uninstantiable)␤»

[01:00] <TimToady> m: my @v := [1, 2]; my \step1 = (8 X* ^4).eager; my \step2 = @v X+> step1; say step2 X% 256;

[01:00] <camelia> rakudo-moar 631ac4: OUTPUT«(1 0 0 0 2 0 0 0)␤»

[01:07] *** kanishka left
[01:09] *** aborazmeh joined
[01:09] *** aborazmeh left
[01:09] *** aborazmeh joined
[01:28] *** yqt left
[01:45] *** ilbot3 left
[01:46] *** ilbot3 joined
[01:52] *** zakharyas joined
[02:01] *** telex left
[02:02] *** telex joined
[02:14] *** vendethiel joined
[02:14] *** zed_ left
[02:19] *** dnmfarrell joined
[02:23] *** kid51 joined
[02:26] <dnmfarrell> woo it's quiet here for once. Guess the everyone's asleep eh? FWIW, I just published http://perltricks.com/article/194/2015/9/22/Activating-Perl-6-syntax-highlighting-in-Vim

[02:38] *** thou joined
[02:43] *** grondilu left
[02:44] *** noganex joined
[02:47] *** noganex_ left
[02:53] *** grondilu joined
[02:56] *** dnmfarrell left
[02:57] *** kid51 left
[03:03] *** kaare_ joined
[03:05] *** vendethiel left
[03:10] *** aborazmeh left
[03:15] *** zed_ joined
[03:15] *** zed_ left
[03:30] *** shinobi-cl joined
[03:32] <shinobi-cl> Hi

[03:38] *** pdcawley joined
[03:39] *** pdcawley left
[03:55] *** shinobi-cl left
[04:14] *** khw left
[04:21] *** skids left
[04:26] *** rmgk_ joined
[04:26] *** rmgk left
[04:26] *** rmgk_ is now known as rmgk

[04:30] *** prevost joined
[04:34] *** rurban joined
[04:37] *** prevost left
[04:39] *** thou left
[04:44] *** _28_ria left
[04:44] *** _28_ria joined
[04:54] *** rurban left
[04:59] *** Sqirrel_ left
[04:59] *** Sqirrel joined
[05:09] *** BenGoldberg left
[05:18] *** davido_ joined
[05:37] *** aborazmeh joined
[05:37] *** aborazmeh left
[05:37] *** aborazmeh joined
[05:43] <dalek> rakudo/nom: be02b7c | TimToady++ | src/Perl6/Grammar.nqp:

[05:43] <dalek> rakudo/nom: unbreak @a>>.[] dotted form

[05:43] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/be02b7c955

[05:59] <TimToady> oh, that fixes #124513 if anyone has rt write privs

[05:59] <synbot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=124513

[06:02] <dalek> roast: 124aef3 | TimToady++ | S03- (2 files):

[06:02] <dalek> roast: True ^^= True is Nil, so var should end up Any

[06:02] <dalek> roast: review: https://github.com/perl6/roast/commit/124aef3530

[06:04] *** gugod joined
[06:05] <ShimmerFairy> TimToady: I find it hard to believe that you don't :)

[06:07] *** diana_olhovik joined
[06:10] * bartolin closed RT #124513

[06:14] *** domidumont joined
[06:16] * mst got told I must hate larry earlier today for saying that perl6 and perl5 weren't the same language and I wasn't trying to port my modules to it any more than I was to python

[06:16] <mst> I. um. really?

[06:18] *** pochi left
[06:19] *** aiacob joined
[06:19] *** domidumont left
[06:20] *** domidumont joined
[06:20] <[Tux]> test             50000    36.333    36.232

[06:20] <[Tux]> test-t           50000    37.206    37.106

[06:22] *** xfix joined
[06:22] *** xfix left
[06:22] *** xfix joined
[06:23] <dalek> roast: 57f2fdf | usev6++ | S12-methods/parallel-dispatch.t:

[06:23] <dalek> roast: Unfudge passing test for RT #124513

[06:23] <dalek> roast: review: https://github.com/perl6/roast/commit/57f2fdf8d1

[06:23] <synbot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=124513

[06:27] *** espadrine joined
[06:38] *** Ven joined
[06:44] <grondilu> http://rosettacode.org/wiki/Reverse_words_in_a_string#Perl_6  now prints parenthesis.

[06:45] <grondilu> m: say ("foo",)

[06:45] <camelia> rakudo-moar be02b7: OUTPUT«(foo)␤»

[06:45] <grondilu> m: say ~("foo",)

[06:45] <camelia> rakudo-moar be02b7: OUTPUT«foo␤»

[06:45] <grondilu> m: say ~("foo", "bar")

[06:45] <camelia> rakudo-moar be02b7: OUTPUT«foo bar␤»

[06:45] <grondilu> ok, I just have to stringify then

[06:48] <Ven> Hi, #perl6!/

[06:48] <Ven> s/\/, o\//

[06:49] <grondilu> \o

[06:49] <dalek> roast: 30f08b1 | TimToady++ | S03-operators/orelse.t:

[06:49] <dalek> roast: update to new orelse semantics

[06:49] <dalek> roast: review: https://github.com/perl6/roast/commit/30f08b143a

[07:03] *** darutoko joined
[07:04] *** Ven left
[07:08] *** quester joined
[07:10] *** Ven joined
[07:14] *** davido_ left
[07:17] <[Tux]> http://tux.nl/Talks/CSV6/test-t.png

[07:17] <dalek> rakudo/nom: 5a534d6 | TimToady++ | src/core/Any.pm:

[07:17] <dalek> rakudo/nom: Mu ~~ 0 is false

[07:17] <dalek> rakudo/nom: 

[07:17] <dalek> rakudo/nom: By default, nothing defined should be accepting anything undefined.

[07:17] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/5a534d65ff

[07:17] <dalek> roast: f3a52d4 | TimToady++ | S03-smartmatch/any-num.t:

[07:17] <dalek> roast: Mu ~~ 0 and such should return False

[07:17] <dalek> roast: review: https://github.com/perl6/roast/commit/f3a52d4c82

[07:22] <dalek> roast: 579fc71 | TimToady++ | S03-smartmatch/any-str.t:

[07:22] <dalek> roast: Mu ~~ '' should also be false

[07:22] <dalek> roast: review: https://github.com/perl6/roast/commit/579fc71a3a

[07:23] *** Ven left
[07:24] *** Ven joined
[07:25] <Ven> http://perl6.org/compilers/features – should the LoL part be removed?

[07:25] <Ven> .ask TimToady also – http://perl6.org/compilers/features – can we remove the "missing exception semantics" to orelse/andalso?

[07:25] <yoleaux> Ven: I'll pass your message to TimToady.

[07:26] <[Tux]> http://tux.nl/Talks/CSV6/speed3.html

[07:27] <TimToady> Ven, yes you can remove that

[07:27] <yoleaux> 07:25Z <Ven> TimToady: also – http://perl6.org/compilers/features – can we remove the "missing exception semantics" to orelse/andalso?

[07:28] *** larion left
[07:29] <Ven> TimToady: so, I can mark them as "working as intended" now?

[07:30] <TimToady> yup

[07:32] <Ven> somehow, I keep writing "andthen" as "andalso"..:)

[07:33] *** RabidGravy joined
[07:34] *** Woodi joined
[07:34] <dalek> features: 4a6ab85 | ven++ | features.json:

[07:34] <dalek> features: Mark andthen/orelse as working

[07:34] <dalek> features: 

[07:34] <dalek> features: see http://irclog.perlgeek.de/perl6/2015-09-23#i_11260976 and https://github.com/perl6/roast/commit/30f08b143a1ec59cb89266a8209ef7bc1bb35ff4

[07:34] <dalek> features: review: https://github.com/perl6/features/commit/4a6ab85112

[07:39] *** brrt joined
[07:39] <brrt> \o

[07:40] *** rindolf joined
[07:44] <nine> Ven: hasn't NFG been default for several months now? Is still marked red in features

[07:47] <Ven> nine: yeah, jnthn++ might want to confirm we have "everything", but it warrants at least a +-

[07:47] <nine> Well I don't know what StrPos/StrLen is about and I can't find it in src/, so I guess it's gonna end up as +-

[07:50] <moritz> StrPos and StrLen are no longer needed

[07:50] <moritz> they were from a time where we thought Buf, Uni and Str were one type

[07:50] <nine> Oh, so it might end up as + after all :)

[07:50] *** domidumont left
[07:51] *** abraxxa joined
[07:53] <moritz> does rakudo-jvm do graphemes?

[07:53] <TEttinger> hm, someone brought up an odd question: if you were using perl 6 code to model English, you'd need to track certain things for verb usage like he swims, she swims, you swim, they swim, I swim, etc. being all only dependent on number. but if you modeled Spanish, you'd need to track formality for the Usted conjugation, and for adjectives you'd need genders for the applied nouns.

[07:53] <ShimmerFairy> nine: StrPos and StrLen come from before we knew that the different normalizations would be different types. (A time where you were speculated to need to sprinkle :nfkd adverbs in every call, *shudder* :P)

[07:54] <TEttinger> is there some way to attach arbitrary metadata to a perl6 variable, like "how formally this person is to be addressed" or their preferred gender (which also varies between which language, like how German has a neuter gender)

[07:54] *** domidumont joined
[07:55] <DrForr> English used to have formality too. (see 'thou') and Catalan and Andalusian still have formality for both singular and plural forms.

[07:55] <ShimmerFairy> nine: They don't matter now, since using position/length numbers you get from a Str and then turning around and trying them on a Buf is your own fault :)

[07:56] *** Ven left
[07:56] <TEttinger> and I think Japanese has a much more in-depth formality system than most Western languages

[07:56] <DrForr> TEttinger: Offhand I'd package that into an object and overload stringification, or whatever the proper term is now.

[07:56] <TEttinger> (the bowing custom alone has so many grades of formality in Japan)

[07:56] <ShimmerFairy> DrForr: and before that we didn't have any formality :P (silly French language influences...)

[07:58] <TEttinger> and the other question would be, is there a way to enforce that, if you were making say a dictionary, every object that represents a noun has a gender, but verbs and adjectives do not ever have that?

[07:59] <DrForr> One way would be to create a gender role and apply it only to the noun?

[07:59] <TEttinger> the literal question was about gendered natural languages made into an analogy about gendered programming languages. I suggested "perl 6 has every other feature, it probably has a way to represent that"

[08:00] <ShimmerFairy> TEttinger: I think the best option (or at least one of the easier ones) would be to have custom classes for that, with maybe a base role .oO(role Word ?) to at least make checking for the right collection of types easier.

[08:00] <TEttinger> yeah

[08:00] <TEttinger> I think it's completely possible, I wonder about a slang...

[08:01] <DrForr> Great, Perl6::InEsperanto :)

[08:02] <ShimmerFairy> TEttinger: perhaps I don't understand the question well enough, but I get the sense that anything more complex than classes (messing with the metamodel or such) would likely be overengineering.

[08:02] *** Ven joined
[08:02] *** abaugher left
[08:03] *** abaugher joined
[08:04] *** Ven left
[08:08] <DrForr> And really, the natural evolution I would see would be to at least start with an object hierarchy that you can poke and prod at your leisure, then add whatever overloading or casting operations you see fit on top of the working framework, so the code reads how you want.

[08:08] *** dakkar joined
[08:17] *** espadrine left
[08:17] *** aborazmeh left
[08:18] *** jack_rabbit_ joined
[08:36] *** duncan_dmg joined
[08:40] *** larion joined
[08:48] *** jack_rabbit_ left
[08:54] *** brrt left
[08:56] <Ulti> ShimmerFairy does your example of the allomorph issue work with normal Int and not just the native form, because the issue I had only turned up when I added the MAIN with an Int parameter being passed

[08:57] <ShimmerFairy> m: sub foo(Int $a) { say $a }; foo(val("42"))

[08:57] <camelia> rakudo-moar 5a534d: OUTPUT«42␤»

[08:57] <ShimmerFairy> m: sub foo(int $a) { say $a }; foo(val("42"))

[08:57] <camelia> rakudo-moar 5a534d: OUTPUT«Failed to unbox object to integer␤  in sub foo at /tmp/2r9hthsr_R:1␤  in block <unit> at /tmp/2r9hthsr_R:1␤␤»

[08:58] <ShimmerFairy> Ulti: the problem is with binding to natively-typed parameters in signatures, in the implementation of Range's iterator IIRC. (Use --ll-exception with perl6 to see where the error really comes from.)

[09:06] *** Ven joined
[09:19] *** espadrine joined
[09:19] *** cognominal joined
[09:22] *** domidumont left
[09:23] *** domidumont joined
[09:24] *** woolfy joined
[09:32] *** pat_js joined
[09:33] *** TEttinger left
[09:36] *** woolfy left
[09:38] *** domidumont left
[09:39] *** domidumont joined
[09:43] *** AlexDaniel joined
[09:46] *** brrt joined
[09:53] <dalek> rakudo/nom: c3ba558 | lizmat++ | src/core/Any-iterable-methods.pm:

[09:53] <dalek> rakudo/nom: Reinstate original grep handler for junctions

[09:53] <dalek> rakudo/nom: 

[09:53] <dalek> rakudo/nom: The new Seq based code for some reason does not handle grepping using with

[09:53] <dalek> rakudo/nom: a junction (at least according to test 28 in S32-list/grep.t).  Adding this

[09:53] <dalek> rakudo/nom: candidate using the original code, makes the test pass.  Not 100% if that

[09:53] <dalek> rakudo/nom: test is legit, though.  At least this reinstates the previous behaviour.

[09:53] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/c3ba5584a9

[09:56] <Ulti> ShimmerFairy well the issue for me is in MAIN I specify Int as the type and thats not what I got

[09:56] <Ulti> just calling .Int on that before passing it in fixes everything

[09:56] <Ulti> so its something to do with the MAIN wrangling

[09:57] *** Ven left
[09:57] <ShimmerFairy> Ulti: you get an IntStr, which isa Int. If you really mean integer, you have to convert it to numeric (and if you really mean string, you have to convert it to string)

[09:59] *** andreoss joined
[10:00] <ShimmerFairy> The issue isn't with MAIN, the issue is with the fact that IntStr won't unbox like Int does in binding to natively-typed signature params, for whatever reason.

[10:01] <Ulti> I kind of expect what I got from MAIN to be an instance of that specific type though :/

[10:02] *** brrt left
[10:02] <Ulti> but yeah I guess I wouldnt notice if it was all working as expected

[10:02] <ShimmerFairy> Ulti: that's not how parameters work in general, though. (You can use Int() as a coercive type parameter however, which say "accept objects of type Any, and call .Int on it, and give me that")

[10:03] <ShimmerFairy> Hm, I think perhaps I don't have that quite right, so nvm

[10:03] <Ulti> also another big win, the junction form of finding primes (which is incredibly elegant) now runs in 1 second instead of 11 from two years ago :)

[10:04] <Ulti> ShimmerFairy sure but whats coming from MAIN is a little magical since I'm not passing into it 

[10:04] * psch is kind of relieved to see allomorphs have bumps on both backends :P

[10:04] <moritz> lizmat: fwiw grep is supposed to work with arbitrary matches, smart-matching against them

[10:04] <moritz> m: say ('a', 42).grep(Int)

[10:04] <camelia> rakudo-moar 5a534d: OUTPUT«(42)␤»

[10:04] <moritz> so also with junctions, yes

[10:04] <moritz> m: say ('a', 42).grep(Int|Str)

[10:04] <camelia> rakudo-moar 5a534d: OUTPUT«any((42), (a))␤»

[10:05] <moritz> but that's wrong

[10:05] <moritz> it should just return ('a', 42).Seq, not a junction

[10:06] <psch> m: sub f(int $x) { say $x }; f val("42") # points at MoarVM/src/core/args.c:199, which suggests the composition get the storage spec right

[10:06] <camelia> rakudo-moar 5a534d: OUTPUT«Failed to unbox object to integer␤  in sub f at /tmp/Gf51tkPs9p:1␤  in block <unit> at /tmp/Gf51tkPs9p:1␤␤»

[10:06] <Ulti> m: my @primes.push($_) unless $_ %% any(@primes) for 2 .. 1000; say @primes[0..2]

[10:06] <camelia> rakudo-moar 5a534d: OUTPUT«(2 3 5)␤»

[10:06] <psch> +doesn't

[10:06] <lizmat> moritz: that's the bug I just fixed

[10:06] <moritz> lizmat: ok, great

[10:06] <ShimmerFairy> Ulti: P6 automatically processes stuff that comes through the commandline with val(), since there's no way for someone typing at the commandline to specify numbers vs. string data :)

[10:07] *** aiacob left
[10:07] <psch> unless there's bigint wonkiness hiding there somewhere, which is possible...

[10:07] <ShimmerFairy> Ulti: before val() and allomorphs existed, rakudo did a hackish version of it just for val()

[10:07] <Ulti> apart from me the programmer did specify I wanted an Int

[10:07] <Ulti> if its not numeric MAIN exits with usage

[10:07] <ShimmerFairy> *just for MAIN

[10:07] <ShimmerFairy> psch: fwiw this also occurs trying to bind a native num

[10:07] <psch> m: sub f(num $x) { say $x }; f val("42.0")

[10:07] <camelia> rakudo-moar 5a534d: OUTPUT«coerce string to num NYI␤  in sub f at /tmp/Et088YiAuO:1␤  in block <unit> at /tmp/Et088YiAuO:1␤␤»

[10:07] <ShimmerFairy> m: sub foo(num $x) { say $x }; foo(val("42e0"))

[10:07] <camelia> rakudo-moar 5a534d: OUTPUT«Failed to unbox object to number␤  in sub foo at /tmp/vtqU8dcPV5:1␤  in block <unit> at /tmp/vtqU8dcPV5:1␤␤»

[10:08] <psch> aah right

[10:08] <psch> hmm

[10:08] <psch> yeah "42.0" is a RatStr isn't it

[10:08] <ShimmerFairy> yep, and there aren't any native rats out there :)

[10:09] <psch> ShimmerFairy: well, in that case it's probably not the add_I workaround, but an actual problem in delegation of $!box_target

[10:10] <psch> m: use nqp; my $x = IntStr.new(5, "5"); say nqp::unbox_i($x) # but uhh

[10:10] <camelia> rakudo-moar 5a534d: OUTPUT«5␤»

[10:10] <psch> m: use nqp; my $x = IntStr.new(5, "5"); say nqp::unbox_i($x).WHAT # but uhh

[10:10] <camelia> rakudo-moar 5a534d: OUTPUT«(Int)␤»

[10:10] <psch> .WHAT reboxed iirc?

[10:10] <moritz> all method calls do

[10:10] <psch> right

[10:10] <ShimmerFairy> psch: makes sense, multiple box targets is something I spotted when working on this, and I'm surprised it didn't cause an explosion of problems :)

[10:11] <moritz> it did, on JVM, no?

[10:12] <psch> moritz: kind of, yes.  but the first hint at the problem was because the getBI implementation was overly optimistic

[10:12] <psch> moritz: as in, it assumed that the unboxIntSlot is always 0

[10:12] <psch> (which it isn't with IntStr)

[10:13] <psch> trying to fix it lead me to discover that we don't even get the right values for the unbox{*}Slot fields...

[10:13] <psch> well, for IntStr at least

[10:13] <psch> which is kind of weird..?

[10:13] *** quester left
[10:15] <ShimmerFairy> m: use nqp; sub foo(num $x) { say $x }; foo(nqp::unbox_n(val("42e0")))

[10:15] <camelia> rakudo-moar 5a534d: OUTPUT«42␤»

[10:15] <ShimmerFairy> psch: if I had the expertise to look into it, I'd try seeing what exactly the whole signature binding business does, and why it fails on allomorphs

[10:19] <psch> j: sub foo(num $x) { say $x }; foo(val("42e0")) 

[10:19] <camelia> rakudo-jvm 5a534d: OUTPUT«42␤»

[10:19] <psch> huh

[10:20] <ShimmerFairy> psch: considering the error message exists in MoarVM, I don't find that _too_ surprising :)

[10:20] <psch> ShimmerFairy: well, a similar error message exists in org.perl6.rakudo.Binder...

[10:21] <psch> ShimmerFairy: the surprising bit is that apparently the storage spec seems to differ, because both backends look rather similar in their checking code

[10:21] <ShimmerFairy> sure, I'm just saying that, as a VM-level error message, I'm not surprised to find only one VM with an issue :)

[10:21] <andreoss> # grammar Y { token TOP { [<a> | <b> | <c>]+ } { make ... } } 

[10:22] <andreoss> how can I make a ordered list here? 

[10:22] <andreoss> $/.values>>.made has broken order

[10:23] <psch> andreoss: named captures build a hash, you can &sort them by e.g. .pos

[10:23] <psch> andreoss: oh, i think Match.caps() already does that

[10:24] *** pat_js left
[10:25] <psch> m: grammar G { token TOP { [$<a>=a | $<b>=b | $<c>=c ]+ { make $/.caps() } } }; G.parse("abaacab").say;

[10:25] <camelia> rakudo-moar c3ba55: OUTPUT«｢abaacab｣␤ a => ｢a｣␤ b => ｢b｣␤ a => ｢a｣␤ a => ｢a｣␤ c => ｢c｣␤ a => ｢a｣␤ b => ｢b｣␤»

[10:25] *** mattprelude joined
[10:25] <psch> m: grammar G { token TOP { [$<a>=a | $<b>=b | $<c>=c ]+ { make $/.caps()>>.Str } } }; G.parse("abaacab").say;

[10:25] <camelia> rakudo-moar c3ba55: OUTPUT«｢abaacab｣␤ a => ｢a｣␤ b => ｢b｣␤ a => ｢a｣␤ a => ｢a｣␤ c => ｢c｣␤ a => ｢a｣␤ b => ｢b｣␤»

[10:25] <psch> ...something like that

[10:26] <psch> m: grammar G { token TOP { [$<a>=a | $<b>=b | $<c>=c ]+ { make $/.caps()>>.values } } }; G.parse("abaacab").ast.say; # i suppose

[10:26] <camelia> rakudo-moar c3ba55: OUTPUT«((｢a｣) (｢b｣) (｢a｣) (｢a｣) (｢c｣) (｢a｣) (｢b｣))␤»

[10:26] *** zakharyas left
[10:41] <andreoss> m: grammar Y { token TOP {  ^^ [ <a> | <b> ]+ % \s $$  { make $/.caps()>>.values>>.made } } ; token a { \d+ { make +$/ } }; token b { \w+ { make ~$/ } } ; }; Y.parse("A 1 b 3 c 2").ast.perl.say

[10:41] <camelia> rakudo-moar c3ba55: OUTPUT«($("A",), $(1,), $("b",), $(3,), $("c",), $(2,))␤»

[10:44] <andreoss> m: grammar Y { token TOP {  ^^ [ <a> | <b> ]+ % \s $$  { make do $_.made for $/.caps()>>.values } } ; token a { \d+ { make +$/ } }; token b { \w+ { make ~$/ } } ; }; Y.parse("A 1 b 3 c 2").ast.perl.say

[10:44] <camelia> rakudo-moar c3ba55: OUTPUT«Method 'made' not found for invocant of class 'List'␤  in block  at /tmp/edy3yFPLqk:1␤  in regex TOP at /tmp/edy3yFPLqk:1␤  in block <unit> at /tmp/edy3yFPLqk:1␤␤»

[10:46] <andreoss> m: grammar Y { token TOP {  ^^ [ <a> | <b> ]+ % \s $$  { make $/.caps()».values.flat».made } } ; token a { \d+ { make +$/ } }; token b { \w+ { make ~$/ } } ; }; Y.parse("A 1 b 3 c 2").ast.perl.say

[10:46] <camelia> rakudo-moar c3ba55: OUTPUT«("A", 1, "b", 3, "c", 2)␤»

[10:48] <andreoss> so not obvious 

[10:49] *** tomboh left
[10:51] *** pmurias joined
[10:52] *** aiacob joined
[10:57] *** pat_js joined
[11:09] *** wind_chh joined
[11:11] <lizmat> .tell jnthn got a diff for grep-index: https://gist.github.com/lizmat/bc7a10a695d361d94e71   the win does not seem to warrant the code bloat, do you agree?

[11:11] <yoleaux> lizmat: I'll pass your message to jnthn.

[11:13] *** Ven joined
[11:15] <dalek> rakudo/nom: 62a5033 | lizmat++ | src/core/Any-iterable-methods.pm:

[11:15] <dalek> rakudo/nom: Only instantiated Junctions, please

[11:15] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/62a5033d4e

[11:25] *** raiph left
[11:26] *** raiph joined
[11:29] *** Ven left
[11:31] <nine> andreoss: if order is important, use .map instead of >>

[11:33] <nine> andreoss: err...disregard that

[11:35] *** andreoss` joined
[11:35] *** kid51 joined
[11:37] *** andreoss left
[11:37] *** Gothmog_ left
[11:40] *** rurban joined
[11:46] *** Ven joined
[11:48] *** kid51 left
[11:57] <lizmat> DrForr++ : http://blogs.perl.org/users/drforr/2015/09/post-yapc-update.html

[11:58] <DrForr> Oh, thanks.

[11:58] <DrForr> I figured I was straight enough to write something up. There's lots more of course, but that's best kept off public networks :)

[11:59] <lizmat> :-)

[11:59] <dalek> rakudo/nom: 1acccc2 | lizmat++ | src/core/Any-iterable-methods.pm:

[11:59] <dalek> rakudo/nom: Make .unique about 2x / 3x faster

[11:59] <dalek> rakudo/nom: 

[11:59] <dalek> rakudo/nom: 2x for pull-one situation, 3x for push-all situations

[11:59] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/1acccc2efe

[12:03] <Ven> lizmat++ # great perf. improvements :D

[12:04] <Ven> lizmat: I wonder which kind of abstractions we'll be able to factor out of these classes after some point

[12:04] *** wind_chh left
[12:05] <lizmat> yeah, it feels it can use a lot of sugar / macro's  :-)

[12:16] *** Ven left
[12:17] <nine> Well all those optimizations have in common that they replace the abstracted, generic code with concrete, optimized implementations. So abstracting might be counter productive ;)

[12:21] <moritz> nine: what they all have in common is knowledge about when the end is reached, and how to generate the next value; it's just that avoiding doing that in several method calls is faster

[12:22] <moritz> nine: so there really is something that can be abstracted, and the default Iterator API does it; it just does it with too much overhead

[12:25] <lizmat> I see the following reason:

[12:25] <lizmat> map needs to take care of: 1 returning more than one value per iteration, 2. making sure any loop-like phasers are fired

[12:26] <lizmat> the latter could be fixed, I think

[12:26] <lizmat> the former is basically not generically possible

[12:27] <lizmat> perhaps we need a map that does not fire any loop-like phasers and must take 1 return value per iteration?

[12:28] <lizmat> perhaps filter() ?

[12:29] <nine> filter sounds more like grep

[12:30] <lizmat> well, unique is a grep, grep-index is a grep, squish is a grep  :-)

[12:30] <lizmat> hmmmm....

[12:31] <nine> They don't seem to be implemented as grep

[12:31] <dalek> rakudo-star-daily: b59e098 | coke++ | log/ (9 files):

[12:31] <dalek> rakudo-star-daily: today (automated commit)

[12:31] <dalek> rakudo-star-daily: review: https://github.com/coke/rakudo-star-daily/commit/b59e098480

[12:31] <lizmat> no, they weren't, because of grep being implemented in terms of map

[12:32] <lizmat> that's no longer the case  :-)

[12:32] <nine> >(

[12:32] <nine> :)

[12:37] *** Ven joined
[12:40] <lizmat> turning that last opt into a generic grep, makes it 2x as slow  :-(

[12:40] *** thou joined
[12:41] <lizmat> at least  :-(

[12:41] *** guest11534 left
[12:42] <nine> Let's not do that then :)

[12:43] <lizmat> hmmm.... may have a test failure here, double checking

[12:46] <jnthn> afternoon, #perl6

[12:46] <yoleaux> 11:11Z <lizmat> jnthn: got a diff for grep-index: https://gist.github.com/lizmat/bc7a10a695d361d94e71   the win does not seem to warrant the code bloat, do you agree?

[12:46] <lizmat> jnthn o/

[12:46] <lizmat> ok, between 1.2 and 1.5 times slower  :-(

[12:46] <RabidGravy> erp

[12:46] * jnthn guesses he has some patches to read...

[12:47] <jnthn> lizmat: Note that one downside of making grep not be implemented in terms of map is that it'll also no longer be parallelized without further work

[12:47] <jnthn> (though maybe you already took care of that and implemented HyperSeq.grep)

[12:48] <lizmat> no, I didn't... but will do when I get around to it  :-)

[12:48] <jnthn> ok 

[12:48] <jnthn> I will review what's happened in grep

[12:48] <jnthn> I guess it still supports next/last/redo like map?

[12:50] <lizmat> yes, the only spectest breakage is handling regexes directly

[12:50] <lizmat> sorry, no, regexes directly is fine

[12:50] <lizmat> having a regex inside a callable by itself:   /a/  is ok,  { /a/ } fails, { m/a/ } is ok

[12:50] <[Coke]> RT: 1,024; GLR: 4, testneeded: 9; xmas: 108

[12:50] *** Ven left
[12:50] *** Psyche^_ joined
[12:51] <jnthn> { /a/ } is more than a little dubious.

[12:51] <jnthn> I'm surprised it worked before

[12:51] <lizmat> well, yes, that's why I didn't fix the code or the test

[12:51] <lizmat> I wasn't sure which one was dubious

[12:51] <jnthn> { m/a/ } is fine

[12:52] <jnthn> Because it means "immediately match against $_"

[12:52] <lizmat> yup

[12:52] <jnthn> But { /a/ } means "return a Regex"

[12:52] <lizmat>  /a/ is also fine, as we have a separate candidate (opt) to handle that

[12:52] <[Coke]> m: (2/6).WHAT.say; (2/6).perl.WHAT.say;

[12:52] <camelia> rakudo-moar 1acccc: OUTPUT«(Rat)␤(Str)␤»

[12:52] <jnthn> And boolifying it will try to match it against...some $_, but you'd be darn lucky if what's in $_ is the right thing

[12:52] <[Coke]> m: (2/6).WHAT.say; (2/6).perl.EVAL.WHAT.say;

[12:52] <camelia> rakudo-moar 1acccc: OUTPUT«(Rat)␤(Rat)␤»

[12:53] <jnthn> So I think .grep({ /a/ }) is bogus, and if it worked it was an accident.

[12:53] <lizmat> ok, then I'll adapt the tests

[12:54] *** Psyche^ left
[12:55] <dalek> roast: b8cd2e8 | lizmat++ | integration/advent201 (2 files):

[12:55] <dalek> roast: Fix bogus tests wrt to { /a/ }

[12:55] <dalek> roast: see http://irclog.perlgeek.de/perl6/2015-09-23#i_11262007

[12:55] <dalek> roast: review: https://github.com/perl6/roast/commit/b8cd2e88c2

[13:00] <lizmat> jnthn: theoretical question: if grep is a HyperSeq, and unique is a grep, how would the system know that unique has a global state that doesn't let itself be hypered ?

[13:01] <jnthn> lizmat: It doesn't; we need to review such things and .serial them

[13:01] <lizmat> ok, that's what I thought  :-)

[13:01] <jnthn> lizmat: Or, better still, to give them a parallel implementation.

[13:01] <lizmat> yeah, that would be the consequence of that

[13:02] <jnthn> .uniq is a little challening I guess

[13:02] *** Ven joined
[13:02] <jnthn> .squish is quite easy

[13:02] <jnthn> You just need to be very careful at the join points

[13:02] <lizmat> it's unique nowadays  :-)

[13:02] <jnthn> gah, stop renaming stuff! :P

[13:03] <lizmat> well, uniq in unix is squish around here  :)

[13:03] <jnthn> True :)

[13:03] <lizmat> so I think that made sense  :)

[13:06] *** skids joined
[13:10] *** abaugher left
[13:11] *** abaugher joined
[13:15] <pmurias> hi

[13:18] <moritz> \o pmurias 

[13:18] *** Debolaz joined
[13:19] * jnthn is looking into the POST regression

[13:19] *** rurban left
[13:25] *** carlin joined
[13:27] <jnthn> lizmat: I don't think you need to keep the custom candidate for Junction

[13:27] <jnthn> (for grep)

[13:27] <jnthn> lizmat: I think that it should be a small fix in the grep iterator

[13:28] <jnthn> Of note, I suspect:

[13:28] <jnthn> method BUILD(\list,\test) {

[13:28] <jnthn> Needs to be Mu \test

[13:28] <lizmat> jnthn++  I will test that

[13:28] <jnthn> Oh, it's a BUILD

[13:28] <jnthn> But I think you know where I mean :)

[13:28] <jnthn> oh, I did copy it...gah, wake up brane! :)

[13:28] <lizmat> yeah, all the way through  

[13:28] <jnthn> Well, variables default to Mu, it's just parameters

[13:29] <jnthn> (which default to Any)

[13:29] *** khw joined
[13:29] <moritz> also, I think you can optimiize $value ~~ $!test  into $!test.ACCEPTS($value)

[13:29] <lizmat> moritz: I seem to recall I tried that, but that it caused spectest failures

[13:29] <lizmat> but I will check again

[13:30] <carlin> m: need Test; Test::ok 1;

[13:30] <camelia> rakudo-moar 1acccc: OUTPUT«Could not find symbol '&ok'␤  in block <unit> at /tmp/bKFqz9j1YQ:1␤␤Actually thrown at:␤  in block <unit> at /tmp/bKFqz9j1YQ:1␤␤»

[13:30] <carlin> is it possible to call an exported sub that you didn't export?

[13:30] <carlin> *didn't import

[13:31] <jnthn> carlin: Only if it declared itself "our"

[13:31] <jnthn> You're better off importing. Note that import is lexical in Perl 6, so you can easily control the scope of the import.

[13:31] <moritz> carlin: only if you go hunting in the packages EXPORT scope (oh, and don't do that)

[13:32] <dalek> rakudo/nom: e741fcd | jnthn++ | src/Perl6/World.nqp:

[13:32] <dalek> rakudo/nom: Unbust POST.

[13:32] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/e741fcd02d

[13:32] <carlin> okay, thanks jnthn and moritz 

[13:32] <jnthn> .oO( POST no bills about that bug any more... )

[13:32] *** Ven left
[13:36] * [Coke] wonders if all post stuff is working now, testing...

[13:37] <jnthn> [Coke]: Well, pre-post.t is clean (well, as clean as it was before, e.g. nothing unfudged is failing)

[13:38] <[Coke]> ok, there are fudged things in there, so the ticket is still open. danke.

[13:38] <jnthn> I just unbusted the regression, so wasn't expecting anything beyond that.

[13:38] <jnthn> Anything anyone has that they really want me to look at?

[13:39] *** sufrostico joined
[13:39] <psch> m: sub f(int $x) { $x }; f val("42")

[13:39] <camelia> rakudo-moar 1acccc: OUTPUT«Failed to unbox object to integer␤  in sub f at /tmp/xi58JTFI5R:1␤  in block <unit> at /tmp/xi58JTFI5R:1␤␤»

[13:39] <psch> m: sub f(int $x) { $x }; f nqp::unbox_i(val("42"))

[13:39] <camelia> rakudo-moar 1acccc: ( no output )

[13:39] <dalek> rakudo/nom: 0cd80e4 | lizmat++ | src/core/Any-iterable-methods.pm:

[13:39] <dalek> rakudo/nom: Remove unnecessary Junction candidate

[13:39] <dalek> rakudo/nom: 

[13:39] <dalek> rakudo/nom: Default for parameters is Any, not Mu.  jnthn++ for the pointer

[13:39] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/0cd80e4336

[13:39] <dalek> roast: 5015ba2 | coke++ | S04-phasers/pre-post.t:

[13:39] <dalek> roast: less forceful fudge

[13:39] <dalek> roast: review: https://github.com/perl6/roast/commit/5015ba2bf5

[13:40] <jnthn> psch: Hmm

[13:40] <psch> jnthn: ^^^ that seems kinda easy-ish from a distance, and allomorphs still have 1/3rd failures in their test file

[13:40] <psch> on moar that is, jvm jumps between "dies the first test" and "fails 2/3"

[13:40] <psch> depending on my progress and guesses... :)

[13:41] *** Gothmog_ joined
[13:41] <ShimmerFairy> psch: allomorphic.t passes everything for me on moar

[13:43] <psch> ShimmerFairy: oh?  my last run on moar was a few days ago, but i doubt you changed anything..?

[13:43] <ShimmerFairy> I did update the test files a bit a couple days ago

[13:43] <psch> ah, that might be it i guess

[13:43] <jnthn> Do we have a test to cover that native issue?

[13:43] <jnthn> (Or an RT?)

[13:45] <jnthn> hm, what the heck is this code doing...

[13:46] <jnthn> ah...

[13:46] <jnthn> But yeah, I think I see the fix.

[13:47] <jnthn> m: my $x = 42; sub foo(num $) { }; foo($x)

[13:47] <camelia> rakudo-moar 1acccc: ( no output )

[13:47] <jnthn> grmbl

[13:47] <jnthn> m: my $x = 42; sub foo(num $a) { say $a }; foo($x)

[13:47] <camelia> rakudo-moar 1acccc: OUTPUT«42␤»

[13:47] <jnthn> m: my $x = 42; sub foo(num $a) { say $a.WHAT }; foo($x)

[13:47] <camelia> rakudo-moar 1acccc: OUTPUT«(Num)␤»

[13:48] <jnthn> m: my $x = 42e0; sub foo(int $a) { say $a.WHAT }; foo($x)

[13:48] <camelia> rakudo-moar 1acccc: OUTPUT«(Int)␤»

[13:48] <jnthn> Those should die...

[13:50] *** Goblin_ joined
[13:50] *** Ven joined
[13:50] <Goblin_>  How can i compile perl 6 file to windows executable ?

[13:51] <jnthn> Goblin_: Don't know of a way to do that yet

[13:52] *** machin joined
[13:53] *** kanishka joined
[13:54] <Goblin_> How to distribute program?

[13:54] <moritz> same as with Perl 5: as source

[13:54] <moritz> and the user must have the compiler installed

[13:54] <DrForr> Same way you do in perl5, source ideally packaged in a module like what's on modules.perl.org.

[13:55] <moritz> though fat packing would be cool

[13:55] <moritz> (but requires Rakudo and all dependencies to be relocatable)

[13:56] <psch> well, there's this half-baked jar-packaging in a branch...

[13:56] <moritz> .oO( There's Java in the Jar! )

[13:57] <jnthn> I expect somebody will build a way at some point to bundle a load of modules up into an executable with the VM linked in

[13:57] *** timbunce_ joined
[13:57] *** Ven left
[13:58] * jnthn is muchly relieved to find that NQP and its tests don't rely anywhere on the magical int/num unbox coercion accident

[13:58] *** Goblin_ left
[13:58] <psch> oh, insight!

[13:59] <pmurias> jnthn: what's that incident about?

[13:59] <psch> the type object that gets passed into add_I from IntStr.new has the proper unbox{Int,Str}Slot values!

[13:59] <psch> ...but that'd mean all the other _I ops also need to care for the type..?

[13:59] *** rurban joined
[14:00] <jnthn> pmurias: The thing I pasted above

[14:01] <jnthn> m: my $x = 42; sub foo(num $) { }; foo($x) # should die

[14:01] <camelia> rakudo-moar e741fc: ( no output )

[14:01] <jnthn> (Does now locally)

[14:01] <psch> unless i can assume the REPRData is populated correctly after new finishes

[14:01] <psch> but there's nothing indicating that it should be

[14:01] <dalek> rakudo/nom: be46c2e | lizmat++ | src/core/Any-iterable-methods.pm:

[14:01] <dalek> rakudo/nom: Make .grep(Mu) use .ACCEPTS instead of ~~

[14:01] <dalek> rakudo/nom: 

[14:01] <dalek> rakudo/nom: moritz++ for the pointer

[14:01] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/be46c2e1d2

[14:03] *** hernanGOA joined
[14:08] <[Coke]> isn't ~~ ACCEPTS under the coversd?

[14:08] <moritz> mostly, yes

[14:08] <moritz> but ~~ also topicalizes

[14:10] * [Coke] sees that tools/autounfudge is using the limited perl6 instance (to restrict memory and time) but still seems to get hung up.

[14:11] *** Sqirrel_ joined
[14:11] <dalek> roast: a1c7756 | jnthn++ | S02-types/native.t:

[14:11] <dalek> roast: Tests for int/Int->num and num/Num->int args.

[14:11] <dalek> roast: 

[14:11] <dalek> roast: Should constrain; in Moar they accidentally coerced. And it seems we

[14:11] <dalek> roast: had no test coverage for that.

[14:11] <dalek> roast: review: https://github.com/perl6/roast/commit/a1c77562f6

[14:13] *** Sqirrel left
[14:19] *** Ven joined
[14:21] *** Ven left
[14:21] *** hernanGOA left
[14:21] <dalek> nqp: e0fdaee | jnthn++ | src/QAST/Node.nqp:

[14:21] <dalek> nqp: Tighten up use of natives in QAST dumping.

[14:21] <dalek> nqp: 

[14:21] <dalek> nqp: Also, things end up simpler. This is in anticipation of a MoarVM patch

[14:21] <dalek> nqp: that tightens up int/num native parameters.

[14:21] <dalek> nqp: review: https://github.com/perl6/nqp/commit/e0fdaee9d0

[14:21] *** machin left
[14:23] <dalek> rakudo/nom: 49fd469 | jnthn++ | src/Perl6/Actions.nqp:

[14:23] <dalek> rakudo/nom: Make sure we end up with int, not num, here.

[14:23] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/49fd469627

[14:29] <jnthn> psch: Seems I've a fix for val passing to a native int/num, testing it doesn't regress anything and adding tests.

[14:29] *** rurban left
[14:30] <psch> jnthn++ 

[14:30] *** telex left
[14:30] <jnthn> I'd better check passing to str works too :)

[14:32] *** telex joined
[14:33] *** hernanGOA joined
[14:34] <[Coke]> t/spectest.data has a test last marked "# last to prevent load interference" - -1 - if that test is failing under load, it needs to be fixed, not hidden.

[14:35] *** rurban joined
[14:36] <sjn> \o

[14:36] <lizmat> sjn o/

[14:37] <sjn> quick question; can I make a subtype of Positional where I'm only allowed to have a certain max amount of elements?

[14:37] <sjn> or something

[14:37] <sjn> (e.g. an array where I'm allowed max 8 elements)

[14:38] <jnthn> subset Limited of Positional where .elems <= 8

[14:38] <jnthn> Or something

[14:38] <jnthn> But

[14:38] <jnthn> m: my @a := Array.new(:shape(8)); @a[4] = 42

[14:38] <camelia> rakudo-moar be46c2: ( no output )

[14:38] <jnthn> m: my @a := Array.new(:shape(8)); @a[8] = 42

[14:38] <camelia> rakudo-moar be46c2: OUTPUT«Index 8 for dimension 1 out of range (must be 0..7)␤  in block <unit> at /tmp/mCNnUD0mqc:1␤␤»

[14:38] <jnthn> You can already do that, and when I wire up the syntax sugar then it'll be just `my @a[8]`

[14:39] <sjn> how would I use that in a signature?

[14:39] <jnthn> Ah, in a sig you'll have to do it with a where for the time being

[14:39] <jnthn> while .elems < 8

[14:39] <sjn> ok

[14:39] <jnthn> oops

[14:39] <sjn> where*

[14:39] <jnthn> where .elems < 8

[14:39] <jnthn> :)

[14:39] <nine> m: subset Limited of Positional where .elems < 8; my Limited $a = [1, 2, 3]; $a.push: $_ for 1 .. 10; say $a.elems; # also .elems is only checked on assignment

[14:39] <camelia> rakudo-moar be46c2: OUTPUT«13␤»

[14:41] <nine> m: subset Limited of Positional where .elems < 8; my Limited $a = []; say $a ~~ Limited; $a.push: $_ for 1 .. 10; say $a ~~ Limited # funny

[14:41] <camelia> rakudo-moar be46c2: OUTPUT«True␤False␤»

[14:41] *** timbunce_ left
[14:43] <dalek> nqp: 8304e17 | jnthn++ | tools/build/MOAR_REVISION:

[14:43] <dalek> nqp: Get Moar with native arg fixes.

[14:43] <dalek> nqp: review: https://github.com/perl6/nqp/commit/8304e17638

[14:43] <[Coke]> jnthn: t/spec/S02-types/native.rakudo.moar is failing 50, 52 here.

[14:43] *** timbunce_ joined
[14:43] <dalek> rakudo/nom: ddd2fe6 | jnthn++ | tools/build/NQP_REVISION:

[14:43] <dalek> rakudo/nom: NQP bump for Moar/NQP native param fixes.

[14:43] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/ddd2fe6086

[14:43] <[Coke]> ... trying again. :)

[14:43] <jnthn> [Coke]: Yeah, I pushed it by accident

[14:43] <[Coke]> I assume those last 2 commits fix it?

[14:44] <jnthn> [Coke]: Meant to git push in another window, and push the test after the thing I jsut pushed now :)

[14:44] *** rurban left
[14:44] <dalek> roast: 71f348a | jnthn++ | S02-literals/allomorphic.t:

[14:44] <dalek> roast: Tests for allomorphs and native parameters.

[14:44] <dalek> roast: review: https://github.com/perl6/roast/commit/71f348a47f

[14:45] <jnthn> psch: ^^ now passing on Moar; hope that covers what you were meaning :)

[14:45] <psch> jnthn: tbh, i just caught ShimmerFairy++ and Ulti++ discussing the behavior this morning... :)

[14:45] *** rurban joined
[14:45] <sjn> m: subset Limited of Positional where .elems < 8; sub foo (Limited @myargs) { say "got {@myargs.elems} args" }; foo(1,2,3,4)

[14:45] <camelia> rakudo-moar be46c2: OUTPUT«Too many positionals passed; expected 1 argument but got 4␤  in sub foo at /tmp/ySySsT2Enq:1␤  in block <unit> at /tmp/ySySsT2Enq:1␤␤»

[14:46] <jnthn> psch: Well, good to clear it up :)

[14:46] <sjn> not sure what do do here

[14:47] <jnthn> OK, that next...

[14:47] <jnthn> *what next... :)

[14:47] <psch> std: sub f(:\a) { }

[14:47] <camelia> std 28329a7: OUTPUT«ok 00:00 138m␤»

[14:47] <psch> m: sub f(:\a) { }

[14:47] <camelia> rakudo-moar be46c2: OUTPUT«5===SORRY!5=== Error while compiling /tmp/4hi5ah4pK3␤Missing block␤at /tmp/4hi5ah4pK3:1␤------> 3sub f(:7⏏5\a) { }␤»

[14:48] <psch> that's something that i postponed RTing because RT was really slow at that time

[14:48] <psch> but i guess that's mostly Perl6::Grammar

[14:48] <jnthn> :\a looks...pretty :P

[14:48] <jnthn> But yeah, makes sense it should work

[14:49] <psch> got the idea to try when there was the "is parcel" to "is raw" change

[14:49] <nine> m: subset Limited of Positional where .elems < 8; sub foo (Limited @myargs) { say "got {@myargs.elems} args" }; foo((1,2,3,4))

[14:49] <camelia> rakudo-moar be46c2: OUTPUT«Type check failed in binding @myargs; expected 'Positional[Positional]' but got 'List'␤  in sub foo at /tmp/fBjklpqXuM:1␤  in block <unit> at /tmp/fBjklpqXuM:1␤␤»

[14:49] <nine> m: subset Limited of Positional where .elems < 8; sub foo (Limited $myargs) { say "got {$myargs.elems} args" }; foo((1,2,3,4))

[14:49] <camelia> rakudo-moar be46c2: OUTPUT«got 4 args␤»

[14:49] <nine> sjn: ^^^

[14:49] <nine> sjn: Limited @myargs means an Array where each element is a Limited.

[14:50] <sjn> it does?

[14:50] <sjn> hm

[14:50] <jnthn> sub foo(*@args where Limited) { } # may cut it

[14:51] * [Coke] runs spectest with TEST_JOBS=50 for grins.

[14:51] <dalek> rakudo/nom: abb9712 | lizmat++ | src/core/Any-iterable-methods.pm:

[14:51] <dalek> rakudo/nom: Make .unique(:as) about 1.5x faster

[14:51] <dalek> rakudo/nom: 

[14:51] <dalek> rakudo/nom: There is little point in optimising the cases with a :with parameter, as

[14:51] <dalek> rakudo/nom: the bottleneck there is the use of first() to check identity.

[14:51] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/abb9712327

[14:52] <nine> sjn: my Int $foo; # $foo should obviously be an Int; my Int @foo; # @foo should almost as obviously contain Ints

[14:52] <ilmari> m: subset Limited of Positional where .elems < 8; sub foo(*@args where Limited) { say "got {@args.elems} args" }; foo(1..3); foo(1..9)

[14:52] <camelia> rakudo-moar be46c2: OUTPUT«got 3 args␤Constraint type check failed for parameter '@args'␤  in sub foo at /tmp/c58rugr1hW:1␤  in block <unit> at /tmp/c58rugr1hW:1␤␤»

[14:52] <dalek> rakudo/nom: 564a255 | coke++ | t/spectest.data:

[14:52] <dalek> rakudo/nom: Add these already passing tests to spectest

[14:52] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/564a255d0c

[14:54] <[Coke]> S04-statements/lift.t appears to be a conjectural test that refers to something that no longer exists.

[14:54] <[Coke]> Can I kill it?

[14:55] <[Coke]> ah. RT #124579 was rejected, but the test wasn't deleted. Killing test..

[14:55] <synbot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=124579

[14:56] <lizmat> [Coke]:: also spec commit eb0f21689e70b3280745

[14:56] <lizmat> "This is going away in favor of better parameter declarations that can implicitly default to operators as seen by the caller."

[14:57] <dalek> roast: 0a0e339 | coke++ | S04-statements/lift.t:

[14:57] <dalek> roast: Lift was unspecced. Removing test file

[14:57] <dalek> roast: 

[14:57] <dalek> roast: RT #124579

[14:57] <dalek> roast: review: https://github.com/perl6/roast/commit/0a0e33987b

[14:57] <synbot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=124579

[15:06] * TimToady wanted to close a couple of tickets last night but doesn't have the RT charm to do that yet

[15:07] <jnthn> [Coke]: Do you have admin access to fix ^^? :)

[15:07] <zostay> m: sub f(*@a) { @a.say }; f('a' => 1, 'b' => 2, 'c' => 3); f(a => 1, b => 2, c => 3);

[15:07] <camelia> rakudo-moar 49fd46: OUTPUT«[a => 1 b => 2 c => 3]␤Unexpected named parameter 'a' passed␤  in sub f at /tmp/oXPl6sok4E:1␤  in block <unit> at /tmp/oXPl6sok4E:1␤␤»

[15:08] <jnthn> zostay: If you want to capture named params into a hash, there's *%h

[15:09] <zostay> right, i'm just trying to understand the nuances of when an arg is a Pair and when an arg is a named parameter

[15:10] <jnthn> zostay: Whenever there's an identifier to the left of the => it's a named arg

[15:10] <TimToady> basically it comes down to whether there's a bare identifier

[15:10] <TimToady> and :foo is always considered bare

[15:10] <zostay> that makes sense to me, thx

[15:11] <TimToady> and has to be at the arg level, so parens are also hiding

[15:11] *** Ven joined
[15:11] *** royalkiran007 joined
[15:12] <jnthn> m: say uniname(0x7F)

[15:12] <camelia> rakudo-moar 49fd46: OUTPUT«DELETE␤»

[15:12] <jnthn> m: say 0x7F

[15:12] <camelia> rakudo-moar 49fd46: OUTPUT«127␤»

[15:12] <TimToady> shoulda been named RUBOUT :)

[15:13] <jnthn> Just looking into the missing <.print> and <.graph> in regexen

[15:13] <zostay> cool beans, now that Pair has been refactored to handling binding, i am making KnottyPair obsolete and removing it

[15:13] <jnthn> TimToady: iiuc, <.print> is the same as <-cntrl>?

[15:14] *** domidumont left
[15:15] <TimToady> that's at least a good first approximation

[15:15] <jnthn> Ah, Perl 5's re docs have a different definition

[15:16] <jnthn> "All printable characters, which is the set of all graphical characters plus those whitespace characters which are not also controls."

[15:16] <jnthn> And

[15:16] <jnthn> (graphical is defined as)

[15:16] <jnthn> "Any character that is graphical, that is, visible. This class consists of all alphanumeric characters and all punctuation characters."

[15:17] *** aiacob left
[15:18] * jnthn leaves print as "not control" for now, and makes graph annum + punct

[15:19] <timotimo> jnthn: i realize people keep piling things onto your plate; how do you feel about investigating the chaining of flattening in the perl6 optimizer or the nfa to statelist thing branch? :|

[15:19] <jnthn> m: say nqp::iscclass(nqp::const::CCLASS_PUNCTUATION, '_', 0)

[15:19] <camelia> rakudo-moar 49fd46: OUTPUT«1␤»

[15:21] <jnthn> timotimo: Chaining of flattening?

[15:22] <jnthn> The NFA thing...I know that at some point I need to deal with the fact that our NFAs don't quite get NFG right, so probably something to poinder when I get to that.

[15:23] <timotimo> jnthn: the optimizer has a flag that signifies "was this block flattened?" that gets passed to "incorporate_inner", but it's never set to 1

[15:24] <jnthn> Oh, *that* kind of flattening

[15:24] <timotimo> when i set it to 1 after flattening the block, it causes problems: a QAST::Var that gets turned from lex to local inside a block that's far removed from where i'd've expected it, and it breaks because the var wasn't defined in that block

[15:24] * jnthn apparently still has the GLR swapped in... :)

[15:25] <timotimo> right, i should have disambiguated immediately :)

[15:25] <TimToady> let's not overload "flat" any further

[15:25] *** rurban left
[15:26] *** diana_olhovik left
[15:26] <timotimo> we should call executables that contain modules and scripts and such "flat", too

[15:26] <jnthn> TimToady: Yeah, though thankfully this one's in the bowels of the optimizer only :)

[15:28] <timotimo> so, i thought there's some kind of oversharing and the one thing i recalled that shares qast nodes across large distances was build_inline_info, but that's not at fault here

[15:30] <jnthn> ooh yay, seems I get to remove the last fudge marks from stdrules.t.

[15:31] <[Coke]> TimToady: you should be a bug admin now.

[15:31] <timotimo> if not, bug admins now

[15:31] <[Coke]> (please be sure to cc the mailing list when replying to tickets via the webterface, which is pretty much the only advice I give to people answering tickets. :)

[15:32] <TimToady> okay

[15:33] *** rurban joined
[15:34] *** xinming_ joined
[15:36] *** adu joined
[15:37] <nine> [Coke]: what mailing list?

[15:37] *** xinming left
[15:37] <timotimo> perhaps rakudobug@ ?

[15:37] <dalek> nqp: bf1d2ad | jnthn++ | src/QRegex/Cursor.nqp:

[15:37] <dalek> nqp: Implement <.print> and <.graph> rules.

[15:37] <dalek> nqp: review: https://github.com/perl6/nqp/commit/bf1d2ad74a

[15:39] <hoelzro> o/ #perl6

[15:39] <dalek> roast: ba45802 | coke++ | S05-syntactic-categories/new-symbols.t:

[15:39] <dalek> roast: Add refs to RT #126142

[15:39] <dalek> roast: review: https://github.com/perl6/roast/commit/ba45802d80

[15:39] <synbot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=126142

[15:40] <[Coke]> perl6-compiler - it's one of the options when replying to a ticket via the webterface, to cc the mailing list.

[15:40] <dalek> rakudo/nom: c43ac75 | jnthn++ | tools/build/NQP_REVISION:

[15:40] <dalek> rakudo/nom: Bump NQP_REVISION for <.print>/<.graph>.

[15:40] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/c43ac75d79

[15:40] <jnthn> [Coke]: Isn't that the default?

[15:40] <[Coke]> the mailing list gets the initial email ona ticket, but the default is not to cc them on comments later.

[15:40] <[Coke]> so, no.

[15:41] <jnthn> I see a

[15:41] <TimToady> it's a single click to do it though

[15:41] <jnthn> Bcc: [email@hidden.address] 

[15:41] <[Coke]> jnthn: yes. you have to click to enable it.

[15:41] <jnthn> I'd been assuming that meant it was mailing the list... :S

[15:41] <TimToady> the bullet is misleading

[15:41] *** Ven left
[15:41] <TimToady> it looks like a clicked button

[15:41] * [Coke] adds a NYI ticket.

[15:41] <jnthn> I see this in the Recipients section, though?

[15:42] <TimToady> it didn't send my last message when I forgot to click

[15:42] <TimToady> but this time it did

[15:43] <dalek> roast: cafa204 | jnthn++ | S05-mass/stdrules.t:

[15:43] <dalek> roast: Unfudge tests for <.print> and <.graph>.

[15:43] <dalek> roast: review: https://github.com/perl6/roast/commit/cafa204ab1

[15:44] <jnthn> There's an easy one off my "stuff before xmas" list :)

[15:44] <[Coke]> r: use Test; ok("  a b\tc" ~~ m/@<chars>=( \s+ \S+ )+/, 'Named simple array capture');

[15:45] <camelia> rakudo-moar 564a25: OUTPUT«===SORRY!===␤QAST::Block with cuid cuid_1_1443023098.31053 has not appeared␤»

[15:45] <camelia> ..rakudo-jvm 564a25: OUTPUT«===SORRY!===␤setcodeobj can only be used with a CodeRef␤»

[15:45] <jnthn> TimToady: Please can you at some point make a ruling on https://rt.perl.org/Ticket/Display.html?id=67128 ?

[15:45] <[Coke]> ^^ that's at least LTA, but should that work?

[15:47] <dalek> rakudo/nom: 3970634 | lizmat++ | src/core/Str.pm:

[15:47] <dalek> rakudo/nom: Oops, we need an if instead a while here

[15:47] <dalek> rakudo/nom: 

[15:47] <dalek> rakudo/nom: timotimo++ for spotting.  No noticeable performance difference, though

[15:47] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/3970634d0f

[15:47] <jnthn> [Coke]: I...think so, yeah

[15:47] <jnthn> m: multi foo(:$d!, *@f) {}; multi foo(*@f) { say "works" }; foo()

[15:47] <camelia> rakudo-moar 564a25: OUTPUT«works␤»

[15:47] <jnthn> m: multi foo(*@f, :$d!) {}; multi foo(*@f) { say "works" }; foo()

[15:47] <camelia> rakudo-moar 564a25: OUTPUT«Ambiguous call to 'foo'; these signatures all match:␤:(*@f, :$d!)␤:(*@f)␤  in block <unit> at /tmp/Ck5R19Bsbw:1␤␤»

[15:47] <jnthn> std: multi foo(:$d!, *@f) {}; multi foo(*@f) { say "works" }; foo()

[15:47] <camelia> std 28329a7: OUTPUT«Potential difficulties:␤  @f is declared but not used at /tmp/rT08h6Drfz line 1:␤------> 3multi foo(:$d!, *7⏏5@f) {}; multi foo(*@f) { say "works" }; ␤ok 00:00 140m␤»

[15:48] <jnthn> std: multi foo(:$d!, *@f) {}; multi foo(*@f) { say "works" }; foo() # OK shut up about unused crapp STD

[15:48] <camelia> std 28329a7: OUTPUT«Potential difficulties:␤  @f is declared but not used at /tmp/NwpdpWFw_3 line 1:␤------> 3multi foo(:$d!, *7⏏5@f) {}; multi foo(*@f) { say "works" }; ␤ok 00:00 141m␤»

[15:48] <jnthn> std: multi foo(:$d!, *@f) {}; multi foo(*@f) { say "works" }; foo() # OK

[15:48] <camelia> std 28329a7: OUTPUT«Potential difficulties:␤  @f is declared but not used at /tmp/KO9jaF8oLB line 1:␤------> 3multi foo(:$d!, *7⏏5@f) {}; multi foo(*@f) { say "works" }; ␤ok 00:01 141m␤»

[15:48] <jnthn> std: multi foo(:$d!, *@f) {}; multi foo(*@f) { say "works" }; foo() #OK

[15:48] <camelia> std 28329a7: OUTPUT«ok 00:00 141m␤»

[15:48] <jnthn> *sigh*

[15:48] <jnthn> One feature Rakudo will NOT be borrowing from STD...

[15:48] <timotimo> :D

[15:48] <jnthn> std: multi foo(*@f, :$d!) {}; multi foo(*@f) { say "works" }; foo() #OK

[15:48] <camelia> std 28329a7: OUTPUT«ok 00:01 141m␤»

[15:48] <jnthn> Hm, so you can order things that way

[15:48] *** Ven joined
[15:49] *** Alina-malina left
[15:50] *** Ven left
[15:52] <lizmat> m: (^10).grep( { .say } ).grep( { last } )   # did this work pre-GLR  (as in only say 0 ?)

[15:52] <camelia> rakudo-moar 564a25: OUTPUT«0␤»

[15:53] *** kanishka left
[15:53] <lizmat> if not, yeah GLR  :-)

[15:53] <jnthn> lizmat: I think it should have worked pre-GLR

[15:54] <lizmat> star: (^10).grep( { .say } ).grep( { last } ) 

[15:54] <camelia> star-m 2015.03: OUTPUT«0␤»

[15:54] <jnthn> Though I'm sure it works more efficiently nowadays :)

[15:54] <lizmat> ok, but it still workd now  :-)

[15:54] * jnthn wonders if there's a test for that :)

[15:54] *** yqt joined
[15:55] *** abraxxa left
[15:55] <lizmat> well, one could wonder whether they should live in roast

[15:55] <lizmat> as laziness is really optional, no?

[15:56] <jnthn> Yes, I think those semantics are something one should be able to rely on

[15:56] *** xinming_ left
[15:56] <jnthn> I mean, for $*IN.lines.grep(/a/) { last if /b/; }

[15:56] *** xinming joined
[15:56] <jnthn> We don't expect it to swallow ahead on the filehandle there

[15:57] <jnthn> In fact, we'd be rather upset if it did :)

[15:57] <dalek> roast: 442a23d | coke++ | S05-capture/array-alias.t:

[15:57] <dalek> roast: Add note for RT #126143

[15:57] <dalek> roast: review: https://github.com/perl6/roast/commit/442a23d74c

[15:57] <synbot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=126143

[15:57] <jnthn> So I think such semantics are required by the language.

[15:57] <jnthn> (And so are a good thing to roast)

[15:57] <lizmat> ok, time to write some tests, then

[15:57] <lizmat> as I think these are most definitely, not tested yet

[15:58] <dakkar> hmm. I have a class with a «submethod DESTROY { }» that serialises some state; what's the best way to test that it works?

[15:58] <dakkar> in other words, how do I trigger object destruction?

[15:58] <lizmat> from Perl 6, you can't

[15:58] <dakkar> (or am I thinking too much like perl5 / c++ here?)

[15:58] <dakkar> lizmat: I feared such a response :)

[15:58] <lizmat> you can never be sure that your DESTROY method will be called

[15:59] <dakkar> not at all? not even at process termination?

[15:59] <timotimo> correct

[15:59] <lizmat> especially not at process termination

[15:59] <dakkar> argh

[15:59] <dakkar> so I have to *explicitly* tell my objects to save themselves? :(

[15:59] <lizmat> well, there are things like LEAVE phasers

[16:00] <lizmat> and will leave

[16:00] <jnthn> And END still exists

[16:00] <lizmat> my $object will leave { $object.save }

[16:00] <lizmat> my $object will leave { $object.save } = Class.new

[16:00] <dakkar> eh. conceptually, to me, that's the "wrong" place to say it

[16:00] <dakkar> why should the caller have to know that the object is caching state to disk?

[16:01] <dakkar> it could (in my case) just rebuild the state every time

[16:01] <dakkar> it's an implementation detail, inside the class

[16:02] <lizmat> dakkar: I think we will find some syntactic sugar for will leave in the future

[16:02] *** rindolf left
[16:02] <lizmat> but I don't think that will be before Christmas  :-(

[16:02] <dakkar> I'm not objecting to the syntax

[16:02] <lizmat> I understand your point...

[16:02] <dakkar> if, when creating an object, I want to attach some code to "when this name goes out of scope", «will leave» is fine

[16:03] <dakkar> I'm trying to solve a slightly different problem…

[16:03] <lizmat> I've been looking at making a "use Class" in a scope make magic happen to variables with objects of that type leaving that scope

[16:03] <lizmat> it's hard  :-)

[16:04] <dakkar> if it weren't hard, it would have been done already :))))

[16:04] <dakkar> looks like you people have already solved all the easy and medium problems

[16:04] <moritz> there are still a lot of low-hanging fruits in Perl 6 land

[16:06] <lizmat> cycling&

[16:07] <jnthn> dakkar: If we wanted to keep timely destruction of objects in Perl 6 then we'd pretty much be forced to do ref counting, which is (a) not good for concurrency, and (b) would rule out running on things like the JVM

[16:07] <dakkar> I understand that

[16:07] <dakkar> it's the part where DESTROY may not be called at all that worries me

[16:07] <dalek> perl6-roast-data: 272b4a7 | coke++ | / (8 files):

[16:07] <dalek> perl6-roast-data: today (automated commit)

[16:07] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/272b4a767c

[16:07] <dakkar> I have no issues with "it will be called at some point between last-ref-goes-away and global destruction"

[16:08] <moritz> maybe we should have a way to signal "always do a global destruction at exit"

[16:08] <[Coke]> pmurias: what can I do to fix the nqp-js builds on hack?

[16:08] <TimToady> which an embedding interface would turn on by default

[16:09] <jnthn> Trouble is, even if we do manage to find a way to make that happen on, say, MoarVM, it'll only be setting you up for bug reports about misbehavior on JVM et al.

[16:09] <jnthn> TimToady: Yes, embedding is where we'd want to find a way, though note that "free all memory" != "call all DESTROYs"

[16:10] *** Alina-malina joined
[16:10] <jnthn> We could arrange for the latter too, or a decent approximation.

[16:10] *** mattprelude left
[16:11] <[Coke]> psch: you're working on jvm, aye? currently 1432 failing tests.

[16:12] <jnthn> Darn, fixing RT #118467 - or at least the first attempt - caused a small number of odd regressions.

[16:12] <synbot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=118467

[16:12] <[Coke]> 63 failures on moar-jit and moar-nojit.

[16:12] <psch> [Coke]: yeah, i'm still working on the IntStr stuff

[16:12] <[Coke]> (not on my os x box, but on hack)

[16:12] <[Coke]> psch++

[16:13] <TimToady> jnthn: yeah, I've noticed lately that fixing one corner case tends to light up several others  :/

[16:14] <jnthn> TimToady: Why didn't we just design a really simple language like Java where there aren't enough features for corner caess? ;)

[16:14] <TimToady> because it wasn't there!

[16:14] <jnthn> :)

[16:14] <psch> checked vs unchecked exceptions, native arrays vs object arrays...

[16:15] <psch> i'll admit, javas corners are rounded and padded :)

[16:15] *** larion left
[16:16] <jnthn> Apparenlty it's time to ponder dinner :) Will continue hunting later. :)

[16:21] *** carlin left
[16:22] *** xinming_ joined
[16:24] <pmurias> [Coke]: do you have a stack trace of the builds failing?

[16:25] *** xinming left
[16:26] <pmurias> [Coke]: or do you mean how to we make the version of nqp-js the evalbot automatically rebuilt?

[16:26] <[Coke]> not evalbot, my daily runs. one sec.

[16:27] <[Coke]> https://github.com/coke/perl6-roast-data/blob/master/log/nqp.js_summary.out#L120

[16:28] *** rindolf joined
[16:28] * pmurias checks

[16:31] <pmurias> [Coke]: it's an issue with building the node.js module we use to implement nqp::sleep

[16:32] *** rurban left
[16:33] <pmurias> [Coke]: while googling the error message someone seems to suggest that it's the fault of the debian node.js package

[16:33] *** Ven joined
[16:33] <pmurias> and using a nodesource node.js fixes that

[16:34] *** xinming joined
[16:34] <[Coke]> ok. verified this is debian. How does one do that last thing?

[16:34] <TimToady> hmm, the message cc'd to p6c doesn't mention the state change

[16:35] <[Coke]> nope. for bonus points, you need to say "so I'm resolving/rejecting/whatever" in the comment. :|

[16:35] <[Coke]> the originator of the ticket gets an email on the state chagne.

[16:37] *** xinming_ left
[16:38] *** pat_js left
[16:38] *** diana_olhovik_ joined
[16:38] <pmurias> [Coke]: I'm not sure, I'm a lousy sysadmin and I don't have root on hack (and likely shouldn't :) )

[16:39] *** pat_js joined
[16:39] *** dakkar left
[16:41] *** Ven left
[16:42] <psch> https://github.com/RobertCNelson/omap-image-builder/issues/61 has <npm install -g npm> as workaround for that error

[16:43] *** diana_olhovik_ left
[16:46] <[Coke]> that page also says, "This is not a good idea". :)

[16:46] <[Coke]> I'll leave this to moritz. :)

[16:47] <psch> oh, i must've overlooked that

[16:49] *** hernanGOA left
[16:51] *** hernanGOA joined
[16:52] *** pochi joined
[16:53] *** raiph left
[16:56] *** raiph joined
[17:02] *** liztormato joined
[17:03] <TimToady> actually, I find it kind of reassuring that my fan backs off during S17; means we're sleeping and not busylooping

[17:05] <liztormato> dakkar: if you don't mind objects hanging around until global destruction, it would be trivial to put objects of a class in an array to be used to execute DESTROY on in an END block

[17:07] *** hernanGOA left
[17:10] <PerlJam> liztormato: sounds like someone could write a role/module just for that purpose too.

[17:11] <liztormato> Yeah. Will prototype when I get home unless someone beats me to it

[17:17] *** diana_olhovik__ joined
[17:20] *** duncan_dmg left
[17:23] *** domidumont joined
[17:23] *** diana_olhovik__ left
[17:30] *** Peter_R joined
[17:32] *** diana_olhovik_ joined
[17:36] *** raiph left
[17:37] *** diana_olhovik_ left
[17:39] * jnthn back for a little bit

[17:42] <nine> liztormato: Inline::Perl5 does something similar with the first object

[17:43] *** yqt left
[17:43] *** diana_olhovik joined
[17:48] *** diana_olhovik left
[17:48] *** vendethiel joined
[17:54] *** diana_olhovik joined
[17:58] <jnthn> m: multi foo(*@x where True) { }; foo(1,2)

[17:58] <camelia> rakudo-moar 397063: ( no output )

[17:58] <jnthn> m: multi foo(*@x where True) { say @x }; foo(1,2)

[17:58] <camelia> rakudo-moar 397063: OUTPUT«[1 2]␤»

[17:59] <jnthn> m: multi foo(*@x where @x) { say @x }; foo(1,2)

[17:59] <camelia> rakudo-moar 397063: OUTPUT«[1 2]␤»

[18:01] *** timbunce_ left
[18:01] *** liztormato left
[18:03] *** timbunce_ joined
[18:04] *** diana_olhovik left
[18:06] *** liztormato joined
[18:12] *** liztormato left
[18:16] <jnthn> The move.t and rename.t spectest fails after my multi patch are pretty odd

[18:16] *** espadrine left
[18:16] *** patrickz joined
[18:17] *** FROGGS[mobile] joined
[18:18] <[Coke]> S32-io/move.t was -just- added.

[18:18] <[Coke]> it passed here, so I added it. might not have been passing for you yet.

[18:18] <[Coke]> (rename.t is from May, no such luck there.)

[18:20] <jnthn> Oh...

[18:21] <FROGGS[mobile]> o/

[18:21] <FROGGS[mobile]> hello from a bus

[18:22] <[Coke]> Hello, bus, I'm dad.

[18:22] <jnthn> Huh, rename.t is unhappy without my patches too

[18:22] *** hernanGOA joined
[18:22] <psch> o/ FROGGS[mobile] 

[18:22] <[Coke]> ship it!

[18:23] <FROGGS[mobile]> bus it!

[18:25] * jnthn runs a fresh spectest to make sure his fix for the real regression is really fine enough :)

[18:29] *** diana_olhovik_ joined
[18:31] *** rurban joined
[18:32] <TimToady> m: constant @digs = flat (0..9 xx *) X% 10;

[18:32] <camelia> rakudo-moar 397063: OUTPUT«5===SORRY!5=== Error while compiling /tmp/QtHfi3cEDg␤An exception occurred while evaluating a constant␤at /tmp/QtHfi3cEDg:1␤Exception details:␤  Earlier failures:␤   Cannot .elems a lazy list␤    in block  at /tmp/QtHfi3cEDg:1␤␤  Final …»

[18:33] <TimToady> that's...not so good

[18:34] <jnthn> What tries to .elems, I wonder...

[18:34] <TimToady> m: constant @digs = (|(0..9) xx *) X% 10;

[18:34] <camelia> rakudo-moar 397063: ( no output )

[18:34] <TimToady> flat?

[18:35] <FROGGS[mobile]> why should it? 

[18:35] <jnthn> I can't imagine why .flat would.

[18:35] <jnthn> Well, or flat

[18:36] <TimToady> handle-begin-time-exceptions from the trace

[18:36] *** leont joined
[18:36] <patrickz> Is there any initiative or plan to get a CPAN lookalike (CPAN as in a Website where one can browse modules, look at documentation and a store where versioned modules can be put) up and running by 6.christmas?

[18:36] <[Coke]> patrickz: I doubt that will happen, no.

[18:36] <TimToady> no, that's after, I guess

[18:37] <[Coke]> work is being done to take advantage of the PAUSE infrastructure.

[18:37] <FROGGS[mobile]> patrickz: I've got such a dream, but I'm not working on that bit this year I fear

[18:38] <jnthn> *sigh* Gah, now I've managed to make a couple of spectests hang with the fix :/

[18:38] <TimToady> m: constant @digs = ((0..9 xx *) X% 10).flat;

[18:38] <camelia> rakudo-moar 397063: OUTPUT«5===SORRY!5=== Error while compiling /tmp/E9qpH898eb␤An exception occurred while evaluating a constant␤at /tmp/E9qpH898eb:1␤Exception details:␤  Earlier failures:␤   Cannot .elems a lazy list␤    in block  at /tmp/E9qpH898eb:1␤␤  Final …»

[18:38] <patrickz> It's neither decided whether it'll be CPAN that's adapted or a separate platform, is it?

[18:39] <FROGGS[mobile]> it kinda is

[18:39] <patrickz> no CPAN?

[18:39] <[Coke]> PAUSE looks very likely. CPAN is more than just the website, though.

[18:39] <[Coke]> I suspect the website is not going to be done before christmas, no.

[18:40] <FROGGS[mobile]> as most of us dont expect that either search.cpan.org or metacpan will Mix P5 an P6 stuff

[18:40] <TimToady> m: constant @digs = ((0..9 xx *) X% 10).WHAT;

[18:40] <camelia> rakudo-moar 397063: OUTPUT«5===SORRY!5=== Error while compiling /tmp/StJIjX20Kc␤An exception occurred while evaluating a constant␤at /tmp/StJIjX20Kc:1␤Exception details:␤  Earlier failures:␤   Cannot .elems a lazy list␤    in block  at /tmp/StJIjX20Kc:1␤␤  Final …»

[18:40] <patrickz> I have read something on ShimmerFairies blog that CPAN is fundamentaly incompatible with Perl6s versioning schema.

[18:40] <TimToady> curious

[18:40] <[ptc]> m: my @files = find(:dir("/tmp"), :type("file")); say @files; say @files.WHAT

[18:40] <camelia> rakudo-moar 397063: OUTPUT«5===SORRY!5=== Error while compiling /tmp/DplRL7tSFu␤Undeclared routine:␤    find used at line 1␤␤»

[18:40] <pink_mist> my personal expectation is that metacpan will make a p6.metacpan.org site for p6

[18:41] <[Coke]> patrickz: as far as I know, that's not the case.

[18:41] <[ptc]> m: use File::Find; my @files = find(:dir("/tmp"), :type("file")); say @files; say @files.WHAT

[18:41] <camelia> rakudo-moar 397063: OUTPUT«===SORRY!===␤Could not find File::Find in any of:␤  file#/home/camelia/.perl6/2015.09-95-g3970634/lib␤  inst#/home/camelia/.perl6/2015.09-95-g3970634␤  file#/home/camelia/rakudo-inst-2/share/perl6/lib␤  file#/home/camelia/rakudo-inst-2/share/perl…»

[18:41] * patrickz is looking that up

[18:41] <[ptc]> bother...

[18:41] <[Coke]> no one at metacpan is going to do that on their own, I'm sure.

[18:41] <[Coke]> anyway, yes, it'd be great to have. Probably won't be by christmas.

[18:42] <[ptc]> patrickz: I had a discussion with Andreas König at the Austrian Perl Workshop about that last year, and it seems that Perl6 modules can be uploaded without problems; only Perl5 modules get indexed

[18:42] <[ptc]> patrickz: however, afaict it was planned to have Perl6 modules on CPAN

[18:43] <patrickz> https://rdstar.wordpress.com/2014/03/09/perl6-and-cpan/

[18:43] <[ptc]> come to think of it, FROGGS[mobile] probably knows more about thaty

[18:43] <[ptc]> *that

[18:44] <FROGGS[mobile]> we can upload stuff via PAUSE, yes

[18:45] <FROGGS[mobile]> so we make use of their mirrors, and author registrations

[18:46] *** sufrostico left
[18:46] <FROGGS[mobile]> patrickz: we have our own distribution indexer running on cpan already btw

[18:46] <patrickz> Ignoring the website for now, I think it'd be great to have the module platform efforts point in one single direction by christmas, to make sure Perl6 will end up with one single most famous place for modules to be put. (And not end up with a fractured ecosystem like Java or Android)

[18:48] <TimToady> oh, duh, 0..9 xx * is a precedence problem

[18:48] *** spider-mario joined
[18:49] <FROGGS[mobile]> patrickz: there can be a douzen sites that use the same data from cpan, mind

[18:49] *** diana_olhovik_ left
[18:52] <dalek> rakudo/nom: cf3439c | jnthn++ | src/core/List.pm:

[18:52] <dalek> rakudo/nom: Add missing .cache in flat slurpy handling.

[18:52] <dalek> rakudo/nom: 

[18:52] <dalek> rakudo/nom: Needed if we end up doing a bind check in a multi-dispatch. Has been a

[18:52] <dalek> rakudo/nom: potential issue for a while, but an upcoming multi-dispatch tweak made

[18:52] <dalek> rakudo/nom: a spectest show up this problem.

[18:52] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/cf3439c511

[18:52] <dalek> rakudo/nom: f2488e7 | jnthn++ | src/Perl6/Metamodel/BOOTSTRAP.nqp:

[18:52] <dalek> rakudo/nom: Multi-dispatcher shouldn't ignore all beyond **@x.

[18:52] <dalek> rakudo/nom: 

[18:52] <dalek> rakudo/nom: There may be extra, required, named arguments beyond it that serve as

[18:52] <dalek> rakudo/nom: a tie-breaker.

[18:52] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/f2488e7043

[18:52] <dalek> roast: d35c69e | jnthn++ | S06-multi/positional-vs-named.t:

[18:52] <dalek> roast: Unfudge tests for RT #118467.

[18:52] <dalek> roast: review: https://github.com/perl6/roast/commit/d35c69edda

[18:52] <synbot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=118467

[18:52] <jnthn> Finally...

[18:53] <FROGGS[mobile]> jnthn++

[18:53] <patrickz>  I'm fine with that (there is CPAN/MetaCPAN after all). But having documentation looking different and having to use different installation strategies for two modules is time-consuming and annoying. That's one of the features I like so much about Perl. Go to MetaCPAN, find the fitting module, and look at the synopsis at the top of the page. Happyness. :-)

[18:55] <FROGGS[mobile]> patrickz: the site showing dists is independend from your dist installer anyway

[18:55] *** andreoss` left
[18:58] <jnthn> TimToady: From S11: "Any proto declaration that is not declared my is exported by default. Any multi that depends on an exported proto is also automatically exported. Any autogenerated proto is assumed to be exported by default." Do we still want those semantics?

[18:58] <jnthn> TimToady: Especially as "my" is now the default for any routine declaration.

[18:59] <FROGGS[mobile]> I envision a shop like page btw, that allows to create profiles like "dev-laptop", and install the dists of that profile

[18:59] *** diana_olhovik joined
[19:00] <patrickz> Compare that to Java. Documentation for Tomcat is different from documentation for Guava. They start to converge on Maven Central. But some time ago one had to add separate repository links for nearly every library one wished to depend on.

[19:00] <FROGGS[mobile]> like the app-/playstore remembers what you've bought to ease reinstallation

[19:01] *** sufrostico joined
[19:01] <FROGGS[mobile]> eww

[19:03] *** rindolf left
[19:03] <FROGGS[mobile]> docs are Pod shipped with the dist, there should be no trouble

[19:04] <patrickz> Once Pod6 hits PrimeTime. :-) Go ShimmerFairy!

[19:04] <patrickz> Until then there is README.md...

[19:05] <FROGGS[mobile]> jnthn: pollut\Wexport something by default? I'd say no

[19:05] <FROGGS[mobile]> patrickz: well, the web page renders it

[19:06] <FROGGS[mobile]> it might be less fun to read locally

[19:06] <FROGGS[mobile]> same goes for markdown though

[19:06] <patrickz> True. I can't blame WIP of documentation of modules on markdown I guess.

[19:06] *** rurban left
[19:07] *** rindolf joined
[19:07] <jnthn> FROGGS[mobile]: Yes, my gut feeling is "I'd think we maybe don't want that feature any more", in which case I can remove that bit from the design docs, close the RT, and we're another issue before Christmas down. :)

[19:07] <RabidGravy> all my modules just have pod no actually documentation in the README

[19:07] <rindolf> Hi all. Sup?

[19:07] <jnthn> But will hold fire in case TimToady++ feels different :)

[19:08] <FROGGS[mobile]> :o)

[19:08] <FROGGS[mobile]> rindolf: supper'sup

[19:08] <FROGGS[mobile]> almost at least 

[19:09] <rindolf> FROGGS[mobile]: bon appetit.

[19:10] <FROGGS[mobile]> thanks :o)

[19:11] <TimToady> jnthn: we can get rid of it

[19:13] <jnthn> TimToady: Will do :)

[19:15] <dalek> specs: bab6c34 | jnthn++ | S11-modules.pod:

[19:15] <dalek> specs: Remove language on auto-export of protos.

[19:15] <dalek> specs: 

[19:15] <dalek> specs: It probably made more sense before we settled on lexical scoping for

[19:15] <dalek> specs: resolving routine calls and `my` as the default routine scope. Today,

[19:15] <dalek> specs: less so.

[19:15] <dalek> specs: review: https://github.com/perl6/specs/commit/bab6c34833

[19:16] *** yqt joined
[19:18] *** timbunce_ left
[19:19] <FROGGS[mobile]> language?

[19:19] *** CurtisOvidPoe joined
[19:19] *** CurtisOvidPoe is now known as CurtisPoe

[19:19] <CurtisPoe> p6: class Point { has Rat $.x; has Rat $.y }; my $p = Point.new(x => 5.0,y => 3.0); say $p.x

[19:19] <camelia> rakudo-moar 397063: OUTPUT«5␤»

[19:20] <rindolf> So my rakudobrew solution to that Project Euler problem used to run in under a second, and after the latest rakudobrew update it started running at 1.2s.

[19:20] <CurtisPoe> Question: if I must pass “5.0” instead of “5” for the Rat, why does it print a value it can’t accept?

[19:21] <CurtisPoe> A clearer example:

[19:21] <CurtisPoe> p6: my Rat $x = 5.0; print $x

[19:21] <camelia> rakudo-moar 397063: OUTPUT«5»

[19:22] <CurtisPoe> p6: my Rat $x = 5; print $x; # boom

[19:22] <camelia> rakudo-moar 397063: OUTPUT«Type check failed in assignment to '$x'; expected 'Rat' but got 'Int'␤  in block <unit> at /tmp/tmpfile:1␤␤»

[19:22] <pink_mist> p6: print my Rat $x = 5.0; #shorter example

[19:22] <camelia> rakudo-moar 397063: OUTPUT«5»

[19:22] <pink_mist> anyway, I'd guess it's because that's how it stringifies

[19:22] <FROGGS[mobile]> because .Str is not .perl

[19:23] <FROGGS[mobile]> it is not meant to roundtrip

[19:23] *** timbunce_ joined
[19:24] <CurtisPoe> I know it’s  not meant to round-trip, but it seems odd that we now display to people values that we cannot use in the program.

[19:24] *** domidumont left
[19:24] *** fling left
[19:25] <jnthn> Do you expect us strings to not need quoting too?

[19:25] <jnthn> s/us//

[19:25] <CurtisPoe> jnthn: The quotes aren’t part of the string :)

[19:26] <CurtisPoe> Since Int/1 is guaranteed to always hold true, I was arguing that having ‘my Rat $foo = 3’ be allowed. Most did not agree, but seeing that “disallowed

[19:26] <CurtisPoe> But seeing that “disallowed” value in the output was odd.

[19:27] *** pullphinger joined
[19:27] <jnthn> Heh, fine, if you can argue that then I can argue that the .0 isn't part of the value, and also just needed to make it clear we're writing a Rat literal :P

[19:27] <FROGGS[mobile]> stringifying something is very much known to be a lossy transformation

[19:27] <CurtisPoe> If we’re going to be consistent, it seems like Rats should stringify to have a decimal place.

[19:29] <FROGGS[mobile]> how does this apply to other things, say, a Match?

[19:33] <skids> m: now.Str.say;

[19:33] <camelia> rakudo-moar f2488e: OUTPUT«Instant:1443036825.257303␤»

[19:33] <skids> m: Instant:⏏1443036775.442184;

[19:33] <camelia> rakudo-moar f2488e: OUTPUT«5===SORRY!5=== Error while compiling /tmp/z8taWeCKdI␤Confused␤at /tmp/z8taWeCKdI:1␤------> 3Instant:7⏏5⏏1443036775.442184;␤    expecting any of:␤        colon pair␤»

[19:33] <skids> m: Instant:1443036775.442184;

[19:33] <camelia> rakudo-moar f2488e: OUTPUT«5===SORRY!5=== Error while compiling /tmp/TGvoTYusAZ␤Confused␤at /tmp/TGvoTYusAZ:1␤------> 3Instant:7⏏051443036775.442184;␤    expecting any of:␤        colon pair␤»

[19:35] *** rurban joined
[19:43] *** rindolf left
[19:54] *** [particle] joined
[19:59] <[Coke]> m: my Rat $x = 5.0; say $x.perl;

[19:59] <camelia> rakudo-moar f2488e: OUTPUT«5.0␤»

[19:59] <[Coke]> ^^ that is expected to roundtrip.

[20:00] <[Coke]> .gist is not.

[20:00] <[Coke]> m: my $a = (1..10023423).flat; say $a.perl;

[20:01] <[Coke]> m: my $a = (1..1002).flat; say $a.perl;

[20:01] <camelia> rakudo-moar f2488e: OUTPUT«(timeout)»

[20:01] <camelia> rakudo-moar f2488e: OUTPUT«(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, …»

[20:01] <[Coke]> gist is, for better or worse, lossy.

[20:02] *** darutoko left
[20:02] <[Coke]> (btw, CurtisPoe, I agree with your request - Rats should be able to take literal Ints and DTRT. I was hoping masak could explain -why- the type system ended up in a way that didn't let that happen, but I'm not sure that ever came through.)

[20:03] *** larion joined
[20:04] *** espadrine joined
[20:04] <TimToady> but as for print round trippng, that's what .perl is for

[20:04] <TimToady> m: say 5.0.perl

[20:04] <camelia> rakudo-moar f2488e: OUTPUT«5.0␤»

[20:04] <TimToady> notice that one puts the .0

[20:05] <CurtisPoe> Thanks, Coke. I never did here a counter-example of why ‘my Rat $foo = 2’ is bad. There was discussion about performance in hot code, but that was the only convincing argument (to me) :)

[20:06] <TimToady> we might be able to intuit a Rat() type rather than a Rat type, but we don't even implement Rat() there on assignment yet, and that's considered post 6.0 anyway

[20:07] <TimToady> unless someone who is not jnthn sneaks in an implements coercive assignment :)

[20:08] <jnthn> It's not a performance thing. I need to go sleep, but I can probably explain 3 or 4 ways we could make `my Rat $x = 3` "work", and why they all make things worse than the status quo, and thus why things won't be chaning.

[20:08] <jnthn> But...tomorrow... 'night

[20:08] <TimToady> o/

[20:09] <TimToady> speaking of which, never et lunch... &

[20:11] <CurtisPoe> ‘night jnthn

[20:12] <zacts> CurtisPoe: are you ovid?

[20:12] <zacts> or an ovid wannabe? :-P

[20:12] <zacts> if you are ovid, I like your beginning perl book.

[20:12] <CurtisPoe> Yes, I’m Ovid :)

[20:12] <zacts> coolio! :-)

[20:12] <CurtisPoe> But that nick is apparently taken.

[20:12] <zacts> ah I see

[20:13] <zacts> anyway, cool. I can't wait for this hopeful release of Perl 6 this winter

[20:14] *** colomon left
[20:16] *** patrickz left
[20:17] <CurtisPoe> Quick question: if you had to name the top 3 benefits the average programmer will get from Perl 6, what would it be? (I think subsets, the OO model, and working concurrency in a dynamic language (though the latter might not be for the average programmer))

[20:18] *** espadrine left
[20:19] <lizmat> CurtisPoe: remember that concurrency may be hidden in junctions and >> hypers

[20:19] <lizmat> so average programmers may be using concurrency (I should say: async features) without knowing it

[20:21] <pink_mist> what about perl6's infinite list features?

[20:26] * vendethiel today learned that "F[2;3]" worked in APL

[20:26] <vendethiel> they didn't use * tho, only M[;3] if they wanted to skip the 1st one :P

[20:27] <dalek> ecosystem: e6f1f9a | Carlin++ | META.list:

[20:27] <dalek> ecosystem: Add UNIX::Privileges

[20:27] <dalek> ecosystem: review: https://github.com/perl6/ecosystem/commit/e6f1f9a4ff

[20:31] *** colomon joined
[20:39] *** FROGGS[mobile] left
[20:40] *** larion left
[20:40] *** kaare_ left
[20:41] *** sufrostico left
[20:50] *** pullphinger left
[20:54] *** xfix left
[20:54] <[Coke]> CurtisPoe: yah, Coke was also taken. :P

[20:55] *** thou left
[20:55] *** carlin joined
[20:55] <CurtisPoe> That sentence, out of context, makes Perl 6 hackers seem dangerous :)

[20:55] * [Coke] wonders if there's anythign to rescue from his APL grammar on parrot.

[20:55] *** colomon left
[20:56] *** colomon joined
[20:56] <cognominal> CurtisPoe: you forgot first class Unicode support with NFG.  Also, grammars bring in the support of OO for regexen. This gives a new dimension to the motto : only perl can parse Perl because the lexer and parser are written in Perl. Perl 6 brings string handling to a higher level, leapfrogging all the languages that have copied Perl 5.

[20:57] <carlin> m: my $x = now; EVAL($x.perl)

[20:57] <camelia> rakudo-moar f2488e: OUTPUT«===SORRY!===␤Cannot find method 'compile_time_value'␤»

[20:57] <carlin> m: my $x = now; say $x.perl

[20:57] <camelia> rakudo-moar f2488e: OUTPUT«Instant.new(<1176079147668/815>)␤»

[20:57] <cognominal> rubyists are dangerous too with their rails.

[20:57] *** skids left
[20:57] <carlin> m: <1176079147668/815>

[20:57] <camelia> rakudo-moar f2488e: OUTPUT«===SORRY!===␤Cannot find method 'compile_time_value'␤»

[20:58] *** _sri joined
[20:58] <carlin> Is that known? (or somehow expected?)

[20:59] *** khw left
[20:59] <[Coke]> not expected.

[21:00] <[Coke]> please open a ticket via [email@hidden.address]
[21:00] *** _sri left
[21:00] *** _sri joined
[21:00] * [Coke] commutes

[21:01] *** _sri left
[21:01] *** _sri joined
[21:02] *** larion joined
[21:03] <psch> m: <2147483647/8>

[21:03] <camelia> rakudo-moar f2488e: ( no output )

[21:03] <psch> m: <2147483648/8>

[21:03] <camelia> rakudo-moar f2488e: OUTPUT«===SORRY!===␤Cannot find method 'compile_time_value'␤»

[21:04] <psch> carlin: did you rakudobug that yet?

[21:04] <psch> apparently not, according to "sort by created"

[21:05] <carlin> psch: working on it now

[21:05] *** _sri left
[21:05] <psch> carlin: ahh, alright, i'll abort then

[21:05] *** _sri joined
[21:05] <psch> carlin: i suspect 2**31 - 1 working and 2**31 not is a hint :)

[21:06] <lizmat> .tell jnthn should the COMPOSE phaser be in nope or not?

[21:06] <yoleaux> lizmat: I'll pass your message to jnthn.

[21:06] *** _sri left
[21:06] *** _sri joined
[21:07] *** _sri left
[21:07] *** _sri joined
[21:07] <lizmat> .tell jnthn or maybe some way to export something into a class that will get run when a class is "finalized" at compile time

[21:07] <yoleaux> lizmat: I'll pass your message to jnthn.

[21:08] *** adu left
[21:09] <lizmat> .tell jnthn thinking about something like class A is reaped {} to make objects run their DESTROY at global destruction

[21:09] <yoleaux> lizmat: I'll pass your message to jnthn.

[21:09] *** _sri left
[21:11] <psch> # Looks like you planned 93 tests, but ran 45

[21:11] <psch> # Looks like you failed 7 tests of 45

[21:11] <psch> that's it for today for allomorphic.t 

[21:12] <psch> i'm gonna push getBI/makeBI, cause the rest seems to come from somewhere else...

[21:15] <carlin> bug sent, including psch++'s hint

[21:15] *** colomon left
[21:15] *** apotheon joined
[21:15] <apotheon> CurtisPoe: Hi.

[21:18] * apotheon waits to see if CurtisPoe even remembers him.

[21:21] <dalek> nqp: 97a0490 | peschwa++ | src/vm/jvm/runtime/org/perl6/nqp/runtime/Ops.java:

[21:21] <dalek> nqp: Fix a comment.

[21:21] <dalek> nqp: review: https://github.com/perl6/nqp/commit/97a0490052

[21:21] <dalek> nqp: 7190914 | peschwa++ | src/vm/jvm/runtime/org/perl6/nqp/ (2 files):

[21:21] <dalek> nqp: Fix getBI and makeBI again, differently this time.

[21:21] <dalek> nqp: 

[21:21] <dalek> nqp: For Rakudos IntStr, we have to rely on the target type to get the right

[21:21] <dalek> nqp: unboxIntSlot, because for some reason the LHS already comes with the same REPR

[21:21] <dalek> nqp: but different REPRData. It works for now, but I can imagine cases where it

[21:21] <dalek> nqp: would stop working - I'm not sure how likely these cases are to occur, though.

[21:21] <dalek> nqp: review: https://github.com/perl6/nqp/commit/7190914a19

[21:24] *** travis-ci joined
[21:25] <travis-ci> NQP build failed. Pepe Schwarz 'Fix getBI and makeBI again, differently this time.

[21:25] <travis-ci> https://travis-ci.org/perl6/nqp/builds/81859185 https://github.com/perl6/nqp/compare/bf1d2ad74abb...7190914a1985

[21:25] *** travis-ci left
[21:25] *** rurban left
[21:25] * psch sighs

[21:25] *** timbunce_ left
[21:25] <psch> travis, you don't even build nqp-j

[21:26] *** ennio joined
[21:26] *** rurban joined
[21:27] *** rurban left
[21:28] *** rurban joined
[21:29] <dalek> rakudo/nom: 1247986 | peschwa++ | tools/build/NQP_REVISION:

[21:29] <dalek> rakudo/nom: Bump NQP_REVISION

[21:29] <dalek> rakudo/nom: 

[21:29] <dalek> rakudo/nom: Get a probably durable enough implementation of getBI and makeBI for IntStr.

[21:29] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/12479862b2

[21:29] <psch> it keeps happening though

[21:29] <psch> all the last few times i pushed an nqp commit travis complained /o\

[21:30] *** TEttinger joined
[21:31] *** timbunce_ joined
[21:33] <Zefram_Fysh> carlin: your bug is already in RT as [perl #126103]

[21:34] <synbot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=126103

[21:35] *** colomon joined
[21:38] *** pmurias left
[21:40] *** khw joined
[21:49] *** patrickz joined
[21:49] <Zefram_Fysh> there are a couple of followups to RT tickets that I've sent to [email@hidden.address] (replying to messages from RT) and they haven't shown up in RT.  followups that I send manually to [email@hidden.address] do show up.  are the followups to the former address lost, or merely being delayed?

[21:51] <lizmat> my replies to [email@hidden.address] arrive back at the mailing list, so I would expect to see them at some point

[21:53] *** spider-mario left
[21:53] <Zefram_Fysh> do they show up in the RT web interface too?

[21:54] <lizmat> afaik they do

[21:54] * Zefram_Fysh will wait a bit then

[21:55] *** carlin left
[21:56] *** espadrine joined
[22:02] *** Grrrr left
[22:02] *** Grrrr joined
[22:03] *** felher left
[22:04] *** psch left
[22:04] *** TimToady left
[22:04] *** psch joined
[22:05] *** felher joined
[22:06] *** TimToady joined
[22:08] <dalek> rakudo/nom: 747c69f | lizmat++ | src/core/Any-iterable-methods.pm:

[22:08] <dalek> rakudo/nom: Make .squish()/.squish(:with) about 2.5x faster

[22:08] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/747c69f0ff

[22:08] *** cognominal left
[22:09] *** larion left
[22:09] *** ennio left
[22:10] *** espadrine left
[22:16] *** larion joined
[22:19] *** colomon left
[22:19] *** colomon joined
[22:24] *** Sqirrel_ left
[22:26] *** hernanGOA left
[22:27] *** skids joined
[22:31] *** RabidGravy left
[22:31] *** kid51 joined
[22:39] *** vendethiel left
[22:41] *** dnmfarrell joined
[22:45] *** AlexDaniel left
[22:51] *** adu joined
[22:54] <dnmfarrell> does Perl 6 have an equivalent of P5's "select"? I'm thinking for checking whether a socket will block or not when read

[22:58] <pink_mist> why not do it async instead? attach a Supply and whenever it

[22:58] <dnmfarrell> ah well because I want to build a multiplexer :)

[22:59] <pink_mist> no need, that's already in the language =)

[22:59] <pink_mist> dnmfarrell: https://www.youtube.com/watch?v=JpqnNCx7wVY please see this excellent talk on the topic by jnthn++

[23:01] <dnmfarrell> thanks for the link, is there a particular part of that talk that discusses multiplexing? I don't want to watch an hour long video if possible

[23:02] <dalek> roast: 4841832 | thundergnat++ | S06-advanced/return.t:

[23:02] <dalek> roast: Add tests for RT #126049, remove faulty test that didn't catch it.

[23:02] <dalek> roast: 

[23:02] <dalek> roast: Add tests for RT #126049. Remove faulty test. String comparison on arrays with empty elements leads to tears... or bugs, at least.

[23:02] <dalek> roast: review: https://github.com/perl6/roast/commit/484183258b

[23:02] <synbot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=126049

[23:02] <pink_mist> I ... would haveto rewatch it myself to be able to say :P

[23:02] <pink_mist> and that'd take an hour :P

[23:03] <lizmat> https://6guts.wordpress.com/2015/09/23/updates/   # jnthn++

[23:04] *** patrickz left
[23:07] * geekosaur would appreciate language materials that are not videos, btw

[23:07] <dalek> rakudo/nom: 88c191b | lizmat++ | src/core/Any-iterable-methods.pm:

[23:07] <dalek> rakudo/nom: Make .squish(:as)/squish(:as,:with) 1.5..2x faster

[23:07] <dalek> rakudo/nom: 

[23:07] <dalek> rakudo/nom: The fact that for each value, a block needs to be called, dampens the

[23:07] <dalek> rakudo/nom: optimization fun here.

[23:07] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/88c191bdbb

[23:07] <geekosaur> (Being that videos and I are increasingly incompatible)

[23:08] <pink_mist> geekosaur: well there are the excellent slides for that talk too =)

[23:08] * lizmat would appreciate finding people willing to make such materials

[23:08] <pink_mist> geekosaur: you can find them on the link lizmat++ posted =)

[23:08] * lizmat goes to bed

[23:08] <lizmat> so good night, #perl6!

[23:09] <pink_mist> goog night, lizmat

[23:15] *** Peter_R left
[23:16] *** adu left
[23:17] *** mattprelude joined
[23:35] *** araujo_ joined
[23:35] *** leont left
[23:36] *** araujo left
[23:37] *** silug left
[23:38] *** adu joined
[23:45] *** diana_olhovik left
[23:50] <pink_mist> dnmfarrell: alright, so it's basically from the 18 minute mark until a few minutes before the 40 minute mark

[23:50] *** adu left
[23:51] <dnmfarrell> pink_mist: I'm at 41:57 right now :D

[23:51] <pink_mist> haha alright :P

[23:52] *** BenGoldberg joined
[23:52] <pink_mist> hope it was enlightening =)

[23:52] *** telex left
[23:52] <dnmfarrell> Yeah I'm enjoying it! But ... here's the issue: if you try to read from a socket and it's empty, it blocks. So what I want is way to check socket before I read from it. I'm not sure this helps with that problem.

[23:53] *** silug joined
[23:53] <dnmfarrell> Or maybe I'm not thinking about it in the right way

[23:54] *** telex joined
[23:54] <geekosaur> async lets you have a bunch of threads that block on reads but collect their output as it becomes available?

[23:55] <geekosaur> this is how most languages that aren't C or Perl5 handle it

[23:55] <pink_mist> http://doc.perl6.org/type/IO::Socket::Async have a look at this maybe?

[23:58] <dnmfarrell> pink_mist: thanks, I'd overlooked that

