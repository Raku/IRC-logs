[00:28] *** gfldex left
[00:31] *** geekosaur left
[00:32] *** Ben_Goldberg joined
[00:32] *** geekosaur joined
[00:35] *** cognominal_ joined
[00:37] *** cognominal left
[00:46] *** tinyblak joined
[00:51] <dalek> rakudo/nom: da530e3 | labster++ | src/core/Temporal.pm:

[00:51] <dalek> rakudo/nom: Time zone changes now preserve fractional seconds

[00:51] <dalek> rakudo/nom: 

[00:51] <dalek> rakudo/nom: Also get rid of some supersticious use of float() and .Int, use int div.

[00:51] <dalek> rakudo/nom: Now 3% faster DateTime.now() ... still kinda slow.

[00:51] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/da530e3049

[00:56] <timotimo> labster: thanks for working on this :)

[00:56] <timotimo> m: say now

[00:56] <camelia> rakudo-moar 6e425f: OUTPUT«Instant:1436230654.277332␤»

[00:57] <timotimo> does this also get faster, out of curiosity?

[01:09] *** smls left
[01:12] *** rmgk left
[01:14] *** vendethiel left
[01:15] *** rmgk joined
[01:30] *** vendethiel joined
[01:32] *** kanl joined
[01:34] <labster> timotimo: no, just the DateTime object, because it does time zone conversion

[01:36] *** dayangkun joined
[01:43] <timotimo> OK

[01:46] <timotimo> still a good thing to improve, of course!

[02:02] *** kaare_ joined
[02:04] <dalek> roast: ee637c4 | skids++ | S06-signature/introspection.t:

[02:04] <dalek> roast: Add idempotency tests for .perl of Signatures with anonymous parameters

[02:04] <dalek> roast: review: https://github.com/perl6/roast/commit/ee637c4814

[02:19] *** noganex_ joined
[02:21] *** nys left
[02:22] *** noganex left
[02:27] *** aborazmeh joined
[02:27] *** aborazmeh left
[02:27] *** aborazmeh joined
[02:41] *** aborazmeh left
[02:43] *** aborazmeh joined
[02:43] *** aborazmeh left
[02:43] *** aborazmeh joined
[02:48] *** lsm-desktop left
[02:49] *** dayangkun left
[02:55] <kanl> m: say [||] ( True, False ) ?? 'a' !! 'b'; say [&&] ( True, False ) ?? 'a' !! 'b';

[02:55] <camelia> rakudo-moar da530e: OUTPUT«a␤a␤»

[02:55] * kanl blinks

[02:59] *** dayangkun joined
[02:59] <ShimmerFairy> m: say [||] ( True, False ) ?? 'a' !! 'b'; say ([&&] ( True, False )) ?? 'a' !! 'b';

[02:59] <camelia> rakudo-moar da530e: OUTPUT«a␤b␤»

[03:00] <kanl> why [||] need not be quoted?

[03:00] <ShimmerFairy> The conditional was checking the truth value of the list (that is, ?(True, False) ),

[03:00] <ShimmerFairy> m: say [||] (False, False) ?? 'a' !! 'b'

[03:00] <camelia> rakudo-moar da530e: OUTPUT«a␤»

[03:00] *** lsm-desktop joined
[03:00] <ShimmerFairy> m: say ([||] (False, False)) ?? 'a' !! 'b'

[03:00] <camelia> rakudo-moar da530e: OUTPUT«b␤»

[03:01] <ShimmerFairy> the [||] needs to be in parens too, you just got lucky with the list you were using :)

[03:02] <kanl> how is it parsed in the case when i was lucky?

[03:02] <kanl> i'd expect it to say True/False instead of any varieties of 'a', 'b'

[03:04] <kanl> ah, ic. [] has the lowest precedence, apparently.

[03:05] <kanl> so [&&] on 'a'/'b' would get 'a'/'b'

[03:05] <leont> Reduction operators are list operators, they have very low precedence

[03:06] <kanl> ( True, False ) of course, evaluate to True, being not empty. 

[03:06] <kanl> thanks!

[03:07] <kanl> it's probably one of those best-practices things, new operators increase potential for misuse :)

[03:10] <leont> It's the same in perl5 really

[03:11] <kanl> i'm not familiar with this feature in p5. 

[03:11] <leont> It doesn't have reduction operators, but it does have list operators

[03:15] <kanl> leont: such as? ( i honestly am not familiar with any list ops in p5, other than things like splice et-al. :)

[03:16] <Ben_Goldberg> m: sau ?(False, False)

[03:16] <camelia> rakudo-moar da530e: OUTPUT«5===SORRY!5=== Error while compiling /tmp/aXgwRH9o2A␤Undeclared routine:␤    sau used at line 1. Did you mean 'say'?␤␤»

[03:16] <Ben_Goldberg> m: say ?(False, False)

[03:16] <camelia> rakudo-moar da530e: OUTPUT«True␤»

[03:16] <Ben_Goldberg> m: say ?(False)

[03:16] <camelia> rakudo-moar da530e: OUTPUT«False␤»

[03:16] <kanl> m: say ?(False,)

[03:16] <camelia> rakudo-moar da530e: OUTPUT«True␤»

[03:16] <Ben_Goldberg> kanl, You read my mind!  I was about to type that :)

[03:18] *** leont left
[03:20] <labster> m: say ([&&] True, False) ?? 'a' !! 'b'; # don't need the inner parens, commas make a List

[03:20] <camelia> rakudo-moar da530e: OUTPUT«b␤»

[03:21] <kanl> old p5 habits die hard :p

[03:24] <dalek> rakudo/nom: d524b22 | (Nick Logan)++ | src/core/IO/Path.pm:

[03:24] <dalek> rakudo/nom: bugfix: chdir ensure `.` is resolved to abspath

[03:24] <dalek> rakudo/nom: 

[03:24] <dalek> rakudo/nom: Fixes:

[03:24] <dalek> rakudo/nom: 

[03:24] <dalek> rakudo/nom:     nickl@localhost:~/perl6$ perl6 -e 'say ".".IO.chdir("rakudo/t").IO.perl.say'

[03:24] <dalek> rakudo/nom:     Failed to change the working directory to '/rakudo/t': does not exist

[03:24] <dalek> rakudo/nom: 

[03:24] <dalek> rakudo/nom: This also addresses windows behavior where the volume would become lost.

[03:24] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/d524b22aaa

[03:24] <dalek> rakudo/nom: f0816d3 | lizmat++ | src/core/IO/Path.pm:

[03:24] <dalek> rakudo/nom: Merge pull request #462 from ugexe/patch-9

[03:24] <dalek> rakudo/nom: 

[03:24] <dalek> rakudo/nom: bugfix: chdir ensure `.` is resolved to abspath

[03:24] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/f0816d3479

[03:36] *** Ben_Goldberg left
[03:39] *** amurf left
[03:54] <dalek> roast: 961c60f | lizmat++ | S32-temporal/DateTime.t:

[03:54] <dalek> roast: Unfudge now passing test, labster++

[03:54] <dalek> roast: review: https://github.com/perl6/roast/commit/961c60f5ba

[03:56] *** dj_goku left
[04:13] *** dj_goku joined
[04:22] *** davido__ left
[04:22] *** mr-foobar left
[04:23] *** davido__ joined
[04:24] *** amurf joined
[04:29] *** davido___ joined
[04:32] *** davido__ left
[04:32] <dalek> rakudo/nom: f5ebbf4 | skids++ | src/core/Block.pm:

[04:32] <dalek> rakudo/nom:   .assuming now produces closures with populated signatures.

[04:32] <dalek> rakudo/nom:   ... (fixes RT#78240/RT#77744 noting that 2 tests in RT#77744 are

[04:32] <dalek> rakudo/nom:   ...  outdated due to trying to use named parameters to fill positionals)

[04:32] <dalek> rakudo/nom:   .assuming now supports * and Nil primers with special behaviors.

[04:32] <dalek> rakudo/nom:   .assuming will try to bind primer arguments to a partial signature:

[04:32] <dalek> rakudo/nom:   ... currently it will mix most failures into the returned closure.

[04:32] <synbot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=78240

[04:32] <dalek> rakudo/nom:   ... eventually we can phase-in throwing them instead.

[04:32] <dalek> rakudo/nom:   For now, subsignatures are mostly ignored during this bind.

[04:32] <dalek> rakudo/nom:   For now, constraints pointing to captured types are stripped.

[04:32] <dalek> rakudo/nom:   Where clauses and default value exprs are not evaluated until runtime invoke.

[04:32] <dalek> rakudo/nom:   This currently uses EVAL to construct the closure, which is LTA,

[04:32] <dalek> rakudo/nom:   but it gives us something functional/testable to work forward from.

[04:32] <dalek> rakudo/nom:   Roast tests available at https://github.com/skids/roast/tree/assuming

[04:32] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/f5ebbf480c

[04:32] <dalek> rakudo/nom: 072d691 | lizmat++ | src/core/Block.pm:

[04:32] <dalek> rakudo/nom: Merge pull request #463 from skids/assuming

[04:32] <dalek> rakudo/nom: 

[04:32] <dalek> rakudo/nom:   .assuming now produces closures with populated signatures.

[04:32] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/072d691c43

[04:33] <skids> Thanks, lizmat++

[04:34] <dalek> rakudo/nom: 07a05cd | lizmat++ | src/core/Exception.pm:

[04:34] <dalek> rakudo/nom: Add latest P5 worries as exceptions

[04:34] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/07a05cd181

[04:34] <dalek> rakudo/nom: 369ec75 | lizmat++ | src/core/Exception.pm:

[04:34] <dalek> rakudo/nom: Hmmm...  apparently we can't heredoc in the core

[04:34] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/369ec75e43

[04:34] <dalek> rakudo/nom: 47d1ed6 | lizmat++ | src/Perl6/Grammar.nqp:

[04:34] <dalek> rakudo/nom: Make P5 reference worries typed

[04:34] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/47d1ed6ae2

[04:34] <lizmat> skids: yw

[04:36] *** Dee22 joined
[04:39] *** VinceDee left
[04:49] *** khw left
[04:52] <dalek> rakudo/nom: a891f98 | lizmat++ | src/ (2 files):

[04:52] <dalek> rakudo/nom: Make 0234 octal warning a typed exception

[04:52] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/a891f98d49

[04:53] <ugexe> zef can now bootstrap itself from source and install modules on windows/linux and moar/jvm :D https://gist.github.com/ugexe/2a2d4a2654dea9b253a2

[04:53] * skids wonders how long to wait to push/unskip/unfudge spectests so as not to catch any autobuilds without the new .assuming code.

[04:55] <lizmat> anybody smoking spectests is assumed to get the latest code

[04:56] <lizmat> so it should be safe now, I think

[04:57] <dalek> roast: a19359e | skids++ | S06-currying/named.t:

[04:57] <dalek> roast: Tests for new .assuming implementation

[04:57] <dalek> roast: review: https://github.com/perl6/roast/commit/a19359e5f7

[04:57] <dalek> roast: d97da19 | skids++ | S06-currying/ (2 files):

[04:57] <dalek> roast: Unfudge/unskip passing JVM tests

[04:57] <dalek> roast: review: https://github.com/perl6/roast/commit/d97da19525

[04:57] * lizmat runs a spectest

[05:02] <lizmat> $ perl6 t/spec/S06-currying/named.t

[05:02] <lizmat> ===SORRY!===

[05:02] <lizmat> Could not find Test::Assuming in any of:

[05:03] <lizmat> skids: could it be you forgot to add Test::Assuming ?

[05:04] <lizmat> hmm... it also seems to cause t/spec/S17-supply/classify.t to hang

[05:04] <lizmat> hmmm.. flapper

[05:05] <skids> Oh doh I screwed that commit up.  Forgot to add after patching my main tree.

[05:05] <lizmat> please PR, and I'll merge

[05:06] *** leont joined
[05:06] <skids> Rather than just push them?

[05:06] <lizmat> ah, well, if you can push, then push!

[05:07] <dalek> roast: 216231d | skids++ | / (4 files):

[05:07] <dalek> roast: Add forgotten files for .assuming tests

[05:07] <dalek> roast: review: https://github.com/perl6/roast/commit/216231dde6

[05:07] * lizmat runs another spectest

[05:07] <skids> Wow JVM spectest takes time.

[05:08] <lizmat> yeah :-(

[05:08] *** diana_olhovik_ joined
[05:10] <skids> At least S06 is towards the top :-)

[05:13] *** atroxaper joined
[05:14] <dalek> roast: ab80106 | lizmat++ | S06-currying/named.t:

[05:14] <dalek> roast: Add missing 'use lib'

[05:14] <dalek> roast: review: https://github.com/perl6/roast/commit/ab80106073

[05:14] <lizmat> skids:  after adding ^^, I get:

[05:14] <lizmat> t/spec/S06-currying/named.rakudo.moar (Wstat: 768 Tests: 27 Failed: 3)

[05:14] <lizmat>   Failed tests:  4, 21, 27

[05:14] <lizmat>   TODO passed:   5, 22

[05:19] <skids> Hrm those should be fudged.

[05:19] <lizmat> even after that fix, I see all of the S17-supply tests flapping, and worse, hanging when they flap

[05:19] <skids> I don't think .assuming is used anywhere in core.

[05:20] <lizmat> I think the EVAL is somehow interacting badly 

[05:20] <lizmat> true

[05:20] <lizmat> but still, empirically, I see this

[05:21] <lizmat> let me revert your patch (locally) and make sure it's not one of the things I just did this morning

[05:22] * skids wonders why his "todo"s don't work in named.t

[05:27] <lizmat> no flappers with your patch reverted  :-(

[05:27] *** diana_olhovik_ left
[05:27] <skids> Hrm.

[05:27] <lizmat> how about we give it a day and hope jnthn will be able to shed a light as to why your patch has this effect ?

[05:28] <skids> Yeah.  I'm up too late yet again.

[05:29] <skids> Is a new moarvm invoked for each test file?

[05:29] *** tinyblak left
[05:30] <lizmat> yes, afaik

[05:30] <lizmat> judging from top and the hanging tests, I'm quite sure  :-)

[05:30] <skids> Soo how the heck... well it's not like I've never seen code work just because I moved something else around.

[05:31] * skids wonders if anyone can wider-ecosystem-grep to see how much .assuming use is out there.

[05:32] <lizmat> perhaps someone will as they wake up

[05:32] * lizmat is just up early to ventilate the house before another hot day

[05:35] <lizmat> .tell jnthn Could you have a look as to why f5ebbf480c5936 is causing S17-supply hangs

[05:35] <yoleaux> lizmat: I'll pass your message to jnthn.

[05:36] <skids> Yeah my housemate goes crazy with the box fans about this time of night.

[05:36] *** tinyblak joined
[05:36] <skids> Probably using more wattage than an AC would.

[05:37] <lizmat> only using natural ventilation here (open all of the possible windows *wide*)

[05:38] <skids> Anyhow I hate to leave breakage in my wake, but my "wake" is waning fast.

[05:40] <lizmat> don't worry about it...

[05:40] <lizmat> mind if I try some things in the mean time ?

[05:41] <skids> No go right ahead.  I've got nothing related pending.

[05:41] <skids> good n8, thanks for the help again

[05:41] *** spollei left
[05:41] <lizmat> yw, sleep well!

[05:42] <dalek> rakudo/nom: eaee44f | lizmat++ | src/Perl6/Grammar.nqp:

[05:42] <dalek> rakudo/nom: Seems we don't need worryobs anymore

[05:42] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/eaee44f812

[05:45] *** skids left
[05:58] <dalek> rakudo/nom: 0585860 | lizmat++ | src/core/Block.pm:

[05:58] <dalek> rakudo/nom: Return more gently

[05:58] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/058586052a

[05:58] <dalek> rakudo/nom: cbff68a | lizmat++ | src/core/Block.pm:

[05:58] <dalek> rakudo/nom: Change $s.substr(0,..) eq $f to $s.starts-with($f)

[05:58] <dalek> rakudo/nom: 

[05:58] <dalek> rakudo/nom: Oddly enough, this change seems to fix the hanging S17-supply tests!

[05:58] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/cbff68a64d

[06:04] <lizmat> .tell jnthn empirically, cbff68a fixes the hanging S17-supply tests

[06:04] <yoleaux> lizmat: I'll pass your message to jnthn.

[06:04] *** diana_olhovik_ joined
[06:12] *** mr-foobar joined
[06:27] *** FROGGS joined
[06:30] *** atroxaper left
[06:31] *** RabidGravy joined
[06:33] *** atroxaper joined
[06:44] *** abraxxa joined
[06:44] *** xinming left
[06:46] *** brrt joined
[06:50] *** domidumont joined
[06:50] *** quester joined
[06:54] *** domidumont left
[06:54] *** domidumont joined
[07:00] *** espadrine_ joined
[07:11] *** darutoko joined
[07:11] *** xinming joined
[07:21] *** g4 joined
[07:21] *** g4 left
[07:21] *** g4 joined
[07:21] <nine> That's odd:

[07:21] <nine> m: say [{a => 1}][0].perl; say [{a => 1}, {a => 2}]>>.perl

[07:21] <camelia> rakudo-moar cbff68: OUTPUT«{:a(1)}␤a => 1 a => 2␤»

[07:22] <nine> Why is >>.perl giving me something different than .perl on individual elements?

[07:23] <moritz> nine: because >> descends into hashes

[07:24] <nine> m: say [{a => 1}, {a => 2}].map: *.perl

[07:24] <camelia> rakudo-moar cbff68: OUTPUT«{:a(1)} {:a(2)}␤»

[07:24] <lizmat> m: (a=>1).perl.say

[07:24] <camelia> rakudo-moar cbff68: OUTPUT«:a(1)␤»

[07:24] <nine> So there is a difference between map and >>

[07:25] <moritz> yes

[07:25] <lizmat> m: say [<a b>]>>.WHAT.say

[07:25] <camelia> rakudo-moar cbff68: OUTPUT«(Array)␤True␤»

[07:25] <lizmat> m: say [<a b>]>>.WHAT.elems.say

[07:25] <camelia> rakudo-moar cbff68: OUTPUT«0␤True␤»

[07:25] <lizmat> m: say [<a b>]>>.elems.say

[07:25] <camelia> rakudo-moar cbff68: OUTPUT«1 1␤True␤»

[07:26] * lizmat should wak up

[07:26] <El_Che> lizmat: wake up or you'll miss Christmas!

[07:26] <lizmat> getting up at 5am is not my cuppa tea

[07:28] <nine> lizmat: still so hot up there?

[07:28] <RabidGravy> marnin!

[07:29] <lizmat> nine: high of 31C / 88F expected again

[07:29] <moritz> we expect more like 36C

[07:30] *** quester left
[07:31] <El_Che> lizmat: where are you now?

[07:31] <lizmat> at home  :-)

[07:31] <El_Che> exotic limburg :)

[07:32] <lizmat> RabidGravy o/

[07:32] <RabidGravy> are we all fabulous this morning?

[07:33] <labster> super fabulous here 🌈

[07:33] <lizmat> the part of me that's awake, is fabulous

[07:33] * moritz is tinkering with continuous deployment

[07:33] <RabidGravy> most excellent!

[07:33] <moritz> fun, if a bit tedious

[07:34] <lizmat> .oO( all the time! )

[07:35] <labster> I almost have some comparison operators for DateTime, just need to write some tests.

[07:47] *** amurf left
[07:50] <DrForr> It was 37 or so yesterday afternoon.

[07:52] <moritz> yesterday was fine here (not too hot), but it was 37 to 38 on the weekend

[07:53] *** atroxaper left
[07:53] *** domidumont left
[07:57] <masak> morning, #perl6

[07:58] <moritz> 'o masak

[07:59] *** dakkar joined
[08:02] <masak> labster++ # DateTime cmp ops

[08:10] *** domidumont joined
[08:20] <masak> I discovered I needed them the other day when I was writing Real Actual Code.

[08:24] <dalek> roast: c1c25bf | lizmat++ | S02-types/WHICH.t:

[08:24] <dalek> roast: Add the X::Worry classes

[08:24] <dalek> roast: review: https://github.com/perl6/roast/commit/c1c25bf4fa

[08:24] <lizmat> afk for a few hours&

[08:25] *** virtualsue joined
[08:28] *** [TuxCM] joined
[08:32] *** rindolf joined
[08:37] *** atroxaper joined
[08:39] *** mr-fooba_ joined
[08:40] *** mr-foobar left
[08:41] *** leont left
[08:46] *** larion joined
[08:46] *** Fleurety joined
[08:47] *** aborazmeh left
[08:48] *** smls joined
[08:48] <oha> gethost() is not implemented in rakudo, right?

[08:48] *** espadrine_ left
[08:49] <smls> right

[08:50] <smls> The design docs only seem to mention this signature for 'fail':

[08:50] <smls> multi fail (Str $message)

[08:50] <smls> But Rakudo has these:

[08:50] <smls> sub fail (Exception $e)

[08:50] <smls> sub fail ($payload)

[08:50] <smls> sub fail (*@msg)

[08:50] <smls> Are those official (and should be documented on p6doc)?

[08:52] <smls> And isn't the second-to-last one redundant?

[08:54] <moritz> not quite

[08:54] <moritz> it probably doesn't stringify $payload

[08:54] <moritz> whereas the *@msg case stringifies

[08:55] <moritz> (which makes the Str case redundant)

[08:55] <moritz> but it's a nice optimization

[08:55] <moritz> I'm pretty sure fail ( Exception ) should be documented on perl6/doc

[08:55] <smls> *@msg dfoesn't stringify either for the n=1 case:  my $payload = @msg == 1 ?? @msg[0] !! @msg.join;

[08:55] <moritz> oh

[08:55] <moritz> the way I understand multi dispatch, it should never happen

[08:56] *** brrt left
[09:03] *** Dee22 left
[09:05] <labster> masak: I'm afraid time cmp ops are going to have to wait until tomorrow, my brilliant plans didn't take time zones into account :/  Incidentally, how do you feel about comparing Date to DateTime?  Might DWIM, might just be weird.

[09:06] <masak> labster: uuh

[09:06] <masak> labster: (1) just convert both DateTimes to Instant and compare those? you don't have to do the calculation yourself...

[09:07] <labster> Yes that makes more sense I realize now, but I had fun.

[09:07] <masak> labster: (2) I think we should disallow comparing Date to DateTime. even though for "most" values it makes sense, for some it doesn't.

[09:07] <masak> I'd rather people convert their DateTime to a Date, and compare that with the other Date.

[09:08] <labster> Right, so no Datish candidates then.

[09:09] <masak> main hiccup with DateTime vs Date comparisons would be when the DateTime falls within the Date. breaks transitivity.

[09:10] *** espadrine_ joined
[09:10] <masak> rather than hide the underlying complexity of that, better to force the programmer to be explicit.

[09:11] *** tinyblak left
[09:12] *** espadrine_ is now known as espadrine

[09:13] <masak> lunch &

[09:14] *** mr-fooba_ left
[09:15] *** rurban joined
[09:15] *** mr-foobar joined
[09:17] <oha> m: say v1.3 le v1.25, v1.3 cmp v1.25;

[09:17] <camelia> rakudo-moar cbff68: OUTPUT«FalseLess␤»

[09:19] <oha> is le coercing to Str, while cmp being smart?

[09:19] <moritz> yes

[09:20] <moritz> m: say v1.3 before v1.25

[09:20] <camelia> rakudo-moar cbff68: OUTPUT«True␤»

[09:20] <oha> i see now, i should use before

[09:20] <oha> right

[09:20] <oha> thanks

[09:20] <dalek> doc: ad5acd2 | smls++ | lib/Type/Exception.pod:

[09:20] <dalek> doc: Document sub fail

[09:20] <dalek> doc: review: https://github.com/perl6/doc/commit/ad5acd2efa

[09:26] *** bin_005 joined
[09:28] *** AlexDaniel joined
[09:33] *** rindolf left
[09:36] *** amurf joined
[09:37] *** brrt joined
[09:40] *** amurf left
[09:44] *** tinyblak joined
[09:49] *** andreoss joined
[09:49] *** telex left
[09:50] * timotimo had unRESTful sleep :|

[09:50] *** telex joined
[09:50] <timotimo> not actually sure if the sleep can be said to have been had

[09:51] <RabidGravy> Oooh "Package rakudo-star.x86_64 0:0.0.2015.06-1.fc21 will be an update" pretty snappy there from Fedora

[09:52] *** VinceDee joined
[09:53] *** TEttinger left
[09:56] *** nowan left
[09:58] *** atroxaper left
[09:59] *** nowan joined
[09:59] *** atroxaper joined
[10:07] *** domidumont left
[10:14] *** rindolf joined
[10:19] *** Alina-malina left
[10:22] *** aborazmeh joined
[10:22] *** aborazmeh left
[10:22] *** aborazmeh joined
[10:26] *** andreoss left
[10:39] *** huf left
[10:42] *** huf joined
[10:59] *** AlexDaniel left
[11:00] <smls> Can the Perl 6 type system express  "either a string, or an array of strings"  ?

[11:00] *** xinming left
[11:01] *** xinming joined
[11:05] <vendethiel> smls: it's always the case :P

[11:05] <vendethiel> m: my $a = "a string"; say $a[0]; # *g*

[11:05] <camelia> rakudo-moar cbff68: OUTPUT«a string␤»

[11:06] <vendethiel> m: sub f(@strs) { say @strs.elems }; f("hey"); f(("hey", "foo"));

[11:06] <camelia> rakudo-moar cbff68: OUTPUT«5===SORRY!5=== Error while compiling /tmp/c7TCdKpIP0␤Calling f(str) will never work with declared signature (@strs)␤at /tmp/c7TCdKpIP0:1␤------> 3sub f(@strs) { say @strs.elems }; 7⏏5f("hey"); f(("hey", "foo"));␤»

[11:06] <smls> No, I mean a type constraint that aceepts an Array objects whose elements are Str, *or* a single Str, but nothing else

[11:09] <vendethiel> m: subset OneOrManyStr where all($_) ~~ String; say "a" ~~ OneOrManyStr; say ("a", "b") ~~ OneOrManyStr;

[11:09] <camelia> rakudo-moar cbff68: OUTPUT«5===SORRY!5=== Error while compiling /tmp/OrGNEwYzi_␤Undeclared name:␤    String used at line 1. Did you mean 'Stringy'?␤␤»

[11:09] *** kanl left
[11:09] <vendethiel> m: subset OneOrManyStr where all($_) ~~ Str; say "a" ~~ OneOrManyStr; say ("a", "b") ~~ OneOrManyStr;

[11:09] <camelia> rakudo-moar cbff68: OUTPUT«True␤False␤»

[11:10] <vendethiel> m: subset OneOrManyStr where all($_.list) ~~ Str; say "a" ~~ OneOrManyStr; say ("a", "b") ~~ OneOrManyStr;

[11:10] <camelia> rakudo-moar cbff68: OUTPUT«True␤True␤»

[11:10] *** kanl joined
[11:10] <vendethiel> smls: sigils aren't first-class, so... I guess that way?

[11:11] <smls> hm, I guess

[11:12] *** domidumont joined
[11:14] <smls> is there a declarative way (i.e. without 'where') to specify an "Array whose elements are Str" constraint?

[11:14] <smls> Array[Str] does the wrong thing

[11:15] <smls> Array[Str]() does not seem to work either

[11:15] <vendethiel> smls: not if you didn't declare your array explicitly as such

[11:16] <smls> :(

[11:16] <oha> smls, i might be wrong, but i read something about roles that could support template type signatures, but not sure if that would help anyways

[11:18] <vendethiel> problem being that "if you pass an Array to a function expecting Array[Str], someone *outside* could add something that's not an int"

[11:18] <vendethiel> s/int/Str/

[11:18] *** dayangkun left
[11:20] <oha> smls, http://doc.perl6.org/language/objects#Parameterized_Roles but i don't know if there is a "core" role that works as an array container

[11:21] <vendethiel> there's Array[X] AFAIK

[11:25] *** amurf joined
[11:30] *** amurf left
[11:32] <nine> Captures are the closest analogue to Perl 5's scalar references we have, aren't they?

[11:35] <moritz> or containers (type Scalar), depending on the context

[11:37] <nine> Well, I'm trying to find something that can represent a P5 scalar ref in Perl 6 land. DBIx::Class expects a reference to a string for literal SQL and I wonder how I could pass that from Perl 6.

[11:39] <smls> exoecting a Capture would be the most generic way to handle such cases for the purposes of Inline::Perl

[11:40] <smls> though if you're talking about *porting* DBIx::Class to Perl 6, you should change the API to be more 6ish.

[11:40] <nine> smls: I'm talking about using Perl 5's DBIx::Class as is :)

[11:41] <lizmat> nine: what would be wrong with just passing the string from P6 ?

[11:42] <lizmat> and make it a ref on the P5 side?

[11:42] <lizmat> by doing a nqp::getattr($s,Str,'$!value') ?

[11:42] <smls> lizmat: I guess the PErl 5 side wants to distinguish different meanings basewd on whether it got a CALAR

[11:42] <smls> or reference

[11:43] <smls> *scalar

[11:43] <nine> lizmat: the string ref is an argument for DBIx::Class::ResultSet::search. Making it a ref on the P5 side would mean that I have to write a wrapper for every call of that method where I want to supply a ref.

[11:43] <lizmat> but that's really an optimization, isn't it?

[11:43] <RabidGravy> for anyone who cares DBIsh seems afflicted by the recent \  Capture changes

[11:44] <lizmat> because it generates a lot of worries?  or maybe too many?

[11:45] <nine> $resultset->search({foo => "bar"}) generates ~~ select * from table where foo = 'bar'; while $resultset->search({foo => \"= bar"}) generates ~~ select * from table where foo = bar; # without the quoting, thereby allowing literal SQL

[11:45] <RabidGravy> a lot of worries, I'll check it out later

[11:45] <nine> m: sub test(Positional $foo) { say $foo.WHAT }; test(\("foo"));

[11:45] <camelia> rakudo-moar cbff68: OUTPUT«Type check failed in binding $foo; expected 'Positional' but got 'Capture'␤  in sub test at /tmp/PAyfZfHCh3:1␤  in block <unit> at /tmp/PAyfZfHCh3:1␤␤»

[11:46] <nine> But according to http://doc.perl6.org/type/Capture class Capture does Positional does Associative { }

[11:46] <lizmat> Associative for the named parameters, I think

[11:47] <lizmat> I mean, there's a *lot* of machinery around a Capture

[12:00] <ribasushi> nine: both \$sql and \[ $sql, @bind ] are actually SQL::Abstract syntax thingies

[12:01] <ribasushi> so the application is wider

[12:02] *** atroxaper left
[12:02] <lizmat> ribasushi: would \[$sql]' be the same as \$sql ?

[12:03] <ribasushi> lizmat: yes, but both are user-facing API

[12:03] <lizmat> so nine could fake this on the P6 side by either doing $sql or [$sql]

[12:04] *** atroxaper joined
[12:04] <ribasushi> he can't just do $sql... how do you tell it apart from "value containing the string $sql"

[12:04] <ribasushi> let me show a clearer example

[12:05] <ShimmerFairy> Would it be possible to make use of blocks with  use v5;  in them?

[12:05] <huf> :q!

[12:05] <huf> nooooo

[12:06] *** atroxaper left
[12:09] <ribasushi> http://paste.scsys.co.uk/492394

[12:09] *** gfldex joined
[12:09] <ribasushi> lizmat: ^^

[12:09] <ribasushi> smls: ^^

[12:09] <ribasushi> nine: ^^

[12:09] <ribasushi> note the presence/absence of ` quotes

[12:09] *** Possum joined
[12:10] *** ShimmerFairy left
[12:10] <moritz> maybe one needs to create a type P5Ref or so for explicit (un)marshalling

[12:12] * ribasushi doesn't have an informed opinion about the p6 side, just pointing that all of the above are different invocations in active use by end users 

[12:14] <smls> moritz: So one would have to write  P5Ref.new("= col as-is")  on the Perl 6 side?

[12:14] <smls> instead of   \"= col as-is"

[12:15] <moritz> smls: yes

[12:15] <moritz> maybe there's a way to make Capture marshalling DWIM

[12:15] <smls> I guess P5Ref could be made to act like Scalar, so that when it is *returned* from a P5 sub, the Perl 6 side doesn't even have to care that it got a reference

[12:16] <smls> but can still check  ~~ P5Ref  in case that it does care

[12:17] <ribasushi> http://paste.scsys.co.uk/492397 <--- better paste, showcasing *why* there is a { -value } 

[12:17] <smls> getting back a Capture would be... unwieldy.

[12:17] <smls> thought for *calling* Perl 5 subs,  \  is prettier than   P5Ref.new()

[12:17] <ribasushi> (think PostgreSQL arrays)

[12:18] <moritz> m: sub prefix:<P5\>($x) { say "P5 ref to $x" }; say P5\"foo"

[12:18] <camelia> rakudo-moar cbff68: OUTPUT«5===SORRY!5=== Error while compiling /tmp/8CXnRrZRO2␤Unable to parse expression in quote words; couldn't find final '>'␤        ␤at /tmp/8CXnRrZRO2:1␤------> 3$x) { say "P5 ref to $x" }; say P5\"foo"7⏏5<EOL>␤    expecting any of:␤    …»

[12:18] <moritz> m: sub prefix:<P5\>($x) { say "P5 ref to $x" }; say P5\ "foo"

[12:18] <camelia> rakudo-moar cbff68: OUTPUT«5===SORRY!5=== Error while compiling /tmp/fiI7NRG00w␤Unable to parse expression in quote words; couldn't find final '>'␤        ␤at /tmp/fiI7NRG00w:1␤------> 3x) { say "P5 ref to $x" }; say P5\ "foo"7⏏5<EOL>␤    expecting any of:␤    …»

[12:19] <moritz> m: sub prefix:<P5\\>($x) { say "P5 ref to $x" }; say P5\ "foo"

[12:19] <camelia> rakudo-moar cbff68: OUTPUT«5===SORRY!5=== Error while compiling /tmp/6KQ_KGO_Dy␤Bogus postfix␤at /tmp/6KQ_KGO_Dy:1␤------> 3P5\\>($x) { say "P5 ref to $x" }; say P57⏏5\ "foo"␤    expecting any of:␤        infix␤        infix stopper␤        postfix␤        …»

[12:21] <ribasushi> and then there is "the other direction", also public API and used all over the place: https://metacpan.org/pod/DBIx::Class::ResultSet#as_query

[12:21] <nine> moritz: introducing a P5Ref type for this (presumabliy in Inline::Perl5) would be a step back to where the user has to use Inline::Perl5 explicitly.

[12:21] <nine> ribasushi: yep, that happens when people who write extremely important modules know perl too well.

[12:22] *** tinyblak left
[12:23] <ribasushi> all of these "design decisions" were made way before me, and the step from one to the other is straightforward

[12:23] *** ShimmerFairy joined
[12:23] <ribasushi> "ohhh you want to pass in whatever? - sure just give a reference to it"

[12:23] <ribasushi> "ooooh... you also need to pass binds... hmm well if \$sql means as-is, then \[ $sql, @binds ] is a no-brainer"

[12:24] <ribasushi> "hmmm you want to pass around random snippets in a stateless manner? - well we will just return you the \[ ... ] you already know and love"

[12:24] <nine> To be fair, it is actually a quite ok interface.

[12:24] <moritz> and this is where sqlalchemy just feels much better designed

[12:24] <smls> nine, moritz: Why not both? Automatically turn a P6 Capture into a P5 reference, but when *returning* a P5 reference to P6 code, return it as a P5Ref object that acts like P6's Scalar

[12:24] *** Alina-malina joined
[12:25] <ribasushi> moritz: haven't had much experience with it, so can't comment

[12:25] <nine> smls: I'd really like this stuff to round-trip without modification

[12:25] <nine> ribasushi: sqlalchemy really is worth a look

[12:25] <moritz> ribasushi: I'm using it for a $work project now, and quite enjoy it

[12:25] *** tinyblak joined
[12:25] <ribasushi> if it is better designed surface-wise, but without the ability to inject random stuff in any spot - this is actually a drawback

[12:25] <moritz> ribasushi: also it gives much better error messages when doing something wrong during the schema definition

[12:26] <ribasushi> nod

[12:26] <smls> nine: Well, it still rount-trip in the sense that you could feed the P5Ref back to P5:  Capture --1st-trip--> P5Ref --2nd-trip--> P5Ref ...

[12:27] *** leont joined
[12:27] <ribasushi> moritz: I will be the first to say - DBIC is rather user-unfriendly, as the user-facing side was not really designed, but instead built on top of built on top of built on top ;/

[12:28] <ribasushi> in any case - does either of you have a pointer to sqlalchemy's "insert random RDBMS-specific thing" ?

[12:30] <moritz> ribasushi: http://docs.sqlalchemy.org/en/latest/core/compiler.html is the first thing I could find

[12:31] <moritz> ribasushi: doesn't seem to be quite as ad-hoc as dbic

[12:32] <nine> ribasushi: http://docs.sqlalchemy.org/en/rel_1_0/core/tutorial.html#using-text

[12:33] <nine> smls: but if I give a Capture to Perl 5 code that just returns it, I get some weird P5Ref thing back instead of what I put in.

[12:34] <ribasushi> right... that's what I got back when I was looking - it's an "either/or"

[12:34] <smls> true

[12:34] <ribasushi> wheread in DBIC he "low-tech" approach allowed for arbotrary "mix-n-match"

[12:34] <ribasushi> which has its own strengths and drawbacks

[12:35] <ribasushi> bah mucho typos :/

[12:35] <nine> ribasushi: this looks pretty mix-n-match to me: select([ text("users.fullname || ', ' || addresses.email_address AS title") ]).where(and_(text("users.id = addresses.user_id"),

[12:36] <ribasushi> nine: I meant more like this: https://youtu.be/aqUcMFalaek?t=193

[12:36] <ribasushi> i.e. usable directly from the high-level API

[12:37] <ribasushi> it's likely possible with a custom-compilation akin to Class::DBI, but that borders on "SQL dictionary" in a sense

[12:38] <nine> In any case, I can't wait to see the results, when someone finally uses all of Perl 6's possibilities to create the one API to rule them all :)

[12:38] <ribasushi> if someone takes on this project I am always available to shoot holes in whatever beta-API someone comes up with

[12:39] * ribasushi doesn't have many design chops, but has plenty of "this is bad, because users will abuse it like that" experience

[12:40] <nine> I hope this someone will not make the same mistake like pretty much all others and starts with basic queries. One should really take the most extreme query imaginable with correlated subqueries, common table expressions, conditionals, custom functions and what not and create the API around that. Because that's where APIs usually really fall apart completely.

[12:41] <ribasushi> this.

[12:42] *** bin_005 left
[12:44] *** xinming left
[12:45] <dalek> roast: 6543aed | lizmat++ | S02-types/WHICH.t:

[12:45] <dalek> roast: Somehow we messed up with the last commit

[12:45] <dalek> roast: review: https://github.com/perl6/roast/commit/6543aedfd5

[12:45] <cdc_> m: so 2 == 2 & True

[12:45] <camelia> rakudo-moar cbff68: ( no output )

[12:45] <cdc_> m: say so 2 == 2 & True

[12:45] <camelia> rakudo-moar cbff68: OUTPUT«False␤»

[12:45] <lizmat> .o( me, myself and I )

[12:45] <cdc_> hello #perl6, is this expected: ^^

[12:46] <lizmat> m: say (2 & True).perl

[12:46] <camelia> rakudo-moar cbff68: OUTPUT«all(2, Bool::True)␤»

[12:46] <moritz> m: say so (2 == 2) & True

[12:46] <camelia> rakudo-moar cbff68: OUTPUT«True␤»

[12:46] <moritz> cdc_: looks pretty non-surprising to me

[12:46] *** domidumont left
[12:46] <moritz> & binds tigther than ==

[12:47] <cdc_> oops, thanks!

[12:47] <moritz> so you're checkint 2 == (2 & True), which autothreads to (2 == 2) & (True == 2)

[12:47] <moritz> which evaluates to True & False

[12:47] <moritz> which again collapses to False

[12:47] <cdc_> moritz: many thanks for the explanation :)

[12:48] <moritz> cdc_: you're welcomew

[12:48] <moritz> s/w$//

[12:49] *** domidumont joined
[12:52] *** aborazmeh left
[12:54] <hoelzro> (timotimo|lizmat)++ # p6weekly

[12:59] *** zakharyas joined
[13:05] *** abraxxa1 joined
[13:05] *** abraxxa left
[13:07] *** ShimmerFairy left
[13:18] <timotimo> thanks :)

[13:18] <timotimo> liz gets all the credit for lifting it off my shoulders for the last few weeks

[13:19] <timotimo> or at least all my kudos

[13:19] <timotimo> lizmat++ # good work on the p6weekly

[13:20] <smls> moritz: I found a trick for reducing ./htmlify.p6 wait times: Temporarily prefix the filename of the doc you're working on with a 1, and use  --sparse=5000.

[13:21] *** ShimmerFairy joined
[13:21] <smls> Maybe  --sparse  should use the last n modified files instead of the first n in alphabetical order?

[13:22] <moritz> smls: I mostly use --sparse to check if a htmlify can run at all; I'm fine with changing its exact semantics

[13:25] <hoelzro> timotimo: I wasn't sure who it was, but the writing style felt more like yours =)

[13:26] <lizmat> all your writing styles are belong to us

[13:27] <lizmat> commute to Amsterdam.PM&

[13:27] *** lizmat left
[13:29] <timotimo> hoelzro: the theme we're using makes the author name very hard to spot ;)

[13:30] <timotimo> liz tends to end her posts with a section called "winding down", i usually just call the equivalent section in my texts whatever i feel like at that moment

[13:32] *** zakharyas left
[13:35] *** ShimmerFairy left
[13:36] *** zakharyas joined
[13:38] *** pullphinger15 joined
[13:39] <masak> lizmat++ # p6weekly

[13:39] *** pullphinger15 left
[13:40] *** pullphinger joined
[13:42] *** pullphinger left
[13:42] *** pullphinger joined
[13:43] <hoelzro> .say for %perl-typemap.kv # how do I get this to print each pair on a line given the new GLR changes?

[13:43] *** zakharyas left
[13:43] <smls> I think it never did

[13:44] <timotimo> %perl-typemap.fmt("%s %s", "\n")

[13:44] <timotimo> is my suggestion :)

[13:44] <smls> maybe .pairs is what you want?

[13:44] <hoelzro> really?

[13:44] <timotimo> m: my %test = :1a, :2b, :3c; say %test.fmt("%s %s", "\n")

[13:44] <camelia> rakudo-moar cbff68: OUTPUT«a 1␤c 3␤b 2␤»

[13:44] <timotimo> ^- fmt is beautiful

[13:44] <hoelzro> I swear it used to do that, but then again, most of the Perl 6 I've written until recently is actually NQP =/

[13:45] <smls> m: for {:1a, :2b, :3c}.kv -> $k, $v { say $k, $v }

[13:45] <camelia> rakudo-moar cbff68: OUTPUT«a1␤c3␤b2␤»

[13:45] <smls> m: for {:1a, :2b, :3c}.pairs { say .key, .value }

[13:45] <camelia> rakudo-moar cbff68: OUTPUT«a1␤c3␤b2␤»

[13:46] <smls> m: for {:1a, :2b, :3c} { say .key, .value }

[13:46] <camelia> rakudo-moar cbff68: OUTPUT«Method 'key' not found for invocant of class 'Hash'␤  in block <unit> at /tmp/qFIYuV25O3:1␤␤»

[13:46] <RabidGravy> m: my %f = Foo => 1, Bar => 2; %f.pairs>>.say

[13:46] <camelia> rakudo-moar cbff68: OUTPUT«Bar => 2␤Foo => 1␤»

[13:46] <smls> m: for {:1a, :2b, :3c}<> { say .key, .value }

[13:46] <camelia> rakudo-moar cbff68: OUTPUT«a1␤c3␤b2␤»

[13:47] <ribasushi> nwc10: ping - see magnet-side pm when time permits

[13:47] <smls> Oh, looks like RPerl (http://rperl.org) has had its 1.0 release

[13:47] <smls> nice

[13:48] <smls> It compiles a magic-free subset of Perl 5 to C++, compiles it, and wraps it up in XS so it can be used from Perl 5 again

[13:49] <leont> Yeah, it's so little of perl5 that no real codebase can use it, IMO

[13:49] <smls> it is?

[13:49] <smls> :(

[13:49] <leont> It was last time I looked, but I have to admit I haven't looked at it in a while

[13:49] <smls> But maybe porting from Perl 5 -> RPerl code will still be more pleasant that porting to C/C++ by hand?

[13:50] <PerlJam> I wondered what "magic-free subset of Perl 5" really meant when I saw that last night.  They'd help their cause greatly by explaining that.

[13:50] <PerlJam> IMHO

[13:51] <leont> There is an explanation somewhere

[13:51] <geekosaur> doesn't "magic" have a specific meaning in the context of perl 5?

[13:51] <smls> leont: Also, I think it's meant to be used on performance-critical parts, not on whole code-bases

[13:51] <moritz> yes

[13:52] *** brrt left
[13:52] *** pullphinger left
[13:53] *** pullphinger joined
[13:53] <timotimo> MoarVM's profiler can now individually measure how much time is spent in native called routines

[13:54] *** zoosha left
[13:56] <smls> PerlJam: This seems to be sort of an explanation: http://rperl.org/the_low_magic_perl_commandments.html

[13:57] *** lucasb joined
[13:57] *** Celelibi_ joined
[13:57] <leont> Documentation on what it does is disappointingly little

[13:58] <smls> yeah

[13:59] <hoelzro> is there a way to get information from Grammar.parse on how far it got before failing to match?

[14:00] <PerlJam> hoelzro: maybe if you use Grammar::Tracer

[14:00] <hoelzro> PerlJam: I'd like to be able to give feedback to a user without having to print everything, though

[14:00] <timotimo> for rakudo's perl6 grammar, it implements its own thing with the high water marks

[14:01] <timotimo> it's a sort of difficult thing, really

[14:01] <smls> hoelzro: Add a   || { die $/.to }  at the right spot?

[14:01] <timotimo> with such a "high water mark", it's easy to get confusing results

[14:01] <timotimo> backtracking etc can really screw you over

[14:01] <PerlJam> hoelzro: maybe modify Grammar::Tracer to markup the AST instead of printing?

[14:02] <hoelzro> smls: that would work, except for backtracking and a lot of manual work =/

[14:02] <hoelzro> I think I can use smls' idea to achieve what I want for the most part, though

[14:03] <hoelzro> I can at least present a line number

[14:04] *** skids joined
[14:04] *** larion left
[14:04] *** larion joined
[14:04] *** zoosha joined
[14:04] <smls> hoelzro: I've used something like that in http://rosettacode.org/wiki/Dinesman%27s_multiple-dwelling_problem#Perl_6

[14:05] <smls> although I show the line that failed to match, instead of justs its line number

[14:06] <smls> wait, no

[14:06] <smls> just the number actually

[14:08] *** mr-foobar left
[14:10] <oha> got something a bit weird using HTTP::Client, INTERNAL ERROR: X::Numeric::Confused.new(what => ["5ae"]<>)

[14:11] <smls> HTTP::Client didn't work at all last time I tried it

[14:11] <oha> I understand moarvm precompile the pm files, so i'm not sure how to debug this

[14:11] <smls> ended up using HTTP::UserAgent instead

[14:11] <oha> smls, no no, it did so far

[14:11] <smls> hm ok

[14:11] <oha> smls, but if it is not maintained, i can do the same

[14:13] <smls> Doesn't seem to be very maintained judging from supernovus' comment here: https://github.com/supernovus/perl6-http-client/issues/7

[14:13] <oha> right, so HTTP::UserAgent is

[14:16] <RabidGravy> quick sanity check,  if I wanted to pass  (FILE *)NULL in NativeCall is just using the CPointer type object enough?

[14:19] <nine> yes

[14:21] *** xinming joined
[14:26] *** pullphinger left
[14:26] *** pullphinger joined
[14:26] *** [Sno] left
[14:26] *** [Sno] joined
[14:31] <RabidGravy> perfect

[14:32] *** skids left
[14:32] <oha> but... HTML::UserAgent follow automatically redirects (and fails anyway, but for a different reason... there must be something very wrong with this website)

[14:35] <tadzik> oha: HTTP::UserAgent is The THing

[14:35] <tadzik> not perfect, but what imho we should be trying to make perfect

[14:36] *** grondilu left
[14:37] <RabidGravy> must remember to finish up the changes I've got for it

[14:38] <ugexe> fwiw i've worked a lot on https://github.com/ugexe/zef/blob/master/lib/Zef/Net/HTTP/Client.pm6

[14:39] <RabidGravy> the more the merrier!

[14:41] *** khw joined
[14:41] <RabidGravy> we can have an http client deathmatch when it gets too quiet around here ;-)

[14:42] <ugexe> bout time for some 2.0 clients anyway

[14:46] *** gcole left
[14:48] *** vendethiel left
[14:48] *** abraxxa joined
[14:49] *** itz joined
[14:50] *** vendethiel joined
[14:50] *** abraxxa1 left
[14:52] *** gcole joined
[15:00] <dalek> Inline-Perl5: 0b6b575 | (Stefan Seifert)++ | / (5 files):

[15:00] <dalek> Inline-Perl5: Add support for mapping P5 scalar references to P6 Captures

[15:00] <dalek> Inline-Perl5: 

[15:00] <dalek> Inline-Perl5: Perl 6 \("foo") will be converted to \"foo" in Perl 5 and vice versa.

[15:00] <dalek> Inline-Perl5: This is needed for supporting APIs like SQL::Abstract where "foo" and

[15:00] <dalek> Inline-Perl5: \"foo" mean different things.

[15:00] <dalek> Inline-Perl5: review: https://github.com/niner/Inline-Perl5/commit/0b6b5757b8

[15:03] *** amurf joined
[15:08] *** amurf left
[15:08] *** [TuxCM] left
[15:16] *** Celelibi_ is now known as Celelibi

[15:17] *** diana_olhovik_ left
[15:18] *** g4 left
[15:19] *** FROGGS left
[15:29] *** larion left
[15:31] *** raiph joined
[15:33] *** pRiVi left
[15:33] *** pRiVi_ joined
[15:33] <itz_> do any of the http clients handle incorrectly encoded web pages I wonder? :)

[15:34] <ugexe> as far as i know they can all give you the raw output which you can encode/decode as you please

[15:36] <virtualsue> "no"

[15:41] *** leont left
[15:44] *** pullphinger left
[15:46] *** danstone1 left
[15:46] *** FROGGS joined
[15:47] *** danstoner joined
[16:00] <ugexe> the secret to handling incorrectly encoded web pages is to use .encode('latin-1') or .unpack('A*')

[16:00] *** pullphinger joined
[16:00] *** pullphinger left
[16:01] <ugexe> its just a possible security risk. or something

[16:01] *** dj_goku left
[16:01] <smls> you mean s/encode/decode/ ?

[16:01] *** tinyblak left
[16:02] *** diana_olhovik_ joined
[16:03] *** pullphinger joined
[16:04] <ugexe> heh, yeah that would work even better

[16:04] *** dakkar left
[16:13] *** domidumont left
[16:13] *** dakkar joined
[16:14] *** abraxxa left
[16:15] *** skids joined
[16:18] *** raiph left
[16:20] *** raiph joined
[16:22] *** uncleyear left
[16:23] *** davido___ left
[16:24] *** davido___ joined
[16:24] *** uncleyear joined
[16:31] <smls> masak: I'm working on the new  /language/indexing.html  doc page we were briefly talking about.

[16:31] <smls> But now I'm wondering if "indexing" is really a good umbrella term for what the .[] and .{} postfix operators do.

[16:31] <smls> The word is more associated with the positioanl variety, isn't it?

[16:32] <smls> i.e. "indexing" vs "hashing" in database terms

[16:32] <smls> Maybe "subscripting" would be a better title for the page?

[16:32] <smls> It will sound weird to non-Perl people though.

[16:32] <smls> ^^ others may weigh in too, not just masak :P

[16:33] <lucasb> IMO, "subscripts" is good

[16:35] <smls> I'm leaning towards the gerund ("-ing") form, because I'm also imagining an hypothetical  /language/iterating.html  doc page, and then the two would go quite nicely together

[16:36] <smls> And between the two, cover most of what there is to know about Perl 6 data structure handling

[16:37] *** rindolf left
[16:37] <ggoebel> regarding jnthn's grant funding running out at the end of this month... the grant proposal amount requested is $10K - $40/h for 50% of jnthn's time from April to December. How much additional funding is needed to reach the $10K goal?

[16:38] <smls> Though the 'iterating' one will have to be written after the GLR :P

[16:38] <smls> ^^ moritz?

[16:41] <JimmyZ> ggoebel: http://www.perlfoundation.org/perl_6_core_development_fund

[16:43] <JimmyZ> ggoebel: http://news.perlfoundation.org/2015/04/grant-proposal-perl-6-release.html # this one is not from April to December :)

[16:43] *** rindolf joined
[16:44] <ggoebel> JimmyZ: if you read the url you referenced. "I have arranged with my employer to drop to 50% of full-time hours for the period April through December 2015"

[16:45] <ggoebel> JimmyZ: neither of the urls referenced show how much of the grant has been funded beyond lizmat++'s initial seed investment

[16:45] *** Foxcool_ joined
[16:46] <JimmyZ> yeah, that is for the first 3 months

[16:46] <JimmyZ> it said, "Funding is being requested for an initial 3 month period"

[16:46] *** spider-mario joined
[16:47] <JimmyZ> http://www.perlfoundation.org/perl_6_core_development_fund # said total 25K

[16:47] <JimmyZ> thus 15K to be needed :)

[16:48] <ggoebel> JimmyZ: Hmm... makes sense

[16:48] *** Foxcool left
[16:48] *** domidumont joined
[16:48] <ggoebel> I didn't understand how $10K could cover 50% time for 8-9 months

[16:49] <ggoebel> so we would need to raise $3K/m for 5 months

[16:49] <dalek> perl6-roast-data: aa650a9 | coke++ | / (9 files):

[16:49] <dalek> perl6-roast-data: today (automated commit)

[16:49] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/aa650a92cc

[16:49] <JimmyZ> me either, but the plan is about total 25K

[16:51] <ggoebel> I'll talk with the wife tonight and negotiate carving out a piece of our annual charitable contributions budget

[16:52] *** nys joined
[16:54] <JimmyZ> That would be nice, thank you! :)

[16:54] *** andreoss joined
[16:54] <PerlJam> ggoebel++

[16:55] <andreoss> itz: seems that examples.perl6.org is completely ruined by Text::VimColour

[16:55] <ggoebel> It would be nice if there were a perl6 core development fund webpage which listed supporters (and support levels if that is relevant) and a regular note in the p6weekly giving a status update on whether or not we are making progress toward our monthly and annual fund raising goals

[16:55] <andreoss> examples are not even shown now

[16:56] <itz> andreoss: yes I will revert now :( it's very odd works on all the systems I have access too

[16:56] <ggoebel> I could care less about my name showing up on a list. But I'd like to be able to see a growing list of names

[16:56] <smls> yeah, would be nice

[16:57] <andreoss> itz: it doesn't not work wirhout proper .vimrc, with .vimrc i got from vim-perl it works okay

[16:58] <andreoss> itz: do you have ssh access to this box?

[16:58] <itz> no

[16:58] <itz> I will change in git anyway

[16:59] <itz> I suppose I could point the command at a version of .vimrc shipped inside the module

[17:02] *** diana_olhovik_ left
[17:02] <smls> Is there a way to donate to the Perl 6 development fund via simple PayPal or so?

[17:03] <smls> The webpage wants me to sign up for an account with a million requiered form fields...

[17:03] <dalek> perl6-examples: c616ed1 | (Steve Mynott)++ | / (2 files):

[17:03] <dalek> perl6-examples: revert Text::VimColour use

[17:03] <dalek> perl6-examples: review: https://github.com/perl6/perl6-examples/commit/c616ed1e11

[17:04] <andreoss> itz: the code for highlighting from main site might be borrowed, but i hesitate doing so since it's in python

[17:04] <JimmyZ> ggoebel: me too. 

[17:05] <itz> andreoss: I'm sure its possible to get Vim working .. it's just tricker than expected .. I will look at it again tomorrow UK time 

[17:05] <itz> and have the Vim Colour support as a command line option (off by default)

[17:06] *** berekuk joined
[17:07] *** dakkar left
[17:08] <JimmyZ> smls: I don't know, maybe lizmat++ knows :)

[17:10] *** rindolf left
[17:10] <hoelzro> colomon: are you in charge of rolling out the SmokeResults application to http://smoke.perl6.org?

[17:10] <colomon> hoelzro: er, I guess

[17:11] <hoelzro> colomon: would you mind rolling out the change I submitted last week? it would be cool to start seeing which distributions have warnings =)

[17:11] <colomon> hoelzro: I think I already have

[17:11] <colomon> In order to start seeing changes, we actually have to get a complete smoke run.

[17:12] <colomon> which only happened twice in June, and hasn’t happened yet in July.

[17:12] <colomon> hmm, except the banner was supposed to change, wasn’t it.

[17:12] <hoelzro> colomon: I don't see the GH banner, or the warnings category in the legend

[17:13] <hoelzro> yup

[17:13] <colomon> hoelzro: I think I updated in the wrong account

[17:15] *** rindolf joined
[17:15] *** ab6tract joined
[17:18] <raiph> How does one coerce (or at least convert) a (known to be suitably small value) Int to an int?

[17:18] <RabidGravy> any reason why we can't have a "can-ok" in Test?  I keep typing it only to find it isn't there

[17:19] <colomon> hoelzro: will have it up in a moment...

[17:19] <RabidGravy> I'll make it and everything 

[17:19] *** domidumont left
[17:20] <smls> RabidGravy:  you mean as a shortcut for   ok $obj.^can("method")  ?

[17:20] <RabidGravy> yeah

[17:20] <colomon> hoelzro: huh.  updated elsewhere, still no improvement.  moritz?

[17:21] <hoelzro> colomon: cool, thanks!

[17:21] <smls> would that really gain much though?

[17:21] <smls> not much less to type

[17:21] <PerlJam> smls: we have isa-ok 

[17:21] <smls> yes, because that allowes much better failure messages

[17:22] <smls> oh, you wrote *isa*

[17:22] <smls> hm

[17:22] <colomon> hoelzro: third time’s the charm?

[17:22] <RabidGravy> yeah by the same token you could just take away all of Test except for ok()

[17:22] <RabidGravy> ;-)

[17:22] <smls> nah

[17:23] <smls> is  allows it to show what was expected and what was found, in case of failure

[17:23] <colomon> hoelzro: FOURTH time is the charm!

[17:23] <smls> ok  can only report "eep, the expression was false"

[17:23] <colomon> hoelzro: still no useful information for you, though.

[17:23] <smls> I guess isa-ok can also show the expected vs found value

[17:24] <hoelzro> colomon: that's fine

[17:24] <hoelzro> is the lack of warnings why it's not showing up in the legend?

[17:24] <colomon> hoelzro: that I cannot tell you.

[17:24] <PerlJam> RabidGravy: write it and see what happens ;)

[17:24] <smls> can-ok  would not be able to show more info than  ok  would though, right?

[17:24] <smls> so maybe that's why it doesn't exist

[17:25] <colomon> hoelzro: I need to triage smoking and get it to skip the modules that break it completely (like DateTime::TimeZone)

[17:25] <PerlJam> smls: or ... maybe no one got around to implementing it yet

[17:25] <hoelzro> colomon: alright, thanks for pushing that out!

[17:25] <RabidGravy> well more info than "defined $obj  && defined $obj.HOW and $obj.^can ...."

[17:25] <smls> PerlJam: I was talking conceptually

[17:26] <smls> because what is there to report in case of failure, oither than "nope the method does not exist"?

[17:26] <PerlJam> well ... it conceptually already exists ... in Perl 5's Test::More

[17:27] <smls> Wouldn't really be shorter either:   ok $obj.^can("method")   vs  can-ok $obj, "method"

[17:27] <smls> though nicer to write I suppose

[17:27] <RabidGravy> and the thing is actually a valid invocant and so on and so forth

[17:28] <smls> RabidGravy:  *Should* it implicitly check  'defined $obj'  though inb Perl 6?

[17:28] <RabidGravy> it's in Test::More - I've been writing tests with Test::More for more than ten years, so have a lot of people. It's a convenience, a comfort thing

[17:29] <smls> checking a method on a type object is not so unusual I think.

[17:29] <RabidGravy> probably

[17:30] <smls> in Perl it makes sense, because definedness is different there

[17:30] <RabidGravy> you know the amount of typing we just did, I could have implemented it and sent the PR?

[17:31] <smls> well-designed API > big API

[17:31] <PerlJam> smls: TMTOWTDI!  ;)

[17:32] <raiph> m: use nqp; say nqp::decont(10, int) # How does one coerce (or at least convert) a (known to be suitably small value) Int to an int, without using NQP?

[17:32] <camelia> rakudo-moar cbff68: OUTPUT«(int)␤»

[17:32] *** Sqirrel joined
[17:32] <PerlJam> personally, I see no compelling reason NOT to include it, nor do I have a compelling reason TO include it, other than RabidGravy (and possibly others) would find it useful.  Ergo, for me, the balance tips towards having it.

[17:34] <ab6tract> howdy #perl6

[17:34] <RabidGravy> erp

[17:35] <PerlJam> raiph: why the "without nqp" restriction?

[17:35] <ab6tract> So I've gotten what appears to be a pretty complete version of an overlaps-with check for ranges

[17:36] <ab6tract> My only problem with it so far is that it was arrived at entirely via ballistic programming. I would be curious to hear what others think: https://gist.github.com/ab5tract/73bf6ca1663073b33e71

[17:37] <ab6tract> obviously, were it added to ranges via core-settings, it would have optimizations for returning early for easier to test cases

[17:39] <ab6tract> anyway, it's been passing all the ranges I've been throwing at it. I wonder if someone can break it.

[17:40] *** davido___ left
[17:41] *** davido___ joined
[17:42] <JimmyZ> m: my Int $i = 10; my int $j = int($i); say $j;

[17:42] <camelia> rakudo-moar cbff68: OUTPUT«Cannot invoke this object (REPR: P6int, cs = 0)␤  in block <unit> at /tmp/aVPUHRBkxt:1␤␤»

[17:43] <JimmyZ> m: my Int $i = 10; my int $j = $i; say $j;

[17:43] <camelia> rakudo-moar cbff68: OUTPUT«10␤»

[17:43] <JimmyZ> raiph: ^^ ?

[17:45] <[Coke]> having just done some range checking for dates at work, isn't it (r1.max >= r2.min AND r1.min <=r2.max) # this doesn't deal with endpoints.

[17:45] <[Coke]> for ab6tract 

[17:46] <ab6tract> [Coke]: it's precisely the endpoints that my implementation is designed to account for

[17:47] <ab6tract> because otherwise someone is going to have to handroll the overlaps check themselves, or suffer from the subtle yet important bug of ignoring end point exclusions

[17:47] <timotimo> raiph: int will only survive in native vars "my int $foo", native attributes "has int $.foo", native arrays "my int @foo", and parameters for calls

[17:47] <moritz> https://www.python.org/dev/peps/pep-0485/ food for thought for our is_approx implementation

[17:48] *** espadrine left
[17:48] <timotimo> raiph: however, for sufficiently small int values we actually do not store full big int structures in the Int object

[17:48] <timotimo> raiph: and many big int ops can handle those "small big ints"

[17:49] <PerlJam> ab6tract: Then isn't it what Coke said, but subtract the numeric  .excludes_max  and .excludes_min as appropriate?

[17:49] <ab6tract> PerlJam: No, because the excluded-6 is not 5

[17:49] <flussence> m: unit sub MAIN(); # I like that it allows unit here for consistency, but is this meant to work?

[17:49] <camelia> rakudo-moar cbff68: ( no output )

[17:50] <ab6tract> sorry, that's a confusing way to say it. PerlJam, I invite you to plug in such a solution

[17:52] <ab6tract> 5^..^6  needs to return true for any floating point value that exists between 5 and 6

[17:52] *** telex left
[17:53] <ab6tract> overlaps-with( 5^..^6, 5.5^..^5.6 )

[17:53] <PerlJam> oh, good poitn.

[17:54] *** telex joined
[17:54] <lucasb> m: unit enum X <a b c>; unit constant C = 42; unit subset Foo; say 'ok'

[17:54] <camelia> rakudo-moar cbff68: OUTPUT«ok␤»

[17:55] <lucasb> flussence: It doesn't seem to be intentional

[17:57] <ab6tract> ah, I found a case where the current expression fails.. overlaps-with( 5^..^6, 5.5^..6 )

[17:59] *** cdc_ is now known as cdc

[18:02] *** WABF3FZ joined
[18:10] <dalek> perl6-examples: a018c56 | andreoss++ | / (2 files):

[18:10] <dalek> perl6-examples: [euler] problem 97

[18:10] <dalek> perl6-examples: review: https://github.com/perl6/perl6-examples/commit/a018c56b80

[18:11] *** smls left
[18:12] <lucasb> I don't think I can see Captures and P5 references as similar things. (Are they?) Sure, both can be used to hold references to other things, it's fine if that helps solve some problem as a work-around.

[18:13] *** Begi joined
[18:14] <Begi> Hey ! I'd like use the Twitter API with Perl6. Which module can I use ? i've try HTTP::Client, but it doesn't support the HTTPS protocol

[18:16] <nine> lucasb: if you have a different suggestion, it's not too late to change it

[18:17] *** uncleyear left
[18:17] *** uncleyear joined
[18:17] <ugexe> HTTP::UserAgent + IO::Socket::SSL

[18:18] <Begi> ugexe : I'll saw that. Thanks

[18:18] <raiph> m: my Int $i = 10; my int $j = $i; say $j ~~ int; # JimmyZ

[18:19] <camelia> rakudo-moar cbff68: OUTPUT«False␤»

[18:19] <PerlJam> ab6tract: I gave up playing with your overlaps code, but I converted it to use tests.  You might find that useful.  See https://gist.github.com/perlpilot/091488db934dd4b3d9da

[18:19] <raiph> m: sub foo (int $i) { say $i; $i }; say (foo(10**19) ~~ int) # timotimo

[18:19] <camelia> rakudo-moar cbff68: OUTPUT«-8446744073709551616␤False␤»

[18:19] <raiph> PerlJam: Mostly curiosity; I was thinking there'd be a way to get from an Int to an int without using NQP -- also see the lines just above (that mention JimmyZ, timotimo)

[18:19] *** lizmat joined
[18:20] <ab6tract> PerlJam: thanks man! That was definitely necessary

[18:22] <timotimo> raiph: the ~~ operator boxes the int into an Int for your convenience

[18:23] <raiph> timotimo: ah

[18:23] <andreoss> is there a function composition in Perl 6?

[18:25] <lizmat> good *, #perl6!

[18:27] <lizmat> re http://irclog.perlgeek.de/perl6/2015-07-07#i_10861628 : there's the donate button on the perlfoundation site that takes you to https://secure.donor.com/pf012/give

[18:27] <andreoss> m: sub x {}; &x.^methods».gist.grep(/compose/)

[18:27] <camelia> rakudo-moar cbff68: ( no output )

[18:27] <lizmat> for which you indeed need to create a login  :-(

[18:27] <raiph> andreoss: http://irclog.perlgeek.de/perl6/2015-03-13#i_10271727

[18:28] * [Coke] threw a small amount into the pot.

[18:28] <lizmat> smls: I wish there were a Paypal account

[18:29] <ab6tract> PerlJam: thank you very much indeed. I was delaying converting to tests as long as possible. I've forked your version and changed the logic so that the edge cases I've found this evening are accounted for: https://gist.github.com/ab5tract/ef4190612d84f49decc2

[18:29] <lizmat> [Coke]++

[18:30] <timotimo> in general, pretty much every method call on an int, num or str will create a box for you

[18:31] * [Coke] found a perler in NYC to dine with tomorrow.

[18:32] *** larion joined
[18:35] <lucasb> m: say(|\a=>1)

[18:35] <camelia> rakudo-moar cbff68: OUTPUT«a => 1␤»

[18:35] <lucasb> m: say(|\'a'=>1)

[18:35] <camelia> rakudo-moar cbff68: OUTPUT«5===SORRY!5=== Error while compiling /tmp/Z49awGCf8x␤Variable '&prefix:<|>' is not declared␤at /tmp/Z49awGCf8x:1␤------> 3say(7⏏5|\'a'=>1)␤»

[18:36] <lucasb> Trying to understand how I ended up with a variable '&prefix:<|>'

[18:40] <masak> lucasb: that's how operators are named.

[18:40] *** andreoss left
[18:40] *** amurf joined
[18:40] *** baest_ joined
[18:41] <masak> m: sub infix:<+++>($l, $r) { "OH HAI" }; say "nice" +++ "greeting"; say &infix:<+++>

[18:41] <camelia> rakudo-moar cbff68: OUTPUT«OH HAI␤sub infix:<+++> ($l, $r) { #`(Sub+{Precedence}|44130160) ... }␤»

[18:41] <masak> m: sub infix:<+++>($l, $r) { "OH HAI" }; say "nice" +++ "greeting"; say &infix:<+++>.name

[18:41] <camelia> rakudo-moar cbff68: OUTPUT«OH HAI␤infix:<+++>␤»

[18:42] *** baest left
[18:45] *** amurf left
[18:53] <raiph> m: my int $i = 10; use nqp; say nqp::istype($i, int); say nqp::istype($i, Int); # timotimo: do you know of any way to get an int (without using nqp::decont or other nqp op)?

[18:53] <camelia> rakudo-moar cbff68: OUTPUT«0␤1␤»

[18:56] *** ab6tract left
[18:58] *** larion left
[19:00] *** Begi left
[19:01] *** AlexDaniel joined
[19:04] *** lolisa joined
[19:07] <dalek> rakudo/nom: 1c3b559 | RabidGravy++ | lib/Test.pm:

[19:07] <dalek> rakudo/nom: Add can-ok subroutine

[19:07] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/1c3b559328

[19:07] <dalek> rakudo/nom: 3899982 | lizmat++ | lib/Test.pm:

[19:07] <dalek> rakudo/nom: Merge pull request #464 from jonathanstowe/can-ok

[19:07] <dalek> rakudo/nom: 

[19:07] <dalek> rakudo/nom: Add can-ok subroutine

[19:07] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/38999825cb

[19:08] *** spintronic left
[19:09] *** dams_ left
[19:09] <lucasb> m: say { 'a' R=> 1 }

[19:09] <camelia> rakudo-moar cbff68: OUTPUT«1 => a␤»

[19:09] <lucasb> m: say { 'a' RR=> 1 }

[19:09] <camelia> rakudo-moar cbff68: OUTPUT«-> (;; $_? is parcel) { #`(Block|50977024) ... }␤»

[19:10] <lizmat> m: say { 'a' RRR=> 1 }   # just checking

[19:10] <camelia> rakudo-moar cbff68: OUTPUT«-> (;; $_? is parcel) { #`(Block|39475696) ... }␤»

[19:10] <RabidGravy> and just as I was typing "ok($obj.^can($param), $obj.WHAT.perl ~ " can $param")

[19:12] <lizmat> RabidGravy: what then?

[19:13] <RabidGravy> ;) I'll rebuild rakudo instead

[19:13] <RabidGravy> cheers!

[19:13] <lizmat> it'll be quick, only lib/Test.pm  :-)

[19:17] *** itz left
[19:22] <lizmat> raiph: I have no answer for you, I hope jnthn will

[19:36] *** khw left
[19:42] <masak> m: my Int @a = 1, 2, 3; @a.push("4"); say @a

[19:42] <camelia> rakudo-moar 389998: OUTPUT«Type check failed in assignment to '@a'; expected 'Int' but got 'Str'␤  in block <unit> at /tmp/oPoDdGSzQs:1␤␤»

[19:42] <masak> m: my Int @a = 1, 2, 4; @a.splice(2, 0, "3"); say @a

[19:42] <camelia> rakudo-moar 389998: OUTPUT«1 2 3 4␤»

[19:42] * masak submits rakudobug

[19:42] <masak> *grin*

[19:42] <lizmat> grrrr

[19:43] *** [TuxCM] joined
[19:45] <moritz> that's the disadvantage of the implementation not using its own API

[19:47] *** bin_005 joined
[19:50] *** rurban left
[19:52] <timotimo> raiph: not sure; what exactly are you trying to do?

[20:00] <timotimo> m: my int $foo = 10; say nqp::objprimspec($foo); my Int $bar = 20; say nqp::objprimspec($bar)

[20:00] <camelia> rakudo-moar 389998: OUTPUT«===============================================================================␤The use of nqp::operations has been deprecated for non-CORE code.  Please␤change your code to not use these non-portable functions.  If you really want␤to keep using nqp:…»

[20:00] <timotimo> m: use nqp; my int $foo = 10; say nqp::objprimspec($foo); my Int $bar = 20; say nqp::objprimspec($bar)

[20:00] <camelia> rakudo-moar 389998: OUTPUT«0␤0␤»

[20:00] <timotimo> oh, huh.

[20:00] *** rurban joined
[20:01] <dalek> roast: 9379577 | (Nick Logan)++ | S32-io/IO-Socket-Async.t:

[20:01] <dalek> roast: fix flapping(?) test. indent cleanup

[20:01] <dalek> roast: 

[20:01] <dalek> roast: Passes all tests, including supposed previously flapping test.

[20:01] <dalek> roast: 

[20:01] <dalek> roast: Convert mix of tabs+spaces to all space indentation. 

[20:01] <dalek> roast: Corrected the binary server code to actually work.

[20:01] <dalek> roast: Passes previously flapping test RT 122318? (Not sure if this is fixed or not. The RT has 0 information so its impossible to know)

[20:01] <dalek> roast: 

[20:01] <dalek> roast: I was not able to reproduce a flapping test before or after this PR so you may wish to un-skip the final test and close the ticket. Before this PR, it was simply FAILING the final test after some 10k iterations.

[20:01] <dalek> roast:     

[20:01] <dalek> roast:     nickl@localhost:~/perl6/rakudo$ prove -v -e './perl6 -Ilib' t/spec/S32-io/IO-Socket-Async.t

[20:01] <dalek> roast:     t/spec/S32-io/IO-Socket-Async.t ..

[20:01] <dalek> roast:     1..6

[20:01] <dalek> roast:     ok 1 - Async listen on bogus hostname

[20:01] <dalek> roast:     ok 2 - Async connect to unavailable server breaks promise

[20:01] <dalek> roast:     ok 3 - Async connect to available server keeps promise

[20:01] <dalek> roast:     ok 4 - Echo server

[20:01] <dalek> roast:     ok 5 - Discard server

[20:01] <dalek> roast:     ok 6 - bytes_supply

[20:01] <dalek> roast:     ok

[20:01] <dalek> roast: review: https://github.com/perl6/roast/commit/937957770e

[20:05] *** ab6tract joined
[20:07] *** FROGGS left
[20:08] *** lizmat left
[20:10] <ab6tract> PerlJam: I think I've nailed it https://gist.github.com/ab5tract/ef4190612d84f49decc2

[20:11] <ab6tract> It is also look much more symmetric, which was one thing that made me uncomfortable about it before. Doing the commutative test is important. Thanks (once again!) for the testing setup.

[20:12] *** [TuxCM] left
[20:13] *** darutoko left
[20:14] <timotimo> ab6tract: only for numerical ranges, though? :)

[20:20] <ab6tract> timotimo: :(

[20:22] *** diakopter left
[20:23] <ab6tract> timotimo: how many other forms of ranges do we support?

[20:23] <masak> it's kind of open-ended. anything that supports .succ, basically

[20:24] <masak> to give two examples, Str and Date

[20:24] <masak> m: say "f".succ

[20:24] <camelia> rakudo-moar 389998: OUTPUT«g␤»

[20:24] <masak> m: say Date.today.succ

[20:24] <camelia> rakudo-moar 389998: OUTPUT«2015-07-08␤»

[20:24] <masak> m: say "f" ..^ "m"

[20:24] <camelia> rakudo-moar 389998: OUTPUT«"f"..^"m"␤»

[20:24] <masak> m: say Date.today ..^ Date.today.later(:5days)

[20:24] <camelia> rakudo-moar 389998: OUTPUT«Date.new(2015, 7, 7)..^Date.new(2015, 7, 12)␤»

[20:26] <labster> m: say Date.today ~~ "🎋"

[20:26] <camelia> rakudo-moar 389998: OUTPUT«False␤»

[20:27] <labster> We obviously need a unidate function.

[20:28] *** [TuxCM] joined
[20:30] <ugexe> which method returns the number of seconds until the heat death of the universe?

[20:30] <dalek> roast: bc052ef | usev6++ | S32-list/map.t:

[20:30] <dalek> roast: Unfudge last test for RT #125207; skids++

[20:30] <dalek> roast: review: https://github.com/perl6/roast/commit/bc052effcb

[20:30] <synbot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=125207

[20:31] *** berekuk left
[20:31] *** smls joined
[20:33] *** lucasb left
[20:37] <ab6tract> masak: ah, that does clarify things. 

[20:37] <ab6tract> fortunately, I think the excludes logic should be simpler for non-numeric cases

[20:38] <masak> it's simpler for discrete domains, yes.

[20:40] *** gtbjj joined
[20:41] <smls> jnthn, lizmat: It looks like   @a[0..3]   calls @a.list to find out which of the requested elements exist, and then calls @a.AT-POS for each of the existing ones.

[20:42] <smls> Is that intentional?

[20:43] <smls> If so, that's yet another gotcha for people trying to implement the postcircumfix [] interace for a custom type... :/

[20:46] <smls> m: my @a = 5, 10; dd @a[1, 10]; dd @a[1..10]

[20:46] <camelia> rakudo-moar 389998: OUTPUT«(10, Any)␤(10,)␤»

[20:47] <smls> ^^ and is this different behavior of list vs range subscripts by design?

[20:47] <skids> Ranges autotruncate inside .[]

[20:47] <smls> ok

[20:47] <skids> As long as they don't start with a negative (or well, off the left side of whatever your indexes are)

[20:48] <skids> But lizmat++ recently noted that:

[20:48] <smls> shouldn't they be calling .elems or .end to find out where to truncate though?

[20:48] <skids> m: my @a = 5, 10; dd @a[1, 1..10]

[20:48] <camelia> rakudo-moar 389998: OUTPUT«(10, 10, Any, Any, Any, Any, Any, Any, Any, Any, Any)␤»

[20:48] <smls> instead of .list

[20:48] <skids> Which looks borken.

[20:48] <masak> yeah, that feels inconsistent.

[20:48] <smls> yeah

[20:49] <skids> The problem with calling .elems is when you are dealing with a lazy list.

[20:49] <smls> also, didn't TimToady/pmichaud_ say that subscript arguments flatten?

[20:49] *** khw joined
[20:49] <skids> Yes it is noted  in the GLR notes now that .[] is a flattening context.

[20:50] <skids> Though the range behavior makes it more special than just that.

[20:50] <smls> ETOOMUCHMAGIC

[20:52] <skids> I think the GLR has deigns on, instead of just A) Iterating the list, or B) calling elems, a third option of C) chunking negotiation will be in play.

[20:52] <skids> *designs

[20:52] <skids> But that's just me guessing.

[20:52] <smls> couldn't the auto-truncating be restricted to range subscripts of the form  4..*  ?

[20:53] <smls> since I'm guessing that's the motivation for having them?

[20:53] *** pullphinger left
[20:53] *** pullphinger15 joined
[20:53] <skids> No actually, they are usful in general.

[20:54] *** [TuxCM] left
[20:55] <skids> Now if another behavior like throwing an OOR exception is desired a lot, how to make that happen is a good question.

[20:56] <skids> One way, of course, would be to use ... instead of ..

[20:57] *** raiph left
[21:00] <skids> .oO(Ranges form an interesting algebra in that they are not closed under subtraction even when overlapping)

[21:00] <smls> skids: For the auto-truncating, it could also simply do  $range.map({ @a.EXISTS-POS ?? @a.AT-POS !! Empty })

[21:00] <skids> Yeah I don't know why .list is invoked.

[21:00] <smls> well, gotta handle infinite ranges, but you get the idea

[21:02] <skids> I always have the impression when wading into that area that there's someone with a firm grip on the corner of the rug ready to give it a good pull :-)

[21:04] <skids> .oO(A closed algebra on ranges would have two addition and two subtraction operators each returning the upper and lower range, or same if only one resulted.)

[21:07] *** VinceDee left
[21:10] *** gtbjj1 joined
[21:11] *** kaare_ left
[21:11] *** kaare_ joined
[21:13] *** gtbjj left
[21:14] <smls> FYI this is what I use for testing this stuff: https://gist.github.com/smls/7e1835a2e581cceaaf6a

[21:17] *** gtbjj joined
[21:17] *** gtbjj1 left
[21:17] *** ab6tract left
[21:18] *** skids left
[21:18] *** lucasb joined
[21:19] *** beastd joined
[21:19] *** gtbjj1 joined
[21:21] *** gtbjj left
[21:22] <lucasb> m: my &prefix:<|> = { 'oh hai' }; say |1=>1

[21:22] <camelia> rakudo-moar 389998: OUTPUT«oh hai => 1␤»

[21:24] *** gtbjj1 left
[21:28] *** kurahaupo joined
[21:28] *** shmibs joined
[21:33] *** shmibs left
[21:34] *** shmibs joined
[21:37] *** lucasb left
[21:43] *** pRiVi_ left
[21:45] *** pRiVi joined
[21:49] *** pullphinger15 left
[21:54] *** spider-mario left
[21:57] <smls> m: my %hash; my $val := %hash<foo><bar>; dd %hash

[21:57] <camelia> rakudo-moar 389998: OUTPUT«%hash = {}<>␤»

[21:57] <smls> ^^ S09 claims this would autovivify

[21:58] <masak> m: my %hash; my $val := %hash<foo><bar>; $val = 42; dd %hash

[21:58] <camelia> rakudo-moar 389998: OUTPUT«%hash = {:foo({:bar(42)})}<>␤»

[21:59] *** lolisa left
[21:59] <smls> yes, but it claims that the binding itself autovivifies

[21:59] <masak> I haven't checked S09, but it makes intuitive sense that it wouldn't autovivify *before* you assign to it.

[21:59] <smls> "Autovivification will only happen if the vivifiable path is bound to a read-write container."

[21:59] <smls> and it gives that example as one that does

[21:59] <masak> so I don't know what reason S09 has, but the way Rakudo has it feels quite straightforward.

[22:01] *** rindolf left
[22:01] <smls> But then again, S09 does seems to consist mostly of fossils, NYI stuff, and things where it's not clear whether it's a fossil or NYI... :S

[22:03] *** ab6tract joined
[22:05] *** ab6tract left
[22:07] *** beastd left
[22:09] <smls> m: my @array; foo(@array[0][0]); sub foo ($obj is rw) { dd $obj }; dd @array

[22:09] <camelia> rakudo-moar 389998: OUTPUT«$v = Any␤@array = []<>␤»

[22:10] <smls> yeah, looks like Raduko and design docs fundamentally disagree here

[22:11] <smls> So in Rakudo, assignment to the container returned by .[] or .{} is the only condiditon that will cause auto-vivification?

[22:12] <smls> That does seem simpler, though I wonder what the reasoning behind the 09 design was.

[22:12] *** [particle]1 joined
[22:15] *** [particle] left
[22:17] *** itz joined
[22:18] *** amurf joined
[22:19] *** bin_005 left
[22:22] *** pRiVi left
[22:23] *** amurf left
[22:25] *** ggoebel left
[22:27] *** raiph joined
[22:28] *** pRiVi joined
[22:33] *** ShimmerFairy joined
[22:40] *** ggoebel joined
[22:43] *** lizmat joined
[22:52] *** skids joined
[23:15] *** TEttinger joined
[23:15] *** RabidGravy left
[23:20] *** smls left
[23:22] *** amurf joined
[23:34] *** itz left
[23:40] *** roguelazer joined
[23:41] *** virtualsue left
[23:44] <roguelazer> Hello; does anyone know if there’s a convenient way to make $*IN.lines() behave as a Supply?

[23:45] <roguelazer> or, I suppose, to otherwise make stdin interact nicely with all of the promise-based async stuff

[23:48] <roguelazer> $*IN.get() never seems to return if it’s inside a start { } block

