[00:00] *** Peter_R joined
[00:03] <skids> It hovers around 32ish for me.  Might have picked up a second or two.

[00:05] <ShimmerFairy> I would think I have a slower computer than normal, but then I remember my old PPC laptop that towards the end of its life basically couldn't compile rakudo anymore (didn't help that we only had Parrot at the time) :P

[00:07] <flussence> ISTR compiling r-p on my netbook took *at least* 1 hour for CORE.setting... maybe even 2

[00:10] <ShimmerFairy> I'm curious how that laptop would handle moar, but as I recall it doesn't boot up anymore :)

[00:15] *** laouji joined
[00:35] *** BenGoldberg joined
[00:39] *** laouji left
[00:40] *** laouji joined
[00:40] *** laouji left
[00:41] *** laouji joined
[00:46] *** Timbus left
[00:58] *** llfourn joined
[01:02] *** llfourn left
[01:20] *** skids left
[01:33] *** cibs left
[01:35] *** cibs joined
[01:47] *** Timbus joined
[01:48] *** kaare_ joined
[01:54] *** dayangkun joined
[02:01] *** abaugher left
[02:10] *** aborazmeh joined
[02:10] *** aborazmeh left
[02:10] *** aborazmeh joined
[02:26] <flussence> I'm trying to refactor some stuff atm and I'm stumped on this one thing: if I have "unit module Foo;" at the top of a file, what do I need to do to use a "sub MAIN { ... }" in the same file (and have it do its automagic stuff, and call things from Foo)?

[02:31] <flussence> I've made it "module Foo { ... }" and put MAIN at the end, which works. I feel like it ought to be possible to do nicer though...

[02:33] *** gfldex left
[02:36] *** noganex joined
[02:38] *** cognominal_ left
[02:38] *** noganex_ left
[02:48] *** cognominal joined
[02:59] *** llfourn joined
[02:59] <dalek> nqp: a8c8ee4 | hoelzro++ | src/vm/jvm/QAST/Compiler.nqp:

[02:59] <dalek> nqp: Implement with/without for JVM backend

[02:59] <dalek> nqp: review: https://github.com/perl6/nqp/commit/a8c8ee4ff6

[03:00] <dalek> rakudo/nom: 5b6a348 | hoelzro++ | tools/build/NQP_REVISION:

[03:00] <dalek> rakudo/nom: Bump NQP revision to include JVM with[out]? impl

[03:00] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/5b6a348c70

[03:01] *** ugexe joined
[03:03] *** llfourn left
[03:13] *** grondilu left
[03:14] *** grondilu joined
[03:21] *** aristotle joined
[03:22] <aristotle> so I thought I recently saw mention of .contains and something like .starts-with/.ends-with (I think those were called differently) being added to Str, that are basically the boolean version of .index

[03:22] <aristotle> but now I can’t find anything on it any more

[03:22] <aristotle> did I just hallucinate that?

[03:24] <hoelzro> aristotle: I see mention of starts-with on 2015-07-31

[03:25] <hoelzro> and lizmat mentioned .contains on 2015-08-07

[03:26] *** bin_005 joined
[03:30] <b2gills> starts-with and ends-with are in Cool.pm

[03:38] <aristotle> ah

[03:39] <aristotle> is Cool documented anywhere publicly at least with something like a synopsis?

[03:43] *** bin_005 left
[03:43] *** aborazmeh left
[03:44] <dalek> rakudo/nom: f39d115 | hoelzro++ | src/Perl6/Compiler.nqp:

[03:44] <dalek> rakudo/nom: Use :outer_ctx to force Compiler.eval to return a value

[03:44] <dalek> rakudo/nom: 

[03:44] <dalek> rakudo/nom: This fixes Linenoise REPL support

[03:44] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/f39d115ed7

[03:45] *** bin_005 joined
[03:50] *** bin_005 left
[03:53] <flussence> aristotle: I can't find either in perl6/specs, they're in perl6/doc under Str though

[03:54] *** cognominal left
[03:55] <aristotle> thanks. I’ve left my comment now, with bets hedged appropriately:

[03:55] <aristotle> http://blogs.perl.org/users/aaron_baugher/2015/08/refactoring-very-old-perl-5-in-perl-6.html#comment-1612104

[03:57] *** khw left
[04:00] <ShimmerFairy> m: say "ABC".contains("BC")

[04:00] <camelia> rakudo-moar 5b6a34: OUTPUT«Method 'contains' not found for invocant of class 'Str'␤  in block <unit> at /tmp/GgBtTf3AXl:1␤␤»

[04:00] <ShimmerFairy> aristotle: there is no such .contains method

[04:01] <aristotle> so I haven’t caught recent development rights

[04:01] <aristotle> *developments right

[04:02] <flussence> m: say .so with 'ABC'.index('BC')

[04:02] <camelia> rakudo-moar 5b6a34: OUTPUT«True␤»

[04:16] <Sgeo> So, what if some clueless person uses `if' with index instead of `with'?

[04:19] *** firefish5000 joined
[04:19] <ShimmerFairy> same thing that happens in every other language where you forget about position 0 :)

[04:19] <Sgeo> 0 isn't falsey in Haskell

[04:20] <Sgeo> Nor truthy

[04:20] <Sgeo> You need to use actual Bools for if

[04:20] <Sgeo> Smalltalk's similar

[04:21] <ShimmerFairy> languages that eschew the historical meanings of zero and non-zero values wrt boolean logic don't count :)

[04:42] *** pyrimidi_ joined
[04:45] *** pyrimidine left
[04:46] *** b42_ joined
[04:55] <JimmyZ> m: say so 'ABC'.index('A')

[04:55] <camelia> rakudo-moar f39d11: OUTPUT«False␤»

[04:56] <JimmyZ> m: say .so with 'ABC'.index('A')

[04:56] <camelia> rakudo-moar f39d11: OUTPUT«False␤»

[04:56] <Sgeo> m: say defined 'ABC'.index('A')

[04:56] <camelia> rakudo-moar f39d11: OUTPUT«True␤»

[04:56] <Sgeo> Of course, a general "takes a truthiness function and blocks" etc. might be useful

[04:59] <JimmyZ> m: say 'ABC'.index('D')

[04:59] <camelia> rakudo-moar f39d11: OUTPUT«Nil␤»

[04:59] *** llfourn joined
[05:01] *** b42_ left
[05:10] *** mr-foobar left
[05:14] *** davido___ left
[05:16] *** davido___ joined
[05:18] *** BenGoldberg left
[05:20] *** laouji left
[05:20] *** gfldex joined
[05:27] *** cognominal joined
[05:35] *** rurban joined
[05:35] *** laouji joined
[05:42] *** laouji left
[05:43] *** laouji joined
[05:52] *** aborazmeh joined
[05:52] *** aborazmeh left
[05:52] *** aborazmeh joined
[05:59] <TimToady> .tell flussence sub MAIN should certainly work inside unit module Foo, so it's just a plain old bug

[05:59] <yoleaux> TimToady: I'll pass your message to flussence.

[06:01] *** diana_olhovik_ joined
[06:01] *** espadrine joined
[06:08] *** dayangkun left
[06:08] *** fxer joined
[06:12] *** laouji left
[06:13] *** laouji joined
[06:33] *** cognominal left
[06:35] *** maettu joined
[06:40] *** dayangkun joined
[06:46] *** jjido joined
[06:46] <ShimmerFairy> TimToady: I'm wondering, are nqp::with[out] required to call .defined, or could they use nqp::defined() ?  I only ask because as of now you can't use them on plain NQP objects. (I don't need nqp::with[out] to be changed, just something I happened to come across)

[06:51] *** virtualsue joined
[06:54] <nine> .tell japhb thanks, very much appreciated :) It's really conference driven development at its best. I just want my message at YAPC::EU to be "you don't have to know much, just use it!"

[06:54] <yoleaux> nine: I'll pass your message to japhb.

[06:55] <[Tux]> shouldn't this warn?

[06:55] <[Tux]> m: my Int $this = 1; $thıs++; say $this;

[06:55] <camelia> rakudo-moar f39d11: OUTPUT«5===SORRY!5=== Error while compiling /tmp/QgcDsRffJj␤Variable '$thıs' is not declared. Did you mean '$this'?␤at /tmp/QgcDsRffJj:1␤------> 3my Int $this = 1; 7⏏5$thıs++; say $this;␤»

[06:55] <[Tux]> $ perl6 -e'my Int $this = 1; $thıs++; say $this;'

[06:55] <[Tux]> 1

[06:57] <[Tux]> isn't there a command-line switch to force that strictness?

[06:57] <ShimmerFairy> -e runs in 'no strict' mode, so that's just implicitly declaring a new variable on the ++'d one.

[06:58] <ShimmerFairy> [Tux]: perl6 -e 'use strict; ...' or perl6 -Mstrict -e '...'

[06:58] *** aborazmeh left
[06:58] <[Tux]> use v6 also works

[06:59] <ShimmerFairy> [Tux]: and for the record I don't get what the rationale for defaulting to "no strict" _anywhere_ in Perl 6 is :)

[06:59] <[Tux]> but why isn't there a *short* switch for that or even an option to make that default

[06:59] *** SamuraiJack joined
[06:59] <nine> I thought we changed that already

[06:59] <[Tux]> ShimmerFairy, I completely agree

[06:59] <ShimmerFairy> nine: was there discussion?

[07:00] <ShimmerFairy> [Tux]: As far as I'm concerned, Perl 6 has 'use strict' for a reason. You don't get to be sloppy-by-default just because you typed -e :)

[07:00] <[Tux]> that reads to me as contradictive

[07:01] <ShimmerFairy> Sorry, I should've written that as "Perl 6 defaulted to 'use strict' for a reason."

[07:01] <nine> ShimmerFairy: IIRC the topic came up a couple months ago and pretty much everyone was for strictness by default

[07:01] <[Tux]> to that I agree

[07:01] <[Tux]> nine, make it so! :)

[07:02] <ShimmerFairy> [Tux]: your example actually highlights a possible source of errors without strict, and a very frustrating one at that; accidentally confusing some confusable Unicode chars when typing a variable name.

[07:02] <ShimmerFairy> [Tux]: at first I didn't notice that the i was dotless in the second statement :)

[07:02] <Sgeo> m: with "foo".index('z') { say "Huh?" } elsif True { say "Will this work?" }

[07:02] <camelia> rakudo-moar f39d11: OUTPUT«Will this work?␤»

[07:02] <Sgeo> neat

[07:03] *** darutoko joined
[07:03] * [Tux] thinks he's pretty sharp in finding nice examples :)

[07:04] <nine> According to http://irclog.perlgeek.de/perl6/search/?nick=;q=strict it actually came up several times this year alone and I can't find anyone arguing for a lax -e

[07:05] *** brrt joined
[07:06] *** edsc joined
[07:11] *** jkva joined
[07:11] *** dayangkun left
[07:13] <nine> I found clear positive statements about a strict -e by psch, masak, jnthn, nine and Tux so far. I'm not sure what lizmat thinks.

[07:14] *** dayangkun joined
[07:15] <ShimmerFairy> nine: I can't say much since I'm on the "strict" side, but the only justification I can think of is "Someone from P5 might start playing with P6 by using -e and then it's all strict and nooooooo", but that's a very weak argument to me :)

[07:15] <dalek> Inline-Perl5: 64826f1 | (Stefan Seifert)++ | lib/Inline/Perl5.pm6:

[07:15] <dalek> Inline-Perl5: Fix undef warnings in Test::WWW::Mechanize

[07:15] <dalek> Inline-Perl5: 

[07:15] <dalek> Inline-Perl5: We add 'v6.pm' and 'v6/inline.pm' to %INC by setting the hash slots to undef

[07:15] <dalek> Inline-Perl5: to prevent perl from actually trying to find those files.

[07:15] <dalek> Inline-Perl5: Test::WWW::Mechanize::_taintedness has a weird loop, looping over

[07:15] <dalek> Inline-Perl5: qw(/dev/null / . ..), values %INC, $0, $^X to find some taintedness.

[07:15] <dalek> Inline-Perl5: This gives a warning about an undefined $filename caused by our undefs in %INC.

[07:15] <dalek> Inline-Perl5: 

[07:15] <dalek> Inline-Perl5: Set $INC{'v6.pm'} and $INC{'v6/inline.pm'} to '' instead to avoid this.

[07:15] <dalek> Inline-Perl5: review: https://github.com/niner/Inline-Perl5/commit/64826f1db8

[07:16] <brrt> good morning!

[07:16] <nine> Real life code really brings out the strangest issues...

[07:16] *** jkva left
[07:16] <nine> Good morning brrt!

[07:16] *** jkva joined
[07:16] <brrt> good morning nine

[07:17] <brrt> yapc::eu schedule is online \o/

[07:21] <[Tux]> is "Merging GLOBAL symbols failed: duplicate definition of symbol HLL" so difficult to fix? It is still present

[07:22] <[Tux]> OpenSSH-7.0p1 released today (FYI)

[07:22] <nine> |Tux|: I guess everyone is just busy with other things. Haven't seen FROGGS++ around much lately, who would be a candidate. Even lizmat++ seems kind of sparse.

[07:22] <nine> |Tux|: maybe I can have a look at the P6 hackathon if no one beats me. But I have no experience at all with that area of the code.

[07:23] <nine> Oh my, I'm scheduled for 8:30 on the last day :/

[07:24] <[Tux]> I think both FROGGS and lizmat stated they would have a look. There is no hurry, but it hinders me in giving more feedback

[07:26] <[Tux]> test             50000    44.663    44.280

[07:26] <[Tux]> test-t           50000    42.309    41.926

[07:26] <nine> And I'm scheduled next to Stevan Little's "The Intersection of Code and Art". Even I would probably choose his talk

[07:28] <[Tux]> I was once scheduled next to Damien and MJD :(

[07:28] <El_Che> [Tux]: that pretty bad

[07:28] <[Tux]> I had TWO people in the audience and one of them was the time-keeper

[07:28] <[Tux]> we decide to cancel the talk and go to MJD

[07:29] <brrt> 8:30 in the morning? :-o

[07:29] <[Tux]> I had a conversation with that one person at the end of the day

[07:29] * brrt is at 12:00 on wednesday, which is kind of nice

[07:29] <El_Che> I have given talks to small audiences (discourse analysis, not IT) and they were very interesting. More discussion than talk

[07:29] <El_Che> although 1 attendee is the type of talk to move to the bar :)

[07:29] * [Tux] 15:30

[07:30] <[Tux]> El_Che, exactly

[07:30] <[Tux]> I also had prepared a presentation at a workshop. The room was well visited

[07:30] *** pyrimidine joined
[07:30] <JimmyZ> 15:30 here too

[07:30] <[Tux]> when I started, one person asked if I was the one that did configure for perl5

[07:30] <El_Che> like you said, a lot of expternal factors

[07:30] <[Tux]> I replied yes

[07:31] *** ecocode joined
[07:31] <[Tux]> and then they audience asked if I could talk about that instead. WEIRD!

[07:31] <El_Che> hehe :)

[07:32] <nine> Kinda takes the drive out of my preparations

[07:32] *** [Sno] left
[07:33] *** pyrimidi_ left
[07:33] <El_Che> well, perl6 talks out of the echochamber may be like that once released

[07:34] *** laouji left
[07:34] *** laouji joined
[07:37] *** rurban left
[07:38] *** rurban joined
[07:42] <brrt> i'm wondering who will show up at mine...

[07:43] <nine> I will

[07:43] <brrt> :-)

[07:44] <brrt> well, i hope it'll be sufficiently interesting, then

[07:44] <[Tux]> brrt, what is your talk?

[07:44] <brrt> [Tux]: this one http://act.yapc.eu/ye2015/talk/6267 about the moarvm JIT compiler

[07:44] <[Tux]> 12:00 wed - JIT - I signed up for that

[07:44] <brrt> cool

[07:44] *** edsc left
[07:44] <[Tux]> shows as 24 persons attending

[07:45] *** laben joined
[07:45] *** dayangkun left
[07:45] <[Tux]> 25 if you include yourself

[07:45] <laben> hello p6'ers

[07:46] <DrForr> Marnin'.

[07:46] <DrForr> Huh, I'm just before that talk.

[07:46] <laben> i got a question, is UFO still supported or is it deprecated?

[07:47] <laben> i mean this UFO: https://github.com/masak/ufo/

[07:47] <DrForr> Good thing that it wasn't directly up against "modeling mathematical objects with perl", I imagine the crowds are similar.

[07:48] *** jjido left
[07:49] *** tinyblak joined
[07:50] <arnsholt> laben: UFO is deprecated in favour of Panda, I think

[07:51] <laben> arnsholt: mh, that makes packagins seriously challenging

[07:52] *** RabidGravy joined
[07:52] <laben> unless i package the bootstrapped panda, dang

[07:52] <laben> it's just that ufo fails on json-tiny

[07:53] <laben> and i dont understand why

[07:58] <laben> it fails with this: https://gist.github.com/anonymous/03bf7928a4bedbb96730

[07:58] *** dakkar joined
[07:58] <lizmat> [Tux] nine: my answer to the strict / -e question: alias 6='time perl6 -Mstrict -e'

[07:58] <laben> dunno whay it doesnt find the precompiled Actions.pm

[07:59] <[Tux]> lizmat, I also have that in an alias, but only on the machine where I develop Text::CSV

[07:59] <lizmat> I just meant to say I'm in the "strict all the time everywhere" camp  :-)

[07:59] <[Tux]> *we* (all) know how to work around this "issue"

[08:00] <[Tux]> who is against, and what would be their reason/argument?

[08:01] <[Tux]> alias p6="perl6 -I. -Ilib perl6 -Mstrict"

[08:04] *** rindolf joined
[08:05] <laben> wow, i found a way to make it work, but it shouldnt...

[08:05] <nine> lizmat: thanks for clarification

[08:05] <laben> shouldnt 'perl6 -I' give an error?

[08:07] <DrForr> Looks like the p6 track gets the big room this year.

[08:08] *** zakharyas joined
[08:10] *** breinbaas joined
[08:11] <lizmat> laben: $ perl6 -l 

[08:11] <lizmat> No such option -l

[08:12] <laben> not lc(L) but uc(i)

[08:12] <lizmat> $ perl6 -I

[08:12] <lizmat> Option -I needs a value

[08:12] <laben> the one you use to add lib paths

[08:13] <laben> yeah it doesnt give error but the result is not good anyway

[08:13] <dalek> rakudo/nom: bd0871a | lizmat++ | src/core/Cool.pm:

[08:13] <dalek> rakudo/nom: Make position checking robust like with index()

[08:13] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/bd0871ac6c

[08:14] <laben> i dont understant why rakudo doesnt find the file: it's precompiled, in the right dir-tree, freshly done, but it says it cand find it

[08:17] <lizmat> what does it say when you run it with RAKUDO_MODULE_DEBUG=1 ?

[08:18] <laben> right away https://gist.github.com/anonymous/897043c1a560a21b7f62

[08:19] <laben> how come the first path isnt split by ':' ?

[08:19] <dalek> rakudo/nom: 2fec0bd | lizmat++ | src/core/Cool.pm:

[08:19] <dalek> rakudo/nom: Implement Cool.contains

[08:19] <dalek> rakudo/nom: 

[08:19] <dalek> rakudo/nom: This was discussed many times in the past weeks.  I tought I'd bite the

[08:19] <dalek> rakudo/nom: bullet.

[08:19] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/2fec0bd6fb

[08:19] <laben> error in Makefile?

[08:20] <lizmat> that first @*INC entry seems bogus

[08:21] <laben> yea dunno why, it was made by ufo in Makefile

[08:21] <lizmat> ah, perhaps UFO isn't aware of the delimiter change

[08:21] <jnthn> glrd morning, #perl6

[08:21] <laben> what is it?

[08:22] <laben> jnthn: hello there

[08:22] <lizmat> laben: it should be , nowadays

[08:22] <laben> lizmat: ill try asap

[08:22] <lizmat> jnthn o/

[08:23] * lizmat needs to afk to pack for trip to Tokyo

[08:24] <laben> lizmat: PERFECT!

[08:25] <laben> ill work some magiks for the rest then, will someone update ufo or accept a patch?

[08:28] <RabidGravy> it's just send a PR to ufo

[08:29] <JimmyZ> \o jnthn 

[08:35] <jnthn> So...nobody patched glr branch while I left it... :/

[08:35] *** g5 joined
[08:35] <jnthn> skids++ sent me a gist with some patches though

[08:36] <laben> well, PR fix for ufo already exists (from May), just need someone to accept it

[08:37] <laben> there's also one to fix the deprecated use

[08:42] <laben> .tell masak could you please accept the two PR for masak/ufo? it would make my life much easier, thanks :)

[08:42] <yoleaux> laben: I'll pass your message to masak.

[08:45] <jnthn> heh, I broke ($a, $b) = 1, 2;

[08:45] <jnthn> No wonder a lot is bust

[08:46] *** firefish5000 left
[08:48] *** dayangkun joined
[08:51] *** fxer left
[08:59] <jdv79> so, how does one wedge a proxy into an attr

[09:00] <lizmat> my writing the accessot method ?

[09:00] <lizmat> *accessor

[09:01] <lizmat> BTW, hoelzro++ for unbusting the JVM build

[09:01] <jnthn> Binding should do it

[09:01] <jnthn> hoelzro++ # Hacking with JVM without complaining :)

[09:02] <lizmat> although now nativecall on the JVM is pretty busted

[09:02] * jnthn wonders if list assignment really needs a 2-pass algorithm...

[09:03] <jnthn> m: my ($a, $b) = 1, 2; ($a, $b) = ($b, $a); say $a; say $b;

[09:03] <camelia> rakudo-moar 2fec0b: OUTPUT«2␤1␤»

[09:03] <lizmat> $ perl6-j t/04-nativecall/01-argless.t

[09:03] <lizmat> 1..3

[09:03] <lizmat> Unable to execute 'sw_vers'

[09:03] *** [Sno] joined
[09:03] <jnthn> yeah, that case *does* need 2-pass.

[09:05] *** smls joined
[09:06] <lizmat> The root of the problem on JVM atm:

[09:06] <lizmat> $ perl6-j -e 'say $*KERNEL'

[09:06] <lizmat> Unable to execute 'sw_vers'

[09:06] <lizmat>   in block <unit> at -e:1

[09:06] <lizmat> whereas "sw_vers" *is* available and runnable on OS X

[09:07] <lizmat> afk again&

[09:07] *** japhb left
[09:23] *** azawawi joined
[09:23] <azawawi> hi

[09:24] <azawawi> hoelzro: ping

[09:27] <azawawi> .tell hoelzro Regarding yesterday's backlog, the topic was github parsing .pod6 files and how to make your p6 module documentation available on github. Is there anything you needed to discuss with me about it?

[09:27] <yoleaux> azawawi: I'll pass your message to hoelzro.

[09:29] *** espadrine left
[09:29] <jdv79> isnt 2 pass frowned upon?

[09:30] <jdv79> thanks lizmat.  i was trying with attr default.

[09:31] <jdv79> idk why now that i think more on it

[09:31] *** bin_005 joined
[09:31] <lizmat> jdv79: 2 pass is about runtime, nor parsing, in this case

[09:31] <lizmat> aka, making temps for the RHS of the assignment first, and then assigning them

[09:31] <lizmat> so that ($a,$b) = ($b,$a) works

[09:33] <dalek> rakudo/glr: 34a4c0a | jnthn++ | src/core/Any.pm:

[09:33] <dalek> rakudo/glr: Missing join default; b2gills++.

[09:33] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/34a4c0aa9e

[09:33] <dalek> rakudo/glr: b706d2b | jnthn++ | src/core/List.pm:

[09:33] <dalek> rakudo/glr: Re-instate list assignment.

[09:33] <dalek> rakudo/glr: 

[09:33] <dalek> rakudo/glr: This unbreaks 'my ($a, $b) = 1, 2;', which probably unbreaks quite a

[09:33] <dalek> rakudo/glr: lot (including another of the sanity tests). Also changes the error

[09:33] <dalek> rakudo/glr: from compiling Test.pm.

[09:33] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/b706d2b4aa

[09:34] *** iH2O joined
[09:34] <jnthn> Decided to get that working, given the skids++ patch commented out various of them :)

[09:34] *** iH2O left
[09:35] *** TEttinger left
[09:40] *** virtualsue left
[09:40] *** ChoHag joined
[09:44] *** CIAvash joined
[09:44] *** baest_ joined
[09:45] *** baest left
[09:46] *** dayangkun left
[09:49] *** dayangkun joined
[09:52] *** breinbaas left
[09:53] *** espadrine joined
[09:57] *** tinyblak left
[10:01] *** telex left
[10:02] *** telex joined
[10:17] <lizmat> commute to Tokyo&

[10:17] *** lizmat left
[10:23] *** skids joined
[10:26] <ShimmerFairy> m: "abc" ~~ /$<foo> = [<first=alpha> .+]/; say $<foo><first>; say $<first>;

[10:26] <camelia> rakudo-moar 2fec0b: OUTPUT«Nil␤｢a｣␤»

[10:27] <ShimmerFairy> ^ how dumb was I not to know/realize this for way too long? :)

[10:27] *** brrt left
[10:27] *** laouji left
[10:28] *** azawawi left
[10:29] <ShimmerFairy> I'm sure something in S05 would explain it, but why does that regex stored the "first" named thing as $<first> and not $<foo><first> ?

[10:31] <laben> why would you expect $<foo><first> and not $<first>?

[10:31] <jnthn> ShimmerFairy: Because [...] doesn't count as a nested match

[10:31] <ShimmerFairy> Because the <first> capture is captured within $<foo>

[10:31] <jnthn> m: "abc" ~~ /$<foo> = (<first=alpha> .+)/; say $<foo><first>; say $<first>;

[10:31] <camelia> rakudo-moar 2fec0b: OUTPUT«｢a｣␤Nil␤»

[10:32] <ShimmerFairy> jnthn: ah. It should be noted that I usually do $<foo>=(...) in my own code, for some reason I've since forgotten :)

[10:32] <jnthn> Because (...) *is* a nested match :)

[10:32] <laben> ShimmerFairy: there was something amiss

[10:32] <jnthn> So it generates a separate match object.

[10:32] <laben> and jnthn found it :)

[10:32] <ShimmerFairy> jnthn: oh yeah! I decided to stick with $<a>=() in my own code because I wanted $<a> to act like I had written an <a> rule somewhere :)

[10:33] <dalek> rakudo/glr: f9d8459 | jnthn++ | src/core/IO/Handle.pm:

[10:33] <dalek> rakudo/glr: Eliminate gimme use in IO::Handle.print.

[10:33] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/f9d8459750

[10:33] *** skids left
[10:34] <ShimmerFairy> jnthn: I just spent far too much time with perl6 running out of memory or sometimes just locking up (_after_ the core compilation step) because I mistakenly expected $<coeff><int> and $<coeff><frac> to work :P

[10:35] *** skids joined
[10:37] <jnthn> ShimmerFairy: d'oh :)

[10:37] <ShimmerFairy> jnthn: it was really weird, for I time I thought I broke radix_I, but when I reverted my MVM and nqp repos to master and it was still breaking I thought maybe radix_I was always broken ~somehow~ and... argh :)

[10:39] <dalek> rakudo/glr: a16adb8 | jnthn++ | src/core/Array.pm:

[10:39] <dalek> rakudo/glr: It's fine to store non-Any things into Arrays.

[10:39] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/a16adb8f09

[10:39] <dalek> rakudo/glr: b0851b3 | jnthn++ | src/core/io_operators.pm:

[10:39] <dalek> rakudo/glr: Make print subs .Str.

[10:39] <dalek> rakudo/glr: 

[10:39] <dalek> rakudo/glr: Makes things cheaper a layer down.

[10:39] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/b0851b3dc4

[10:40] <dalek> rakudo/glr: e1e908a | jnthn++ | t/01-sanity/08-var-array.t:

[10:40] <dalek> rakudo/glr: This test needs a 'flat' to pass post-GLR.

[10:40] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/e1e908ac56

[10:44] <jnthn> OK, seems the next big blocker is range iteration

[10:57] *** laouji joined
[10:58] *** tinyblak joined
[11:00] *** rurban_ joined
[11:02] *** tinyblak left
[11:05] *** breinbaas joined
[11:12] <dalek> rakudo/glr: 01444dd | jnthn++ | src/core/Range.pm:

[11:12] <dalek> rakudo/glr: Start getting range iteration in place.

[11:12] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/01444ddf02

[11:12] <jnthn> Bloody hell. The slicing code.

[11:21] *** breinbaas left
[11:22] <jnthn> @a[1..2] manage to set up a pipeline 8 iterators deep o.O

[11:22] *** tinyblak_ joined
[11:22] <RabidGravy> wahay!

[11:23] *** CIAvash left
[11:23] * jnthn goes for lunch

[11:25] *** tinyblak_ left
[11:30] *** bin_005 left
[11:30] *** brrt joined
[11:41] <jdv79> seems like too much

[11:45] <smls> jnthn: Does that mean you've decided on a new slice semantic (e.g. the "truncating if known infinite" you speculated earlier)?

[11:46] <smls> Or just trying to bring back the old behavior for now?

[11:53] <timotimo> jnthn: i wanted to look into it a bit, but i ddin't get a sane error message and then i was pulled away from my computer

[11:53] *** japhb joined
[12:13] <jnthn> timotimo: You'll need --ll-exception for the moment

[12:13] <jnthn> smls: Still need to figure things out a bit :)

[12:15] <jnthn> I'm kinda pondering the fate of the .infinite method

[12:16] <jnthn> The whole concept has gone away really

[12:16] <jnthn> But we still have a bunch of code that wants to go introspecting

[12:17] <skids> One thing I saw a possible need for was a ".whatever-you-can-say-about-elems-without-reifying"

[12:18] <jnthn> Reifying isn't a problem

[12:18] <jnthn> It's reifying into a lazy thing that is

[12:18] <jnthn> We already have "deep" reify-until-lazy stuff available

[12:18] <jnthn> But it's in the iterator API

[12:19] <jnthn> And while I was fine using that with .join, and will be for postcircumfix stuff.

[12:19] <jnthn> But that doesn't cover the rest of the use cases.

[12:19] <skids> Right, but if you have a computationally heavy thing that knows how many elems it will produce, but has to work to produce them, it could help with things like ThisSeq ~~ ThatSeq.

[12:20] <skids> (by short-circuiting on a length check)

[12:20] * jnthn wonders what smart-matching a Seq even means :)

[12:20] <skids> Well, [...] ~~ [...] where they are lazy is what I mean.

[12:20] <jnthn> I guess equivalent semantics to "do .list on either side"

[12:21] <jnthn> BTW, I think the slicing *can* flatten the things it's slicing over

[12:21] <jnthn> Because the commonest caess are @a[1..2] style things, or @a[@b]

[12:21] <jnthn> And .flat on those can be almost free

[12:21] <skids> ISRT pmichaud saying "we know we want numbers there so..."

[12:22] <skids> *ISTR (too much RT)

[12:22] <jnthn> Yeah...having slept on it I think DWIM there probably is saneest

[12:23] <jnthn> And I can see how the common cases don't have to be expensive.

[12:23] <jnthn> I *do* think that the type constraint on the postcircumfix:<[ ]> candidates that currently takes Positional needs to start being Iterable instead.

[12:32] <jnthn> m: my @a = 1..10; say @a[5..20]

[12:32] <camelia> rakudo-moar 2fec0b: OUTPUT«6 7 8 9 10␤»

[12:32] <jnthn> m: my @a = 1..10; say @a[1, 5..20]

[12:32] <camelia> rakudo-moar 2fec0b: OUTPUT«2 6 7 8 9 10 (Any) (Any) (Any) (Any) (Any) (Any) (Any) (Any) (Any) (Any) (Any)␤»

[12:32] <jnthn> m: my @a = 1..10; @a[5..20] = 40..60; say @a

[12:32] <camelia> rakudo-moar 2fec0b: OUTPUT«1 2 3 4 5 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55␤»

[12:32] <jnthn> m: my @a = 1..10; (@a[5..20]) = 40..60; say @a

[12:33] <camelia> rakudo-moar 2fec0b: OUTPUT«1 2 3 4 5 40 41 42 43 44␤»

[12:33] * jnthn figured so :)

[12:33] <jnthn> S09 doesn't actually talk about the case of a range inside of a set of subscripts.

[12:34] <jnthn> The last 2 I did are interesting also; they show the lookup/assign discrepancy up nicely.

[12:39] <jnthn> What's also interesting is the current code assumes any infinite thing is monotonic. :)

[12:39] <jnthn> m: my @a = 1..10; say @a[1, 3, 11, 5, * + * ... *];

[12:39] <camelia> rakudo-moar 2fec0b: OUTPUT«2 4␤»

[12:39] <skids> Yeah I would say in the face of that discrepency, better not to autotruncate at all.  Clear case of "if we make that work, this looks broken."

[12:40] <jnthn> Well, I can kinda maybe sorta live with assign and lookup behaving differently.

[12:40] <jnthn> But if we just got and flatten the whole thing and apply the monotic assumption if it's infinite, we'll get other surprises.

[12:41] <jnthn> And infinite is kinda confusing to talk about now too

[12:41] <jnthn> Oh, this is horribly confusing...

[12:43] <jnthn> I wonder what happens if we

[12:43] <jnthn> 1) Grab the iterator for the positions we're to index

[12:43] <jnthn> 2) Do a reify-until-infinite to get the positions, filtering out any where EXISTS-POS returns False

[12:44] <jnthn> s/reify-until-ifinite/reify-until-lazy/

[12:44] <jnthn> Dammit, I really AM going to kill the use of the word infinite in the codebase just stop me seeing it :/

[12:45] <jnthn> 3) For the remaining position that are marked lazy, hand them back until one fails to exist, and then assume it's monotonic beyond that point.

[12:46] *** aramisf joined
[12:46] <jnthn> And for assignment we actually just assume that we really are going to obtain all of the positions, so try to do so, and if you're silly enough to do something infinite there then you get the hang you deserved.

[12:48] <hoelzro> morning #perl6

[12:48] <yoleaux> 09:27Z <azawawi> hoelzro: Regarding yesterday's backlog, the topic was github parsing .pod6 files and how to make your p6 module documentation available on github. Is there anything you needed to discuss with me about it?

[12:49] <hoelzro> .tell azawawi I just wanted to share my experience on the matter.  Pod6 is a bit more complex than Pod, so adding support to GH could be somewhat difficult.  Not that you shouldn't try, of course =) For now I've been generating my README.md via Pod::To::Markdown

[12:49] <yoleaux> hoelzro: I'll pass your message to azawawi.

[12:50] <ShimmerFairy> jnthn: I'm fine with assign and lookup being different. I don't think it's unreasonable to force the user to know that assignment acts differently from a lot of other typical operations :)

[12:50] <skids> .oO(@a[@oddseq] <== ...; @a[@evenseq] <==...; # I think I just hurt my bane) 

[12:51] <ShimmerFairy> (After all, $a = 5 is probably one of the few operations that does something to the Scalar container, instead of what it contains ☺)

[12:52] * jnthn notes that we can do something cheaper when the positions we need are coming out of a range too

[12:53] <jnthn> But I'll code up the general thing first

[12:53] <ShimmerFairy> Er, I think s/operations/operators/ would've been more correct in what I said :)

[12:54] <jnthn> smls: Seems you get your "we don't call .elems, but .EXISTS-POS" wish for slicing; unfortunately, you still need it to support @a[*-2] :)

[12:55] <smls> .list was what it called for slicing

[12:56] <jnthn> Oh

[12:56] <jnthn> OK, that won't be happening :P

[12:56] <smls> .elems, I've made my peace with

[12:56] <jnthn> OK

[12:56] <smls> ok, sounds good

[12:56] <jnthn> Fine, then you'll be some kind of happyish :)

[13:08] *** dayangkun left
[13:12] *** rmgk_ joined
[13:12] *** rmgk is now known as Guest44305

[13:12] *** Guest44305 left
[13:12] *** rmgk_ is now known as rmgk

[13:13] <timotimo> jnthn: even with --ll-exception it was pretty much bullcrap; but what you fixed, array sasignment, sort of explains why the exception seemed so weird-ass confusing

[13:13] <jnthn> grr, but what I suggested will go badly wrong 'cus it doesn't distinguish Ranges from other indexes.

[13:16] <jnthn> How badly do we want @a[0, 2..5] to give the range auto-truncating behavior, and @a[0, |(2..5)] (or @a[0, 2, 3, 4, 5]) to not?

[13:16] <jnthn> And do we want @a[0, (2, 3..5)] also to auto-truncate?

[13:17] <smls> "badly do we want @a[0, 2..5] to give the range auto-truncating behavior" -- it doesnt currenty, I think

[13:17] <jnthn> Yes, I know that ;)

[13:17] <jnthn> I'm asking if we want that.

[13:18] <ShimmerFairy> jnthn: To be honest, I wasn't even aware of auto-truncating behavior until a short while ago, so I clearly don't need it that much :)  (to me, it seems like it's only potentially useful in really common [] uses where manual end-checking would be too tedious)

[13:18] <timotimo> autotrunc was only recently discussed; i'm not sure it was in rakudo for a while before that?

[13:18] <dalek> rakudo/fix-travis: 3621cd7 | hoelzro++ | .travis.yml:

[13:18] <dalek> rakudo/fix-travis: Try to fix Travis tests

[13:18] <dalek> rakudo/fix-travis: 

[13:18] <dalek> rakudo/fix-travis: https://travis-ci.org/rakudo/rakudo currently reports

[13:18] <dalek> rakudo/fix-travis: "This is not an active repository"

[13:18] <dalek> rakudo/fix-travis: review: https://github.com/rakudo/rakudo/commit/3621cd7340

[13:18] <jnthn> Well, we've had it for ranges and sequences if you use them directly until now

[13:19] <timotimo> OK

[13:19] <jnthn> With what I've got, @a[2..5] will auto-truncate, @a[0, 2..5] would not, but curiously @a[0, lazy 2..5] actually would... :)

[13:19] <timotimo> i'll build a fresh rakudo and see how far i get with my "wavy block animation" code :)

[13:19] <smls> jnthn: regardless of @a[0, 2..5], will .[2..5] actually truncate?

[13:19] <smls> I thought you said it would need to be written as .[lazy 2..5]

[13:20] <jnthn> smls: Maybe accidentally ;)

[13:20] <ShimmerFairy> m: my @a = 1,2,3,4,5; say @a[0, ($_ if $_ < +@a for 3..7)] # <-- jnthn: the non-truncating workaround doesn't seem too bad, at least :)

[13:20] <camelia> rakudo-moar 2fec0b: OUTPUT«1 4 5␤»

[13:20] <jnthn> smls: I know I can't get away with *that* though ;)

[13:20] <jnthn> smls: And I don't especially want to.

[13:20] <jnthn> ShimmerFairy: Well, with my current semantics a simple "lazy" before the Range does that for you :)

[13:21] <hoelzro> does anyone know why https://travis-ci.org/rakudo/rakudo might be marked as an inactive repository as far as Travis concerned?

[13:21] <ShimmerFairy> jnthn: ah, even less reason to make sure auto-truncating automagically works beyond the simplest [] use cases! :P

[13:22] *** SamuraiJack left
[13:22] <smls> jnthn: Would it make sense to only truncate if the top-level thing is marked as "strictly lazy" from the start?

[13:23] <jnthn> smls: I don't think people will like having to write @a[lazy 1..10] :)

[13:23] <smls> so only if you add the 'lazyl keyword at the start, or give something that is inherently infinite

[13:23] <jnthn> Really this is about Range wanting to be special.

[13:23] <smls> sequences too, though

[13:23] <smls> .[0, 3, 6, 9 ... *]

[13:24] <ShimmerFairy> .oO('lazy' is an inherently ironic keyword)

[13:24] <jnthn> Yeah, but that one falls out as lazy.

[13:24] <jnthn> Basically, I'm looking for a semantics that will DWIM often enough, not be crazy expensive to implement, and not be uttery unteachable. :)

[13:25] <smls> I woulnd't mind @a[lazy 1..10]  (can also be written as @a[1..10]:v if you only need the ro values)

[13:26] <ShimmerFairy> I would, that's exactly double the number of characters in those brackets as before :)

[13:26] <smls> ....for some non-trivial extra functionality.

[13:29] <ShimmerFairy> I think you could safely make a "just one range argument" version of [] that treats said range as implicitly lazy.

[13:29] <smls> in any case, things like  @a[1..*]  (all except the first) will probably be the most commohn uses of it

[13:29] <jnthn> Aye

[13:29] <smls> for everything else, it would be fine to require extra explicitness imo

[13:29] <jnthn> I think for now I'll:

[13:29] <jnthn> 1) Special-case @a[range here]

[13:31] <jnthn> 2) For everything else, we reify until a lazy thing is encountered, and then that lazy thing will cut off on the first EXISTS-KEY failure

[13:32] <smls> in   .[0, 2, 4, 6 ... *]   will the sequence operator return something that is lazy from the start? wouldn't want the "0, 2, 4, 6" to be non-truncating there.

[13:33] <ShimmerFairy> jnhtn: and then non-lazy things after the lazy thing will reify and behave no differently from reified things before the lazy thing, correct?

[13:35] <smls> I don't think  @a[2..5]  (i.e. non-infinite range) for truncating is that common, which is why i'd be fine with it requiring an explicit lazy prefix or :v adverb.

[13:35] <jnthn> ShimmerFairy: Only if the lazy thing doesn't produce an element that doesn't exist

[13:37] <ShimmerFairy> jnthn: so    my @a = 1,2,3; say @a[0, lazy 2..5, 1]    wouldn't get @a[1] at the end, if I understand correctly?

[13:37] <jnthn> Right

[13:38] <jnthn> If you want us to have things like that work, we're going to have to do something more difficult.

[13:38] <jnthn> I'll levae it up to TimToady to decide

[13:38] <smls> Also, it would be easier to document without the .[2..5] vs .[1, 2..5] inconsistency.

[13:38] <jnthn> I can implement it either way

[13:38] <smls> So I'd prbably drop rule (1).

[13:38] <jnthn> smls: I can tell you that won't happen.

[13:39] <jnthn> Like, almost certain :)

[13:39] <ShimmerFairy> jnthn: seems fair. I'm fine with subscripting not expecting or trying to see if I go back and forth, instead of in one direction :)

[13:39] <jnthn> Won't get past lang design :)

[13:40] *** mr-foobar joined
[13:40] <smls> The thing is, it's a little weird to have one rule that only checks the top-level (Range), and one that may also be encountered in a nested part of the list (lazyness)

[13:41] <ShimmerFairy> I don't think your use of the word "top-level" is appropriate here; makes it sound like you're possibly referring to multi-dim stuff.

[13:42] <smls> i.e. if  .[2..5]  truncates but  .[1, 2..5]  doesn't, maybe  .[1, @something-lazy]  shouldn't either?

[13:45] <smls> TimToady will know.

[13:45] <jnthn> Yeah

[13:45] <jnthn> I'm a bit fed up of it all

[13:45] <jnthn> I didn't want to waste hours of today's GLR time on slice crap

[13:45] <jnthn> But I couldn't leave it alone when it was .gimme this and .infinite that

[13:48] *** aramisf left
[13:53] <hoelzro> nqp::shell is documented as blocking until the process is complete, and returning the exit status of the process.  Now that shell has been expanded to allow piping and background processes, what do others think it should return in case of usage of things like :out ?

[13:54] *** cognominal joined
[13:55] *** aramisf joined
[13:55] *** aramisf is now known as Guest37541

[14:04] *** rurban left
[14:08] <leont> hoelzro: what do you propose?

[14:09] <dalek> rakudo/glr: f5c14a1 | jnthn++ | src/core/ (2 files):

[14:09] <dalek> rakudo/glr: Range and Seq are flat "for free".

[14:09] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/f5c14a1e3e

[14:09] <dalek> rakudo/glr: 23d8e71 | jnthn++ | src/core/List.pm:

[14:09] <dalek> rakudo/glr: Re-instate EXISTS-POS on List.

[14:09] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/23d8e71129

[14:09] <dalek> rakudo/glr: 5546f38 | jnthn++ | src/core/array_slice.pm:

[14:09] <dalek> rakudo/glr: Get array slicing basically working again.

[14:09] <dalek> rakudo/glr: 

[14:09] <dalek> rakudo/glr: Semantic details TBD, but this should handle all the normal things.

[14:09] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/5546f38ebc

[14:09] <leont> Backgrounding makes it impossible to return a wait-status, a PID would make more sense

[14:09] <leont> Redirecting std{in,out,err} shouldn't really affect the return status, right?

[14:10] <leont> Actually, backgrounding has other issues, at least if you want to make it do the POSIXy thing on POSIX systems with regard to signals

[14:11] <timotimo> it's also problematic if you're not reading out of the stderr and stdout streams

[14:11] <timotimo> they're buffered, but not infinitely so, you may deadlock your program

[14:11] <leont> Indeed

[14:11] <leont> Really, redirection kind of only makes sense when not synchronizing that way.

[14:14] <hoelzro> leont: I'm thinking a sentinel value, perhaps -1, in case the process is still runing

[14:14] <hoelzro> *running

[14:14] <leont> But then you don't know which process

[14:15] <hoelzro> the pipe has a reference to the child's PID

[14:15] *** laouji left
[14:15] <leont> Seems rather convoluted to get it from there

[14:16] <hoelzro> it's a bit odd, yes

[14:16] <hoelzro> that's how it currently works, though

[14:16] <hoelzro> but we can always change that =)

[14:16] <hoelzro> we could return the pid with a bitmask set

[14:17] <hoelzro> and add an nqp::wait

[14:17] <leont> I don't think the backgrounding is a good fit with the rest of shell (assuming nqp::shell is mostly like P6's shell)

[14:17] <leont> If you need async, why don't you use a Proc::Async?

[14:18] <hoelzro> I'm just trying to get qx{...}/run/shell working again

[14:19] <hoelzro> we *could* implement qx in terms of P::A, and remove the pipe functionality from run&shell

[14:20] <leont> Where is that pipe functionality documented?

[14:20] <hoelzro> afaik, it's not

[14:20] <hoelzro> it's not in docs/ops.markdown

[14:20] <hoelzro> but Rakudo now relies on it

[14:21] *** lizmat joined
[14:21] <leont> Having something return the output is sensible, and can synchronously. Having something return a stream is rather tricky to get right for the reason timotimo mentioned

[14:21] <leont> s/can/can be done/

[14:21] * lizmat waves from FRA

[14:22] <colomon> \o

[14:22] <brrt> \o lizmat

[14:23] <lizmat> brrt colomon o/

[14:23] <PerlJam> good $localtime all.

[14:24] <hoelzro> ahoy lizmat, PerlJam 

[14:24] <lizmat> PerlJam hoelzro o/

[14:24] <hoelzro> leont: I didn't see timotimo's comment on that; I'll backlog

[14:24] <hoelzro> commute &

[14:25] <leont> The pipe buffer is of limited size (typically 4k), so if the child process writes to it and it is full, it will hang until the other side reads from it

[14:28] *** g5 left
[14:29] <jnthn> o/ lizmat 

[14:29] <jnthn> Hope the journey was fine so far :)

[14:29] <lizmat> yeah...  just the maze that is FRA was the hardest parts so far

[14:29] <jnthn> FRA is...big

[14:30] <lizmat> yeah...  

[14:30] <lizmat> better make a picture of where you parked your car  :-)

[14:32] <PerlJam> hoelzro: I don't think removing the pipe functionality from run/shell is a good idea.  It's a better fit for piped opens ala Perl 5.  (e.g.  open(my $fh, "zcat $filename |") or die; )   Unless, you're also proposing to add that functionality back to P6's open

[14:33] <jnthn> lizmat: ah, you drove the first bit :)

[14:33] <jnthn> lizmat: I'll be flying PRG -> MUC -> Tokyo

[14:33] <lizmat> yeah, I mean, driving to AMS is also 2 hours

[14:33] <lizmat> and FRA for us is 2.5 hours

[14:33] <jnthn> yeah, then you may as well do that

[14:33] <lizmat> and no direct flight from AMS to HND

[14:34] * [Coke] cannot imagine jnthn's crazy schedule. Coke is freaking out just getting prepped for something 2 weeks out!

[14:36] <jnthn> lizmat: ah, you're going to HND too rather than Narita :)

[14:36] <jnthn> lizmat: Staying somewhere near the venue, ooc?

[14:36] <lizmat> yup

[14:38] <jnthn> Cool...me also

[14:38] <jnthn> And flying to HND 'cus it's more convenient for that :)

[14:40] <dalek> rakudo/glr: 5b635cd | jnthn++ | src/core/List.pm:

[14:40] <dalek> rakudo/glr: A correct fix, plus code simplification.

[14:40] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/5b635cd852

[14:40] <dalek> rakudo/glr: d68086f | jnthn++ | src/core/ (2 files):

[14:40] <dalek> rakudo/glr: Ensure storage is allocated for Array.

[14:40] <dalek> rakudo/glr: 

[14:40] <dalek> rakudo/glr: We need this because of the lazy lexical stuff that allocates my @a.

[14:40] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/d68086f2fe

[14:41] <lizmat> jnthn: yup, that was the plan

[14:41] *** zakharyas left
[14:41] <dalek> roast: f7705af | lizmat++ | S32-str/contains.t:

[14:41] <dalek> roast: Add some tests for Cool.contains

[14:41] <dalek> roast: review: https://github.com/perl6/roast/commit/f7705af120

[14:42] <TimToady> we're flying into Kansai

[14:43] <leont> PerlJam: that is essentially an asynchronous execution, but with synchronous IO

[14:43] *** baest joined
[14:44] *** arch_vader joined
[14:44] <brrt> exit

[14:44] *** brrt left
[14:44] *** baest_ left
[14:44] *** davido___ left
[14:45] <hoelzro> leont: I brought that up on #moarvm a few months ago; with the MVM backend (at least), it's not an issue, because MVM is constantly reading from handles hooked up to its event loop in the background

[14:45] <leont> Yeah, that is sensible really

[14:46] <hoelzro> PerlJam: I would rather not, but we would have to if we want to distance ourselves from the implementation warts leont is pointing out

[14:46] *** davido___ joined
[14:46] <hoelzro> but you know what they say about implementors and users ;)

[14:47] <leont> The obvious solution would be to implement the synchronous IO on top of asynchronous, but that may be tricky with bootstrapping

[14:48] <leont> No wait, I'm overly complicating things now

[14:48] <leont> As long as you're doing backgrounding and redirecting together, you should be fine

[14:48] <leont> The zcat scenario is essentially doing that

[14:49] *** andreoss joined
[14:52] <leont> qx makes sense as a backgrounded shell that is then waited upon.

[14:56] * lizmat is enjoying the complimentary sekt

[14:56] *** arch_vader left
[14:57] <dalek> rakudo/glr: b3c5ca3 | jnthn++ | src/core/Array.pm:

[14:57] <dalek> rakudo/glr: Array.new, one-value Array.push and Array.unshift.

[14:57] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/b3c5ca3199

[15:00] <dalek> rakudo/nom: 5342f98 | lizmat++ | t/spectest.data:

[15:00] <dalek> rakudo/nom: Add Cool.contains tests

[15:00] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/5342f98ea3

[15:06] *** CIAvash joined
[15:08] *** tinyblak joined
[15:13] *** skarn joined
[15:14] <jnthn> Hm, after re-instating hash iteration the build gets through to NativeCall before exploding.

[15:14] *** diana_olhovik_ left
[15:16] <dalek> roast: 4587519 | lizmat++ | S02-types/pair.t:

[15:16] <dalek> roast: Add some Pair.new and pair() tests

[15:16] <dalek> roast: review: https://github.com/perl6/roast/commit/4587519a90

[15:18] <xinming> How do we do around modifier just like Moose in perl 6?

[15:19] <dalek> rakudo/glr: dad13fe | jnthn++ | src/core/EnumMap.pm:

[15:19] <dalek> rakudo/glr: Re-instate most forms of hash iteration.

[15:19] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/dad13fe07f

[15:20] <jnthn> xinming: method foo() { ...before stuff...; callsame(); ...after stuff... }

[15:21] *** jkva left
[15:21] <xinming> Ok, so, all methods are around modifiers.

[15:21] <xinming> thanks

[15:22] <lizmat> boarding&

[15:22] *** lizmat left
[15:22] *** khw joined
[15:22] *** tgt joined
[15:23] *** tgt left
[15:26] <timotimo> deepmap calls $o.new(deepmap(op, $o)).item; in this case that seems to be List, which says "default constructor only takes named arguments"

[15:26] <timotimo> so List wants to get a method new that takes positionals?

[15:26] <jnthn> timotimo: yeah, the new is still commented out there

[15:26] <timotimo> ah, yes, indeed

[15:26] <timotimo> what's the lbocker there? p6list?

[15:27] <dalek> rakudo/glr: 1f154fe | jnthn++ | src/core/Array.pm:

[15:27] <dalek> rakudo/glr: Fix missing allocation.

[15:27] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/1f154fe07a

[15:27] <jnthn> p6list is dead

[15:27] <jnthn> Just writing the boring code to make it happen really :)

[15:27] <timotimo> fair enough; where do i cargo-cult from? :)

[15:27] <laben> does someone know a c library contained but still useful to begin experimenting with nativecall? i tried libxml2 for my needs but it's waaaaay too big

[15:28] <timotimo> laben: are you interested in looking at examples? like Cairo or SDL2::Raw perhaps?

[15:28] <timotimo> GTK::Simple is quite big and exercises many features

[15:28] <jnthn> timotimo: I'd do it like method new(**@things) { ...

[15:29] <laben> more like i was interested in makeing a new module, to make new bindings, but all the libs i need to use are immense in scope

[15:29] <timotimo> ah

[15:29] <laben> maybe i should just checkout some already done

[15:29] <jnthn> timotimo: And then grab @things.iterator, make an IterationBuffer, populate that until you hit something lazy, and then if you do set it up as a "reify later"

[15:29] <laben> it's not the same

[15:29] <PerlJam> laben: DBM is small and perhaps useful  :)

[15:29] <TimToady> .tell ShimmerFairy re http://irclog.perlgeek.de/perl6/2015-08-12#i_11042225 the problem with nqp::defined is that it treats Failure.new as defined, and 'with' needs to treat those as undefined

[15:29] <yoleaux> TimToady: I'll pass your message to ShimmerFairy.

[15:29] <jnthn> timotimo: You can actually steal most of that from sub POSITIONS in array_slice.pm

[15:29] <timotimo> thanks!

[15:30] *** araujo left
[15:30] <timotimo> it'll just be filling in $!reified with the values from @things and current-iter and reification target to be empty, yeah?

[15:30] <laben> PerlJam: you mean this? http://www.gnu.org.ua/software/gdbm/

[15:31] <PerlJam> laben: aye

[15:31] <jnthn> timotimo: you'll need to create an IterationBuffer for $!reified

[15:31] <xinming> Is it ok to ask Inline::Perl5 question here?

[15:31] <timotimo> xinming: yeah

[15:31] <xinming> It seems Inline::Perl5 doesn't work with perl 5.20

[15:31] <xinming> Ok

[15:31] <laben> PerlJam: cool, i never even knew it existed, thanks for the mention

[15:31] <xinming> I got the rror

[15:31] <xinming> /lib/perl5/5.22.0/x86_64-linux/CORE/libperl.a(op.o): relocation R_X86_64_32 against `.rodata.str1.8' can not be used when making a shared object; recompile with -fPIC

[15:31] <xinming> But I checked 'perl -V'

[15:32] <xinming> It does have -fPIC

[15:32] <PerlJam> laben: and once you do the native call stuff to make it available in P6-land, you can then figure out how to tie it to a %hash via a trait.  (lots of learning potential there :)

[15:33] <xinming> 5.22

[15:33] <xinming> Not 5.20

[15:33] <laben> PerlJam: well, before i need to learn exactly what can i do with that lib, but thanks for the heads up :)

[15:38] <xinming> How do I check where the problem is please?

[15:40] <dalek> rakudo/glr: 0c47e1a | jnthn++ | src/core/Array.pm:

[15:40] <dalek> rakudo/glr: Cannot fail at a distance, plus another thinko.

[15:40] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/0c47e1a94e

[15:41] *** Guest37541 left
[15:43] *** rurban_ left
[15:43] *** araujo joined
[15:45] <xinming> I'll nopate the whole log

[15:46] *** ChoHag left
[15:47] <timotimo> jnthn: i'm not really sure how .new should behave with regards to LoL-ish argument lists

[15:48] <timotimo> i don't know why, but apparently LoL args will correctly create a nested List already ?!

[15:48] <timotimo> that's cool

[15:48] <xinming> http://paste.scsys.co.uk/496969 <-- This is the error log for 'panda install Inline::Perl5'

[15:49] <dalek> ecosystem: 34d91c3 | RabidGravy++ | META.list:

[15:49] <dalek> ecosystem: Add Audio::Convert::Samplerate

[15:49] <dalek> ecosystem: review: https://github.com/perl6/ecosystem/commit/34d91c3cb6

[15:49] <timotimo> nine probably wants to be highlighted fro this ^

[15:49] <dalek> rakudo/glr: b3aa4ff | jnthn++ | src/core/Iterable.pm:

[15:49] <dalek> rakudo/glr: Missing 'is rw's in various pull-one methods.

[15:49] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/b3aa4ff9bb

[15:50] <jnthn> timotimo: LoL is gone, we just don't do a .flat

[15:50] <jnthn> timotimo: List.new shouldn't flatten

[15:50] <timotimo> oh, cool

[15:50] <timotimo> what do i run to test this?

[15:51] <timotimo> my script that does >>.clone seems to work

[15:51] <timotimo> i just don't understand how with my code a **@ turns into a List with List objects inside :)

[15:51] <timotimo> should i just push?

[15:52] <TimToady> jnthn: but what flattens the lower-level slices in .[1,3..5;2,stuff()]?

[15:53] <TimToady> that's what ** did

[15:53] *** TEttinger joined
[15:54] <dalek> rakudo/glr: 6ed8694 | timotimo++ | src/core/List.pm:

[15:54] <dalek> rakudo/glr: this implementation of List.new(**@) seems to work

[15:54] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/6ed86947bf

[15:54] <timotimo> there you can has a look at it

[15:54] <jnthn> TimToady: We'll need a new type for the ;-separated stuff, I think

[15:54] <TimToady> or recognize it in the parser

[15:54] <jnthn> TimToady: I think that's de-coupled from **@foo now

[15:54] <TimToady> and just call something different

[15:55] <laben> xinming: did you check if you have libperl.so?

[15:57] <jnthn> oh fuck it, git crashed, and indstead of deleting .git/index.lock I deleted .git/index :/

[15:57] <leont> xinming: first guess: you need a shrplib perl (what does 􏿽xABperl -V:useshrplib􏿽xBB return?

[15:57] <jnthn> *sigh*

[15:58] <laben> jnthn: may the google-fu help you fix this problem

[15:59] *** ChoHag joined
[15:59] <timotimo> oops, i was wrong, this doesn't work after all :S

[16:00] *** diana_olhovik_ joined
[16:00] <dalek> rakudo/glr: 826b491 | jnthn++ | src/core/ (2 files):

[16:00] <dalek> rakudo/glr: Seq.sink should return Nil, not self.

[16:00] <dalek> rakudo/glr: 

[16:00] <dalek> rakudo/glr: Otherwise, we'll end up trying to do it twice, which will throw an

[16:00] <dalek> rakudo/glr: exception.

[16:00] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/826b491e57

[16:01] <timotimo> but now i can dive deeper

[16:01] <RabidGravy> now, what shall I do next?

[16:04] <xinming> leont: false

[16:04] <xinming> leont: oops, sorry, wrong compleetion

[16:04] <xinming> leont: false

[16:05] <timotimo> %)

[16:05] <laben> xinming: that's your answer, you need to add " -Duseshrplib" to the ./Configure line when building perl

[16:05] <leont> Without useshrplib, it won't create a libperl.so, so the object files won't be made relocatable

[16:05] <xinming> Alright, Thanks for your info.

[16:05] <xinming> By default, we won't have -Duseshrplib, right

[16:05] <xinming> ?

[16:06] *** rurban joined
[16:06] <RabidGravy> some packagers build it like, some don't - I don't think that "e.g. ./Configure -des" does

[16:06] <laben> xinming: i dont think so, but which distro are you using that doesnt use that flag while building perl?

[16:07] <xinming> It's not distro, It might be because I press the enter to create the perl

[16:07] <xinming> I'll re-compile perl, thanks.

[16:09] *** [TuxCM] joined
[16:09] *** [TuxCM] left
[16:14] <dalek> rakudo/glr: 4036ace | jnthn++ | src/core/traits.pm:

[16:14] <dalek> rakudo/glr: Add a now-needed flat.

[16:14] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/4036ace3b4

[16:14] <dalek> rakudo/glr: e24313c | jnthn++ | lib/NativeCall.pm:

[16:14] <dalek> rakudo/glr: Get rid of an nqp::p6list in NativeCall.

[16:14] <dalek> rakudo/glr: 

[16:14] <dalek> rakudo/glr: We don't need the hack from before because we don't have so much magic

[16:14] <dalek> rakudo/glr: flattening any more.

[16:14] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/e24313c3c9

[16:14] <jnthn> With that, "make" in the glr branch gets all the way through.

[16:16] <nine> xinming: Perl 5.20.0 is even the example used in the Inline::Perl5 README ;) perlbrew install perl-5.20.0 -Duseshrplib

[16:16] <timotimo> way cool, thanks jnthn 

[16:16] <timotimo> that'll make things much more smooth

[16:17] <timotimo> because make install

[16:17] <jnthn> The error reporting without --ll-exception is still broken, but the error has kept changing as I've gone, so it's clearly unbreaking :)

[16:18] <timotimo> :)

[16:19] <timotimo> maybe we should make parsing of comments beginning with # in the rakudo parser faster

[16:20] <timotimo> i bet the increase to parsing time recently comes from all the commented-out lines :P

[16:20] *** ChoHag left
[16:20] <laben> PerlJam: first binding stuff seems to work, exciting times!

[16:22] <timotimo> bleh, method push not found for invocant of type Mu ... with one frame from m-BOOTSTRAP and two with :1 line numbers :(

[16:23] *** ChoHag joined
[16:24] <laben> PerlJam: oops, too easy to be true, i was wrong

[16:25] <PerlJam> laben: It happens  :-)  Share your code with #perl6 when you're comfortable and maybe you can get some pointers about better or different ways to do things.  

[16:26] <dalek> rakudo/glr: f9384f6 | jnthn++ | src/core/Array.pm:

[16:26] <dalek> rakudo/glr: Re-instate pop and shift on Array.

[16:26] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/f9384f6f34

[16:26] <dalek> rakudo/glr: 511c03b | jnthn++ | src/core/CompUnitRepo.pm:

[16:26] <dalek> rakudo/glr: Re-enable some CompUnitRepo setup code.

[16:26] <dalek> rakudo/glr: 

[16:26] <dalek> rakudo/glr: Was commented out because it broke setting loading; now that's fixed.

[16:26] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/511c03bc47

[16:27] *** ChoHag left
[16:28] <laben> PerlJam: sorry, i was wrong about being wrong, i simply wrote down the wrong libname ;P

[16:28] *** ChoHag joined
[16:28] <TimToady> jnthn: I'm fine with your current formulation of slicing, btw, at least for now

[16:29] <laben> but now i need to understand those erro codes

[16:31] <dalek> rakudo/glr: 680fe58 | jnthn++ | src/core/Inc.pm:

[16:31] <dalek> rakudo/glr: Partial re-instatement of @*INC setup.

[16:31] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/680fe58c14

[16:31] *** japhb left
[16:32] <jnthn> TimToady: OK...I'm not sure I am, but we'll live with it for now :)

[16:32] <jnthn> perl6-m -Ilib -e "use Test; ok 1" is really rather close to working now :)

[16:33] <jnthn> It actually spits out the ok 1, then seems to die afterwards. 

[16:34] <jnthn> If I can fix that, we'll be back to being able to run "make spectest", though fixing the sanity tests further is probably more sensible :)

[16:34] <jnthn> Time for a break first, though :)

[16:34] <jnthn> bbl

[16:35] *** ChoHag left
[16:36] *** virtualsue joined
[16:36] *** ChoHag joined
[16:36] *** tinyblak left
[16:41] <flussence> #| TimToady: thanks for the confirmation, I'm not making insane assumptions at least

[16:41] <yoleaux> 05:59Z <TimToady> flussence: sub MAIN should certainly work inside unit module Foo, so it's just a plain old bug

[16:42] <TimToady> though, of course, only if the file is invoked directly, but I verified that doesn't work

[16:43] <flussence> m: module Foo;␤sub MAIN() { say 'foo' }

[16:43] <camelia> rakudo-moar 5342f9: OUTPUT«Saw 1 occurrence of deprecated code.␤================================================================================␤Semicolon form of 'module' without 'unit' seen at:␤  /tmp/hggRXVO707, line 1␤Deprecated since v2015.4, will be removed with releas…»

[16:43] <TimToady> the #| is cute there

[16:43] <flussence> whoops

[16:43] <flussence> :)

[16:43] <flussence> m: unit module Foo;␤sub MAIN() { say 'foo' }

[16:43] <camelia> rakudo-moar 5342f9: ( no output )

[16:43] <flussence> m: sub MAIN() { say 'foo' }

[16:43] <camelia> rakudo-moar 5342f9: OUTPUT«foo␤»

[16:44] <flussence> (it'll take a while to retrain my fingers to type "unit", it seems...)

[16:44] <TimToady> it's lexically scoped, so it shouldn't be misplacing it, unless unit module is adding in a spurious lexical scope

[16:45] <TimToady> m: say MY::.WHICH; unit module Foo; say MY::.WHICH

[16:45] <camelia> rakudo-moar 5342f9: OUTPUT«PseudoStash|54046200␤PseudoStash|54046256␤»

[16:46] <TimToady> unit should not be introducing a new lexical scope, it's just supposed to label the existing file scope

[16:48] <laben> is there a way to make dd correctly dump $var of a class inheriting from repr('CStruct')?

[16:49] *** ChoHag left
[16:50] <TimToady> well, it's open source, so there's always a way... :)

[16:50] <TimToady> I dunno if there's a convenient way though...

[16:53] <laben> is dd code in rakudo, right? not nqp or moarvm?

[16:53] <laben> trying to see how it does its work

[16:55] *** virtualsue_ joined
[16:55] <laben> if it's this src/core/Any.pm:888, then it calls .perl

[16:55] <timotimo> in rakudo

[16:55] <laben> but can i add it to the class but keep it repr of CStruct?

[16:56] *** virtualsue left
[16:56] *** virtualsue_ is now known as virtualsue

[16:57] <timotimo> sure, CStruct can have methods

[16:57] <timotimo> repr is only about storing the internal data

[16:57] <timotimo> the metaobject, the ClassHOW, is in charge of methods and such

[16:57] <dalek> doc: a5267c9 | (Steve Mynott)++ | lib/Type/IO/Notification.pod:

[16:57] <dalek> doc: watch_path is now watch-path and some white space changes

[16:57] <dalek> doc: review: https://github.com/perl6/doc/commit/a5267c94b4

[16:58] <xinming> I know that pre-mature optimization is wrong thing to do. But still curious, Will rakudo be much faster in this X-Mas? :-)

[16:58] <timotimo> the Great List Refactoring has shown good results in preliminary benchmarks

[16:59] <RabidGravy> laben, see for example https://github.com/jonathanstowe/Audio-Sndfile/blob/master/lib/Audio/Sndfile/Info.pm

[17:00] <RabidGravy> but most of those bindings do something similar

[17:00] *** ecocode left
[17:08] *** dakkar left
[17:08] *** beastd joined
[17:08] *** dha joined
[17:08] *** jkva joined
[17:11] *** aramisf joined
[17:11] *** aramisf is now known as Guest39820

[17:13] *** jkva_ joined
[17:14] *** raiph left
[17:15] *** jkva left
[17:16] <dha> So, I was looking at the CONTRIBUTING document, and I was wondering - how strict are we being about using the active voice?

[17:16] <yoleaux> 4 Aug 2015 07:25Z <nine> dha: please merge your 5-to-6 docs into docs.perl6.org. Yesterday I would have had a use for it but couldn't find it.

[17:16] <dha> eep.

[17:17] *** jkva_ left
[17:17] <dha> sorry nine. I'm cleaning them up, and will work on merging them asap.

[17:17] <dha> Speaking of which, any thoughts on said merging, anyone?

[17:18] <dha> Should there be a separate 5->6 directory?

[17:18] <DrForr> dha: Also I sent you a blurb on Facebook, speaking of things.

[17:19] <dha> Ah, yes! Thanks for reminding me. I saw it, but didn't get to doing anything with it yet.

[17:19] <DrForr> The email I remembered for you was out of date.

[17:19] <dha> oh?

[17:19] <DrForr> panix.net.

[17:19] <DrForr> Probably *very* out of date.

[17:21] <dha> No, it's just wrong. :-) It's panix.com. But you can pretty much just use pobox.com nowadays.

[17:22] <timotimo> it kind of seems like we don't annotate nqp:: ops from the source code with line number annotations

[17:22] <timotimo> maybe i can fix that

[17:23] *** zakharyas joined
[17:24] *** jjido joined
[17:25] *** spider-mario joined
[17:26] <smls> dha: A separate directory/category would probably be overkill. Could you make do with a set of docs named  /language/5to6  /language/5to6-variables  /language/5to6-functions  or similar?

[17:27] <timotimo> yes, i apparetnly fixed it

[17:27] <timotimo> this'll help

[17:28] <dha> Sure. I'm just thinking that might - *might* - get a bit unweildy. So far I've got Functions, Operators, Special Variables and Syntax.

[17:28] <dha> But I'll do it as you suggest, and we can always change it later if it turns out to be a problem. Yay!

[17:29] <smls> dha: Syntax could go in the main doc, no? Operators probably too.

[17:29] <dalek> rakudo/glr: a945ce0 | timotimo++ | src/Perl6/Actions.nqp:

[17:29] <dalek> rakudo/glr: ulti-line nqp::ops trees will now give you line numbers

[17:29] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/a945ce0322

[17:30] <smls> dha: Maybe abbreviate the filenames to sth like   5to6, 5to6-var, 5to6-func   to keep them as short as the existing ones

[17:30] <dha> It *could*, but my original intent was to write these as, essentially, replacements for the old Perl 5 docs - perlfunc, perlop, etc. To make things as easy for the Perl 5 programmer to find as possible.

[17:31] <DrForr> And formatted so I can copy/paste into modules :)

[17:31] <dalek> rakudo/nom: 591a147 | timotimo++ | src/Perl6/Actions.nqp:

[17:31] <dalek> rakudo/nom: ulti-line nqp::ops trees will now give you line numbers

[17:31] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/591a1476a0

[17:31] <timotimo> i hope this doesn't break anything

[17:31] <timotimo> i better check

[17:32] <dha> I'm not really sure that the differences between p5 and p6 should be in the main docs, as that seems to me that it would be... cluttered, at best, confusing at worst.

[17:32] *** espadrine left
[17:32] <dha> And, yes, so DrForr can Mogrify. :-)

[17:32] <laben> i implemented method perl(), but it gives me "Cannot look up attributes in a type object"

[17:32] <smls> dha: That's why it would be in the Appendix section in my /language docs structuring plan

[17:33] <geekosaur> laben: a type object is a typed "undef", so somewhere you have something without a value

[17:33] <dha> Right. Which is one of the things that made me think maybe a separate directory under Appendix might be the way to go.

[17:34] <dha> Are there plans to implement the restructuring soon? Because, apparently at least one person would like my docs now. :-)

[17:34] *** jjido left
[17:34] <laben> geekosaur: yea it seems the attributes dont get set by the native funcs, some kind of error

[17:34] <laben> geekosaur: but i would like it to say "undefined" istead of erroring out

[17:35] <PerlJam> laben: show the code :)

[17:36] <smls> dha: dunno, hopefully we'll get it done soon

[17:36] <laben> PerlJam: here it is, https://gist.github.com/anonymous/8960d3e45caad00ec63d

[17:37] <RabidGravy> laben, right so how is it supposed to get created?

[17:37] <RabidGravy> and/or populated

[17:37] <smls> dha: re separate pages: There are dozens of perldoc pages though, you can't (meaningfully) replace all of them... I think it's fine to condense things into the main doc and only have pages for long listings like functions and variables.

[17:37] <laben> i get the struct created directly by the c funcs

[17:38] <RabidGravy> as a return value or a rw argument>

[17:38] <PerlJam> laben: um ... show more code 

[17:38] <laben> for now i get some errors, but i would like to debug them. it would be useful to see when it's undefined

[17:38] <laben> as a return value

[17:39] <laben> PerlJam: the rest are the bindings and 1 line calling a func that gives this struct

[17:39] <dalek> rakudo/glr: d5c28cc | TimToady++ | src/core/Array.pm:

[17:39] <dalek> rakudo/glr: 1st whack at Array.perl

[17:39] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/d5c28cca79

[17:40] <RabidGravy> and you have declared the ... returns datum

[17:40] <dha> True. But some are fairly essential, such as - I would argue - those I've already done. Also, some version of perlre would probably be useful.

[17:40] <laben> RabidGravy: yep, right as they're called in the c code

[17:40] <RabidGravy> laben, by the why nicely volunteered for doing a gdbm binding btw

[17:40] <RabidGravy> show us more code

[17:41] <smls> dha: Right, there's probably quite a bit to document when it comes to regex changes... ;)

[17:41] <laben> well, if it works

[17:41] <dha> But, no, I certainly don't intend to do *all* of the p5 pages.

[17:41] <laben> i think i messed up somewhere greatly

[17:41] <laben> it cant be this hard

[17:41] <PerlJam> laben: it's not :)

[17:41] *** hahainternet joined
[17:42] <dha> perlootut and perlperf, for instance, do not strike me as ripe for conversion.

[17:42] <laben> uhoh, wait, is it called dbm or gdbm?

[17:42] <PerlJam> laben: there are multiple flavors of *dbm, gdbm is one of them. 

[17:42] <hahainternet> in p5, -c seems to catch printing a nonexistent variable, is there an equivalent level of checking in perl6 or am i confused about how perl works? :D

[17:43] <PerlJam> hahainternet: I think you may be slightly confused.

[17:43] <dha> When we get to it, though, we might want to use the old perlfaqs as the skeleton for the new perlfaqs. I'm sure many of the same questions would apply.

[17:43] <dalek> rakudo/glr: 1ede1e3 | (Stefan Seifert)++ | src/core/Inc.pm:

[17:43] <dalek> rakudo/glr: We can actually run more of core/Inc.pm before things explode

[17:43] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/1ede1e3849

[17:43] <RabidGravy> you have something like "sub gdbm_fetch(GdbmFile, datum) returns datum is native('libgdbm')" ?

[17:43] <geekosaur> perl6 should always catch that. make sure you are using the correct quotes though; in a unix-like shell, unquoted or double quoted will see $xxx interpreted by the *shell*before perl ever sees it

[17:43] <geekosaur> hahainternet, ^^

[17:43] <laben> i think i got the old one dangit, only now i see

[17:44] <hahainternet> geekosaur: it catches it but prints it as if it was blank, i'm wondering if there's a way to check ahead of time without actually executing

[17:44] <laben> sorry p6'ers, i wasted some of your time

[17:44] <hahainternet> the syntax check -c in current rakudo doesn't seem to care

[17:44] *** llfourn left
[17:44] <smls> dha: I already started an issue about adding FAQs (https://github.com/perl6/doc/issues/112) and yes, I used the perlfaqs as a guide in my preliminary plan

[17:45] <RabidGravy> labenL no worries, I was actually thinking of doing the gdbm binding recently

[17:45] <timotimo> m: CONTROL { die $_ }; my Str $foo; say "Hello, $foo"

[17:45] <camelia> rakudo-moar 5342f9: OUTPUT«Use of uninitialized value $foo of type Str in string context␤  in block <unit> at /tmp/7KOODuXzs7:1␤␤»

[17:45] <timotimo> m: CONTROL { die $_ }; my Str $foo; say "Hello, $foo"; say "alive"

[17:45] <camelia> rakudo-moar 5342f9: OUTPUT«Use of uninitialized value $foo of type Str in string context␤  in block <unit> at /tmp/lZ3qus9Q3Y:1␤␤»

[17:45] <hahainternet> PerlJam: i welcome elucidation, but no pressure, it's just something i couldn't figure out

[17:45] <timotimo> m:  my Str $foo; say "Hello, $foo"; say "alive"

[17:45] <camelia> rakudo-moar 5342f9: OUTPUT«Use of uninitialized value $foo of type Str in string context  in block <unit> at /tmp/DOOpAIgxQM:1␤Hello, ␤alive␤»

[17:45] <timotimo> m: use fatal; my Str $foo; say "Hello, $foo"; say "alive"

[17:45] <camelia> rakudo-moar 5342f9: OUTPUT«Use of uninitialized value $foo of type Str in string context  in block <unit> at /tmp/e4vY0HuDIP:1␤Hello, ␤alive␤»

[17:45] <hahainternet> interesting, i will go google CONTROL blocks

[17:46] <hahainternet> it seems a bit of a subtle difference between the two -c options, but those examples are clear enough

[17:46] <timotimo> they'll be triggered when a control exception flies by; those are resumable exceptions, which is how - among other things - warnings are implemented

[17:46] <PerlJam> hahainternet: perl 5's -c doesn't catch anything, it's warnings and/or strict that will complain.

[17:47] <RabidGravy> all -c does is compile the code and then exit without running it, on both 5 and 6

[17:47] <PerlJam> hahainternet: *doesn't catch anything with regard to a non-existant variable.

[17:47] <hahainternet> PerlJam: rgr

[17:47] <hahainternet> makes perfect sense

[17:47] <laben> right, the gdbm one has much more info and stuff, i will work on this thing more

[17:48] <laben> seems very interesting

[17:48] <hahainternet> although, i don't understand what use fatal; is doing there

[17:48] <hahainternet> as the output is identical?

[17:48] <hahainternet> i guess that's what timotimo is saying about reusmable

[17:48] *** [Sno] left
[17:49] <laben> see you later

[17:49] *** laben left
[17:51] <dha> smls - ah. Excellent.

[17:51] <dha> But I guess my general point is that, although there will definitely be p5 pages not useful to turn into conversion documents, I'm going to look at all of them to make sure. :-)

[17:52] *** telex left
[17:52] <dha> Ah, Must run. Thanks for the suggestions.

[17:52] *** dha left
[17:54] *** telex joined
[17:54] *** skids left
[17:54] <timotimo> hahainternet: it's about Failure, not about control exceptions

[17:56] <dalek> rakudo/glr: 95e34ac | (Stefan Seifert)++ | src/Perl6/World.nqp:

[17:56] <dalek> rakudo/glr: Bring back initialization of %?INC

[17:56] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/95e34acd52

[17:56] <nine> Hey this is fun :)

[17:56] *** andreoss left
[17:56] <nine> Although I'm a bit nervous as I'm not sure what exactly I'm doing...

[17:56] <hahainternet> timotimo: roger

[17:57] * timotimo figured out method close has a little problem apparently

[17:57] * timotimo is now trying to fix it for /glr

[17:58] *** rurban left
[18:07] <dalek> rakudo/glr: a3d3ae5 | jnthn++ | src/core/Inc.pm:

[18:07] <dalek> rakudo/glr: These bits of Inc.pm are OK too.

[18:07] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/a3d3ae5d53

[18:08] <dalek> rakudo/glr: 41a8fb3 | (Stefan Seifert)++ | src/core/Perl.pm:

[18:08] <dalek> rakudo/glr: Bustage in Version seems to be gone

[18:08] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/41a8fb398e

[18:11] <nine> jnthn: "Cannot assign to an immutable value" seems to be everywhere. Is there any common pattern to look out for?

[18:11] <jnthn> nine: my @; @a[0] = 42; # does this die? :)

[18:12] <nine> jnthn: you mean my @a;?

[18:12] <nine> jnthn: yes, that dies gloriously :)

[18:12] <jnthn> I bet that's a lot of them

[18:12] <jnthn> It's amazing how far you can get without auto-extending array assignment working :D

[18:13] <dalek> rakudo/glr: 63bac99 | jnthn++ | src/core/Array.pm:

[18:13] <dalek> rakudo/glr: Implement multi-value Array.push.

[18:13] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/63bac99776

[18:13] <nine> jnthn: good that you didn't tell me earlier. I'd have never dared to start poking around had I known :)

[18:14] <jnthn> Real programmers don't need to stinkin' assignment statement... :P

[18:14] <dalek> rakudo/glr: b3a4d76 | jnthn++ | src/core/Inc.pm:

[18:14] <dalek> rakudo/glr: More of Inc.pm can come back with .push fix.

[18:14] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/b3a4d76fa8

[18:16] <leont> Probably my entire p6 codebase would work without that, yes :-p

[18:16] <nine> jnthn: why does this seem to help? https://gist.github.com/niner/fe8f0f4df17f84d7e0d5

[18:17] <timotimo> probably because you're overriding the Var inside the array?

[18:17] <jnthn> Uh, is that in map? :)

[18:18] <nine> jnthn: yes

[18:18] <nine> in sequential-map

[18:18] *** zakharyas left
[18:19] <nine> I guess this would be a case where it'd pay off to fully understand containers and binding in Perl 6

[18:19] <jnthn> Yes, your patch is correct

[18:19] <jnthn> Thinko on my part

[18:19] <timotimo> oh, neato

[18:19] <jnthn> nine++ for finding that one

[18:19] <dalek> rakudo/glr: edbc2af | (Stefan Seifert)++ | src/core/Any-iterable-methods.pm:

[18:19] <nine> wwoooohooo :)

[18:19] <dalek> rakudo/glr: Fix one case of Cannot assign to an immutable value

[18:19] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/edbc2afb68

[18:20] <jnthn> dinner; bbiab

[18:21] *** jkva joined
[18:25] *** lucasb joined
[18:27] <_itz>  is the Test module itself broken on glr or something? :)

[18:28] <geekosaur> was certainly expected to be

[18:28] <nine> _itz: I guess it's more like too much brokenness in rakudo itself

[18:29] <geekosaur> glr heavily impacts most of the core, and Test requires a lot of basics to work

[18:30] <_itz> > use Test

[18:30] <_itz> Cannot assign to an immutable value

[18:31] <_itz> oh I'm out of date

[18:31] *** jkva left
[18:33] <_itz> > use Test

[18:33] <_itz> Too few positionals passed; expected 3 arguments but got 0

[18:33] <_itz> I guess something parameter parsing ish

[18:34] <nine> _itz: yes, that's brokenness in the Binder

[18:38] *** dwarring joined
[18:44] *** bin_005 joined
[18:45] <dalek> perl6-roast-data: 8392601 | coke++ | / (9 files):

[18:45] <dalek> perl6-roast-data: today (automated commit)

[18:45] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/83926017f7

[18:48] <dalek> rakudo/glr: d1a5b29 | (Stefan Seifert)++ | src/core/Array.pm:

[18:48] <dalek> rakudo/glr: Try to implement Array::AT-POS(Int)

[18:48] <dalek> rakudo/glr: 

[18:48] <dalek> rakudo/glr: my @a; @a[0] = 42; say @a[0]; works now :)

[18:48] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/d1a5b29d18

[18:54] <nine> jnthn: please have a look at this ^^^ I'm really just stumbling along with no idea if this is in any way correct.

[18:55] * [Coke] wonders if half-tab is a common style in the rakudo core.

[18:55] <timotimo> +            fail X::Cannot::Infinite.new(action => '.unshift to')

[18:55] <timotimo> is that right?

[18:56] <nine> timotimo: definitely not, copy&pasto

[18:56] <timotimo> :)

[18:57] <dalek> rakudo/glr: 9d4099c | (Stefan Seifert)++ | src/core/Array.pm:

[18:57] <dalek> rakudo/glr: Fix copy&pasto noticed by timotimo++

[18:57] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/9d4099c860

[18:57] <nine> [Coke]: same question could be asked about the missing space in: reified,$pos

[18:58] <nine> [Coke]: maybe this would actually be a good time to clean up this code, as git blame is affected already anyway

[18:59] *** bin_005_q joined
[19:01] *** bin_005 left
[19:01] <nine> jnthn: why does my $foo; $foo := try die if False; say $foo.^name; give me a Slip?

[19:02] <jnthn> nine: Because that's what a failed if block evaluates to

[19:02] <jnthn> so .map({ $_ if .is-prime }) style things work

[19:02] <nine> jnthn: so $msg := try ~$msg if defined($msg); is no longer correct in Exception::throw?

[19:02] <jnthn> I think Slip will need to be treated as a kind of Nil though

[19:03] <jnthn> But...it's binding here not assignment

[19:03] <jnthn> m: say (try 1 if False).WHAT

[19:03] <camelia> rakudo-moar 591a14: OUTPUT«Empty␤»

[19:03] <jnthn> m: my $msg := (try 1 if False); say $msg.WHAT

[19:03] <camelia> rakudo-moar 591a14: OUTPUT«Empty␤»

[19:04] <jnthn> Empty in the GLR is an empty Slip

[19:04] <leont> How should I put a binary zero byte in a string? "\0"?

[19:04] <jnthn> m: say ord("\0")

[19:04] <camelia> rakudo-moar 591a14: OUTPUT«0␤»

[19:04] <jnthn> Indeed

[19:04] *** spider-mario left
[19:04] <leont> Ah

[19:04] <leont> m: say ord("\x01")

[19:04] <camelia> rakudo-moar 591a14: OUTPUT«1␤»

[19:04] <leont> m: say ord("\x011")

[19:04] <camelia> rakudo-moar 591a14: OUTPUT«17␤»

[19:05] <leont> m: say ord("\x01111111")

[19:05] <camelia> rakudo-moar 591a14: OUTPUT«17895697␤»

[19:05] <leont> m: say ord("\x{01111111}")

[19:05] <camelia> rakudo-moar 591a14: OUTPUT«5===SORRY!5=== Error while compiling /tmp/v0A9Jhx7hs␤Unsupported use of curlies around escape argument; in Perl 6 please use square brackets␤at /tmp/v0A9Jhx7hs:1␤------> 3say ord("\x{7⏏0501111111}")␤»

[19:05] <leont> m: say ord("\x[1111111]")

[19:05] <camelia> rakudo-moar 591a14: OUTPUT«17895697␤»

[19:05] <nine> jnthn: should I change it to if defined($msg) { $msg := try ~$msg; } then?

[19:05] <leont> Nice error :-)

[19:06] <jnthn> nine: Can do, I'm surprised we got away with it before

[19:06] <leont> m: say ord("\x0b")

[19:06] <camelia> rakudo-moar 591a14: OUTPUT«11␤»

[19:07] <dalek> rakudo/glr: 6c45969 | (Stefan Seifert)++ | src/core/Exception.pm:

[19:07] <dalek> rakudo/glr: Fix "This type cannot unbox to a native string" in Exception::throw

[19:07] <dalek> rakudo/glr: 

[19:07] <dalek> rakudo/glr: try ~$msg if defined($msg); returns a Slip now for which the error message is

[19:07] <dalek> rakudo/glr: indeed correct.

[19:07] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/6c459694b7

[19:07] *** [Sno] joined
[19:07] <jnthn> nine: I'd say that AT-POS isn't quite right there

[19:08] <nine> jnthn: I'd have been quite surprised if it were otherwise :)

[19:08] <jnthn> But yeah, I can see it'll work for the basic cases :)

[19:11] *** skids joined
[19:15] <nine> It also breaks .isa

[19:16] <jnthn> "it"?

[19:16] <nine> My AT-POS implementation

[19:16] <jnthn> ah :)

[19:16] <jnthn> I've got a tweaked one to try out

[19:16] <nine> With it 01-sanity/17-isa.t dies with X::Multi::Ambiguous exception produced no message

[19:19] *** zakharyas joined
[19:20] <nine> But I guess it's the mere precense of AT-POS that's the issue

[19:23] <jnthn> Will see if my patch fixes it

[19:23] <jnthn> compiling now :)

[19:23] *** CIAvash left
[19:23] *** fxer joined
[19:28] *** spider-mario joined
[19:29] <jnthn> nine: 17-isa.t passes with my patch so I guess I made things better somehow :)

[19:29] <nine> yeah :)

[19:30] <nine> Curious what it looks like

[19:31] <dalek> rakudo/glr: c629eb7 | jnthn++ | src/core/Array.pm:

[19:31] <dalek> rakudo/glr: Improve Array.AT-POS.

[19:31] <dalek> rakudo/glr: 

[19:31] <dalek> rakudo/glr: Split it into fast path and slow path like List.AT-POS, add the int

[19:31] <dalek> rakudo/glr: candidate, and properly handle laziness.

[19:31] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/c629eb7a56

[19:31] <jnthn> OK, I need to try and fill out some more of the missing slides for my YAPC::Asia talk, so the interpreter has an idea what I'll be talking about. :)

[19:34] *** tinyblak joined
[19:37] *** breinbaas joined
[19:38] *** tinyblak left
[19:38] *** jkva joined
[19:40] <nine> Btw. --ll-exception is no longer needed to get useful exception messages :)

[19:40] <jnthn> \o/

[19:41] *** llfourn joined
[19:41] *** espadrine joined
[19:41] <timotimo> i've made nqp::ops have a line number and such, too!

[19:42] *** mlei joined
[19:43] *** mlei left
[19:45] *** llfourn left
[19:46] *** fxer left
[19:46] <timotimo> which of the many things we have now will cause a List to be fully reified?

[19:46] <timotimo> well, currently the thing starts with .List, so maybe that wants to be changed, too?

[19:49] *** japhb joined
[19:51] <[Coke]> ARGH. I waited a day to book my flights to SPW to insure I could find my passport. Go to book flight - 300USD increase.

[19:51] <PerlJam> ouch.

[19:51] <timotimo> is "gimme" dead in GLR?

[19:51] <timotimo> seems so

[19:51] <PerlJam> timotimo: I think jnthn said as much earlier today

[19:52] <timotimo> so perhaps everything that uses "gimme" at the moment may want to be commented out or something?

[19:52] <nine> Seems like. A lot already is

[19:53] <PerlJam> oops, no it was 2 days ago ... http://irclog.perlgeek.de/perl6/2015-08-10#i_11032421

[19:53] <jnthn> Well, no point commenting ones that explode...

[19:53] <jnthn> It's pretty clear we need to fix them

[19:54] <jnthn> Replacing the use of gimme with a die isn't much help

[19:54] <timotimo> right

[19:54] <jnthn> timotimo: .elems will fully reify a list but...be sure you really want to do that

[19:54] <timotimo> in nodemap, which is used for HYPER, yeah :)

[19:54] <timotimo> we do want that

[19:55] <timotimo> ideally, i'd somehow translate the thing to use .hyper.map or something

[19:55] <DrForr> [Coke]: If you haven't booked yet, delete cooies and cache, and try again. Airlines do track.

[19:55] <[Coke]> DrForr: sneaky!

[19:55] *** bin_005_q left
[19:56] *** bin_005_q joined
[19:56] <jnthn> timotimo: I suspect we only want to parallelize at the first level, at least initially

[19:56] <jnthn> timotimo: I'd leave that out though for now

[19:56] <jnthn> timotimo: Let's get things basically working again, then switch on the parallelism

[19:57] <jnthn> Especially as I didn't finish it yet really :)

[19:57] <timotimo> yeah, adding .elems made it work again <3

[19:57] <timotimo> um, no

[19:57] <timotimo> i replaced >>.clone with .hyper.map: *.clone

[19:58] <timotimo> in my code

[19:59] <jnthn> That's not the same though :)

[19:59] <jnthn> hyper goes deep

[19:59] <jnthn> uh, >>.clone goes deep

[19:59] <jnthn> .hyper doesn't mean that

[19:59] <jnthn> But I didn't really implement .hyper yet, only .race

[19:59] <jnthn> So it'll dis-order your stuff if you try it

[19:59] <timotimo> yeah

[19:59] <timotimo> oh, i didn't know that

[20:00] <timotimo> well, without .hyper the code works, too

[20:00] <nine> Oh: my ($a, $b) := 1, 2; gives Too few positionals passed; expected 2 arguments but got 0

[20:01] <jnthn> nine: I'll bet it's 'cus List.Capture ain't been re-implemented yet

[20:07] <timotimo> my @grid   = (^2).roll(COLS).List xx ROWS;

[20:07] <timotimo> trying to @grid[1][1] = 5 gives me "cannot modify an immutable Int"

[20:07] <timotimo> how come no containers get created here?

[20:08] <timotimo> oh

[20:08] <timotimo> because List not Array

[20:08] <timotimo> my code runs!

[20:08] <timotimo> ohmygosh

[20:10] <dalek> rakudo/glr: 1fd4619 | (Stefan Seifert)++ | src/core/List.pm:

[20:10] <dalek> rakudo/glr: Bring back List.Capture()

[20:10] <dalek> rakudo/glr: 

[20:10] <dalek> rakudo/glr: my ($a, $b) := 1, 2; works with this

[20:10] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/1fd4619435

[20:10] <nine> jnthn: a look at this can't hurt ^^^

[20:12] <jnthn> nine: Works for me. :)

[20:12] <nine> nice :)

[20:12] <jnthn> I love how we can just share $!reified safe in the knowledge nothing will mutate it :)

[20:12] <jnthn> Oh

[20:12] *** brrt joined
[20:13] <jnthn> But now you perhaps need to do an override in Array that does an nqp::clone of it

[20:13] <jnthn> Or we could just say that's erroneous

[20:13] <jnthn> You tend to consume the .Capture immediately anyway

[20:13] <timotimo> WHAT STARTS WITH THE LETTER C?

[20:13] <timotimo> Capture! OM NOM NOM!

[20:23] <timotimo> jnthn: should i rather build push-at-least or push-exactly for Range's Int Iterator?

[20:23] *** darutoko left
[20:23] <timotimo> apparently currently for'ing a range gives us sink -> sink-all -> pull-one

[20:23] *** diana_olhovik_ left
[20:25] <jnthn> timotimo: Actually for loops have to pull-one since they only want one value at a time; they've no buffer :)

[20:26] <dalek> rakudo/glr: bbfb4a1 | (Stefan Seifert)++ | src/core/Cool.pm:

[20:26] <dalek> rakudo/glr: Somewhat unbreak sprintf

[20:26] <dalek> rakudo/glr: 

[20:26] <dalek> rakudo/glr: This lets CompUnitRepo get along a step further.

[20:26] <dalek> rakudo/glr: However a perl6 -e 'sprintf "%d", 1;' still fails :/

[20:26] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/bbfb4a150c

[20:26] <nine> I really should get some nom now...

[20:26] <jnthn> git checkout nom # there :)

[20:26] <jnthn> timotimo: We do want to implement push-exactly and push-at-least for Range's iterator though, so my @a = 1..10; can push the lot :)

[20:27] <jnthn> timotimo: push-at-least can check if the number given to it is less than, say 256, and if so push-exactly with 256

[20:27] <jnthn> timotimo: So you only have to do the hard work once :)

[20:28] <jnthn> (as in, implement the loop in one method)

[20:32] *** rurban joined
[20:37] *** lucasb left
[20:37] *** zakharyas left
[20:41] <RabidGravy> Hmm, maybe PortMidi next - an area that needs exploring

[20:41] *** llfourn joined
[20:41] <RabidGravy> then we can haz noise

[20:46] *** llfourn left
[20:46] *** jkva_ joined
[20:49] *** jkva left
[20:51] <timotimo> cool

[20:51] <timotimo> i just picked up my name tag

[20:52] <timotimo> it can say "hello my name is timo" on any radio frequency from 50 MHz to 4000 MHz

[21:03] *** bin_005_q left
[21:03] *** bin_005 joined
[21:07] *** jkva_ left
[21:08] *** brrt left
[21:10] *** muraiki left
[21:18] <_itz>  ccc?

[21:18] <timotimo> yup

[21:18] <timotimo> this year the "name badge" is actually a software defined radio :)

[21:19] <_itz> nice

[21:19] <timotimo> last year the badge was already rf-enabled, but limited to one frequency and i think also with a pre-defined protocol (which could probably be replaced via a firmware flash)

[21:21] <dalek> rakudo/glr: 3f0557c | PerlJam++ | src/core/List.pm:

[21:21] <dalek> rakudo/glr: Take a whack at List.perl

[21:21] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/3f0557cfd4

[21:24] *** espadrine left
[21:33] <RabidGravy> whack it real good!

[21:36] *** rindolf left
[21:40] * jnthn is happy to see plenty of folks jumping into the glr hacking :)

[21:40] *** Guest39820 left
[21:42] <dalek> rakudo/glr: 58ae243 | (Stefan Seifert)++ | src/core/Signature.pm:

[21:42] <dalek> rakudo/glr: Unbust Signature!gistperl

[21:42] <dalek> rakudo/glr: 

[21:42] <dalek> rakudo/glr: self.params is now an immutable List.

[21:42] <dalek> rakudo/glr: .Array that to keep .shift working

[21:42] <dalek> rakudo/glr: 

[21:42] <dalek> rakudo/glr: Allows at least some exceptions to show their message

[21:42] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/58ae243620

[21:45] *** labster left
[21:46] *** labster joined
[21:47] *** yqt joined
[21:53] *** aiden joined
[21:53] <aiden> hello

[21:53] <hoelzro> greetings aiden 

[21:56] *** aiden left
[21:59] *** geraud joined
[21:59] <nine> Ok, no more progress today. But this was fun!

[21:59] <nine> Good night all :)

[22:00] <jnthn> 'night nine o/

[22:01] <geraud> m: say "a\nb\nc\n".lines.elems;

[22:01] <camelia> rakudo-moar 591a14: OUTPUT«3␤»

[22:02] <timotimo> nighty nine!

[22:24] *** yqt left
[22:24] *** bin_005 left
[22:28] <japhb> .botsnack

[22:28] <yoleaux> 06:54Z <nine> japhb: thanks, very much appreciated :) It's really conference driven development at its best. I just want my message at YAPC::EU to be "you don't have to know much, just use it!"

[22:28] <yoleaux> :D

[22:29] <timotimo> jnthn: could it be we're takeclosure-ing a whole bunc hwhen we have a "my class" inside a method?

[22:29] <timotimo> er, wait

[22:29] <timotimo> yeah

[22:30] <timotimo> a huge number of BOOTCode get allocated with the line number pointing at the "class :: does Iterator {" line inside method iterator inside class List

[22:30] <leont> Type junctions don't work yet?

[22:30] <timotimo> yeah it still uses gimme(*)

[22:31] <leont> I'm using Foo|Bar, and it's giving me "Missing block" errors

[22:31] *** breinbaas left
[22:31] *** smls left
[22:31] <timotimo> oh

[22:31] <timotimo> type junctions!

[22:31] <timotimo> they have been thrown out

[22:32] *** smls joined
[22:32] *** ilbelkyr is now known as bcode

[22:33] <leont> Bummer

[22:33] <timotimo> can still have them with a subset

[22:34] *** yqt joined
[22:36] <leont> Like explicitly? subset Baz of Any where .does(Foo) || .does(Bar) ?

[22:36] <jnthn> timotimo: I hope not, and if it is then I'll be fixing it, because there ain't any closures there. :)

[22:36] <timotimo> yeah

[22:36] <timotimo> potentially the line number is just wrong

[22:37] <jnthn> subset Baz where any(Foo, Bar); may well be enough

[22:37] <jnthn> I *think* Any is the default base type for a subset

[22:37] <timotimo> anyway, i found i was allocating 50k unncessary Scalar objects because Num.ACCEPTS has $a for the other instead of \a

[22:37] <jnthn> Heck, subset Baz where Foo|Bar; probably works

[22:37] <timotimo> should, yeah

[22:37] <leont> Right

[22:37] <leont> Kind of makes sense

[22:38] * timotimo spec tests with the Numeric.ACCPEPTS change

[22:42] *** llfourn joined
[22:42] <Sgeo> Why are type junctions gone?

[22:44] <jnthn> We never actually had them

[22:44] <jnthn> Unless you count speculated about in design docs

[22:44] <Sgeo> That where doesn't help if you want to accept Failures and some other type normally, or Failures and Junctions but not unanticipated non-Any things in the future

[22:45] <jnthn> They're probably not ruled out forever, but they bring up some interesting issues with multi-dispatch, iirc. And we already have too much to do.

[22:46] <jnthn> So, not this side of 6.christmas.

[22:47] <Sgeo> ok

[22:47] *** llfourn left
[22:47] <jnthn> The big question is if they should work as nominal types or constraitn types

[22:47] <jnthn> *constraint

[22:48] <jnthn> And the latter is easier, but equivalent to the "where"

[22:48] <Sgeo> Ah

[22:48] <jnthn> Which means they'd only tie-break in multi-dispatch

[22:48] <jnthn> So better to reserve the syntax until we have time to make good decisions about it.

[22:49] <Sgeo> Makes sense

[22:49] <dalek> rakudo/nom: 98df934 | timotimo++ | src/core/Numeric.pm:

[22:49] <dalek> rakudo/nom: avoid allocating a scalar for Numeric.ACCEPTS

[22:49] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/98df934b82

[22:51] *** virtualsue left
[22:53] *** rurban left
[22:53] <RabidGravy> I thought I'd seen  "where Fii|Bii" in the world

[22:54] <RabidGravy> in HTTP::UserAgent

[22:54] <RabidGravy> sub get($target where URI|Str)

[22:54] *** Psyche^_ joined
[22:55] <smls> the RHS of 'where' is an arbitrary expression (to be smart-matched against), not a type spec

[22:55] <jnthn> Right :)

[22:57] <RabidGravy> it was more agreeing that the explicit any wasn't required

[22:58] *** Psyche^ left
[22:59] <leont> Why does JSON::Tiny use .flatmap here: https://github.com/moritz/json/blob/master/lib/JSON/Tiny.pm#L46 ?

[22:59] <leont> And how does that relate to the GLR?

[23:02] <jnthn> No idea; a hash doesn't have a way to not be flat...

[23:03] <leont> Not sure it's correct for the positional case either

[23:03] <jnthn> No, same here

[23:03] <jnthn> The GLR does get rid of almost all implicit flattening

[23:04] <jnthn> my @a = @b, @c; # @a has two elements, for example

[23:04] <jnthn> But I don't see how that affects the hash case

[23:04] *** RabidGravy left
[23:05] <jnthn> And yeah, a bit dubious on the positional one too :)

[23:05] <jnthn> And it's a bit odd for a serializer to be trying to flatten the data structure you gave it.

[23:06] <jnthn> I mean, you should give it the data structure you want serialized.

[23:06] <jnthn> So I'd probably lean to turning those two into map

[23:11] <jnthn> sleep &

[23:11] <timotimo> gnite jnthn :)

[23:12] *** smls left
[23:22] <timotimo> this script bails 16 frames in total due to setcodeobj being encountered

[23:58] *** yqt left
[23:59] <skids> m: my @a = 1..*; @a.unshift(1); # rationale?

[23:59] <camelia> rakudo-moar 98df93: OUTPUT«Cannot push to an infinite list␤  in block <unit> at /tmp/07Na8gD92v:1␤␤Actually thrown at:␤  in block <unit> at /tmp/07Na8gD92v:1␤␤»

