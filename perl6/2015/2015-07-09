[00:02] *** vendethiel joined
[00:19] *** anaeem1 left
[00:26] *** vendethiel left
[00:33] *** gcole left
[00:34] *** kanl left
[00:39] *** laouji joined
[00:40] *** telex left
[00:42] *** telex joined
[00:43] *** laouji left
[00:45] <dalek> rakudo-star-daily: 91d64f4 | coke++ | log/ (8 files):

[00:45] <dalek> rakudo-star-daily: today (automated commit)

[00:45] <dalek> rakudo-star-daily: review: https://github.com/coke/rakudo-star-daily/commit/91d64f48f9

[01:04] *** Ben_Goldberg joined
[01:06] *** BenGoldberg_ joined
[01:07] *** aborazmeh joined
[01:07] *** aborazmeh left
[01:07] *** aborazmeh joined
[01:07] <[Coke]> in backlog, but years ain't dates. they're years.

[01:07] *** davido___ left
[01:09] *** davido___ joined
[01:10] *** Ben_Goldberg left
[01:13] *** khw joined
[01:14] *** rmgk is now known as Guest20935

[01:14] *** rmgk_ joined
[01:14] *** Guest20935 left
[01:14] *** rmgk_ is now known as rmgk

[01:16] *** vike1 left
[01:23] *** vendethiel joined
[01:23] *** colomon left
[01:24] *** vike joined
[01:25] *** gfldex left
[01:29] *** leont left
[01:33] *** Peter_R left
[01:34] *** colomon joined
[01:35] *** Peter_R joined
[01:40] *** yeahnoob joined
[01:45] *** vendethiel left
[01:49] *** dayangkun joined
[01:50] *** dayangkun left
[01:54] *** roguelazer left
[01:57] *** dayangkun joined
[01:58] *** araujo_ joined
[02:00] *** dayangkun left
[02:00] *** vendethiel joined
[02:00] *** dayangkun joined
[02:01] *** araujo left
[02:02] *** dayangkun left
[02:04] *** dayangkun joined
[02:07] *** TEttinger left
[02:12] *** araujo_ left
[02:12] *** araujo__ joined
[02:12] *** araujo__ left
[02:12] *** roguelazer joined
[02:13] *** araujo__ joined
[02:14] *** colomon left
[02:17] *** noganex_ joined
[02:18] *** atroxaper joined
[02:19] *** colomon joined
[02:20] *** noganex left
[02:22] *** vendethiel left
[02:23] *** atroxaper left
[02:24] *** raiph joined
[02:24] *** vendethiel joined
[02:32] *** BenGoldberg joined
[02:34] *** BenGoldberg_ left
[02:40] *** geekosaur left
[02:41] *** geekosaur joined
[02:47] *** colomon left
[02:48] *** tinyblak_ joined
[02:50] *** vendethiel left
[02:51] *** TEttinger joined
[02:52] *** tinyblak left
[03:02] *** kanl joined
[03:04] <kanl> is "is copy" only applicable to scalars? or does it depend on .clone to copy-by-value?

[03:06] *** colomon joined
[03:06] <kanl> sub foo( @f is copy ) { @f.shift } my @f = 1 .. 3; foo( @f ); @f.say;

[03:06] <kanl> m: sub foo( @f is copy ) { @f.shift } my @f = 1 .. 3; foo( @f ); @f.say;

[03:06] <camelia> rakudo-moar 377672: OUTPUT«5===SORRY!5=== Error while compiling /tmp/2jkzKeW2pJ␤Strange text after block (missing semicolon or comma?)␤at /tmp/2jkzKeW2pJ:1␤------> 3sub foo( @f is copy ) { @f.shift }7⏏5 my @f = 1 .. 3; foo( @f ); @f.say;␤    expecting any of:␤   …»

[03:07] <kanl> sub foo( @f is copy ) { @f.shift }; my @f = 1 .. 3; foo( @f ); @f.say;

[03:08] <kanl> ok. 

[03:10] *** vendethiel joined
[03:11] <BenGoldberg> m: (-> @f is copy { @f.shift })( 1 .. 3 ).say;

[03:11] <camelia> rakudo-moar 377672: OUTPUT«1␤»

[03:11] <BenGoldberg> m: (-> @f is copy { @f.shift })( 'a' .. 'c' ).say;

[03:11] <camelia> rakudo-moar 377672: OUTPUT«a␤»

[03:12] *** roguelazer left
[03:12] <BenGoldberg> m: (-> @f { @f.shift })( 'a' .. 'c' ).say;

[03:12] <camelia> rakudo-moar 377672: OUTPUT«Method 'shift' not found for invocant of class 'Range'␤  in block <unit> at /tmp/wObdPAtp49:1␤␤»

[03:16] *** khw left
[03:16] <kanl> so apparently 'is copy' does not depend on .clone..

[03:17] *** TimToady left
[03:18] *** BenGoldberg left
[03:19] *** kaare_ joined
[03:19] *** TimToady joined
[03:25] *** geekosaur left
[03:26] *** geekosaur joined
[03:30] *** nys left
[03:34] *** vendethiel left
[03:40] *** pierrot joined
[03:42] *** vendethiel joined
[04:16] *** laouji joined
[04:21] *** laouji left
[04:28] *** vendethiel left
[04:34] *** diana_olhovik_ joined
[04:37] *** vendethiel joined
[04:47] *** [Sno] left
[04:53] *** skids left
[05:07] *** atroxaper joined
[05:11] *** atroxaper left
[05:19] *** aborazmeh left
[05:20] *** vendethiel left
[05:21] *** atroxaper joined
[05:23] *** diana_olhovik_ left
[05:27] *** vendethiel joined
[05:46] *** araujo__ left
[05:47] *** araujo__ joined
[05:49] *** vendethiel left
[05:50] *** araujo__ left
[05:50] *** araujo joined
[05:51] *** vendethiel joined
[06:00] *** diana_olhovik_ joined
[06:00] *** brrt joined
[06:05] *** [Sno] joined
[06:14] *** rurban joined
[06:15] *** vendethiel left
[06:16] *** diana_olhovik_ left
[06:17] *** WABM9Q9 joined
[06:18] *** brrt left
[06:18] *** salva joined
[06:20] *** anaeem1_ joined
[06:21] *** zacts joined
[06:26] *** kurahaupo left
[06:26] *** kurahaupo joined
[06:26] *** FROGGS joined
[06:33] *** vendethiel joined
[06:35] <jdv79> why is the CUR part so complex?

[06:36] <masak> morning, #perl6

[06:37] <masak> jdv79: "the CUR part"?

[06:38] <jdv79> the finding and loading of comp units

[06:38] <jdv79> (CompUnitRepo)

[06:38] <masak> kanl: no, `is copy` does not clone the underlying object. it makes a copy of the reference. since a new reference to the same object will behave just like the old reference, I consider `is copy` on reference types to be pretty useless.

[06:38] *** kanl left
[06:38] *** btyler joined
[06:39] *** kanl joined
[06:39] <masak> jdv79: I think because it is trying to allow (a) Unicode module names that are not necessarily supported by the underlying file system, and (b) auths and versions.

[06:39] <masak> I could be wrong though, because I've only read the spec, not been involved in actual CompUnitRepo work.

[06:40] <FROGGS> masak is right

[06:40] <masak> as far as I know, lizmat++ and FROGGS++ are driving in that.

[06:40] <FROGGS> another aspect that makes it more complex is that distributions are also about media files, configuration files and other stuff

[06:41] <FROGGS> that also needs to be handled

[06:41] <jdv79> just feels a bit overdone/big - idk

[06:41] <oha> masak, both is copy and is ro are misleading on that regard.

[06:41] <FROGGS> jdv79: Perl 6's goal is to be prepared to evolve, and the CUR concept is very much sane IMO

[06:42] <FROGGS> masak: I'd vote for 'is copy' meaning 'is clone' always fwiw

[06:43] *** brrt joined
[06:43] <jdv79> is S22 the only formal words on it?

[06:44] <FROGGS> also S11

[06:45] <kanl> cloning could be expensive though. one can still do sub foo( $foo is copy ) { my $bar = $foo.clone; ... } if he/she wants a proper by-copy, right?

[06:45] <FROGGS> kanl: why do put an 'is copy' trait there at all?

[06:46] <kanl> to want a 'local' effect, i guess?

[06:47] <kanl> if people don't want 'is copy' changed, maybe a 'is clone' can be added?

[06:48] <oha> kanl, can i ask why people don't want it changed? (I honestly don't get the "local" effet)

[06:48] <jdv79> "sane" is quite subjective.  RMI is same to some and its still generally a bad idea.

[06:48] <jdv79> *sane

[06:48] <kanl> i'm only guessing :)

[06:48] <jdv79> similarly, non-local CURs seems a bit out there

[06:48] *** gfldex joined
[06:49] <kanl> oha: 'local' as in p5.

[06:49] <jdv79> i kinda like my code in hand so to speak and not from the cloud

[06:49] <kanl> { local $/ } etc.

[06:50] <oha> kanl, yeah... but i still don't see how it would apply here. (you still have temp and let)

[06:50] <kanl> true..

[06:51] <oha> so in a way, i can see why someone "might" want "$arg is temp"

[06:52] <kanl> m: class A { has $!a; submethod BUILD( Int :@a ){ $!a = [+] @a } }; my $foo = A.new( a => [ 1 .. 10 ] );

[06:52] <camelia> rakudo-moar 377672: OUTPUT«Type check failed in binding @a; expected 'Positional[Int]' but got 'Array'␤  in submethod BUILD at /tmp/xB6Df2y1sM:1␤  in block <unit> at /tmp/xB6Df2y1sM:1␤␤»

[06:52] <nine> jdv79: but there are use cases where it would come in handy: https://metacpan.org/pod/Object::Remote

[06:52] <kanl> isn't Array Positional?

[06:53] <dalek> perl6-most-wanted: ad24f13 | rurban++ | most-wanted/modules.md:

[06:53] <dalek> perl6-most-wanted: Update modules.md

[06:53] <dalek> perl6-most-wanted: 

[06:53] <dalek> perl6-most-wanted: add Unicode::LineBreak

[06:53] <dalek> perl6-most-wanted: east asian languages need access to the linebreak properties 

[06:53] <dalek> perl6-most-wanted: See http://stackoverflow.com/questions/31250503/perl-6-and-print-columns

[06:53] <dalek> perl6-most-wanted: review: https://github.com/perl6/perl6-most-wanted/commit/ad24f131da

[06:53] <dalek> perl6-most-wanted: d3adbf4 | FROGGS++ | most-wanted/modules.md:

[06:53] <dalek> perl6-most-wanted: Merge pull request #4 from rurban/patch-1

[06:53] <dalek> perl6-most-wanted: 

[06:53] <dalek> perl6-most-wanted: Update modules.md

[06:53] <dalek> perl6-most-wanted: review: https://github.com/perl6/perl6-most-wanted/commit/d3adbf42b8

[06:54] *** brrt left
[06:55] *** raiph left
[06:56] <kanl> so how so i properly do type constraints on List/Array?

[06:56] <kanl> should ^^

[06:58] *** domidumont joined
[07:01] *** rindolf joined
[07:03] <moritz> well, you can do it with  Int @a, but then one has to pass in an Array[Int], not an Array

[07:04] <kanl> but BUILD wants named parameters no?

[07:04] <moritz> http://www.nntp.perl.org/group/perl.perl6.users/2015/07/msg2155.html

[07:04] <moritz> kanl: so?

[07:04] <moritz> you can pass an Array[Int] to a named parameter too

[07:05] <kanl> m: class A { has $!a; submethod BUILD( @a ){ $!a = [+] @a } }; my $foo = A.new( [ 1 .. 10 ] );

[07:05] <camelia> rakudo-moar 377672: OUTPUT«Default constructor for 'A' only takes named arguments␤  in block <unit> at /tmp/736BpXDVWg:1␤␤»

[07:06] <kanl> Int or not, i'm not getting pass on BUILD :/

[07:06] <moritz> if you want to pass a positional param to .new, you have to define your own .new

[07:07] <kanl> ah, ic. thanks!

[07:07] <moritz> m: class A { has $!a; method new($a) { self.bless(a => $a) }; submethod BUILD( @a ){ $!a = [+] @a } }; my $foo = A.new( [ 1 .. 10 ] );

[07:07] <camelia> rakudo-moar 377672: OUTPUT«Too few positionals passed; expected 2 arguments but got 1␤  in submethod BUILD at /tmp/vqwLfLmZcV:1␤  in method new at /tmp/vqwLfLmZcV:1␤  in block <unit> at /tmp/vqwLfLmZcV:1␤␤»

[07:07] <moritz> m: class A { has $!a; method new($a) { self.bless(a => $a) }; submethod BUILD( :@a ){ $!a = [+] @a } }; my $foo = A.new( [ 1 .. 10 ] );

[07:07] <camelia> rakudo-moar 377672: ( no output )

[07:08] <moritz> m: class A { has $!a handles 'gist'; method new($a) { self.bless(a => $a) }; submethod BUILD( :@a ){ $!a = [+] @a } }; my $foo = A.new( [ 1 .. 10 ] ); say $foo; say $foo.^name;

[07:08] <camelia> rakudo-moar 377672: OUTPUT«55␤A␤»

[07:08] <moritz> kanl: but think twice before you do it; it makes subclassing much harder

[07:08] *** TimToady left
[07:09] *** RabidGravy joined
[07:10] <moritz> kanl: see also http://doc.perl6.org/language/objects#Object_Construction

[07:11] *** rindolf left
[07:12] <kanl> m: class A { has $!a; submethod BUILD( Array[Int] :@a ){ $!a = [+] @a } }; my $foo = A.new( a => [ 1 .. 10 ] );

[07:12] <camelia> rakudo-moar 377672: OUTPUT«Type check failed in binding @a; expected 'Positional[Array[Int]]' but got 'Array'␤  in submethod BUILD at /tmp/hlzGMjdpGu:1␤  in block <unit> at /tmp/hlzGMjdpGu:1␤␤»

[07:14] <kanl> ok. i'll just forgo the type contraint for now.

[07:15] *** darutoko joined
[07:15] <moritz> m: class A { has $!a; submethod BUILD( Array[Int] :@a ){ $!a = [+] @a } }; my $foo = A.new( a => (my Int @ = 1 .. 10 ) );

[07:15] <camelia> rakudo-moar 377672: OUTPUT«Type check failed in binding @a; expected 'Positional[Array[Int]]' but got 'Array[Int]'␤  in submethod BUILD at /tmp/t4BfSi0eNx:1␤  in block <unit> at /tmp/t4BfSi0eNx:1␤␤»

[07:15] <moritz> m: class A { has $!a; submethod BUILD( Int :@a ){ $!a = [+] @a } }; my $foo = A.new( a => (my Int @ = 1 .. 10 ) );

[07:15] <camelia> rakudo-moar 377672: ( no output )

[07:16] <moritz> that's what I wrote in http://www.nntp.perl.org/group/perl.perl6.users/2015/07/msg2155.html

[07:17] *** vendethiel left
[07:18] <kanl> moritz: i c now. good rant :)

[07:21] <kanl> my $a = bag( -Inf .. Inf ); my $b = bag( 1 .. 3 ); my $c = bag(); say $a(+)$b(+)$c; ## this won't work

[07:21] <kanl> 1. Inf is not properly guarded

[07:21] <oha> but wasn't kanl example about requiring proper types, not coercing it?

[07:21] <kanl> 2. the (whatever) operator requires leading whitespaces.

[07:21] <kanl> 3. can't mix the operators without grouping ()

[07:22] *** vendethiel joined
[07:23] <kanl> m: my $a = bag( 1 .. 4 ); my $b = bag( 1 .. 3 ); say $a(+)$b;

[07:23] <camelia> rakudo-moar 377672: OUTPUT«5===SORRY!5=== Error while compiling /tmp/hlD7eRLLzW␤Prefix + requires an argument, but no valid term found␤at /tmp/hlD7eRLLzW:1␤------> 3 .. 4 ); my $b = bag( 1 .. 3 ); say $a(+7⏏5)$b;␤    expecting any of:␤        prefix␤»

[07:23] <kanl> m: my $a = bag( 1 .. 4 ); my $b = bag( 1 .. 3 ); my $c = bag(); say $a (+) $b (-) $c;

[07:23] <camelia> rakudo-moar 377672: OUTPUT«5===SORRY!5=== Error while compiling /tmp/YpB9DyyE64␤Operators '(+)' and '(-)' are non-associative and require parentheses␤at /tmp/YpB9DyyE64:1␤------> 3( 1 .. 3 ); my $c = bag(); say $a (+) $b7⏏5 (-) $c;␤    expecting any of:␤        i…»

[07:23] <moritz> oha: kanl passed [1, 2, 3] to a 'Int @a' parameter, and was surprised it didn't work

[07:23] <moritz> oha: so that's exactly the case of expecting coercion where none is

[07:27] *** anaeem1__ joined
[07:27] *** mr-foobar joined
[07:28] *** anaeem1_ left
[07:29] <jdv79> yeah ok.  remote and local are distinct enough to warrant a hard distinction

[07:29] <jdv79> imho

[07:30] <jdv79> i guess we'll see.

[07:33] <jdv79> if non-local CUR is just a population method for local CUR then its less insane to me

[07:33] <oha> moritz, I wonder if things would become easier if this would be possible: f (Array[Int] $a) { ... }; f([1,2,3]); 

[07:35] <oha> actually, more like 'my Array[Int] $a = [1,2,3];'

[07:35] <moritz> oha: they would, at least on the surface; but that would also totally mess up multi dispatch

[07:36] <oha> moritz, are you impling that [1,2,3] should become Array[Int], but I'm saying that it might get "narrow typed" if no other candidates are present. yet i see your point

[07:38] <moritz> oha: I'm not implying that [1, 2, 3] should become Array[Int]

[07:39] <moritz> oha: more that an 'Int @a' param should behave more like 'Int() @a' (coercive)

[07:39] <oha> moritz, so couldn't it work like for f(Int) vs f(1)?

[07:39] <moritz> no

[07:39] <nine> jdv79: CUR is not just about remotes. It also allows for simpler implementation of loading from archive files (think .jar) or even generating modules on-the-fly.

[07:39] <moritz> or, even more to the point,  like 'Array[Int]() \a'

[07:40] *** abraxxa joined
[07:40] <jdv79> my perhaps naive point is that including remotes seems like a bad idea

[07:40] <jdv79> not that CUR is a bad concept in general

[07:41] *** amurf left
[07:41] <jdv79> also the global db seems an even worse part

[07:41] <lizmat> jdv79: which global db ?

[07:42] <jdv79> isn't there some sort of repo db that's maintained 

[07:42] <jdv79> i don't know if it has a name

[07:42] <jdv79> if it does i donn't know it

[07:43] <nine> jdv79: alas, none of these are really new possibilities. You can already do this in Perl 5 by pushing a CODEREF to @INC

[07:43] <lizmat> jdv79: check out S22:114

[07:44] *** vendethiel left
[07:52] <jdv79> so what happens when this recomendation mgr yields a candidate that is non-local?

[07:53] *** laouji joined
[07:58] <RabidGravy> marnin!

[07:58] *** laouji left
[07:58] <jdv79> late aft here

[07:58] <jdv79> is 1700 still considered aft of is that eve?

[07:58] <jdv79> *or

[08:08] *** cognominal joined
[08:14] *** dakkar joined
[08:21] <RabidGravy> jdv79, depends on whether I was at work or not really ;-)

[08:23] <jdv79> what if you are not currently employed?

[08:27] <dalek> rakudo/nom: eaaaff2 | lizmat++ | src/core/List.pm:

[08:27] <dalek> rakudo/nom: Some more List.splice tweaking

[08:27] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/eaaaff23d7

[08:28] <dalek> roast: 4405592 | lizmat++ | S32-array/splice.t:

[08:28] <dalek> roast: Work in progress on splice tests

[08:28] <dalek> roast: review: https://github.com/perl6/roast/commit/440559211f

[08:28] <lizmat> afk for a few hours&

[08:36] *** vendethiel joined
[08:37] *** g4 joined
[08:37] *** g4 left
[08:37] *** g4 joined
[08:38] *** kurahaupo left
[08:47] *** sivoais left
[08:49] *** sivoais joined
[08:51] *** Woodi left
[08:51] *** espadrine joined
[08:52] *** mr-foobar left
[08:54] *** mr-foobar joined
[08:58] *** vendethiel left
[09:03] *** Woodi joined
[09:06] *** atroxape_ joined
[09:06] *** atroxaper left
[09:06] *** vendethiel joined
[09:07] *** cognominal left
[09:09] *** sunnavy left
[09:10] *** sunnavy joined
[09:13] *** bin_005 joined
[09:24] *** ab6tract joined
[09:26] <ab6tract> o/ #perl6

[09:27] <ab6tract> .tell [Coke] the conversation about years clearly ended with everyone agreeing that it should be a separate class

[09:27] <yoleaux> ab6tract: I'll pass your message to [Coke].

[09:29] *** amurf joined
[09:34] *** amurf left
[09:37] *** yeahnoob left
[09:38] *** telex left
[09:40] *** telex joined
[09:44] <ab6tract> but I think you all are not doing much date related things to think that subset Year of Int is a reasonably solution, or that Years shouldn't smartwatch Dateish

[09:45] <ab6tract> *smartmatch 

[09:46] *** rindolf joined
[09:53] <FROGGS> I do quite some date related things... I calculate fees for the employees of the company I am working for...

[09:53] <FROGGS> that is, if someone works at night for example, (s)he gets extra fees, depending on the contract atc

[09:53] <FROGGS> etc*

[09:57] *** daxim joined
[09:59] <ab6tract> FROGGS: sorry, the "you all" was a little overbroad there.. that really just meant leont and [Coke]

[10:03] <FROGGS> ab5tract: np

[10:03] *** kanl left
[10:03] *** kanl joined
[10:03] <FROGGS> what I'd like to see is a port of DateTime::Span(Set) etc

[10:09] *** laouji joined
[10:11] *** TEttinger left
[10:17] <lizmat> Camelia growing up: http://toons.gotblah.com/archive/wulffmorgenthaler/150709-0301.jpg   :-)

[10:21] <masak> FROGGS: what's a Span? is it something like "one year"?

[10:23] *** rindolf left
[10:29] *** rurban left
[10:33] *** laouji left
[10:34] *** laouji joined
[10:44] *** aborazmeh joined
[10:44] *** aborazmeh left
[10:44] *** aborazmeh joined
[10:46] *** dayangkun left
[10:49] *** TimToady joined
[10:54] *** laouji left
[10:54] *** laouji joined
[10:56] <FROGGS> masak: aye

[10:57] <FROGGS> bbl

[10:57] *** virtualsue joined
[11:03] *** FROGGS left
[11:03] <ab6tract> FROGGS: sounds a bit like TimToady's suggestion that what I'm talking about is DateInterval

[11:10] *** user3 joined
[11:14] <user3> Rakudo 2015.03 on Linux and Windows

[11:15] <user3> The synopsis for command line option -e says "Arguments following ... -e are always parsed as a list of values, even if they look like valid options."

[11:15] <user3> Then why does this work perl6 "-e say 10-5" but not this perl6 -e say 10-5

[11:16] <moritz> user3: because the second case executes the program with the text 'say' and the command-line argument '10-5'

[11:16] <moritz> a better wording would be "arguments following -e ... are always passed to the Perl 6 program being executed"

[11:19] *** rurban joined
[11:23] <jnthn> afternoon, #perl6

[11:23] <yoleaux> 7 Jul 2015 05:35Z <lizmat> jnthn: Could you have a look as to why f5ebbf480c5936 is causing S17-supply hangs

[11:23] <yoleaux> 7 Jul 2015 06:04Z <lizmat> jnthn: empirically, cbff68a fixes the hanging S17-supply tests

[11:24] <lizmat> jnthn o/

[11:24] <lizmat> how is the red tape?

[11:25] <jnthn> lizmat: We're not doing that red tape this time...due to...uh...other red tape...

[11:25] *** rurban1 joined
[11:25] <lizmat> argh

[11:25] <lizmat> :-(

[11:25] <lizmat> hope you're enjoying Kyiv and each other nonetheless

[11:26] <jnthn> (Nothing out of the ordinary. Just things taking more time than we'd imagined or lacking the fast-paths we'd imagined.)

[11:26] <jnthn> Each othr certainly. And Kyiv, yes when the temperature is agreeable to venturing outside... :)

[11:26] * jnthn has been a bit ill also :/

[11:27] <lizmat> hope you're feeling better now

[11:28] <jnthn> In the "improved" sense, at least.

[11:28] <jnthn> I've no idea why the .assuming work might cause hangs, unless something somewhere is using .assuming

[11:28] *** user3 left
[11:29] <jnthn> Anyways, right now I'm feeling well enough to try doing something useful :)

[11:29] <jnthn> And $wife++ just brought a cup of tea to help :)

[11:30] <jnthn> I've not kept up with backlog...is there anything of note anybody is blocking on?

[11:32] <lizmat> jnthn: that's the thing, nothing is using .assuming in core, afaik

[11:32] <lizmat> jnthn: I think timotimo and brrt could use some input on #moarvm

[11:32] *** bin_005 left
[11:33] <jnthn> .tell hoelzro re RT #125574, obtaining a type object means committing to a REPR, meaning that I can't actually fix that...I should, however, make it tell you it's not going to work rather than silently fail. I'll do that.

[11:33] <yoleaux> jnthn: I'll pass your message to hoelzro.

[11:33] <lizmat> other than that, it has been pretty quiet (for what I've seen of the backlog)

[11:33] <jnthn> OK, thanks :)

[11:33] <lizmat> ah, I have one question though

[11:34] <lizmat> is there a specific reason why splice(@a,...) delegates to @a.splice(...) rather than the reverse ?

[11:34] <jnthn> Because we long had a policy of sub delegates to method.

[11:34] <jnthn> e.g. prefix:<?> delegates to .Bool

[11:35] <lizmat> and why was that policy?

[11:35] <lizmat> I'm thinking splice() specifically here

[11:35] <lizmat> from a performance optimizing point of view, wouldn't it be better to use splice() and have it all the logic

[11:35] <lizmat> and @a.splice delegate to the sub ?

[11:35] <jnthn> Because objects are more natural behavior extenion points.

[11:35] <jnthn> *extension

[11:36] <jnthn> e.g. it's more natural to subclass and override, or implemnet a new type, than it is to export a multi candidate to change behavior

[11:36] <RabidGravy> m: use Test; my $b = Buf.new; isa-ok($b, Buf); # er what's all this about?

[11:36] <camelia> rakudo-moar eaaaff: OUTPUT«not ok 1 - The object is-a 'Buf'␤␤# Failed test 'The object is-a 'Buf''␤# at /tmp/0xDoqNyPhy line 1␤# Actual type: Buf␤»

[11:36] <jnthn> m: say Buf.HOW.^name

[11:36] <camelia> rakudo-moar eaaaff: OUTPUT«Perl6::Metamodel::ParametricRoleGroupHOW␤»

[11:36] <jnthn> RabidGravy: Buf ain't a class.

[11:37] <RabidGravy> ah

[11:38] <jnthn> lizmat: So really it's a case of what we expect people to implement if they want to create their own custom Stringy thing, or Listy thing, for example

[11:38] <lizmat> ok, so we see subs like splice() more as a delegator then as a processor

[11:39] <RabidGravy> is($b.^name, Buf.^name) then ;-)

[11:40] <jnthn> RabidGravy: Smart-match is the natural way to write it

[11:44] <RabidGravy> so it is, cheers

[11:46] *** breinbaa1 joined
[11:50] *** atroxape_ left
[11:52] <dalek> rakudo/nom: ed8270a | jnthn++ | src/core/Supply (2 files):

[11:52] <dalek> rakudo/nom: Move 'is repr' to the predeclaration.

[11:52] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/ed8270a21a

[11:54] *** anaeem1__ left
[11:55] *** leont joined
[11:55] <lizmat> jnthn: aaah, a bug fixed  :-)

[11:55] <lizmat> an unfound one, right ?

[11:56] <jnthn> Right, found by the stricter checking I just put in :)

[11:58] <kanl> :w

[11:59] <kanl> oops

[12:00] *** ab6tract left
[12:02] *** breinbaa2 joined
[12:03] <kanl> is there a way to prevent something like any( 1..Inf ) from eagerly running OOM,  other than being very careful?

[12:05] <jnthn> Not really; a Junction has to have all the values

[12:05] <jnthn> And flattens its args 

[12:06] <jnthn> Maybe GLR will have it not doing so, I don't know.

[12:06] <oha> using a quantum computer would do the trick, tho :)

[12:06] *** laouji left
[12:07] <kanl> jnthn: thanks

[12:08] <dalek> rakudo/nom: a51ac08 | jnthn++ | src/ (2 files):

[12:08] <dalek> rakudo/nom: Catch too-late application of REPR trait.

[12:08] <dalek> rakudo/nom: 

[12:08] <dalek> rakudo/nom: Fixes RT #125574.

[12:08] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/a51ac085ad

[12:08] <dalek> roast: 87560fd | jnthn++ | S32-exceptions/misc.t:

[12:08] <dalek> roast: Test for RT #125574.

[12:08] <dalek> roast: review: https://github.com/perl6/roast/commit/87560fd9c5

[12:11] <masak> oha: no, I don't think that's what quantum computers do.

[12:11] <masak> (I know you were joking, but... it's not true) :P

[12:11] <oha> :)

[12:11] <kanl> you'd still need infinitely many q-bits :)

[12:12] <masak> yeah

[12:12] <oha> even for really small values of Inf? :)

[12:13] <kanl> Inf++

[12:14] <timotimo> hm, synopsebot isn't here?

[12:14] <lizmat> timotimo: indeed

[12:16] <dalek> rakudo/nom: 341f6e5 | jnthn++ | src/Perl6/World.nqp:

[12:16] <dalek> rakudo/nom: Look harder for existing *%_ or | pre-autogen.

[12:16] <dalek> rakudo/nom: 

[12:16] <dalek> rakudo/nom: Fixes RT #125513.

[12:16] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/341f6e541d

[12:17] <dalek> roast: 1cda041 | jnthn++ | S12-class/interface-consistency.t:

[12:17] <dalek> roast: Test for RT #125513.

[12:17] <dalek> roast: review: https://github.com/perl6/roast/commit/1cda041242

[12:19] <kanl> what's the rationale for bag/set to have custom made arithmetic operators, instead of overloading the Numeric ones?

[12:20] <jnthn> kanl: Example of an arithmetic operation on a set/bag?

[12:21] <kanl> sorry, i mean set operations.

[12:21] <kanl> (+) (-) (|) etc.

[12:21] <jnthn> Well, that's the answer though. :) In Perl we avoid overloading *semantics* onto the same symbol.

[12:21] <kanl> they seem to me unwieldy and introduce parsing complexity

[12:22] <jnthn> There's two sane ways to make a language with operators. Etiher you statically know your types and overload operator meanings, or you have dynamic types and operators always have consistent semantics.

[12:23] <jnthn> That's why in Perl you never have to guess if + means numeric addition or concatenation, or whether == with do numeric or string equality.

[12:23] <jnthn> This is just another application of that overarching design rule.

[12:24] *** muraiki joined
[12:25] *** brrt joined
[12:26] <brrt> \o

[12:27] <itz_> does any here have access to update modules running under rakudobrew user on hack.p6c.org?

[12:27] <kanl> jnthn: i see your point, thank you. i suppose i can always overload +/- etc. if i really wanted to :)

[12:28] <JimmyZ> itz_: I can't switch to rakudobrew user ...

[12:31] *** virtualsue left
[12:31] <JimmyZ> itz_: https://github.com/perl6/infrastructure-doc/blob/master/hosts/hack.p6c.org.pod

[12:33] <jnthn> m: use Test; my $m = "AAA" ~~ /$<letter>=(A)**3/; is +$<letter>, 3;

[12:33] <camelia> rakudo-moar ed8270: OUTPUT«ok 1 - ␤»

[12:33] <jnthn> m: use Test; my $m = "AAA" ~~ /$<letter>=(A)**{3}/; is +$<letter>, 3;

[12:33] <camelia> rakudo-moar ed8270: OUTPUT«not ok 1 - ␤␤# Failed test at /tmp/iH6vbs_Lcf line 1␤# expected: '3'␤#      got: (Failure)␤»

[12:33] <jnthn> hm, bet I know why :)

[12:34] <timotimo> jnthn: did you notice the thing where substr on a string built with the x operator can give bogus results?

[12:34] <masak> by the way, speaking of `is copy`, I agree with the people who say that it's currently useless for reference types, and who feel inclined to give it cloning semantics... but I would like the reaction of TimToady, pmichaud_, jnthn, moritz (or an appropriate subset) before going ahead with that.

[12:34] <timotimo> i think it's about concatenating a character at the end of a single character x'd multiple times and then trying to get one of the x'd characters together with the added character results in the x'd character twice

[12:34] <itz_> timotimo: can you update Text::VimColour on hack.p6c.org rakudobrew please? :)

[12:35] <timotimo> let's see

[12:36] <timotimo> …

[12:36] <timotimo> how do i sudo

[12:36] <timotimo> well, Vim::TextColour is already in MODULES, i wonder why it doesn't install

[12:37] <JimmyZ> sudo su rakudobrew -

[12:37] <timotimo> JimmyZ: that's what i ended up doing

[12:37] <itz_> it is installed . I need a bumped version 

[12:37] <timotimo> ah!^

[12:38] <timotimo> m)

[12:38] <timotimo> i can't install it if i try to have Vim::TextColour

[12:38] <itz_> sorry I don't understand

[12:38] <timotimo> ==> Successfully installed Text::VimColour

[12:39] <timotimo> i creatively typo'd the module name

[12:39] <timotimo> to such an extent that panda didn't know how to suggest the right one :)

[12:39] *** mr-foobar left
[12:39] <itz_> ah

[12:39] <kanl> m: say say any( 1..3 ) + any( 2..5 );

[12:39] <camelia> rakudo-moar ed8270: OUTPUT«any(any(3, 4, 5, 6), any(4, 5, 6, 7), any(5, 6, 7, 8))␤True␤»

[12:39] <kanl> m: say say any( 1..3 ) ~ any( 2..5 );

[12:39] <camelia> rakudo-moar ed8270: OUTPUT«any(1, 2, 3)any(2, 3, 4, 5)␤True␤»

[12:39] <itz_> maybe perl6 should allow several versions of English spelling in module names :)

[12:40] <itz_> timotimo: ty

[12:40] <hoelzro> morning #perl6

[12:40] <yoleaux> 11:33Z <jnthn> hoelzro: re RT #125574, obtaining a type object means committing to a REPR, meaning that I can't actually fix that...I should, however, make it tell you it's not going to work rather than silently fail. I'll do that.

[12:40] <timotimo> maybe there shoud be a unicode codepoint for ou that casefolds into o? :)

[12:41] <hoelzro> jnthn: thanks for having a look!  that solution is fine with me

[12:42] <dalek> perl6-examples: 8432216 | (Steve Mynott)++ | / (2 files):

[12:42] <dalek> perl6-examples: enable Text::VimColour

[12:42] <dalek> perl6-examples: review: https://github.com/perl6/perl6-examples/commit/8432216998

[12:42] *** xinming_ joined
[12:43] <kanl> why not any(any(12, 13, 14, 15) ... in the case of any(...) ~ any(...)?

[12:44] *** rindolf joined
[12:46] *** xinming left
[12:46] <jnthn> timotimo: Yes, I'm aware of that issue

[12:47] <jnthn> timotimo: though had forgotten about it until you just reminded me...

[12:47] *** mr-foobar joined
[12:49] *** rurban1 left
[12:49] <lizmat> m: my @a; say @a.splice(1,1).perl; say @a.perl  # seems splice has some unwanted vivification behaviour

[12:49] <camelia> rakudo-moar ed8270: OUTPUT«[]<>␤[Any]<>␤»

[12:50] *** atroxaper joined
[12:55] *** atroxaper left
[13:00] *** g4 left
[13:04] <timotimo> i don't know why it just popped into my mind

[13:10] *** VinceDee joined
[13:10] <timotimo> loadbytecode.c has another

[13:10] <jnthn> Maybe sudden optimism that I'm smart enough to debug it today... :)

[13:10] <timotimo> oops, ww

[13:10] *** mr-foobar left
[13:11] *** dakkar left
[13:11] *** mr-foobar joined
[13:11] <timotimo> to be honest, i'd not point you at any more bugs myself until the code-gen thing for local/localref is done, because i'm interested in that :P

[13:11] *** dakkar joined
[13:12] <timotimo> hope i'm not nagging too much

[13:12] * lizmat is starting to question non-infinite ranges not autovivifying slices more and more

[13:12] * jnthn did after a few attempts manage to fix le regex engine bug with dynamic quantifiers and captures (subject to spectesting...)

[13:13] *** asdfqerzcvasdfqw joined
[13:13] <asdfqerzcvasdfqw> hello

[13:13] <timotimo> hi there

[13:14] *** asdfqerzcvasdfqw left
[13:17] *** mr-foobar left
[13:18] *** g4 joined
[13:18] *** g4 left
[13:18] *** g4 joined
[13:21] *** vendethiel left
[13:24] <lizmat> m: my @a = ^2; say @a.splice(1,3,3,4).perl; say @a.perl  # this feels incorrect

[13:24] <camelia> rakudo-moar 341f6e: OUTPUT«[1]<>␤[0, 3, 4]<>␤»

[13:24] <lizmat> sort of expected [0,Any,Any,3,4]

[13:24] <lizmat> afk&

[13:25] <lizmat> looks like P5 has a different problem there:

[13:25] <lizmat> $ perl -E 'my @a = 0,1; say splice(@a,1,3,3,4); say @a'

[13:25] <lizmat> 034

[13:25] <lizmat> aka, the 1 is not returned

[13:26] <dalek> nqp: cb78f9e | jnthn++ | src/QRegex/P6Regex/Actions.nqp:

[13:26] <dalek> nqp: Account properly for dynquant in capture handling.

[13:26] <dalek> nqp: 

[13:26] <dalek> nqp: We sometimes ended up with a clearly quantified (by **) capture only

[13:26] <dalek> nqp: capturing once and the whole match.

[13:26] <dalek> nqp: review: https://github.com/perl6/nqp/commit/cb78f9e38f

[13:26] <lizmat> oops, differetnt P5 issue altogether

[13:26] <lizmat> afk for a while

[13:27] <dalek> rakudo/nom: 6a000f8 | jnthn++ | tools/build/NQP_REVISION:

[13:27] <dalek> rakudo/nom: Bump NQP_REVISION for regex dynquant/capture fix.

[13:27] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/6a000f8938

[13:27] *** skids joined
[13:27] <dalek> roast: 302b5c2 | jnthn++ | S05-metasyntax/repeat.t:

[13:27] <dalek> roast: Test for RT #125521.

[13:27] <dalek> roast: review: https://github.com/perl6/roast/commit/302b5c2779

[13:28] <dalek> rakudo/nom: 261accb | lizmat++ | src/core/List.pm:

[13:28] <dalek> rakudo/nom: Handle splice with offset past end

[13:28] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/261accb4a4

[13:29] <cdc> Hello #perl6!

[13:29] <timotimo> BBL

[13:29] *** vendethiel joined
[13:30] <cdc> I'd like to format -1 as an uint8 hexadecimal number, something like "-1.fmt('%x')" but that returns "0xff".

[13:30] <cdc> please, could you tell me how I should proceed?

[13:31] <jnthn> hoelzro: re 125531, do you have any concrete ideas on what you'd like to happen?

[13:31] <oha> cdc: (1 % 256).fmt() ?

[13:31] <jnthn> (I agree it's LTA, not immediately got a feeling for right way forward)

[13:32] <oha> cdc, (-1 % 256) actually

[13:32] <cdc> m: (-1 % 256).fmt('%x').say

[13:32] <camelia> rakudo-moar 341f6e: OUTPUT«ff␤»

[13:32] <moritz> m: say (-1).fmt('%x')

[13:32] <camelia> rakudo-moar 341f6e: OUTPUT«-1␤»

[13:32] <cdc> oha: Thanks!

[13:33] <cdc> moritz: do you think it's a bug?

[13:33] <moritz> cdc: I don't think so; %x just says hex, not unsigned hex, does it?

[13:33] <moritz> I mean, how would even know if it should say ff or ffff or fffffffff?

[13:34] <cdc> m: (-10).fmt('%x')

[13:34] <camelia> rakudo-moar 341f6e: ( no output )

[13:34] <cdc> m: (-10).fmt('%x').say

[13:34] <camelia> rakudo-moar 341f6e: OUTPUT«-a␤»

[13:35] <cdc> moritz: I don't know :)

[13:39] <dalek> roast: 60ffb35 | lizmat++ | S32-array/splice.t:

[13:39] <dalek> roast: Some more splice tests, still work in progress

[13:39] <dalek> roast: review: https://github.com/perl6/roast/commit/60ffb35cfb

[13:39] <lizmat> really afk for a while now

[13:39] *** cognominal joined
[13:46] <dalek> roast: 6d6c4fb | jnthn++ | S12-introspection/meta-class.t:

[13:46] <dalek> roast: Add tests covering RT #80694.

[13:46] <dalek> roast: review: https://github.com/perl6/roast/commit/6d6c4fbbaa

[13:51] *** vendethiel left
[13:52] *** Begi joined
[13:53] <Begi> Hey ! I began with Perl6. I've code a little GuessNumber. Please, can you tell me what can I improve ? Thanks a lot ! http://pastebin.com/STCzpv7Z

[13:54] <tadzik> looks good, though you may want to use loop {} instaed of while 1 {} :)

[13:55] <tadzik> also $attempts++ is probably more suited over += 1 here

[13:55] <PerlJam> or maybe even   for 1..* -> $attempts { ... }

[13:55] <DrForr> You can also remove the () around your if() statements as well, and $attempts++ # guh, like tadzik said.

[13:58] *** vendethiel joined
[13:58] <PerlJam> Begi: I guess you've never run this program?

[13:58] *** zakharyas joined
[13:58] <DrForr> Because of the $attemps tyops?  :)

[13:58] <PerlJam> yeah

[13:59] <Begi> Yes , I hesitated between loop and while. I'll watch that. Thanks again

[13:59] <Begi> In fact, I've code in French. When I post it, I've change the variable names

[14:00] <PerlJam> Begi: you won't hurt our feelings if your variables have french names  :)

[14:00] *** notjack joined
[14:00] <Begi> Oh yes, I've forget a t =)

[14:01] <Begi> Just a question, do you have another exercise to do ?

[14:02] <PerlJam> Begi: hangman?

[14:02] <PerlJam> Begi: or take your existing code and make it more DRY

[14:03] <Begi> Hangman, good idea ! Make it more DRY, how can I do it ?

[14:04] *** FROGGS joined
[14:04] <PerlJam> Begi: you can get rid of the repeated $attempts += 1  by using a for loop that keeps track of the attempts as I said,  or keep the loop the same and add a NEXT phaser that handles incrementing $attempts and outputting their number.

[14:05] <cdc> Begi: loop (my $i = 0;; $i++) { state $r = round 100.rand; given prompt('? ') { when * < $r { say "+, $i" }; when * > $r { say "-, $i" }; when * { say "=, $i"; last } } }

[14:05] <jnthn> m: given 2 { when * > 1 { when 2 { say 'here' }; say 'hmm'; } say 'oh'; }

[14:05] <camelia> rakudo-moar 261acc: OUTPUT«5===SORRY!5=== Error while compiling /tmp/CHg8nqRyuw␤Strange text after block (missing semicolon or comma?)␤at /tmp/CHg8nqRyuw:1␤------> 3 1 { when 2 { say 'here' }; say 'hmm'; }7⏏5 say 'oh'; }␤»

[14:05] <cdc> Begi: a shorter version :)

[14:06] <jnthn> m: given 2 { when * > 1 { when 2 { say 'here' }; say 'hmm'; }; say 'oh'; }

[14:06] <camelia> rakudo-moar 261acc: OUTPUT«here␤»

[14:06] <PerlJam> Begi: or use some of the "tricks" that cdc mentions :)

[14:06] <jnthn> m: for 2 { when * > 1 { when 2 { say 'here' }; say 'hmm'; }; say 'oh'; }

[14:06] <camelia> rakudo-moar 261acc: OUTPUT«here␤»

[14:06] <jnthn> m: { $_ = 2 { when * > 1 { when 2 { say 'here' }; say 'hmm'; }; say 'oh'; } }

[14:06] <camelia> rakudo-moar 261acc: OUTPUT«5===SORRY!5=== Error while compiling /tmp/AZdgLDSCUM␤Unexpected block in infix position (missing statement control word before the expression?)␤at /tmp/AZdgLDSCUM:1␤------> 3{ $_ = 27⏏5 { when * > 1 { when 2 { say 'here' }; s␤    expectin…»

[14:06] <jnthn> m: { $_ = 2; { when * > 1 { when 2 { say 'here' }; say 'hmm'; }; say 'oh'; } }

[14:06] <camelia> rakudo-moar 261acc: OUTPUT«here␤»

[14:06] <jnthn> m: { $_ = 2; { when * > 1 { when 2 { say 'here' }; say 'hmm'; }; say 'oh'; } }; say 'yay';

[14:06] <camelia> rakudo-moar 261acc: OUTPUT«here␤yay␤»

[14:06] <ggoebel> made a small donation to perl6 development fund...

[14:06] <PerlJam> ggoebel++

[14:06] <jnthn> ggoebel++

[14:07] <jnthn> m: sub foo { $_ = 2; { when * > 1 { when 2 { say 'here' }; say 'hmm'; }; say 'oh'; } }; foo; say 'here'

[14:07] <camelia> rakudo-moar 261acc: OUTPUT«here␤here␤»

[14:07] <ggoebel> its the least I can do

[14:07] *** anaeem1_ joined
[14:07] <jnthn> Of the camelia evals I just did with when, does anybody have any objections to the semantics?

[14:08] <jnthn> It turns out some of the details of the semantics in S04 are out of line with what we've long implemented, and what is being usefully used in the wild.

[14:09] <jnthn> This relates to RT #71368, which a while back I tried to resolve by implementing the suggested semantics in the ticket and S04

[14:09] <jnthn> It turns out that this didn't play well with various useful code/patterns in the wild.

[14:10] <jnthn> So, I'm going to get S04 in line with what is actually implemented, since that seems to be working out well enough.

[14:10] <ggoebel> might be able to give more later. It would be appreciated if there were some on-going updates... progress toward monthly and annual goals and the like breaking out one time and reoccuring donation levels. It would be nice to hear how much needs to be raised by July 31 to keep jnthn++ on 50% time next month.

[14:11] <PerlJam> jnthn: Seems fine to me.

[14:11] <PerlJam> I was worried about one of them, but it turned out I'd misread the position of a closing }

[14:12] <jnthn> ggoebel: Anything specific you're looking for on upates? I try to blog every 1-2 weeks with technical reports and recently did a summary of what got done in the first 3 months at a high level, at https://6guts.wordpress.com/

[14:12] <jnthn> ggoebel: I also have a detailed time sheet that I'm fine with being public.

[14:13] <ggoebel> jnthn: I'm content with your updates. I'm more concerned with updates from the perl6 foundation on your funding status and whether we're moving toward something that is sustainable. -And doesn't have you guessing from month to month whether or not the next month will be funded.

[14:13] <hoelzro> jnthn: I think it would be nice if it said "Cannot assign to a readonly variable $/"

[14:13] <hoelzro> perhaps including the fact that ~~ is responsbiel

[14:13] <hoelzro> *responsible

[14:14] <ggoebel> when I made a donation there was no where to leave a comment for me to express why I was giving or what I wished the funds to support

[14:14] <ggoebel> different people are motivated by different things

[14:14] *** notjack left
[14:15] *** anaeem1_ left
[14:16] <dalek> roast: 5aa33ab | jnthn++ | S04-statements/when.t:

[14:16] <dalek> roast: Toss tests for semantics we've decided against.

[14:16] <dalek> roast: 

[14:16] <dalek> roast: We won't try to statically work out whether a "when"/"default" is a

[14:16] <dalek> roast: valid thing, since it pretty much always can be, and folks have come

[14:16] <dalek> roast: to make good use of those semantics.

[14:16] <dalek> roast: review: https://github.com/perl6/roast/commit/5aa33abd81

[14:18] <vendethiel> jnthn: what's the usecase for non-`given`'d `default`?

[14:18] <jnthn> vendethiel: Documentary, just like given'd default...

[14:18] *** anaeem1 joined
[14:19] <jnthn> vendethiel: Note that, short of introducing a lexical scope, the behavior of the code in default is as if the default block wasn't there at all.

[14:19] <jnthn> Well, and any code after it is dead

[14:20] <jnthn> m: given 1 { when * > 2 { say 'big number' }; default { say 'here' } }

[14:20] <camelia> rakudo-moar 261acc: OUTPUT«here␤»

[14:20] <jnthn> m: given 1 { when * > 2 { say 'big number' }; say 'here' }

[14:20] <camelia> rakudo-moar 261acc: OUTPUT«here␤»

[14:20] <vendethiel> m: for ^5 { when * > 10 { say 'big number' }; default { say 'here' }; say 'ded'; }

[14:20] <camelia> rakudo-moar 261acc: OUTPUT«here␤here␤here␤here␤here␤»

[14:21] *** anaeem1 left
[14:21] <ggoebel> I'd like to give a regular monthly or annual donation. But my motivation is to support developers... not the perl foundation.

[14:22] <skids> Re: RT#125537 it looks like I overgolfed that so the fix for that did not fix what I had hoped.  Should this work?:

[14:22] <skids> m: :(::T $a, T $b).params[1].type.WHICH.say

[14:22] <camelia> rakudo-moar 261acc: OUTPUT«Method 'WHICH' not found for invocant of class 'T'␤  in block <unit> at /tmp/8B9EXitm_e:1␤␤»

[14:23] <PerlJam> ggoebel: you make me wonder now how much of the donated funds end up in the hands of developers vs how much end up paying for the overhead of TPF.

[14:25] <jnthn> skids: Not really...it's senseless to do anything on a type var

[14:25] *** rindolf left
[14:25] <jnthn> skids: We could improve the error

[14:25] <jnthn> Somehow... :)

[14:26] <skids> :-) So what I really need is to be able to compare .type to Mu.  Which can't use ===.

[14:28] <moritz> Mu ~~ .type ?

[14:28] *** AlexDaniel joined
[14:28] <jnthn> You'll probably need to handle type vars explicitly

[14:28] *** VinceDee left
[14:29] <cdc> I tried to reduce Begi's program again, but I hit something strange:

[14:29] <cdc> my $r = 100.rand.round; while prompt('? ') Rcmp $r { say "$^x ($r)" }; say 'OK'

[14:29] <skids> No it's more like $type1 === $type2 and either could be Mu, Nil, or a capturing type.

[14:29] <cdc> "$^x" is always "More"

[14:29] <jnthn> cdc: Try R<=>

[14:29] <moritz> right, prompt returns a Str

[14:30] <jnthn> Yes, that's what's up.

[14:30] <cdc> jnthn: Thanks! It works :)

[14:30] <cdc> my bad

[14:30] <jnthn> <=> forces numeric comparsion

[14:31] <cdc> Begi: my $r = 100.rand.round; while prompt('? ') R<=> $r { say $^x }; say 'OK'

[14:31] <ggoebel> PerlJam: I assume it is all operating in good faith. non-profit organization need funds too. And there is a lot of information on their website if you go digging for it. However, I was surprised that no where in the process of giving a donation did anyone think to ask why I was doing so, nor offer to bring me into the communications fold via an email list, etc.

[14:32] <Ulti> if I do "somepath" .= IO and the somepath doesn't exist what is that failure because it doesn't appear to be an exception I can catch

[14:33] <Ulti> m: my $file = "oogabooga"; try { $file .= IO; CATCH { say "getting here" } }

[14:33] <camelia> rakudo-moar 261acc: ( no output )

[14:34] *** anaeem1_ joined
[14:36] *** colomon left
[14:37] *** colomon joined
[14:38] <dalek> roast: c43e6a7 | jnthn++ | S04-statements/when.t:

[14:38] <dalek> roast: More tests for when/default.

[14:38] <dalek> roast: 

[14:38] <dalek> roast: To exercise semantics update coming in S04 design doc.

[14:38] <dalek> roast: review: https://github.com/perl6/roast/commit/c43e6a763f

[14:39] *** atroxaper joined
[14:41] <ugexe> IO doesnt give you a file handle

[14:43] *** atroxaper left
[14:44] <ugexe> m: my $file = $?FILE.IO; say "{$file.e} | {$file.d} {$file.f}"; say $file.slurp; 

[14:44] <camelia> rakudo-moar 261acc: OUTPUT«True | False True␤my $file = $?FILE.IO; say "{$file.e} | {$file.d} {$file.f}"; say $file.slurp;␤»

[14:46] *** rindolf joined
[14:46] <cdc> is "default" same as "when *"?

[14:47] <Ulti> ugexe huh? I'm saying it complains when the file doesn't exist but doesn't give me a chance to do anything about that

[14:47] <Ulti> you can call .lines which opens that path

[14:47] <Ulti> or slurp

[14:48] <Ulti> but I dont even get that far because I want to test if the file exists but it errors on that

[14:48] <ugexe> thats what the $file.e shows you

[14:48] <Ulti> I get that I can do this some other way I was just wondering what exactly is happening since its not a normal exception

[14:52] <hoelzro> jnthn: thanks for that is repr fix!  would be difficult or encourage bad code to allow is repr on the definition only if the is repr matches? ex. class F is repr(A) { ... } class F is repr(A) {}

[14:52] <jnthn> hoelzro: Feels like a DRY violation...

[14:53] <jnthn> cdc: Yes

[14:58] <dalek> ecosystem: 51b15e8 | (Matt Oates)++ | META.list:

[14:58] <dalek> ecosystem: Added BioInfo

[14:58] <dalek> ecosystem: 

[14:58] <dalek> ecosystem: Finally got annoyed at not being able to install wherever I want to release :3

[14:58] <dalek> ecosystem: review: https://github.com/perl6/ecosystem/commit/51b15e88d2

[14:58] <dalek> specs: 5f132ab | jnthn++ | S04-control.pod:

[14:58] <dalek> specs: Revise and simplify when/default semantics.

[14:58] <dalek> specs: 

[14:58] <dalek> specs: This matches behavior seen in implementation and relied upon in the

[14:58] <dalek> specs: wild. There are various examples of existing code making use of the

[14:58] <dalek> specs: fact every block has an implicit C<$_>, which it sets so it can use

[14:58] <dalek> specs: C<when> and C<default>. This means trying to identify a topicalizer

[14:58] <dalek> specs: in a clever way, or even complain in the absence of one, breaks a

[14:58] <dalek> specs: common and useful pattern (yes, I tried it!) Added some notes on

[14:58] <dalek> specs: the semantics of nested when/default, also bringing the design doc

[14:58] <dalek> specs: in line with existing and tested behavior.

[14:58] <dalek> specs: review: https://github.com/perl6/specs/commit/5f132abb41

[14:59] <ugexe> Util: ah. if you do "oogabooga" .= IO i think you actually will catch it. if you do $file = "oogabooga"; $file .= IO you get uncatchable 

[15:00] *** xinming_ left
[15:00] <ugexe> CATCH { default { say "caught" }}; say "start"; "xxx" .= IO

[15:00] <ugexe> m: CATCH { default { say "caught" }}; say "start"; "xxx" .= IO

[15:00] <camelia> rakudo-moar 261acc: OUTPUT«start␤caught␤»

[15:00] *** xinming joined
[15:00] <ugexe> m: CATCH { default { say "caught" }}; say "start"; my $y = "xxx"; $y .= IO

[15:00] <camelia> rakudo-moar 261acc: OUTPUT«start␤»

[15:01] <jnthn> Phew, down below 1030 RTs again.

[15:01] <Util> Ulti: ^^^ (7 lines up from ugexe)

[15:02] <hoelzro> jnthn: alright, I'll just change my code then

[15:03] <ugexe> oh oops

[15:06] <Ulti> heh yeah

[15:07] <Ulti> well at least its not just me, yeah I get something you can catch direct from the string literal like that and even just doing .IO.e on the variable its specifically the .= IO thats odd

[15:07] <ugexe> well IO is just an empty role mostly

[15:08] <Ulti> yeah but $thing .= IO should be the same as just doing $thing = $thing.IO right? and I can catch that

[15:08] <Ulti> I think... *double checks*

[15:08] <ugexe> $thing.IO doesnt call IO.new($thing) i dont think

[15:09] *** zakharyas left
[15:10] <ugexe> if th ecompiler knows its a string it looks like it knows what to do

[15:10] <ugexe> m: CATCH { default { say "caught" }}; say "start"; my Str $y = "xxx"; $y .= IO

[15:10] <camelia> rakudo-moar 261acc: OUTPUT«start␤caught␤»

[15:10] <dalek> roast: 2098c0c | jnthn++ | S04-blocks-and-statements/pointy.t:

[15:10] <dalek> roast: Correct and unfudge test.

[15:10] <dalek> roast: 

[15:10] <dalek> roast: Routine.name is not fully qualified.

[15:10] <dalek> roast: review: https://github.com/perl6/roast/commit/2098c0c91e

[15:10] *** domidumont left
[15:11] <Ulti> hmm either way what I was doing was kind of gross just wondered about why the error was slippery

[15:12] <ugexe> yeah the code is not right. but its not doing the right not right thing

[15:14] *** brrt left
[15:14] <jnthn> m: sub foo($a) { sub bar($n) { say $a; $n == 1 ?? 1 !! $n * &?ROUTINE($n - 1) } }; my $r1 = foo('a'); my $r2 = foo('b'); $r2(4);

[15:14] <camelia> rakudo-moar 261acc: OUTPUT«b␤b␤b␤b␤»

[15:14] <jnthn> m: sub foo($a) { sub bar($n) { say $a; $n == 1 ?? 1 !! $n * &?ROUTINE($n - 1) } }; my $r1 = foo('a'); my $r2 = foo('b'); $r1(4);

[15:14] <camelia> rakudo-moar 261acc: OUTPUT«a␤b␤b␤b␤»

[15:14] <jnthn> bingo

[15:18] *** nys joined
[15:22] *** vendethiel left
[15:24] *** FROGGS left
[15:28] <itz_> w00t! examples.perl6.org is colour syntaxed now .. and not a line of python insight :)

[15:29] <jnthn> itz_++

[15:32] <hoelzro> itz_: you didn't use pygments? how'd you highlight it?

[15:33] *** vendethiel joined
[15:35] <itz_> basically shelling out to a vim line from a perl6 wrapper and using that.  perl 6 syntax support is in vim 7.4

[15:35] *** aborazmeh left
[15:35] <Ulti> itz_ is it using the (relatively) recently updated Perl 6 vim highlighting?

[15:36] <itz_> Ulti: not yet I was just wondering about importing those files from https://github.com/vim-perl/vim-perl

[15:36] <itz_> or using git to pull them in via a submodule (?) or something

[15:37] <Ulti> yeah they are way better now

[15:37] <Ulti> vim tended to get quite confused frequently before the updates in my experience

[15:38] <itz_> yes I'm using the newer files myself and they are better (although slower which I guess is hard to avoid)

[15:39] <Ulti> yeah looking at them I get why :) they are HUGE compared to other language syntax files

[15:40] <Ulti> really we want vim shelling out to perl6 to do the highlighting with the rakudo parser :P

[15:40] <RabidGravy> has anyone had any further thoughts about the https://rt.perl.org/Ticket/Display.html?id=125408 ? really getting in my way now 

[15:40] *** Begi left
[15:41] <itz_> yes long term I'm sure using Perl6's own grammar to highlight is the way to go

[15:45] *** petercommand left
[15:45] *** petercommand joined
[15:45] *** anaeem1_ left
[15:46] *** anaeem1 joined
[15:47] *** virtualsue joined
[15:49] *** g4 left
[15:49] *** zakharyas joined
[15:50] *** anaeem1 left
[15:55] *** FROGGS joined
[15:55] *** vendethiel left
[15:57] *** nowan left
[15:59] *** vendethiel joined
[16:00] *** nowan joined
[16:04] <dalek> rakudo/nom: 3db9326 | jnthn++ | src/Perl6/Actions.nqp:

[16:04] <dalek> rakudo/nom: Correct closure semantics of &?ROUTINE.

[16:04] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/3db9326bda

[16:04] <dalek> rakudo/nom: 3bdd0af | jnthn++ | src/Perl6/Actions.nqp:

[16:04] <dalek> rakudo/nom: Implement &?BLOCK.

[16:04] <dalek> rakudo/nom: 

[16:04] <dalek> rakudo/nom: We go with a similar approach to $?FILE/$?LINE, which lets us cheaply

[16:04] <dalek> rakudo/nom: get the closure semantics correct (cheaply as in "only pay if the

[16:04] <dalek> rakudo/nom: symbol is used").

[16:04] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/3bdd0af908

[16:04] <dalek> roast: 4331787 | jnthn++ | S02-magicals/sub.t:

[16:04] <dalek> roast: Test closure semantics of &?ROUTINE.

[16:04] <dalek> roast: review: https://github.com/perl6/roast/commit/4331787b85

[16:04] <dalek> roast: aaf36de | jnthn++ | S02-magicals/block.t:

[16:04] <dalek> roast: Unfudge &?BLOCK test; add closure semantics test.

[16:04] <dalek> roast: review: https://github.com/perl6/roast/commit/aaf36de87e

[16:06] <jnthn> Time for break, dinner, etc.

[16:08] * [Coke] waves from the AWS summit, where there is no metion of p5, let alone p6.

[16:08] <yoleaux> 09:27Z <ab6tract> [Coke]: the conversation about years clearly ended with everyone agreeing that it should be a separate class

[16:08] *** brrt joined
[16:09] <[Coke]> . tell ab6tract - yes, I see that, it was clear. I obviously responded before backscroll completed, but does that mean I shouldn't have voiced my opinion, even if I had waited until I caught up?

[16:09] <[Coke]> .tell ab6tract - yes, I see that, it was clear. I obviously responded before backscroll completed, but does that mean I shouldn't have voiced my opinion, even if I had waited until I caught up?

[16:09] <yoleaux> [Coke]: I'll pass your message to ab6tract.

[16:16] *** synbot6 joined
[16:18] <[Coke]> 1028 tickets. wonder if we can get that under 1K today.

[16:18] <[Coke]> I will have a few uninterrupted hours on the train later today, will see what I can do.

[16:21] *** vendethiel left
[16:22] <[Coke]> https://rt.perl.org/Ticket/Display.html?id=77170 - how clever can we be here? Is it worth it?

[16:22] *** uncleyear left
[16:22] *** uncleyear joined
[16:28] *** abraxxa left
[16:34] *** brrt left
[16:34] *** vendethiel joined
[16:37] *** spider-mario joined
[16:42] *** rurban left
[16:45] *** amurf joined
[16:46] *** molaf joined
[16:47] *** synbot6 left
[16:47] <[Coke]> I'm seeing failures in S32-exceptions/misc.t

[16:50] *** dakkar left
[16:50] *** amurf left
[16:54] *** diana_olhovik joined
[16:55] *** brrt joined
[16:57] *** vendethiel left
[17:02] *** tinyblak_ left
[17:07] *** zakharyas left
[17:11] *** Hor|zon left
[17:12] *** uncleyear left
[17:12] *** uncleyear joined
[17:15] <b2gills> m: -> $a { say &?BLOCK }($) # gist doesn't match definition

[17:15] <camelia> rakudo-moar 3bdd0a: OUTPUT«-> ($a) { #`(Block|48836336) ... }␤»

[17:18] *** vendethiel joined
[17:29] *** domidumont joined
[17:40] *** vendethiel left
[17:42] *** telex left
[17:44] *** espadrine left
[17:44] *** telex joined
[17:45] <FROGGS> jnthn++ # &?BLOCK

[17:45] *** vendethiel joined
[17:46] *** molaf_ joined
[17:48] *** breinbaa2 left
[17:49] *** molaf left
[17:52] *** rurban joined
[17:59] <dalek> perl6-roast-data: 70b00e6 | coke++ | / (9 files):

[17:59] <dalek> perl6-roast-data: today (automated commit)

[17:59] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/70b00e634f

[18:01] <[Coke]> Maybe it's mac only. :P

[18:01] <itz_> https://twitter.com/bryanl/status/619204092842377216/photo/1

[18:03] <[Coke]> m: use Test; throws_like 'sub foo;', X::SemicolonForm::Invalid, what => 'sub';

[18:03] <camelia> rakudo-moar 3bdd0a: OUTPUT«Could not find symbol '&Invalid'␤  in block <unit> at /tmp/aEzbf6OspH:1␤␤»

[18:04] *** baest_ joined
[18:04] <[Coke]> huh. why doesn't that fail in the daily run, I wonder. but it's failing on OSX, failing here.

[18:06] *** baest left
[18:07] *** atroxaper joined
[18:07] *** Hor|zon joined
[18:08] *** roguelazer joined
[18:12] *** atroxaper left
[18:12] *** bin_005 joined
[18:12] *** Hor|zon left
[18:14] <bartolin> [Coke]: that was changed to 'X::UnitScope::Invalid' with https://github.com/perl6/roast/commit/1c4b217809

[18:15] <[Coke]> ... arglebargle.

[18:16] <[Coke]> I would have figured that out in a few hours that I needed to update roast. Thanks! ;)

[18:16] <bartolin> yw :-)

[18:18] *** domidumont left
[18:20] <itz_> I'm still getting t/spec/S32-io/IO-Socket-INET.t fail on OSX

[18:21] <brrt> anything changed recently that'd make s05-metasyntax/repeat.t die

[18:23] <dalek> roast: cf0d490 | coke++ | S32-exceptions/misc.t:

[18:23] <dalek> roast: Add test for RT #114274

[18:23] <dalek> roast: review: https://github.com/perl6/roast/commit/cf0d4905c2

[18:23] <itz_> which is golfed for perl6 -e 'qx{PERL6_BINARY=/Users/steve/.rakudobrew/moar-nom/perl6-m sh -x t/spec/S32-io/IO-Socket-INET.sh 7 1024}'

[18:23] <itz_> Unhandled exception: Unable to execute...

[18:24] <[Coke]> 1027 tickets!

[18:25] <[Coke]> r: say 1.0000000000000000000000000000001 

[18:25] <camelia> rakudo-{moar,jvm} 3bdd0a: OUTPUT«1.000000000000000000000000000000100␤»

[18:25] *** rurban left
[18:25] *** muraiki left
[18:26] *** muraiki joined
[18:29] *** domidumont joined
[18:31] *** [Sno] left
[18:34] *** Ven joined
[18:34] *** amurf joined
[18:37] <[Coke]> r: my $a = :b; say $a.key =:= $a.key

[18:37] <camelia> rakudo-jvm 3bdd0a: OUTPUT«False␤»

[18:37] <camelia> ..rakudo-moar 3bdd0a: OUTPUT«True␤»

[18:38] <[Coke]> m: sub a(int $i) is cached { return unless $i; a($i-1) }; say a(4);

[18:38] <camelia> rakudo-moar 3bdd0a: OUTPUT«Cannot find method 'perl': no method cache and no .^find_method␤  in any enter at src/gen/m-Metamodel.nqp:3560␤  in sub a at /tmp/wZutjuAe0s:1␤  in any call_with_capture at src/gen/m-Metamodel.nqp:3488␤  in any enter at src/gen/m-Metamodel.nqp:3560…»

[18:39] <[Coke]> m: sub a(int $i) { return unless $i; a($i-1) }; say a(4);

[18:39] <camelia> rakudo-moar 3bdd0a: OUTPUT«Nil␤»

[18:39] *** amurf left
[18:43] <colomon> jnthn++

[18:47] *** konkeydong joined
[18:50] *** Hor|zon joined
[18:52] <masak> FROGGS: sorry; conversation scattered across the day...

[18:52] <FROGGS> masak: we have a conversation? :S

[18:52] <masak> FROGGS: I didn't do something like DateTime::Span or Interval or whatever, because '1 year' does not have a single defined length.

[18:52] <FROGGS> was very busy today at $work :o(

[18:53] <masak> FROGGS: instead, it depends where you put either endpoint.

[18:53] <FROGGS> masak: true

[18:53] <masak> FROGGS: also, things like 'one month after Jan 31'. the day you end up on might even depend on whether it's a leap year or not.

[18:54] <brrt> masak: fwiw, take a look at the current way i use macros :-) 

[18:54] <brrt> https://github.com/MoarVM/MoarVM/blob/even-moar-jit/src/jit/exprlist

[18:54] <masak> FROGGS: instead, I ended up mapping those needs to the .earlier and .later methods, where you can only add/subtract one time unit at a time. many problems thus go away.

[18:54] <FROGGS> I use usually do: DateTime::Span->new(from => $today-at-midnight, $today-at-midnight->add($one-day))

[18:54] * masak looks

[18:55] <masak> FROGGS: oh, so a Span is always rooted in two DateTime endpoints?

[18:55] <FROGGS> then my span is from midnight to midnight, and I can use set-like ops to get intersections etc

[18:55] <brrt> i've chosen to go for consistency between definition and use; adding a 'keyword' as the first list item also resolved parsing special-casing

[18:55] <FROGGS> masak: you have to apply a span to an endpoint to work with it, yes

[18:55] <brrt> because the macro name, with a ^, isn't resolved as a macro if it isn't the first item in the list

[18:55] <masak> brrt: nice.

[18:56] <masak> brrt: yeah, looks clean and usable. brrt++

[18:56] <brrt> thanks for the advice again :-) masak++

[18:56] <masak> brrt: glad I could apply my (meagre) knowledge of macros to something useful :P

[18:57] *** pyrimidine joined
[18:57] <brrt> now i'm really off for today :-)

[18:57] <FROGGS> masak: my use case is that I have a "calender" (a spanset) of spans defining the possible fees one can get, and another calender/spanset describing when that someone actually were at work

[18:57] *** brrt left
[18:57] <FROGGS> the intersection is the fees (s)he gets

[18:58] <FROGGS> (it is not that simple in fact, but the underlying principle works like that)

[18:58] <masak> FROGGS: what does a Span give you that a range of DateTime doesn't?

[18:58] *** konkeydong left
[18:59] <FROGGS> well, I usually prepare spans to apply them later to different endpoints...

[18:59] <FROGGS> but my intend is to do math with datetime ranges only

[19:00] <FROGGS> ohh way, I think it is stilled called span when a span has concrete endpoints

[19:02] <FROGGS> masak: in fact I dont need a Span that has loose endpoints

[19:03] <masak> all the better.

[19:03] <masak> then it looks like what you have is two DateTimes that you want to manipulate in concert.

[19:03] <FROGGS> what I want: my $span = DateTime::Span.new( $dt1, $dt2 ); [...]; if $span1 (&) $span2 -> $intersection { ... }

[19:03] <masak> ooh, yes.

[19:03] <masak> that would come out nicely.

[19:04] <masak> (|) would only be closed if the spans intersect, though.

[19:08] <FROGGS> a spanset is about a bunch of spans btw

[19:09] <FROGGS> like today from 0-6 o'clock and 20 to midnight

[19:10] <FROGGS> and when I work from 5 to 14, and 22 to midnight, I get night-fees for three hours

[19:10] <FROGGS> so you can just calc the intersections of both sets, and all is fine

[19:11] <FROGGS> and it also just works out on the days when we switch to daylight savings time for example

[19:12] <FROGGS> (which was a nice bug report I got once from our HR department.... "Ohh noes, we paid for 25 hours on-call fee that day!" - "That's right :o)")

[19:13] *** anaeem1 joined
[19:17] <dalek> roast: 0aa3fde | usev6++ | S02-literals/numeric.t:

[19:17] <dalek> roast: Unfudge some tests for RT #124559

[19:17] <dalek> roast: review: https://github.com/perl6/roast/commit/0aa3fde915

[19:26] *** domidumont left
[19:37] <moritz> FROGGS: funny, we had an actual bug in our time accounting regarding DST

[19:37] <moritz> FROGGS: when entering a time that ended at midnight, it would miscalculate the date, becaue it assumed each day had 24 hours

[19:38] <FROGGS> moritz: well, I had (of course) bugs in that area in the past... also involving endless loops when we added 24 hours and expecting to get to the next day

[19:38] <FROGGS> though that was when doing most stuff in php... it got better when we switched to Perl :o)

[19:38] <Ven> oh, we have &?BLOCK now? amazing :D. jnthn++

[19:41] <skids> b2gills: I'll look into that block .signature problem probly next week.

[19:42] <skids> And yes jnthn++.  Now I have to go figure out all the places where I worked around not having it :-)

[19:42] <Ven> m: { my $a = &?BLOCK; }

[19:42] <camelia> rakudo-moar 3bdd0a: ( no output )

[19:43] *** FROGGS left
[19:44] *** virtualsue left
[19:46] *** virtualsue joined
[19:47] *** molaf_ left
[19:49] *** [Sno] joined
[19:50] <skids> m:  say (for 1..2 -> $a { &?BLOCK.last(3); })# uhp, well I guess we need .last now :-)

[19:50] <camelia> rakudo-moar 3bdd0a: OUTPUT«Method 'last' not found for invocant of class 'Block'␤  in block <unit> at /tmp/aIzmoZwI1r:1␤␤»

[19:53] *** notjack joined
[19:54] <Ven> skids: and leave :P

[19:54] *** muraiki left
[19:57] <dalek> roast: f6a7dfb | usev6++ | S06-advanced/wrap.t:

[19:57] <dalek> roast: Change test from 'dies-ok' to 'throws-like'

[19:57] <dalek> roast: review: https://github.com/perl6/roast/commit/f6a7dfb95d

[19:58] <notjack> m: 3.WHAT.say;

[19:58] <camelia> rakudo-moar 3bdd0a: OUTPUT«(Int)␤»

[19:58] <notjack> m: Int.WHAT.say;

[19:58] <camelia> rakudo-moar 3bdd0a: OUTPUT«(Int)␤»

[20:08] <dalek> roast: 865092a | usev6++ | S32-str/substr.t:

[20:08] <dalek> roast: Don't fudge whole block for JVM (RT #124692)

[20:08] <dalek> roast: review: https://github.com/perl6/roast/commit/865092ac66

[20:10] <masak> notjack: the .WHAT of a type object is the type object itself.

[20:12] *** darutoko left
[20:15] *** notjack left
[20:18] *** Alina-malina left
[20:19] *** Alina-malina joined
[20:23] *** amurf joined
[20:25] *** pecastro left
[20:28] *** amurf left
[20:30] *** zakharyas joined
[20:32] *** diana_olhovik left
[20:34] *** diana_olhovik joined
[20:36] *** ab6tract joined
[20:37] *** itz__ joined
[20:40] *** davido___ left
[20:40] *** itz_ left
[20:40] *** davido___ joined
[20:41] *** rurban joined
[20:53] <dalek> rakudo-star-daily: 74c1fe2 | coke++ | log/ (9 files):

[20:53] <dalek> rakudo-star-daily: today (automated commit)

[20:53] <dalek> rakudo-star-daily: review: https://github.com/coke/rakudo-star-daily/commit/74c1fe2743

[20:53] *** zakharyas left
[20:59] *** rurban left
[21:03] *** ab6tract left
[21:04] *** beastd joined
[21:05] *** skids left
[21:09] *** diana_olhovik left
[21:13] <jnthn> The report on last week's work: https://6guts.wordpress.com/2015/07/09/this-week-digging-into-multi-dimensional-arrays-and-plenty-more/

[21:13] <jnthn> 'night, #perl6

[21:14] <masak> jnthn++ # blug

[21:14] <masak> 'night, jnthn 

[21:15] <lizmat> gnight jnthn 

[21:16] *** rurban joined
[21:16] *** rurban left
[21:26] <cognominal> jnthn++

[21:27] *** TEttinger joined
[21:27] *** pyrimidine left
[21:28] <dalek> rakudo/nom: 01a60df | lizmat++ | src/core/List.pm:

[21:28] <dalek> rakudo/nom: Handle offset past end as failure (as per spec)

[21:28] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/01a60df924

[21:34] *** kaare_ left
[21:36] *** ab6tract joined
[21:36] *** pyrimidine joined
[21:37] <ab6tract> masak, FROGGS: I enjoyed reading your DateTime::Span discussion in the backlog

[21:37] <yoleaux> 16:09Z <[Coke]> ab6tract: - yes, I see that, it was clear. I obviously responded before backscroll completed, but does that mean I shouldn't have voiced my opinion, even if I had waited until I caught up?

[21:37] <masak> how long was the interval you enjoyed it? :P

[21:38] <PerlJam> .oO( many many many light-meters )

[21:38] <ab6tract> [Coke]: no, of course not

[21:38] <ab6tract> masak: at least a parsec ;)

[21:39] * ab6tract hopes the Han Solo reference carries through

[21:39] <masak> indeed.

[21:43] *** atroxaper joined
[21:47] *** atroxaper left
[21:49] <lizmat> m: say [email@hidden.address]  # why are we backslashing the array ?

[21:49] <camelia> rakudo-moar 3bdd0a: OUTPUT«"\@a.foo"␤»

[21:49] <masak> no good reason.

[21:49] <ab6tract> The thing about intervals that distinguishes them from a range of dates is that it would feel natural to me to have a range of intervals. since ranges can't have ranges as endpoints, a different solution must be found.

[21:49] <geekosaur> seems like a holdover from perl5?

[21:50] <masak> ab6tract: I'm all for having intervals of Instant.

[21:50] <masak> ab6tract: intervals of DateTime just aren't well-defined. ranges of intervals of DateTime even less so.

[21:51] <masak> ab6tract: the conceptual problems keep multiplying as you build bigger and bigger abstractions on a murky foundation.

[21:51] <lizmat> geekosaur: yeah, feels like it

[21:52] <masak> backslashing @a there is not wrong. just unnecessary.

[21:52] <masak> m: say "\@a".perl

[21:52] <camelia> rakudo-moar 01a60d: OUTPUT«"\@a"␤»

[21:52] <geekosaur> actually I think early on (like pugs era) we still expanded simple variables

[21:52] <masak> m: say "@a".perl

[21:52] <camelia> rakudo-moar 01a60d: OUTPUT«"\@a"␤»

[21:52] <ab6tract> fair enough. the ecosystem is a fine place for something more robust

[21:52] <dalek> specs: 5e0b4bd | (Stéphane Payrard)++ | S03-operators.pod:

[21:52] <dalek> specs: suppressed spurious double quotes

[21:52] <dalek> specs: review: https://github.com/perl6/specs/commit/5e0b4bd50a

[21:53] <masak> there isn't a "more robust". it's ill-defined even in theory.

[21:53] <ab6tract> because my idea is exactly that the murky foundations exist and I'm tired of dealing with '2002' as an numeric value

[21:53] <masak> ab6tract: if you want to deal with '2002', define a class Year, and give it all the DateTime semantics you please.

[21:53] <ab6tract> when it could be an object with knowledge of 2002's specifities

[21:53] <masak> people are too afraid sometimes to build their own abstractions.

[21:55] <ab6tract> what exactly are you talking about? I have a) agreed that it wasn't a thing for Date, but Dateish, and b) said that I will do my own thing and put it in the ecosystem

[21:55] <ab6tract> I fail to see my unwillingness to craft my own abstraction

[21:58] <lizmat> .oO( maybe it's an ab6traction? )

[21:58] <masak> m: class Year { has $.year; has $.start-date = Date.new(:$!year, :month(1), :day(1)); has $.end-date = Date.new(:$!year, :month(12), :day(31)); method leap-year { $.start-date.is-leap-year } }; say .end-date and say .leap-year given Year.new(:year(2012))

[21:58] <camelia> rakudo-moar 01a60d: OUTPUT«2012-12-31␤True␤»

[21:59] <masak> ab6tract: oh, it's quite possible that we agree and that I'm just arguing our side too agressively. apologies if so. ;)

[22:00] <ab6tract> cheers :)

[22:02] <ab6tract> is anyone going to the Swiss Perl Workshop?

[22:04] * masak 

[22:04] <ab6tract> cool!

[22:05] <masak> see each other there?

[22:05] <ab6tract> I'd imagine so ;)

[22:05] <RabidGravy> I'll be in Ibiza I think ;-)

[22:06] <ab6tract> RabidGravy: well, shortly after I'll be talking up Perl 6 ops in Grenada :)

[22:07] * vendethiel should be coming as well

[22:07] <masak> \o/

[22:08] <itz__> RabidGravy: rave on?

[22:09] <RabidGravy> well probably just drinking too much and winding up deep house DJs ;-)

[22:09] <ab6tract> I notice jnthn has a new async talk scheduled :D

[22:09] <ab6tract> and yours looks cool too, vendethiel :D

[22:10] <dalek> rakudo/nom: 1b537b9 | lizmat++ | src/core/List.pm:

[22:10] <dalek> rakudo/nom: Some failure mode tweaks

[22:10] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/1b537b90dd

[22:10] <ab6tract> MAIN is definitely a super-sweet feature that tends to impress folks

[22:11] <itz__> "doves and white gloves"

[22:11] <itz__> ;)

[22:11] <dalek> roast: 48a5a13 | lizmat++ | S32-array/splice.t:

[22:11] <dalek> roast: Add some more sanity / failure tests

[22:11] <dalek> roast: review: https://github.com/perl6/roast/commit/48a5a13565

[22:11] <Ven> ab6tract: i'm particularly found of the talk title :P

[22:12] <ab6tract> masak: both of yours sound awesome as well. it's a p6 party! :D

[22:12] *** spider-mario left
[22:13] * lizmat will be at SPW as well

[22:13] <lizmat> but probably not in the best of shapes, as we will have come back from the YAPC::Asia only days before

[22:13] <cognominal> m: say True.'!' #  https://github.com/perl6/specs/blame/master/S03-operators.pod#L2867

[22:13] <camelia> rakudo-moar 01a60d: OUTPUT«5===SORRY!5=== Error while compiling /tmp/pfXTxsU6br␤Quoted method name requires parenthesized arguments. If you meant to concatenate two strings, use '~'.␤at /tmp/pfXTxsU6br:1␤------> 3say True.'!'7⏏5 #  https://github.com/perl6/specs/blame…»

[22:13] <masak> ab6tract: glad to hear it! I'm looking forward to it all too. :)

[22:14] <cognominal> do I misinterpret the doc, or is this not supported?

[22:14] <lizmat> and on that note, I wish everybody a good night's sleep (unless prohibited)

[22:14] <ab6tract> masak: now I need to decide whether to give a dry run of my Whatever talk that's already scheduled for YAPC::EU

[22:14] *** virtualsue left
[22:15] <ab6tract> or use the opportunity to prepare a different one

[22:15] <cognominal> m: my @a = < a b c>;  say @a.'$'

[22:15] <camelia> rakudo-moar 01a60d: OUTPUT«5===SORRY!5=== Error while compiling /tmp/fjeUiAZw8C␤Quoted method name requires parenthesized arguments. If you meant to concatenate two strings, use '~'.␤at /tmp/fjeUiAZw8C:1␤------> 3my @a = < a b c>;  say @a.'$'7⏏5<EOL>␤»

[22:16] <ab6tract> nice to have choices :)

[22:16] <masak> ab6tract: http://i0.kym-cdn.com/photos/images/newsfeed/000/538/731/0fc.gif

[22:17] <ab6tract> I've been wanting to talk about general "programming culture" trends, the cycles of buildup and teardown (*sheds a tear for jQuery*), famous flame war quotables, etc

[22:18] <ab6tract> masak: well played sir. I can honestly type lol for that one :)

[22:19] <labster> m: say DateTime.now < now;

[22:19] <camelia> rakudo-moar 01a60d: OUTPUT«Cannot call Real(DateTime: ); none of these signatures match:␤    (Mu:U \v: *%_)␤  in block <unit> at /tmp/uDv0emrYoi:1␤␤»

[22:19] <ab6tract> through the lens of perl's history

[22:20] <ab6tract> m: say so DateTime.now before now

[22:20] <camelia> rakudo-moar 01a60d: OUTPUT«True␤»

[22:23] <ab6tract> are there any hidden gotchas behind 'before' ? I ask because I developed a hand rolled "version" of it before chancing upon it on the periodic table today

[22:23] <labster> wow, didn't know about before.

[22:23] <cognominal> m: my $a; @$a = 1,2,3

[22:23] <camelia> rakudo-moar 01a60d: OUTPUT«Cannot modify an immutable List␤  in block <unit> at /tmp/Nd84kew49J:1␤␤»

[22:23] <ab6tract> labster: me either :)

[22:23] *** bin_005 left
[22:24] <cognominal> hum, many things dubious and not implemented in S03 :(

[22:24] <masak> ab6tract: only that `before` is the least specific you can get. so prefer more specific ones (`<`, `lt`) whenever it makes sense.

[22:24] <cognominal> m: my $a; $a[] = 1,2,3

[22:24] <camelia> rakudo-moar 01a60d: OUTPUT«Cannot modify an immutable Any␤  in block <unit> at /tmp/gonFkl7ROv:1␤␤»

[22:24] <labster> multi sub infix:<before>(\a, \b)   { (a cmp b) < 0 } # I doub't there's anything gotcha in here.

[22:25] <labster> and apparently doub't is now a contraction :)

[22:26] <TimToady> that's dub'itable

[22:26] <ab6tract> I thought I was pretty cool doing:

[22:26] <ab6tract> m: my $a=DateTime.now; my $cmp = $a ~~ Numeric ?? * <= * !! * lt *; $cmp($a,now)

[22:26] <camelia> rakudo-moar 01a60d: ( no output )

[22:27] <TimToady> well, but you should only do lt if it's a string, and use 'before' for the general case...

[22:27] <masak> 'night, #perl6

[22:27] <labster> I do feel like one should be able to compare Instants and DateTimes with the numeric comparison operators.  I was thinking about having both DateTime and Instant inherit from a role, but can't decide what to name it.

[22:28] <labster> I was thinking about Momentous.

[22:28] <ab6tract> labster: note that 'lt' works here because stringified DateTime comparison DWIMs

[22:28] <ab6tract> TimToady: yeah, but this was before I know about 'before' :)

[22:28] <TimToady> m: say DateTime.new.earlier(:2000years)

[22:28] <camelia> rakudo-moar 01a60d: OUTPUT«Required named parameter 'year' is missing for DateTime.new()␤  in block <unit> at /tmp/gnqlOicGzA:1␤␤»

[22:28] <TimToady> m: say DateTime.new.earlier(:2000year)

[22:28] <camelia> rakudo-moar 01a60d: OUTPUT«Required named parameter 'year' is missing for DateTime.new()␤  in block <unit> at /tmp/1PblTEjXwN:1␤␤»

[22:29] <TimToady> m: say DateTime.now.earlier(:2000year)

[22:29] <camelia> rakudo-moar 01a60d: OUTPUT«0015-07-10T00:29:05+02:00␤»

[22:29] <TimToady> I guess... :)

[22:29] <TimToady> was there a leap second that year?  :P

[22:29] <ab6tract> night masak!

[22:31] <labster> m: say DateTime.now.later(:1000year) lt now;

[22:31] <camelia> rakudo-moar 01a60d: OUTPUT«True␤»

[22:31] <RabidGravy> .tell jnthn that it seems that the https://rt.perl.org/Ticket/Display.html?id=125408 has gone away at 2015.06-226-g01a60df built on MoarVM version 2015.06-88-g647df11

[22:31] <yoleaux> RabidGravy: I'll pass your message to jnthn.

[22:31] <ab6tract> okay, so now it don't :)

[22:31] <ab6tract> s/now/no/

[22:32] <ab6tract> m: DateTime.now.later(:1000year) before now

[22:32] <camelia> rakudo-moar 01a60d: ( no output )

[22:32] <ab6tract> m: say DateTime.now.later(:1000year) before now

[22:32] <camelia> rakudo-moar 01a60d: OUTPUT«True␤»

[22:32] <labster> m: say DateTime.now.earlier(:1000year) before now

[22:32] <camelia> rakudo-moar 01a60d: OUTPUT«True␤»

[22:32] <labster> Time is circular

[22:32] <TimToady> um, comparing DateTimes with Instants there

[22:33] <TimToady> m: say DateTime.now.earlier(:2000year) before DateTime.now

[22:33] <camelia> rakudo-moar 01a60d: OUTPUT«True␤»

[22:33] <labster> Yeah, the stringy representations are bound to be wrong.  But I think it makes sense to let < and friends work.

[22:34] <TimToady> then people will think they're working with normal numbers, which is misleading

[22:35] <labster> m: say now < now

[22:36] <camelia> rakudo-moar 01a60d: OUTPUT«True␤»

[22:36] <labster> so that's misleading too?

[22:36] <ab6tract> TimToady: I assumed that DateTime.now was the equivalent of calling : DateTime.new( now )

[22:36] <ab6tract> labster: I think 'before' is good enough for me

[22:36] <labster> ab6tract: it's very similar, but .now includes the timezone

[22:37] <ab6tract> labster: ah, gotcha

[22:39] <labster> TimToady: I ask about the comparison ops for Date/DateTime/Instant, because of https://rt.perl.org/Ticket/Display.html?id=125555

[22:41] <TimToady> m: my $dt1 = DateTime.now; say +$dt1

[22:41] <camelia> rakudo-moar 01a60d: OUTPUT«Cannot call Numeric(DateTime: ); none of these signatures match:␤    (Mu:U \v: *%_)␤  in block <unit> at /tmp/48RaAFhT9z:1␤␤»

[22:41] <TimToady> < is supposed to coerce to Numeric, and I do not think we should be overloading things with < that don't do that

[22:42] <TimToady> m: +now

[22:42] <camelia> rakudo-moar 01a60d: ( no output )

[22:42] <TimToady> m: say +now

[22:42] <camelia> rakudo-moar 01a60d: OUTPUT«Instant:1436481797.189694␤»

[22:42] <labster> Well, it could by coverting to TAI.

[22:42] <labster> *converting

[22:43] <labster> secretly, of course

[22:43] <TimToady> we've been trying to move away from epochs, and I'm not terribly interested in re-installing them into the languge

[22:44] <ab6tract> m: say DateTime.now.later(:1day).Instant before now

[22:44] <camelia> rakudo-moar 01a60d: OUTPUT«False␤»

[22:44] <ab6tract> that's pretty clear :)

[22:44] <[Coke]> (swiss perl workshop) maybe, depending on funding.

[22:44] <ab6tract> [Coke]++

[22:45] <TimToady> just as we've moved away from absolute precedence levels, and we encourage everyone to add new precedence relative to existing precedence levels

[22:45] <ab6tract> labster: tbh, that ticket almost makes me think that < could be turned off for Date instead

[22:46] <TimToady> yes, I think that supporting < there is something like a mistake

[22:46] <labster> m: say DateTime.now.later(:1day).Instant after now

[22:46] <camelia> rakudo-moar 01a60d: OUTPUT«True␤»

[22:46] *** rindolf left
[22:46] <labster> before and after seem about right.  We'd just need to support cmp for these, which is pretty easy.

[22:47] <TimToady> well, we still haven't made a final determination about comparisons between different types

[22:48] <ab6tract> TimToady: that seems like something that should throw an exception

[22:48] * TimToady suspects that we want to differentiate cmp into strict and lax versions, with sort using the lax version

[22:48] <[Coke]> m: A::B

[22:48] <camelia> rakudo-moar 01a60d: OUTPUT«Could not find symbol '&B'␤  in block <unit> at /tmp/QFPMXNqMbE:1␤␤»

[22:48] <ab6tract> $a cmp $b :lax

[22:48] <TimToady> m: say 42 before "123"

[22:48] <camelia> rakudo-moar 01a60d: OUTPUT«False␤»

[22:48] <[Coke]> std: A::B

[22:48] <camelia> std 28329a7: OUTPUT«5===SORRY!5===␤Undeclared name:␤        'A::B' used at line 1␤Check failed␤FAILED 00:00 134m␤»

[22:48] <TimToady> m: say "42" before 123

[22:48] <camelia> rakudo-moar 01a60d: OUTPUT«False␤»

[22:49] <[Coke]> TimToady: std's behavior there is desired, yes

[22:49] <[Coke]> ?

[22:49] <TimToady> currently I think it just stringifies between types, but that's probably not the best thing

[22:50] <TimToady> [Coke]: yeah, I think the full name would probably be more awesome

[22:50] <ab6tract> TimToady: yeah, that sounds like the kind of thing that should only happen via an explicit mechanism

[22:50] <[Coke]> TimToady: danke. digging...

[22:52] <ab6tract> plus, you can catch the exception, and if you have known-dirty lists with routines ready to handle turning the Milk into Cheese based on a given context, you do your business and resume the exception

[22:53] <ab6tract> so to speak

[22:53] <TimToady> or at least provide a Cheese view of the Milk, if Milk is immutable...

[22:53] <ab6tract> well said

[22:54] <ab6tract> though the milk must already be cheese then, to be so solid? ;)

[22:55] <labster> Perl 6 has liquid typing.

[22:55] <ab6tract> have a great *, #perl6. catch you on .succ

[22:56] <labster> good night, ab6tract

[22:56] <TimToady> .tell jnthn "to implementing through implementing"?

[22:56] <yoleaux> TimToady: I'll pass your message to jnthn.

[22:56] *** ab6tract left
[22:57] * [Coke] looks at the ll exception backtrace for that and tries to figure out what is calling the Stash AT-KEY that is failing.

[22:58] *** beastd left
[22:58] *** skids joined
[22:59] <[Coke]> it's soft failing - at the point that it fails, it only has the &B and the stash doesn't seem to know it's own name. wondering if there's something in the Perl6 Action I can tweak there...

[22:59] *** roguelazer left
[23:00] * TimToady is tired of typing --ll-exception

[23:01] <[Coke]> is there anything that hides from ll-exception and can I show that?

[23:01] <[Coke]> *its own, bah.

[23:06] *** amurf joined
[23:06] *** anaeem1 left
[23:07] *** anaeem1_ joined
[23:07] <RabidGravy> nighty night people!

[23:07] <[Coke]> ~~

[23:10] <labster> alias 6 perl6 --ll-exception

[23:12] *** RabidGravy left
[23:14] <[Coke]> is there a parameter to make fail die immediately?

[23:14] <[Coke]> or get the backtrace from the fail, not from where it ends up throwing?

[23:14] <[Coke]> fail--

[23:14] <[Coke]> [6~[6~

[23:15] *** anaeem1_ left
[23:16] * [Coke] gives up and moves on to a more tractable RT. :P

[23:17] <skids> [Coke]: I've the hood open on Failure right now and that is one of the things I'm looking at

[23:28] <psch> hi #perl6 o/

[23:29] <psch> i have 2 FAILs in S04-phasers/enter-leave.t, on jvm.  i wouldn't have thought that the changes in my branch are responsible, has anything there come up?

[23:32] <[Coke]> psch: https://github.com/coke/perl6-roast-data/blob/master/log/rakudo.jvm_summary.out#L1846

[23:33] <psch> [Coke]: thanks, that's reassuring.  i might be able to spare a look, although i suspect the guts of phasers on jvm are a bit beyond me

[23:37] <psch> m: say ((rand * 10) %% 2 ?? "standalone jar" !! "roast fixes")

[23:37] <camelia> rakudo-moar 1b537b: OUTPUT«roast fixes␤»

[23:38] <psch> ...because what good is a deployable format if it doesn't pass the official test suite, i guess

[23:38] <[Coke]> if we have an enum, and support ++ -- on it, what should happen at the ends of the enum?

[23:39] <[Coke]> m: Enum A <a b c>; my A $q = a; say $q++; say $q++;say $q++;say $q++;

[23:39] <camelia> rakudo-moar 1b537b: OUTPUT«5===SORRY!5=== Error while compiling /tmp/VqZnC0IbFY␤Two terms in a row␤at /tmp/VqZnC0IbFY:1␤------> 3Enum7⏏5 A <a b c>; my A $q = a; say $q++; say $␤    expecting any of:␤        infix␤        infix stopper␤        statement end␤…»

[23:40] <[Coke]> m: enum A <a b c>; my A $q = a; say $q++; say $q++;say $q++;say $q++;

[23:40] <camelia> rakudo-moar 1b537b: OUTPUT«Type check failed in assignment to '$q'; expected 'A' but got 'Int'␤  in block <unit> at /tmp/B3mNplEoBs:1␤␤»

[23:40] <[Coke]> m: enum A <a b c>; my A $q = a; say $q++;

[23:40] <camelia> rakudo-moar 1b537b: OUTPUT«Type check failed in assignment to '$q'; expected 'A' but got 'Int'␤  in block <unit> at /tmp/GB4_KjYciJ:1␤␤»

[23:40] <psch> m: enum A <a b c>; my $a = b; say $a++ 

[23:40] <camelia> rakudo-moar 1b537b: OUTPUT«b␤»

[23:40] <psch> m: enum A <a b c>; my $a = c; say $a++ 

[23:40] <camelia> rakudo-moar 1b537b: OUTPUT«c␤»

[23:40] <psch> oh wait

[23:40] <[Coke]> m: enum A <a b c>; a++.say;

[23:40] <camelia> rakudo-moar 1b537b: OUTPUT«Cannot assign to an immutable value␤  in block <unit> at /tmp/4apOGLOpJ1:1␤␤»

[23:40] <psch> m: enum A <a b c>; my $a = c; say ++$a

[23:40] <camelia> rakudo-moar 1b537b: OUTPUT«3␤»

[23:41] <psch> m: enum A <a b c>; my $a = c; $a++ andthen say $a

[23:41] <camelia> rakudo-moar 1b537b: OUTPUT«3␤»

[23:41] <psch> makes sense to me, coerce to Numeric and assign

[23:41] <[Coke]> right. Trying to fix that so you get the enum back, not the int val. but if you have c, should get c back?

[23:41] <[Coke]> psch: see RT #92742

[23:42] <[Coke]> or does that throw?

[23:42] <psch> m: enum A <a b c>; say b.succ

[23:42] <camelia> rakudo-moar 1b537b: OUTPUT«2␤»

[23:42] <psch> that should give c

[23:42] <psch> imo

[23:42] <psch> but c.succ... i'm not sure

[23:42] <psch> i'm leaning towards modulo arithmetic

[23:42] <psch> i.e. wrap around

[23:43] <dalek> ecosystem: 3481a5c | hoelzro++ | META.list:

[23:43] <dalek> ecosystem: Add Algorithm::Elo to ecosystem

[23:43] <dalek> ecosystem: review: https://github.com/perl6/ecosystem/commit/3481a5c3be

[23:43] <[Coke]> .ask TimToady if we can get a ruling on RT#92742 - should enum <a b c>; c++ give c, a, or die?

[23:43] <yoleaux> [Coke]: I'll pass your message to TimToady.

[23:44] <[Coke]> m: class A { has str $.x; method BUILD(:$!x) { } }; say A.new(:x<foo>).x'

[23:44] <camelia> rakudo-moar 1b537b: OUTPUT«5===SORRY!5=== Error while compiling /tmp/DYlXqapa8B␤Two terms in a row␤at /tmp/DYlXqapa8B:1␤------> 3 BUILD(:$!x) { } }; say A.new(:x<foo>).x7⏏5'␤    expecting any of:␤        infix␤        infix stopper␤        postfix␤        s…»

[23:45] <[Coke]> m: class A { has str $.x; method BUILD(:$!x) { } }; say A.new(:x<foo>).x

[23:45] <camelia> rakudo-moar 1b537b: OUTPUT«Cannot modify an immutable str␤  in method BUILD at /tmp/fVt6fwaJ3s:1␤  in block <unit> at /tmp/fVt6fwaJ3s:1␤␤»

[23:45] *** BenGoldberg joined
[23:46] <psch> actually, thinking more about it throwing seems more fitting

[23:46] <psch> enumeration is (somewhat) counting, and counting beyond what is countable isn't feasible

[23:46] <psch> kind of the inverse of "you can't count to Inf"

[23:48] *** tinyblak joined
[23:49] <psch> ...we wouldn't want to pidgeon hole people into modulo arithmetic :)

[23:50] *** nightfrog left
[23:55] *** nightfrog joined
[23:55] <[Coke]> .ask jnthn I bet RT #107204 is closable with tests after your nfg work.

[23:55] <yoleaux> [Coke]: I'll pass your message to jnthn.

[23:57] *** kurahaupo joined
[23:58] *** Ven left
