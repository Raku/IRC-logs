[00:07] <skids> m: use nqp; sub a ( \a ) { 42.say }; a(Failure.new);

[00:07] <GLRelia> rakudo-moar abf079: OUTPUT«42␤»

[00:07] <camelia> rakudo-moar 93418e: OUTPUT«42␤»

[00:07] <skids> m: use nqp; sub a ( \a ) { nqp::push(IterationBuffer.CREATE, a) }; a(Failure.new);

[00:07] <GLRelia> rakudo-moar abf079: OUTPUT«Failed␤␤Actually thrown at:␤  in block <unit> at /tmp/ld6fgKt2jZ:1␤␤»

[00:07] <camelia> rakudo-moar 93418e: OUTPUT«5===SORRY!5=== Error while compiling /tmp/0NUwHX642A␤Undeclared name:␤    IterationBuffer used at line 1␤␤»

[00:07] <skids> m: use nqp; my \a ::= Failure.new; nqp::push(IterationBuffer.CREATE, a);

[00:07] <GLRelia> rakudo-moar abf079: ( no output )

[00:07] <camelia> rakudo-moar 93418e: OUTPUT«5===SORRY!5=== Error while compiling /tmp/0qXoexjqKO␤Undeclared name:␤    IterationBuffer used at line 1␤␤»

[00:08] <skids> o.O I'm actually... stumped.

[00:10] *** aborazmeh left
[00:15] *** aborazmeh joined
[00:15] *** aborazmeh left
[00:15] *** aborazmeh joined
[00:17] *** laouji joined
[00:17] *** AlexDaniel joined
[00:18] *** raiph joined
[00:18] *** KCL_ joined
[00:18] <skids> m: use nqp; sub a ( $a ) { nqp::push(IterationBuffer.CREATE, $a) }; a(Failure.new); # \o/

[00:18] <GLRelia> rakudo-moar abf079: ( no output )

[00:18] <camelia> rakudo-moar 93418e: OUTPUT«5===SORRY!5=== Error while compiling /tmp/tOB65fZEyi␤Undeclared name:␤    IterationBuffer used at line 1␤␤»

[00:19] <skids> Failure + sigilless param + nqp:: op makes bad mojo.

[00:20] <raiph> Mu does Numeric;    # Cannot use 'does' operator with a type object.

[00:20] <raiph> The correct way to applies roles to type objects is at declaration time class GrassmannNumber does Numeric { ... }

[00:20] <raiph> Sorry, that's scrambled

[00:24] <raiph> "The correct way..." is from http://doc.perl6.org/type/X::Does::TypeObject

[00:27] *** LordVorp left
[00:29] *** aborazmeh left
[00:31] *** aborazmeh joined
[00:31] *** aborazmeh left
[00:31] *** aborazmeh joined
[00:39] *** laouji left
[00:39] *** laouji joined
[00:43] *** laouji left
[00:44] *** laouji joined
[00:46] *** bjz joined
[00:46] <TimToady> .tell jnthn lists should just match literally, and we should have an explicit list pattern type, or extend regex to cover Positional matching

[00:46] <yoleaux> TimToady: I'll pass your message to jnthn.

[00:48] *** bjz left
[00:53] <timotimo> oh, huh. i was going to do the weekly some time today, but suddenly it turned 3am

[00:57] *** bjz joined
[00:58] *** bjz left
[00:58] <dalek> doc: d494fbd | skids++ | lib/Type/X/Does/TypeObject.pod:

[00:58] <dalek> doc: Fix and flesh out X::Does::TypeObject, raiph++

[00:58] <dalek> doc: review: https://github.com/perl6/doc/commit/d494fbd072

[00:58] *** BenGoldberg joined
[01:00] <ugexe> is there a way to show the normal failure message if --ll-exception is set?

[01:02] *** AlexDaniel left
[01:02] *** AlexDani` joined
[01:03] <ugexe> i want to use --ll-exception so if a module is not found it exits non-zero, but i dont want to show the entire dump of --ll-exception 

[01:03] <ugexe> module not found while using Test.pm^ rather

[01:25] <skids> ugexe: maybe a "use fatal" may catch a failure early?

[01:40] *** cognominal left
[01:42] <skids> Aha. It's just:

[01:42] <skids> m: use nqp; sub a ( $a ) { return $a }; a(Failure.new);

[01:42] <GLRelia> rakudo-moar abf079: ( no output )

[01:42] <camelia> rakudo-moar 93418e: ( no output )

[01:43] <skids> m: use nqp; sub a ( a ) { return a }; a(Failure.new);

[01:43] <GLRelia> rakudo-moar abf079: OUTPUT«5===SORRY!5=== Error while compiling /tmp/xWmwPrWhkz␤Invalid typename 'a' in parameter declaration.␤at /tmp/xWmwPrWhkz:1␤------> 3use nqp; sub a ( a7⏏5 ) { return a }; a(Failure.new);␤»

[01:43] <camelia> rakudo-moar 93418e: OUTPUT«5===SORRY!5=== Error while compiling /tmp/MdqEarOBDs␤Invalid typename 'a' in parameter declaration.␤at /tmp/MdqEarOBDs:1␤------> 3use nqp; sub a ( a7⏏5 ) { return a }; a(Failure.new);␤»

[01:43] <skids> oh

[01:43] <skids> m: use nqp; sub a ( \a ) { return a }; a(Failure.new);

[01:43] <GLRelia> rakudo-moar abf079: OUTPUT«Failed␤␤Actually thrown at:␤  in block <unit> at /tmp/H_mFUXaV37:1␤␤»

[01:43] <camelia> rakudo-moar 93418e: OUTPUT«Failed␤␤Actually thrown at:␤  in block <unit> at /tmp/WZPf21pu3M:1␤␤»

[01:44] *** llfourn joined
[01:44] *** ilbot3 left
[01:46] *** ilbot3 joined
[01:49] *** llfourn left
[01:58] *** dayangkun joined
[02:16] *** cognominal joined
[02:16] *** blackcat_ joined
[02:20] *** KCL_ left
[02:22] * jnthn made it to Tokyo

[02:22] <yoleaux> 00:46Z <TimToady> jnthn: lists should just match literally, and we should have an explicit list pattern type, or extend regex to cover Positional matching

[02:24] <skids> o/ from the other side of the world

[02:24] <lizmat> jnthn o/

[02:25] * jnthn is crazy tired because he was sleep deprived before the trip and can't sleep on planes

[02:25] <skids> I won't bother you with my probably-nqp-or-optimizer problem now then :-)

[02:26] <jnthn> No, don't :P

[02:26] <jnthn> I did get upgraded to economy plus, which mean I had a power socket

[02:26] <jnthn> So I wrote a little code...

[02:27] <TEttinger> jnthn: maybe you'll dream about the GLR. Godzilla List Refactoring

[02:28] *** noganex_ joined
[02:30] <dalek> nqp: 87d8a61 | jnthn++ | src/vm/jvm/ (2 files):

[02:30] <dalek> nqp: Add new control exception types for JVM.

[02:30] <dalek> nqp: 

[02:30] <dalek> nqp: To support new async features in Perl 6.

[02:30] <dalek> nqp: review: https://github.com/perl6/nqp/commit/87d8a61a9a

[02:30] <dalek> nqp: d85cdc4 | jnthn++ | / (2 files):

[02:30] <dalek> nqp: Bump MOAR_REVISION; add new control exceptions.

[02:30] <dalek> nqp: review: https://github.com/perl6/nqp/commit/d85cdc4950

[02:31] *** noganex left
[02:31] <dalek> rakudo/nom: ec640d5 | jnthn++ | src/core/Proc/Async.pm:

[02:31] <dalek> rakudo/nom: Tweaks to avoid conflict with new supply syntax.

[02:31] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/ec640d5c1b

[02:31] <dalek> rakudo/nom: f996bbf | jnthn++ | src/Perl6/ (2 files):

[02:31] <dalek> rakudo/nom: Stub in supply { ... } syntax.

[02:31] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/f996bbfef8

[02:31] <dalek> rakudo/nom: 5400fce | jnthn++ | src/Perl6/ (2 files):

[02:31] <dalek> rakudo/nom: Stub in whenever syntax.

[02:31] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/5400fcea09

[02:31] <dalek> rakudo/nom: e838194 | jnthn++ | src/Perl6/ (2 files):

[02:31] <dalek> rakudo/nom: Stub in QUIT phaser.

[02:31] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/e838194746

[02:31] <dalek> rakudo/nom: 207399e | jnthn++ | tools/build/NQP_REVISION:

[02:31] <dalek> rakudo/nom: Get NQP_REVISION with new control exceptions.

[02:31] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/207399e69d

[02:31] <dalek> rakudo/nom: fb20929 | jnthn++ | src/core/ (3 files):

[02:31] <dalek> rakudo/nom: Initial implementation of supply/whenever.

[02:31] <dalek> rakudo/nom: 

[02:31] <dalek> rakudo/nom: Already covers a good amount of the design laid out in my S17 gist,

[02:31] <dalek> rakudo/nom: including LAST and QUIT phasers inside of whenever blocks, multiple

[02:31] <dalek> rakudo/nom: whenever blocks, concurrency control, etc. Note that the emit and done

[02:31] <dalek> rakudo/nom: control exception subs ended up as supply-emit and supply-done for now,

[02:31] <dalek> rakudo/nom: since rather unfortunately the name 'done' is used in Test.pm. I guess

[02:31] <dalek> rakudo/nom: S17 might win the keyword away from testing stuff, but for now this

[02:31] <dalek> rakudo/nom: avoids any confusion.

[02:31] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/fb209296f0

[02:32] <dalek> rakudo/nom: 7bf7457 | jnthn++ | t/spectest.data:

[02:32] <dalek> rakudo/nom: Run S17-supply/syntax.t.

[02:32] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/7bf7457917

[02:32] <dalek> rakudo/nom: 1f15ace | jnthn++ | src/core/Promise.pm:

[02:32] <dalek> rakudo/nom: Implement Promise.Supply.

[02:32] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/1f15ace748

[02:32] <dalek> rakudo/nom: 0e8fbd5 | jnthn++ | src/core/Supply.pm:

[02:32] <dalek> rakudo/nom: Coerce whenever expression to a Supply.

[02:32] <dalek> rakudo/nom: 

[02:32] <dalek> rakudo/nom: This means whenever $promise -> $result { } works.

[02:32] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/0e8fbd50ad

[02:32] <dalek> rakudo/nom: 7cda449 | jnthn++ | src/ (3 files):

[02:32] <dalek> rakudo/nom: Add tentative `react` block.

[02:32] <dalek> rakudo/nom: 

[02:32] <dalek> rakudo/nom: The supply block is great for processing stages, but you'll often have

[02:32] <dalek> rakudo/nom: some kind of "top level" in an asynchronous application - or those new

[02:32] <dalek> rakudo/nom: to the Perl 6 asynchronous features will want an easy way to play with

[02:32] <dalek> rakudo/nom: things. Creating a Supply to immediately wait on it would thus be a

[02:32] <dalek> rakudo/nom: really common pattern. `react { ... }` does that, warns on bogus emit

[02:32] <dalek> rakudo/nom: usages, and throws any unhandled async exception in the react.

[02:32] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/7cda449465

[02:32] <jnthn> And that's all I managed on the plane ride :P

[02:32] <lizmat> :-)

[02:32] <ShimmerFairy> jnthn++  a "little" code

[02:32] <lizmat> no wonder you didn't sleep

[02:33] <lizmat> :-)

[02:33] <jnthn> Oh, I basically never can on planes... :(

[02:33] <ShimmerFairy> jnthn: my initial thought is that Test.pm should be doing its  sub done {...}  stuff in a phaser anyway :)

[02:33] * lizmat pulls and builds new goodies

[02:34] <skids> Now there's an airdrop for ya.  Or Air Supply.  Ta dum dum.

[02:34] <jnthn> https://gist.github.com/anonymous/6607717a5d201a9acf82 is a little run-my-tests-when-I-change-anything tool to show off the new features :)

[02:38] <ShimmerFairy> jnthn: I like how $running-tests is basically a mutex (based on my limited concurrency knowledge), but you don't have to use a special mutex type or anything :)

[02:42] *** skids left
[02:42] <jnthn> Yeah, well, it's kinda time do drag async programming kicking and screaming into the structured programming era. :)

[02:42] <jnthn> *to

[02:42] <jnthn> ok, bed :)

[02:42] <jnthn> o/

[02:42] <ShimmerFairy> jnthn: I would agree. ♞ o/

[02:45] <lizmat> hmmm... IO::Socket::Async now also hangs on nom?

[02:46] <ShimmerFairy> The Async test has been failing for me for a while, at least

[02:46] <lizmat> ShimmerFairy: failing, yes, but hanging ?

[02:47] <ShimmerFairy> Not unless  make spectest  has a timeout for tests.

[02:47] <lizmat> ah, there were two processes still running after I killed the spectest

[02:47] <lizmat> 2 version of the IO::Socket::Async test

[02:48] <lizmat> killing them made the test pass

[02:48] <lizmat> so it's a matter of a test not cleaning up after itself / not setting up a clean environment beforehand

[02:49] <ShimmerFairy> Could that be the issue with the S17 lock test? I notice it has a tendency to fail on use of TEST_JOBS

[02:49] <lizmat> no, that's a race / load condition, afaik

[02:51] <ShimmerFairy> m: say :a{1=>2}

[02:51] <camelia> rakudo-moar 93418e: OUTPUT«Unexpected named parameter 'a' passed␤  in block <unit> at /tmp/PNDnWAD1Q6:1␤␤»

[02:51] <GLRelia> rakudo-moar abf079: OUTPUT«Unexpected named parameter 'a' passed␤  in block <unit> at /tmp/V5EQTspFCV:1␤␤»

[02:51] <ShimmerFairy> S26 claims that's valid pair notation, but I don't think I've ever see anyone use it

[02:52] <ShimmerFairy> m: say (:a{1=>2})

[02:52] <camelia> rakudo-moar 93418e: OUTPUT«a => 1 => 2␤»

[02:52] <GLRelia> rakudo-moar abf079: OUTPUT«a => 1 => 2␤»

[02:52] <ShimmerFairy> Nevermind, it was just pair/named conflation again e_e

[02:52] *** llfourn joined
[03:02] *** kaare_ joined
[03:03] *** travis-ci joined
[03:03] <travis-ci> Rakudo build errored. Jonathan Worthington 'Add tentative `react` block.

[03:03] <travis-ci> https://travis-ci.org/rakudo/rakudo/builds/76217175 https://github.com/rakudo/rakudo/compare/1f15ace748e2...7cda449465b7

[03:03] *** travis-ci left
[03:05] <lizmat> something hanging

[03:06] <lizmat> "No output has been received in the last 10 minutes, this potentially indicates a stalled build or something wrong with the build itself."

[03:06] <lizmat> after the make test

[03:06] <lizmat> and one make test fail

[03:06] <lizmat> same as I see locally

[03:10] *** aborazmeh left
[03:15] *** mr-foobar left
[03:15] *** grondilu joined
[03:17] *** ingy left
[03:18] <dalek> roast: 5787447 | lizmat++ | S (4 files):

[03:18] <dalek> roast: Remove unneeded "done" to easy migration

[03:18] <dalek> roast: review: https://github.com/perl6/roast/commit/5787447c49

[03:19] *** xxx joined
[03:19] *** ingy joined
[03:24] *** mr-foobar joined
[03:29] *** Brock is now known as awwaiid

[03:31] <awwaiid> fancy feature demo thingie you got there jnthn!

[03:36] *** jordman joined
[03:40] *** laouji left
[03:42] *** aborazmeh joined
[03:42] *** aborazmeh left
[03:42] *** aborazmeh joined
[03:43] *** BenGoldberg left
[03:54] *** khw left
[03:56] *** Woodi left
[03:57] *** Woodi joined
[04:31] *** laouji joined
[04:44] <moritz> good morning

[04:55] <lizmat> moritz o/

[05:02] <dalek> rakudo/nom: ad0f6f3 | lizmat++ | lib/Test.pm:

[05:02] <dalek> rakudo/nom: Deprecate done() for done-testing()

[05:02] <dalek> rakudo/nom: 

[05:02] <dalek> rakudo/nom: Since done() should only be called when you don't have a plan, and you

[05:02] <dalek> rakudo/nom: should most definitely always have a plan, it feels right to de-huffmanize

[05:02] <dalek> rakudo/nom: done() to make room for the new supply related done().

[05:02] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/ad0f6f332a

[05:05] <dalek> roast: f4f4af1 | lizmat++ | S32-trig/generate-tests.pl:

[05:05] <dalek> roast: Use done-testing instead of done

[05:05] <dalek> roast: review: https://github.com/perl6/roast/commit/f4f4af1a96

[05:05] <dalek> roast: 04520b2 | lizmat++ | S32-trig/ (13 files):

[05:05] <dalek> roast: Re-generated files with done-testing

[05:05] <dalek> roast: review: https://github.com/perl6/roast/commit/04520b26ec

[05:07] <dalek> roast: 5b4f138 | lizmat++ | S24-testing/6-done_testing.t:

[05:07] <dalek> roast: Replace last 'done' with 'done-testing'

[05:07] <dalek> roast: 

[05:07] <dalek> roast: Roast should now be free of 'done' to indicate end of testing

[05:07] <dalek> roast: review: https://github.com/perl6/roast/commit/5b4f138636

[05:07] *** travis-ci joined
[05:07] <travis-ci> Rakudo build passed. Elizabeth Mattijsen 'Deprecate done() for done-testing()

[05:07] <travis-ci> https://travis-ci.org/rakudo/rakudo/builds/76227430 https://github.com/rakudo/rakudo/compare/7cda449465b7...ad0f6f332ae3

[05:07] *** travis-ci left
[05:09] <dalek> rakudo/nom: 83daf83 | lizmat++ | docs/ChangeLog:

[05:09] <dalek> rakudo/nom: Mention deprecation of Test's done()

[05:09] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/83daf83b01

[05:12] <ugexe> https://github.com/rakudo/rakudo/blob/nom/lib/Test.pm#L645

[05:14] <lizmat> ugexe: good catch

[05:16] *** xxx left
[05:17] *** mr-foobar left
[05:21] <dalek> rakudo/nom: 5ad8122 | lizmat++ | lib/Test.pm:

[05:21] <dalek> rakudo/nom: Fix two 'done's missed, ugexe++

[05:21] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/5ad81220a2

[05:25] *** xxx joined
[05:30] *** mr-foobar joined
[05:32] *** mr-foobar left
[05:34] <ShimmerFairy> lizmat: wait, done() was supposed to a plan-less done-testing() ? (and done-testing already existed?)

[05:36] <ShimmerFairy> oh, I see now. I thought done() was something you're supposed to call at the end of the test, not an alternative to a plan.

[05:40] <lizmat> you're supposed to call it if you don't have a plan

[05:40] <lizmat> indeed

[05:40] <lizmat> somehow it got cargo-culted that you needed a done() always

[05:41] <ShimmerFairy> I just thought it was necessary for finishing up the test (clearing variables or something, I dunno)

[05:42] *** Timbus joined
[05:47] <lizmat> it gets done for you automatically if you have a plan

[05:47] *** simcop2387 joined
[05:47] <ShimmerFairy> At first I thought it'd be nice to expose role STD for the fact that it has a nice setup for error reporting in grammars, but I think it's too integrated with the src/Perl6 grammars. I still think it'd be nice if there were built-in features to have more useful parse errors, though.

[05:53] <moritz> ShimmerFairy: agreed. The way forward is to develop those error reporting facilities in a module, and if it proves useful, integrate it into core

[05:53] *** jack_rabbit joined
[05:53] <ShimmerFairy> moritz: I'm on my way to making some as part of developing a part of the grammar out-of-core, so I feel like the module stage will be forming already :)

[05:54] *** AlexDani` is now known as AlexDaniel

[05:55] <ShimmerFairy> moritz: also, I notice that Rakudo's grammar errors (their backtraces, specifically) only go so far as the token/regex/rule declarator; they don't go inside the rule to point at the specific problem. I'm guessing that level of detail is hidden in NQP-land?

[06:00] *** diana_olhovik_ joined
[06:01] <moritz> ShimmerFairy: what do you mean by "they don't go inside the rule to point at the specific problem."?

[06:02] <ShimmerFairy> moritz: here's part of one error I got earlier:

[06:02] <ShimmerFairy> P6opaque: no such attribute '$!pos'

[06:02] <ShimmerFairy>   in regex block at Grammar.pm6:78

[06:03] <ShimmerFairy> where line 78 had    token block {

[06:03] <moritz> ah

[06:03] <moritz> I thought you were talking about parse errors that a grammar generated

[06:03] <ShimmerFairy> no, the {die "..."} statements I put in as a stopgap solution and so on work fine

[06:05] <ShimmerFairy> moritz: I think I'll be running into more NQP/Perl6 boundary issues, since I have to do the unusual task of coding a parser as NQP-like as possible, but in Perl 6 because in NQP I wouldn't be able to get things like $*W

[06:06] <ShimmerFairy> (unless I 'use'd the appropriate things from Perl6 and nqp-m knew where to find them, I suppose, but that feels like it would require some tricky maneuvering as well)

[06:19] *** aborazmeh left
[06:20] *** laouji left
[06:20] <lizmat> m: BEGIN say $*W   # ShimmerFairy: may be helpful to know that $*W is exposed at compile time

[06:20] <GLRelia> rakudo-moar abf079: OUTPUT«5===SORRY!5=== Error while compiling /tmp/DZJKTgSz8p␤An exception occurred while evaluating a BEGIN␤at /tmp/DZJKTgSz8p:1␤Exception details:␤  5===SORRY!5=== Error while compiling ␤  Method 'gist' not found for invocant of class 'Perl6::Wo…»

[06:20] <camelia> rakudo-moar 93418e: OUTPUT«5===SORRY!5=== Error while compiling /tmp/VNgC8M_zt0␤An exception occurred while evaluating a BEGIN␤at /tmp/VNgC8M_zt0:1␤Exception details:␤  5===SORRY!5=== Error while compiling ␤  Method 'gist' not found for invocant of class 'Perl6::Wo…»

[06:21] <lizmat> it's an NQP Perl6::World object without .gist :-)

[06:22] <ShimmerFairy> lizmat: cool, that should make integration a bit nicer to plan for. :)  (Though I still had that weird inability to do  @foobar := nqp::list() , so I had to go for a P6-y solution to the method)

[06:22] <lizmat> my $list := $nqp::list() # works fine afaik

[06:23] <ShimmerFairy> lizmat: Also, I noticed that the components in a Slang.new() don't have .gists or anything. Granted, I _did_ have to pull some .^meth trickery to access those objects on their own, but still.

[06:23] *** RabidGravy joined
[06:23] <moritz> ShimmerFairy: NQP objects generally don't have .gist methods

[06:24] <ShimmerFairy> moritz: I know, I'm just thinking that NQP objects that can be exposed in Perl 6 would ideally behave a bit nicer. The .^ trickery qualifier was because it's not exactly easy to find yourself with the Grammar object, so it's perhaps not that important anyway

[06:25] *** laouji joined
[06:26] <ShimmerFairy> m: use nqp; my @a := nqp::split(nqp::unbox_s(","), nqp::unbox_s("A,B"));  # lizmat: I think this is what prevented me from going on with an NQP-like solution, that nqp::split() doesn't seem to want to play nice for some reason

[06:26] <GLRelia> rakudo-moar abf079: OUTPUT«Type check failed in binding; expected 'Positional' but got 'List'␤  in block <unit> at /tmp/F4cubBkzSQ:1␤␤»

[06:26] <camelia> rakudo-moar 93418e: OUTPUT«Type check failed in binding; expected 'Positional' but got 'Parcel'␤  in block <unit> at /tmp/TKavRec0oV:1␤␤»

[06:28] *** dayangkun left
[06:29] <moritz> GLR question: I see the patttern  "my \iterator = nqp::istype(thing, Iterable) ?? thing.iterator !! thing.list.iterator;" everywhere; maybe we want an op or a sub or so for that?

[06:29] *** jkva joined
[06:30] <ShimmerFairy> nqp::asiter if an op, perhaps?

[06:31] <lizmat> perhaps an Any.iterator ?

[06:31] <moritz> p6iter or p6iterator

[06:31] <masak> morning, #perl6

[06:31] <ShimmerFairy> yeah, as an op it should probably have p6 prefixed to it :)

[06:31] <ShimmerFairy> o/

[06:31] <moritz> lizmat: maybe, though that's a level of indirection that's harder to optimize

[06:31] <moritz> \o masak

[06:31] <masak> welcome back, moritz

[06:32] <moritz> takk :-)

[06:32] *** laouji left
[06:32] * masak .oO( oh no, the Norwegians got to his speech center! )

[06:33] <ShimmerFairy> I'm able to bind the result of nqp::split to an array just fine in nqp. Does nqp::split do something different in Perl 6 that makes it difficult to use in a NQP-y way?

[06:34] *** xinming left
[06:34] <moritz> m: my @a := nqp::split('foo', 'o')

[06:34] <GLRelia> rakudo-moar abf079: OUTPUT«===============================================================================␤The use of nqp::operations has been deprecated for non-CORE code.  Please␤change your code to not use these non-portable functions.  If you really want␤to keep using nqp:…»

[06:34] <camelia> rakudo-moar 93418e: OUTPUT«===============================================================================␤The use of nqp::operations has been deprecated for non-CORE code.  Please␤change your code to not use these non-portable functions.  If you really want␤to keep using nqp:…»

[06:34] <moritz> m: use NQP; my @a := nqp::split('foo', 'o')

[06:34] <GLRelia> rakudo-moar abf079: OUTPUT«===SORRY!===␤Could not find NQP in any of:␤  file#/home/steve/.perl6/2015.07.1-329-g88e439c/lib␤  inst#/home/steve/.perl6/2015.07.1-329-g88e439c␤  file#/home/steve/sandbox/perl6/rakudo/install/share/perl6/lib␤  file#/home/steve/sandbox/perl6/raku…»

[06:34] <camelia> rakudo-moar 93418e: OUTPUT«===SORRY!===␤Could not find NQP in any of:␤  file#/home/camelia/.perl6/2015.07.1-138-g93418e9/lib␤  inst#/home/camelia/.perl6/2015.07.1-138-g93418e9␤  file#/home/camelia/rakudo-inst-2/share/perl6/lib␤  file#/home/camelia/rakudo-inst-2/share/perl6…»

[06:34] <moritz> m: use nqp; my @a := nqp::split('foo', 'o')

[06:34] <GLRelia> rakudo-moar abf079: OUTPUT«Type check failed in binding; expected 'Positional' but got 'List'␤  in block <unit> at /tmp/Nh_1DESDLJ:1␤␤»

[06:34] <camelia> rakudo-moar 93418e: OUTPUT«Type check failed in binding; expected 'Positional' but got 'Parcel'␤  in block <unit> at /tmp/IFgA4I0DMF:1␤␤»

[06:34] <moritz> m: say List ~~ Positional

[06:34] <GLRelia> rakudo-moar abf079: OUTPUT«True␤»

[06:34] <camelia> rakudo-moar 93418e: OUTPUT«True␤»

[06:35] <moritz> m: say Parcel ~~ Positional

[06:35] <camelia> rakudo-moar 93418e: OUTPUT«True␤»

[06:35] <GLRelia> rakudo-moar abf079: OUTPUT«5===SORRY!5=== Error while compiling /tmp/TjK1ZjjMfZ␤Expected a term, but found either infix ~~ or redundant prefix ~␤  (to suppress this message, please use a space like ~ ~)␤at /tmp/TjK1ZjjMfZ:1␤------> 3say Parcel ~~7⏏5 Positional␤»

[06:35] <lizmat> ShimmerFairy: https://github.com/perl6/nqp/blob/master/docs/ops.markdown may be of help?

[06:36] *** xinming joined
[06:36] <lizmat> sightseeing&

[06:37] <ShimmerFairy> and once I managed to put the split result somewhere, I croaked on nqp::elems not working, so I had to give in and code a P6-based version of the method in question

[06:38] *** laouji joined
[06:39] *** domidumont joined
[06:41] <moritz> m: my \list = nqp::split('foo', 'o'); say(nqp::elems(list))

[06:41] <GLRelia> rakudo-moar abf079: OUTPUT«===============================================================================␤The use of nqp::operations has been deprecated for non-CORE code.  Please␤change your code to not use these non-portable functions.  If you really want␤to keep using nqp:…»

[06:41] <camelia> rakudo-moar 93418e: OUTPUT«===============================================================================␤The use of nqp::operations has been deprecated for non-CORE code.  Please␤change your code to not use these non-portable functions.  If you really want␤to keep using nqp:…»

[06:41] <moritz> m: use nqp; my \list = nqp::split('foo', 'o'); say(nqp::elems(list))

[06:41] <camelia> rakudo-moar 93418e: OUTPUT«1␤»

[06:41] <GLRelia> rakudo-moar abf079: OUTPUT«1␤»

[06:41] <moritz> m: use nqp; my \list = nqp::split('o', 'foo'); say(nqp::elems(list))

[06:41] <camelia> rakudo-moar 93418e: OUTPUT«3␤»

[06:41] <GLRelia> rakudo-moar abf079: OUTPUT«3␤»

[06:43] <ShimmerFairy> ok, I'll try using \sigilless and see how that goes

[06:43] *** domidumont left
[06:44] *** domidumont joined
[06:46] <ShimmerFairy> thanks moritz :)  I guess the Scalar container on $var variables was getting in the way, when doing $a = nqp::split. And apparently $a := works too, so it was probably just too late last night for me to make much sense of stuff :)

[06:47] *** xfix joined
[06:47] <ShimmerFairy> (I also wasn't returning a cursor like I needed to, so before I figured that out I think the error related to that made me think $a := failed)

[06:47] *** laouji left
[06:50] *** laouji joined
[06:51] *** dayangkun joined
[06:52] *** laouji left
[06:53] *** simcop2387 left
[06:53] *** laouji joined
[06:55] <nine> m: ((1,2,3),(1,2),(1,2)).unique(:with({warn $^a.perl; warn $^b.perl; True}))

[06:55] <camelia> rakudo-moar 93418e: OUTPUT«$(1, 2)  in block  at /tmp/fwIkJ33h0a:1␤1  in block  at /tmp/fwIkJ33h0a:1␤$(1, 2)  in block  at /tmp/fwIkJ33h0a:1␤1  in block  at /tmp/fwIkJ33h0a:1␤»

[06:55] <GLRelia> rakudo-moar abf079: OUTPUT«$(1, 2)  in block  at /tmp/l9Ki3MUvOQ:1␤1  in block  at /tmp/l9Ki3MUvOQ:1␤$(1, 2)  in block  at /tmp/l9Ki3MUvOQ:1␤1  in block  at /tmp/l9Ki3MUvOQ:1␤»

[06:55] *** simcop2387 joined
[06:56] <nine> m: say ((1,2,3),(1,2),(1,2)).unique)

[06:56] <GLRelia> rakudo-moar abf079: OUTPUT«5===SORRY!5=== Error while compiling /tmp/asna45Gmj0␤Unexpected closing bracket␤at /tmp/asna45Gmj0:1␤------> 3say ((1,2,3),(1,2),(1,2)).unique7⏏5)␤»

[06:56] <camelia> rakudo-moar 93418e: OUTPUT«5===SORRY!5=== Error while compiling /tmp/1t1IqlBhGy␤Unexpected closing bracket␤at /tmp/1t1IqlBhGy:1␤------> 3say ((1,2,3),(1,2),(1,2)).unique7⏏5)␤»

[06:56] <nine> m: say ((1,2,3),(1,2),(1,2)).unique

[06:56] <GLRelia> rakudo-moar abf079: OUTPUT«1 2 3 1 2 1 2␤»

[06:56] <camelia> rakudo-moar 93418e: OUTPUT«1 2 3 1 2␤»

[06:56] *** rurban joined
[06:56] *** laouji left
[06:57] *** laouji joined
[06:58] <moritz> m: say ((1,2,3),(1,2),(1,2)).unique.perl

[06:58] <GLRelia> rakudo-moar abf079: OUTPUT«((1, 2, 3), (1, 2), (1, 2)).iterator␤»

[06:58] <camelia> rakudo-moar 93418e: OUTPUT«((1, 2, 3), (1, 2))␤»

[06:58] <nine> The warn output doesn't make sense even on nom, but the result at least is correct. I just have no idea how it can be.

[06:58] <moritz> m: say (1, 2) === (1, 2)

[06:58] <GLRelia> rakudo-moar abf079: OUTPUT«False␤»

[06:58] <camelia> rakudo-moar 93418e: OUTPUT«True␤»

[06:59] <nine> m: ((1,2,3),(1,2),(1,2)).unique(:with({warn $^a.perl; warn $^b.perl; $^a eqv $^b}))

[06:59] <GLRelia> rakudo-moar abf079: OUTPUT«$(1, 2)  in block  at /tmp/I574I6Wxyh:1␤1  in block  at /tmp/I574I6Wxyh:1␤$(1, 2)  in block  at /tmp/I574I6Wxyh:1␤2  in block  at /tmp/I574I6Wxyh:1␤$(1, 2)  in block  at /tmp/I574I6Wxyh:1␤3  in block  at /tmp/I574I6Wxyh:1␤$(1, 2)  in block  at …»

[06:59] <camelia> rakudo-moar 93418e: OUTPUT«$(1, 2)  in block  at /tmp/URwNQO3jeB:1␤1  in block  at /tmp/URwNQO3jeB:1␤$(1, 2)  in block  at /tmp/URwNQO3jeB:1␤2  in block  at /tmp/URwNQO3jeB:1␤$(1, 2)  in block  at /tmp/URwNQO3jeB:1␤3  in block  at /tmp/URwNQO3jeB:1␤$(1, 2)  in block  at …»

[06:59] <moritz> m: say (1, 2).^name

[06:59] <GLRelia> rakudo-moar abf079: OUTPUT«List␤»

[06:59] <camelia> rakudo-moar 93418e: OUTPUT«Parcel␤»

[06:59] <moritz> m: say (1, 2) eqv (1, 2)

[06:59] <GLRelia> rakudo-moar abf079: OUTPUT«True␤»

[06:59] <camelia> rakudo-moar 93418e: OUTPUT«True␤»

[06:59] <nine> m: ((1,2,3),(1,2),(1,2)).unique(:with({note $^a.perl; note $^b.perl; $^a eqv $^b}))

[06:59] <GLRelia> rakudo-moar abf079: OUTPUT«$(1, 2)␤1␤$(1, 2)␤2␤$(1, 2)␤3␤$(1, 2)␤1␤$(1, 2)␤2␤$(1, 2)␤3␤$(1, 2)␤1␤$(1, 2)␤2␤»

[06:59] <camelia> rakudo-moar 93418e: OUTPUT«$(1, 2)␤1␤$(1, 2)␤2␤$(1, 2)␤3␤$(1, 2)␤1␤$(1, 2)␤2␤$(1, 2)␤3␤$(1, 2)␤1␤$(1, 2)␤2␤»

[07:00] <nine> m: say ((1,2,3),(1,2),(1,2)).unique(:with({note $^a.perl; note $^b.perl; $^a eqv $^b}))

[07:00] <camelia> rakudo-moar 93418e: OUTPUT«$(1, 2)␤1␤$(1, 2)␤2␤$(1, 2)␤3␤$(1, 2)␤1␤$(1, 2)␤2␤$(1, 2)␤3␤$(1, 2)␤1␤$(1, 2)␤2␤1 2 3 1 2 1 2␤»

[07:00] <GLRelia> rakudo-moar abf079: OUTPUT«$(1, 2)␤1␤$(1, 2)␤2␤$(1, 2)␤3␤$(1, 2)␤1␤$(1, 2)␤2␤$(1, 2)␤3␤$(1, 2)␤1␤$(1, 2)␤2␤1 2 3 1 2 1 2␤»

[07:00] *** abraxxa joined
[07:00] <nine> m: say <a b b c b d>.unique(:with({note $^a.perl; note $^b.perl; $^a eqv $^b}))

[07:00] <GLRelia> rakudo-moar abf079: OUTPUT«"b"␤"a"␤"b"␤"a"␤"b"␤"b"␤"c"␤"a"␤"c"␤"b"␤"b"␤"a"␤"b"␤"b"␤"d"␤"a"␤"d"␤"b"␤"d"␤"c"␤a b c d␤»

[07:00] <camelia> rakudo-moar 93418e: OUTPUT«"b"␤"a"␤"b"␤"a"␤"b"␤"b"␤"c"␤"a"␤"c"␤"b"␤"b"␤"a"␤"b"␤"b"␤"d"␤"a"␤"d"␤"b"␤"d"␤"c"␤a b c d␤»

[07:01] <nine> So $^b should indeed be set to an element of the list. It just doesn't work for Lists neither in glr nor in nom.

[07:07] <nine> m: my @seen; my $target := (1, 2); @seen.push($target); say @seen.perl;

[07:07] <GLRelia> rakudo-moar abf079: OUTPUT«[1, 2]␤»

[07:07] <camelia> rakudo-moar 93418e: OUTPUT«[1, 2]<>␤»

[07:07] <nine> That's the underlying issue

[07:14] *** luiz_lha left
[07:16] <moritz> the GLR output seems saner to me

[07:16] <dalek> rakudo/glr: 4bcdf98 | (Stefan Seifert)++ | src/core/Any-iterable-methods.pm:

[07:16] <dalek> rakudo/glr: Fix unique(:with({})) on lists of Lists

[07:16] <dalek> rakudo/glr: 

[07:16] <dalek> rakudo/glr: In "((1, 2), (1, 2)).unique(:with($^a eqv $^b))" $^b was set to the numbers

[07:16] <dalek> rakudo/glr: contained in the lists instead of the lists themselves due to missing

[07:16] <dalek> rakudo/glr: itemization when pushing into the @seen array.

[07:16] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/4bcdf98646

[07:17] <nine> As usual, a rather trivial fix, but quite time consuming to find it.

[07:17] <ShimmerFairy> m: my $*X = BEGIN $*W; say $*X.defined

[07:17] <GLRelia> rakudo-moar abf079: OUTPUT«1␤»

[07:17] <camelia> rakudo-moar 93418e: OUTPUT«1␤»

[07:17] <ShimmerFairy> m: my $*W = BEGIN $*W; say $*W.defined

[07:17] <GLRelia> rakudo-moar abf079: OUTPUT«1␤»

[07:17] <camelia> rakudo-moar 93418e: OUTPUT«5===SORRY!5=== Error while compiling /tmp/TZRTCoR0QF␤Cannot use variable $*W in declaration to initialize itself␤at /tmp/TZRTCoR0QF:1␤------> 3my $*W = BEGIN $*7⏏5W; say $*W.defined␤    expecting any of:␤        term␤»

[07:17] <ShimmerFairy> ^ I feel like that paranoid error is a bug here

[07:17] <nine> Well this time, on the way I unbusted SEQUENCE some more just to be able to run first.t (which passes) just to find out that first is not the source of the problem ;)

[07:18] *** zakharyas joined
[07:19] <ShimmerFairy> (and as GLRelia shows, it's fine in this instance, since no list structures are involved ☺)

[07:19] <dalek> roast/glr: 5bb3591 | (Stefan Seifert)++ | S32-list/unique.t:

[07:19] <dalek> roast/glr: Adapt new GLR semantics in unique.t

[07:19] <dalek> roast/glr: 

[07:19] <dalek> roast/glr: As unique now returns a Seq instead of a List, we have to Listify it, before we

[07:19] <dalek> roast/glr: can directly compare it to a List with is-deeply.

[07:19] <dalek> roast/glr: 

[07:19] <dalek> roast/glr: Need to use :with and eqv for the flattening test because (1, 2) === (1, 2) is

[07:20] <dalek> roast/glr: no longer True.

[07:20] <dalek> roast/glr: review: https://github.com/perl6/roast/commit/5bb3591b54

[07:20] *** darutoko joined
[07:20] <nine> And another test file passing.

[07:20] <ShimmerFairy> m: my $a = 1; { my $a = $a + 1; say $a; }; say $a;

[07:20] <GLRelia> rakudo-moar abf079: OUTPUT«Use of uninitialized value of type Any in numeric context  in block  at /tmp/jk3Tp_owyd:1␤1␤1␤»

[07:20] <camelia> rakudo-moar 93418e: OUTPUT«5===SORRY!5=== Error while compiling /tmp/hUIjA_WT7f␤Cannot use variable $a in declaration to initialize itself␤at /tmp/hUIjA_WT7f:1␤------> 3my $a = 1; { my $a = $7⏏5a + 1; say $a; }; say $a;␤    expecting any of:␤        term␤»

[07:20] *** telex left
[07:21] <ShimmerFairy> m: our $a = 1; { my $a = $a + 1; say $a; }; say $a;

[07:21] <GLRelia> rakudo-moar abf079: OUTPUT«Use of uninitialized value of type Any in numeric context  in block  at /tmp/q0yeI1fWmL:1␤1␤1␤»

[07:21] <camelia> rakudo-moar 93418e: OUTPUT«5===SORRY!5=== Error while compiling /tmp/wAen9aRZhf␤Cannot use variable $a in declaration to initialize itself␤at /tmp/wAen9aRZhf:1␤------> 3our $a = 1; { my $a = $7⏏5a + 1; say $a; }; say $a;␤    expecting any of:␤        term␤»

[07:22] *** telex joined
[07:35] *** espadrine joined
[07:40] *** laouji left
[07:42] *** laouji joined
[07:49] <nine> m: ((1,2,3), (1,2), (1,2)).unique(:with(&[eqv])).perl.say

[07:49] <GLRelia> rakudo-moar 4bcdf9: OUTPUT«((1, 2, 3), (1, 2)).iterator␤»

[07:49] <camelia> rakudo-moar 93418e: OUTPUT«((1, 2, 3), (1, 2), (1, 2))␤»

[07:50] <nine> m: ((1,2,3), (1,2), (1,2)).unique.perl.say

[07:50] <camelia> rakudo-moar 93418e: OUTPUT«((1, 2, 3), (1, 2))␤»

[07:50] <GLRelia> rakudo-moar 4bcdf9: OUTPUT«((1, 2, 3), (1, 2), (1, 2)).iterator␤»

[07:50] <nine> One works on nom, one on glr. I think that's a fair exchange ;)

[07:54] <DrForr> Parsing stage much faster on my build today, nice.

[07:58] <ShimmerFairy> m: "abc" ~~ /abc/; say $/.WHAT; say $/.^attributes;

[07:58] <GLRelia> rakudo-moar 4bcdf9: OUTPUT«(Match)␤Method 'gist' not found for invocant of class 'BOOTSTRAPATTR'␤  in block <unit> at /tmp/qciGKbrEki:1␤␤»

[07:58] <camelia> rakudo-moar 93418e: OUTPUT«(Match)␤Method 'gist' not found for invocant of class 'BOOTSTRAPATTR'␤  in block <unit> at /tmp/Pqd0PPahvi:1␤␤»

[07:59] *** diana_olhovik_ left
[07:59] <ShimmerFairy> AFAIK, that BOOTSTRAPATTR should be an Attribute post-bootstrap

[07:59] *** diana_olhovik joined
[08:01] <RabidGravy> yeah, I was wondering about that the other day, then put it aside as I couldn't fix it right then

[08:01] <ShimmerFairy> m: "abc" ~~ /abc/; say $/.WHAT; for $/.^attributes { say $_ }

[08:01] <GLRelia> rakudo-moar 4bcdf9: OUTPUT«(Match)␤Mu $!orig␤int $!from␤int $!to␤Mu $!CURSOR␤Mu $!made␤Method 'gist' not found for invocant of class 'BOOTSTRAPATTR'␤  in block <unit> at /tmp/YpDkMZVwpn:1␤␤»

[08:01] <camelia> rakudo-moar 93418e: OUTPUT«(Match)␤Mu $!orig␤int $!from␤int $!to␤Mu $!CURSOR␤Mu $!made␤Method 'gist' not found for invocant of class 'BOOTSTRAPATTR'␤  in block <unit> at /tmp/opHhQLJxTB:1␤␤»

[08:01] <ShimmerFairy> looks like there's one attribute specifically that's not getting converted

[08:02] <ShimmerFairy> m: "abc" ~~ /abc/; say $/.WHAT; for $/.^attributes { say $_.^name }

[08:02] <GLRelia> rakudo-moar 4bcdf9: OUTPUT«(Match)␤Attribute␤Attribute␤Attribute␤Attribute␤Attribute␤BOOTSTRAPATTR␤BOOTSTRAPATTR␤»

[08:02] <camelia> rakudo-moar 93418e: OUTPUT«(Match)␤Attribute␤Attribute␤Attribute␤Attribute␤Attribute␤BOOTSTRAPATTR␤BOOTSTRAPATTR␤»

[08:02] <ShimmerFairy> two attributes, specifically :)

[08:03] <RabidGravy> (it wasn't Match that I noticed it with though)

[08:05] <ShimmerFairy> m: my $a = \(1,2); say $a.WHAT; say $a.^attributes.map: *.^name

[08:05] <GLRelia> rakudo-moar 4bcdf9: OUTPUT«(Capture)␤BOOTSTRAPATTR BOOTSTRAPATTR␤»

[08:05] <camelia> rakudo-moar 93418e: OUTPUT«(Capture)␤BOOTSTRAPATTR BOOTSTRAPATTR␤»

[08:05] <ShimmerFairy> RabidGravy: in my case, it seems the problem lies with Capture

[08:05] <RabidGravy> it might have been Capture or something in that vicinity

[08:07] <ShimmerFairy> m: my $attr = Complex.^attributes[0]; say $attr.WHAT; say $attr.^attributes.map: *.^name

[08:07] <GLRelia> rakudo-moar 4bcdf9: OUTPUT«(Attribute)␤BOOTSTRAPATTR BOOTSTRAPATTR BOOTSTRAPATTR BOOTSTRAPATTR BOOTSTRAPATTR BOOTSTRAPATTR BOOTSTRAPATTR BOOTSTRAPATTR BOOTSTRAPATTR BOOTSTRAPATTR BOOTSTRAPATTR BOOTSTRAPATTR BOOTSTRAPATTR BOOTSTRAPATTR BOOTSTRAPATTR␤»

[08:07] <camelia> rakudo-moar 93418e: OUTPUT«(Attribute)␤BOOTSTRAPATTR BOOTSTRAPATTR BOOTSTRAPATTR BOOTSTRAPATTR BOOTSTRAPATTR BOOTSTRAPATTR BOOTSTRAPATTR BOOTSTRAPATTR BOOTSTRAPATTR BOOTSTRAPATTR BOOTSTRAPATTR BOOTSTRAPATTR BOOTSTRAPATTR BOOTSTRAPATTR BOOTSTRAPATTR␤»

[08:07] <ShimmerFairy> RabidGravy: I think the issue may be that private attributes that are in BOOTSTRAP but not defined in the class itself in src/core

[08:09] <RabidGravy> anyhow off to get the car serviced.  Have fun and play nicely.

[08:10] <ShimmerFairy> m: say Cursor.^attributes[0].WHAT

[08:10] <GLRelia> rakudo-moar 4bcdf9: OUTPUT«(Attribute)␤»

[08:10] <camelia> rakudo-moar 93418e: OUTPUT«(Attribute)␤»

[08:10] <ShimmerFairy> the other attributes in Cursor are from an NQP class, and thus NQPAttributes.

[08:11] <ShimmerFairy> So I think the issue is bootstrapped private attributes. I don't know if you can redeclare them in src/core (since the 'has' declarations for them are there, but commented out, for documentation purposes I assume)

[08:14] *** RabidGravy left
[08:18] *** g4 joined
[08:19] * TimToady et al. in Tokyo now

[08:21] <ShimmerFairy> o/ TimToady et al. :)

[08:23] <moritz> \o

[08:26] <FROGGS> o/

[08:30] *** laouji left
[08:34] <moritz> is there an easy-ish entry point for helping with GLR stuff?

[08:35] <FROGGS> moritz: I understand it as: run the spectest, and fix the fallout

[08:35] <FROGGS> though, I've not tested it yet

[08:36] *** Ven joined
[08:42] <nine> moritz: https://github.com/perl6/roast/commit/5bb3591b54 is a good example for easy fixes

[08:44] <moritz> nine: thanks

[08:44] <moritz> nine: does http://perlpunks.de/paste/show/55d441e1.1ac1.1c look vaguely sane to you?

[08:45] <nine> moritz: we also often need to explicitly flatten like in: https://github.com/perl6/roast/commit/1ac5df177f223813eb86a29181d29b8759c94287

[08:46] <moritz> nine: does that really need both flat *and* @(...) ?

[08:47] <nine> moritz: oh yes, absolutely!

[08:47] <nine> moritz: no, I removed the @(...) in the next commit :)

[08:48] <moritz> :-)

[08:48] <dalek> rakudo/glr: 7b4392b | moritz++ | src/core/List.pm:

[08:48] <dalek> rakudo/glr: Eliminate .gimme usage from infix:<X>

[08:48] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/7b4392be78

[08:48] <nine> moritz: I mean your past looks absolutely sane

[08:48] <nine> \o/

[08:50] *** virtualsue joined
[08:51] <Ven> o/, #perl6

[08:53] <nine> Wow, jnthn++ must have been quite exhausted already. Just found the 4th bug in POSITIONS

[08:55] <nine> m: (0,1,1) >>+<< (0,0,1)

[08:55] <camelia> rakudo-moar 93418e: ( no output )

[08:55] <GLRelia> rakudo-moar 7b4392: ( no output )

[08:56] <nine> m: say ( (0,1,1) >>+<< (0,0,1) )

[08:56] <GLRelia> rakudo-moar 7b4392: OUTPUT«0 1 2␤»

[08:56] <camelia> rakudo-moar 93418e: OUTPUT«0 1 2␤»

[08:56] <nine> m: say ( (0,1,1) >>+<< (0,0,1) ).perl

[08:56] <camelia> rakudo-moar 93418e: OUTPUT«(0, 1, 2)␤»

[08:56] <GLRelia> rakudo-moar 7b4392: OUTPUT«((0, 1, 2).iterator)␤»

[08:56] <JimmyZ> m: [1,2] ~~ [1,1]

[08:56] <GLRelia> rakudo-moar 7b4392: ( no output )

[08:56] <camelia> rakudo-moar 93418e: ( no output )

[08:57] <JimmyZ> m: say [1,2] ~~ [1,1]

[08:57] <GLRelia> rakudo-moar 7b4392: OUTPUT«False␤»

[08:57] <camelia> rakudo-moar 93418e: OUTPUT«False␤»

[09:00] <moritz> looks like slice.t is loop in the GLR branch

[09:01] <nine> moritz: that's why I'm working on POSITIONS

[09:01] <moritz> nine: ah, good

[09:01] <moritz> I'm trying to remove a few more uses of .gimme

[09:01] <nine> Already have a fix for that and a couple other issues. Only is((3,7,9), [@array[(0,1,1) >>+<< (0,0,1)]] is still failing

[09:04] *** jkva left
[09:10] *** rindolf joined
[09:10] *** laouji joined
[09:11] *** espadrine left
[09:12] <dalek> rakudo/glr: 2f5c4ed | (Stefan Seifert)++ | / (3 files):

[09:12] <dalek> rakudo/glr: Fix slice indexing with lazy lists

[09:12] <dalek> rakudo/glr: 

[09:12] <dalek> rakudo/glr: Fixes the hang in @a[0...*] and makes it return useful results.

[09:12] <dalek> rakudo/glr: Fixes all slice.t tests but @array[(0,1,1) >>+<< (0,0,1)]. That one I

[09:12] <dalek> rakudo/glr: think is due to a bug in the hyper operator itself, not in POSITIONS.

[09:12] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/2f5c4ed37d

[09:17] *** GLRelia left
[09:17] <nine> 223/1047 spec test files failing

[09:17] *** GLRelia joined
[09:19] *** llfourn left
[09:20] <jnthn> nine: I was pretty tired when working on POSITIONS, but also the thing my simpler re-impl replaced was incredibly hairy

[09:20] <jnthn> nine: So I had a really hard time figuring out what it did/didn't handle in the first place

[09:20] <dalek> rakudo/glr: e9911c0 | moritz++ | src/core/metaops.pm:

[09:20] <dalek> rakudo/glr: Remove two more uses of .gimme(1)

[09:20] <dalek> rakudo/glr: 

[09:20] <dalek> rakudo/glr: Compiles, but does not cause more spectest passes

[09:20] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/e9911c01b2

[09:21] *** Ven left
[09:22] <nine> jnthn: no worry, that's all past now :)

[09:24] <dalek> roast/glr: 10a78d9 | moritz++ | S32-list/roll.t:

[09:24] <dalek> roast/glr: Fix a type error in roll.t

[09:24] <dalek> roast/glr: review: https://github.com/perl6/roast/commit/10a78d97b7

[09:25] <jnthn> nine++ 

[09:25] * jnthn wonders how we're still managing to fail more than 200... :)

[09:25] <moritz> m: say (1..5).list.roll(*).infinite.perl

[09:25] <camelia> rakudo-moar 93418e: OUTPUT«Bool::True␤»

[09:25] <GLRelia> rakudo-moar 2f5c4e: OUTPUT«Nil␤»

[09:26] <moritz> m: say (1..5).list.roll(*).^name

[09:26] <camelia> rakudo-moar 93418e: OUTPUT«List␤»

[09:26] <GLRelia> rakudo-moar 2f5c4e: OUTPUT«Seq␤»

[09:26] <jnthn> .infinite is almost certainly going away

[09:26] <moritz> jnthn: yes, I'm trying to figure out how to replace the test

[09:26] <moritz> ok <a b c d>.roll(*).infinite, 'roll(*) knows itself to be infinite';

[09:26] <jnthn> I think .is-lazy is what lizmat called The New Thing

[09:26] <moritz> takk

[09:26] <jnthn> But I don't know if .is-lazy is implemented on Seq yet

[09:27] *** TEttinger left
[09:27] <jnthn> But if not, it's really easy to do: just asking the $!iterator if it demands lazy evaluation :)

[09:27] <moritz> I'll look into it.

[09:28] <jnthn> fwiw, "lazy" is how you mark something as needing lazy evaluation, and is the answer to the "how do we mark something infinite" question we've lon ghad

[09:28] <jnthn> *long

[09:28] *** rurban_ joined
[09:28] <jnthn> m: my @a = 1, 2, 3; my @b = lazy @a; @a[0] = 42; say @b;

[09:28] <GLRelia> rakudo-moar e9911c: OUTPUT«...␤»

[09:28] <camelia> rakudo-moar 93418e: OUTPUT«1 2 3␤»

[09:28] <moritz> what should Seq.is-lazy do if $!iterator is undefined? throw a X::Seq::Consumed?

[09:28] <jnthn> uh

[09:29] <jnthn> m: my @a = 1, 2, 3; my @b = lazy @a; @a[0] = 42; say @b.perl

[09:29] <camelia> rakudo-moar 93418e: OUTPUT«[1, 2, 3]<>␤»

[09:29] <GLRelia> rakudo-moar e9911c: OUTPUT«[...]␤»

[09:29] <jnthn> wtf, I thought that worked before

[09:29] <jnthn> m: my @a = 1, 2, 3; my @b = lazy @a; @a[0] = 42; say @b[^3]

[09:29] <camelia> rakudo-moar 93418e: OUTPUT«1 2 3␤»

[09:29] <GLRelia> rakudo-moar e9911c: OUTPUT«42 2 3␤»

[09:29] <jnthn> Anyway, that's what I was after

[09:29] <jnthn> moritz: Yes

[09:30] <jnthn> moritz: Well, if $!iterator is gone but the memoized list is there, you could ask that I ugess

[09:30] <jnthn> *guess

[09:30] <jnthn> +        my \list = @values.reverse;

[09:30] <jnthn> +        my $result := list.pull-one;

[09:31] <jnthn> You can't pull-one a list

[09:31] <jnthn> You need my \iter = list.iterator; ... iter.pull-one;

[09:31] <_itz_> nqp-m: say(1+3)

[09:31] <camelia> nqp-moarvm: OUTPUT«4␤»

[09:31] <GLRelia> nqp-moarvm: OUTPUT«4␤»

[09:31] <moritz> jnthn: and I guess I should find a way to test it :-)

[09:32] <moritz> jnthn: is this good practise, making iterators out of already reified lists?

[09:32] *** GLRelia left
[09:32] *** GLRelia joined
[09:32] <jnthn> moritz: Well, your alternative is to go indexing...

[09:32] <_itz_> nqp-m: say(1+3)

[09:32] <camelia> nqp-moarvm: OUTPUT«4␤»

[09:33] <jnthn> moritz: It's not really a bad thing to do, though

[09:33] <moritz> jnthn: ok

[09:33] <jnthn> moritz: After all, that's what for @reified-list { } does :)

[09:33] <_itz_> m: say 1+3

[09:33] <camelia> rakudo-moar 93418e: OUTPUT«4␤»

[09:33] <GLRelia> rakudo-moar e9911c: OUTPUT«4␤»

[09:37] *** llfourn joined
[09:37] *** espadrine joined
[09:38] *** AlexDaniel left
[09:38] <dalek> evalbot: f5b8bcf | (Steve Mynott)++ | run.sh:

[09:38] <dalek> evalbot: ulimit options are bash specific.  Fix when user shell isn't bash

[09:38] <dalek> evalbot: review: https://github.com/perl6/evalbot/commit/f5b8bcfb7d

[09:38] <dalek> evalbot: 5c45df6 | moritz++ | run.sh:

[09:38] <dalek> evalbot: Merge pull request #7 from stmuk/master

[09:38] <dalek> evalbot: 

[09:38] <dalek> evalbot: ulimit options are bash specific.  Fix when user shell isn't bash.

[09:38] <dalek> evalbot: review: https://github.com/perl6/evalbot/commit/5c45df6f59

[09:39] <moritz> jnthn: there seem to be methods 'is-lazy' and 'lazy'; is that intentional?

[09:41] <jnthn> moritz: Heh, it's confusing as heck by now I think

[09:41] <jnthn> moritz: .lazy on *Iterable* is a contextualizer

[09:42] <moritz> .lazy on Iterator seems to be Boolean

[09:42] <jnthn> moritz: But .lazy on *Iterator* is an introspection method that does what .is-lazy does elsewhere :)

[09:42] <moritz> jnthn: so, should I rename .lazy on Iterator to .is-lazy?

[09:42] <jnthn> I suspect the one on Iterator wants to change to is-lazy

[09:43] <moritz> ok

[09:43] <jnthn> Yeah, but you'll need to hunt down the various places that need updating :)

[09:44] *** cognominal left
[09:48] *** leont joined
[09:55] *** rindolf left
[09:55] *** laouji left
[09:55] *** laouji_ joined
[10:07] *** laouji_ left
[10:08] *** jack_rabbit left
[10:09] *** jack_rabbit joined
[10:10] *** skids joined
[10:17] *** abraxxa left
[10:17] *** abraxxa joined
[10:21] *** skids left
[10:28] <dalek> rakudo/glr: 52bf81a | moritz++ | src/core/ (7 files):

[10:28] <dalek> rakudo/glr: Rename Iterator.lazy to is-lazy

[10:28] <dalek> rakudo/glr: 

[10:28] <dalek> rakudo/glr: previously, .lazy on Iterator was introspection, while .lazy on Iterable

[10:28] <dalek> rakudo/glr: was coercive; now is-lazy is always introspection, and .lazy always coercion

[10:28] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/52bf81a383

[10:29] *** magistr joined
[10:30] <magistr> perl 6 is too awful as perl

[10:31] <tadzik> where's hugme when we need it?

[10:31] * moritz hugs magistr 

[10:31] <moritz> tadzik: probably died during the feather -> hack transition

[10:32] *** rurban left
[10:32] <tadzik> good thing you were there to fill in the blanks :)

[10:33] <magistr> scriptshitting

[10:33] <moritz> magistr: is there anything we can do to brighten your day? make some fun puns for you, maybe?

[10:33] <DrForr> magistr: Sorry you feel that way, what do you find ugly?

[10:33] <tadzik> did you know that according to popular belief polar bears are *not* left handed?

[10:34] <tadzik> so many of my github descriptions are wrong now

[10:34] *** breinbaas joined
[10:36] <_itz_> doesn't it depend on *which* pole they live at?

[10:37] *** magistr left
[10:37] <DrForr> "Hug an engineer. They won't like it, but do it anyway."

[10:41] *** skids joined
[10:48] <dalek> rakudo/glr: a343c2f | moritz++ | src/core/List.pm:

[10:48] <dalek> rakudo/glr: Produce a known-lazy Seq from List.roll(*)

[10:48] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/a343c2f228

[10:50] <dalek> roast/glr: 3a2d1df | moritz++ | S32-list/reverse.t:

[10:50] <dalek> roast/glr: reverse.t: Do not use isa-ok with a role

[10:50] <dalek> roast/glr: review: https://github.com/perl6/roast/commit/3a2d1dfd98

[10:50] <dalek> roast/glr: c5d9603 | moritz++ | S32-list/roll.t:

[10:50] <dalek> roast/glr: roll.t: s/infinite/is-lazy/; relax return type check to Iterable

[10:50] <dalek> roast/glr: review: https://github.com/perl6/roast/commit/c5d96032d4

[10:51] <moritz> two more passing test files; yay!

[10:53] <moritz> m: my %h = a => 42, b => 666;

[10:53] <camelia> rakudo-moar 93418e: ( no output )

[10:53] <GLRelia> rakudo-moar a343c2: ( no output )

[10:53] <moritz> m: my %h = a => 42, b => 666; say "value = %h{*}"

[10:53] <camelia> rakudo-moar 93418e: OUTPUT«value = 42 666␤»

[10:53] <GLRelia> rakudo-moar a343c2: OUTPUT«Use of uninitialized value %h of type Any in string context  in block <unit> at /tmp/mauMJUNQEa:1␤value = ␤»

[10:53] <dalek> roast/glr: 8a3fb80 | moritz++ | integration/advent2014-day13.t:

[10:53] <dalek> roast/glr: Simply test case a wee bit

[10:53] <dalek> roast/glr: review: https://github.com/perl6/roast/commit/8a3fb80a75

[10:59] *** rurban joined
[11:02] *** skids left
[11:05] *** laouji joined
[11:23] *** xinming left
[11:32] *** laouji left
[11:33] <_itz_> m: my @s = [1,2,3,4]; my $foo = @s[0..1, 2..4].join; warn $foo.perl;

[11:33] <camelia> rakudo-moar 93418e: OUTPUT«Use of uninitialized value @s of type Any in string context  in block <unit> at /tmp/xAvKyGHDf9:1␤Use of uninitialized value @s of type Any in string context  in block <unit> at /tmp/xAvKyGHDf9:1␤Use of uninitialized value @s of type Any in string cont…»

[11:33] <GLRelia> rakudo-moar a343c2: OUTPUT«"1 23 4"  in block <unit> at /tmp/LXVa5HhZRo:1␤»

[11:33] <_itz_> the behaviour of that has changed in GLR (breaking a zef test).  Output a day or two back was 1234

[11:34] *** virtualsue left
[11:38] *** FROGGS_ joined
[11:41] <_itz_> it returned 1234 in 2015.07.1-350-gabf079b 

[11:41] <_itz_> or later

[11:42] <moritz> m: my @a = 1, 2; my $s = @a; for $s { say "oh hai" }

[11:42] <camelia> rakudo-moar 93418e: OUTPUT«oh hai␤»

[11:42] <GLRelia> rakudo-moar a343c2: OUTPUT«oh hai␤oh hai␤»

[11:42] *** FROGGS left
[11:43] <moritz> is this intentional?

[11:44] <nine> moritz: I think thats because of the single arg rule

[11:44] <moritz> m: my @a = 1, 2; my $s = @a; for $s, 2 { say "oh hai" }

[11:44] <camelia> rakudo-moar 93418e: OUTPUT«oh hai␤oh hai␤»

[11:44] <GLRelia> rakudo-moar a343c2: OUTPUT«oh hai␤oh hai␤»

[11:51] * masak should look into this GLR thing

[11:54] <moritz> m: my @a = 1, 2; my $s = @a; for (), $s { say "oh hai" }

[11:54] <camelia> rakudo-moar 93418e: OUTPUT«oh hai␤oh hai␤»

[11:54] <GLRelia> rakudo-moar a343c2: OUTPUT«oh hai␤oh hai␤»

[11:54] <moritz> m: my @a = 1, 2; my $s = @a; for Empty, $s { say "oh hai" }

[11:54] <camelia> rakudo-moar 93418e: OUTPUT«oh hai␤»

[11:54] <GLRelia> rakudo-moar a343c2: OUTPUT«oh hai␤»

[11:55] *** skids joined
[11:55] *** magistr joined
[11:55] <magistr> perdl

[11:56] * moritz hugs magistr again

[11:56] <masak> magistr: hi! you expressed some dissatisfaction before?

[11:57] <dalek> roast/glr: c71b678 | moritz++ | integration/advent2011-day16.t:

[11:57] <dalek> roast/glr: Fix advent2011-day16.t

[11:57] <dalek> roast/glr: 

[11:57] <dalek> roast/glr: also add a test for the spirit of the original test

[11:57] <dalek> roast/glr: review: https://github.com/perl6/roast/commit/c71b6788ab

[11:57] *** dayangkun left
[11:57] <nine> If you were the >> << operator, where would I find your code?

[11:57] <masak> magistr: have you downloaded Rakudo? it's pretty sweet.

[11:57] <magistr> async IO it is overhead to a sriptshitting languages

[11:58] *** xinming joined
[11:59] <jdv79> what is this sinle arg rule thats oft referred to?

[11:59] *** abraxxa left
[11:59] *** abraxxa joined
[12:00] <jdv79> also, what is scriptshitting.  sounds dirty.

[12:00] <moritz> jdv79: seems to me that a single argument bound to a positional or slurpy flattens out, even if it's a scalar

[12:00] <tadzik> jdv79: sounds like producing scripts on a massive scale

[12:00] <tadzik> let me look up the english word for that...

[12:00] <tadzik> "scribbler"

[12:00] <magistr> eventmachine, AnyEvent, nodejs, reactphp, twisted - it is awful

[12:00] <tadzik> that must be it

[12:01] <_itz_> magistr: are you a markov chain?

[12:02] <moritz> m: say do for 1..20;

[12:02] <camelia> rakudo-moar 93418e: OUTPUT«5===SORRY!5=== Error while compiling /tmp/HlJp1cCNbp␤Missing block␤at /tmp/HlJp1cCNbp:1␤------> 3say do for 1..207⏏5;␤    expecting any of:␤        block or pointy block␤»

[12:02] <GLRelia> rakudo-moar a343c2: OUTPUT«5===SORRY!5=== Error while compiling /tmp/bT4fYFMxuc␤Missing block␤at /tmp/bT4fYFMxuc:1␤------> 3say do for 1..207⏏5;␤    expecting any of:␤        block or pointy block␤»

[12:02] <moritz> m: say do $_ for 1..20;

[12:02] <camelia> rakudo-moar 93418e: OUTPUT«1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20␤»

[12:02] <GLRelia> rakudo-moar a343c2: OUTPUT«1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20␤»

[12:02] *** cognominal joined
[12:03] <magistr> _itz_, are you a shit?

[12:03] <tadzik> please be respectful

[12:04] <tadzik> we may still have a civilized discussion if you only express anger towards software rather than people

[12:04] <tadzik> if you're only interested in the latter, then please leave

[12:05] <moritz> m: sub f(*@a) { say @a[0] }; f gather { while True { take 5 } }

[12:05] <camelia> rakudo-moar 93418e: OUTPUT«5␤»

[12:05] <GLRelia> rakudo-moar a343c2: OUTPUT«5␤»

[12:05] *** magistr left
[12:05] <moritz> tadzik++

[12:06] *** skids left
[12:06] <tadzik> I'm surprised this worked

[12:07] *** llfourn left
[12:09] *** llfourn joined
[12:09] *** skids joined
[12:09] * masak guesses that magistr is a Russian 14yo

[12:10] <tadzik> (s)he was a lot more eloquent than usual 14yo russians I meet on the internet

[12:10] <tadzik> much more polite too!

[12:10] <jdv79> who knows the reasoning behind this one arg rule

[12:10] <masak> though I find "are you a shit?" is hilariously funny if magistr actually *is* a Markov chain :P

[12:11] <tadzik> :D{:D:D:D

[12:11] <tadzik> masak: do you know about SubredditSimulator?

[12:11] <masak> jdv79: guessing here -- people expect to be able to loop over something like $array or [1, 2, 3]

[12:11] <dalek> rakudo/glr: c4d1b08 | moritz++ | src/core/asyncops.pm:

[12:11] <dalek> rakudo/glr: Clarify error message from argument-less supply

[12:11] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/c4d1b086b3

[12:11] <masak> tadzik: yes, I saw something about it on twitter today

[12:11] <jdv79> i want true facrs

[12:11] <jdv79> facts

[12:11] <masak> jdv79: oh, then ignore me :P

[12:11] <jdv79> phone typing:(

[12:12] <masak> I only provide false or inconclusive facts today.

[12:12] <moritz> jdv79: it makes dereferencing nested data structures much simpler

[12:12] <masak> I'm fresh out of true ones.

[12:12] <jdv79> oh...

[12:12] * moritz only has True Scotsman facts

[12:12] <masak> I could offer you a true "fact" :)

[12:12] <tadzik> masak: https://www.reddit.com/r/SubredditSimulator/comments/3hjgpg/113_a_robot_and_i_am_having_issues_with_another/

[12:13] * DrForr prefers true lies :)

[12:13] <moritz> m: multi a() { die "oh nooz" }; multi a($a) { say $a }; (gather { take 42 }).map(&a)

[12:13] <tadzik> it is so real!

[12:13] <camelia> rakudo-moar 93418e: OUTPUT«42␤»

[12:13] <GLRelia> rakudo-moar a343c2: OUTPUT«42␤Cannot invoke this object (REPR: Uninstantiable)␤  in block <unit> at /tmp/HnaFyjZsPa:1␤␤»

[12:13] <timotimo> o/

[12:13] <masak> tadzik: wow, that is painful to read

[12:15] <moritz> m: (gather { take 42 }).map(&say)

[12:15] <camelia> rakudo-moar 93418e: OUTPUT«42␤»

[12:15] <GLRelia> rakudo-moar a343c2: OUTPUT«42␤Cannot invoke this object (REPR: Uninstantiable)␤  in block <unit> at /tmp/xfMEeZi5kg:1␤␤»

[12:18] <masak> moritz++ # whatever it is you're doing

[12:18] <masak> going through spectests, looks like

[12:19] <moritz> fwiw this one dies in pull-exactly from GATHER

[12:20] <moritz> masak: yes

[12:20] <moritz> nqp::continuationreset(PROMPT, &!resumption); is the line that dies

[12:20] <timotimo> so $!resumption is perhaps null?

[12:21] <moritz> maybe; I just know that I don't know the code well enough to dig deeper into this one

[12:22] * masak .oO( nqp::continuationresurrect(PROMPT, &!redemption); )

[12:22] <timotimo> %)

[12:22] <TimToady> the "one arg" rule is not that single args are special, but that things that look like multiple args are really a single arg to begin with

[12:23] <TimToady> and the rationale is that we can use the same constructs to iterate anything, not have two different mechanisms for iterating internal vs external lists

[12:24] <TimToady> so asking a comma list for its list of values is no different from asking any other object for its list of values

[12:24] <masak> that sounds... vaguely sane.

[12:25] <masak> I would say "entirely sane", but my head is still spinning. :)

[12:25] <TimToady> so, for instance, the implementation of 'for' no longer has to jump through hoops to make it look a map; it now really is just a map

[12:26] *** Ven joined
[12:28] <TimToady> under the old way, we had to keep slapping a (thing,) around the expression internally, which was really bad for performance

[12:28] <timotimo> oh, is that so!

[12:29] <ShimmerFairy> TimToady: so at this point we should obviously rename the 'for' keyword to 'map' :P

[12:29] <timotimo> map is for having the arguments of for in reverse order

[12:29] <timotimo> otherwise you'd have to Rfor

[12:30] <ugexe> should CUR install hook files to the same place as bin/ and module files? they would be required for rebuild-recompiliation

[12:31] *** laben joined
[12:31] <ShimmerFairy> ugexe: for some reason I'm reminded of emerge with its @preserved-rebuild (and before that, "revdep-rebuild")    :)

[12:32] <laben> hello p6'ers

[12:32] <timotimo> mhhh revdep rebuild

[12:32] <timotimo> i remember using that quite a bit

[12:32] <ShimmerFairy> timotimo: `revdep-rebuild` is now spelled `emerge [your usual flags] @preserved-rebuild`, and has been for a little while :)

[12:32] <timotimo> i haven't used gentoo for a long time :)

[12:33] <nine> TimToady: many thanks! With your explanation this makes so much sense now :)

[12:34] <ShimmerFairy> timotimo: but for sure, if I ever get into working on Perl 6's module stuff (that is, S11 and S22), I'd probably be taking a lot of inspiration from portage, both intentionally and accidentally :P

[12:34] <ugexe> i've been working on package orphaning but im getting to the reinstall-but-validate dealy

[12:34] <timotimo> hehe

[12:35] <timotimo> being inspired by lots of different sources is definitely a good thing

[12:35] <timotimo> maybe we should take inspiration from maven and npm and some more others

[12:35] <ShimmerFairy> I was about to say gradle, but that Java-based tool doesn't do the modules bit :)

[12:36] <timotimo> mhm

[12:36] <timotimo> well, build system related stuff could be interesting to perl6, too ... to get production pipelines for video game development ... assets and such for example

[12:36] <laben> today i got the easiest fix ever seen (at least by me) and it's for the TestML module, someone got commit rights?

[12:37] <timotimo> ooooh!

[12:37] <masak> I agree, after TimToady's explanations, GLR almost seems like a good thing. :P

[12:37] <timotimo> you can fix TestML?

[12:37] <timotimo> that's excellent!

[12:37] <ShimmerFairy> timotimo: 6make would be far superior to gmake for sure :3

[12:37] <laben> for nom... didnt check glr

[12:37] <timotimo> ugh

[12:37] <timotimo> how do you feel about qmake and cmake?

[12:38] <ShimmerFairy> timotimo: I use cmake for my C++ stuff, including my Qt projects :) (aka the KDE approach)

[12:38] * JimmyZ doesn't know what is  'one arg rule'

[12:38] <timotimo> ah, yes. i saw that when building krita

[12:38] <laben> timotimo: lib/TestML/Parser.pm line 66 => change the last char (the comma) to semicolon

[12:38] <timotimo> JimmyZ: more or less "if you write for $foo, it'll iterate over the contents of $foo"

[12:39] <timotimo> laben: when i tried to improve TestML some time ago, i found out that that module doesn't even barely parse official testML syntax

[12:40] <JimmyZ> like my $foo = [2,3], ' for $foo { .. } ' vs  'for $foo, 4 { ... }' ?

[12:40] <timotimo> yes

[12:40] <laben> timotimo: oh, i didnt know that, i need to go deeper ò.ò

[12:40] <timotimo> "$foo, 4" will do 2 iterations, "for $foo", too

[12:40] <timotimo> laben: i might have become massively confused, though

[12:40] <ugexe> id be surprised if you could just swap out that comma for a ; and it would work correctly. maybe pass tests

[12:41] <JimmyZ> yeah, I saw it in the roast 

[12:41] <laben> as i said, it's a fix for nom, not glr

[12:42] <ugexe> m: my %x; my %y; %x<a> = 1; %y = "\\\\" => "\\", %x; say %y.perl

[12:42] <camelia> rakudo-moar 93418e: OUTPUT«{"\\\\" => "\\", :a(1)}<>␤»

[12:42] <GLRelia> rakudo-moar c4d1b0: OUTPUT«{"\\\\" => "\\", :a(1)}␤»

[12:42] <ugexe> m: my %x; my %y; %x<a> = 1; %y = "\\\\" => "\\"; %x; say %y.perl

[12:42] <camelia> rakudo-moar 93418e: OUTPUT«WARNINGS:␤Useless use of variable %x in sink context (line 1)␤{"\\\\" => "\\"}<>␤»

[12:42] <GLRelia> rakudo-moar c4d1b0: OUTPUT«WARNINGS:␤Useless use of variable %x in sink context (line 1)␤{"\\\\" => "\\"}␤»

[12:44] <ugexe> plus that method then returns the result of make %h, instead of returning my %h = '\\' => "\\", make %h

[12:45] <moritz> m: my $gorch = "foo bar"; say «FOO $gorch BAR».perl

[12:45] <camelia> rakudo-moar 93418e: OUTPUT«("FOO", ("foo", "bar"), "BAR")␤»

[12:45] <GLRelia> rakudo-moar c4d1b0: OUTPUT«("FOO", ("foo", "bar"), "BAR")␤»

[12:45] <laben> mh, trying to set up glr right now, is it normal that bootstrapping panda fails at the very beginning?

[12:45] <nine> laben: yes

[12:46] <moritz> laben: I'm pretty sure that rakudo-glr is not far enough yet to bootstrap panda

[12:46] <timotimo> right, sadly yes

[12:46] <timotimo> well, rakudo-glr may have to advance a little bit still, but panda needs a few changes, too, no?

[12:46] <nine> laben: there's a glr branch of panda that comes a little further

[12:46] <laben> "Must specify something as a path: did you mean '.' for the current directory?" which bring us to lib/Panda/Ecosystem.pm line 25

[12:46] <dalek> roast/glr: 316336e | moritz++ | S02-literals/quoting.t:

[12:46] <dalek> roast/glr: Add a flat() call to quoting.t

[12:46] <dalek> roast/glr: review: https://github.com/perl6/roast/commit/316336e7a3

[12:46] <moritz> timotimo: yes

[12:47] <nine> and I've got some trivial local changes that allows it to install, just not yet to work fully

[12:47] <timotimo> oooooh

[12:47] <nine> moritz: we're actually pretty close :)

[12:47] <_itz_> laben: zef has worked recently on GLR although maybe not right now

[12:47] <ugexe> zef works still. you just have to force install

[12:47] *** leont left
[12:47] <_itz_> I stand corrected :)

[12:47] <moritz> just don't do anything with lists, and you'll be fine :-)

[12:48] <timotimo> yeah, all you really need is cons cells

[12:48] <moritz> hashes work too (mostly)

[12:48] <nine> moritz: I wonder if this flat you added really is how it's supposed to work now, or if it's just a remaining bug in rakudo?

[12:48] <ShimmerFairy> As long as your program does not need a grouped collection of items, it's good to go! :P

[12:49] <moritz> nine: I'm not entirely sure; but since the result was the same pre-glr, I decided to add it

[12:49] <moritz> but it does feel odd

[12:49] <laben> well then, i'll check out ufo then

[12:50] <nine> moritz: the whole point of <<foo $bar>> is AFAIK to build lists. Seems strange if you had to explicitly flatten that to actually assign it to an array.

[12:50] <nine> m: my $b = "bar"; my @a = <<foo $bar>>; say @a.perl;

[12:50] <camelia> rakudo-moar 93418e: OUTPUT«5===SORRY!5=== Error while compiling /tmp/la7Z_14fSd␤Variable '$bar' is not declared␤at /tmp/la7Z_14fSd:1␤------> 3my $b = "bar"; my @a = <<foo 7⏏5$bar>>; say @a.perl;␤»

[12:50] <GLRelia> rakudo-moar c4d1b0: OUTPUT«5===SORRY!5=== Error while compiling /tmp/XhZoTraNdx␤Variable '$bar' is not declared␤at /tmp/XhZoTraNdx:1␤------> 3my $b = "bar"; my @a = <<foo 7⏏5$bar>>; say @a.perl;␤»

[12:50] <nine> m: my $b = "bar"; my @a = <<foo $b>>; say @a.perl;

[12:50] <camelia> rakudo-moar 93418e: OUTPUT«["foo", "bar"]<>␤»

[12:50] <GLRelia> rakudo-moar c4d1b0: OUTPUT«["foo", "bar"]␤»

[12:50] <dalek> roast/glr: 625fc57 | moritz++ | S02-literals/quoting.t:

[12:50] <dalek> roast/glr: Revert "Add a flat() call to quoting.t"

[12:50] <dalek> roast/glr: 

[12:50] <dalek> roast/glr: This reverts commit 316336e7a32f300e9e853325bd815bd6d3fffd28.

[12:50] <dalek> roast/glr: review: https://github.com/perl6/roast/commit/625fc572d6

[12:50] <moritz> nine: ok, you convinced me :-)

[12:51] <moritz> oh, and nine++ for fixing that spectest hang earlier

[12:51] <nine> moritz: ah, now I saw the $gorch. I left that one alone because I have no idea if <<>> should flatten its contents

[12:52] <nine> Would be nice if someone who actually knew (rather than guessed) something about the new semantics could chime in there.

[12:53] <timotimo> where are we going to find a TimToady at this time of day?

[12:53] <nine> From HYPER: my $type = left.WHAT; nqp::iscont(left) ?? $type(@result.eager).item !! $type(@result.eager)

[12:53] <nine> ^^^ this looks kinda oldish to me. Probably the reason for the remaining slice fail

[12:54] <nine> Oh, I just noticed that I have already done some work on HYPER...

[12:55] <laben> m: my @a=1..5; my @b = @a>>.pred Z @a; @b.say

[12:55] <camelia> rakudo-moar 93418e: OUTPUT«0 1 1 2 2 3 3 4 4 5␤»

[12:55] <GLRelia> rakudo-moar c4d1b0: OUTPUT«0 1 1 2 2 3 3 4 4 5␤»

[12:56] <TimToady> what makes you think I'm not guessing too?  :)

[12:57] <ugexe> these new supply constructs are going to make stdmuxing trivial :)

[12:57] <TimToady> only instead of trying to guess what TimToady wants, I'm trying to guess what future generations of programmers will want...

[12:57] <laben> m: my @a='a'..'e'; my %b = @a>>.succ Z @a; %b.say

[12:57] <camelia> rakudo-moar 93418e: OUTPUT«b => a, c => b, d => c, e => d, f => e␤»

[12:57] <GLRelia> rakudo-moar c4d1b0: OUTPUT«Odd number of elements found where hash initializer expected␤  in block <unit> at /tmp/fa582_lDKs:1␤␤»

[12:57] <laben> m: my @a='a'..'e'; my %b = @a>>.succ Z=> @a; %b.say

[12:57] <camelia> rakudo-moar 93418e: OUTPUT«b => a, c => b, d => c, e => d, f => e␤»

[12:57] <GLRelia> rakudo-moar c4d1b0: OUTPUT«b => a, c => b, d => c, e => d, f => e␤»

[12:57] <laben> eureka!

[12:58] <TimToady> we really, really need to make .gist through in parens for clarity

[12:58] <nine> TimToady: I'd just very much like to defer to your experience in guessing what future generations of programmers want

[12:58] <TimToady> *throw

[12:59] <ShimmerFairy> TimToady: I would very much love if Positional .gists weren't unbracketed space-separated-values

[12:59] <TimToady> they can still be space separated

[12:59] <TimToady> just make 'em look more like s-exprs

[12:59] <ShimmerFairy> sure, so long as you don't choose <> or «» as the general brackets :P

[13:00] *** AlexDaniel joined
[13:01] <moritz> as long as the spaces are further delimited by commas, all is good

[13:02] <TimToady> clutter

[13:02] <ShimmerFairy> I don't the spaces are so much an issue, it's just that combined with the lack of brackets it makes it look worse (but I think brackets alone should suffice)

[13:06] *** jack_rabbit left
[13:06] *** Ven left
[13:09] <TimToady> I think in this case I probably agree with the view that trying to use «» for multi-dimensional stuff comes under the categor of "unnatural act", so it should probably imply .flat itself

[13:09] <dalek> rakudo/glr: b445bf1 | (Stefan Seifert)++ | src/core/metaops.pm:

[13:09] <dalek> rakudo/glr: Fix HYPER wrapping results in an extra list

[13:09] <dalek> rakudo/glr: 

[13:09] <dalek> rakudo/glr: We need to explicitly flatten the array when passing to the coercer now.

[13:09] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/b445bf1c2d

[13:12] *** brrt joined
[13:13] *** rmgk_ joined
[13:13] *** rmgk is now known as Guest45101

[13:13] *** Guest45101 left
[13:13] *** rmgk_ is now known as rmgk

[13:14] *** brrt left
[13:15] *** brrt joined
[13:17] <ShimmerFairy> I wasn't aware you could, I think you'd have to be quite clever to sneak a list into «» (doubly so for <>)

[13:19] <TimToady> it was more a side effect of how it implements interpolation

[13:19] <JimmyZ> .tell jnthn looks like  you forgot to push  the new S17-supply/syntax.t

[13:19] <yoleaux> JimmyZ: I'll pass your message to jnthn.

[13:20] <ShimmerFairy> Yeah, that's what I was thinking. You certainly can't stick another «» in there, and every list construct would just be interpreted as a number of strings.

[13:26] *** Ven joined
[13:27] *** g4 left
[13:37] *** Possum joined
[13:40] <dalek> perl6-roast-data: 20c77e8 | coke++ | / (10 files):

[13:40] <dalek> perl6-roast-data: today (automated commit)

[13:40] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/20c77e80e2

[13:41] <[Coke]> glr percentage increasing.

[13:44] <[Coke]> S09-typed-arrays/native-int.t - 1380 tests aborted (

[13:44] *** pierrot joined
[13:44] <[Coke]> that's the biggest fail ATM.

[13:46] *** xfix left
[13:47] *** aborazmeh joined
[13:47] *** aborazmeh left
[13:47] *** aborazmeh joined
[13:52] <dalek> rakudo/glr: 3e32f40 | (Stefan Seifert)++ | src/core/metaops.pm:

[13:52] <dalek> rakudo/glr: Fix >> >> and << << hypers

[13:52] <dalek> rakudo/glr: 

[13:52] <dalek> rakudo/glr: Hyper operators with a single item on one side work now as well.

[13:52] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/3e32f40444

[13:52] <Ven> nine++

[13:52] <nine> [Coke]: natives have a lot of NYI still

[13:52] <Ven> .oO( great work jnthning it all up )

[13:53] <nine> It's a great way of learning Perl 6 btw. I didn't even know what >>+<<, <<+<< or >>+>> meant before I started fixing them ;)

[13:54] <timotimo> sadly, now you've fixed them, others won't be able to learn much from that :(

[13:54] <nine> Yeah, we'd need another great refactor for that

[13:54] <timotimo> what do we refactor next

[13:54] <timotimo> integers?

[13:55] <nine> Scalars?

[13:55] <Ven> first-class {s,tw}igils!

[13:56] <timotimo> sub scalar_mod:<√> ...

[13:56] <Ven> :D.

[13:57] <[Coke]> nine: D'oh - that's actually an easy fix. look at the for loop on about line 10...

[13:57] <[Coke]> I spent 5 minutes reducing that down and realized it's actually the for loop that's dying, not anything else. :P

[13:58] <nine> [Coke]: for flat @int,@uint -> $T { allows 14 tests to pass

[13:58] <[Coke]> yup. :)

[13:58] <[Coke]> well, that's 14 more, anywhere. I'll let you push that.

[13:58] *** aborazmeh left
[13:58] <nine> [Coke]: well you found it :)

[13:59] *** cognominal left
[13:59] <[Coke]> ok, pushing.

[14:00] <AlexDaniel> timotimo: qx//, shell and run, please

[14:00] <[Coke]> ENODALEK?

[14:00] <AlexDaniel> that's what needs some changes before 1.0

[14:01] <timotimo> didn't we just have changes made to that?

[14:01] <AlexDaniel> timotimo: oh really!

[14:01] <timotimo> froggs changed things

[14:01] <AlexDaniel> timotimo: that sounds really, really nice!

[14:01] <timotimo> in order to make them work differently with regards to output grabbing

[14:01] *** synbot6 joined
[14:01] <AlexDaniel> timotimo: where can I read about that?

[14:01] <timotimo> like, with the :out parameter

[14:01] *** Ven left
[14:01] <AlexDaniel> oh yeah!!!

[14:01] <timotimo> sorry, dunno :S

[14:02] <AlexDaniel> hm, does anybody knows something about that?

[14:03] <timotimo> froggs is the one who did it

[14:03] <ugexe> what about it

[14:04] <AlexDaniel> .tell FROGGS I've been waiting for this! So how does it work now? “<timotimo> froggs changed things in order to make them work differently with regards to output grabbing”

[14:04] <yoleaux> AlexDaniel: I'll pass your message to FROGGS.

[14:04] <laben> O.o seems like ufo gets by with 2 simple fixes...

[14:05] <ugexe> my $handle = shell("cmd", :out); say $handle.out.lines

[14:05] <timotimo> but ufo doesn't know about registering things with the right CUR, so you have to -Iblib/lib all the time

[14:05] <AlexDaniel> .tell FROGGS I mean, qx// and run.

[14:05] <yoleaux> AlexDaniel: I'll pass your message to FROGGS.

[14:06] <laben> timotimo: but it's much better for (amateur) packaging, at least up to panda and its deps

[14:06] *** pmurias joined
[14:06] <timotimo> fair enough

[14:06] <dalek> nqp/js: 1de4996 | (Pawel Murias)++ | src/vm/js/QAST/Compiler.nqp:

[14:06] <dalek> nqp/js: Fix indentation

[14:06] <dalek> nqp/js: review: https://github.com/perl6/nqp/commit/1de4996f3a

[14:06] <dalek> nqp/js: 43b8d66 | (Pawel Murias)++ | src/vm/js/ (2 files):

[14:06] <dalek> nqp/js: Implement the quant regex type

[14:06] <dalek> nqp/js: review: https://github.com/perl6/nqp/commit/43b8d66664

[14:06] <dalek> nqp/js: 965c075 | (Pawel Murias)++ | src/vm/js/ (3 files):

[14:06] <dalek> nqp/js: Pass test 31-grammars.

[14:06] <dalek> nqp/js: 

[14:06] <dalek> nqp/js: Set boolification mode when deserializing STables.

[14:06] <dalek> nqp/js: review: https://github.com/perl6/nqp/commit/965c075964

[14:06] <AlexDaniel> ugexe: http://irclog.perlgeek.de/perl6/2015-07-11#i_10881463

[14:08] *** Ven joined
[14:08] <ugexe> run can give you a file handle though. so you can read from it lazily

[14:08] <ugexe> well a handle

[14:09] <AlexDaniel> ugexe: good-good, still everyone is going to use qqx// just because it is shorter…

[14:10] <AlexDaniel> I mean, less characters to type

[14:10] <ugexe> run and shell will (in the future) have :merge for capturing both :out and :err to the $out handle. or you can have each separate

[14:11] <ShimmerFairy> What's wrong with qx// ?

[14:11] *** virtualsue joined
[14:11] <AlexDaniel> ShimmerFairy:  http://irclog.perlgeek.de/perl6/2015-07-11#i_10881463

[14:11] *** rurban_ left
[14:12] <ugexe> qx also doesn't give you the status/exitcode and whatnot. for fine grained control, you would use run over qx//

[14:13] <AlexDaniel> ugexe: you can have all these nice features but the most common need is to get the output

[14:13] <AlexDaniel> ugexe: and whether you need status code or whatever should not even be a question here

[14:13] <AlexDaniel> the question is whether you want to do it through shell or not

[14:13] <AlexDaniel> want shell? OK, use qx

[14:13] <AlexDaniel> or 'shell'

[14:14] <AlexDaniel> nope? Use 'run'

[14:15] <AlexDaniel> And I really think that most people don't. And if they do, this is should be a conscious step

[14:15] <ShimmerFairy> AlexDaniel: I'm sorry, I don't get what the issue is from that link.

[14:15] <AlexDaniel> ShimmerFairy: let's say you want to run some program and get its output

[14:16] <pmurias> ShimmerFairy: qx uses the shell, and as such can expose you to shell injection attacks

[14:16] <AlexDaniel> ShimmerFairy: what would you use? This: $output = run(«echo $test», :out).out.lines;

[14:16] <AlexDaniel> ShimmerFairy: or just this: $output = qqx/echo $test/;

[14:17] <ShimmerFairy> I've used qx// before because I specifically _didn't_ want to take the output, and instead let the terminal print it, fwiw :)

[14:18] *** virtualsue left
[14:19] <timotimo> if you run without :out, i think the output will just travel outwards to the terminal, too

[14:19] <ugexe> true

[14:20] <ShimmerFairy> Wait, I got mixed up, it was qx// for getting the output, shell() (run didn't work when I had to use these last) for not taking it :P

[14:20] <ShimmerFairy> (It has been a while since I had to call external commands :P)

[14:20] <laben> masak: got a patch for ufo, works on both nom and glr with this https://gist.github.com/c6e198e31a82fff5e0cf

[14:21] <ugexe> *makes a supply from .out.lines(:!eager) and .taps it*

[14:22] <ShimmerFairy> I can see the security issue, but I'm not convinced shell/run would avoid those where qx// doesn't. (Or rather, I don't think qx is that much more problematic than the others. You shouldn't be blindly passing unchecked arguments in any case.)

[14:23] <pmurias> run doesn't call the shell so it avoids shell injection

[14:25] <ShimmerFairy> unless run is asked to run a shell, of course :)

[14:28] *** virtualsue joined
[14:29] <ShimmerFairy> I definitely see the security concern, but I think "Know what qx//, shell, and run do" is a perfectly valid solution here. I don't see where the language needs to do something about it, aside from whatever security features S23 would mention that you could enable.

[14:31] *** colomon joined
[14:31] <ugexe> will `whatever` eventually allow to say (using the react/whatever gist as an example) `whenever @runners>>.stdout -> $output { print $output.indent(2); }` ?

[14:31] <laben> .tell FROGGS got a patch for TestML with a fix for latest nom, seems to work already on glr: https://gist.github.com/986ba2b9e63d1763601d

[14:31] <yoleaux> laben: I'll pass your message to FROGGS.

[14:32] <AlexDaniel> ShimmerFairy: then we don't have to think about security at all. Just tell the users to “Know what …” and that's it

[14:33] <AlexDaniel> can be applied to any common problem, like SQL injection and etc.

[14:33] <ShimmerFairy> If you're accepting arbitrary input for SQL queries and you don't know about SQL injections (regardless of if your systems handles it for you), you deserve whatever happens :P

[14:34] <AlexDaniel> “If you want to avoid problems, just type that weird-looking long thing” and if the user does not, he “should have known better”

[14:35] <Woodi> hi #perl6 :)

[14:35] <ShimmerFairy> I think the issue here is that S23 has yet to be even written. I really think the better solution would be to have features to disallow tainted input, for example, instead of paranoid-ly removing language features because they have a higher risk of security issues.

[14:35] <Woodi> so how eg. compilers deal with arbitrary input ? :)

[14:36] <ugexe> which, for someone that is new, will likely mean extra code to setup the enviroment to do things like run 'git' that also works on windows

[14:36] <brrt> hi Woodi

[14:36] <brrt> what do you mean arbitrary input?

[14:36] <brrt> what do you mean by compilers? just rakudo, or compilers in general?

[14:36] <Woodi> brrt: I don't know :) like in shell and SQL ;)

[14:37] <AlexDaniel> usually it is not arbitrary input, it is wisely constructed malicious input

[14:38] <AlexDaniel> and “compilers” or whatever do exactly what the hacker tells to do, that's the point :)

[14:38] <brrt> ok, well, some of those are interpreters

[14:38] <ShimmerFairy> I meant "arbitrary" as in "could be anything", not "randomly generated" :)

[14:38] <brrt> but in the first place, it starts with a parser

[14:38] <brrt> actually, that's wrong

[14:39] <brrt> typically compilers and interpreters start with lexical analysis (lexing)

[14:39] <AlexDaniel> ShimmerFairy: OK disallow tainted input, how would you taint variables passed to shell?

[14:39] <brrt> lexical analysis is the origin of regular expressions

[14:39] <|Tux|> test             50000    42.570    42.481

[14:39] <|Tux|> test-t           50000    41.897    41.807

[14:39] <laben> ShimmerFairy: why not random? this shiny thing could be used on moarvm http://lcamtuf.coredump.cx/afl/

[14:39] <ShimmerFairy> shell vars or p6 vars?

[14:40] <AlexDaniel> ShimmerFairy: p6 vars passed to the shell

[14:40] <ShimmerFairy> laben: "could be anything" includes random, I just wanted to point that I didn't mean _just_ random :)

[14:40] <laben> well, yeah

[14:41] <ShimmerFairy> AlexDaniel: my understanding of Perl 5's tainting mechanism (which is very limited) is that variables would be tainted if assigned tainted objects.

[14:41] <brrt> to make a very long story short: any interpreter or compiler worth anything converts the input during lexing (matching input to tokens understood by the language)

[14:41] <AlexDaniel> ShimmerFairy: yea, sure, but what would you do with the string to make sure that it is safe?

[14:41] <brrt> this means that 'input safety' in terms of buffer overflow input safety is *primarily* a lexer issue

[14:42] <AlexDaniel> ShimmerFairy: how would you sanitize it?

[14:42] <brrt> actually recognizing the input stream is part of the parser, which takes a stream of input and builds a tree from it (typically)

[14:42] <ShimmerFairy> AlexDaniel: make sure it's untainted (sanitizing as needed), and qx// and shell would complain if their string is tainted (at least when security features are enabled)

[14:43] <AlexDaniel> ShimmerFairy: yes but that's the question, how would you sanitize it?

[14:43] <dalek> rakudo/glr: 3e7cfcb | (Stefan Seifert)++ | src/core/metaops.pm:

[14:43] <dalek> rakudo/glr: Bring back HYPER with one side shorter than the other

[14:43] <dalek> rakudo/glr: 

[14:43] <dalek> rakudo/glr: (1,2,3) >>+>> (1,2) and (1,2) <<+<< (1,2,3) work again

[14:43] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/3e7cfcbf45

[14:43] <ShimmerFairy> AlexDaniel: that falls on the user of course. There's no way the language could be responsible for sanitizing data for everything.

[14:43] <brrt> perl5 tainting detection is problematic. variables are considered untainted basically after they went through a regular expression

[14:43] <AlexDaniel> ShimmerFairy: yes, ok, but what would *you* do?

[14:43] <ShimmerFairy> brrt: of course, P6 would be better :)

[14:44] <laben> i got a question for GLR'ers: when is a Seq returned/generated instead of a List?

[14:44] <Woodi> so compilers/interpreters have "full" knowledge how to transform things. and with SQL/sh we usually aiming only for "do standard escaping"...

[14:44] <brrt> yeah, and that's dumb, Woodi

[14:44] <brrt> basically, it's faking knowledge about the input language, and that can be circumvented really often

[14:44] <ShimmerFairy> AlexDaniel: whatever input I get externally, I make sure is sanitized, and use it.

[14:44] <Woodi> $shString.bind("-e", 1) # ;)

[14:45] <brrt> the *good* way to do it would be to make a grammar matching the input and serializing the result to a valid language input

[14:45] <AlexDaniel> ShimmerFairy: how do you make sure that it is sanitized? :)

[14:45] <timotimo> yeah, always know what language you're in

[14:45] <Woodi> problem is we want to keep run/qx/... handy, close to CORE...

[14:45] <brrt> well, you can do that. but you can't do that and make it safe

[14:46] <ShimmerFairy> AlexDaniel: the reason I haven't specified is because it depends on what I'm sanitizing for. There's no universal sanitation method, for there are a variety of syntaxes

[14:46] <AlexDaniel> ShimmerFairy: hehe. So the solution is: don't use the shell

[14:46] <AlexDaniel> and there is no problem

[14:46] <Woodi> ShimmerFairy: but exact&perfect eg. for bash ? or perfect for csh ?

[14:46] <ShimmerFairy> AlexDaniel: I'm not talking about just the shell atm, all destinations you could send data to.

[14:47] <AlexDaniel> ShimmerFairy: my issue is with qqx// in particular and not something general

[14:47] <ShimmerFairy> And I don't presently know how to ensure sanity of input for bash or whatever, but when I need to do that I'll look up what's required, and do it :)

[14:48] <AlexDaniel> … you look it up, and some answers will tell you not to use shell because you don't need it…

[14:48] <brrt> Woodi: exact and perfect for bash requires you emulate bash to a pretty far extent

[14:48] <brrt> and it likely won't DWYM anyway

[14:49] <Woodi> ShimmerFairy: there was a talks: "Do not implement file escaping yourself, use File::..." :)

[14:49] <ShimmerFairy> Woodi: of course I would prefer a module, but this is Perl 6. As of now, I'd probably be the one writing the module :P

[14:49] <Woodi> brrt: I hoped for list of chars to \  buuu

[14:50] <AlexDaniel> ShimmerFairy: I see people doing it wrong everywhere. And if the language itself can help the user to step on the right path, so much the better

[14:50] <ShimmerFairy> AlexDaniel: sure, and we already have run() for that, as I understand it :)  I just don't think removing features because they have the potential to cause problems is a good idea.

[14:51] <brrt> i can think of a few tricks that would work. $, (, ) etc, but it's not really safe, and you don't know just what people have linked /bin/sh to

[14:51] <AlexDaniel> uuuuuggghhhh

[14:52] <AlexDaniel> A great example of someone trying to quote things correctly is here, I think: https://github.com/notsecure/uTox/issues/265

[14:52] <AlexDaniel> It took like 4 commits to get it right

[14:52] <brrt> anyway, anyone assuming shelling out on untrusted input .... kind of deserves what they're getting. there are plenty of ways to start a program with arguments without a shell

[14:52] <AlexDaniel> and in the end the solution was… not to use the shell

[14:52] <brrt> there are plenty of ways to start a pipeline, ffs, without starting a shell

[14:53] <brrt> don't. shell. on. input.

[14:54] <AlexDaniel> brrt: Huffman coding

[14:54] <brrt> make a module

[14:54] <AlexDaniel> brrt: if you make it easy to do it wrong then people will do it

[14:55] <brrt> hmm

[14:55] <ShimmerFairy> I think you're giving Huffman too much weight in this instance, it doesn't convince me there's a problem worth removing qx over.

[14:55] <Woodi> maybe just include compile-time switch to disallow shell interaction :)

[14:56] <AlexDaniel> ShimmerFairy: ok, you can make easier to use “run” then

[14:56] <nine> ShimmerFairy: without having backlogged yet, I'm quite reminded of mysql_real_escape() ;)

[14:56] <AlexDaniel> ShimmerFairy: but keep in mind that it is pretty hard to beat qqx//

[14:56] <brrt> then maybe we should be making building a pipeline simpler, which is the only valid reason to use a shell anyway

[14:56] <AlexDaniel> simply because it is too short

[14:56] <DrForr> mysql_real_escape() of course being a tarball of postgres :)

[14:56] <nine> 213/1047 spec test files failing now

[14:57] *** xfix joined
[14:57] <ShimmerFairy> AlexDaniel: if I don't believe Huffman to be an issue here, why would I be interested in making something shorter? :P

[14:57] <AlexDaniel> whatever

[14:59] <ugexe> i think it might be nice if qx// used run, and then you could do like qx: $cmd, :shell;, but then the problem is for shell $cmd is a string, and run it should be an array

[15:00] <AlexDaniel> ugexe: yeah, that's why it is so hard to fix it

[15:00] <ShimmerFairy> ugexe: also, for qqx// , you'd have to deal with  qqx/$prgm-name-might-have-space-tho /  , and I'm not sure I want qqx// to end up doing something like handling the first term specially

[15:01] <AlexDaniel> ShimmerFairy: you have to quote it if it has spaces

[15:01] <ShimmerFairy> AlexDaniel: I mean in terms of qqx// being passed to run, what would you do there?

[15:02] <ShimmerFairy> I could see a qwx// and qqwx// as a "run" version of qx// and qqx// , however.

[15:02] <AlexDaniel> ShimmerFairy: if I, like, really want to use shell? Like under torture?

[15:03] <AlexDaniel> ShimmerFairy: you have to quote all single quotes (turn ' into '\'') and put ' ' around

[15:03] <AlexDaniel> that will work sometimes

[15:03] <AlexDaniel> and basically that's what ShellQuote does in perl5

[15:04] <ShimmerFairy> AlexDaniel: what if you did  qqx/$prgm stuff/  expecting run($prgm, "stuff") , but  my $prgm = "cmd; cmd" ? Would that $prgm be a valid first arg to run?

[15:04] <AlexDaniel> sure

[15:04] <AlexDaniel> well, 'cmd; cmd' is a valid filename

[15:05] <AlexDaniel> under some conditions, like in unix

[15:05] <ShimmerFairy> I think if you really wanted a quoting construct for run() , then the addition of qwx and qqwx would be best. Those names would highlight the fact that you're using quotewords in an executable fashion :)

[15:06] <AlexDaniel> …

[15:07] <AlexDaniel> but then it gets confusing, just like system() is in perl5

[15:07] <AlexDaniel> you change something slighly and the behaviour changes are huge (shell is used or not)

[15:09] <ShimmerFairy> AlexDaniel: no, I'm proposing that qx// and qqx// are the quoting construct versions of shell(), and qwx// and qqwx// are the quoting construct version of run()

[15:10] <AlexDaniel> for those who don't know: system('echo', 'hello world') seems to run a command, system('echo hello world') seems to execute that string in shell

[15:10] *** rindolf joined
[15:11] <ShimmerFairy> To me, having the names contain "quote word" in them perfectly illustrates the nature of run(). You used «» (which is qqx) to pass stuff to run() in that backlog link, so I think it really is a natural fit :)

[15:11] <ShimmerFairy> er, s/qqx/qqw/

[15:11] <AlexDaniel> ShimmerFairy: run does not quote anything

[15:11] <AlexDaniel> ShimmerFairy: so what does it illustrate?

[15:11] <geekosaur> yes, that's documented (single parameter acts like C's system(), multiple uses exec) --- but. I thought it also looked for simple single strings and bypassed the shell?

[15:11] *** tadzik joined
[15:11] <geekosaur> ...perldoc -f system confirms

[15:12] <ShimmerFairy> You used    run(«echo $test», :out).out.get;    that «echo $test» is equivalent to qqw[echo $test]

[15:12] *** leont joined
[15:12] <ugexe> the only thing that bugs me is the inconsistency with proc::async... notably this (trying to pass '$program' via -e)

[15:12] <ugexe> [$*EXECUTABLE, '-I.', '-e', $.async ?? $cmd !! '"'~$cmd~'"', 'Build.pm']

[15:13] <ShimmerFairy> so I'm saying that qqwx/echo $test/ would be equivalent to   run(qqw/echo $test/)  which is equivalent to  run("echo", "$test")

[15:13] <geekosaur> ugexe, isn't that running a subsidiary perl?

[15:13] <geekosaur> -e vs. -c is correct

[15:14] <AlexDaniel> ShimmerFairy: yes, that's better. Still, Huffmanly speaking, it is wrong. And it is also confusing because there is not enough visual difference

[15:14] <ugexe> i mean if you run that with run and proc::async without the ??!!, it will not run the same thing

[15:14] <AlexDaniel> ShimmerFairy: but I would definitely complain less if that was implemented

[15:14] <AlexDaniel> .oO(less…)

[15:14] *** diana_olhovik left
[15:15] <ShimmerFairy> AlexDaniel: "Huffmanly speaking", qq// is wrongly longer than q// , since qq does more useful stuff for the user, and qq vs. q seems to do fine with the supposed visual difference issue 

[15:16] <laben> tadzik: File::Find seems to be fine on GLR given a slight change to the equals function in the tests (use >> instead of .map)

[15:16] <AlexDaniel> ShimmerFairy: I agree that people should prefer single quotes over double quotes, and it is also consistent with English language – single and double quotes

[15:16] <tadzik> laben: oh, cool

[15:16] <AlexDaniel> although single quotes are not a real thing

[15:17] <tadzik> I was trying to figure out recently why this current code isn't working

[15:17] <AlexDaniel> ShimmerFairy: but you also have “” which I use (as you can see)

[15:17] <laben> tadzik: i fear you need latest-est glr commit by nine++

[15:17] <ShimmerFairy> AlexDaniel: I was pointing out why the huffman argument is especially silly for qx vs. qwx, not making a sincere case there :)

[15:18] <AlexDaniel> ShimmerFairy: it did not really work because q{} qq{} are alright

[15:18] <tadzik> laben: well, if File::Find still needs tests then it doesn't solve my problem :P

[15:18] <laben> ok, maybe not the last one exactly

[15:18] <tadzik> erm, s/tests/changes/

[15:19] <ShimmerFairy> AlexDaniel: first of all, I think the 'w' helps imply "array of strings" where qx and qqx don't (and thus would be an issue of confusion). Second, if you genuinely believe one character of difference is enough to be Huffmanly absolutely terrible, then I don't know what to say.

[15:19] <laben> tadzik: i did not change anything in the lib itself, just the test func. anyway i'm going ahead and check Shell::Command

[15:19] <ShimmerFairy> (Other than the fact that most people don't code in a constant "code golf" mode ☺)

[15:19] <hoelzro> o/ #perl6

[15:20] <laben> tadzik: here it is https://gist.github.com/anonymous/ac86150158062ae482e1

[15:22] <Ven> \o, hoelzro 

[15:23] <hoelzro> ahoy Ven 

[15:24] <AlexDaniel> ShimmerFairy: Well, currently we are getting the users into a trap by making it hard to do things correctly. You are suggesting to make dangerous and safe things equivalent. But I want to have safe things easy, and dangerous things possible.

[15:24] *** brrt left
[15:26] <ShimmerFairy> AlexDaniel: well, I do think it'd be nice to have a short form for run(). But making qx// and qqx// do that would 1) cause deprecation issues I'm not sure are worth it, and 2) make qx and qqx act in a quotewords-like way with no name-wise indication, which is why I'd go for qwx and qqwx for that

[15:27] * AlexDaniel afk

[15:28] <tadzik> laben: yeah, I'm aware that it's just tests. Your patch sheds some more light on what I wanted to know though :)

[15:29] <tadzik> I'd be curious to know why this change is necessary

[15:29] <laben> tadzik: didnt investigate deeply, but it seems .map or .IO were messing something up

[15:30] <laben> tadzik: the list of 7 items got collapsed to only 1 it seems

[15:30] <tadzik> may be something with flattening or so

[15:30] <tadzik> yeah, that's what I got from the error message, I didn't know what it means though

[15:30] <laben> but .map shouldnt do flattening >> doesnt do

[15:31] <laben> i mean, both flatten or dont

[15:32] <jnthn> wow, a lot of backlog while I went for dinner/drinks :)

[15:32] <yoleaux> 13:19Z <JimmyZ> jnthn: looks like  you forgot to push  the new S17-supply/syntax.t

[15:32] *** larrywall joined
[15:33] <larrywall> help me

[15:33] *** larrywall left
[15:33] <tadzik> what is it with trolls today

[15:34] <jnthn> Heh, the async IO is overhead comment is hilarious. Anyone with the first clue about how IO actually works in a computer knows it's all async at the OS level. It's creating the illusion of synchrony that is the overhead.

[15:35] <dalek> roast: a78b9f2 | jnthn++ | S17-supply/syntax.t:

[15:35] <dalek> roast: Add basic S17 supply/whenever syntax tests.

[15:35] <dalek> roast: review: https://github.com/perl6/roast/commit/a78b9f2019

[15:35] *** breinbaas left
[15:36] <jnthn> There's the test file I forgot to push :)

[15:36] *** RabidGravy joined
[15:36] <JimmyZ> jnthn++ :)

[15:36] <jnthn> JimmyZ: Thanks for the reminder. :)

[15:38] <ShimmerFairy> jnthn: well, if I don't have the first clue about how IO works, would async IO be... over my head? :P

[15:38] *** rurban_ joined
[15:38] <flussence> jnthn: I read a long article on efficient memory access a long time ago that made the same case for system RAM. You don't get much speedup from a dozen core CPU if you treat RAM accesses as synchronous, cause they're not at all...

[15:38] *** CQ joined
[15:39] *** khw joined
[15:39] <Ven> .tell [Coke] I remember you were a Tcl fan -- have you looked at http://wiki.tcl.tk/41658 ?

[15:39] <yoleaux> Ven: I'll pass your message to [Coke].

[15:40] *** cognominal joined
[15:40] <jnthn> ShimmerFairy: Depends if your language makes it notably harder to deal with the sync I/O.

[15:40] <_itz_> tadzik: I suspect a certain blog post brought some trolls from under their bridges

[15:40] <jnthn> ShimmerFairy: I'm not saying it's wrong to use sync APIs, just that commenting that async IO is overhead is ridiculous. :)

[15:40] <_itz_> I made the mistake of engaging with the author on twitter

[15:40] <ShimmerFairy> ooh, which one?

[15:41] <ShimmerFairy> jnthn: yeah, I was just making a terrible overhead/over my head pun :P

[15:41] <jnthn> Oh!

[15:41] <jnthn> Sorry, I'd have noticed it if I wasn't quite so tired ;)

[15:41] <ShimmerFairy> [joke about async sleeping]

[15:42] <jnthn> flussence: Yeah, memory locality is much why I'm trying to get supplies as the core focus rather than channels :)

[15:43] <ShimmerFairy> I recall hearing a while back that the biggest blocker to Dwarf Fortress' speed is RAM latency, interestingly. I should perhaps get to know how computer hardware works, specifically, at some point :)

[15:43] <ShimmerFairy> _itz_: what blog post, if I may ask?

[15:44] *** telex left
[15:44] <_itz_> its in the backlog .. its really very TD;DR .. it looks like the author has never even tried p6

[15:44] <_itz_> best ignored

[15:45] <_itz_> ^ TL;DR 

[15:45] <laben> Too Dense; Didnt Read, just about right...

[15:46] <laben> but i read it °.°

[15:46] *** telex joined
[15:49] <jnthn> I don't think we need to worry too much over about some Perl 5 folks not wanting to adopt Perl 6. For one becuase it's clear that not only are some Perl 5 users interested, but so are plenty of folks from other backgrounds (which is more important for growth). But for two, those who are happy enough with Perl 5 do, after all, already have a Perl, and Perl 5 has shown a better ability to evolve than most other languages out there.

[15:49] * laben hugs everyone!

[15:50] <laben> Let's be happy :)

[15:50] <ShimmerFairy> I just took a look at it, and yeah, it reads like "I like what I do, so I'm going to complain about what I don't do" :P

[15:53] *** magistr joined
[15:53] *** abraxxa left
[15:55] <[Coke]> Ven: thanks, but nope. :)

[15:55] <yoleaux> 15:39Z <Ven> [Coke]: I remember you were a Tcl fan -- have you looked at http://wiki.tcl.tk/41658 ?

[15:55] <[Coke]> I know people that are still using a perl pre 5.8 and are happy and don't see the need for any of this newfangled stuff.

[15:55] *** diana_olhovik_ joined
[15:56] <[Coke]> (from an Albany.pm meeting - guy showed up hoping that he could find like minded perlites who would do contracting work for him, I think)

[15:56] <_itz_> I used Tcl in one job and ended up quite liking it - http://antirez.com/articoli/tclmisunderstood.html is good

[15:56] <jnthn> laben: Well, yes, exactly. I think everyone here who is actually working on Perl 6 is doing it because they like what they're building.

[15:57] <pmurias> jnthn: if there are technical reason blocking Perl 6 from being adapted we should try to solve them

[15:58] <laben> jnthn: i would like it better if i were able to successfully hack on rakudo :/

[15:58] <ShimmerFairy> I don't think there are any real technical issues anymore, it's more an issue of adoption and ecosystem and all that stuff.

[15:58] * [Coke] hurls http://news.perlfoundation.org/2015/08/perl-6-hague-grant-application-1.html - I have to recuse myself, but if anyone else thinks this is a good idea...

[16:00] <jnthn> pmurias: For sure; I wasn't saying we should ignore input, simply that we shouldn't be disheartened if some folks say "no, I'm happy where I am" - and especially so if the "where they are" is among the better places they could be. :)

[16:01] <Ven> [Coke]: :D

[16:01] <_itz_> I think there are some easy sells about perl6 .. I gave a begineers perl6 grammars talk to a local perlmongers group and the reaction was positive

[16:03] <laben> tadzik: for each map2>> transition done, there's an equal and inverse >>2map transition to do. i found what gave Shell::Command problems at least in the tests

[16:04] <jnthn> [Coke]: I suspect I have to recuse myself on that too ;)

[16:04] *** pyrimidi_ joined
[16:04] <_itz_> I think some people are a bit scared of new syntax and focusing on how perl6 syntax can be simplier and clearer will win those peopel over

[16:04] *** pyrimid__ joined
[16:04] <laben> tadzik: here it is https://gist.github.com/anonymous/5481d2e6df95b8fd5e78, fixes the tests. now onto JSON::Tiny

[16:04] <pmurias> jnthn: sure, Perl 6 in it's current state is not ready for moving important things too

[16:04] *** pyrimid__ is now known as pyrimidine_

[16:04] <pmurias> s/to/

[16:05] <RabidGravy> some people were unsettled by the changes from Perl 4 to Perl 5 too

[16:05] <_itz_> also perl5 people are quite adaptable with things like Moose and MooseX::Declare and the DSL aspects of Dancer

[16:05] <jnthn> pmurias: Depends what things they are, and not everything is a case of "moving X to" either. None of the cases where I used Perl 6 in $dayjob situations were migration ones.

[16:06] <_itz_> RabidGravy: it took me several years to write proper perl5 and not perl4 with "my" and "\@args" :)

[16:06] <mst> _itz_: Moops > MooseX::Declare

[16:06] <mst> _itz_: it has the huge advantage of not involving Devel::Declare

[16:06] <magistr> moose

[16:06] <RabidGravy> moof!

[16:07] <magistr> perl6 don't have normal OOP?

[16:07] *** Ven left
[16:07] <RabidGravy> er yes

[16:08] <[Coke]> magistr: yes, Perl 6 has OOP.

[16:08] <RabidGravy> shocking

[16:08] <magistr> [Coke], hashes is OOP

[16:08] *** pyrimidi_ left
[16:08] <magistr> like javascript or lisp

[16:09] <[Coke]> ok, troll.

[16:09] <RabidGravy> or cobol

[16:09] <jnthn> OOP is about exchange of messages between autonomous actors.

[16:10] *** araujo left
[16:10] <RabidGravy> said the actress to the bishop

[16:10] <jnthn> The rest doesn't matter much.

[16:11] <cognominal> magistr, thx to jnthn,  the compiler toolkit, rakudo, supports a metamodel. It allows to define almost any OO model (class based or object based)

[16:11] <jnthn> :)

[16:11] <jnthn> Time for sleep here

[16:11] <jnthn> 'night

[16:12] <RabidGravy> it would actually be quite amusing to attempt a prototype type of model

[16:13] <cognominal> Supporting js would allow rakudo to live in a browser.

[16:14] <_itz_> there is that llvm to js route

[16:16] *** Ven joined
[16:17] <magistr> actor model is awful in erlang...

[16:17] <cognominal> nice try

[16:18] <magistr> only a lightweight processes

[16:19] <laben> well, it's true that erlang is made for telecommunications code, not for fashion shows of actors and models

[16:19] *** brrt joined
[16:20] <_itz_> magistr is about the "ST doesn't have a blitter" level of convo from back in the day

[16:21] <RabidGravy> there's some really useful and excellent software made in Erlang

[16:21] <virtualsue> rabbitmq

[16:22] <RabidGravy> couchdb, ejabberd

[16:22] <RabidGravy> loads

[16:24] <magistr> erlang is awful, couse it will be have a normal jobs with lists etc, which is slower than operations in ets

[16:25] <Ven> magistr: seems to be pretty harsh for such a "small" point

[16:25] <tadzik> haha

[16:26] <tadzik> laben: okay, I really need to understand those before I apply them:)

[16:26] <pmurias> _itz_: re llvm to js route, you mean compiling MoarVM to js?

[16:27] <_itz_> pmurias: yes I wondered if anyone had tried it.  I have seen demos of quake etc running

[16:28] <laben> moritz tadzik: dont worry, i got your back. same >>2map for JSON::Tiny

[16:29] <pmurias> _itz_: I'm not aware of any attempts, personally I'm working on getting Perl 6 in the browser by writing a backend that emits javascript

[16:31] <RabidGravy> nobody has mentioned ocaml yet, now I only know one piece of software made with it and that piece of software is almost unique in its domain

[16:31] <magistr> RabidGravy, erl must have a servants to solve a difficult jobs

[16:32] <RabidGravy> but there again so must I ;-)

[16:32] <laben> RabidGravy: ooc, what is it? i seem to remember a compiler in ocaml for another language, but at the moment i cannot remember

[16:32] <pmurias> RabidGravy: why should we mention ocaml?

[16:33] <magistr> ocaml is too ugly as perl

[16:33] <RabidGravy> http://liquidsoap.fm/ is an almost unique piece of software made in ocaml

[16:34] * pmurias is confused why we should talk about ocaml in #perl6?

[16:34] <magistr> but normal books such as TAPL and Data Structures by Okasaki uses ML

[16:35] <_itz_> pmurias: it has camel in it! sorta

[16:35] <laben> RabidGravy: ooh, shiny! what a nic(h)e thing.

[16:35] <_itz_> hmm there are some mailing list messages about errors with MoarVM and emscripten

[16:35] <RabidGravy> pmurias, it's because someone keeps bringing up other languages

[16:36] <magistr> perl6 have TCO?

[16:36] <geekosaur> hello, unison

[16:36] <RabidGravy> yaw

[16:37] <geekosaur> (for widely used software written in ocaml)

[16:37] <virtualsue> TCO?

[16:38] <magistr> tale rec optimize

[16:38] <RabidGravy> total cost of ownership?

[16:38] <laben> The Chosen One? ofc perl6 it is

[16:38] <pmurias> RabidGravy: I don't think that's a good idea

[16:38] <laben> wait is TCO perl6 or TimToady?

[16:38] <_itz_> I think we need a perl6 script to parse magistr 

[16:39] <laben> or maybe it was Totally Cool Operation

[16:39] <magistr> coq written on OCaml and it is a very nice

[16:40] <geekosaur> oh dear, did they hit this channel too?

[16:42] *** colomon left
[16:44] <ugexe> is there a way to do atomic compare and swap yet?

[16:44] *** colomon joined
[16:45] <RabidGravy> pmurias, another interest in a JS backend for me is some crack induced idea I have of using P6 to make CouchDB applications

[16:45] <flussence> "atomic" sounds like you're trying to avoid a race condition... sounds like something that may be better handled at a higher level.

[16:46] <magistr> perl...only loops

[16:46] <tadzik> so, what's this blog post everyone's talking about?

[16:46] <flussence> .oO( I wonder if this self-unaware character is actually a markov/eliza bot... )

[16:48] <magistr> it is imposible to define a types

[16:48] <ugexe> maybe, but i dont want a high level object. i want to write my own register

[16:48] <flussence> .oO( yeah, they definitely seem mind-bogglingly oblivious... )

[16:48] <mst> the rage out in ##prolog after he got banned from #perl seemed more coherent than that

[16:49] <flussence> heh, figured it'd be someone on a trolling spree :)

[16:49] <AlexDaniel> geekosaur: there are other channels?

[16:49] *** Loren_ joined
[16:50] *** espadrine left
[16:50] <AlexDaniel> tadzik: I don't know. Probably this one: http://varlogrant.blogspot.com/2015/08/i-am-unlikely-to-move-to-perl6.html

[16:52] <RabidGravy> some people are strange

[16:52] <pmurias> RabidGravy: any good introduction to couchdb?

[16:52] <geekosaur> they started out in ##math and have been spreading out from there

[16:53] *** blackcat_ left
[16:53] <AlexDaniel> whatever, as long as kids are happy

[16:54] <magistr> people who use a perl are strange

[16:54] *** zakharyas left
[16:54] <AlexDaniel> magistr: yes :)

[16:54] <pmurias> RabidGravy: I could try to see what's currently possible with nqp-js ;)

[16:54] <brrt> people are strange

[16:54] <brrt> when you're a stranger

[16:54] <brrt> faces look ugly, when you're alone :-)

[16:55] <mst> AlexDaniel: that really just seems like "I have my issues because of the 'waiting for godot' period, and I'm trying to work through them"

[16:55] *** diana_olhovik_ left
[16:56] <RabidGravy> pmurias, the docs http://docs.couchdb.org/en/1.6.1/contents.html have most of it, but the bottom line is that the query server is basically a JS thing

[16:56] <brrt> i feel as if that blogpost was written without concern for a coherent story

[16:57] * Ven is surprised people still answer magistr 

[16:57] * Ven still hugs magistr for good measure. After all, coq and ocaml are nice!

[16:58] * brrt has never written ocaml, but heard good things about it

[16:58] <flussence> maybe he's just struggling with the last query he brought to the channel? he just repeated it up above... http://irclog.perlgeek.de/perl6/2015-08-14#i_11057036

[16:59] *** pmurias left
[17:01] *** spider-mario joined
[17:04] <brrt> hmmm... ok, that looks markov-botty to me

[17:05] <brrt> or, poor english, in which case, no offence meant magistr :-)

[17:05] <DrForr> Oh, he's back?

[17:05] <brrt> and yes, perl6 allows you to define your own types, and subtypes, in quite a flexible way

[17:05] <DrForr> Or it's back?

[17:05] <brrt> recent enough to have been in my chat log

[17:07] <DrForr> Oh, sure.

[17:08] <DrForr> *plonk*

[17:11] <flussence> to me it's kinda fascinating to see these types grow increasingly incoherent and frustrated when they don't get the expected reaction :)

[17:11] *** magistr left
[17:12] <RabidGravy> Siberian

[17:13] *** rarara left
[17:13] <flussence> my guess was way off...

[17:13] *** domidumont left
[17:14] <RabidGravy> could of course be a proxy there

[17:14] <laben> m: dd [{a => 1, b => 2}];

[17:14] <camelia> rakudo-moar 93418e: OUTPUT«$ = [{:a(1), :b(2)}]␤»

[17:14] <GLRelia> rakudo-moar 3e7cfc: OUTPUT«[:a(1), :b(2)]␤»

[17:14] <moritz> uhm, that looks wrong on GLR

[17:14] <laben> so, i got this thing [{a => 1, b => 2}] but the hash inside gets flattened away. what to do?

[17:15] <DrForr> You're spending more time thinking about this than he did clicking on the 'download' button :)

[17:15] <flussence> m: dd [+{a => 1, b => 2}]

[17:15] <camelia> rakudo-moar 93418e: OUTPUT«$ = [2]␤»

[17:15] <GLRelia> rakudo-moar 3e7cfc: OUTPUT«[2]␤»

[17:15] <flussence> oh whoops, not p5

[17:15] <flussence> m: dd [%(a => 1, b => 2)]

[17:15] <camelia> rakudo-moar 93418e: OUTPUT«$ = [:a(1), :b(2)]␤»

[17:15] <GLRelia> rakudo-moar 3e7cfc: OUTPUT«[:a(1), :b(2)]␤»

[17:16] <flussence> m: dd [{;a => 1, b => 2}]

[17:16] <camelia> rakudo-moar 93418e: OUTPUT«$ = [-> ;; $_? is parcel { #`(Block|76312816) ... }]␤»

[17:16] <GLRelia> rakudo-moar 3e7cfc: OUTPUT«[-> ;; $_? is parcel { #`(Block|49320912) ... }]␤»

[17:16] <laben> moritz: it actually causes one of the only two glr-pains on JSON::Tiny, the other i "fixed" already

[17:16] <flussence> hm, that's an awkward problem...

[17:17] <flussence> m: say [{;a => 1, b => 2}].[0]

[17:17] <camelia> rakudo-moar 93418e: OUTPUT«-> ;; $_? is parcel { #`(Block|74152272) ... }␤»

[17:17] <GLRelia> rakudo-moar 3e7cfc: OUTPUT«-> ;; $_? is parcel { #`(Block|49155400) ... }␤»

[17:17] <flussence> m: say [{;a => 1, b => 2}].[0]()

[17:17] <camelia> rakudo-moar 93418e: OUTPUT«a => 1 b => 2␤»

[17:17] <GLRelia> rakudo-moar 3e7cfc: OUTPUT«a => 1 b => 2␤»

[17:18] <laben> m: { a => 1, b => 2 }.WHAT.say

[17:18] <camelia> rakudo-moar 93418e: OUTPUT«(Hash)␤»

[17:18] <GLRelia> rakudo-moar 3e7cfc: OUTPUT«(Hash)␤»

[17:18] <laben> m: [{ a => 1, b => 2 }].WHAT.say

[17:18] <camelia> rakudo-moar 93418e: OUTPUT«(Array)␤»

[17:18] <GLRelia> rakudo-moar 3e7cfc: OUTPUT«(Array)␤»

[17:18] <laben> m: [{ a => 1, b => 2 }].perl

[17:18] <camelia> rakudo-moar 93418e: ( no output )

[17:18] <GLRelia> rakudo-moar 3e7cfc: ( no output )

[17:18] <laben> m: [{ a => 1, b => 2 }].perl.say

[17:18] <GLRelia> rakudo-moar 3e7cfc: OUTPUT«[:a(1), :b(2)]␤»

[17:18] <camelia> rakudo-moar 93418e: OUTPUT«[{:a(1), :b(2)}]␤»

[17:18] <ugexe> m: [{a => 1, b => 2},].perl.say

[17:18] <camelia> rakudo-moar 93418e: OUTPUT«[{:a(1), :b(2)}]␤»

[17:18] <GLRelia> rakudo-moar 3e7cfc: OUTPUT«[${:a(1), :b(2)}]␤»

[17:18] <laben> ugexe++

[17:18] <flussence> ugexe++

[17:19] <laben> let's go with that

[17:20] <laben> and with that, i got JSON::Tiny to pass all tests on glr

[17:21] <flussence> those magic trailing commas kinda feel like Rust's magic trailing semicolons :/

[17:21] *** brrt left
[17:21] <laben> moritz: this is for JSON::Tiny on GLR https://gist.github.com/anonymous/f45037d1d61ceb16adbf

[17:21] <laben> next, onto Panda

[17:22] <ugexe> you should note if any of the changes you are submitting also work on nom

[17:22] *** Loren_ left
[17:23] *** mr-foobar joined
[17:23] <laben> ugexe: i'm pretty sure they do, will check later

[17:23] <moritz> nah, you should note if they *don't* work on nom :-)

[17:24] <moritz> it seems S02-types/whatever.t has started looping on GLR :(

[17:25] <laben> nine++ already got some work done on panda-glr

[17:26] *** domidumont joined
[17:26] <moritz> laben: what's your github ID?

[17:27] <laben> moritz: same as my nick here

[17:29] <moritz> laben: ok, you have push access to moritz/json; feel free to push your GLR workaround/fix after you verified that it still works on nom

[17:30] <laben> moritz: will do, meanwhile Panda builds on GLR but few if any test passes

[17:30] *** diana_olhovik_ joined
[17:30] <laben> moritz: sorry, thinko of mine, they do pass some

[17:31] <moritz> m: my $a = 42; my $b = 23; ($a, $b) = ($b, $a); say $a; say $b

[17:31] <camelia> rakudo-moar 93418e: OUTPUT«23␤42␤»

[17:31] <GLRelia> rakudo-moar 3e7cfc: OUTPUT«23␤23␤»

[17:32] <moritz> I wonder what magic is necessary to make that work

[17:34] <moritz> I can see exactly how the current behavior falls out of the design

[17:35] *** skids left
[17:36] *** MadcapJake joined
[17:36] <moritz> m: say (1..Inf).elems

[17:36] <camelia> rakudo-moar 93418e: OUTPUT«Inf␤»

[17:36] <GLRelia> rakudo-moar 3e7cfc: OUTPUT«Cannot .elems a lazy list␤  in block <unit> at /tmp/KkwjlJVDUw:1␤␤Actually thrown at:␤  in block <unit> at /tmp/KkwjlJVDUw:1␤␤»

[17:41] <dalek> roast/glr: 2a34cc8 | moritz++ | S02-types/lazy-lists.t:

[17:41] <dalek> roast/glr: Fix some laziness tests

[17:41] <dalek> roast/glr: review: https://github.com/perl6/roast/commit/2a34cc837a

[17:41] *** llfourn left
[17:42] *** Ven left
[17:43] *** llfourn joined
[17:43] <moritz> m: my $c = (1,2,(3,4)); say $c.elems

[17:43] <camelia> rakudo-moar 93418e: OUTPUT«3␤»

[17:43] <GLRelia> rakudo-moar 3e7cfc: OUTPUT«3␤»

[17:45] <laben> moritz: confirmed that nom passes all glr-adjusted File::Find Shell::Command and JSON::Tiny, now i'll proceed to push to moritz/json if you're okay with it

[17:45] * [Coke] just realizes why his roast commit wasn't reported.

[17:46] <laben> moritz: do you prefer a commit per fix (there are 2) or all together in a "fix for glr" commit?

[17:46] <dalek> roast/glr: 4492a7f | coke++ | S09-typed-arrays/native-int.t:

[17:46] <dalek> roast/glr: for doesn't flatten in glr

[17:46] <dalek> roast/glr: review: https://github.com/perl6/roast/commit/4492a7f680

[17:46] <moritz> laben: together

[17:48] *** llfourn left
[17:50] *** Ven joined
[17:51] <cognominal> ruby bait for bot

[17:54] <dalek> json: 4b020ae | (Luca Bennati)++ | / (2 files):

[17:54] <dalek> json: Fix up methods and test object construction for GLR

[17:54] <dalek> json: review: https://github.com/moritz/json/commit/4b020ae2b8

[17:55] *** sno joined
[17:55] *** [Sno] left
[17:58] *** Ven left
[18:08] <ugexe> i have an action with make $/<blah>>>.made that gives the 'gimmie' error. HYPER -> deepmap -> gimmie

[18:10] <laben> ugexe: check out the fix i made for the same problem is JSON::Tiny

[18:10] <laben> s/ is / in /

[18:13] <DrForr> Huh, the ANTLR converter still runs...

[18:24] *** dha joined
[18:25] <DrForr> dha: Some of your work bears fruit this weekend :)

[18:26] <dha> Oh?

[18:26] *** lucasb joined
[18:27] <DrForr> Yeah, I'm going through builtins and a few other things before YAPC.

[18:28] <dha> Cool. Hope it helps.

[18:30] *** danaj left
[18:32] *** ggoebel joined
[18:33] <dha> Some stuff strikes me as hard to fully automate, however. Certainly behaviors of caller map decently to callframe, but in general... not so much.

[18:33] <DrForr> General channel question - The old 'use My::Package foo => 1' has gone away?

[18:33] <DrForr> dha: Oh, I'm not expecting 100%, not even 80%, but preliminary tests have been encouraging.

[18:34] <dha> Indeed. Just a point, not a dealbreaker.

[18:35] <dalek> roast/glr: c28f587 | (Stefan Seifert)++ | S02-types/whatever.t:

[18:35] <dalek> roast/glr: Fix hang in S02-types/whatever.t

[18:35] <dalek> roast/glr: 

[18:35] <dalek> roast/glr: Flattening an infinit lazy list leads to and endless loop. We use Slip now to

[18:35] <dalek> roast/glr: indicate that we want the list to be interpolated.

[18:35] <dalek> roast/glr: review: https://github.com/perl6/roast/commit/c28f587a91

[18:37] <moritz> uhm, but ((1, 2) xx *).flat shouldn't loop, no?

[18:39] *** cognominal left
[18:42] *** xinming left
[18:42] <nine> moritz: indeed, it will create an iterator. List inherits Iterable's flat method and that does not care about lazyness.

[18:43] <nine> So maybe it's time to give List its own flat implementation

[18:44] <nine> OTOH what would be .flat's job if it does just the same as .iterator?

[18:46] <nine> Even stranger: Array has a flat method that does Seq.new(self.iterator) while inheriting .iterator from List while List itself does not use its own iterator for .flat and inherits Iterable's instead.

[18:48] <DrForr> m: $*PERL.version

[18:48] <camelia> rakudo-moar 93418e: ( no output )

[18:48] <GLRelia> rakudo-moar 3e7cfc: ( no output )

[18:48] <DrForr> m: say $*PERL.version

[18:48] <camelia> rakudo-moar 93418e: OUTPUT«v6.Advent␤»

[18:48] <GLRelia> rakudo-moar 3e7cfc: OUTPUT«v6.Advent␤»

[18:48] <DrForr> No numeric versions?

[18:50] <DrForr> Or will that be v6.1.0 or similar at rollout?

[18:51] <[Coke]>  Probably not.

[18:52] <dha> My reasearch so far has not indicated that any way of getting at the "version" gives anything actually useful.

[18:52] <[Coke]> I think the thought was: any purely numeric versions are going to be confusing as hell given 5 vs. 6 anyway.

[18:52] <dha> Although "v6.Advent" is new. I may need to compile a new rakudo

[18:53] <DrForr> So there won't be an unambiguous way of saying "X is newer than Y".

[18:54] <[Coke]> DrForr: I'm pretty sure we'll be able to figure that out, yes.

[18:54] <DrForr> Okay, I'll leave it alone for the time being.

[18:55] <[Coke]> I don't think it's written down anywhere. I'll make a note that we need to write something up about version numbers at the SPW if it's not done already.

[18:56] <PerlJam> [Coke]++

[18:57] <DrForr> I wasn't expecting a formal spec, I was just looking at 'ok $*PERL.version > 5.006001' and wondering if there was going t be something ordered.

[18:57] <DrForr> Wish I could make it, but my flights are already booked for YAPC. Had I know, I would have requested a few more days off.

[18:58] * PerlJam is still not entirely sure what $*PERL.version *means*

[18:59] <DrForr> m say $*PERL.version

[18:59] <DrForr> m: say $*PERL.version

[18:59] <GLRelia> rakudo-moar 3e7cfc: OUTPUT«v6.Advent␤»

[18:59] <camelia> rakudo-moar 93418e: OUTPUT«v6.Advent␤»

[18:59] <dha> m: say $*PERL

[18:59] <camelia> rakudo-moar 93418e: OUTPUT«Perl 6 (6.Advent)␤»

[18:59] <GLRelia> rakudo-moar 3e7cfc: OUTPUT«Perl 6 (6.Advent)␤»

[19:00] <[Coke]> there's a version of the spec, and a version of the compiler.

[19:00] <[Coke]> pretty sure .Advent is referring to the spec.

[19:01] <DrForr> Makes sense.

[19:03] <laben> m: my @a = 1..3; my @b = 4..6; my @c = @a, @b; dd @c

[19:03] <camelia> rakudo-moar 93418e: OUTPUT«@c = [1, 2, 3, 4, 5, 6]<>␤»

[19:03] <GLRelia> rakudo-moar 3e7cfc: OUTPUT«@c = [$[1, 2, 3], $[4, 5, 6]]␤»

[19:04] <laben> m: my @a = 1..3; my @b = 4..6; my @c = flat @a, @b; dd @c

[19:04] <camelia> rakudo-moar 93418e: OUTPUT«@c = [1, 2, 3, 4, 5, 6]<>␤»

[19:04] <GLRelia> rakudo-moar 3e7cfc: OUTPUT«@c = [1, 2, 3, 4, 5, 6]␤»

[19:06] <nine> .tell jnthn what is .flat actually supposed to mean? Array has a flat method that does Seq.new(self.iterator) while inheriting .iterator from List. List itself on the other hand does not use its own iterator for .flat and inherits Iterable's instead.

[19:06] <yoleaux> nine: I'll pass your message to jnthn.

[19:07] *** zakharyas joined
[19:09] *** araujo joined
[19:09] *** araujo left
[19:09] *** araujo joined
[19:13] *** domidumont left
[19:21] <dalek> rakudo/glr: 0f328b2 | (Stefan Seifert)++ | src/core/metaops.pm:

[19:21] <dalek> rakudo/glr: Fix hypers on lazy/infinite lists and iterators

[19:21] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/0f328b2c66

[19:22] *** yqt joined
[19:23] *** bin_005 joined
[19:24] <masak> 'night, #perl6

[19:24] <moritz> \o masak

[19:24] <moritz> m: say [**] 2, 3

[19:24] <camelia> rakudo-moar 93418e: OUTPUT«8␤»

[19:24] <GLRelia> rakudo-moar 3e7cfc: OUTPUT«␤The 'gimme' method was an internal method used by rakudo before the Great␤List Refactor.  The fact that you are seeing this message, means that you␤have code that was using that unsupported rakudo internal API.␤␤Please refactor this code using t…»

[19:25] <colomon> whoops

[19:25] <moritz> just a NYI

[19:25] <colomon> moritz: NYF

[19:25] <moritz> a 'git grep gimme' shows some more cases

[19:26] <colomon> or NYG  :)

[19:26] <moritz> NYGLR'd :-)

[19:27] * [Coke] wonders how many people in #perl6 use git grep instead of ack

[19:28] * colomon has never gotten used to git grep

[19:28] * colomon also frequently acks things not in git.  :)

[19:29] <moritz> colomon: it's very handy for largish projects that also create largish caches that 'ack' searches through by default

[19:29] <lucasb> Is it realistic to expect to ship GLR in august? Seems there's still lots of work to do...

[19:30] <moritz> lucasb: uhm, no.

[19:30] <moritz> I mean, release date is tomorrow, right?

[19:30] <[Coke]> moritz: the -default- release date is tomorrow.

[19:30] <lucasb> people were talking about relaxing the third tuesday/thursday rule, wasn't it?

[19:30] <laben> panda is a mess right now

[19:31] <laben> i fixed up the installer, but builder and tester are still KO

[19:33] <moritz> if there's a release tomorrow, it'll be a nom release, not a GLR release

[19:33] <dalek> rakudo/glr: 1e870ba | (Stefan Seifert)++ | src/core/metaops.pm:

[19:33] <dalek> rakudo/glr: Move HYPER for Associative to avoid confusion with Iterable

[19:33] <dalek> rakudo/glr: 

[19:33] <dalek> rakudo/glr: Hashes are Iterable and Associative. Need to move the HYPER multi candidates

[19:33] <dalek> rakudo/glr: for Associative before the ones for Iterable to give them a chance to actually

[19:33] <dalek> rakudo/glr: run.

[19:33] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/1e870ba8c5

[19:38] <moritz> nine++ # GLR hacking

[19:42] <moritz> m: 'abc' ~~ /(.)+/; say $/.caps

[19:42] <camelia> rakudo-moar 93418e: OUTPUT«0 => ｢a｣ 0 => ｢b｣ 0 => ｢c｣␤»

[19:42] <GLRelia> rakudo-moar 1e870b: OUTPUT«0 => ｢a｣ 0 => ｢b｣ 0 => ｢c｣␤»

[19:42] <moritz> m: 'abc' ~~ /(.)+/; say $/.caps[1]

[19:42] <camelia> rakudo-moar 93418e: OUTPUT«0 => ｢b｣␤»

[19:42] <GLRelia> rakudo-moar 1e870b: OUTPUT«0 => ｢b｣␤»

[19:43] <moritz> m: 'abc' ~~ /(.)+/; say $/.caps.^name

[19:43] <camelia> rakudo-moar 93418e: OUTPUT«Parcel␤»

[19:43] <GLRelia> rakudo-moar 1e870b: OUTPUT«Seq␤»

[19:43] <moritz> is Seq the right thing to return? Or should it be List?

[19:44] *** llfourn joined
[19:44] <nine> So many methods return Seq now

[19:45] <moritz> one would hope for a nice way to test for Positional|PositionalBindFailover

[19:48] *** llfourn left
[19:49] <laben> nine: when i somehow get a Seq (in Perl6), what is the usual line to avoid the seq-already-consumed error?

[19:49] <dalek> roast/glr: 1d0069f | moritz++ | S05-capture/caps.t:

[19:49] <dalek> roast/glr: Test that Match.caps and .chunks returns something Iterable

[19:49] <dalek> roast/glr: review: https://github.com/perl6/roast/commit/1d0069f813

[19:49] <nine> laben: you can .List it

[19:49] <moritz> laben: assign to an array first, or store it's .list

[19:49] <nine> laben: It's been a while since I've seen one however.

[19:50] <moritz> m: my \g = gather { take 1; take 2 }; say g; say g

[19:50] <camelia> rakudo-moar 93418e: OUTPUT«1 2␤1 2␤»

[19:50] <GLRelia> rakudo-moar 1e870b: OUTPUT«1 2␤1 2␤»

[19:50] <moritz> huh.

[19:50] <moritz> m: my \g = gather { take 1; take 2 }; say g.^name

[19:50] <camelia> rakudo-moar 93418e: OUTPUT«List␤»

[19:50] <GLRelia> rakudo-moar 1e870b: OUTPUT«Seq␤»

[19:50] <moritz> that's a Seq; why was I able to consume it twice?

[19:51] <PerlJam> you didn't use an iterator with say

[19:52] <moritz> m: my \g = gather { take 1; take 2 }; say for g; say for g;

[19:52] <camelia> rakudo-moar 93418e: OUTPUT«5===SORRY!5=== Error while compiling /tmp/wFdqAX6ePC␤Unsupported use of bare "say"; in Perl 6 please use .say if you meant $_, or use an explicit invocant or argument␤at /tmp/wFdqAX6ePC:1␤------> 3my \g = gather { take 1; take 2 }; say7⏏5 fo…»

[19:52] <GLRelia> rakudo-moar 1e870b: OUTPUT«5===SORRY!5=== Error while compiling /tmp/PU4412sPpJ␤Unsupported use of bare "say"; in Perl 6 please use .say if you meant $_, or use an explicit invocant or argument␤at /tmp/PU4412sPpJ:1␤------> 3my \g = gather { take 1; take 2 }; say7⏏5 fo…»

[19:52] <moritz> m: my \g = gather { take 1; take 2 }; .say for g; .say for g;

[19:52] <camelia> rakudo-moar 93418e: OUTPUT«1␤2␤1␤2␤»

[19:52] <GLRelia> rakudo-moar 1e870b: OUTPUT«1␤2␤This Seq has already been iterated, and its values consumed␤  in block <unit> at /tmp/JrsODPlCPJ:1␤␤»

[19:52] <laben> nine: i was retesting File::Find without my changes on your latest commit and it gave me that error. fortunately my change fixes it anyway

[19:57] <DrForr> nine: perl6 'use PPI:from<Perl5>; PPI::Document.new()' - PPI::Document isn't loaded in Perl6. It's not bad as I can add 'use PPI::Document:from<Perl5>;', just thought you should know.

[20:01] <nine> DrForr: yes, that's a shortcut I took. I don't even look at which packages are actually loaded. I just create a package for the name in the use line.

[20:03] <DrForr> No worries. I understand that's a bit too dynamic to pull in.

[20:04] <DrForr> The tool's making the test suite conversion simple so far.

[20:05] *** rangerprice joined
[20:05] <rangerprice> Hi

[20:06] <nine> DrForr: oh, I think it's actually possible.

[20:08] <DrForr> Cool. I note in passing that the error is a bit obsure, but there's nothing for you to worry about on that.

[20:12] <dalek> roast/glr: c191630 | moritz++ | S02-types/nested_arrays.t:

[20:12] <dalek> roast/glr: Fix some element numbers in nested_arrays.t

[20:12] <dalek> roast/glr: review: https://github.com/perl6/roast/commit/c191630fcc

[20:12] <moritz> enough hacking for tonight

[20:12] <moritz> TTFN folks

[20:14] *** darutoko left
[20:15] <dalek> rakudo/glr: 59be37a | (Stefan Seifert)++ | src/core/metaops.pm:

[20:15] <dalek> rakudo/glr: Fix infix hypers on Hashes

[20:15] <dalek> rakudo/glr: 

[20:15] <dalek> rakudo/glr: Allows 90 % of the hyper tests to pass now.

[20:15] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/59be37a6a8

[20:16] *** colomon left
[20:20] *** rurban_ left
[20:21] <nine> The day ends at 210/1047 spec test files failing

[20:22] <nine> Nice improvement from the 270 it was two days ago :)

[20:23] <DrForr> This, however... WARNING unhandled Failure detected in DESTROY: No such symbol 'Scalar::Util'

[20:31] *** lucasb left
[20:36] <DrForr> nine: I think I done gone and broke something deep :)

[20:37] <nine> DrForr: no, I've seen such errors. And fixed them. Can you golf it down?

[20:38] *** llfourn joined
[20:38] <DrForr> Well, it looks like a memory leak, so it's sporadic.

[20:39] <DrForr> And I've got to get to bed here. I'll send you the file in a gist. It *does* generate perl6 errors, so it's not necessarily going to compile.

[20:40] *** colomon joined
[20:41] <nine> DrForr: no, no, those errors just appear sporadic but have quite mundane causes

[20:41] *** rurban left
[20:41] <nine> DrForr: if it depends or not just depends on MoarVM's garbage collector

[20:43] *** llfourn left
[20:43] *** rindolf left
[20:43] *** zakharyas left
[20:43] *** diana_olhovik_ left
[20:45] <nine> DrForr: it may happen when a method is called on a package but Inline::Perl5 expects an object. I've had such bugs in ->can

[20:47] <DrForr> Yeah, it feels like a GC bug. I point out that it's got some 'undeclared routines' that will trip, but the DESTROY is the problem.

[20:48] *** Averna joined
[20:48] *** skids joined
[20:49] <DrForr> I'm guessing that perl6-valgrind will trip the error reliably, but I'm on a laptop in a VM...

[20:52] <vendethiel> DrForr: https://github.com/niner/Inline-Perl5/issues/38 could you edit the markdown :)?

[20:54] *** muraiki joined
[20:54] <DrForr> If someone can tell me how to do block formatting...

[20:54] <vendethiel> ```blabla```

[20:55] <DrForr> Yeah, just saw that.

[20:56] <DrForr> Still broken...

[20:58] <vendethiel> DrForr: I don't see a ``` before your code

[20:58] <laben> m: my @a = (1..3)>>.succ; for @a {.say;}

[20:58] <camelia> rakudo-moar 93418e: OUTPUT«2␤3␤4␤»

[20:58] <GLRelia> rakudo-moar 59be37: ( no output )

[20:59] <vendethiel> DrForr++

[20:59] <laben> why doesn't this work with >> but does with map?

[20:59] <laben> m: my @a = (1..3).map(*.succ); for @a {.say;}

[20:59] <camelia> rakudo-moar 93418e: OUTPUT«2␤3␤4␤»

[20:59] <GLRelia> rakudo-moar 59be37: OUTPUT«2␤3␤4␤»

[20:59] <laben> just a NYI or intentional?

[21:00] <DrForr> https://github.com/niner/Inline-Perl5/issues/39

[21:00] <DrForr> ``` has to be on its own line, apparently.

[21:02] *** xfix left
[21:06] <jdv79> amazing wht env can do to mood

[21:07] <jdv79> istanbul - heat wave and shity beer = unhappier jdv

[21:07] <DrForr> You're in Istanbul? I'm thinking of going there in October.

[21:07] <jdv79> bamberg - decent beer and its almost too cold to wear shorts and a t-shirt - wow

[21:07] <jdv79> i was

[21:08] <DrForr> Past tense. Nice. What did you think, aside from the beer and heat?

[21:09] <jdv79> i would like to do it in better weathr

[21:09] <jdv79> it was cool

[21:10] <dalek> perl6-roast-data: f26d75e | coke++ | / (2 files):

[21:10] <dalek> perl6-roast-data: redo today's glr run. progress!

[21:10] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/f26d75e5bc

[21:10] * jdv79 is surpringly upbeat

[21:10] <tadzik> heh, klasyk

[21:10] <tadzik> ww

[21:11] *** kaare_ left
[21:11] <[Coke]> m: say 111730-112240 # that many more passing tests in a few hours.

[21:11] <camelia> rakudo-moar 93418e: OUTPUT«-510␤»

[21:11] <GLRelia> rakudo-moar 59be37: OUTPUT«-510␤»

[21:11] <[Coke]> er, reverse that!

[21:12] <jdv79> [Coke]: spw? ::EU?

[21:14] *** colomon left
[21:17] *** dha left
[21:23] <[Coke]>  swiss perl workshop

[21:24] <[Coke]> http://act.perl-workshop.ch/spw2015/

[21:24] <dalek> rakudo/glr: 7880bb8 | PerlJam++ | src/core/ (2 files):

[21:24] <dalek> rakudo/glr: Restore suggestions for unknown symbols.

[21:24] <dalek> rakudo/glr: 

[21:24] <dalek> rakudo/glr: Something is getting passed to .join that is not a Str, nor can we

[21:24] <dalek> rakudo/glr: call a .Str method on it, but we can box it as a Str.

[21:24] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/7880bb83d7

[21:26] *** bin_005_r joined
[21:27] *** bin_005 left
[21:29] <laben> Panda::Builder fixed, 1 character change that took like 4 hours to do...

[21:29] *** figitaki joined
[21:30] *** figitaki left
[21:33] *** colomon joined
[21:37] *** muraiki left
[21:39] <RabidGravy> :)

[21:40] *** Averna left
[21:53] *** TEttinger joined
[22:00] <timotimo> huh!

[22:01] <timotimo> that seems so wrong ... push_s is most probably going to unbox_s the boxed string again

[22:01] <leont> I have a hash of Match, how can I *elegantly* transform that into a hash of Int?

[22:02] <timotimo> what part of the match do you want to use as the Int?

[22:03] <timotimo> oh, you mean the match was from something like \d ?

[22:03] <leont> Yeah

[22:03] <timotimo> right

[22:03] <timotimo> deepmap ought to DTRT with hashes, like hyper method calls

[22:03] <leont> I mean, I can think of plenty of non-elegant ways, but this should be easy

[22:04] <timotimo> m: my %foo = "hello", ("123" ~~ / \d+ /), "goodbye" ("hey 444" ~~ / \d+ /); say %foo.perl

[22:04] <camelia> rakudo-moar 93418e: OUTPUT«5===SORRY!5=== Error while compiling /tmp/KI5TQkDemL␤Two terms in a row␤at /tmp/KI5TQkDemL:1␤------> 3= "hello", ("123" ~~ / \d+ /), "goodbye"7⏏5 ("hey 444" ~~ / \d+ /); say %foo.perl␤    expecting any of:␤        infix␤        infix …»

[22:04] <GLRelia> rakudo-moar 7880bb: OUTPUT«5===SORRY!5=== Error while compiling /tmp/r3vhnzSRWZ␤Two terms in a row␤at /tmp/r3vhnzSRWZ:1␤------> 3= "hello", ("123" ~~ / \d+ /), "goodbye"7⏏5 ("hey 444" ~~ / \d+ /); say %foo.perl␤    expecting any of:␤        infix␤        infix …»

[22:04] <timotimo> m: my %foo = "hello", ("123" ~~ / \d+ /), "goodbye", ("hey 444" ~~ / \d+ /); say %foo.perl

[22:04] <camelia> rakudo-moar 93418e: OUTPUT«{:goodbye(Match.new(ast => Any, list => (), hash => EnumMap.new(), orig => "hey 444", to => 7, from => 4)), :hello(Match.new(ast => Any, list => (), hash => EnumMap.new(), orig => "123", to => 3, from => 0))}<>␤»

[22:04] <GLRelia> rakudo-moar 7880bb: OUTPUT«{:goodbye(Match.new(ast => Any, list => (), hash => EnumMap.new(), orig => "hey 444", to => 7, from => 4)), :hello(Match.new(ast => Any, list => (), hash => EnumMap.new(), orig => "123", to => 3, from => 0))}␤»

[22:04] <timotimo> m: my %foo = "hello", ("123" ~~ / \d+ /), "goodbye", ("hey 444" ~~ / \d+ /); say %foo>>.Int.perl

[22:04] <camelia> rakudo-moar 93418e: OUTPUT«{:goodbye(444), :hello(123)}<>␤»

[22:04] <GLRelia> rakudo-moar 7880bb: OUTPUT«{}␤»

[22:04] <timotimo> but i think hyperops are a bit b0rken on GLR right now

[22:04] <timotimo> looks kind of like somewhere there's a "eagerify this list" missing inside hyper or deepmap or something

[22:05] * leont isn't on glr yet

[22:05] <laben> m: sub foo() { my $f = False; :$f}; my (:$f) = foo(); $f.say; if $f { say "Not Falsey" } else { say "Falsey" }

[22:05] <camelia> rakudo-moar 93418e: OUTPUT«f => False␤Not Falsey␤»

[22:05] <GLRelia> rakudo-moar 7880bb: OUTPUT«f => False␤Not Falsey␤»

[22:07] <leont> timotimo++

[22:07] <laben> i think i... fixed Panda::Tester, but the last thing i changed... i dunno how it ever worked?!

[22:07] <timotimo> you're welcome :)

[22:08] <laben> has the return-as-named-param always constructed a Pair?

[22:10] <timotimo> star: sub test() { my $f = False; :$f); say test.perl

[22:10] *** GLRelia left
[22:10] <camelia> star-m 2015.03: OUTPUT«5===SORRY!5=== Error while compiling /tmp/hT2YFx9omu␤Unable to parse expression in block; couldn't find final '}' ␤at /tmp/hT2YFx9omu:1␤------> 3sub test() { my $f = False; :$f7⏏5); say test.perl␤    expecting any of:␤        statement end…»

[22:10] <timotimo> yikes! what did i do to glrelia? :(

[22:11] <timotimo> star: sub test() { my $f = False; :$f }; say test.perl

[22:11] <camelia> star-m 2015.03: OUTPUT«"f" => Bool::False␤»

[22:11] <timotimo> star: sub test() { my $f = False; return :$f }; say test.perl

[22:11] <camelia> star-m 2015.03: OUTPUT«"f" => Mu␤»

[22:11] <timotimo> ... what

[22:11] <laben> i dont think glrelia has star dist

[22:11] <vendethiel> timotimo: probably didn't like star

[22:11] <timotimo> m: sub test() { my $f = False; return :$f }; say test.perl

[22:11] <camelia> rakudo-moar 93418e: OUTPUT«:f(Mu)␤»

[22:11] *** GLRelia joined
[22:11] <timotimo> ... what?

[22:12] <GLRelia> star-m : OUTPUT«Can't chdir to '/home/steve/star/': No such file or directory at lib/EvalbotExecuter.pm line 171.␤      EvalbotExecuter::_auto_execute(HASH(0x253db90), "sub test() { my \$f = False; :\$f); say test.perl", GLOB(0x2824208), "/tmp/aAnBxthDkm", "star-m") called at lib/Evalb…»

[22:12] <laben> oh, she's back

[22:13] <laben> m: sub foo() { my $f = False; :$f}; foo.perl.say

[22:13] <GLRelia> rakudo-moar 7880bb: OUTPUT«:!f␤»

[22:13] <camelia> rakudo-moar 93418e: OUTPUT«:!f␤»

[22:13] <laben> m: sub foo() { my $f = False; :$f}; dd foo()

[22:13] <GLRelia> rakudo-moar 7880bb: OUTPUT«:!f␤»

[22:13] <camelia> rakudo-moar 93418e: OUTPUT«:!f␤»

[22:13] *** TEttinger left
[22:13] <laben> m: sub foo() { my $f = False; :$f}; my (:$a) = foo(); $a.perl.say

[22:13] <GLRelia> rakudo-moar 7880bb: OUTPUT«:!f␤»

[22:13] <camelia> rakudo-moar 93418e: OUTPUT«:!f␤»

[22:14] <laben> m: sub foo() { my $f = False; :$f}; my (:$a) = foo(); $a.say;

[22:14] <GLRelia> rakudo-moar 7880bb: OUTPUT«f => False␤»

[22:14] <camelia> rakudo-moar 93418e: OUTPUT«f => False␤»

[22:14] <laben> m: sub foo() { my $f = False; return :$f}; my (:$a) = foo(); $a.say;

[22:14] <GLRelia> rakudo-moar 7880bb: OUTPUT«f => (Mu)␤»

[22:14] <camelia> rakudo-moar 93418e: OUTPUT«f => (Mu)␤»

[22:14] <laben> oh my

[22:14] <laben> m: sub foo() { my $f = False; return :$f;}; my (:$a) = foo(); $a.say;

[22:14] <GLRelia> rakudo-moar 7880bb: OUTPUT«f => (Mu)␤»

[22:14] <camelia> rakudo-moar 93418e: OUTPUT«f => (Mu)␤»

[22:15] <laben> m: sub foo() { my $f = False; :$f}; my (:$a) = foo(); $a.value.say

[22:15] <GLRelia> rakudo-moar 7880bb: OUTPUT«False␤»

[22:15] <camelia> rakudo-moar 93418e: OUTPUT«False␤»

[22:16] <laben> ... anyway i got panda working over glr. this is after having patched File::Find and Shell::Command, while JSON::Tiny has the changes already pushed to git

[22:16] <timotimo> very cool :)

[22:17] <laben> the last thing is making (re)bootstrap work i think

[22:17] <laben> for now, ufo saved my life

[22:19] *** RabidGravy left
[22:19] *** Averna joined
[22:20] <laben> it's getting late over here, i guess i'll publish the patches on gist. the rest if for tomorrow and later on

[22:20] <timotimo> thank you for your hard work!

[22:22] <laben> this is for File::Find https://gist.github.com/b47ed8bfb11ea001c23a

[22:23] *** bin_005_r left
[22:24] <laben> this is for Shell::Command https://gist.github.com/71682f09109a5169e5d5

[22:26] <timotimo> ideally, hyper-methodcall would be fixed instead of having to turn >>. into .map(*. )

[22:29] <laben> the last one is for the branch 'glr' of Panda https://gist.github.com/0935bf0a54ce50685f93

[22:30] <laben> timotimo: possible yeah, but the panda ones are different and possibly wont change even after fixing up rakudo/glr

[22:30] <laben> m: my @a = (1..3)>>.succ; for @a {.say}

[22:30] <GLRelia> rakudo-moar 7880bb: ( no output )

[22:30] <camelia> rakudo-moar 93418e: OUTPUT«2␤3␤4␤»

[22:30] <laben> m: my @a = (1..3).map(*.succ); for @a {.say}

[22:30] <GLRelia> rakudo-moar 7880bb: OUTPUT«2␤3␤4␤»

[22:30] <camelia> rakudo-moar 93418e: OUTPUT«2␤3␤4␤»

[22:30] <laben> see what happened? >> did not work there

[22:31] <laben> not sure if intentional or NYI

[22:32] <laben> truthfully speaking, the strange one is the File::Find one, but im not gonna dig deeper, since i dont know enough about rakudo to check that out

[22:37] *** leont left
[22:37] <laben> better republish the ufo one too, still backwards compatible but better conceptually https://gist.github.com/bfac93f00649f1609ec2

[22:38] <laben> with this, good night or good hacking #perl6

[22:38] <timotimo> >> not working there is definitely not intentional

[22:39] *** llfourn joined
[22:42] <timotimo> mhhh, this cat is getting cuddled something fierce

[22:43] *** llfourn left
[22:44] *** yqt left
[22:48] *** virtualsue left
[22:49] <timotimo> i wanted to stop cuddling the cat and went to wash my hands, now i'm back and the cat is requesting, nay demanding more cuddles

[22:52] *** krakan joined
[23:01] *** danaj joined
[23:06] *** telex left
[23:08] *** telex joined
[23:24] <rangerprice> I'm happy on my Arch Linux distribution

[23:25] *** SHODAN joined
[23:25] <rangerprice> Everybody that use Windows 10 should read this: https://i.imgur.com/Gu6bBV1.png

[23:27] <timotimo> i wouldn't expect anybody who uses windows seriously to take this text seriously

[23:29] <tadzik> I don't expect anyone serious to take it seriously either :)

[23:29] <flussence> stale copypasta is stale

[23:30] <tadzik> I even have a weechat script for that

[23:30] <tadzik> but it's very spammy, obvioustly, so I'll resist now

[23:30] <flussence> heh :)

[23:34] <timotimo> did anybody try zef yet? with the glr branch?

[23:35] <timotimo> ugexe: any words about glr support?

[23:35] <timotimo> i see you have a one-line-change commit in zef that is explicitly related to glr

[23:35] <timotimo> does that mean everything else already works?

[23:35] *** spider-mario left
[23:44] <timotimo> m: reat { }

[23:44] <GLRelia> rakudo-moar 7880bb: OUTPUT«5===SORRY!5=== Error while compiling /tmp/pgPbvBrTTD␤Undeclared routine:␤    reat used at line 1␤␤»

[23:44] <camelia> rakudo-moar 93418e: OUTPUT«5===SORRY!5=== Error while compiling /tmp/UelTK9goTN␤Undeclared routine:␤    reat used at line 1␤␤»

[23:44] <timotimo> m: react { }

[23:44] <GLRelia> rakudo-moar 7880bb: OUTPUT«5===SORRY!5=== Error while compiling /tmp/8rsQHD9G0b␤Undeclared routine:␤    react used at line 1␤␤»

[23:44] <camelia> rakudo-moar 93418e: OUTPUT«5===SORRY!5=== Error while compiling /tmp/yB1nhMv2Kn␤Undeclared routine:␤    react used at line 1␤␤»

[23:44] <timotimo> m: supply { }

[23:44] <GLRelia> rakudo-moar 7880bb: OUTPUT«5===SORRY!5=== Error while compiling /tmp/_Vvk22BQdr␤Undeclared routine:␤    supply used at line 1␤␤»

[23:44] <camelia> rakudo-moar 93418e: OUTPUT«5===SORRY!5=== Error while compiling /tmp/XjrpeVI4_r␤Undeclared routine:␤    supply used at line 1␤␤»

[23:45] <timotimo> didn't that get merged?

[23:45] <timotimo> m: say &REACT

[23:45] <GLRelia> rakudo-moar 7880bb: OUTPUT«5===SORRY!5=== Error while compiling /tmp/0Uevs4_7WK␤Undeclared routine:␤    &REACT used at line 1␤␤»

[23:45] <camelia> rakudo-moar 93418e: OUTPUT«5===SORRY!5=== Error while compiling /tmp/60vuqyXA6i␤Undeclared routine:␤    &REACT used at line 1␤␤»

[23:46] <timotimo> the version of rakudo on camelia is kind of old

[23:56] *** BenGoldberg joined
[23:57] <timotimo> http://doc.perl6.org/type-basic.html - huh?

[23:58] <labster> We only have advanced types?

[23:58] <timotimo> probably

