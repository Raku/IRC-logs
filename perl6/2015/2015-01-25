[00:00] <Kristien> Is there a nicer way to do the for loop?

[00:00] <Kristien> Couldn't find an each function or something like that

[00:00] <masak> map?

[00:01] <Kristien> map is lazy

[00:01] <Kristien> AFAIK

[00:01] <masak> troo

[00:01] <masak> but you're feeding things into it, so that shouldn't be a problem, I think.

[00:02] <vendethiel> m: : 1..* Z @lines ==> map { "$^i: $^l" } ==> map(&say);

[00:02] <camelia> rakudo-moar f12020: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/CkJoJ8iYDB␤Invocant colon not allowed here␤at /tmp/CkJoJ8iYDB:1␤------> [32m:[33m⏏[31m 1..* Z @lines ==> map { "$^i: $^l" } ==[0m␤»

[00:02] <Kristien> m: sub each(&f, @xs) { for @xs { &f($_) } }; each (1, 2, 3, 4, 5), &say

[00:02] <camelia> rakudo-moar f12020: OUTPUT«Type check failed in binding &f; expected 'Callable' but got 'Parcel'␤  in sub each at /tmp/bboYqen_J_:1␤  in block <unit> at /tmp/bboYqen_J_:1␤␤»

[00:02] <Kristien> m: sub each(&f, @xs) { for @xs { &f($_) } }; each &say, (1, 2, 3, 4, 5)

[00:02] <camelia> rakudo-moar f12020: OUTPUT«1␤2␤3␤4␤5␤»

[00:02] <vendethiel> m: : 1..* Z @lines ==> map { "$^i: $^l" } ==> each(&say);

[00:02] <camelia> rakudo-moar f12020: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/uWM3fyBizI␤Invocant colon not allowed here␤at /tmp/uWM3fyBizI:1␤------> [32m:[33m⏏[31m 1..* Z @lines ==> map { "$^i: $^l" } ==[0m␤»

[00:02] <Kristien> m: map &say, (1, 2, 3, 4, 5)

[00:02] <camelia> rakudo-moar f12020: OUTPUT«1␤2␤3␤4␤5␤»

[00:02] <vendethiel> m: 1..* Z @lines ==> map { "$^i: $^l" } ==> each(&say);

[00:02] <camelia> rakudo-moar f12020: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/t3qGX7Nwwy␤Variable '@lines' is not declared. Did you mean '&lines'?␤at /tmp/t3qGX7Nwwy:1␤------> [32m1..* Z @lines[33m⏏[31m ==> map { "$^i: $^l" } ==> each(&say);[0m␤    expecting any…»

[00:02] <Kristien> well it only shows that because I force it to print the result of say

[00:02] <Kristien> how about

[00:02] <vendethiel> m: 1..* Z <a b c> ==> map { "$^i: $^l" } ==> each(&say);

[00:02] <camelia> rakudo-moar f12020: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/QrAAdolFhD␤Undeclared routine:␤    each used at line 1␤␤»

[00:03] <vendethiel> oh,yes, you declared it

[00:03] <vendethiel> Kristien: sink()

[00:03] <Kristien> m: sub ignore(Any $x) { }; ignore(map(&say, (1, 2, 3, 4, 5)))

[00:03] <camelia> rakudo-moar f12020: ( no output )

[00:03] <vendethiel> which is like ml's sink

[00:03] <vendethiel> m: 1..* Z <a b c> ==> map { "$^i: $^l" } ==> map(&say);

[00:03] <camelia> rakudo-moar f12020: OUTPUT«1: a␤2: b␤3: c␤»

[00:03] <vendethiel> this works though

[00:04] <Kristien> no

[00:04] <Kristien> it only works in this case because the output of map is iterated over

[00:04] <Kristien> I need eager map which returns Nil

[00:04] *** dayangkun left
[00:05] <vendethiel> m: 1..* Z <a b c> ==> map { "$^i: $^l" } ==> map(&say); 1

[00:05] <camelia> rakudo-moar f12020: OUTPUT«1: a␤2: b␤3: c␤»

[00:05] <Kristien> but sink should work

[00:06] <Kristien> m: my @lines = "Hello", "World"; sink { 1..* Z @lines ==> map { "$^i: $^l" } ==> map &say };

[00:06] <camelia> rakudo-moar f12020: OUTPUT«1: Hello␤2: World␤»

[00:09] <Kristien> Dankeschön!

[00:10] *** espadrine_ left
[00:14] <Kristien> I like sub each(&f, @xs) { for @xs { &f($_) } } better, though.

[00:14] <Kristien> Plays nicely with ==>.

[00:15] <Kristien> I guess sink is implicit when an expression is used as a statement in non-return position?

[00:16] <masak> aye

[00:18] <Kristien> When a good Perl 6 book comes out I'll be the first one to buy a copy!

[00:19] <masak> "a good Perl 6 book" might be our biggest weakness... :/

[00:20] <masak> we tried to do it as a community effort once, and ran into difficulties.

[00:30] *** zakharyas left
[00:35] <Kristien> Methods like join and uc seem to be callable without .

[00:35] <Kristien> m: say(join(' ', <1 2 3>))

[00:35] <camelia> rakudo-moar f12020: OUTPUT«1 2 3␤»

[00:36] <Kristien> however, I can only find documentation of methods

[00:36] <Kristien> Is this special behaviour for method calls or am I overlooking something?

[00:39] <Kristien> m: say(<1 2 3>.join(' '))

[00:39] <camelia> rakudo-moar f12020: OUTPUT«1 2 3␤»

[00:39] <vendethiel> Kristien: it's there if you put the "is export" on the method, IIRC

[00:39] <vendethiel> m: class Foo { method bar is export { 1 } }; bar(Foo.new);

[00:39] <camelia> rakudo-moar f12020: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/RFlM_J46TP␤Undeclared routine:␤    bar used at line 1. Did you mean 'bag'?␤␤»

[00:39] <vendethiel> no, so, probably just declared below.

[00:39] <vendethiel> (I know what is export does, but I thought it also did that)

[00:39] <Kristien> > Methods also take the "is export" trait: the method will then be exported as a multi sub that takes the object as the first parameter:

[00:40] <vendethiel> right :-)

[00:44] <masak> I don't know if that's supposed to work or not, but I can say this:

[00:45] <masak> the notion that the sub form of built-in methods are an exported form of the method in Perl 6 has been replaced by other things.

[00:46] <masak> usually, the sub is just defined in the setting, and calls the corresponding method.

[00:47] <Kristien> m: class Foo { method bar is export { 1 } }; import Foo; say bar(Foo.new);

[00:47] <camelia> rakudo-moar f12020: OUTPUT«1␤»

[00:47] <vendethiel> Kristien++ # smarter than me

[00:47] <masak> hey, it works :)

[00:47] <Kristien> :D

[00:48] <masak> what I said still holds true, though.

[00:48] <masak> I don't end up exporting methods a lot.

[00:48] <masak> IIRC, even Perl 5 lore considers it a Bad Thing.

[00:51] <Kristien> This is also interesting:

[00:51] <Kristien> This works:

[00:51] <Kristien> m: sub filter-profanity(Str $s) { $s.subst(/Java/, '****', :g) }; "Perl 6 is so much more fun than Java!" ==> filter-profanity() ==> uc() ==> say()

[00:51] <camelia> rakudo-moar f12020: OUTPUT«PERL 6 IS SO MUCH MORE FUN THAN ****!␤»

[00:51] <Kristien> whereas this fails:

[00:51] <Kristien> m: sub filter-profanity(Str $s) { $s.subst(/Java/, '****', :g) }; "Perl 6 is so much more fun than Java!" ==> filter-profanity ==> uc ==> say

[00:51] <camelia> rakudo-moar f12020: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/71EN2a_iYq␤Preceding context expects a term, but found infix ==> instead␤at /tmp/71EN2a_iYq:1␤------> [32mfun than Java!" ==> filter-profanity ==>[33m⏏[31m uc ==> say[0m␤»

[00:51] *** agentzh joined
[00:52] <vendethiel> Kristien: you currently need () after a call inside a ==>

[00:52] <vendethiel> m: 'a' ==> say

[00:52] <camelia> rakudo-moar f12020: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/Eod2xKzdcT␤Unsupported use of bare 'say'; in Perl 6 please use .say if you meant $_, or use an explicit invocant or argument␤at /tmp/Eod2xKzdcT:1␤------> [32m'a' ==> say[33m⏏[31m<EOL>[0m…»

[00:53] <vendethiel> m: 'a' ==> say()

[00:53] <camelia> rakudo-moar f12020: OUTPUT«a␤»

[00:53] <Kristien> "currently" so will it not stay that way?

[00:53] <vendethiel> well, it works in std

[00:53] <vendethiel> std: 'a' ==> say

[00:53] <camelia> std f9b7f55: OUTPUT«[31m===[0mSORRY![31m===[0m␤Unsupported use of bare 'say'; in Perl 6 please use .say if you meant $_, or use an explicit invocant or argument at /tmp/AWH6U6dwVw line 1:␤------> [32m'a' ==> say[33m⏏[31m<EOL>[0m␤Check failed␤FAILED 00:00 134m␤»

[00:53] <vendethiel> TimToady: can you confirm that's a STD bug?

[00:53] <vendethiel> or maybe masak++ can find the RT ticket associated to this one

[00:53] <Kristien> ==> is most shiny. |> was my favourite feature in LiveScript and F#

[00:54] <vendethiel> we completly and utterly stole it from f#, yes :P

[00:54] <Kristien> I wonder if Arabs like normal calls better. :)

[00:54] <vendethiel> I think elixir did that as well

[00:54] <Kristien> In Elixir x |> f(1) is sugar for f(x, 1)

[00:55] <Kristien> In LiveScript and F# it's sugar for f(1) x

[00:55] <Kristien> Well in F# it's slightly different

[00:55] <TimToady> well, we're still trying to figure out what feed operators are

[00:55] <Kristien> in F# it's sugar for let __1 = x; f(1) x

[00:55] <Kristien> because of order of evaluation being LTR always

[00:55] <TimToady> and we certainly didn't steal it from F#

[00:56] <Kristien> uh s/x$/__1/

[00:56] <TimToady> it's really just the idea of Unix pipes that can transmit objects, is all

[00:56] <TimToady> I think we thought of it before PowerShell

[00:56] <Kristien> Joe the Plumber is proud.

[00:57] <vendethiel> TimToady: sorry, my "we" was from LiveScript ;-)

[00:57] <TimToady> as for join, that can't be done by 'is export' because the order of arguments is different

[00:57] <TimToady> ok

[00:58] <vendethiel> Kristien: I'd certainly like f# better with more curry

[00:58] <Kristien> vendethiel: LasagnaScript steals it from Elixir because almost no JS APIs are curried.

[00:58] <vendethiel> Kristien: that's why prelude.ls has curry()

[00:59] <Kristien> Meh

[00:59] <Kristien> I kinda implemented protocols btw :P

[00:59] <masak> wait... LasagnaScript?

[01:00] <vendethiel> masak: Kristien's altJS :P

[01:00] <vendethiel> also, ls's |> allows for the "_" placeholder, so that if a API is considered "poxy", you can just work around it. ('foo' |> fn arg1, _)

[01:00] <masak> I see.

[01:00] <Kristien> vendethiel: I generalised that; % operator takes any term and turns it into a function, turning %n into the nth argument

[01:01] <vendethiel> this is like clojure's %, right?

[01:01] <Kristien> jawohl, except it doesn't restrict to calls

[01:02] <Kristien> E.g. %%1 is the identity function. %(%1 * %2 + %3) and %try { foo(%1) } finally { bar() } are other examples.

[01:03] <vendethiel> oh, pretty good

[01:03] <Kristien> Not sure about nesting of them though. Could disallow or make %n pick arguments from the innermost %-function

[01:03] <masak> a little bit like we use whatever and placeholder parameters for in Perl 6.

[01:05] <Kristien> If you want a constant function returning a number you have to parenthesise the number though, so %(42) instead of %42

[01:05] <Kristien> since the latter will try to yield the 42nd argument :P

[01:05] *** BenGoldberg left
[01:06] *** BenGoldberg joined
[01:10] *** spider-mario left
[01:28] *** telex left
[01:30] *** telex joined
[01:42] *** beastd left
[01:48] <masak> 'night, #perl6

[01:50] <Kristien> masak: goodbye

[01:51] <psch> hi #perl6 \o

[01:51] <psch> vendethiel: you mis-containered %num-to-notes in your PR :)

[01:52] <psch> vendethiel: it's still neater though ;)

[01:52] <vendethiel> psch: mmh?

[01:52] <vendethiel> did I? :p sorry!

[01:52] <psch> vendethiel: yes, you scalared it, even though it's a hash

[01:53] <psch> vendethiel: also, there's a tad more in the repo now, including a README, and tritone-in-c.pl has fallen to the wayside 

[01:54] <vendethiel> psch: 'twas a typo, sorry :(

[01:55] <psch> vendethiel: it's fine.  the repo is a collection of stuff i'm trying and that file in particular was just a check to see if what i'm imagining could be feasible :)

[01:55] <tony-o_> jnthn: ab5tract: bsd32 fails to build JVM perl6 too with the same error

[01:55] <tony-o_> too weird

[01:56] *** fil_ left
[01:58] <tony-o_> ab5tract: what 686 linux distro did you use?

[02:00] *** Kristien left
[02:08] *** ggoebel111111111 joined
[02:09] *** retupmoc1 joined
[02:09] *** nine_ joined
[02:09] *** felher_ joined
[02:10] *** Psyche^ joined
[02:10] *** robins joined
[02:11] *** Tux__ joined
[02:11] *** xinming_ joined
[02:11] *** breinbaa1 joined
[02:12] *** broquain1 joined
[02:14] *** raydiak_ joined
[02:16] *** Pleiades` left
[02:16] *** Patterner left
[02:16] *** vukcrni left
[02:16] *** raydiak left
[02:16] *** xinming left
[02:16] *** ggoebel111111119 left
[02:16] *** breinbaas left
[02:16] *** |Tux| left
[02:16] *** tadzik left
[02:16] *** mattp_ left
[02:16] *** avuserow left
[02:16] *** robinsmidsrod left
[02:16] *** retupmoca left
[02:16] *** nine left
[02:16] *** broquaint left
[02:16] *** lestrrat left
[02:16] *** felher left
[02:16] *** mattp__ joined
[02:16] *** Pleiades` joined
[02:18] *** avuserow joined
[02:20] *** tadzik joined
[02:21] *** vukcrni joined
[02:22] *** cxreg joined
[02:22] *** skaufman_ joined
[02:23] *** japhb_ joined
[02:24] *** [particle]1 joined
[02:24] *** nebuchad` joined
[02:26] *** simcop2387_ joined
[02:27] *** TimToady_ joined
[02:27] *** slavik1 joined
[02:27] *** risou is now known as 17SABKHBC

[02:27] *** risou joined
[02:27] *** VAB17AF joined
[02:27] *** lestrrat joined
[02:28] *** gfldex left
[02:28] *** gfldex joined
[02:29] *** rmgk_ joined
[02:29] *** rmgk left
[02:29] *** rmgk_ is now known as rmgk

[02:33] *** daxim_ joined
[02:33] *** agentzh left
[02:35] *** cxreg2 left
[02:35] *** skaufman left
[02:35] *** TimToady left
[02:35] *** japhb left
[02:35] *** nebuchadnezzar left
[02:35] *** petercommand left
[02:35] *** [particle] left
[02:35] *** 17SABKHBC left
[02:35] *** slavik left
[02:35] *** simcop2387 left
[02:35] *** daxim left
[02:35] *** simcop2387_ is now known as simcop2387

[02:40] *** Ben_Goldberg joined
[02:40] *** [particle] joined
[02:41] *** kst` joined
[02:44] *** [Coke]_ joined
[02:44] *** huf_ joined
[02:44] *** bartolin_ joined
[02:44] *** Juerd_ joined
[02:44] *** cosimo_ joined
[02:45] *** ab5tract_ joined
[02:45] *** BinGOs_ joined
[02:45] *** osfamero1 joined
[02:45] *** krunen_ joined
[02:45] *** yeltzooo joined
[02:46] *** Gothmog_1 joined
[02:46] *** bcode_ joined
[02:49] *** [particle]1 left
[02:49] *** BenGoldberg left
[02:49] *** bcode left
[02:49] *** dalek left
[02:49] *** IllvilJa left
[02:49] *** PZt left
[02:49] *** [Tux] left
[02:49] *** lue left
[02:49] *** pnu left
[02:49] *** Juerd left
[02:49] *** krunen left
[02:49] *** jferrero left
[02:49] *** BinGOs left
[02:49] *** Gothmog_ left
[02:49] *** bartolin left
[02:49] *** woolfy left
[02:49] *** ab5tract left
[02:49] *** renormalist left
[02:49] *** kst left
[02:49] *** osfameron left
[02:49] *** huf left
[02:49] *** [Coke] left
[02:49] *** yeltzooo9 left
[02:49] *** dg left
[02:49] *** cosimo left
[02:49] *** charsbar_____ left
[02:49] *** bcode_ is now known as bcode

[02:49] *** Juerd_ is now known as Juerd

[02:49] *** Gothmog_1 is now known as Gothmog_

[02:50] *** jferrero joined
[02:51] *** renormalist joined
[02:52] *** dg joined
[02:52] *** TimToady_ is now known as TimToady

[02:52] *** TimToady left
[02:52] *** TimToady joined
[02:55] *** lue joined
[02:56] *** IllvilJa joined
[02:57] *** gfldex left
[02:58] *** [Tux] joined
[02:59] *** charsbar_____ joined
[03:00] *** woolfy joined
[03:02] *** pnu joined
[03:02] *** dalek joined
[03:02] *** pnu left
[03:02] *** pnu joined
[03:02] *** ChanServ sets mode: +v dalek

[03:15] *** VAB17AF joined
[03:29] *** dj_goku left
[03:29] *** dj_goku_ joined
[03:29] *** dj_goku_ left
[03:29] *** dj_goku_ joined
[03:37] *** Maddingu1 joined
[03:39] *** kaare__ joined
[03:41] *** ugexe_ joined
[03:45] *** kst` is now known as kst

[03:48] *** stux|RC joined
[03:48] *** Timbus_ joined
[03:50] *** silug_ joined
[03:50] *** noganex joined
[03:52] *** Timbus left
[03:52] *** stux|RC-only left
[03:52] *** Alina-malina left
[03:52] *** molaf_ left
[03:52] *** kaare_ left
[03:52] *** silug left
[03:52] *** ugexe left
[03:52] *** Maddingue left
[03:54] *** noganex_ left
[03:54] *** molaf_ joined
[03:58] *** dj_goku_ left
[04:18] *** dj_goku joined
[04:18] *** dj_goku left
[04:18] *** dj_goku joined
[04:35] *** dj_goku left
[04:38] *** dj_goku joined
[04:38] *** dj_goku left
[04:38] *** dj_goku joined
[04:58] <skids> .tell japhb "The last statement in a module with more than one statement seems to have some extra-sinky context (because it supplies the return value of "use" I think). I just put 1; at the end of the module to prevent that."

[04:58] <yoleaux> skids: I'll pass your message to japhb.

[04:58] <timotimo> i don't think we have return values from use

[05:13] <TimToady> the last statement of a module file should be sunk just as much as the other statements; if not, it's a bug

[05:16] <TimToady> in fact, the 1; should be complaining about a useless use of '1' in a sink context

[05:19] <skids> Well, I can't get it do error anymore so maybe it is fixed?  I'll try with the code I needed to put it in way back when.

[05:19] <TimToady> and, in fact, it doesn't complain, so it's a bug I thnk

[05:20] <TimToady> if the final statement is a for loop, that used to require a more explicit sink

[05:20] <TimToady> nowadays we autosink any loop in a statementlist

[05:22] <skids> Yeah, no complaints about the final 1; in my Sum module, which uses it in most of the files.

[05:23] <TimToady> but it does seem to sink the final statement anyway, just won't complain about useless use there for some reason

[05:23] <TimToady> m: module Foo { 42; 43; 44 }

[05:23] <camelia> rakudo-moar f12020: OUTPUT«WARNINGS:␤Useless use of constant integer 42 in sink context (line 1)␤Useless use of constant integer 43 in sink context (line 1)␤Useless use of constant integer 44 in sink context (line 1)␤»

[05:24] <TimToady> warns there

[05:24] <TimToady> m: module Foo; 42; 43; 44

[05:24] <camelia> rakudo-moar f12020: OUTPUT«WARNINGS:␤Useless use of constant integer 42 in sink context (line 1)␤Useless use of constant integer 43 in sink context (line 1)␤Useless use of constant integer 44 in sink context (line 1)␤»

[05:24] <TimToady> and there, huh

[05:25] <TimToady> but use seems to suppress the final one somehow

[05:26] <skids> It used to more than sink it, it somehow extra-double-super-secret-sunk it and punned the role.  I have to yank out all the 1s and try all combos of precomp to see if there is still any such problem.

[05:26] <TimToady> weird, if I put a module foo; at the front of my foo.pm, it warns on the last one now

[05:27] <TimToady> so the whole file is treated as a block that might return a value, but if we switch into module, it enforces sink on the last statement

[05:29] <skids> .tell japhb well, maybe read the backlog before doing what I just said.

[05:29] <yoleaux> skids: I'll pass your message to japhb.

[05:30] *** adu joined
[05:50] <skids> m: (role A { }).HOW.WHAT.say; A.HOW.WHAT.say; # scratches head, wishes he had more time to read code.

[05:50] <camelia> rakudo-moar f12020: OUTPUT«(Perl6::Metamodel::ParametricRoleHOW)␤(Perl6::Metamodel::ParametricRoleGroupHOW)␤»

[06:02] *** Alina-malina joined
[06:08] *** atroxaper joined
[06:54] *** espadrine_ joined
[07:11] <japhb_> Thanks for taking a gander at my Role problem, skids.

[07:11] *** japhb_ is now known as japhb

[07:11] <japhb> .botsnack

[07:11] <yoleaux> :D

[07:11] <yoleaux> 04:58Z <skids> japhb: "The last statement in a module with more than one statement seems to have some extra-sinky context (because it supplies the return value of "use" I think). I just put 1; at the end of the module to prevent that."

[07:11] <yoleaux> 05:29Z <skids> japhb: well, maybe read the backlog before doing what I just said.

[07:16] <moritz> \o

[07:30] *** adu left
[07:32] *** darutoko joined
[07:32] *** espadrine joined
[07:33] *** espadrine_ left
[07:36] *** xfix joined
[07:52] *** rindolf joined
[08:04] <FROGGS[mobile]> o/

[08:04] *** prime left
[08:04] <FROGGS[mobile]> mornäng

[08:05] *** Ben_Goldberg left
[08:05] *** Ben_Goldberg joined
[08:09] *** adu joined
[08:11] *** prime joined
[08:28] *** xinming_ left
[08:29] *** xinming joined
[08:37] <moritz> .ask jnthn is there a good reason to keep $!started in Proc::Async private? sounds like potentially useful information for the caller

[08:37] <yoleaux> moritz: I'll pass your message to jnthn.

[08:42] <dalek> roast: 7eb85d9 | usev6++ | S32-str/substr-rw.t:

[08:42] <dalek> roast: Add test for RT #114526 (fudged 'skip' for Parrot)

[08:42] <dalek> roast: review: https://github.com/perl6/roast/commit/7eb85d9e18

[08:42] <synopsebot> Link: https://rt.perl.org/rt3//Public/Bug/Display.html?id=114526

[08:48] <dalek> roast: f16e55e | usev6++ | S32-str/sprintf.t:

[08:48] <dalek> roast: Fudge two tests (todo) since error message would change with NQP PR 219

[08:48] <dalek> roast: review: https://github.com/perl6/roast/commit/f16e55e99c

[08:52] *** zby_home joined
[08:54] <dalek> doc: 1517511 | moritz++ | lib/Type/ (2 files):

[08:54] <dalek> doc: Start to documtn Proc::Async

[08:54] <dalek> doc: review: https://github.com/perl6/doc/commit/1517511201

[09:05] *** agentzh joined
[09:05] *** ptc_p6 joined
[09:06] *** atroxaper left
[09:06] *** telex left
[09:08] *** telex joined
[09:11] <dalek> nqp: 878c6ae | usev6++ | src/HLL/sprintf.nqp:

[09:11] <dalek> nqp: Change message for mismatch between specified arguments in directives and supplied arguments

[09:11] <dalek> nqp: cmp. http://irclog.perlgeek.de/perl6/2015-01-24#i_9996416

[09:11] <dalek> nqp: review: https://github.com/perl6/nqp/commit/878c6ae734

[09:11] <dalek> nqp: 6fa84cc | usev6++ | t/hll/06-sprintf.t:

[09:11] <dalek> nqp: Adjust error message for directives/arguements mismatch in nqp tests

[09:12] <dalek> nqp: review: https://github.com/perl6/nqp/commit/6fa84cc363

[09:12] <dalek> nqp: 5a33762 | moritz++ | / (2 files):

[09:12] <dalek> nqp: Merge pull request #219 from usev6/master

[09:12] <dalek> nqp: 

[09:12] <dalek> nqp: Improve error message for sprintf

[09:12] <dalek> nqp: review: https://github.com/perl6/nqp/commit/5a33762ac9

[09:16] *** jakesyl left
[09:17] *** jakesyl joined
[09:22] *** nebuchad` is now known as nebuchadnezzar

[09:23] *** vendethiel left
[09:24] *** vendethiel joined
[09:27] *** mr-foobar left
[09:30] *** molaf__ joined
[09:33] *** molaf_ left
[09:33] *** Ben_Goldberg left
[09:34] *** Ben_Goldberg joined
[09:35] *** Ben_Goldberg left
[09:35] *** Ben_Goldberg joined
[09:36] *** Rounin joined
[09:39] *** kaare__ is now known as kaare_

[09:46] *** vendethiel left
[09:50] *** BinGOs_ is now known as BinGOs

[09:50] *** zby_home left
[09:50] *** BinGOs left
[09:50] *** BinGOs joined
[10:00] *** espadrine_ joined
[10:01] *** virtualsue joined
[10:04] *** espadrine left
[10:09] *** vendethiel joined
[10:11] *** bjz_ joined
[10:11] *** bjz left
[10:13] *** Ben_Goldberg left
[10:19] *** gfldex joined
[10:27] *** sz joined
[10:27] *** mvuets joined
[10:27] *** sz left
[10:29] *** abraxxa joined
[10:30] *** szabgab joined
[10:30] *** breinbaa1 left
[10:30] <szabgab> rakudo: say 19+23

[10:30] <camelia> rakudo-{parrot,moar} f12020: OUTPUT«42␤»

[10:37] <masak> good antenoon, #perl6

[10:42] *** breinbaas joined
[10:43] *** zby_home_ joined
[10:43] *** zby_home_ left
[10:49] *** agentzh left
[10:53] <moritz> good *, masak

[10:59] <dalek> doc: 1c9eace | moritz++ | lib/Type/ (2 files):

[10:59] <dalek> doc: Document X::Proc::Async::AlreadyStarted

[10:59] <dalek> doc: review: https://github.com/perl6/doc/commit/1c9eacee1d

[11:01] <szabgab> hello ppl

[11:01] <moritz> \o szabgab 

[11:01] <szabgab> I have a really strange bug on the Perl6Maven site

[11:01] <szabgab> \o moritz 

[11:01] <szabgab> beside it leaking memory like hell :)

[11:02] <szabgab> once in a while it seems as if the regex engine stopped working

[11:02] <ab5tract_> m:  my $x = '\E]45;65H'; say $x.substr(/45/,77)

[11:02] <camelia> rakudo-moar f12020: OUTPUT«No such method '!cursor_start' for invocant of type 'Int'␤  in sub substr at src/gen/m-CORE.setting:7679␤  in method substr at src/gen/m-CORE.setting:4097␤  in block <unit> at /tmp/161RXUN10t:1␤␤»

[11:02] <moritz> szabgab: are you ever using user-supplied strings in regexes?

[11:03] *** Woodi left
[11:03] <szabgab> every time someone visits the site, it loads a file, parses it using some regexes 

[11:03] <szabgab> do you mean the regex part?

[11:03] <szabgab> I think no

[11:03] <szabgab> let me check

[11:03] <szabgab> but I finish the sentence first :)

[11:03] <moritz> oh, you weren't

[11:03] <moritz> then go ahead :-)

[11:04] <ab5tract_> ah, never mind.. another confusion of subst and substr

[11:04] <szabgab> so the code parses the header that looks like     =title Title

[11:04] <szabgab> but sometimes it seems it stops the parsing 

[11:04] <szabgab> and does not recognize the matching rows

[11:05] <szabgab> then after the restart (I have to restart the server every 30 requests) it works again

[11:05] <szabgab> so far I could not figure out what might trigger the behaviour

[11:06] <szabgab> pastebot?

[11:06] <moritz> none here

[11:06] <moritz> just use gist.github.com or so

[11:07] <szabgab> https://gist.github.com/szabgab/35359cfe441fd0a9f9fb

[11:08] <szabgab> those seem to be the only regexes

[11:08] <szabgab> but that's just my code, maybe some of the modules I use...

[11:08] <szabgab> Maybe the template module?

[11:08] <moritz> which one do you use?

[11:09] <szabgab>  Template::Mojo

[11:09] <szabgab> Eerything is Rakudo Star 2014.12 except Bailador which I've patched

[11:11] <szabgab> I thin Bailador builds regexes on-the-fly

[11:11] <szabgab> from the routes in the application

[11:11] <moritz> but I hope those aren't user-input

[11:11] <szabgab> If that's what you were after

[11:11] <szabgab> not from the end-user

[11:12] <szabgab> from the source code of Perl6::Maven

[11:12] <moritz> but I think my question as mis-guided. I thought the regexes hangs, but it seems they simply don't match=

[11:12] <moritz> s/=/?/

[11:12] <szabgab> right

[11:12] <szabgab> they stop matching

[11:12] <szabgab> and never resume matching

[11:13] <moritz> can you identify the place where the first stop matching?

[11:13] *** rurban_ joined
[11:14] <szabgab> probably not

[11:14] <szabgab> I might need to add lots of logging and that might help

[11:15] <moritz> well, I haven't heard of this phenomenon before

[11:15] <szabgab> OK, if there is nothing obvious to you, then I'll just add more code to be able to log the requests well

[11:15] <moritz> it might or might not help

[11:15] <szabgab> and then I might have better input

[11:16] *** espadrine_ left
[11:16] <szabgab> is there a logging module ?

[11:17] *** spider-mario joined
[11:20] *** isBEKaml joined
[11:23] <moritz> I'm not aware of any

[11:24] <dalek> rakudo/nom: 6429a22 | moritz++ | src/core/Proc/Async.pm:

[11:24] <dalek> rakudo/nom: Proc::Async.write: accept Blob, not Buf

[11:24] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/6429a22d99

[11:26] <szabgab> ok, thanks

[11:37] *** kjs_ joined
[11:41] *** szabgab left
[11:56] <rurban_> got now msvc on win64 working

[12:00] <dalek> rakudo/nom: 7e8d8af | moritz++ | src/core/Proc/Async.pm:

[12:00] <dalek> rakudo/nom: Proc::Async: fix exception throwing

[12:00] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/7e8d8af835

[12:11] *** rindolf left
[12:13] <dalek> Inline-Python: c26bd6e | (Stefan Seifert)++ | .gitignore:

[12:13] <dalek> Inline-Python: .gitignore file

[12:13] <dalek> Inline-Python: review: https://github.com/niner/Inline-Python/commit/c26bd6e459

[12:15] *** abraxxa left
[12:18] *** jluis_ joined
[12:19] *** Kristien joined
[12:31] *** kjs_ left
[12:38] *** rmgk_ joined
[12:38] *** rmgk left
[12:38] *** rmgk_ is now known as rmgk

[12:50] <Kristien> hola #perl6

[12:54] <masak> \o

[12:55] <masak> vendethiel: which would you say was the first altJS? has someone written a history/chronicle about them? which altJS languages do you think will be in use/remembered 20 years down the line, and why?

[12:56] *** rurban_ left
[12:57] *** jluis_ left
[13:00] <vendethiel> masak: GWT would probably be it

[13:00] <masak> oh, right.

[13:01] <masak> GWT is basically abandoned now, is it?

[13:02] *** virtualsue left
[13:03] <vendethiel> masak: I think gmail still uses it?

[13:03] <masak> oh, mebbe.

[13:04] <vendethiel> masak: sorry, apparently it isn't anymore. But it seems chrome web store and google groups use it https://groups.google.com/forum/#!msg/google-web-toolkit/Mjjk5y9RQbw/hCWzIrZ1vzcJ

[13:04] <vendethiel> it was from 2011 though, so maybe not up to date

[13:04] <masak> ah.

[13:04] <masak> interesting that Gmail moved off it.

[13:04] <masak> I wonder why.

[13:05] <vendethiel> masak: I'm not *sure* it did. gwt's website doesn't mention it -- it mentions adwords and wallet

[13:05] <masak> *nod*

[13:05] <vendethiel> masak: GWT 2.7 on nov 14. I don't think it's been "abandoned" -- it's just that no one wants to write java

[13:07] <masak> fair enough

[13:10] <isBEKaml> masak: Gmail didn't abandon GWT - but AFAICR, they maintain their own version of GWT

[13:11] <isBEKaml> masak: that was in addition to open source releases of GWT (by its own team)

[13:11] <masak> ugh

[13:11] *** jluis_ joined
[13:11] <isBEKaml> yeah, as I read it back then - their use of GWT was simply too complex and it cannot be integrated into the main release. 

[13:12] <isBEKaml> so they had to maintain their own internal version of GWT

[13:20] <Kristien> masak: Objective-C is also pretty old

[13:20] <Kristien> I mean Objective-J

[13:21] <masak> heard about it, but not more'n that

[13:21] <masak> what is it?

[13:21] <Kristien> It's Objective-C except with JavaScript instead of C.

[13:22] <masak> but... hm.

[13:22] <masak> JS already has an object system. and a syntax for method calls.

[13:22] <masak> I guess I don't see the point.

[13:22] <Kristien> Objective-J has a new separate object system xD

[13:23] <masak> o.O

[13:23] <masak> they must've not liked the first one...

[13:28] <moritz> .oO( how did that happen? :-)

[13:29] *** adu left
[13:30] <masak> random thought: P6 is a bigger breaking change than py3k because Larry had more to atone for than Guido (language-wise)

[13:34] <ab5tract_> masak: that's an interesting perspective

[13:34] <masak> maybe that's obvious, I dunno. the Perl 5 line didn't shirk from sinning if it got the job done.

[13:34] <masak> Perl 6 aims to do better. Python somehow always did.

[13:37] *** Kristien left
[13:38] <ab5tract_> for that generation of dynamic languages, it seems to me that python "won" in the sense that it runs the spectrum of teaching to sysadmin to web to science and back again

[13:39] <ab5tract_> and i always take the POV that perl 6 caused some sort of irreperable harm to the reputation of perl 5 with a grain of salt

[13:40] <ab5tract_> because it was pretty clear to me that people were leaving perl 5 to python at a pretty big clip even prior to the announcement

[13:42] <masak> yes, Python sure has mindshare.

[13:42] <masak> and deservedly, if you ask me. I say that as someone who loves Perl.

[13:43] <masak> (and as one who isn't all that into indentation-as-blocks)

[13:44] <ab5tract_> it is almost certainly a retcon on my part, but i always took the design of python as directly inspired by perl, but in the sense that guido's design was in realizing the power of exploring a language where DWIM is reinforced by the fact that !(TMTOWTDI)

[13:45] <moritz> as a relative beginner in python, I find that it seldom DWIM

[13:46] <moritz> but it usually gives an error instead of doing the wrong thing

[13:46] <ab5tract_> moritz: that's because when there is one way to do it, 'do what i mean' takes on a new dimension where you must 'mean what you do'

[13:51] <ab5tract_> when TMTOWTDI, meaning what you do can come free-form, even retaining the jazz definition; the multiplicity is a double edged sword, though. that's why part of p5's continued popularity is at least partly a result of the "modern perl" movement, which advocated heavily for trimming down the cuteness and dark magic

[13:56] *** isBEKaml left
[13:56] <ab5tract_> i'm a huge fan of TIMTOWTDI, but i've always largely attributed python's near-universal appeal (minus the haters-for-life) to guido's rejection of the principle

[14:00] *** osfamero1 is now known as osfameron

[14:02] <ab5tract_> what makes perl 6 so appealing to me is that it really does feel like it has been carefully designed to host that multiplicity of 'ways to do it', while addressing things like the dangers of building a monkey patching culture by making it basically unnecessary *and* still provide support for it :)

[14:02] <ab5tract_> *providing

[14:03] <dalek> roast: 3101a04 | usev6++ | S11-modules/export.t:

[14:03] <dalek> roast: Add test for RT #84280

[14:03] <dalek> roast: review: https://github.com/perl6/roast/commit/3101a0468f

[14:03] <synopsebot> Link: https://rt.perl.org/rt3//Public/Bug/Display.html?id=84280

[14:06] <dalek> doc: c9d67d3 | moritz++ | lib/Type/ (3 files):

[14:06] <dalek> doc: Document a bit more of Proc::Aync, related exceptions

[14:06] <dalek> doc: review: https://github.com/perl6/doc/commit/c9d67d30a7

[14:08] *** Kristien joined
[14:09] <moritz> lizmat: Proc::Async.say doesn't use .gist to stringify its argument. Is that intentential?

[14:12] *** jluis_ left
[14:16] <moritz> m: say $*KERNEL.signal('KILL')

[14:16] <camelia> rakudo-moar 7e8d8a: OUTPUT«9␤»

[14:16] <moritz> m: say $*KERNEL.signal('SIGKILL')

[14:16] <camelia> rakudo-moar 7e8d8a: OUTPUT«9␤»

[14:16] <moritz> m: say $*KERNEL.signal(SIGKILL)

[14:16] <camelia> rakudo-moar 7e8d8a: OUTPUT«9␤»

[14:16] <moritz> m: say $*KERNEL.signal(9)

[14:16] <camelia> rakudo-moar 7e8d8a: OUTPUT«9␤»

[14:17] *** jluis_ joined
[14:17] *** Peter_R joined
[14:18] <Kristien> m: say $*KERNEL.WHAT

[14:18] <camelia> rakudo-moar 7e8d8a: OUTPUT«(Kernel)␤»

[14:18] <Kristien> Interesting.

[14:22] <dalek> doc: 3b83fb1 | moritz++ | lib/Type/Proc/Async.pod:

[14:22] <dalek> doc: mostly finish documenting Proc::Async

[14:22] <dalek> doc: review: https://github.com/perl6/doc/commit/3b83fb19b1

[14:22] *** rindolf joined
[14:25] <lizmat> moritz: Proc::Async.say not gisting is probably an oversight

[14:28] *** mr-foobar joined
[14:28] <dalek> doc: 83a1c78 | moritz++ | lib/Type/Proc/Async.pod:

[14:28] <dalek> doc: Add a note that only MoarVM supports Proc::Async

[14:28] <dalek> doc: review: https://github.com/perl6/doc/commit/83a1c78ee1

[14:29] <Kristien> m: ObjAt.new

[14:29] <camelia> rakudo-moar 7e8d8a: ( no output )

[14:29] <Kristien> Segfaults on my machine :P

[14:29] <moritz> :(

[14:30] *** sirdancealot joined
[14:31] <dalek> roast: bc2983c | moritz++ | S17-procasync/basic.t:

[14:31] <dalek> roast: start to test some exceptions for Proc::Async

[14:31] <dalek> roast: review: https://github.com/perl6/roast/commit/bc2983c9bb

[14:34] <Kristien> seems to be an old bug

[14:35] <dalek> roast: e223c44 | moritz++ | S17-procasync/basic.t:

[14:35] <dalek> roast: Proc::Async: test more exceptions

[14:35] <dalek> roast: review: https://github.com/perl6/roast/commit/e223c44b72

[14:35] <Kristien> Stuff like Set uses WHICH to determine equality right?

[14:36] <moritz> identity

[14:36] <Kristien> right

[14:36] <Kristien> good

[14:37] <moritz> (sorry for being pedantic)

[14:37] <Kristien> And it should be perfectly fine to override WHICH for immutable user-defined types?

[14:38] <lizmat> Kristien: yes, that's the idea

[14:38] <Kristien> Nice.

[14:39] <Kristien> Perl 6 is well-designed.

[14:39] <moritz> can anybody on windows confirm that 'type' on the command line without arguments reads from STDIN?

[14:40] <moritz> or do I have to use 'copy con' or such weird magics?

[14:43] <lumimies> moritz: It does not

[14:44] <lumimies> type con: seems to

[14:48] <moritz> lumimies: thanks

[14:53] <Kristien> This is interesting: https://gist.github.com/rightfold/f05c4d4c31e09ca0d9bf

[14:53] <moritz> Kristien: the REPL has known problems with natively typed variables

[14:53] <Kristien> OK!

[14:53] <moritz> Kristien: basically, it starts a new compilation unit for each line

[14:54] <moritz> Kristien: but to make the previous variables available, it copies them into an outer scope

[14:54] <moritz> Kristien: and that doesn't work well yet in some corner cases

[14:55] <Kristien> I have to implement a REPL soon.

[14:56] <moritz> +1

[14:56] <Kristien> I think I have an idea of how I'll do it.

[14:58] *** jmark joined
[14:59] *** _4d47 joined
[15:07] <dalek> roast: 67bb8b3 | moritz++ | S17-procasync/basic.t:

[15:07] <dalek> roast: more tests for Proc::Async

[15:07] <dalek> roast: 

[15:07] <dalek> roast: in particular:

[15:07] <dalek> roast: * test .write and .print, open for writing

[15:07] <dalek> roast: * .close-stdin

[15:07] <dalek> roast: * more exceptions

[15:07] <dalek> roast: review: https://github.com/perl6/roast/commit/67bb8b3be1

[15:08] <Kristien> Just a reduction over the lines of stdin :P

[15:12] <vendethiel> moritz: it doesn't either here :P

[15:14] *** virtualsue joined
[15:15] <[Tux]> what is the perl way to do «my Str $foo = function (); is_valid_utf8 ($foo) and "UTF8".say» ?

[15:16] <[Tux]> where full-ASCII would return False

[15:16] *** rurban_ joined
[15:18] *** Ben_Goldberg joined
[15:19] <moritz> [Tux]: checking of a Str is valid utf-8 is mixing of levels

[15:19] <[Tux]> ?

[15:19] <moritz> [Tux]: Str is an encoding-indepenent sequence of codepoints (later hopefully graphemes)

[15:20] <Kristien> > Perl 6 is well-designed.

[15:21] <[Tux]> fine :)

[15:21] <Ben_Goldberg> Somewhere hidden behind the Str is a Buf, which will contain some form of utf, but that's a separate level.

[15:21] <moritz> [Tux]: what do you want to achieve in the end?

[15:21] <[Tux]> So, how can I check id *all* codepoints in a string are inside ASCII?

[15:22] <moritz> all($str.ords) < 128 # but probably not most efficient

[15:22] * [Tux] wants to copy as much as possible of Text::CSV_XS (perl5) to Text::CSV (perl6)

[15:22] <[Tux]> it is lazy, so I do not care about performance there

[15:23] <Kristien> encode it to ASCII and check for encoding errors

[15:23] <Kristien> that's what I'd do

[15:23] <Kristien> I don't like hardcoding 128

[15:23] <moritz> m: say so 'abc' ~~ /^ <[\x0 .. \x127]>* $ /

[15:23] <camelia> rakudo-moar 7e8d8a: OUTPUT«True␤»

[15:23] <moritz> m: say so 'abcö' ~~ /^ <[\x0 .. \x127]>* $ /

[15:23] <camelia> rakudo-moar 7e8d8a: OUTPUT«True␤»

[15:23] <moritz> huh

[15:23] <moritz> erm

[15:24] <moritz> m: say so 'abcö' ~~ /^ <[\x0 .. \x7F]>* $ /

[15:24] <camelia> rakudo-moar 7e8d8a: OUTPUT«False␤»

[15:24] <[Tux]> :)

[15:24] <moritz> m: say so defined try 'abcö'.encode('ASCII')

[15:24] <camelia> rakudo-moar 7e8d8a: OUTPUT«True␤»

[15:24] <moritz> m: say 'ö'.encode('ASCII')

[15:25] <camelia> rakudo-moar 7e8d8a: OUTPUT«Blob[uint8]:0x<3f>␤»

[15:25] <moritz> that looks like a bug to me

[15:25] <ab5tract_> [&&] "6kgj".ords.map( * < 128 )

[15:26] <Kristien> m: say 'ö'.encode('ASCII').decode('ASCII')

[15:26] <camelia> rakudo-moar 7e8d8a: OUTPUT«?␤»

[15:26] <Kristien> moritz: it uses a replacement character instead of throwing an exception

[15:26] <moritz> Kristien: and that's a dangerous default, IMHO, because it silently loses information

[15:26] <Kristien> Yes.

[15:27] <Kristien> IMO there should be a way to parameterise on error handling mechanic.

[15:27] <moritz> well, .encode('ASCII', :replacement) could work

[15:27] <ab5tract_> fwiw, i was banging my head on the wall trying to manipulate terminal escape sequences

[15:27] <Kristien> I've seen one C++ library do enum ErrorHandling { Throw, Replacement, AssumeOK };

[15:27] <moritz> AssumeOK seems pretty dangerous

[15:27] <ab5tract_> yes, adverbs seem like a good approach, and move the current default behavior into one

[15:27] <moritz> but Perl 5's Encode has similar options, iirc

[15:28] <Kristien> Yeah, it's UB if it's not actually OK

[15:28] * [Tux] forsees some interesting problems in decoding binary data :)

[15:28] <moritz> and we try to avoid undefined behavior where we can

[15:28] <[Tux]> images in CSV

[15:28] <Kristien> moritz: good

[15:29] <Kristien> :replacement might also take a parameter: $str.encode('ASCII', :replacement('x'))

[15:29] <Kristien> or rather a uint8 not a Str

[15:31] *** ingy1 is now known as ingy

[15:32] *** Kristien left
[15:34] <lizmat> seems like usev6  ( bartolin_  ??? ) has forgotten to add a RT84280.pm to roast

[15:35] <ab5tract_> one thing i've been bumping my head on is how to print an escape sequence once it is in a variable without it getting interpolated

[15:35] <moritz> ab5tract_: because it's not UTF-8?

[15:36] <ab5tract_> i imagine it is related somehow. just printing the variable will "do" the cursror move command i have stored in the variable

[15:37] <ab5tract_> and i can even extract the numbers with regex groups

[15:37] <moritz> ab5tract_: oh, you want it for debugging?

[15:37] <ab5tract_> but so far my efforts to put numbers back in have been fruitless

[15:37] <ab5tract_> exactly

[15:37] <moritz> say $str.perl; # ?

[15:37] *** zakharyas joined
[15:38] <ab5tract_> damnit moritz, you genius :)

[15:38] <dalek> roast: d591ae5 | moritz++ | S17-procasync/basic.t:

[15:38] <dalek> roast: More Proc::Async tests

[15:38] <dalek> roast: review: https://github.com/perl6/roast/commit/d591ae53f3

[15:39] <moritz> it would be very welcome if somebody could run S17-procasync/basic.t on windows

[15:39] <moritz> and inform me of any failures

[15:40] <ab5tract_> i don't suppose there is a built in character class for matching escape sequences :)

[15:40] <moritz> iirc there's <print> for printable characters

[15:40] <moritz> so something not-<print>able could be an escape sequence

[15:44] <bartolin_> lizmat: oops, you're right.

[15:44] <ab5tract_> m: "\n" !~~ /<print>/

[15:44] <camelia> rakudo-moar 7e8d8a: OUTPUT«Cursor<139843422512584>Cursor<139843422562104>P6opaque: no such attribute '$!pos'␤  in method ACCEPTS at src/gen/m-CORE.setting:14610␤  in block <unit> at /tmp/ASa6x7LUws:1␤␤»

[15:45] <ab5tract_> same error for single-quotes

[15:46] <dalek> rakudo/nom: 5dd603b | lizmat++ | src/core/Proc/Async.pm:

[15:46] <dalek> rakudo/nom: Make Proc::Async.say gist, spotted by moritz++

[15:46] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/5dd603b6cf

[15:46] <FROGGS[mobile]> <print> is either NYI or it picks up the print sub

[15:46] <dalek> roast: e8465cb | usev6++ | packages/RT84280.pm:

[15:46] <dalek> roast: Add missing file for test for RT #84280

[15:46] <dalek> roast: review: https://github.com/perl6/roast/commit/e8465cb6d8

[15:46] <synopsebot> Link: https://rt.perl.org/rt3//Public/Bug/Display.html?id=84280

[15:47] <bartolin_> lizmat++ # spotting the missing file

[15:47] <FROGGS[mobile]> ab5tract_: matching escape sequences is not quite possible when these are interpolated :o)

[15:48] <FROGGS[mobile]> but you can match a backslash and something afterwards, according to what you wanna see

[15:48] <ab5tract_> m: "for" ~~ /<print>/

[15:48] <camelia> rakudo-moar 7e8d8a: OUTPUT«Cursor<140112800721080>Cursor<140112800770600>P6opaque: no such attribute '$!pos'␤  in method ACCEPTS at src/gen/m-CORE.setting:14610␤  in block <unit> at /tmp/BXPDVP2xWT:1␤␤»

[15:49] <FROGGS[mobile]> m: "foo" ~~ /<say>/

[15:49] <camelia> rakudo-moar 7e8d8a: OUTPUT«Cursor.new()␤Cursor.new()␤P6opaque: no such attribute '$!pos'␤  in method ACCEPTS at src/gen/m-CORE.setting:14610␤  in block <unit> at /tmp/9ocu5YoTtd:1␤␤»

[15:50] <ab5tract_> FROGGS[mobile]: ah.. i am seeing a way through now, actually. but yeah, something there doesn't seem happy

[15:51] *** Kristien joined
[15:53] *** pnu left
[15:54] *** ggherdov left
[15:54] *** Ben_Goldberg left
[15:54] <[Tux]> «has %errors = (1 => "foo", 2 => "bar");» can that be typed? «has %errors (int => Str) = (1 => "foo", 2 => "bar");^?

[15:54] *** pnu joined
[15:54] *** Ben_Goldberg joined
[15:56] <masak> [Tux]: `has Str %.errors{Int};`, I think.

[15:56] <FROGGS_> m: my $errors = :{ 1 => "foo", 2 => "bar" }; say $errors.perl

[15:56] <camelia> rakudo-moar 7e8d8a: OUTPUT«:{1 => "foo", 2 => "bar"}␤»

[15:56] <FROGGS_> m: my $errors = :{ 1 => "foo", 2 => "bar" }; say $errors.keys[0].WHAT

[15:56] <camelia> rakudo-moar 7e8d8a: OUTPUT«(Int)␤»

[15:56] <FROGGS_> m: my %errors{Int} = 1 => "foo", 2 => "bar"; say %errors.keys[0].WHAT

[15:56] <camelia> rakudo-moar 7e8d8a: OUTPUT«(Int)␤»

[15:57] <Kristien> m: class C { }; my %errors{C} = C.new => 'a', C.new => 'b'; say %errors.keys[0].WHAT

[15:57] <camelia> rakudo-moar 7e8d8a: OUTPUT«(C)␤»

[15:57] <Kristien> m: class C { }; my %errors{C} = C.new => 'a', C.new => 'b'; say %errors.WHAT

[15:57] <camelia> rakudo-moar 7e8d8a: OUTPUT«(Hash[Any,C])␤»

[15:57] <Kristien> Shiny, I thought hashes worked only with string keys.

[15:58] <FROGGS_> m: say "a" => b => c

[15:58] <camelia> rakudo-moar 7e8d8a: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/qmGmFUa_GB␤Undeclared routine:␤    c used at line 1␤␤»

[15:58] <FROGGS_> m: say "a" => b => "c"

[15:58] <camelia> rakudo-moar 7e8d8a: OUTPUT«a => b => c␤»

[15:58] <FROGGS_> m: say ("a" => b => "c").keys

[15:58] <camelia> rakudo-moar 7e8d8a: OUTPUT«a␤»

[15:58] <FROGGS_> m: say (("a" => b) => "c").keys

[15:58] <camelia> rakudo-moar 7e8d8a: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/Sn981WiJk2␤Undeclared routine:␤    b used at line 1␤␤»

[15:58] <FROGGS_> m: say (("a" => "b") => "c").keys

[15:58] <camelia> rakudo-moar 7e8d8a: OUTPUT«a => b␤»

[15:58] <FROGGS_> a pair as a key...

[15:59] <FROGGS_> everything can be a key nowadays :o)

[15:59] <FROGGS_> so you don't have to serialize something to be used as a key

[15:59] <masak> pairs are not good keys, though.

[16:00] <masak> they're mutable.

[16:01] <masak> m: my $p = a => 5; $p.value = 42; say $p

[16:01] <camelia> rakudo-moar 7e8d8a: OUTPUT«a => 42␤»

[16:01] <Kristien> m: say (("a" => "b") => "c")[("a" => "b")]

[16:01] <camelia> rakudo-moar 7e8d8a: OUTPUT«No such method 'Int' for invocant of type 'Pair'␤  in sub postcircumfix:<[ ]> at src/gen/m-CORE.setting:2869␤  in block <unit> at /tmp/Sam3vOxEkV:1␤␤»

[16:01] *** ggherdov joined
[16:01] <Kristien> oops lol

[16:01] <Kristien> m: say (("a" => "b") => "c"){("a" => "b")}

[16:01] <camelia> rakudo-moar 7e8d8a: OUTPUT«c␤»

[16:01] <Kristien> If pairs are mutable I don't agree with this behavior.

[16:02] <Kristien> m: say (("a" => "b") => "c").WHAT

[16:02] <camelia> rakudo-moar 7e8d8a: OUTPUT«(Pair)␤»

[16:02] <Kristien> Hmm.

[16:02] *** Ben_Goldberg left
[16:02] <Kristien> Oh right. I'm a fool.

[16:02] <[Tux]> int is not allowed, Int is

[16:02] *** Ben_Goldberg joined
[16:03] <[Tux]> m: Str %error{Int} = :{ 1 => "foo" };

[16:03] <camelia> rakudo-moar 7e8d8a: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/QgY1kjMr_W␤Undeclared routine:␤    error used at line 1␤␤»

[16:03] <[Tux]> m: my Str %error{Int} = :{ 1 => "foo" };

[16:03] <camelia> rakudo-moar 7e8d8a: OUTPUT«Saw 1 call to deprecated code during execution.␤================================================================================␤%error = itemized hash called at:␤  /tmp/9_zmuVNxtd, line 1␤Deprecated since v2014.7, will be removed with release v201…»

[16:03] *** ptc_p6 is now known as [ptc]

[16:03] <[Tux]> m: my Str %error{int} = :{ 1 => "foo" };

[16:03] <camelia> rakudo-moar 7e8d8a: OUTPUT«Type check failed in binding key; expected 'int' but got 'Int'␤  in method STORE_AT_KEY at src/gen/m-CORE.setting:10768␤  in block  at src/gen/m-CORE.setting:10398␤  in method STORE at src/gen/m-CORE.setting:10391␤  in block <unit> at /tmp/LAnR3Muz…»

[16:05] *** Ben_Goldberg left
[16:05] <Kristien> m: my $k = ("a" => "b"); say $k.WHAT; my $h = {("a" => "b") => "c"}; say $h.WHAT; say $h{$k}

[16:05] <camelia> rakudo-moar 7e8d8a: OUTPUT«(Pair)␤(Hash)␤c␤»

[16:05] *** Ben_Goldberg joined
[16:06] <Kristien> m: my $x = 'a' => 'b'; my $y = $x; $x.value = 'c'; say $x, $y;

[16:06] <camelia> rakudo-moar 7e8d8a: OUTPUT«a => ca => c␤»

[16:06] <Kristien> m: my $x = 'a' => 'b'; my $y = 'a' => 'c'; $x.value = 'c'; say $x === $y;

[16:06] <camelia> rakudo-moar 7e8d8a: OUTPUT«False␤»

[16:07] *** [ptc] left
[16:07] <Kristien> Does Hash not use WHICH for keys?

[16:08] *** [ptc] joined
[16:12] <skids> Default Hash is Str, Hash[Any] should use WHICH IIRC

[16:12] <Kristien> m: subset Nat of Int where { * >= 0 }; say -1 ~~ Nat

[16:12] <camelia> rakudo-moar 7e8d8a: OUTPUT«True␤»

[16:12] *** Ben_Goldberg left
[16:13] *** Ben_Goldberg joined
[16:14] <Kristien> weird

[16:14] *** [ptc] left
[16:14] <[Tux]> Saw 1 call to deprecated code during execution.

[16:14] <[Tux]> ================================================================================

[16:14] <[Tux]> %!errors = itemized hash called at:

[16:15] <[Tux]> Deprecated since v2014.7, will be removed with release v2015.7!

[16:15] <[Tux]> Please use %!errors = %(itemized hash) instead.

[16:15] <masak> [Tux]: did you use {} ?

[16:15] <Kristien> m: say :{('a'=>'b') => 1, ('a'=>'b') => 2}

[16:15] <camelia> rakudo-moar 7e8d8a: OUTPUT«(a => b) => 1, (a => b) => 2␤»

[16:15] <Kristien> So far so good.

[16:16] <skids> m: subset Nat of Int where * >= 0; say -1 ~~ Nat

[16:16] <camelia> rakudo-moar 7e8d8a: OUTPUT«False␤»

[16:16] <[Tux]> I used «has Str  %!errors{Int} = :{ 1 => "foo" };

[16:16] <Kristien> m: say :{('a'=>'b') => 1, ('a'=>'b') => 2}{('a' => 'b')}

[16:16] <camelia> rakudo-moar 7e8d8a: OUTPUT«(Any)␤»

[16:16] *** [ptc] joined
[16:16] <Kristien> ah, cool

[16:16] <skids> { * => 0 } is a closure that returns a closure.

[16:16] <Kristien> skids: aahh I ee

[16:16] <Kristien> I see*

[16:17] *** kaare_ left
[16:18] <[Tux]> m: my Str %e{Int} = :{ 1 => "foo" };

[16:18] <camelia> rakudo-moar 7e8d8a: OUTPUT«Saw 1 call to deprecated code during execution.␤================================================================================␤%e = itemized hash called at:␤  /tmp/m5E55mLkbx, line 1␤Deprecated since v2014.7, will be removed with release v2015.7!…»

[16:18] <FROGGS_> m: my Str %e{Int} = 1 => "foo";

[16:18] <camelia> rakudo-moar 7e8d8a: ( no output )

[16:18] <FROGGS_> that is redundant when you supply the shape

[16:18] <Kristien> Time for dinner. Byebye!

[16:18] <FROGGS_> o/

[16:18] *** Kristien left
[16:21] *** spider-mario left
[16:22] *** [ptc] left
[16:23] <[Tux]> FROGGS_++

[16:25] <masak> yeah, I suspected there was one hash too many in there.

[16:26] *** jluis_ left
[16:30] <[Tux]> so «warn "foo\n"» does not prevent noting the location of the warn as it does in perl5

[16:30] *** [ptc] joined
[16:30] *** [ptc] left
[16:31] <[Tux]> does perl6 have a warn that prints to catchable STDERR without noting the location?

[16:31] <dalek> doc: bacbf30 | moritz++ | lib/Type/Proc/Async.pod:

[16:31] <dalek> doc: Proc::Async: say, write and print return promises

[16:31] <dalek> doc: review: https://github.com/perl6/doc/commit/bacbf300ce

[16:31] *** [ptc] joined
[16:31] <moritz> [Tux]: note() prints to STDERR

[16:31] <moritz> but it's not an exception like warn

[16:31] *** [ptc] left
[16:32] <dalek> doc: b60db22 | moritz++ | lib/Type/Promise.pod:

[16:32] <dalek> doc: Try to fix formatting of a code block

[16:32] <dalek> doc: review: https://github.com/perl6/doc/commit/b60db22ab8

[16:32] *** [ptc] joined
[16:33] *** [ptc] left
[16:34] *** [ptc] joined
[16:34] <[Tux]> bummer

[16:34] <skids> So when browsing doc/ via github, the reaon some files do not display is because github renders with perl5 pod, right?

[16:34] <moritz> skids: correct

[16:35] <moritz> doc.perl6.org should display them correctly, though :-)

[16:36] <dalek> doc: bc676ad | moritz++ | README.md:

[16:36] <dalek> doc: README: add a note that github mis-displays the pod files

[16:36] <dalek> doc: review: https://github.com/perl6/doc/commit/bc676add00

[16:39] <skids> Any way to just get github to do plaintext for .pod?

[16:39] <moritz> no idea

[16:39] <rurban_> name it pod6

[16:39] <skids> Hmm....

[16:40] <rurban_> they won't interfer with this perl5 vs perl6 fight who got the better/right pod format

[16:40] <moritz> I see no fight

[16:40] <skids> I was thinking more a project-local setting.

[16:41] *** Kristien joined
[16:42] <Kristien> my %x = :{ ('a' => 'b') => 'c' }; say %x{('a' => 'b')};

[16:42] <Kristien> m: my %x = :{ ('a' => 'b') => 'c' }; say %x{('a' => 'b')};

[16:42] <camelia> rakudo-moar 5dd603: OUTPUT«c␤Saw 1 call to deprecated code during execution.␤================================================================================␤%x = itemized hash called at:␤  /tmp/3YhNbc4pTr, line 1␤Deprecated since v2014.7, will be removed with release v201…»

[16:43] <Kristien> m: my $x = :{ ('a' => 'b') => 'c' }; say $x{('a' => 'b')};

[16:43] <camelia> rakudo-moar 5dd603: OUTPUT«(Any)␤»

[16:43] <Kristien> Ok, good.

[16:44] *** [ptc] left
[16:44] *** [ptc] joined
[16:45] *** [ptc] left
[16:48] <Kristien> m: class A { has $.x = 1; submethod BUILD { } }; say A.new.x;

[16:48] <camelia> rakudo-moar 5dd603: OUTPUT«1␤»

[16:50] <[Tux]> what is the most readable/most common way to write qq{"abc\nc"} in perl6? I keep getting confused with all Q and <> variations

[16:51] <moritz> qq{"abc\nc"} is good, IMHO

[16:51] <[Tux]> it sees the \n not as newline /

[16:51] <moritz> oh

[16:51] <moritz> you don't want that?

[16:51] <moritz> q{"abc\nc"}

[16:51] *** Peter_R left
[16:51] <[Tux]> I want an embedded newline, as in perl5

[16:52] <moritz> m: say q{"abc\nc"

[16:52] <camelia> rakudo-moar 5dd603: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/GYGKJtq0R7␤Couldn't find terminator }␤at /tmp/GYGKJtq0R7:1␤------> [32msay q{"abc\nc"[33m⏏[31m<EOL>[0m␤»

[16:52] <moritz> m: say q{"abc\nc"}

[16:52] <camelia> rakudo-moar 5dd603: OUTPUT«"abc\nc"␤»

[16:52] <moritz> m: say qq{"abc\nc"}

[16:52] <camelia> rakudo-moar 5dd603: OUTPUT«"abc␤c"␤»

[16:52] <moritz> that one expand the newlne

[16:52] <[Tux]> weeeeeeeird

[16:52] *** [ptc] joined
[16:52] * [Tux] looks for another cause then

[16:53] <dalek> doc: 7c4d12d | moritz++ | lib/Type/Proc/Async.pod:

[16:53] <dalek> doc: More formatting fixes

[16:53] <dalek> doc: review: https://github.com/perl6/doc/commit/7c4d12d8b5

[16:55] <Kristien> m: my %h = 1, 2, 3, 4; say %h.WHAT; say map({ .WHAT }, %h.keys);

[16:55] <camelia> rakudo-moar 5dd603: OUTPUT«(Hash)␤(Str) (Str)␤»

[16:55] <Kristien> :S

[16:55] <moritz> fwiw I've now changed the doc.perl6.org updating cron job to run every 5 minutes, but only if it's not running (via flock (1))

[16:55] <moritz> and it only does something if there's a new commit

[16:55] <Kristien> m: my %h{Any} = 1, 2, 3, 4; say %h.WHAT; say map({ .WHAT }, %h.keys);

[16:55] <camelia> rakudo-moar 5dd603: OUTPUT«(Hash[Any,Any])␤(Int) (Int)␤»

[16:56] <Kristien> Ahh, it defaults to Str.

[16:56] <moritz> yes

[16:56] <Kristien> Why?

[16:56] <moritz> p5 legacy (and often still very useful behavior)

[16:57] <Kristien> OK.

[17:03] <dalek> doc: 0afbbe8 | moritz++ | lib/Type/Any.pod:

[17:03] <dalek> doc: A bit more documentation for class Any

[17:03] <dalek> doc: review: https://github.com/perl6/doc/commit/0afbbe8832

[17:04] <[ptc]> moritz: hi!  Have you got time for a couple of questions?

[17:04] <moritz> [ptc]: yes (though $family might demand some attention)

[17:05] <[ptc]> cool!  (and if you need to go, no worries)

[17:05] <[ptc]> um, I was looking at #28 on the docs repo; the one about syntax highlighting the code on the website

[17:06] <[ptc]> and was looking at what people had already mentioned, and found SyntaxHighlighter somewhat wanting in functionality

[17:06] <[ptc]> namely, it doesn't handle angle brackets nicely...

[17:06] <[ptc]> anyway, I noticed that pygments (pygments.org) handles Perl6.

[17:06] <moritz> as does vim

[17:07] <[ptc]> would it be ok to investigate that as an option for docs.perl.org for the syntax highlighting/

[17:07] <moritz> the problem with not doing it in the browser is that Perl 6 pod allows interweaving of code with markup

[17:07] <moritz> you can do things like

[17:07] <moritz> =being code :allow<B L>

[17:08] <moritz> and then B<...> and L<...> tags in the code produce bold/link HTML

[17:08] <moritz> but the rest is taken literally

[17:08] <[ptc]> aha

[17:08] <moritz> and it's hard to find hilighters that support that

[17:08] *** TimToady_ joined
[17:08] <moritz> I guess I should add that to the ticket

[17:09] *** ab5tract joined
[17:09] <[ptc]> dunno if pygments does that; they even advertise that they support perl6 :-)

[17:09] *** krunen joined
[17:09] <[ptc]> even though it's in python...

[17:09] <flussence> the pygments support was adaded to get perl6 to look nice on github (which then promptly dropped pygments entirely, for an in-house library with half the functionality...)

[17:09] *** xfix_ joined
[17:09] <flussence> s/adaded/added/

[17:10] *** risou_ joined
[17:10] *** Kristien_ joined
[17:10] *** petercom1and joined
[17:10] <[ptc]> I just wondered if it's worthwhile investigating using pygments instead of something like highlight.js or SyntaxHighlight for docs.perl.org

[17:11] <[ptc]> the problem I see is that one probably has to install pygments on the server, which might not be an option...

[17:11] <[ptc]> just trying to throw ideas around...

[17:11] <moritz> [ptc]: installing stuff on the server is an option

[17:11] *** huf joined
[17:11] <flussence> there's a high chance it's already there as part of some other dep...

[17:11] <moritz> [ptc]: I have root there :-)

[17:12] <flussence> (asciidoc uses it, and plenty of things use that)

[17:12] <moritz> [ptc]: it just shouldn't be something obscure which I end up having to maintain that

[17:12] <moritz> if it's debian-packaged, that makes it easier (but it's not a hard requirement)

[17:12] <Kristien_> m: say [1, 2, 3].perl, set(1, 2, 3).perl

[17:12] <camelia> rakudo-moar 5dd603: OUTPUT«[1, 2, 3]set(1,2,3)␤»

[17:12] <[ptc]> moritz: which was one thing that sort of made me a bit uneasy when looking at the other solutions

[17:13] <Kristien_> Inconsistent whitespace! :P

[17:13] *** rmgk_ joined
[17:13] *** rmgk left
[17:13] *** rmgk_ is now known as rmgk

[17:13] <moritz> [ptc]: understandable

[17:13] <[ptc]> moritz: it's in debian

[17:13] <moritz> python-pygments, python3-pygments

[17:13] <[ptc]> I'll look into it a bit more before you need to install anything

[17:14] <[ptc]> I'll push a feature branch when I'm ready and ping you so for feedback if that's ok

[17:14] <moritz> [ptc]: sure

[17:15] <[ptc]> moritz: cool, ta :-)

[17:15] <moritz> [ptc]: fwiw on my blog I use vim + Text::VimColor for hilighting Perl 6 code

[17:15] *** lestrrat left
[17:15] *** jakesyl left
[17:15] *** krunen_ left
[17:15] *** ab5tract_ left
[17:15] *** risou left
[17:15] *** Kristien left
[17:15] <moritz> [ptc]: but I'm not married to that solution by any means

[17:15] *** jakesyl joined
[17:15] *** xfix left
[17:15] *** Alina-malina left
[17:15] *** huf_ left
[17:15] *** kst left
[17:15] *** TimToady left
[17:17] <[ptc]> hrm, that might be a better option; didn't know about Text::VimColor

[17:17] <[ptc]> that might be easier, and a Perl-only solution

[17:18] <moritz> I've considered porting Text::VimColor to Perl 6

[17:18] <moritz> but haven't done it yet

[17:19] <[ptc]> I'll play with a couple of options, and then recommend something; I'd like to keep the admin-overhead as low as possible, and not have to use too many languages in building the html docs

[17:20] <flussence> heh, I just saw the pygments homepage... :)

[17:20] <flussence> (that list)

[17:33] *** IllvilJa left
[17:34] *** jantore left
[17:34] *** jantore joined
[17:37] <TimToady_> it's quite possible that szabgab's bug is the one we flushed out of spesh a week or two ago

[17:37] <TimToady_> that one that involved regex and negations

[17:38] *** IllvilJa joined
[17:39] *** espadrine_ joined
[17:42] *** ugexe_ is now known as ugexe

[17:43] *** sirdancealot left
[17:46] *** sirdancealot joined
[17:50] *** Vlavv_ left
[17:55] *** xfix_ is now known as xfix

[17:56] *** zakharyas left
[17:59] *** telex left
[18:00] *** telex joined
[18:02] *** Vlavv_ joined
[18:04] <dalek> doc: 13001a6 | paultcochrane++ | lib/Language/operators.pod:

[18:04] <dalek> doc: Add missing prepositon

[18:04] <dalek> doc: review: https://github.com/perl6/doc/commit/13001a6191

[18:04] <dalek> doc: 0b382b6 | paultcochrane++ | lib/Type/Any.pod:

[18:04] <dalek> doc: Merge branch 'master' of github.com:perl6/doc

[18:04] <dalek> doc: review: https://github.com/perl6/doc/commit/0b382b6b0c

[18:06] *** espadrine_ left
[18:16] <timotimo> could we spec UNDO phasers inside grammars/regexes to fire if we backtrack over a closure?

[18:19] *** Alina-malina joined
[18:26] <moritz> isn'T that already specced

[18:26] <Kristien_> If you use map in sink context, does it produce a list or is that optimised out?

[18:26] <moritz> Kristien_: I think it's optimized out

[18:31] <timotimo> dunno

[18:33] *** FROGGS__ joined
[18:34] *** Sqirrel left
[18:35] *** sirdancealot left
[18:36] *** Sqirrel joined
[18:36] *** lestrrat joined
[18:37] *** FROGGS_ left
[18:43] <TimToady_> it's treated as eager

[18:43] <TimToady_> but it doesn't have to actually return any values

[18:44] <TimToady_> part of the GLR is to make sure more things optimize that

[18:44] <TimToady_> it does have to run the block though, since it might have side effects

[18:45] <TimToady_> I think P5 goes as far as to put the inside of the map's block into void context

[18:56] <[ptc]> is it ok if I add '# vim: ft=perl6' at the bottom of files I come across, so that at least vim knows the file is perl6?

[18:56] <Kristien_> Install a proper ft detection plugin.

[18:57] <nwc10> use emacs? :-)

[18:57] <nwc10> (couldn't resist. I'm not sure if emacs does it any better.)

[18:58] <[ptc]> ok.  Just thought I'd ask before I start changing files willy-nilly

[18:59] <[ptc]> Kristien_: what would you recommend?

[18:59] <Kristien_> Or make the file extension pm6 instead of pm.

[19:01] <bartolin_> fwiw: most (if not all) test files from roast have '# vim: ft=perl6' as last line

[19:01] <TimToady_> [ptc]: you should generally also add et to expand tabs to spaces

[19:01] <TimToady_> expandtab and sw=4

[19:02] <[ptc]> bartolin_: yeah, that's one reason why I ask; I've seen files with, and several without

[19:02] <[ptc]> and have had the problem that some files aren't detected correctly as perl6

[19:02] <[ptc]> TimToady_: that's a good idea, I'll do that where there already is a vim coda

[19:03] *** rindolf left
[19:04] <TimToady_> a lot of rakudo files have vim modelines, but not many nqp files yet

[19:04] *** TimToady_ is now known as TimToady

[19:04] <bartolin_> +1 for adding vim modelines

[19:06] <itz_> perl6 vim tags generation would be nice too

[19:12] *** Mouq joined
[19:12] <japhb> While glancing through the backlog, I saw a discussion about what encoding high-codepoint strings to ASCII should do.  Did anyone suggest it returning Failure?  That seems the obvious choice for dial-able complaint level ....

[19:13] <geekosaur> that was the suggested default

[19:13] <geekosaur> hm, no, that was an exception

[19:13] <geekosaur> Failure might work

[19:14] <Kristien_> should be configurable though

[19:14] <japhb> Kristien_: 'use fatal'

[19:15] <Kristien_> no I mean whether it should fail or use a replacement character

[19:15] <Mouq> Also, would it make sense to remove accents? or is that outside the scope of .encode?

[19:16] <japhb> Kristien_: now *that* could be an adverb

[19:16] <Kristien_> "class FatRat is Cool does Rational[Int, Int]" reads funny

[19:16] <japhb> Mouq: I think that's outside the .encode scope -- that's more of a mapping than an encoding

[19:17] <japhb> (Insomuch as you expect .encode to be reversible)

[19:18] <japhb> Also, transliteration seems to me a very non-core thing, ripe for modules

[19:18] <japhb> (Because it would likely have to be language-dependent.)

[19:19] *** KCL_ joined
[19:19] <japhb> And the core setting provides mechanism and tools, not policy.

[19:19] <bartolin_> when I looked at the nqp code for sprintf I found that we are very strict (using nqp::die) when the number of used arguments in directives and the number of supplied arguments are different. on the other hand we are much less strict when at least one index is used. (examples follow)

[19:20] <bartolin_> m: say sprintf "%s",  "a", "b", "c"; # here we die

[19:20] <camelia> rakudo-moar 5dd603: OUTPUT«Too few directives: found 1, fewer than the 3 arguments after the format string␤␤»

[19:20] <bartolin_> m: say sprintf "%1$s",  "a", "b", "c"; # but here not

[19:20] <camelia> rakudo-moar 5dd603: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/7vj5HvGMVt␤Variable '$s' is not declared␤at /tmp/7vj5HvGMVt:1␤------> [32msay sprintf "%1$s[33m⏏[31m",  "a", "b", "c"; # but here not[0m␤    expecting any of:␤        postfix␤»

[19:20] <bartolin_> m: say sprintf q[%1$s],  "a", "b", "c"; # but here not

[19:20] <camelia> rakudo-moar 5dd603: OUTPUT«a␤»

[19:20] <bartolin_> m: say sprintf q[%5$s],  "a", "b", "c"; # and here neither

[19:20] <camelia> rakudo-moar 5dd603: OUTPUT«␤»

[19:21] <bartolin_> I was surprised about the latter two

[19:24] <japhb> bartolin_: I would think that's most likely a NYI, just because harder.

[19:26] <Mouq> moritz: I saw you were trying to parellelize doc/htmlify.p6. I have an old branch sitting around that converts all the processing into safe actions on Supplies. It still failed when I last tried to add start { } blocks, but I'll push the branch to github

[19:26] <bartolin_> japhb: yes, that's plausible. I wanted to make sure there is no other reason

[19:33] *** Rounin left
[19:33] <Kristien_> I think Rat.nude is quite an appropriate name.

[19:33] <Kristien_> It removes the wrapper, making the numbers nude :P

[19:39] <dalek> doc/supplied: 8d8fd30 | Mouq++ | / (3 files):

[19:39] <dalek> doc/supplied: WIP...

[19:39] <dalek> doc/supplied: review: https://github.com/perl6/doc/commit/8d8fd30ad3

[19:39] <dalek> doc/supplied: 5c25606 | Mouq++ | / (188 files):

[19:39] <dalek> doc/supplied: Merge branch 'master' into supplied

[19:39] <dalek> doc/supplied: 

[19:39] <dalek> doc/supplied: Conflicts:

[19:39] <dalek> doc/supplied: 	htmlify.p6

[19:39] <dalek> doc/supplied: review: https://github.com/perl6/doc/commit/5c25606f81

[19:40] <dalek> perl6-roast-data: a7f253b | coke++ | / (5 files):

[19:40] <dalek> perl6-roast-data: today (automated commit)

[19:40] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/a7f253bb47

[19:41] *** agentzh joined
[19:44] <dalek> rakudo/nom: 243c164 | lizmat++ | src/core/Any.pm:

[19:44] <dalek> rakudo/nom: Remove now superfluous test for < 0

[19:44] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/243c164ae9

[19:44] * japhb clears the last crashing bug out of a chunk of code he's been fighting for weeks, has a successful run, and has one of those "OMG -- I can't believe that actually WORKED!" moments

[19:46] <lizmat> japhb++

[19:47] <Kristien_> m: for 42 { .say }

[19:47] <camelia> rakudo-moar 5dd603: OUTPUT«42␤»

[19:47] <Kristien_> It'll be fun to implement something like Scala's case class feature.

[19:48] <dalek> Heuristic branch merge: pushed 31 commits to specs/newio by lizmat

[19:49] *** jmark left
[19:49] <vendethiel> Kristien_: well, "sealed" would be more interesting to implement :)

[19:49] <vendethiel> Kristien_: see timotimo's adt.p6

[19:49] <Kristien_> I don't like adt.p6 in that it does parsing stuff.

[19:51] <vendethiel> :(

[19:51] <Kristien_> But having immutable records with automatic .perl and .WHICH is very nice.

[19:53] <moritz> Mouq++

[19:55] <dalek> doc/supplied: ada0d13 | Mouq++ | / (2 files):

[19:55] <dalek> doc/supplied: Fix for latest Rakudo

[19:55] <dalek> doc/supplied: review: https://github.com/perl6/doc/commit/ada0d13f80

[19:56] <Kristien_> Maybe it can be achieved with just regular class syntax and some extra methods to generate construction, .perl and .WHICH

[19:59] <Kristien_> m: sub record($class) { $class.^add_method('perl', my method perl() { "TODO" }); }; class A { record(A) }; say A.new.perl

[19:59] <camelia> rakudo-moar 5dd603: OUTPUT«A.new()␤»

[19:59] <Kristien_> Something like that.

[19:59] <Kristien_> Except without the bug, lol.

[20:00] <Kristien_> compose seems to override perl

[20:00] <moritz> m: sub record($class) { $class.^add_method('perl', anon method perl() { 'TODO' }) }; class A { BEGIN record(A) }; say A.new.perl

[20:00] <camelia> rakudo-moar 5dd603: OUTPUT«===SORRY!===␤Type check failed in binding $class; expected 'Any' but got 'A'␤»

[20:00] <moritz> m: sub record(Mu $class) { $class.^add_method('perl', anon method perl() { 'TODO' }) }; class A { BEGIN record(A) }; say A.new.perl

[20:00] <camelia> rakudo-moar 5dd603: OUTPUT«TODO␤»

[20:01] <_4d47> just finished my first module, i'm happy have to share https://github.com/4d47/Tag 

[20:01] <Kristien_> ah cool

[20:01] <Kristien_> moritz: nice lemme expand on this stuff

[20:01] *** haxmeister joined
[20:02] <moritz> _4d47: nice

[20:03] <Kristien_> btw why is it add_method not add-method?

[20:03] <moritz> _4d47: see http://doc.perl6.org/language/modules for how to get it into the ecosystem

[20:04] <moritz> Kristien_: because jnthn++ came up with all the meta model :-)

[20:04] <moritz> Kristien_: there was a time when we said that low-level stuff should have _ in the name and high-level stuff -

[20:04] <Kristien_> ah OK

[20:04] <masak> oh, we've stopped saying that? pity.

[20:04] <Mouq> *low_level

[20:04] <moritz> Kristien_: that hasn't really panned out, but we don't have too much consistency as the result :(

[20:04] <moritz> masak: I'm not sure

[20:05] <vendethiel> Kristien_: seems like we could add another declarator instead of "class". like "record"

[20:05] <vendethiel> and you'd do `record Foo { has $!a; has !b; }`. or maybe `is immutable` on the class

[20:07] <moritz> m: multi trait_mod:<is>(Mu $class, :$record!) { say $class.^add_method('marker', anon method() { 'MARKED' } }; class Flurb is record { }; say Flurb.marker

[20:07] <camelia> rakudo-moar 5dd603: OUTPUT«[31m===[0mSORRY![31m===[0m␤Type 'method' is not declared. Did you mean 'Method'?␤at /tmp/qZfE1aWWFO:1␤------> [32m$class.^add_method('marker', anon method[33m⏏[31m() { 'MARKED' } }; class Flurb is record[0m␤Malformed anon␤at /tmp/qZfE1a…»

[20:07] <moritz> m: multi trait_mod:<is>(Mu $class, :$record!) { say $class.^add_method('marker', anon method () { 'MARKED' } }; class Flurb is record { }; say Flurb.marker

[20:07] <camelia> rakudo-moar 5dd603: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/_8vwqkKrmN␤Unable to parse expression in argument list; couldn't find final ')' ␤at /tmp/_8vwqkKrmN:1␤------> [32md('marker', anon method () { 'MARKED' } [33m⏏[31m}; class Flurb is record…»

[20:07] <moritz> m: multi trait_mod:<is>(Mu $class, :$record!) { say $class.^add_method('marker', anon method () { 'MARKED' } ) }; class Flurb is record { }; say Flurb.marker

[20:07] <camelia> rakudo-moar 5dd603: OUTPUT«<anon>␤MARKED␤»

[20:07] <moritz> (minus the first say)

[20:08] <vendethiel> m: class MetamodelX::RecordHOW is Metamodel::ClassHOW { }; my package EXPORTHOW { package DECLARE { constant record = MetamodelX::RecordHOW; } }; record X {};

[20:08] <camelia> rakudo-moar 5dd603: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/4QOLDnNaGt␤Unexpected block in infix position (two terms in a row, or previous statement missing semicolon?)␤at /tmp/4QOLDnNaGt:1␤------> [32m = MetamodelX::RecordHOW; } }; record X [33m⏏…»

[20:09] <Kristien_> https://gist.github.com/rightfold/9d119b8ef0aa5e284b54

[20:09] <Kristien_> awesome :)

[20:09] <dalek> doc: de93815 | moritz++ | lib/Type/Mu.pod:

[20:09] <dalek> doc: Small improvements to the Mu docs

[20:09] <dalek> doc: review: https://github.com/perl6/doc/commit/de9381505e

[20:09] <dalek> doc: 2148faf | moritz++ | lib/Type/Proc/Async.pod:

[20:09] <dalek> doc: Proc::Async.say now calls .gist, just like regular &say. lizmat++

[20:09] <dalek> doc: review: https://github.com/perl6/doc/commit/2148fafa99

[20:09] <Kristien_> Now only new with positional agruments, and WHICH

[20:10] <Kristien_> and copy to create a new instance with some attributes replaced, e.g. $person.copy(:name<vendethiel>)

[20:10] <moritz> Kristien_: .clone already does that

[20:11] <Kristien_> holy shit!

[20:11] <moritz> Kristien_: http://doc.perl6.org/routine/clone

[20:12] <Kristien_> oh wait, perl is already there

[20:13] <Kristien_> only WHICH, then

[20:13] <moritz> isn't it funny when you start to extend stuff, and find it's already there? :-)

[20:14] <Kristien_> yeah

[20:14] <Kristien_> can't get it to prevent compose from adding WHICH though

[20:14] <moritz> call record at BEGIN time

[20:14] <moritz> or use a trait, which automatically runs ASAP

[20:15] <moritz> http://irclog.perlgeek.de/perl6/2015-01-25#i_10002270

[20:15] <Kristien_> oh neat

[20:16] <masak> semi-cogent thought about 'is parsed': someone suggested the other day that 'is parsed' be further separated from the macro itself, and the two communicate over an interface or something.

[20:16] <vendethiel> Kristien_: or create a declarator: https://github.com/jnthn/oo-monitors/blob/master/lib/OO/Monitors.pm :P

[20:17] <masak> but if we look inside the compiler, regex and code are not just combined into one, they are *interleaved*.

[20:17] <Kristien_> vendethiel: is that the correct link?

[20:17] <vendethiel> Kristien_: yes, it's exporting the "monitor" keyword, see at the bottom

[20:17] <Kristien_> oh right

[20:17] <Kristien_> shiny

[20:17] <lizmat> m: my $h = :{}; my $p = (a => 42); $h{$p} = 63; say $h{$p}:p; $p.value = 17; say $h{$p}:p; say $h.pairs   # is this intended / desired bahaviour ?

[20:17] <camelia> rakudo-moar 5dd603: OUTPUT«(a => 42) => 63␤(a => 17) => 63␤(a => 17) => 63␤»

[20:18] <vendethiel> Kristien_: https://github.com/jnthn/oo-monitors/blob/master/t/basic.t then in the test he uses "monitor Classname"

[20:18] <masak> (sometimes I feel that the factoring with actions is a wee bit overgeneralized. I get the "you can have N action classes to 1 grammar!" advantage, but normally I just have 1-to-1.)

[20:18] <vendethiel> masak: I think is parsed's syntax should really look like sweetjs :-)

[20:18] <vendethiel> (which is just racket templates)

[20:19] <masak> regex and code are interleaved in the sense that we really like to check consistency ASAP, which often means right in the middle of a parse.

[20:20] <dalek> rakudo/nom: 403b0f0 | moritz++ | src/core/Proc/Async.pm:

[20:20] <dalek> rakudo/nom: Fix wording of error message

[20:20] <dalek> rakudo/nom: 

[20:20] <dalek> rakudo/nom: at least I do not think "process" made sense here, when it is about handles/streams

[20:20] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/403b0f0687

[20:21] <lizmat> moritz:  but but, it's "Proc" async ?   

[20:22] <moritz> lizmat: I don't understand your objection

[20:23] <lizmat> IO::Async has a similar error, no?

[20:23] <lizmat> IO::Socket::Async I mean

[20:23] <moritz> lizmat: haven't document that one yet :-)

[20:23] <moritz> so I don't know

[20:24] <lizmat> hmmm...  doesn't seem to have that check  :-(

[20:24] <lizmat> it probably should

[20:24] <moritz> does the "process" in "Can only tap one of chars or bytes supply for process stdout" make sense?

[20:24] <lizmat> and then maybe it's important to see in the message whether it was a process or a socket

[20:24] <moritz> stdout is not a process

[20:25] <moritz> oh

[20:26] <moritz> but IO::Socke::Async won't have stdout/stderr, will it?

[20:26] <lizmat> it has a chars_supply/bytes_supply

[20:27] <lizmat> and I also guess we don't want to do both at the same time there either

[20:27] <moritz> yes, but my point is that the error message won't be amibguous, because it doesn't say "stdout" or "stderr" in the error message

[20:28] <lizmat> ok  :-)

[20:28] <dalek> doc: d93a043 | moritz++ | lib/Type/ (2 files):

[20:28] <dalek> doc: Document X::Proc::Async::CharsOrBytes

[20:28] <dalek> doc: review: https://github.com/perl6/doc/commit/d93a0430b0

[20:29] <moritz> Proc::Async is about 280 lines of code (including the exception classes), and it took me basically all the hacking time of the weekend to document it

[20:29] <moritz> now I think the documentation is complete, in the sense that it covers all features

[20:29] <Kristien_> K.

[20:29] <Mouq> masak: macro foo ($a, $b) { #`[code goes here] }; { parsed foo { <.sym> <.ws> (<.num>)(\S+) }; foo 4inches }; parsed foo {  (<.num>) <.ws> in unit <.ws> (<.EXPR>) }; 4 in unit "inches"

[20:29] *** robins left
[20:31] <moritz> Mouq: you skipped the interesting part: what does the code look like

[20:31] *** jmark joined
[20:31] *** jmark left
[20:31] *** robinsmidsrod joined
[20:31] <moritz> 'cause it will have to use the captures from parse to be useful

[20:32] <Kristien_> vendethiel: this works: https://gist.github.com/rightfold/fefad5f66e7654e1a0e5

[20:32] <Kristien_> I only have to fix WHICH to return some proper unique value but I can't do that now since ObjAt.new segfaults

[20:33] <moritz> I guess we should fix that then :-)

[20:33] <masak> ok, the easiest way to make 'is parsed' an code interleave I guess is just using the code block feature of regexes.

[20:34] <masak> and*

[20:34] <Mouq> moritz: True... :)

[20:34] <moritz> m: sub f(str $x) { say $x }; my Str $x = 'foo'; f $x

[20:34] <camelia> rakudo-moar 5dd603: OUTPUT«foo␤»

[20:35] <masak> yeah, putting the parse after the macro code is surely the wrong way forward.

[20:35] *** darutoko left
[20:35] <moritz> .oO( why did I just want to write 'tmux attack'? )

[20:35] <Mouq> m: sub infix:<in unit> (|) { "test" }; say 4 in unit "meters" # nbsp to the rescue

[20:35] <camelia> rakudo-moar 243c16: OUTPUT«test␤»

[20:36] <moritz> that's supposed to not work

[20:36] <Mouq> Oh, wait.. it works with regular space too

[20:36] <moritz> operators my not contain whitespace

[20:36] <Mouq> Yeah, that's not so good

[20:38] <dalek> rakudo/nom: cb5bb33 | moritz++ | src/core/ObjAt.pm:

[20:38] <dalek> rakudo/nom: Make ObjAt.new(str) work

[20:38] <dalek> rakudo/nom: 

[20:38] <dalek> rakudo/nom: Kristien_++ for reporting it as not working

[20:38] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/cb5bb33c1b

[20:38] <moritz> Kristien_: there you go

[20:39] <Kristien_> shiny, thanks

[20:39] <Kristien_> will try it tomorrow, no time to reinstall rakudo right now

[20:39] <moritz> Kristien_: have the appropriate amount of fun!

[20:40] *** brrt joined
[20:40] <vendethiel> Kristien_: nice :-)

[20:41] <Kristien_> vendethiel: I noticed your comment on GH :P

[20:41] *** _4d47 left
[20:42] <Kristien_> The overview section is just to make fun of CoffeeScript, though. :P

[20:42] *** ggherdov left
[20:42] *** pnu left
[20:44] <dalek> roast: 7d17de6 | moritz++ | S32-str/sprintf.t:

[20:44] <dalek> roast: unfudge now passing test, bartolin++

[20:44] <dalek> roast: review: https://github.com/perl6/roast/commit/7d17de6344

[20:47] *** kst joined
[20:48] *** brrt left
[20:48] <bartolin_> moritz: won't that require a nqp bump to work?

[20:49] <moritz> bartolin_: it passed for me, and I'm on the recommended nqp version

[20:49] <moritz> (I think :-)

[20:50] <moritz> $ ./install/bin/nqp-m --version

[20:50] <moritz> This is nqp version 2015.01-2-g4589d81 built on MoarVM version 2015.01-5-ga29eaa9

[20:50] <moritz> $ cat tools/build/NQP_REVISION 

[20:50] <moritz> 2015.01-2-g4589d81

[20:50] <moritz> oh

[20:50] <moritz> where did that come from?

[20:51] <moritz> bartolin_: spectesting with nqp master now, and if it's fine, I'll bump the NQP_REVISION

[20:51] <Kristien_> Is it possible to create custom phasers?

[20:51] <bartolin_> moritz++

[20:52] *** Kristien_ is now known as Kristien

[20:52] <moritz> Kristien_: I don't think so, because phasers most usually hook in some compiler code or even backend-specific codegen to get fired

[20:52] <Kristien> OK.

[20:52] <moritz> Kristien: what phase did you have in mind?

[20:52] <Kristien> just wondering

[20:52] <jnthn> Well, if you are going to write the code to fire them it's do-able I guess.

[20:52] <yoleaux> 08:37Z <moritz> jnthn: is there a good reason to keep $!started in Proc::Async private? sounds like potentially useful information for the caller

[20:53] <Kristien> No specific use-case in mind.

[20:53] <dalek> rakudo/nom: 00c3fae | moritz++ | tools/build/NQP_REVISION:

[20:53] <dalek> rakudo/nom: Bump NQP revision.

[20:53] <dalek> rakudo/nom: 

[20:53] <dalek> rakudo/nom: gives us an sprintf error message fix, free beer and world peace

[20:53] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/00c3faed74

[20:53] *** jluis_ joined
[20:54] <moritz> now I did the 'git push' without waiting for the spectest to finish. The muscle memory is strong in this one...

[20:54] *** haxmeister left
[20:54] <jnthn> m: sub foo() { }; &foo.add_phaser('FOO', { say "lol" }); &foo.fire_phasers('FOO');

[20:54] <camelia> rakudo-moar 243c16: OUTPUT«lol␤»

[20:54] <Kristien> make it a pre-push hook

[20:55] <Kristien> jnthn: lol

[20:55] <dalek> ecosystem: d73f217 | (Mathieu Gagnon)++ | META.list:

[20:55] <dalek> ecosystem: Add Tag module

[20:55] <dalek> ecosystem: review: https://github.com/perl6/ecosystem/commit/d73f217bc4

[20:55] <dalek> ecosystem: c63af83 | moritz++ | META.list:

[20:55] <dalek> ecosystem: Merge pull request #39 from 4d47/master

[20:55] <dalek> ecosystem: 

[20:55] <dalek> ecosystem: Add Tag module

[20:55] <dalek> ecosystem: review: https://github.com/perl6/ecosystem/commit/c63af832ba

[20:55] <jnthn> You can store any phasers you want on the block. But yeah, a bunch lead to some code-gen in the surroudning scope.

[20:56] <jnthn> If you can arrnage for that to happen then something should be possible in slang land...

[20:56] <jnthn> moritz: No strong reason; do you have a use-case in mind?

[20:58] <moritz> jnthn: not really; just that if you juggle with multiple Proc::Async objects, it likely helps to get that piece of information

[20:59] <moritz> or you can write  sub f(Proc::Async:D $proc where { .started }) { ... }

[20:59] *** agentzh left
[20:59] <moritz> to declare that you only want started processes there

[20:59] <moritz> just like $.w is public

[20:59] <moritz> (which I haven't documented yet!)

[21:01] <jnthn> Yeah, no objects to making it publicly readable

[21:04] *** PZt joined
[21:04] <Kristien> m: sub f { END { say "hi" } }; f; f; f;

[21:04] <camelia> rakudo-moar 243c16: OUTPUT«hi␤»

[21:06] <dalek> roast: 0630ae1 | usev6++ | S (2 files):

[21:06] <dalek> roast: Unfudge passing tests

[21:06] <dalek> roast: review: https://github.com/perl6/roast/commit/0630ae1768

[21:13] <dalek> rakudo/nom: 225cf21 | moritz++ | src/core/Proc/Async.pm:

[21:13] <dalek> rakudo/nom: Proc::Async: make $!started public

[21:13] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/225cf21c92

[21:13] <dalek> doc: ccb0946 | moritz++ | lib/Type/Proc/Async.pod:

[21:13] <dalek> doc: document .w, .started

[21:13] <dalek> doc: review: https://github.com/perl6/doc/commit/ccb0946d80

[21:16] <dalek> roast: 8c487c0 | moritz++ | S17-procasync/basic.t:

[21:16] <dalek> roast: Test Proc::Async.w and .started

[21:16] <dalek> roast: review: https://github.com/perl6/roast/commit/8c487c08d1

[21:21] <dalek> doc: d742c13 | moritz++ | lib/Type/Proc/Async.pod:

[21:21] <dalek> doc: Fix typo

[21:21] <dalek> doc: review: https://github.com/perl6/doc/commit/d742c134c5

[21:22] <[ptc]> moritz: I got the syntax highlighting working with pygments

[21:22] <[ptc]> the solution is (at present) quite ugly, however can be improved; I just don't yet know how

[21:23] <moritz> [ptc]: push it to a branch, please

[21:23] <[ptc]> unfortunately, I had to patch Pod::To::HTML and doc...  should I push both branches?  Or should I send patches?

[21:23] <[ptc]> is it ok to push to a branch in the main repo, or should I do it on my own github account

[21:24] <[ptc]> (sorry, still learning the ropes of the project)

[21:24] <moritz> [ptc]: pull request for Pod::To::HTML (it's not in the perl6 org)

[21:24] <moritz> [ptc]: and a branch for doc

[21:25] <[ptc]> moritz: atually Pod::To::HTML is in the perl6 org...  I pushed code to it today...

[21:25] <moritz> [ptc]: oh, then a branch is fine

[21:25] <dalek> doc/add_pygments_highlighting: d7e1907 | paultcochrane++ | html/css/pygments.css:

[21:25] <dalek> doc/add_pygments_highlighting: Add pygments css colour definitions file

[21:25] <dalek> doc/add_pygments_highlighting: review: https://github.com/perl6/doc/commit/d7e1907306

[21:25] <dalek> doc/add_pygments_highlighting: 776d3f4 | paultcochrane++ | template/head.html:

[21:25] <dalek> doc/add_pygments_highlighting: Load pygments style definitions

[21:25] <[ptc]> ok

[21:25] <dalek> doc/add_pygments_highlighting: review: https://github.com/perl6/doc/commit/776d3f4168

[21:25] <moritz> [ptc]: and my memory is out of date :-)

[21:27] <moritz> [ptc]: you already know your way around the ecosystem better than me, it seems :-)

[21:27] *** xfix left
[21:27] <[ptc]> moritz: still learning, I'm afraid.  But getting there :-)

[21:28] <[ptc]> moritz: I used `perl6 -Ipath/to/Pod-To-HTML/lib/ htmlify.p6` to test

[21:28] *** kjs_ joined
[21:28] <[ptc]> the output looks good, and I don't know if it slows down the htmlify program that much

[21:29] <moritz> [ptc]: I see what you mean about it being ugly. I'd suggest to patch Pod::To::HTML to accept a callback for code / preformatted text, and then set that callback in htmlify

[21:29] <[ptc]> it basically runs a qqx on pygmentize, the output of which then replaces what used to be simply in a <pre>

[21:29] <moritz> [ptc]: because making Pod::To::HTML generally depend on pygmentize is a bad idea

[21:29] <[ptc]> agreed

[21:29] <[ptc]> it's really just a proof of concept

[21:29] *** kjs_ left
[21:30] <moritz> aye

[21:30] *** kjs_ joined
[21:32] <b2gills> m: sub test ( :named($) where *.defined ){...}; test()

[21:32] <camelia> rakudo-moar 243c16: OUTPUT«Constraint type check failed for parameter '<anon>'␤  in sub test at /tmp/IkGVAotpuW:1␤  in block <unit> at /tmp/IkGVAotpuW:1␤␤»

[21:32] <b2gills> m: sub test ( :named($)! where *.defined ){...}; test()

[21:32] <camelia> rakudo-moar 243c16: OUTPUT«Required named parameter 'named' not passed␤  in sub test at /tmp/fVCYwjA8VD:1␤  in block <unit> at /tmp/fVCYwjA8VD:1␤␤»

[21:32] <[ptc]> I'd like to know how to pass the contents of a pod node out to a qqx without having to store the output in a temporary file first

[21:33] <[ptc]> unfortunately, couldn't work that one out, hopefully someone here as an idea

[21:34] <b2gills> Perhaps you could try Proc::Async instead

[21:34] <[ptc]> anyway, I'll head off

[21:34] <[ptc]> gn8!

[21:35] *** FROGGS[mobile] left
[21:36] <moritz> aye, Proc::Async works

[21:38] *** [ptc] left
[21:39] *** Kristien left
[21:40] *** Kristien joined
[21:42] *** jluis_ left
[21:47] *** agentzh joined
[21:51] *** mvuets left
[21:51] <dalek> rakudo/nom: e34a9c0 | lizmat++ | src/core/control.pm:

[21:51] <dalek> rakudo/nom: Add CLONE-HASH-DECONTAINERIZED helper sub

[21:51] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/e34a9c0b27

[22:00] *** Kristien left
[22:02] *** jack_rabbit joined
[22:03] <dalek> rakudo-star-daily: 50edfb8 | coke++ | log/ (9 files):

[22:03] <dalek> rakudo-star-daily: today (automated commit)

[22:03] <dalek> rakudo-star-daily: review: https://github.com/coke/rakudo-star-daily/commit/50edfb8e1a

[22:06] *** zby_home joined
[22:07] <Mouq> https://gist.github.com/Mouq/10d5b19f7869add9e9e0

[22:08] <Mouq> (bug in Supply.categorize)

[22:14] * Mouq rakudobugs it

[22:14] *** kjs_ left
[22:14] <lizmat> will look at it tomorrow, unless someone beats me to it

[22:14] <ab5tract> still running into some weirdness with regexes and escapes sequences :( https://gist.github.com/ab5tract/4961802803d3e5fb489d

[22:16] <moritz> Mouq: should it call .done of the sub-supplies before or after the outer?

[22:17] <ab5tract> m: my @a = ("55x77" ~~ rx{(\d\d)(x)(\d\d)}).values; @a.say

[22:17] <camelia> rakudo-moar 243c16: OUTPUT«｢55｣ ｢x｣ ｢77｣ ␤»

[22:18] *** doobi-sham-5008 joined
[22:18] <ab5tract> m: my @a = ("55x77" ~~ rx{(\d\d)(x)(\d\d)}).values.map: { ~$_ }; @a.perl.say

[22:18] <camelia> rakudo-moar 243c16: OUTPUT«Array.new("55", "x", "77", "")␤»

[22:19] *** zby_home left
[22:19] <skids> r: sub f (|c) { c.perl.say }; f(1, b => 3); f(1, "b" => 3); \(1, "b" => 3).perl.say; # Should Capture literals use Capture syntax rules?

[22:19] <camelia> rakudo-{parrot,moar} 243c16: OUTPUT«Capture.new(list => (1,), hash => {"b" => 3})␤Capture.new(list => (1, "b" => 3,))␤Capture.new(list => (1,), hash => {"b" => 3})␤»

[22:19] <ab5tract> what's with the extra element, and i'm guessing there is a better way to get the "just the strings please" of regex captures? 

[22:20] <timotimo> m: say("55x77" ~~ rx{(\d\d)(x)(\d\d)})

[22:20] <camelia> rakudo-moar 243c16: OUTPUT«｢55x77｣␤ 0 => ｢55｣␤ 1 => ｢x｣␤ 2 => ｢77｣␤»

[22:20] <Mouq> I'd say after, since that seems to be the case for other supply-generating methods, but I don't really know. Although if you're relying on the order that .done is called on Supplies, you're probably doing something wrong :P

[22:20] <timotimo> m: say(("55x77" ~~ rx{(\d\d)(x)(\d\d)}).values.perl)

[22:20] <camelia> rakudo-moar 243c16: OUTPUT«(Match.new(orig => "55x77", from => 0, to => 2, ast => Any, list => ().list, hash => EnumMap.new()), Match.new(orig => "55x77", from => 2, to => 3, ast => Any, list => ().list, hash => EnumMap.new()), Match.new(orig => "55x77", from => 3, to => 5, ast => A…»

[22:21] <timotimo> m: say(("55x77" ~~ rx{(\d\d)(x)(\d\d)}).values>>.Str.perl)

[22:21] <camelia> rakudo-moar 243c16: OUTPUT«("55", "x", "77", "")␤»

[22:21] <ab5tract> ah, yes.. >>.Str, should have thought of that

[22:21] * timotimo is not sure where that final element comes from, something about .values being wonky?

[22:21] <timotimo> m: say(("55x77" ~~ rx{(\d\d)(x)(\d\d)}).values[*-1].perl)

[22:21] <camelia> rakudo-moar 243c16: OUTPUT«[]␤»

[22:22] <timotimo> m: say(("55x77" ~~ rx{(\d\d)(x)(\d\d)}).values[*-1])

[22:22] <camelia> rakudo-moar 243c16: OUTPUT«␤»

[22:22] <timotimo> m: say(("55x77" ~~ rx{(\d\d)(x)(\d\d)}).values[*-2])

[22:22] <camelia> rakudo-moar 243c16: OUTPUT«｢77｣␤»

[22:22] <timotimo> i got nothin'

[22:22] <timotimo> except bedtime

[22:22] <timotimo> i definitely gots the bedtime

[22:22] <ab5tract> :(

[22:22] <ab5tract> ye

[22:22] *** brrt joined
[22:22] <lizmat> good night timotimo!

[22:22] <ab5tract> i'm about there too

[22:26] <ab5tract> it's just weird that i can print the escape sequences after its been processed, and it just prints back. if i write that output back in manually as an argument to print, it moves the cursor

[22:26] *** doobi-sham-5008 left
[22:30] <ab5tract> m: my @a = ("55x77" ~~ rx{(\d\d)(x)(\d\d)}).values>>.Str;  @a.join.say; @a.join.comb.elems.say

[22:30] <camelia> rakudo-moar 243c16: OUTPUT«55x77␤5␤»

[22:31] <ab5tract> invisible characters :(

[22:31] <dalek> rakudo/nom: a1c8b97 | lizmat++ | src/core/ (3 files):

[22:31] <dalek> rakudo/nom: Some more uses of CLONE-HASH-DECONTAINERIZED()

[22:31] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/a1c8b97744

[22:32] *** brrt left
[22:34] <moritz> Mouq: I seem to have a fix for you; waiting for spectests...

[22:34] *** ggherdov joined
[22:35] *** pnu joined
[22:36] <moritz> fwiw I've installed mosh on hack.p6c.org

[22:36] <moritz> might interest some of you :-)

[22:38] *** ilbot3 left
[22:38] <dalek> rakudo/nom: 0c524e3 | moritz++ | src/core/Proc/Async.pm:

[22:38] <dalek> rakudo/nom: Throw an X::OS from Proc::Async if the external command could not be launched

[22:38] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/0c524e32ca

[22:38] <dalek> rakudo/nom: 94501a6 | moritz++ | src/core/SupplyOperations.pm:

[22:38] <dalek> rakudo/nom: Supply.categorize: distribute .done to sub-supplies

[22:38] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/94501a6fca

[22:38] *** ilbot3 joined
[22:43] <Mouq> moritz++

[22:43] * Mouq rebuilds

[22:46] <lizmat> moritz: wouldn't that not also need to be done for Supply.classify ?

[22:49] <dalek> rakudo/nom: 8d7542d | lizmat++ | src/core/control.pm:

[22:49] <dalek> rakudo/nom: Create helper sub CLONE-LIST-DECONTAINERIZED

[22:49] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/8d7542d74e

[22:52] *** moomin-aba joined
[22:52] *** moomin-aba left
[22:53] *** ken joined
[22:53] *** ken is now known as Guest13945

[22:54] <Guest13945> Hey

[22:54] *** Guest13945 left
[22:54] *** brrt joined
[22:54] *** fil_ joined
[22:55] <fil_> I've been staring at this code all day: http://rosettacode.org/wiki/Multifactorial#Perl_6

[22:55] <fil_> specifically sub mfact($n, :$degree = 1) { [*] $n, *-$degree ...^ * <= 0 }

[22:55] <fil_> I don't understand the line in the braces

[22:55] <fil_> I assume that is a "whatever" star?

[22:55] <masak> fil_: [*] means "multiply all these things"

[22:55] <dalek> rakudo/nom: 371434f | lizmat++ | src/core/Proc/Async.pm:

[22:55] <dalek> rakudo/nom: One more use of CLONE-LIST-DECONTAINERIZED

[22:55] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/371434faeb

[22:56] <masak> fil_: the `...` creates a sequence of values.

[22:56] <lizmat> m: say [+] 1,2,3,4,5

[22:56] <camelia> rakudo-moar 243c16: OUTPUT«15␤»

[22:56] <masak> fil_: and the `*-$degree` comes out meaning "subtract $degree from the previous value"

[22:56] <lizmat> and on that note, good night, #perl6!

[22:56] <masak> fil_: the `^` on the `...^` means "discard the last value"

[22:57] <masak> fil_: the `* <= 0` means "keep doing the sequence until we find a value that less than or equal to 0"

[22:57] <masak> (and then don't include that value in the sequence, due to `^`)

[22:57] <fil_> so you can use a conditional in place of a limit value?

[22:57] *** Ben_Goldberg left
[22:58] *** Ben_Goldberg joined
[22:58] <fil_> I think part of my confusion is that * is overloaded in the statement

[22:58] <Ovid_> m: sub f(Int $x) {...}; f(3.0)

[22:58] <camelia> rakudo-moar 243c16: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/Y3anEyM3JH␤Calling 'f' will never work with argument types (Rat)␤    Expected: :(Int $x)␤at /tmp/Y3anEyM3JH:1␤------> [32msub f(Int $x) {...}; [33m⏏[31mf(3.0)[0m␤»

[22:58] <masak> fil_: you can use anything that can be matched against. `* <= 0` just happens to create a little runnable thing that returns a boolean when called.

[22:58] <fil_> within the [*] it means multiply, but then later it is a whatever star

[22:58] <masak> m: my $c = (* <= 0); say $c(-4); say $c(0); say $c(7)

[22:58] <camelia> rakudo-moar 243c16: OUTPUT«True␤True␤False␤»

[22:59] <masak> (parentheses for clarity; not needed)

[22:59] <masak> fil_: after a while you learn to distinguish by context.

[22:59] <masak> fil_: there's `*` as an operator, which just means multiplication.

[22:59] <Ovid_> Since 3.0 == 3 (not ===), is it fair to say that the hard-coded Rat 3.0 can’t match an Int?

[22:59] <masak> fil_: and then there's `*` as a term, which is pronounced "whatever" and has a number of useful semantics.

[23:00] <fil_> ok let me try this.

[23:00] <fil_> { [*] $n, *-$degree ...^ * <= 0 }

[23:00] <masak> Ovid_: I think so, yes.

[23:00] <fil_> [*] multiply what follows.

[23:00] <masak> Ovid_: provided I understand your question.

[23:01] <Ovid_> I sort of agree they shouldn’t match, but it looks a touch odd.

[23:01] <fil_> $n, *-$degree ..^ * <=0 means start with $n, then a term minus degree, then keep subtracting degree until you are <= 0 dropping last term

[23:01] <masak> m: my $degree = 5; my $n = 20; say $n, *-$degree ...^ * <= 0

[23:01] <camelia> rakudo-moar 243c16: OUTPUT«20 15 10 5␤»

[23:01] <masak> fil_: ^^ maybe helps

[23:01] <masak> fil_: yes, you got it just right.

[23:01] <fil_> the part that's a bit confusing is the $n, *-$degree part

[23:01] <fil_> those are the first two terms in the sequence?

[23:01] <masak> fil_: yes, with the second one being a bit special.

[23:02] <masak> fil_: since it's also a WhateverCode, just like the stopping criterion.

[23:02] <masak> m: my $degree = 5; say (* - $degree).^name

[23:02] <camelia> rakudo-moar 243c16: OUTPUT«WhateverCode.new()␤»

[23:02] <fil_> there's a REPL here!  Coolness!

[23:02] <masak> we lovez our camelia.

[23:03] <Mouq> m: say 20, -> $i { $i - 5 } ... ^ -> $n { $n <= 0 }

[23:03] <camelia> rakudo-moar 243c16: OUTPUT«Cannot call 'Numeric'; none of these signatures match:␤:(Mu:U \v: *%_)␤  in sub prefix:<^> at src/gen/m-CORE.setting:8468␤  in block <unit> at /tmp/vEqOSIpuun:1␤␤»

[23:03] <Mouq> Err

[23:03] <Mouq> m: say 20, -> $i { $i - 5 } ...^ -> $n { $n <= 0 }

[23:03] <camelia> rakudo-moar 243c16: OUTPUT«20 15 10 5␤»

[23:04] <fil_> m: 10, 9, *-1 ... 0

[23:04] <camelia> rakudo-moar 243c16: ( no output )

[23:04] <fil_> m: 10, *-1 ... 0

[23:04] <camelia> rakudo-moar 243c16: ( no output )

[23:04] <Mouq> fil_: "say "

[23:04] <fil_> m: say 10, 9, *-1 ... 0

[23:04] <camelia> rakudo-moar 243c16: OUTPUT«10 9 8 7 6 5 4 3 2 1 0␤»

[23:04] <fil_> so the whatever term doesn't have to be the first term

[23:04] <fil_> but I assume it has to be the last one?

[23:04] <masak> it has to be the term before the `...`

[23:04] <fil_> aha

[23:05] <masak> but you can have several `...`, so you can sort of "steer" the sequence if you need to.

[23:05] <masak> m: say 1, 2 ... 10, 20 ... 100

[23:05] <camelia> rakudo-moar 243c16: OUTPUT«1 2 3 4 5 6 7 8 9 10 20 30 40 50 60 70 80 90 100␤»

[23:05] <Mouq> m: my @fib := 1, 1, * + * ... *; say @fib[^10]

[23:05] <camelia> rakudo-moar 243c16: OUTPUT«1 1 2 3 5 8 13 21 34 55␤»

[23:05] <fil_> how does [*] work?  It takes any infix operator?

[23:06] <masak> yep.

[23:06] <masak> m: say [&&] True, False, True

[23:06] <camelia> rakudo-moar 243c16: OUTPUT«False␤»

[23:06] <masak> m: say [&&] True, True, True

[23:06] <camelia> rakudo-moar 243c16: OUTPUT«True␤»

[23:06] <masak> fil_: we call them "metaoperators". we have a couple of them, besides [op]

[23:07] <fil_> I'm getting concerned masak that artificial intelligence has been discovered, but it's being kept a secret.  You're just too fast to be believable...

[23:07] *** kaare_ joined
[23:07] <masak> fil_: we have >>op<<, "distribute operation elementwise" (also works on prefixes and postfixes, with appropriate modification)

[23:07] <masak> fil_: I type fast.

[23:07] <masak> fil_: we have Xop, though just X is easier to understand at first.

[23:08] <fil_> so later on in the program it calls the sub as: map &mfact.assuming(:$degree), 1 .. 10;

[23:08] <masak> @a X @b gives you all combinations of @a elements and @b elements.

[23:08] <masak> right.

[23:08] <fil_> what is .assuming?

[23:08] <fil_> it's not in learnxiny

[23:08] <masak> it takes a sub and fills in one of the parameters with a value.

[23:08] <masak> let's make an example.

[23:09] <masak> m: sub greet($name) { say "howdy, $name!" }; &greet.assuming(:name<fil_>).()

[23:09] <camelia> rakudo-moar 243c16: OUTPUT«Too few positionals passed; expected 1 argument but got 0␤  in sub greet at /tmp/Mlk1yQ8UA1:1␤  in sub CURRIED at src/gen/m-CORE.setting:3687␤  in block <unit> at /tmp/Mlk1yQ8UA1:1␤␤»

[23:09] <fil_> in this case it's filling in with $_ from map and 1..10?

[23:09] <masak> m: sub greet(:$name) { say "howdy, $name!" }; &greet.assuming(:name<fil_>).()

[23:09] <camelia> rakudo-moar 243c16: OUTPUT«howdy, fil_!␤»

[23:09] <masak> there we go.

[23:09] <masak> I think I just proved I'm not an AI, too ;)

[23:09] <fil_> Just because you can pass the Turing test doesn't mean you're not an AI

[23:10] <masak> no, it's filling in with $degree from the for loop.

[23:10] <masak> fil_: true...

[23:10] <masak> I could have faked that mistake...

[23:10] <masak> gee, you humans have very high requirements.

[23:10] <fil_> there is no for loop

[23:10] <masak> on the line before the map

[23:11] <masak> the line before the .assuming, I should say

[23:11] *** ribasushi left
[23:12] <fil_> what's the difference between &mfact.assuming(:$degree) and &mfact(:degree<$degree>)

[23:12] <masak> it's :degree($degree)

[23:12] <masak> but given that, no difference -- it's a shorthand

[23:12] <fil_> let me try again

[23:12] <masak> (it's :name<str> when you mean a literal string and :name($expr) when you mean an expression)

[23:13] <fil_> what's the difference between &mfact.assuming(:$degree) and &mfact(:$degree)

[23:13] <masak> the .assuming produces a new sub, still without calling it.

[23:13] <fil_> oh I see!

[23:13] <masak> the *map* calls that new sub, and passes $_

[23:13] *** agentzh left
[23:13] <fil_> that's what the & is doing

[23:13] *** ribasushi joined
[23:13] <masak> which binds to the $n

[23:14] <fil_> I see

[23:14] <fil_> it's like a "partial"

[23:14] <fil_> in clojure

[23:14] <masak> yes, the & here means "we're talking about the sub as a thing, not calling it"

[23:14] <masak> m: sub foo {}; say &foo

[23:14] <camelia> rakudo-moar 243c16: OUTPUT«sub foo () { #`(Sub|66661536) ... }␤»

[23:14] <masak> m: sub foo {}; say &foo.arity

[23:14] <camelia> rakudo-moar 243c16: OUTPUT«0␤»

[23:14] <masak> m: sub foo($n) {}; say &foo.arity

[23:14] <camelia> rakudo-moar 243c16: OUTPUT«1␤»

[23:15] <fil_> I think the writer did a poor job writing that perl6 example

[23:15] <masak> in Perl 6, subs secretly are actually called `&foo` etc. it's just that `foo` is a shorthand for `&foo()`

[23:15] <masak> fil_: it looks like good Perl 6 to me.

[23:15] <masak> fil_: that's not to say there aren't other ways.

[23:16] <fil_> when I read the Java example, it's immediately clear to the reader what's going on

[23:16] <fil_> this one is using some pretty advanced concepts

[23:16] <masak> fil_: I probably would've reached for a sub inside the for loop instead. then I wouldn't have to pass $degree with .assuming.

[23:16] <fil_> do we really need a partial!

[23:16] <masak> no.

[23:16] <masak> here, let me rewrite it for you without it.

[23:17] <fil_> I think I'm just going to change it for the sake of future generations

[23:17] <masak> m: for 1 .. 5 -> $d { sub mfact($n) { [*] $n, *-$d ...^ * <= 0 }; say "$d: ", map &mfact, 1..10 }

[23:17] <camelia> rakudo-moar 243c16: OUTPUT«1: 1 2 6 24 120 720 5040 40320 362880 3628800␤2: 1 2 3 8 15 48 105 384 945 3840␤3: 1 2 3 4 10 18 28 80 162 280␤4: 1 2 3 4 5 12 21 32 45 120␤5: 1 2 3 4 5 6 14 24 36 50␤»

[23:17] <masak> there ya go

[23:17] <masak> speedy rewrite! AI wins again \o/

[23:19] <masak> ooh, and I can show off postfix >>

[23:20] <masak> m: for 1 .. 5 -> $d { sub postfix:<mfact>($n) { [*] $n, *-$d ...^ * <= 0 }; say "$d: ", (1..10)>>mfact }

[23:20] <camelia> rakudo-moar 243c16: OUTPUT«1: 1 2 6 24 120 720 5040 40320 362880 3628800␤2: 1 2 3 8 15 48 105 384 945 3840␤3: 1 2 3 4 10 18 28 80 162 280␤4: 1 2 3 4 5 12 21 32 45 120␤5: 1 2 3 4 5 6 14 24 36 50␤»

[23:20] <masak> not much longer, and kinda cute :)

[23:20] *** _4d47 joined
[23:20] <masak> note how the `>>` means "distribute this operator (that we just defined) over all the elements"

[23:20] <Mouq> m: for 1 .. 5 -> $d { sub mfact($n) { [*] $n, *-$d ...^ * <= 0 }; say "$d: ", (1..10)>>.&mfact } # works too

[23:20] <camelia> rakudo-moar 243c16: OUTPUT«1: 1 2 6 24 120 720 5040 40320 362880 3628800␤2: 1 2 3 8 15 48 105 384 945 3840␤3: 1 2 3 4 10 18 28 80 162 280␤4: 1 2 3 4 5 12 21 32 45 120␤5: 1 2 3 4 5 6 14 24 36 50␤»

[23:20] <masak> ooh, yes.

[23:21] <fil_> I think your first approach was clearer

[23:21] <masak> Mouq++ is here using the fact that any sub can be called as a method: `$obj.&mysub`

[23:21] <masak> fil_: yes, possibly.

[23:21] <masak> fil_: though it depends what you're used to.

[23:21] <masak> I agree not much is gained by making it an operator here.

[23:22] <masak> sometimes it makes a world of difference. when you can use [op], for example.

[23:26] <fil_> I've updated http://rosettacode.org/wiki/Multifactorial#Perl_6 with your simplified solution.  Thanks for walking me through this!

[23:27] <masak> my pleasure.

[23:27] <fil_> I understand that { [*] $n, *-$degree ...^ * <= 0 } is the correct way to write it, but it troubles me that perl6 allows for three completely different meanings of * in the same statement.

[23:27] <masak> two are the same, though.

[23:27] <fil_> well kinda

[23:27] <fil_> but they're not the same instance

[23:28] <fil_> If I saw two $n in the same statement, chances are they referred to the same thing.  But here the first one refers to "previous term" and the second one refers to "current term"

[23:28] <masak> would it reassure you if I said that Perl 6 itself is never confused as to what kind of `*` you use, and that with (minimal) practice it's a breeze to tell the two different meanings apart?

[23:28] <fil_> fair enough

[23:28] <masak> oh, but the `*` means "whatever".

[23:28] <fil_> I just started studying it today

[23:29] <masak> that you *have* to know, otherwise it will not make sense :)

[23:29] <fil_> like what's the difference between $_ and *

[23:29] <masak> the thing with "whatever" is that the surrounding context/callee fills in the appropriate meaning.

[23:29] <masak> easiest to show the difference. hold on.

[23:29] *** _4d47 left
[23:29] <masak> m: my &t = { $_ == 7 }; say &t(5); say &t(7)

[23:29] <camelia> rakudo-moar 243c16: OUTPUT«False␤True␤»

[23:30] <masak> m: my &t = * == 7; say &t(5); say &t(7)

[23:30] <camelia> rakudo-moar 243c16: OUTPUT«False␤True␤»

[23:30] <masak> so `*` is kind of `$_` plus invisible `{ }`

[23:30] <fil_> ah

[23:30] <fil_> ok that is a HUGE help

[23:31] <fil_> it means that spaces are significant in perl

[23:31] <fil_> or at least moreso than in other languages like Java or C.

[23:31] <masak> correct.

[23:32] <masak> it's used to differentiate whether something is a postfix or an infix, for example.

[23:32] <masak> m: my @a; @a[0]

[23:32] <camelia> rakudo-moar 243c16: ( no output )

[23:32] <masak> m: my @a; @a [0]

[23:32] <camelia> rakudo-moar 243c16: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/DItW6NY4u5␤Two terms in a row␤at /tmp/DItW6NY4u5:1␤------> [32mmy @a; @a [[33m⏏[31m0][0m␤    expecting any of:␤        infix stopper␤        infix or meta-infix␤        bracketed…»

[23:32] <masak> ok, that last one wasn't an infix, but still.

[23:32] <fil_> ya

[23:32] <fil_> interesting

[23:32] <masak> m: my $x; $x ++

[23:32] <camelia> rakudo-moar 243c16: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/W7u86gAYMY␤Preceding context expects a term, but found infix + instead␤at /tmp/W7u86gAYMY:1␤------> [32mmy $x; $x ++[33m⏏[31m<EOL>[0m␤»

[23:32] <fil_> I actually kind of like spaces being significant

[23:33] <fil_> results in code with more consistent styling

[23:33] *** brrt left
[23:34] <fil_> hey I have another question for you.

[23:34] <Mouq> fil_: Another rational is that, with the complex grammar of Perl 6, it's super useful to be able to easily tell the user that there's a typo. Having significant space means that typos are much less likely to be interpreted as valid code

[23:34] <masak> fil_: the thing that some people don't like is that they can't put spaces between `mysub` and `(...)`

[23:34] <fil_> I submitted an issue on learnxiny

[23:34] <fil_> https://github.com/adambard/learnxinyminutes-docs/issues/938#issuecomment-71391089

[23:35] <masak> heh

[23:35] <masak> m: sub named-def(:$def) { say "\$def is $def" }; named-def(:10def)

[23:35] <camelia> rakudo-moar 243c16: OUTPUT«$def is 10␤»

[23:36] <masak> there's a backstory to why this weird feature exists.

[23:36] <fil_> so at least you agree with me that it doesn't look right... :-)

[23:36] *** rurban_ left
[23:36] <masak> yes, but I'm also showing that it works.

[23:37] <masak> the reason it's there is to support this feature:

[23:37] <masak> m: $_ = "ABCDE"; m:4th/./; say ~$/

[23:37] <camelia> rakudo-moar 243c16: OUTPUT«D␤»

[23:39] <fil_> Does the second m: refer to camelia or match?

[23:40] <masak> m: $_ = "ABCDE"; m/./; say ~$/

[23:40] <camelia> rakudo-moar 243c16: OUTPUT«A␤»

[23:40] <masak> it's `m//` for "match using this regular expression"

[23:40] <fil_> I see

[23:40] <fil_> that's pretty freekin obscure

[23:40] <fil_> so someone has created :nd, :st, :rd etc...

[23:40] <masak> note how I'm not arguing back.

[23:40] <masak> yep.

[23:40] <fil_> sigh

[23:41] <masak> when it's useful, it's very useful.

[23:41] <fil_> That's Larry and his desire for the language to match English

[23:41] <masak> but it's rare.

[23:41] <fil_> is there a :me for French?

[23:41] <masak> I could have lived with just :nth($n), actually

[23:41] <masak> fil_: only in the expansion pack.

[23:41] <fil_> lol

[23:42] <fil_> It feels like cuteness that will help ppl win obfuscation awards

[23:42] <masak> and the 'm' and the 'e' have to be written with Unicode superscript.

[23:42] <fil_> but it doesn't add anything to the clarity of the language

[23:42] <masak> oh, I don't know about that.

[23:42] <masak> m:2nd/ <$regex> /

[23:43] <masak> feels pretty clear to me.

[23:43] <fil_> I assume then that named arguments can't start with numbers for that reason

[23:43] <fil_> does it only work for numbers

[23:44] <fil_> or can you use <strings>, $vars or other things?

[23:44] <fil_> It feels like an entire language construct just added for the benefit of the match operation

[23:46] <masak> basically.

[23:46] <masak> named arguments can't start with numbers because identifiers can't.

[23:46] <masak> there's prior art there from basically all other languages.

[23:47] <masak> if identifiers could start with numbers, you'd have to backtrack once you distinguished an identifier from a number literal.

[23:47] <masak> and we prefer to keep our languages backtrack-free.

[23:47] <fil_> so masak, besides being an amazing perl6 tutor, what's your role in the perl6 community?

[23:47] <masak> I like to break things.

[23:48] <fil_> :-)

[23:48] <masak> no; correction. I use stuff, and it breaks.

[23:48] <masak> then I submit literally hundreds of bug reports.

[23:48] <fil_> nice

[23:48] <fil_> are you a core perl6 contributor?

[23:48] <masak> on a good day, yes.

[23:48] <fil_> cool!

[23:48] <fil_> how many of you are there?

[23:48] * masak looks around

[23:48] <masak> looks like just me :(

[23:48] <fil_> lol

[23:49] <fil_> I mean core perl6 code contributors

[23:49] <masak> it's a fuzzy number, for sure.

[23:49] <fil_> is Larry writing compiler/interpretor code?

[23:49] <masak> there are scores of names in the Rakudo commit log, for example.

[23:49] <masak> fil_: yes, nowadays he is.

[23:49] <fil_> that's cool

[23:49] <fil_> have you ever met him in person?

[23:49] <masak> fil_: he had a self-imposed embargo for several years.

[23:50] <masak> something about Perl 5 ending up a bit messy in the implementation.

[23:50] <fil_> I've read through perl5 source code.

[23:50] <fil_> It was seriously terrible

[23:50] <fil_> I had a bug I needed to deal with

[23:50] <fil_> Some of the worst code I've ever seen

[23:50] <masak> fil_: I have met him in person. I've done the whole star-struck thing, and "omgomg I'm sitting next to Larry at a hackathon", and gotten yelled at by him, and had amazing technical discussions (mostly on IRC).

[23:51] <masak> fil_: what I've seen has made my hair curl a bit, too :)

[23:51] <fil_> Larry's a visionary, and I'm loving what I see on perl6.  Just goes to show you can write an inspirational spec without being able to write a great compiler for it

[23:51] <masak> see, for example, http://strangelyconsistent.org/blog/dash-n-and-dash-p

[23:52] <masak> fil_: if you want to see something great that Larry wrote, though, check out STD.pm6

[23:52] <masak> fil_: that's inspirational. and it's running code, too.

[23:53] <masak> back when the rest of us couldn't imagine how to make a Perl 6 parser work, Larry wrote one in Perl 6, then wrote "just enough" shimming to translate that Perl 6 back to Perl 5, so it could run.

[23:55] * fil_ falls prostate

[23:56] <masak> considering how messy Perl 5's whole lexer/parser is -- to the point where people talk about "X ways a parser can lie to itself" when they describe it -- STD.pm6 just stands out as an awesome exemplar of clarity and intent.

[23:56] <fil_> gotta go make dinner

[23:56] <fil_> thanks for the inspiration

[23:56] <masak> nice talking to you

[23:56] <fil_> l8ras

[23:56] <masak> o/

[23:56] <fil_> before I go

[23:56] <fil_> nah

[23:56] <fil_> another time

[23:56] <masak> :)

[23:56] <fil_> l8r

[23:56] *** fil_ left
