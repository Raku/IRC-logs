[00:01] *** lolisa joined
[00:03] *** colomon left
[00:05] *** kinslayer left
[00:06] *** laouji joined
[00:14] <dalek> rakudo/allomorphs: f0c5b49 | ShimmerFairy++ | src/Perl6/ (2 files):

[00:14] <dalek> rakudo/allomorphs: Implement a compile-time version of val() in World

[00:14] <dalek> rakudo/allomorphs: 

[00:14] <dalek> rakudo/allomorphs: This is called to help streamline val() processing on strings with

[00:14] <dalek> rakudo/allomorphs: compile_time_values. This version, unlike the one in src/core, calls on

[00:14] <dalek> rakudo/allomorphs: the Perl 6 grammar to do the work (something val() might like to do

[00:14] <dalek> rakudo/allomorphs: someday). It also has three possible return values: an allomorphic

[00:14] <dalek> rakudo/allomorphs: constant, if possible, the original string QAST if we know it can't be a

[00:14] <dalek> rakudo/allomorphs: value, or a call to val() where we're unsure of the string.

[00:14] <dalek> rakudo/allomorphs: 

[00:14] <dalek> rakudo/allomorphs: This takes my sorting benchmark from ≈27.7s to ≈16.2s average, compared

[00:14] <dalek> rakudo/allomorphs: to nom's 12.4s average. This seems to me to be sufficiently close to

[00:14] <dalek> rakudo/allomorphs: pre-val() speeds that this could be merged into nom whenever

[00:14] <dalek> rakudo/allomorphs: appropriate.

[00:14] <dalek> rakudo/allomorphs: 

[00:14] <dalek> rakudo/allomorphs: This test passes all spectests the previous commit did (that is, those

[00:14] <dalek> rakudo/allomorphs: tests relying on a stricter val() definition still fail, pending

[00:14] <dalek> rakudo/allomorphs: decisions about allomorphic types in this area).

[00:14] <dalek> rakudo/allomorphs: review: https://github.com/rakudo/rakudo/commit/f0c5b49ca1

[00:18] <timotimo> why does the benchmark get slower, ooc?

[00:18] <timotimo> Cannot find method '5'

[00:18] <timotimo> that's fun

[00:20] <ShimmerFairy> timotimo: the initial speed decrease was about 90s on a smaller sort, because my initial val() was horribly inefficient. I found that val() was optimized as much as could reasonably be, so the compile-time version eliminates run-time calls for things like %hash<foo> and such

[00:21] <ShimmerFairy> timotimo: the specific sort line is    0.^methods(:all).sort    (the smaller version lacking the :all), and that generates warnings about stringification. That warning ends up calling an AT-POS with a ton of %hash<foo> accesses, hence the slowdown :)

[00:22] <timotimo> i'd not expect <foo> as a postcircumfix to invoke val semantics

[00:22] <ShimmerFairy> timotimo: well, the spec says that <> is eqv. to q:w:v// and «» is eqv. to qq:ww:v// , with no qualifiers or exceptions, so that's what I did :)

[00:23] <timotimo> hmm

[00:23] <timotimo> and what does %hash<foo> actually compile to? at the qast level?

[00:24] <timotimo> and with --target=optimize, does it turn into a WVal? as in: a pre-created object to be loaded from the serialized blob?

[00:25] <timotimo> i feel like i'm about to fall over sideways and fall asleep

[00:25] <ShimmerFairy> timotimo: before that commit, it turned into an Op('&val', Want(WVal(Str), Ss, SVal(foo)), to use an abbreviated invalid format :)

[00:25] <ShimmerFairy> optimize on that shows no change, and trying to use 'is pure' on val earlier did nothing to help

[00:25] <timotimo> mhm

[00:26] <ShimmerFairy> (just realized I forgot a ) on my invalid format above :P)

[00:26] *** rurban1 left
[00:27] *** colomon joined
[00:27] <timotimo> and before your branch?

[00:27] *** rangerprice left
[00:28] <ShimmerFairy> not sure, I'd have to recompile it (but it'd be without a val call, like it is for compile_time_values now)

[00:28] <timotimo> ah

[00:28] <timotimo> and after your commit, in that branch?

[00:28] <timotimo> "an allomorphic constant" being a WVal-ref'd object?

[00:29] <ShimmerFairy> yes, I used $*W.add_constant to add the allomorphic type, if it exists (otherwise fallback on a runtime &val call)

[00:29] <ShimmerFairy> That could possibly be fixed by making the allomorphic types BOOTSTRAPed ones, but I'm not sure that's necessary as of yet

[00:30] *** qnap``` left
[00:30] <timotimo> i'm still surprised it's become that slow :(

[00:30] <timotimo> anyway, i'll go to bed now

[00:31] <timotimo> have a good one!

[00:31] <ShimmerFairy> timotimo: it's not that bad anymore, just about 4s for that one benchmark :)

[00:31] <ShimmerFairy> ♞! o/

[00:31] <timotimo> "just 4s", but that's a quarter of what it was before

[00:32] <ShimmerFairy> timotimo: true, but that sort emits a ton of warnings that each use a bunch of <> constructs, so small differences add up. At this point I think the slowdown will be usually imperceptible (even this would be, I think, if I weren't timing it closely ☺)

[00:34] <ShimmerFairy> I think there could perhaps be optimization in CORE to be had by using {'...'} instead of <...> -- sure, it's weird, but as long as <> is _always_ val()'d, that's the kind of optimization I'd expect to find in CORE code :)

[00:35] <ShimmerFairy> (also, we've been without val() for far too long, so a lot of the new nits, like using {'...'} to ensure string-only, will seem less awesome than if it had been implemented earlier. In other words, we're too used to <> and «» not doing anything val()-ish ☺)

[00:39] *** laouji left
[00:40] *** laouji joined
[00:42] *** paralaxia joined
[00:44] <paralaxia> p6: [+] 1//6

[00:44] <camelia> rakudo-moar 5e1b08: ( no output )

[00:44] <ShimmerFairy> Just did some checking, and Backtrace.AT-POS() is where the offending subscripts were. At 12376 subscripts total from that method (for the :all version), that 4s increase is about .0003s more per subscript, or .3ms. I don't think that turns out to be so bad :)

[00:44] *** laouji left
[00:46] *** laouji joined
[00:49] *** paralaxia left
[00:53] *** gfldex left
[00:53] *** skids joined
[00:57] *** lolisa left
[00:57] *** mprelude left
[01:02] *** dsm joined
[01:05] *** gfldex joined
[01:11] *** araujo_ joined
[01:11] *** spider-mario left
[01:12] *** araujo left
[01:15] *** n0tjack joined
[01:18] <dalek> rakudo-star-daily: d5c2dcf | coke++ | log/ (7 files):

[01:18] <dalek> rakudo-star-daily: today (automated commit)

[01:18] <dalek> rakudo-star-daily: review: https://github.com/coke/rakudo-star-daily/commit/d5c2dcff30

[01:18] <dalek> perl6-roast-data: 06a44a7 | coke++ | / (10 files):

[01:18] <dalek> perl6-roast-data: today (automated commit)

[01:18] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/06a44a7157

[01:20] *** n0tjack left
[01:23] <dalek> perl6-roast-data: 0ebb5c8 | coke++ | / (4 files):

[01:23] <dalek> perl6-roast-data: glr has been merged back to nom

[01:23] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/0ebb5c87e3

[01:29] *** prevost joined
[01:38] *** araujo_ left
[01:43] *** ab5tract_ joined
[01:45] *** ilbot3 left
[01:47] *** ilbot3 joined
[01:50] *** xinming_ joined
[01:53] *** xinming left
[02:04] *** noganex joined
[02:05] *** kbenson_ joined
[02:08] *** noganex_ left
[02:10] *** sunnavy_ joined
[02:10] *** ruoso_ joined
[02:10] *** Shozan joined
[02:10] *** yubimusubi joined
[02:10] *** mls_ joined
[02:10] *** ambs_ joined
[02:13] *** hobbified joined
[02:13] *** timbunce_ joined
[02:15] *** ambs left
[02:15] *** dalek left
[02:15] *** kbenson left
[02:15] *** JimmyZ left
[02:15] *** Possum left
[02:15] *** go|dfish left
[02:15] *** synbot6 left
[02:15] *** [Tux] left
[02:15] *** sunnavy left
[02:15] *** skarn left
[02:15] *** SHODAN left
[02:15] *** hobbs left
[02:15] *** mls left
[02:15] *** ruoso left
[02:15] *** dg left
[02:15] *** timbunce left
[02:15] *** timbunce_ is now known as timbunce

[02:17] *** dg joined
[02:19] *** dayangkun joined
[02:21] *** JimmyZ joined
[02:22] *** go|dfish joined
[02:22] *** laouji left
[02:23] *** [Tux] joined
[02:28] *** krunen_ joined
[02:30] *** cfloare_ joined
[02:30] *** rvchangu- joined
[02:30] *** orbus joined
[02:30] *** petercom1and joined
[02:31] *** b2gills1 joined
[02:32] *** nowan_ joined
[02:34] *** garu_ joined
[02:34] *** El_Che_ joined
[02:34] *** cgfbee left
[02:34] *** rvchangue left
[02:34] *** krunen left
[02:34] *** orbusbak left
[02:34] *** cfloare left
[02:34] *** petercommand left
[02:34] *** nowan left
[02:34] *** |Tux| left
[02:34] *** garu left
[02:34] *** El_Che left
[02:34] *** rvchangu- is now known as rvchangue

[02:35] *** cgfbee joined
[02:36] *** |Tux| joined
[02:37] *** laouji joined
[02:42] *** colomon left
[02:42] *** colomon joined
[02:45] *** labster joined
[02:51] *** Tux__ joined
[02:52] *** ponbiki_ joined
[02:53] *** nightfro` joined
[02:56] *** xinming joined
[02:57] *** |Tux| left
[02:57] *** nightfrog left
[02:57] *** nightfro` is now known as nightfrog

[02:59] *** xinming_ left
[03:02] *** _sri joined
[03:02] *** kaare_ joined
[03:23] *** ilogger2 joined
[03:23] *** ChanServ sets mode: +v ilogger2

[03:25] *** khw joined
[03:35] *** skarn joined
[03:43] *** AlexDaniel joined
[03:44] <AlexDaniel> m: my Int $x = 5; my Str $x = 'hello'; say $x;

[03:44] <camelia> rakudo-moar 5e1b08: OUTPUT«Potential difficulties:␤    Redeclaration of symbol $x␤    at /tmp/KeKcvEXWd2:1␤    ------> 3my Int $x = 5; my Str $x7⏏5 = 'hello'; say $x;␤Type check failed in assignment to '$x'; expected 'Str' but got 'Int'␤  in block <unit> at /tmp/KeKc…»

[03:52] *** khw left
[03:59] <AlexDaniel> “less LTA”, heh

[04:26] *** tokuhiro_ joined
[04:28] <tokuhiro_> how do i write a test case to support before this commit https://github.com/rakudo/rakudo/commit/268ca0802e6106de2880ddf28bfcfe9e2d3b1bc9 and after this commit?

[04:30] *** dalek joined
[04:31] *** ChanServ sets mode: +v dalek

[04:35] <tokuhiro_> In perl5, i can write a code like `__PACKAGE__->can(‘done-testing’) or eval “sub done-testing { done }”` for workaround.

[04:50] *** laouji joined
[05:20] *** ShimmerFairy joined
[05:22] *** n0tjack joined
[05:27] *** n0tjack left
[05:38] *** telex joined
[05:41] *** xfix joined
[05:51] *** rurban joined
[05:55] *** Alina-malina joined
[06:02] *** rurban left
[06:03] *** _mg_ joined
[06:08] *** vendethiel joined
[06:08] *** FROGGS joined
[06:09] *** AlexDaniel left
[06:16] <FROGGS> m: use Test; say &::('done-testing') # tokuhiro_: check for its existence..., but don't check for &done, because that exists anyway

[06:16] <camelia> rakudo-moar 5e1b08: OUTPUT«sub done-testing () { #`(Sub|48978944) ... }␤»

[06:18] <FROGGS> m: use Test; &::('done-testing') ?? &::('done-testing')() !! &::('done')()

[06:18] <camelia> rakudo-moar 5e1b08: OUTPUT«1..0␤»

[06:18] <FROGGS> star-m: use Test; &::('done-testing') ?? &::('done-testing')() !! &::('done')()

[06:18] <camelia> star-m 2015.03: OUTPUT«1..0␤»

[06:21] <tokuhiro_> FROGGS: thanks!

[06:22] <FROGGS> tokuhiro_: you're welcome

[06:32] *** vendethiel left
[06:33] *** cognominal joined
[06:49] <TimToady> I'm not sure there's actually a use case for val()-based subscripts, since you can always write .{1/2} rather than .<1/2> and rely on constant folding, since you always have the brackets to prevent precedence accidents

[06:49] <TimToady> breakfast &

[06:49] *** perlawhirl joined
[06:50] *** [Tux] joined
[06:54] <jnthn> I could happily live without .<...> doing val(...) but if it *does* then there should be zero runtime performance cost

[06:54] <yoleaux> 6 Sep 2015 02:36Z <ShimmerFairy> jnthn: I put japhb's code in val(), with minimum modification to make it work properly, and got marginal improvements (null program startup decreased by about .01s, profiling sorting line shows it went down ≈1.2s). It's of course better (so I'll keep it in ☺), but val()'s implementation seems to be a non-issue now

[06:54] <yoleaux> 6 Sep 2015 02:39Z <ShimmerFairy> jnthn: I suspect having a version of val() in World.nqp, or perhaps even in NQP itself, for strings with compile_time_values would be the most helpful, considering how many constant strings in quotewords there are in CORE and such :)

[06:55] <jnthn> Because in $foo<bar> we can prove that bar is just going to be a Str at compile time and produce exactly what we do now.

[06:56] <jnthn> .tell ShimmerFairy I think $foo<bar> style things really do need resolving to strings at compile time, yes. But...why make another version of val()? Why not just look up $*W.find_symbol(['&val']) from the setting and call it? And if it's not defined yet, then just assume a Str is fine as a fallback.

[06:56] <yoleaux> jnthn: I'll pass your message to ShimmerFairy.

[06:58] <jnthn> .tell bbkr Saw your post; I think the deadlock will go away once I implement the smarter version of await that makes thread pool threads available to do other work while they're awaiting.

[06:58] <yoleaux> jnthn: I'll pass your message to bbkr.

[07:02] *** st_iron joined
[07:02] <st_iron> hi

[07:04] <jnthn> meeting &

[07:07] *** Ven joined
[07:11] *** salv0 joined
[07:20] *** espadrine joined
[07:22] *** pdcawley joined
[07:23] <moritz> Hi st_iron; even though nobody greeted you for 20 minutes, you're not alone :-)

[07:24] *** ufobat joined
[07:27] *** perlawhirl left
[07:33] <masak> hi st_iron -- Europe is still waking up, methinks :)

[07:34] *** lizmat joined
[07:35] *** mr-foobar joined
[07:36] <masak> m: say "hi, ", OUR::.^name.substr(0, 2).lc, "_", :a.^name.substr(2), (1|2).^name.substr(*-2)

[07:36] <camelia> rakudo-moar 5e1b08: OUTPUT«hi, st_iron␤»

[07:36] <masak> Just Another Perl 6 Greeting :P

[07:37] *** pdcawley left
[07:38] *** laouji left
[07:39] *** pdcawley joined
[07:40] <FROGGS> masak++

[07:40] *** test__ joined
[07:41] <test__> p6; say 3

[07:41] <masak> m: say 3

[07:41] <camelia> rakudo-moar 5e1b08: OUTPUT«3␤»

[07:41] *** test__ left
[07:42] <mrf> morning

[07:43] <masak> mrf! \o/

[07:48] *** darutoko joined
[07:48] <st_iron> moritz: thanks for reassuring :)

[07:48] <st_iron> masak: hi 2u2 :)

[07:48] <st_iron> it's is still morning, but this part of the world wakes up around 5am nowadays

[07:49] <st_iron> I like to play a bit with languages (spoken and not spoken) in the early morning

[07:50] * TimToady --> Málaga &

[07:51] *** laouji joined
[07:52] <cdc> m: say OUR::.^name

[07:52] <camelia> rakudo-moar 5e1b08: OUTPUT«Stash␤»

[07:52] *** Ven left
[07:52] *** lizmat left
[07:53] <masak> st_iron: nice to hear that.

[07:53] <masak> st_iron: so, what (if anything) brings you to #perl6?

[07:53] * st_iron is playing with Rakudo Star before the Christmas release

[07:54] <st_iron> and where else could I read more info than on the IRC channel of #perl6

[07:55] <masak> so true.

[07:55] <masak> m: say so True

[07:55] <camelia> rakudo-moar 5e1b08: OUTPUT«True␤»

[07:56] <masak> m: say so so so so so not False

[07:56] <camelia> rakudo-moar 5e1b08: OUTPUT«True␤»

[07:56] *** lizmat joined
[07:56] <masak> m: say infix:<&&>()

[07:56] <camelia> rakudo-moar 5e1b08: OUTPUT«True␤»

[07:57] <FROGGS> m: say [&&]

[07:57] <camelia> rakudo-moar 5e1b08: OUTPUT«True␤»

[07:59] <masak> m: say [max]

[07:59] <camelia> rakudo-moar 5e1b08: OUTPUT«-Inf␤»

[08:01] *** lizmat left
[08:01] <FROGGS> m: say [>] # :D

[08:01] <camelia> rakudo-moar 5e1b08: OUTPUT«True␤»

[08:02] *** lizmat joined
[08:02] <FROGGS> m: say <!-- Place your beer here --> # such comment

[08:02] <camelia> rakudo-moar 5e1b08: OUTPUT«(!-- Place your beer here --)␤»

[08:05] *** leont joined
[08:08] *** lizmat left
[08:11] *** lizmat joined
[08:11] *** leont left
[08:12] *** lizmat left
[08:24] *** zacts joined
[08:26] *** Alina-malina left
[08:28] *** petercom1and joined
[08:28] *** petercom1and is now known as petercommand

[08:38] *** Solidstate joined
[08:38] *** CQ joined
[08:44] *** ab5tract_ joined
[08:45] *** Ven joined
[08:47] *** ab5tract_ left
[08:48] *** KCL_ joined
[08:49] *** grondilu joined
[08:53] *** kinslayer joined
[08:56] *** rindolf joined
[08:57] *** araujo joined
[08:57] *** araujo left
[08:59] *** [Sno] joined
[08:59] *** rurban joined
[08:59] *** leont joined
[08:59] *** bbkr_ joined
[09:01] *** ufobat left
[09:02] *** mprelude joined
[09:06] *** araujo joined
[09:06] *** araujo left
[09:06] *** araujo joined
[09:13] *** rurban left
[09:14] <bbkr_> jnthn: so basically "await start { await start { sleep } }" will take only 1 thread from pool? sounds really tough to implement :)

[09:18] <Solidstate> Is Rakudo-Star 2015.07 an official release?

[09:22] <Solidstate> Anyone manage to get "make rakudo-spectest" pass in Rakudo-Star 2015.07?

[09:24] *** n0tjack joined
[09:27] *** domidumont joined
[09:27] *** Khisanth joined
[09:28] *** Khisanth is now known as Guest77995

[09:28] *** n0tjack left
[09:30] <moritz> it's just as official as all the other rleases

[09:31] <moritz> and I'm pretty sure the tests passed for the (compiler-) release manager, otherwise he shouldn't have released it

[09:35] *** rurban joined
[09:37] *** fling joined
[09:37] *** Ven left
[09:37] <FROGGS> Solidstate: what test failures do you see?

[09:38] *** rarara joined
[09:43] *** rindolf left
[09:46] *** rmgk_ joined
[09:46] *** rmgk_ is now known as rmgk

[09:57] *** laouji left
[09:58] *** laouji joined
[09:59] *** ShimmerFairy left
[10:02] *** rurban left
[10:03] *** pmurias joined
[10:08] *** leont left
[10:11] *** ShimmerFairy joined
[10:11] *** ufobat joined
[10:12] *** ufobat left
[10:12] <Solidstate> FROGGS: sorry was out to lunch. I got:

[10:12] <Solidstate>  Test Summary Report ------------------- t/spec/S17-lowlevel/lock.rakudo.moar                        (Wstat: 11 Tests: 7 Failed: 1)   Failed test:  7                                                                            Non-zero wait status: 11                                                                   Parse errors: Bad plan.  You planned 8 tests but ran 7.                                  t/spec/S32-io/IO-Socket-Asyn

[10:12] <Solidstate> hmm sec bad formatting

[10:13] *** Ven joined
[10:13] <Solidstate> Test Summary Report

[10:13] <Solidstate> -------------------

[10:13] <Solidstate> t/spec/S17-lowlevel/lock.rakudo.moar                        (Wstat: 11 Tests: 7 Failed: 1)

[10:13] <Solidstate>   Failed test:  7                                                                         

[10:13] <Solidstate>   Non-zero wait status: 11                                                                

[10:14] <Solidstate>   Parse errors: Bad plan.  You planned 8 tests but ran 7.                                 

[10:14] <Solidstate> t/spec/S32-io/IO-Socket-Async.rakudo.moar                   (Wstat: 65280 Tests: 5 Failed: 0)

[10:14] <Solidstate>   Non-zero exit status: 255                                                                  

[10:14] <Solidstate>   Parse errors: Bad plan.  You planned 6 tests but ran 5.                                    

[10:14] <Solidstate> t/spec/S32-io/IO-Socket-INET.t                              (Wstat: 65280 Tests: 37 Failed: 0)

[10:14] <Solidstate>   Non-zero exit status: 255                                                                   

[10:14] <Solidstate>   Parse errors: Bad plan.  You planned 47 tests but ran 37.                                   

[10:14] <Solidstate> Files=1028, Tests=45938, 1110 wallclock secs ( 7.03 usr  2.04 sys + 803.69 cusr 60.30 csys = 873.06 CPU)

[10:14] <Solidstate> Result: FAIL                                                                                            

[10:15] <Solidstate> sorry about that, I'm sure there's a better way to copy-paste multi-line content into this chat...

[10:17] <Ven> Solidstate: usually, gist.github.com

[10:20] *** _mg_ left
[10:22] <Solidstate> Ven - thanks, created https://gist.github.com/anonymous/da814a2c8648b3b1be71#file-gistfile1-txt

[10:23] *** Woodi joined
[10:29] <Solidstate> BTW I did some searching and at least one other user reported similar failure message for t/spec/S32-io/IO-Socket-INET.t , perhaps related to my issue: http://www.nntp.perl.org/group/perl.perl6.compiler/2015/08/msg11077.html

[10:30] <Solidstate> I'm using Perl 5.10.1, don't have access to newer :(

[10:34] <Solidstate> On the bright side, after "make install" :

[10:34] <Solidstate> > ./test.p6

[10:34] <Solidstate> Hello, World!

[10:34] <Solidstate> :)

[10:38] <ShimmerFairy> Solidstate: the lock and Async tests are safe to ignore (the Async test was fixed some time ago, and there was work on the lock tests recently). Don't know about the INET one, though.

[10:38] <yoleaux> 06:56Z <jnthn> ShimmerFairy: I think $foo<bar> style things really do need resolving to strings at compile time, yes. But...why make another version of val()? Why not just look up $*W.find_symbol(['&val']) from the setting and call it? And if it's not defined yet, then just assume a Str is fine as a fallback.

[10:42] *** brrt joined
[10:42] <ShimmerFairy> .tell jnthn: I thought about calling &val, I just wasn't sure if compile_time_eval was inefficient or otherwise bad (in the way that the inverse, EVAL, is usually a sign of needing to rethink your code). The Str fallback means it could skip val() on valid values in CORE, but then again I don't think CORE needs allomorphs :)  (I already pushed the result of "another version" to the allomorphs branch, if you missed it)

[10:42] <yoleaux> ShimmerFairy: What kind of a name is "jnthn:"?!

[10:43] <ShimmerFairy> .tell jnthn I thought about calling &val, I just wasn't sure if compile_time_eval was inefficient or otherwise bad (in the way that the inverse, EVAL, is usually a sign of needing to rethink your code). The Str fallback means it could skip val() on valid values in CORE, but then again I don't think CORE needs allomorphs :)  (I already pushed the result of "another version" to the allomorphs branch, if you missed it)

[10:43] <yoleaux> ShimmerFairy: I'll pass your message to jnthn.

[10:43] <FROGGS> Solidstate: these tests (apart from the mentioned one) are flappers... they are usually skipped when a release is made

[10:44] <FROGGS> Solidstate: so yes, you can ignore these for now, but we have to take care of them rather soonish

[10:44] <Solidstate> FROGGS - thanks

[10:45] *** st_iron left
[10:45] <FROGGS> debugging and fixing these will be "fun" :/

[10:46] <ShimmerFairy> .tell jnthn For the record, I'd be fine if we said that %h<foo bar> didn't go under val() (and perhaps don't do val() on colonpairs either, e.g. :foo<bar>). FWIW TimToady already said %h<42> wouldn't let you access Int keys, for example.

[10:46] <yoleaux> ShimmerFairy: I'll pass your message to jnthn.

[10:51] <cdc> bbkr_: about http://irclog.perlgeek.de/perl6/2015-09-07#i_11179225, maybe what jnthn++ had in mind was more about task-based parallelism (ie. several tasks per thread, task migration).  As explained here: http://bartoszmilewski.com/2011/10/10/async-tasks-in-c11-not-quite-there-yet/  This is just my guess, though.

[10:52] <FROGGS> ShimmerFairy: +1 to that fwiw

[10:52] <FROGGS> I've always seen %h<foo bar> a shortcut for %h{'foo bar'}

[10:52] <ShimmerFairy> FROGGS: it does mean the mention of <> and «» in S02 would be less simple, but I think people expect hash subscripts at least to be string-only things :)

[10:53] <ShimmerFairy> well, %h<foo bar> is a shortcut for %h{'foo', 'bar'}, but aside from that I think that's what most people expect, yes :) .

[10:53] <FROGGS> is it really that?

[10:53] <ShimmerFairy> well, it _is_ a qw list :)

[10:54] <FROGGS> m: my %h = 'foo bar' => 1, foo => 2, bar => 3; say $h<foo bar>

[10:54] <ShimmerFairy> m: my %h = 1,2,3,4; say %h<1 3>

[10:54] <camelia> rakudo-moar 5e1b08: OUTPUT«5===SORRY!5=== Error while compiling /tmp/DuU5m4X88E␤Variable '$h' is not declared. Did you mean '%h'?␤at /tmp/DuU5m4X88E:1␤------> 3'foo bar' => 1, foo => 2, bar => 3; say 7⏏5$h<foo bar>␤»

[10:54] <camelia> rakudo-moar 5e1b08: OUTPUT«(2 4)␤»

[10:54] <FROGGS> m: my %h = 'foo bar' => 1, foo => 2, bar => 3; say %h<foo bar>

[10:54] <camelia> rakudo-moar 5e1b08: OUTPUT«(2 3)␤»

[10:54] <FROGGS> hmmm, so my memory is bogus anyway

[10:54] <ShimmerFairy> m: my %h = 'foo bar' => 1, foo => 2, bar => 3; say %h«foo 'foo bar' bar»

[10:54] <camelia> rakudo-moar 5e1b08: OUTPUT«(2 1 3)␤»

[10:55] <FROGGS> I see

[10:56] <ShimmerFairy> So, <> is spec'd as q:w:v// , and «» is spec'd as qq:ww:v// , but I'd be happy going back to :v-less for hash subscripts, and maybe colonpairs (not sure about that, since that for the record includes infix:<example>)

[10:58] <masak> ShimmerFairy: I think :v-less hash subscripts would be less confusing.

[10:58] <masak> but possibly also less consistent.

[10:58] <masak> in other words, I'm not sure what I think. :/

[10:59] <ShimmerFairy> Yeah, the consistency issue is concerning, but like I pointed out TimToady already said  :{1 => 2}<1>  wouldn't get you what you want, which suggests a mostly-Stringy use of <> for that context

[11:02] <ShimmerFairy> The idea of having :v on <> and «», if my guess is correct, is that you can enter in numeric things without being forced to go back to a ('foo', 42, 'bar') style list. So I suppose the question is if there are some contexts where we want to force you to revert to that list style after all.

[11:05] *** laouji left
[11:07] *** laouji joined
[11:07] <ShimmerFairy> There's also the potential argument that you should have to do %hash{'foo'} if you really want just a string, and that not having val() for so long has let you get away with assuming <> was safely string-only :)

[11:11] *** Ven left
[11:11] <nine> I thought the whole point of the differentiation between <> and {} was to get rid of the ambiguity of {} in Perl 5

[11:14] <ShimmerFairy> I wouldn't know about that, and I don't quite see where the ambiguity you're referring to is. (val() produces an allomorphic type that's both a string and a number, so you can treat it whichever way you mean)

[11:14] <nine> And the compiler/runtime has to somehow guess what I mean. That's the ambiguity.

[11:14] <FROGGS> in Perl 5 $foo{flubber} would mean 'flubber' as a string

[11:15] *** domidumont left
[11:15] *** laouji left
[11:16] <ShimmerFairy> nine: no, it's just a case of multiple inheritance. If multiple candidates of a multi match, that's your hint to be explicit about what you want now.

[11:16] *** Ven joined
[11:16] *** domidumont joined
[11:17] *** laouji joined
[11:17] <masak> there's one kind of ambiguity in Perl 5 (literal string vs bare expression) and another in Perl 6 (Str type vs some other type, like Int)

[11:18] <ShimmerFairy> It's not like $foo{flubber} in Perl 5, where you don't know if that's seen as a string xor as a term. allomorphs are more "it's a string _and_ a number!", not an either/or thing.

[11:18] <masak> yes.

[11:19] <masak> but nine is also right that such allomorphism introduces cases where Perl 6 itself now has to guess between e.g. the string and the number.

[11:19] <masak> like in :{1 => 2}<1>

[11:20] <ShimmerFairy> Like I said, there may be some cases where we don't want <> and «» to let you use numerics and still have a nice, space-separated list :)

[11:20] <FROGGS> what will happen if you call foo($int-str) when there is a foo(Str) and foo(Int) candidate? it will be an ambiguous call, right?

[11:20] <ShimmerFairy> yes, and that's specifically mentioned in the spec as something that'll happen :)

[11:21] <FROGGS> k

[11:21] <ShimmerFairy> "In case multiple dispatch determines that it could dispatch as either string or number, a tie results, which may result in an ambiguous dispatch error. You'll need to use prefix + or ~ on the argument to resolve the ambiguity in that case."

[11:21] <FROGGS> I think that's one reason why multiple inheritance might not be always desirable :o)

[11:22] <ShimmerFairy> so perhaps remove the implied :v in contexts where you can't easily prefix-disambiguate items?

[11:23] <ShimmerFairy> right after that quote, there's "[Conjecture: we may someday find a way to make strings bind a little looser than the numeric types, but for now we conservatively outlaw the dispatch as ambiguous, and watch how this plays out in use.]"

[11:25] *** n0tjack joined
[11:27] <jnthn> bbkr_: Uh, not if you sleep and actually block the thread, no, but if you are just awaiting something then yes, the idea is to free up the awaiting thread (perhaps to work on the thing being awaited)

[11:27] <yoleaux> 10:43Z <ShimmerFairy> jnthn: I thought about calling &val, I just wasn't sure if compile_time_eval was inefficient or otherwise bad (in the way that the inverse, EVAL, is usually a sign of needing to rethink your code). The Str fallback means it could skip val() on valid values in CORE, but then again I don't think CORE needs allomorphs :)  (I already pushed the result of "another version" to the allomorphs branch, if you missed it)

[11:27] <yoleaux> 10:46Z <ShimmerFairy> jnthn: For the record, I'd be fine if we said that %h<foo bar> didn't go under val() (and perhaps don't do val() on colonpairs either, e.g. :foo<bar>). FWIW TimToady already said %h<42> wouldn't let you access Int keys, for example.

[11:28] *** _mg_ joined
[11:28] <jnthn> ShimmerFairy: You're not doing compile_time_eval in the normal case though, you're just looking up an (already-called) val sub and calling it, then taking the object it returns and adding it to the SC so you can reference it in a QAST::WVal

[11:29] <ShimmerFairy> One idea is that you could do %h{<foo bar>} if you really want the allomorphic types, now that I think about it. I think "can't manually choose which interpretation you want" might be a good metric for places where <> implies :v and where it doesn't.

[11:29] *** n0tjack left
[11:29] *** rindolf joined
[11:30] <ShimmerFairy> jnthn: is there an existing example of this in the parser that I could look at for reference? (Or is it otherwise not hard to figure out?)

[11:33] *** perlawhirl joined
[11:33] <FROGGS>         my $v := $*W.find_symbol(['Version']).new(~$<vstr>);

[11:33] <FROGGS>         $*W.add_object($v);

[11:33] <FROGGS>         make QAST::WVal.new( :value($v) );

[11:33] <FROGGS> ShimmerFairy: ^^

[11:35] <ShimmerFairy> oh, so P6 functions (or at least object methods) are exposed to NQP when they exist? cool! :)  (I think I noticed that with a .new in add_constant earlier, but I didn't realize that was a general thing)

[11:37] *** Ven left
[11:41] <moritz> $*W gives access to the complete lexical environment of the program being compiled

[11:44] <pmurias> jnthn: do you think it would be ok to merge the js branch into the master nqp branch?

[11:46] <moritz> if it doesn't break anything for moar or jvm, go for it!

[11:47] <jnthn> pmurias: If it makes maint easier, and what moritz++ said, then I'm fine with it

[11:47] <pmurias> it shouldn't break anything

[11:47] <jnthn> pmurias: It is bootstrapped-ish and so has about the same build as other things, yes?

[11:48] <jnthn> Or not quite that far along yet?

[11:49] <pmurias> not yet bootstrapped, should be boostraping soonish 

[11:49] <pmurias> the differences in the way it builds are kept in Makefile-JS.in

[11:51] *** Ven joined
[11:51] <jnthn> ok

[11:57] <pmurias> .tell hoelzro before merging in js into the master branch remember to run the tests for the jvm/moar backends to make sure our improved test suit doesn't uncover any bugs in those

[11:57] <yoleaux> pmurias: I'll pass your message to hoelzro.

[12:03] *** perlawhirl left
[12:08] *** martin__1 joined
[12:09] *** martin__1 is now known as ufobat

[12:12] *** laouji left
[12:13] *** laouji joined
[12:16] *** ufobat left
[12:17] *** lichtkind joined
[12:18] *** Ven left
[12:23] *** lichtkind_ joined
[12:24] *** lichtkind left
[12:24] *** lichtkind_ is now known as lichtkind

[12:26] <jnthn> m: say Seq

[12:26] <camelia> rakudo-moar 5e1b08: OUTPUT«(Seq)␤»

[12:27] <jnthn> m: multi foo(@x) { }; foo((1..10).grep(* %% 2))

[12:27] <camelia> rakudo-moar 5e1b08: OUTPUT«Cannot call foo(Seq); none of these signatures match:␤    (@x)␤  in block <unit> at /tmp/qlP5MgkFMP:1␤␤»

[12:27] <jnthn> m: multi foo([$x, *@xs]) { }; foo((1..10).grep(* %% 2))

[12:27] <camelia> rakudo-moar 5e1b08: OUTPUT«Cannot call foo(Seq); none of these signatures match:␤    (@ (Any $x, *@xs))␤  in block <unit> at /tmp/QH9iuvdqdx:1␤␤»

[12:29] <jnthn> ohh...the test had .List thrown in rather than the multi-dispatcher being fixed

[12:29] <jnthn> So cheating!

[12:30] *** pmurias left
[12:31] *** martin__1 joined
[12:31] *** martin__1 is now known as ufobat

[12:31] *** laouji left
[12:32] <brrt> many deception

[12:32] <jnthn> Yeah.

[12:32] *** laouji joined
[12:32] * jnthn is working out the best way to fix up the multi dispatcher for this case :)

[12:32] *** ufobat left
[12:33] *** rindolf left
[12:33] <jnthn> Hm, most dispatches hit the cache so I guess I don't need to overly worry about making a wildly efficient solution...

[12:33] <FROGGS> we should implement a neural network and then teach it the right candidates :o)

[12:33] *** laouji left
[12:34] *** laouji joined
[12:34] <brrt> that is going to be a serious suggestion in about 18 months, i'm thinking

[12:36] <moritz> ... nope.

[12:36] <moritz> the real problem with neural networks is that, even when they work, they simply aren't transparent

[12:36] <brrt> hmmm

[12:36] <brrt> relational databases aren't transparent to many people

[12:37] <brrt> and people use them for everything

[12:37] <moritz> but there are people who can still explain their behavior

[12:37] <jnthn> .oO( Will relational databases ever have a sequal? )

[12:37] <moritz> and when the maintainers receive bug reports, they can say "this is not a bug because..."

[12:37] <geekosaur> postgres thinks it is one... :p

[12:38] <brrt> hmm

[12:38] <brrt> maybe you are right

[12:38] <brrt> but then again

[12:38] <brrt> i see them popup everywhere

[12:39] <arnsholt> The biggest problem with using an ANN (or any other ML method) for compilery stuff is that there's going to be false positives, which are going to wreck your semantics

[12:39] <moritz> I know a case in Germany where a bank trained a neural network to do credit rating

[12:39] <arnsholt> In some cases false negatives can also be problematic

[12:39] <brrt> do tell

[12:39] <moritz> and they had better performance than the previous algorithms

[12:40] <moritz> and then somebody who got denied a loan sued

[12:40] <moritz> and since the bank couldn't tell why the neural network denied here the loan, they stopped using it (at least for rejections :-)

[12:43] <masak> moritz: why was it so important for the bank to know why the neural network had denied her the loan?

[12:44] <moritz> masak: because to prove that it's not discriminatory not to business with somebody, you have to be able to state the actual reasons

[12:44] <arnsholt> Because laws, probably

[12:44] <brrt> who would sue for a denied loan?

[12:44] <moritz> *not to do

[12:45] <brrt> that makes no sense to me

[12:45] <brrt> hmmm

[12:45] <brrt> ok, that does make some sense

[12:45] <moritz> brrt: maybe it was a customer protection agency on behalf of somebody, dunno

[12:45] <arnsholt> That's a thing which is discussed every now and then in ML circles

[12:45] *** Ven joined
[12:46] <arnsholt> Especially since most ML methods tend to give large weight to features that proxy for things like race and socio-economic class, even though they're not overt in the training data

[12:46] <brrt> my suspicion is that if the ML algorithm is not fed with data that we could understand as being discriminatory, e.g. doesn't actually know your religion, then it couldn't make any discriminatory inferences that a human would not also make without the data

[12:46] *** lichtkind left
[12:47] <brrt> but it's kind of a circular problem

[12:47] <brrt> 'algorithm isn't discriminatory, it just rejects loans from these zipcodes'

[12:49] <arnsholt> Yeah, it's definitely non-trivial

[12:53] *** laouji left
[12:53] <masak> this discussion reminds me of Amazon's recommendation engine being horribly racist at some point by mistake

[12:53] <arnsholt> Yeah

[12:54] <arnsholt> Or face recognition algorithms only finding white people

[12:55] <arnsholt> And digital camera blink recognition false-positives on Asian people

[12:55] <masak> that one is easier to understand, though. probably only tested on fair-skinned folks

[12:55] *** perlawhirl joined
[12:55] *** n0tjack joined
[12:55] <arnsholt> Yeah, not enough non-White people in the training set

[12:56] <moritz> and here I thought most cameras where developeed in Asia anyway

[12:57] <brrt> masak: what?

[12:58] <brrt> have an example of that? i'm curious

[12:59] *** n0tjack left
[13:00] <dalek> rakudo/nom: 9fdaf03 | jnthn++ | src/ (2 files):

[13:00] <dalek> rakudo/nom: Fix Seq and multi-dispatch interaction.

[13:00] <dalek> rakudo/nom: 

[13:00] <dalek> rakudo/nom: Can now pass a Seq to a multi wanting an @arg again.

[13:00] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/9fdaf03b0a

[13:01] <dalek> roast: 9583915 | jnthn++ | S06-multi/type-based.t:

[13:01] <dalek> roast: Test for RT #126003.

[13:01] <dalek> roast: review: https://github.com/perl6/roast/commit/95839155e8

[13:01] <dalek> roast: 6b99c9e | jnthn++ | S06-signature/unpack-array.t:

[13:01] <dalek> roast: Remove no-longer-needed .List.

[13:01] <dalek> roast: 

[13:01] <dalek> roast: This was added to get the test passing under GLR, but really the multi

[13:01] <dalek> roast: dispatcher should have been fixed instead. Now it is, so clean up.

[13:01] <dalek> roast: review: https://github.com/perl6/roast/commit/6b99c9e937

[13:01] *** st_iron joined
[13:02] <jnthn> Well, that gets us back down to 1040...

[13:02] <FROGGS> jnthn: do you have any hints on the jvm breakage?

[13:02] <jnthn> Also the last GLR-related RT I can see

[13:02] <jnthn> FROGGS: No, 'cus I ain't really looked at it at all...

[13:02] <jnthn> Did it get bisuct?

[13:02] <FROGGS> jnthn: I'm willing to spent a few more hours on it, but I dunno what to try next

[13:03] <FROGGS> it is kinda bisectable me thinks

[13:03] <FROGGS> err, unbisectable

[13:03] <moritz> a flapper?

[13:03] <FROGGS> no

[13:03] <moritz> then what makes it unbisectable?

[13:04] <FROGGS> Array.new used to NPE until a recent patch by TimToady

[13:04] <jnthn> .oO( flappy bug, the successor to flappy bird )

[13:04] <FROGGS> and that recent patch uncovers a "Cannot call .jast on NQPMu"

[13:04] <jnthn> Hmmm

[13:05] <FROGGS> I could bisect to the point before the NPE probably

[13:05] <jnthn> I guess I can do a build and take a look

[13:05] * jnthn sets off the NQP build

[13:06] <FROGGS> jnthn: the only thing I know: it gets the entire setting, calls .as_jast on it in comile_all_the_stmts, and the result of that seems to be NQPMu

[13:06] <FROGGS> *I think I know

[13:06] <jnthn> hm

[13:06] * jnthn was pondering blogging about GLR stuff but then realizes he should probably just spend the time updating S07

[13:07] <jnthn> Especially as somebody already bitched about that not having been done :P

[13:07] <FROGGS> *g*

[13:10] * jnthn wonders if it'll be faster to update the GLR draft or just write what got implemented

[13:10] <jnthn> Advantage of JVM backend hacking: have time to go make a cup of tea during the build... :)

[13:13] <masak> :)

[13:13] <brrt> has glr been merged yet?

[13:14] <brrt> another advantage: never be cold when using your computer

[13:20] <eiro> jnthn, awesome talk at YAPC::Asia! thanks a lot

[13:20] <eiro> hello everyone 

[13:21] <FROGGS> hi eiro

[13:21] *** prevost joined
[13:21] <jnthn> eiro: :)

[13:21] <jnthn> brrt: yes

[13:22] <brrt> cool

[13:22] <jnthn> FROGGS: Well, I reproduced the error at least

[13:22] <brrt> somehow i've missed that

[13:23] <masak> eiro: hello!

[13:23] *** Solidstate left
[13:24] <eiro> what's up masak? long time no see :( 

[13:24] <eiro> anyone attending patch -p3 here? i miss the perl6 community

[13:25] <FROGGS> lizmat and wendy should be around

[13:26] <FROGGS> at least I think so...

[13:27] <masak> eiro: I was at YAPC::Europe, where were you? :)

[13:31] <El_Che_> touché

[13:31] <El_Che_> :)

[13:34] *** pat_js joined
[13:38] *** brrt left
[13:42] *** aborazmeh joined
[13:42] *** aborazmeh left
[13:42] *** aborazmeh joined
[13:44] *** khw joined
[13:56] *** n0tjack joined
[13:57] <masak> m: given 1, 2 { when 1, 2 { say .^name } }

[13:57] <camelia> rakudo-moar 9fdaf0: OUTPUT«List␤»

[13:57] <dalek> rakudo/nom: 23286d4 | jnthn++ | src/vm/jvm/Perl6/Ops.nqp:

[13:57] <dalek> rakudo/nom: Map missing op on JVM.

[13:57] <dalek> rakudo/nom: 

[13:57] <dalek> rakudo/nom: This gets it through the CORE.setting build, and just exploding on

[13:57] <dalek> rakudo/nom: startup since the op is NYI.

[13:57] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/23286d4bc3

[14:01] <masak> I hadn't really realized that you can smartmatch on a List with `when`. it's nice.

[14:01] *** n0tjack left
[14:01] <dalek> rakudo/nom: 749b72e | jnthn++ | src/vm/jvm/runtime/org/perl6/rakudo/RakOps.java:

[14:01] <dalek> rakudo/nom: Implement p6configposbindfailover for JVM backend.

[14:01] <dalek> rakudo/nom: 

[14:01] <dalek> rakudo/nom: Though the stuff it stashes isn't yet being used.

[14:01] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/749b72e95f

[14:02] <jnthn> :)

[14:04] *** Skarsnik joined
[14:04] <FROGGS> m: given 1, 2 { when 1, 2, 3 { say .^name } }

[14:04] <camelia> rakudo-moar 9fdaf0: ( no output )

[14:04] <FROGGS> m: given 2 { when 1, 2, 3 { say .^name } }

[14:04] <camelia> rakudo-moar 9fdaf0: OUTPUT«Int␤»

[14:05] <FROGGS> such consistency :o)

[14:05] *** dustinm` joined
[14:07] *** rindolf joined
[14:09] *** perlawhirl left
[14:09] *** smls joined
[14:13] *** smls left
[14:13] *** smls joined
[14:15] <masak> FROGGS: wait, however does 2 smartmatch on 1, 2, 3?

[14:15] <masak> m: say 2 ~~ (1, 2, 3)

[14:15] <camelia> rakudo-moar 749b72: OUTPUT«(1 2 3)␤»

[14:15] *** Ven left
[14:15] <masak> o.O

[14:16] *** aborazmeh left
[14:17] <masak> m: say "bananas" ~~ (1, 2, 3)

[14:17] <camelia> rakudo-moar 749b72: OUTPUT«(1 2 3)␤»

[14:17] <colomon> ??

[14:17] <colomon> m: say ("bananas" ~~ (1, 2, 3))

[14:17] <camelia> rakudo-moar 749b72: OUTPUT«(1 2 3)␤»

[14:18] <jnthn> I *think* that's to make if $a ~~ m:g/.../ { } work out, fwiw

[14:19] <timotimo> that's the list.accepts returns self thing, right?

[14:19] <jnthn> Before you never saw it for such examples 'cus of the Parcel/List distinction.

[14:20] <masak> I'm not sure how I feel about that.

[14:20] <masak> m:g is nice, but messing up List smartmatching for the sake of getting it to work; not so much

[14:21] <jnthn> Yeah, I left it as it was 'cus in terms of "what does List do" it wasn't a semantic change. :)

[14:21] <jnthn> But figured it'd end up getting revisisted.

[14:21] <timotimo> revisionize it!

[14:22] <ShimmerFairy> I'd expect ~~ to be like ∈ in that case, but without building Sets :)

[14:22] <jnthn> I don't actually know what to do about it, so it'll have to be left for TimToady++ :)

[14:22] <smls> ShimmerFairy: That's what  item ~~ any(list)  is for

[14:23] <smls> or  item eqv any(list)

[14:23] * ShimmerFairy still thinks a lot of the set ops could be useful for any kind of Positional, and not just Set objects, btw

[14:23] <dalek> rakudo/nom: 1a76417 | jnthn++ | src/vm/jvm/runtime/org/perl6/rakudo/ (2 files):

[14:23] <dalek> rakudo/nom: Toss mention of LoL in JVM-specific code.

[14:23] <dalek> rakudo/nom: 

[14:23] <dalek> rakudo/nom: Also note that slurpy params still need re-doing.

[14:23] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/1a764171b1

[14:23] <dalek> rakudo/nom: 15a0856 | jnthn++ | src/vm/jvm/ (4 files):

[14:23] <dalek> rakudo/nom: Further GLR steps for JVM backend.

[14:23] <dalek> rakudo/nom: 

[14:23] <dalek> rakudo/nom: Toss the ops we no longer need, and add some throws where we need to

[14:23] <dalek> rakudo/nom: update the code further. This means that the build should now explode

[14:23] <dalek> rakudo/nom: post-setting and with more useful hints of what needs doing to get the

[14:23] <dalek> rakudo/nom: JVM backend up and running post-GLR.

[14:23] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/15a08564cd

[14:24] <jnthn> The JVM backend gets through the CORE.setting build by now

[14:25] <masak> m: say 4 ∈ [1, 2, 3]; say 4 ∈ [6, 3, 4]

[14:25] <camelia> rakudo-moar 749b72: OUTPUT«False␤True␤»

[14:25] <masak> ShimmerFairy: ^^

[14:25] <masak> ShimmerFairy: or were you hoping for something more than that?

[14:25] <masak> (all the other set ops work, too)

[14:26] <ShimmerFairy> masak: Last I used them, they created Set objects you had to manually convert back to a list type

[14:26] <ShimmerFairy> m: say (1,2) ∪ (3,4)

[14:26] <camelia> rakudo-moar 749b72: OUTPUT«set(4, 3, 1, 2)␤»

[14:26] <ShimmerFairy> like that :)

[14:27] <eiro> back ... managers ... always bother me when i chat on irc ! 

[14:27] *** perigrin joined
[14:27] *** perigrin left
[14:27] <ShimmerFairy> I think I'd like it if set operators that didn't get any Set objects didn't end up making Sets

[14:28] * grondilu finally wrote a GLR-compatible version of SHA-256

[14:28] <masak> ShimmerFairy: I think that's an unreasonable expectation.

[14:28] <jnthn> ShimmerFairy: That's the (coercey) way operators in Perl 6 work.

[14:28] <masak> ShimmerFairy: compare "10" + "32"

[14:28] <eiro> El_Che, masak right .... didn't afford it this year. touché 

[14:28] *** perigrin joined
[14:28] *** perigrin left
[14:28] <masak> eiro: too bad :/ it was a nice conf

[14:29] <ShimmerFairy> I know that already, I mean that I think it might be nice if said set operators had multis for non-Set-using calls

[14:29] <eiro> but Cluj will be the year of my next yapc! 

[14:29] * jnthn was sad to miss it too :(

[14:29] <eiro> i saw the schedule and yes: it seems it was awesome. hope we will meet at yapc 

[14:29] *** perigrin joined
[14:29] <ShimmerFairy> I know it's just a minor thing, but whenever I've used set ops on lists, I've just converted them right back to lists afterward, so it seems a bit wasteful to have a Set created in that case.

[14:31] <masak> ShimmerFairy: then define your own ops that add the coercing.

[14:31] <ShimmerFairy> Why are you talking about coercing? That doesn't make sense to me here.

[14:33] <masak> then that's probably where we should start the discussion.

[14:33] <masak> most Perl operators coerce to something.

[14:33] <masak> infix:<+> coerces to numeric, for example

[14:33] <masak> the set operators coerce to set

[14:35] <eiro> s/yapc/fosdem

[14:36] <eiro> grmbl ... meeting again. goodbye everyone 

[14:36] <ShimmerFairy> well, I know about coercing arguments, but that's not what I'm talking about. I'm talking about versions of the set operators which operate on non-Set arguments, and don't involve Set in the process

[14:36] *** perigrin left
[14:37] <masak> yes, you are.

[14:38] <masak> and that's kind of going against the grain of how Perl usually works/thinks, is the point.

[14:38] <masak> &

[14:38] <ShimmerFairy> (I think my problem lies in the fact that sets are such a listy thing to me that it's weird how I'm forced into having the Set type by using set operators. A lot of those ops are just as valid on any kind of list, so why make me use Set?)

[14:38] <moritz> ShimmerFairy: then write those ops you want, publish them in a module; if they turn out to be universally used, we can core them

[14:39] <ShimmerFairy> I still have no clue how "coercion" factors into what I'm talking about. For me, only  Int()  type constraints are "coercion", as well as the various prefix ops

[14:40] * ShimmerFairy thinks the "write it yourself!" response is kinda rude, tbh :/

[14:41] <FROGGS> ShimmerFairy: fwiw, I'd like to use set ops on lists...

[14:42] <ShimmerFairy> It's of course possible right now, I just find it questionable that I have to implicitly construct a Set object to use them, esp. when I'm just going to toss it in list conversion as soon as I'm done with using set ops.

[14:42] <jnthn> ShimmerFairy: Maybe consider if you shoulda been using sets rather than lists in the first place?

[14:43] <FROGGS> hmmm

[14:43] <ShimmerFairy> jnthn: if Sets were more Positional than Associative in implementation, that'd be an easier choice for me, I'm guessing :)  (Like I said, it's been a while since I last used set ops)

[14:44] <jnthn> Yes, but if they weren't then set membership testing would be O(n) instead of being O(1) :)

[14:45] <ShimmerFairy> jnthn: true. It's just really strange to have it based on Associative when there's nothing being associated in a set :)

[14:45] <dalek> rakudo/nom: 376d727 | jnthn++ | src/vm/jvm/runtime/org/perl6/rakudo/Binder.java:

[14:45] <dalek> rakudo/nom: First pass at *@foo and **@foo on JVM post-GLR.

[14:45] <dalek> rakudo/nom: 

[14:45] <dalek> rakudo/nom: Can't yet tell if they work at get us to the next explosioin, or work

[14:45] <dalek> rakudo/nom: and cause the next explosion.

[14:45] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/376d7273bb

[14:45] <jnthn> heh, that second work should be don't work :)

[14:46] <jnthn> ShimmerFairy: It probably makes more sense of Bag and Mix

[14:46] <jnthn> *on

[14:46] <ShimmerFairy> I think the issue is that in those cases I need a list most of the time, _except_ when I want to do something nifty like an intersection between two lists. So for that one moment I need a Setty thing just because the set ops force it.

[14:50] <ShimmerFairy> But like I said, it's just a minor thing I've noticed whenever I've wanted the set ops to filter two lists in some way, not that big a deal :)

[14:53] <jnthn> Hm, no, seems the slurpy patch is at least fairly OK and the issue is elsewhere

[14:55] <colomon> ShimmerFairy: sets are NOT a listy thing.  In particular, they have no ordering on their elements.

[14:56] <ShimmerFairy> well, I perceive sets as an unordered, unique collection of items, and as they're written out they tend to look a lot like lists to me, so thus an unordered, unique list of items :)

[14:59] <ShimmerFairy> I agree that they're not really Positional in the way other Positional things are, but they sure ain't Associative either :)

[15:01] <dalek> rakudo/nom: d8e7b1d | jnthn++ | src/vm/jvm/runtime/org/perl6/rakudo/Binder.java:

[15:01] <dalek> rakudo/nom: Bring hllize semantics in line with Moar backend.

[15:01] <dalek> rakudo/nom: 

[15:01] <dalek> rakudo/nom: Fixes RETURN-LIST crash, getting us further through startup on JVM.

[15:01] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/d8e7b1d416

[15:02] <jnthn> Gets to line 30348 of loading CORE.setting now

[15:03] <FROGGS> only 5k lines to go then

[15:03] <jnthn> Method 'Int' not found for invocant of class 'Any' in SUBSTR-SANITY (gen/jvm/CORE.setting:9696)

[15:03] <jnthn> wtf?!

[15:05] *** Alina-malina joined
[15:06] <jnthn> m: Any.Int

[15:06] <camelia> rakudo-moar 15a085: OUTPUT«Method 'Int' not found for invocant of class 'Any'␤  in block <unit> at /tmp/JVU8xwhRtc:1␤␤»

[15:06] <jnthn> Oh...

[15:07] *** ShimmerFairy left
[15:08] <jnthn> So it's that we're getting Any passed in there...

[15:09] <nine> From the backlog: yes, List.ACCEPTS right now is a weird blend of pre-GLR Parcel's and List's that made the spec tests pass but is bound to raise some WTFs

[15:10] *** st_iron left
[15:11] <ugexe> m: ::("::Foo");

[15:11] <camelia> rakudo-moar d8e7b1: OUTPUT«Start argument to substr out of range. Is: 1, should be in 0..0; use *1 if you want to index relative to the end␤  in block <unit> at /tmp/kvYJ2_PvpS:1␤␤Actually thrown at:␤  in block <unit> at /tmp/kvYJ2_PvpS:1␤␤»

[15:16] <dalek> rakudo/nom: c89820c | jnthn++ | src/core/Inc.pm:

[15:16] <dalek> rakudo/nom: Add missing nqp::hllize.

[15:16] <dalek> rakudo/nom: 

[15:16] <dalek> rakudo/nom: Gets normal startup to...fail at the same place we do if you give a

[15:16] <dalek> rakudo/nom: -Ilib.

[15:16] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/c89820cfc0

[15:16] <jnthn> Darn, hoped that'd fix the -Ilib case too...

[15:16] *** yqt joined
[15:19] *** Guest77995 left
[15:20] *** FROGGS[mobile] joined
[15:20] *** FROGGS left
[15:20] *** ShimmerFairy joined
[15:22] *** Khisanth joined
[15:25] * jnthn is rather confused by the next JVM issue

[15:26] *** psch joined
[15:26] *** ab5tract_ joined
[15:27] <psch> hi #perl6 o/

[15:27] <ab5tract_> ShimmerFairy: on the contrary... sets have all (my, anyway) expected behavior for Associative, and none for Positional

[15:28] <psch> just saw the bit with m:g// on the clog and wanted to mention the re-specing that had happened

[15:28] <ab5tract_> unordered, unique

[15:28] <psch> we used to want m:g// to return a nested match object instead of a List

[15:28] <ShimmerFairy> ab5tract_: well, to me an "Associative" thing, well, associates things. And sets don't do that :)

[15:28] <nine> ab5tract_: but the values in the set are not "associated" with anything

[15:28] <psch> i'll dig for the corresponding discussion

[15:28] <ab5tract_> In fact, Perl 5 never really needed sets because we just use hashes for everything

[15:28] <ab5tract_> it's associated with True

[15:29] <psch> ab5tract_: i .tell'd you to "ab5stract" a few weeks ago, in case you hadn't seen that, re: jvm-interop iirc

[15:29] <ShimmerFairy> well, I don't think existence counts for much of an association, but that's just me :)

[15:29] <ab5tract_> ah! sorry about that

[15:29] <ab5tract_> ShimmerFairy: the point is, you implement sets with hashes (if you want an efficient set, that is)

[15:29] <nine> ab5tract_: that it' with True is purely an implementation detail.

[15:30] <ab5tract_> so clearly they are far more Associative than Positional

[15:30] <nine> taion leaking out into the design.

[15:30] <ShimmerFairy> I don't think sets are either, actually.

[15:30] <ab5tract_> nine: what else would $set{ $val } return ?

[15:32] <ab5tract_> ShimmerFairy: fair enough. I am just responding to your position that "but they sure ain't Associative either"

[15:32] <ab5tract_> not sure I saw the "either" when I first read that, though

[15:32] <ShimmerFairy> ab5tract_: what I meant with that line was that I don't think sets cleanly fit into either role :)

[15:33] <jnthn> OK, I'll put JVM backend hacking aside for a bit now

[15:33] <ab5tract_> Indeed. Still, I'm very much of the opinion that a Set is just a Hash with some Setty sugar on top

[15:34] <jnthn> It's not working again yet post GLR, but it's a lost closer and failing in a hopefully less terrifying way so others might be able to figure out what's going on.

[15:34] <jnthn> If nobody can I'll take another whack at it later in the week. :)

[15:34] <jnthn> *a lot closer

[15:35] <nine> That you can use AT-POS semantics with sets is nice. It's when $set.list returns a list of Pairs where the surprises start

[15:37] <nine> jnthn: thanks!

[15:37] <ab5tract_> nine: true

[15:38] <ab5tract_> nine: except that I would automatically have reached for .keys anyway :)

[15:38] <ab5tract_> but it's a valid point

[15:38] <nine> In 13 years of mathematics at school I've never heard that sets contain some sort of keys. Just items.

[15:39] <ab5tract_> We patched around that for .Bag and .Mix conversion

[15:39] <timotimo> yeah, sets are inside out, so to speak

[15:39] <nine> While I can absolutely see the nice sides of the generalization from an implementor's perspective, I don't feel all that comfortable with it from a user's.

[15:40] <ab5tract_> I do want to caveat that I've been havily Perl-ified wrt to sets. Something interesting happened on the way to my math education, and I never pursued it all that way

[15:40] <nine> But I'd also like to add that it's bickering at a high level. IF that's the ugliest part of the language, then we are very well off indeed :)

[15:40] <ab5tract_> nine: I believe that the .list as Pairs thing was GLR-related

[15:41] <jnthn> ab5tract_: I don't recall that being a GLR change, fwiw

[15:42] <nine> jnthn: I do seem to remember some change lizmat++ did at the SPW. I think before her change it was even more confusing.

[15:43] <nine> And I sort of grudingly made peace with Sets being Hashes there.

[15:44] * ugexe wishes he had the math chops to bicker at *any* level

[15:47] <pink_mist> to me, hashes are just sets with associativity added on

[15:48] <pink_mist> rather than the other way; sets being hashes with nonsensical associativity because of implementation details

[15:53] *** tokuhiro_ left
[15:53] *** FROGGS joined
[15:55] *** domidumont left
[15:58] *** mr-foobar left
[15:59] *** mr-foobar joined
[16:01] *** ab5tract_ left
[16:02] <nine> m: sub foo() { return :c(3) }; say foo().perl;

[16:02] <camelia> rakudo-moar c89820: OUTPUT«:c(Mu)␤»

[16:04] <jnthn> Phew, think I've nailed RT #125987

[16:05] *** smls_ joined
[16:05] *** smls left
[16:07] *** prevost left
[16:07] <jnthn> m: use Test; my $i = 0; react { whenever supply { emit 'x'; emit 'y'; } { $i++ } }; is $i, 2, 'react/whenever with supply that immediately emits values works';

[16:07] <camelia> rakudo-moar c89820: OUTPUT«Useless use of emit in react  in any  at /home/camelia/rakudo-inst-2/share/perl6/runtime/CORE.setting.moarvm:1␤not ok 1 - react/whenever with supply that immediately emits values works␤␤# Failed test 'react/whenever with supply that immediately emits…»

[16:09] <dalek> rakudo/nom: 6e5105d | jnthn++ | src/core/Supply.pm:

[16:09] <dalek> rakudo/nom: Fix handler scoping issue with whenever.

[16:09] <dalek> rakudo/nom: 

[16:09] <dalek> rakudo/nom: whenever $s { } where $s is a Supply that immediately emitted values

[16:09] <dalek> rakudo/nom: upon subscription would end up running the wrong handlers, entangling

[16:09] <dalek> rakudo/nom: the various supplies involved.

[16:09] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/6e5105d78f

[16:09] *** ab5tract_ joined
[16:09] *** telex left
[16:09] *** andreoss joined
[16:09] <dalek> roast: 294d0e4 | jnthn++ | S17-supply/syntax.t:

[16:09] <dalek> roast: Test for RT #125987.

[16:09] <dalek> roast: review: https://github.com/perl6/roast/commit/294d0e4b96

[16:10] <andreoss> m: sub MAIN() { say "hi" }

[16:10] <camelia> rakudo-moar c89820: OUTPUT«hi␤»

[16:10] *** telex joined
[16:10] <andreoss> m: sub MAIN() { my $x = True; END say "hi" if $x }

[16:10] <camelia> rakudo-moar c89820: ( no output )

[16:10] <andreoss> m: sub MAIN() { my $x = True; END say "hi"  }

[16:10] <camelia> rakudo-moar c89820: OUTPUT«hi␤»

[16:10] <andreoss> is it a bug? 

[16:11] <pink_mist> m: sub MAIN() { my $x = True; END { say "hi" if $x } }

[16:11] <camelia> rakudo-moar c89820: OUTPUT«hi␤»

[16:11] <nine> jnthn: if I may ask, what in 6e5105d78f is the actual bugfix? The removal of the duplicate nqp::exception() call or replacing cod() by &code?

[16:12] *** n0tjack joined
[16:12] <jnthn> nine: Actually the lifting of the closure taking for the handler blocks out of the nqp::handle

[16:12] <jnthn> The passing &code is an optimization I probably shoulda put in separate...

[16:12] <pink_mist> m: sub MAIN() { my $x = True; END { say "hi" } if $x }

[16:12] <camelia> rakudo-moar c89820: OUTPUT«hi␤»

[16:13] <pink_mist> huh, that one also works

[16:13] <jnthn> And the removal of the duplicate nqp::exception was actually something I tried first :)

[16:13] <nine> Oh a subtle fix combined with two diversions then ;)

[16:13] <jnthn> m: sub MAIN() { my $x = True; (END say "hi") if $x }

[16:13] <camelia> rakudo-moar c89820: OUTPUT«hi␤»

[16:13] <jnthn> nine: Yeah, sorry 'bout that

[16:14] <nine> No worry. Just asking to learn :)

[16:15] <jnthn> m: sub MAIN() {(END say "hi") if $x }

[16:15] <camelia> rakudo-moar c89820: OUTPUT«5===SORRY!5=== Error while compiling /tmp/UAv2xDtGD6␤Variable '$x' is not declared␤at /tmp/UAv2xDtGD6:1␤------> 3sub MAIN() {(END say "hi") if 7⏏5$x }␤»

[16:15] <jnthn> m: sub MAIN() { my $x; (END say "hi") if $x }

[16:15] <camelia> rakudo-moar c89820: OUTPUT«hi␤»

[16:15] <jnthn> m: sub MAIN() { my $x = True; END say $x }

[16:15] <camelia> rakudo-moar c89820: OUTPUT«(Any)␤»

[16:15] <jnthn> m: sub MAIN() { my $x = True; END { say $x } }

[16:15] <camelia> rakudo-moar c89820: OUTPUT«True␤»

[16:15] <jnthn> There's a golf of it

[16:15] <jnthn> Likely deserves to go RT-wards

[16:17] *** avalenn joined
[16:22] <nine> Seems like my little Map refactor uncovers quite a few Pair related bugs

[16:22] <jnthn> More than just a pair of 'em, I take it...

[16:25] *** Ven joined
[16:25] *** BenGoldberg joined
[16:32] <moritz> we should do that Pairiodically :-)

[16:32] <nine> What is a QAST::Want+{QAST::SpecialArg}?

[16:33] <jnthn> A QAST::Want that has had the QAST::SpecialArg role mixed in (meaning it's either a named arg or flattening arg)

[16:34] <nine> How is such a thing usually created?

[16:35] <nine> Ah, by being .named or .flat

[16:36] <jnthn> Yes

[16:41] <psch> jvm/glr build failure is gcx.LoL and gcx.ListIter being null, from the looks of it

[16:41] *** n0tjack left
[16:41] <psch> the former i imagine replacing with gcx.List is OK, the latter i'm unsure what to do

[16:44] *** Sqirrel joined
[16:44] <moritz> what is it used for?

[16:44] <jnthn> psch: I already fixed those bits

[16:45] *** Alina-malina left
[16:45] <psch> jnthn: oh.  and i was sure i pulled before looking at it :/

[16:46] <psch> oh duh

[16:46] <psch> glr has been merged as well

[16:46] <dalek> perl6-examples: 7701347 | andreoss++ | / (4 files):

[16:46] <dalek> perl6-examples: [euler] problem 60

[16:46] <dalek> perl6-examples: review: https://github.com/perl6/perl6-examples/commit/77013470c1

[16:46] <psch> that's what i get for neglecting my keeping up

[16:47] <moritz> m: say roundrobin(<a b>; <c d>).^name

[16:47] <camelia> rakudo-moar 6e5105: OUTPUT«Seq␤»

[16:49] <moritz> m: say <a b c>.pick.^name

[16:49] <camelia> rakudo-moar 6e5105: OUTPUT«Str␤»

[16:49] <moritz> m: say <a b c>.pick(1).^name

[16:49] <camelia> rakudo-moar 6e5105: OUTPUT«Seq␤»

[16:51] <moritz> m: say <a b c>.roll(1).^name

[16:51] <camelia> rakudo-moar 6e5105: OUTPUT«Seq␤»

[16:51] <moritz> m: say <a b c>.roll.^name

[16:51] <camelia> rakudo-moar 6e5105: OUTPUT«Str␤»

[16:52] *** nowan joined
[16:53] <moritz> m: say <a b>.map({$_}).^Seq

[16:53] <camelia> rakudo-moar 6e5105: OUTPUT«Method 'Seq' not found for invocant of class 'Perl6::Metamodel::ClassHOW'␤  in block <unit> at /tmp/tKAaKtnmGb:1␤␤»

[16:53] <moritz> m: say <a b>.map({$_}).^name

[16:53] <camelia> rakudo-moar 6e5105: OUTPUT«Seq␤»

[16:54] <moritz> m: say <a b>.reverse.^name

[16:54] <camelia> rakudo-moar 6e5105: OUTPUT«List␤»

[16:55] <moritz> m: say <a b>.rotate(1).^name

[16:55] <camelia> rakudo-moar 6e5105: OUTPUT«List␤»

[16:56] <dalek> specs: 7acbc45 | moritz++ | S32-setting-library/ (3 files):

[16:56] <dalek> specs: Remove mentions of Parcel from S32

[16:56] <dalek> specs: review: https://github.com/perl6/specs/commit/7acbc45560

[16:56] <moritz> this commits also cleans up some odd return values

[16:56] <moritz> like map returning a List of Parcel

[16:56] <jnthn> :)

[16:56] <jnthn> moritz++

[16:56] <jnthn> I've also started on an S07 re-write

[17:03] *** Ven left
[17:06] *** cognominal left
[17:10] *** ab5tract_ left
[17:15] *** prevost joined
[17:17] *** Ven joined
[17:22] *** skaji joined
[17:24] *** geever joined
[17:27] *** andreoss left
[17:28] *** psch left
[17:35] *** [Sno] left
[17:47] *** agaurav77 joined
[17:50] *** Peter_R joined
[17:50] <agaurav77> Hi everyone, I've just started viewing tickets on rt.perl.org, and I'm a bit new. Could someone point me to any easy bug?

[17:51] <moritz> agaurav77: I'm taking a look...

[17:51] *** yqt left
[17:52] <agaurav77> thanks

[17:53] <moritz> agaurav77: https://rt.perl.org/Ticket/Display.html?id=126006 might be easy

[17:53] *** pat_js left
[17:54] *** tokuhiro_ joined
[17:55] <nine> I slowly start to doubt that I'm ready for debugging Perl6::Actions

[17:56] *** leont joined
[17:56] <moritz> agaurav77: also https://rt.perl.org/Ticket/Display.html?id=125555

[17:57] *** go|dfish joined
[17:57] <moritz> m: my Int $x; my Str $x; $x = 'foo';

[17:57] <camelia> rakudo-moar 6e5105: OUTPUT«Potential difficulties:␤    Redeclaration of symbol $x␤    at /tmp/uCXxvYO149:1␤    ------> 3my Int $x; my Str $x7⏏5; $x = 'foo';␤»

[17:57] <moritz> m: my Int $x; my Str $x; $x = 'foo'; say $x;

[17:57] <camelia> rakudo-moar 6e5105: OUTPUT«Potential difficulties:␤    Redeclaration of symbol $x␤    at /tmp/8bX4mq4FOg:1␤    ------> 3my Int $x; my Str $x7⏏5; $x = 'foo'; say $x;␤foo␤»

[17:57] <agaurav77> moritz: 126006 might have been fixed

[17:58] *** ab5tract_ joined
[17:58] <agaurav77> $f.e says 'True' for me

[17:58] <agaurav77> looking 125555...

[17:58] *** tokuhiro_ left
[18:00] <FROGGS> nine: what's wrong?

[18:02] <nine> FROGGS: the fix you gisted yesterday seems to work. Unfortunately there seem to be other places that try to create Pairs without values. For example use Foo :named; or return :c(1);

[18:02] <nine> Both seem to be genuine bugs in Rakudo and that they haven't been fixed yet may correlate with them not being easy fixes...

[18:02] *** spider-mario joined
[18:03] <FROGGS> nine: yes, I'd also seen that {:a(1) :b(2)} is broken... I wasn't able to check if my patch is to blame or not

[18:03] <FROGGS> nine: aye, they are certainly not easy

[18:03] <nine> I could of course just work around by giving value a default value of Mu

[18:03] *** Ven left
[18:03] <FROGGS> I was even thinking we should toss the support of chained adverbs without a comma...

[18:04] <moritz> +1

[18:04] <moritz> +2

[18:04] <moritz> +Inf

[18:04] <FROGGS> nine: I can give it a whirl again, but most likely not this evening, as I am still working on the jvm

[18:05] <moritz> oh wait, I think %hash<foo>:k,:v might be ambiguous

[18:06] <nine> FROGGS: if you have any hints for me, I'd also be happy to do some more digging

[18:11] *** CQ left
[18:12] <FROGGS> nine: well, I potentially would try to port the circumfix:<( )> patch to circumfix:<{ }>

[18:13] <FROGGS> nine: but I guess the basic task is to remove all hurting .named that inject QAST::SpecialArgs in the ast

[18:14] <nine> Makes sense. Both.

[18:15] *** TEttinger joined
[18:15] <FROGGS> what we are currently doing is kinda backwards sadly...

[18:16] <nine> backwards how?

[18:16] <FROGGS> in :a :b the second adverb is applied to the first..., and later we try to disentangle them as if a comma was in between

[18:16] *** n0tjack joined
[18:17] *** CQ joined
[18:17] *** bbkr__ joined
[18:20] <nine> Is there a way to dump a piece of QAST for debugging?

[18:20] *** n0tjack left
[18:20] <FROGGS> nine: sure

[18:20] <timotimo> note($node.dump)

[18:20] <FROGGS> nine: nqp::say($past.dump)

[18:21] <nine> That's so.....obvious :)

[18:21] <timotimo> and if you do that, make sure you have my latest nqp commit

[18:21] <nine> don't display :decl() in qast dumps?

[18:24] *** mohij joined
[18:24] *** CQ left
[18:24] <timotimo> yup

[18:25] *** espadrine left
[18:26] *** diana_olhovik_ joined
[18:31] *** vendethiel joined
[18:33] *** bbkr joined
[18:36] *** _mg_ left
[18:37] *** bbkr__ left
[18:44] <nine> FROGGS: I'm happy to report that I successfully ported your fix to {:a(1) :b(2)} :)

[18:44] <timotimo> sweet

[18:45] <nine> No progress however on use Foo :something;

[18:46] <nine> Well I found out that the latter is an arglist and I know which .named call is responsible. Sadly it seems to be needed in some cases, though I don't understand why. The code is creating code for creating a Pair after all.

[18:47] <FROGGS> the .named is only needed if it is going to be a named argument in a call

[18:47] <FROGGS> AFAIK

[18:49] <nine> So if I can detect that it's not actually an arglist for a call, I can safely skip it.

[18:50] <FROGGS> that's what I would attempt

[18:50] <nine> Or the other way around: only do it if it's for a call

[18:50] <nine> A job for a dynamic variable in the grammar?

[18:53] *** [Sno] joined
[18:54] <dalek> nqp: 626b327 | FROGGS++ | src/vm/jvm/QAST/Compiler.nqp:

[18:54] <dalek> nqp: cleanup handling of unkown ops

[18:54] <dalek> nqp: 

[18:54] <dalek> nqp: We used to catch an exception to append source information to the message

[18:54] <dalek> nqp: in order to die again using that more informative message. Now we just

[18:54] <dalek> nqp: put this extra information in the very first exception. That helps us to

[18:54] <dalek> nqp: avoid a problem where we visited the same CATCH block twice.

[18:54] <dalek> nqp: review: https://github.com/perl6/nqp/commit/626b327722

[18:54] <FROGGS> nine: now I can also try fiddling with use Foo :something;

[18:54] <nine> All tests successful. :)

[18:55] *** domidumont joined
[18:55] <FROGGS> what?

[18:55] <nine> use Foo :something; works :)

[18:55] <FROGGS> ohh!

[18:55] *** tokuhiro_ joined
[18:55] <timotimo> neato

[18:55] <FROGGS> I'm eager to see the patch...

[18:55] <FROGGS> nine: do we still need the hunt_loose_adverbs thing?

[18:56] <nine> FROGGS: yes, that's still in. My fix really is not that exciting

[18:56] <nine> These are my first steps in Actions after all :)

[18:57] *** AlexDaniel joined
[18:58] <FROGGS> nine: I really enjoy that area

[18:58] <moritz> at its heart, it's very simple code: it transforms one tree into another, bit by bit

[18:59] <moritz> it just gets complicated when you have to the conventions of how the target tree must look like

[19:00] *** tokuhiro_ left
[19:01] <AlexDaniel> moritz: Oh yes, indeed! I was confused about my line numbers. However, “Note that redeclarations actually replace the previous declaration, at compile time. So at the time the initialization of the first declaration of $x is run, its type has already changed to Str.” – what if that goes into the error message? That would be awesome. If only it is always correct…

[19:03] <dalek> rakudo/gmr: 3649f9d | (Stefan Seifert)++ | src/Perl6/Actions.nqp:

[19:03] <dalek> rakudo/gmr: Fix use Foo :whatever<1> losing the adverb's value

[19:03] <dalek> rakudo/gmr: review: https://github.com/rakudo/rakudo/commit/3649f9db87

[19:03] <dalek> rakudo/gmr: 2cae30e | (Stefan Seifert)++ | src/Perl6/Actions.nqp:

[19:03] <dalek> rakudo/gmr: Fix (:a(1) :b(2)) dieing due to missing value arg to Pair.new

[19:03] <dalek> rakudo/gmr: 

[19:03] <dalek> rakudo/gmr: Patch by FROGGS++

[19:03] <dalek> rakudo/gmr: review: https://github.com/rakudo/rakudo/commit/2cae30ee24

[19:04] <dalek> rakudo/gmr: 7f80346 | (Stefan Seifert)++ | src/Perl6/Actions.nqp:

[19:04] <dalek> rakudo/gmr: Fix {:a(1) :b(2)} dieing due to missing value arg to Pair.new

[19:04] <dalek> rakudo/gmr: review: https://github.com/rakudo/rakudo/commit/7f80346e15

[19:04] *** agaurav77 left
[19:05] <moritz> is gmr "Great Module Refactoring"?

[19:05] <FROGGS> Map*

[19:05] <timotimo> Great Meep Refactoring

[19:05] <nine> Great Map Refactor. Since the GLR was named after the immutable base type, I used Map instead of Hash for the name. And m follows l after all ;)

[19:05] <moritz> ah :-)

[19:06] <nine> Those 3 fixes should actually be of value whether we merge the gmr or not.

[19:08] *** domidumont left
[19:09] * jnthn should look at the GMR at some point :)

[19:10] <jnthn> Though the commit messages have sounded pleasing :)

[19:10] <jnthn> Happy to see the Enum/Pair thing go

[19:10] <jnthn> And just have Pair

[19:10] <AlexDaniel> .oO( GMRelia? )

[19:12] *** n0tjack joined
[19:13] <jnthn> m: say 2 ** 99999999999999999999999999999999999

[19:13] <camelia> rakudo-moar 6e5105: OUTPUT«0␤»

[19:13] <jnthn> hm

[19:13] * jnthn hoped the "too wide" thingy would nail that

[19:14] <AlexDaniel> jnthn: “too wide” thing?

[19:17] <jnthn> m: my int $a = 99999999999999999999999999999999999;

[19:17] <camelia> rakudo-moar 6e5105: OUTPUT«Cannot unbox 117 bit wide bigint into native integer␤  in block <unit> at /tmp/0X124iJ8Y3:1␤␤»

[19:17] <jnthn> That one.

[19:17] *** beastd joined
[19:18] <AlexDaniel> oh, I've seen that error. Is it something new?

[19:18] <timotimo> hm, isn't there something like "arbitrarily unsupported" somewhere?

[19:18] *** n0tjack left
[19:18] <AlexDaniel> because if yes, then I should probably revise my bug reports…

[19:18] <AlexDaniel> there were lots of them associated with overflows

[19:19] <pink_mist> jnthn: isn't that specifically about int? and Int or Num should transparently just make it work?

[19:19] <AlexDaniel> timotimo: I think that it is about lists.

[19:19] <jnthn> AlexDaniel: Yes, that error is the solution to the overflows where it shows up

[19:19] <jnthn> AlexDaniel: So a lot of your bug reports are now closable with tests.

[19:20] <AlexDaniel> jnthn: amazing!

[19:20] <jnthn> I think FROGGS++ is to test

[19:20] <AlexDaniel> m: "x" xx 9999999999

[19:20] <camelia> rakudo-moar 6e5105: OUTPUT«Memory allocation failed; could not allocate 79999999992 bytes␤»

[19:20] <AlexDaniel> m: "x" xx 999999999999999999

[19:20] <camelia> rakudo-moar 6e5105: OUTPUT«Memory allocation failed; could not allocate 7999999999999999992 bytes␤»

[19:20] <AlexDaniel> m: "x" xx 999999999

[19:20] <camelia> rakudo-moar 6e5105: OUTPUT«Memory allocation failed; could not allocate 7999999992 bytes␤»

[19:20] <AlexDaniel> m: "x" xx 99999

[19:20] <camelia> rakudo-moar 6e5105: ( no output )

[19:20] <AlexDaniel> m: "x" xx 999999

[19:20] <camelia> rakudo-moar 6e5105: ( no output )

[19:20] <AlexDaniel> m: "x" xx 99999999

[19:20] <camelia> rakudo-moar 6e5105: ( no output )

[19:20] <jnthn> AlexDaniel: Did you mean x?

[19:20] <AlexDaniel> m: "x" xx 999999999

[19:21] <camelia> rakudo-moar 6e5105: OUTPUT«Memory allocation failed; could not allocate 7999999992 bytes␤»

[19:21] <jnthn> xx is list repetition and it's lazy

[19:21] <AlexDaniel> jnthn: I know

[19:21] <AlexDaniel> the thing is, it just segfaulted for me.

[19:21] <jnthn> Oh?

[19:21] <AlexDaniel> can somebody try that? perl6 -e '"x" xx 9999999999'

[19:21] <jnthn> I get the memory allocation failed

[19:21] <AlexDaniel> Segmentation fault

[19:21] <timotimo> "is to thank" ITYM

[19:21] <AlexDaniel> hmm

[19:21] <AlexDaniel> I'll recompile

[19:22] * moritz too

[19:22] <jnthn> timotimo: hah, yes!

[19:23] <dalek> rakudo/nom: 16d366a | jnthn++ | src/ (2 files):

[19:23] <dalek> rakudo/nom: Provide ACCEPTS hint on attempt to override ~~.

[19:23] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/16d366a2d2

[19:25] <AlexDaniel> hehe, somehow I hope that it will segfault with the recent build… That would be my first segfault, I think!! geez, there's something wrong with me…

[19:26] *** leont left
[19:27] *** mr-foobar left
[19:30] <jnthn> m: constant nums = 1; my \fizzbuzz = nums\ .map({ $_ });

[19:30] <camelia> rakudo-moar 6e5105: OUTPUT«5===SORRY!5=== Error while compiling /tmp/ncfxNFlrWX␤Variable '&nums' is not declared␤at /tmp/ncfxNFlrWX:1␤------> 3constant nums = 1; my \fizzbuzz = 7⏏5nums\ .map({ $_ });␤»

[19:30] <jnthn> std: constant nums = 1; my \fizzbuzz = nums\ .map({ $_ });

[19:30] <camelia> std 28329a7: OUTPUT«ok 00:00 140m␤»

[19:30] <jnthn> m: constant nums = 1; my \fizzbuzz = nums\.map({ $_ });

[19:30] <camelia> rakudo-moar 6e5105: ( no output )

[19:30] <jnthn> std: constant nums = 1; my \fizzbuzz = nums\.map({ $_ });

[19:30] <camelia> std 28329a7: OUTPUT«ok 00:00 140m␤»

[19:31] <jnthn> Very odd. Add some space there and it thinks it's looking at a sub call, not a term

[19:31] *** mr-foobar joined
[19:32] * TimToady waves from Málaga

[19:32] * jnthn notes this on RT #125985

[19:32] <jnthn> o/ TimToady 

[19:33] <jnthn> TimToady: Guess you were at least somewhat attracted there by the airport having rather more options than Granada? :)

[19:34] <AlexDaniel> OK, Segfault

[19:34] <AlexDaniel> I'm on 32-bit, that's probably why

[19:34] *** diana_olhovik_ left
[19:34] <jnthn> Well, you better get 32 more bits quick! :P

[19:35] <AlexDaniel> jnthn: why? :)

[19:36] <AlexDaniel> I'll better report that and hope that one day it will be fixed? :)

[19:36] <jnthn> Can do :)

[19:37] * jnthn going for some rest :) 

[19:37] <jnthn> o/

[19:37] <FROGGS> jnthn: o/

[19:39] *** pdcawley left
[19:39] <timotimo> good rest, jnthn 

[19:40] <AlexDaniel> m: 'x' x 99999999999999

[19:40] <camelia> rakudo-moar 6e5105: OUTPUT«repeat count > 1073741824 arbitrarily unsupported...␤  in block <unit> at /tmp/5vy28rwU54:1␤␤»

[19:40] <AlexDaniel> timotimo: not lists, strings!

[19:41] <timotimo> ah

[19:44] <timotimo> damn the bootstrap process >_<

[19:50] *** yqt joined
[19:51] *** rindolf left
[19:52] *** diana_olhovik joined
[19:56] *** smls_ left
[19:58] *** lolisa joined
[19:59] *** diana_olhovik left
[20:02] <[Coke]> evening

[20:02] <dalek> perl6-roast-data: 2efa916 | coke++ | / (9 files):

[20:02] <dalek> perl6-roast-data: today (automated commit)

[20:02] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/2efa9162f7

[20:02] <FROGGS> hi [Coke] 

[20:08] *** domidumont joined
[20:08] *** Alina-malina joined
[20:10] *** leont joined
[20:10] *** rarara left
[20:13] *** nowan left
[20:14] *** brrt joined
[20:16] *** tokuhiro_ joined
[20:16] *** nowan joined
[20:21] *** tokuhiro_ left
[20:24] *** lolisa left
[20:26] *** domidumont left
[20:27] *** Alina-malina left
[20:28] *** darutoko left
[20:29] *** rurban joined
[20:30] *** KCL joined
[20:32] *** KCL_ left
[20:33] *** Alina-malina joined
[20:33] *** Alina-malina left
[20:33] *** Alina-malina joined
[20:34] *** rurban left
[20:35] *** ab5tract_ left
[20:35] *** cognominal joined
[20:36] *** tokuhirom9 joined
[20:37] *** xfix left
[20:43] <FROGGS> btw, I've got a hack that get's us further building/installing rakudo on jvm

[20:45] *** lolisa joined
[20:51] *** ab5tract_ joined
[20:54] <[Coke]> yay

[21:00] *** brrt left
[21:06] *** lizmat joined
[21:11] *** rurban joined
[21:12] *** pierrot left
[21:13] <dalek> doc: 989af8b | labster++ | lib/Type/Numeric.pod:

[21:13] <dalek> doc: s:g/Numerid/Numeric/

[21:13] <dalek> doc: review: https://github.com/perl6/doc/commit/989af8b211

[21:14] *** xinming joined
[21:22] *** lizmat_ joined
[21:23] *** ab5tract_ left
[21:23] * lizmat_ waves from Belmonte, PT

[21:24] <FROGGS> hi lizmat_ 

[21:24] *** lizmat left
[21:25] <vendethiel> o/ FROGGS, lizmat_

[21:25] *** n0tjack joined
[21:25] *** prevost left
[21:31] *** lizmat_ is now known as lizmat

[21:31] <lizmat> FROGGS vendethiel o/

[21:31] <lizmat> connection seems flaky and with large delay, so probably over satellite

[21:31] <timotimo> ohai lizmat 

[21:31] <lizmat> timotimo o/

[21:33] <lizmat> seems a lot of rosettacode entries got fixed by 9fdaf03b0a43e527f5a808f7a  :-)

[21:33] *** n0tjack left
[21:36] <FROGGS> that's the current state of perl6-j: https://gist.github.com/FROGGS/a6aee767b154a611f4ee

[21:36] <FROGGS> gnight all

[21:42] *** rurban left
[21:45] <lizmat> gnight FROGGS 

[21:48] <jdv79> oh...  pause fix deplyed.  i'lll test tomorrow as i'm wped out.

[21:49] *** rangerprice joined
[21:49] <jdv79> nite

[21:50] <timotimo> lizmat: i can't find a commit with that id anywhere :(

[21:51] *** lizmat left
[21:52] <masak> 'night, #perl6

[21:52] <timotimo> gnite masak 

[21:55] *** lizmat joined
[21:56] *** beastd left
[21:57] <lizmat> timotimo: commit 9fdaf03b0a43e527f5a808f7a8eff68a18684be5 Author: jnthn [email@hidden.address] Date:   Mon Sep 7 14:55:56 2015 +0200

[21:57] <lizmat> in nom

[21:59] <timotimo> oh!

[22:00] *** tokuhirom9 left
[22:00] *** FROGGS left
[22:01] *** psch joined
[22:03] *** laouji joined
[22:13] *** lolisa left
[22:14] <lizmat> good night, #perl6!

[22:15] *** laouji left
[22:15] *** skids joined
[22:15] <raiph> o/

[22:16] <raiph> p6doc says `.DEFINITE` is "True for instances and False for type objects" and `defined` is "False on the type object, and True otherwise". But TimToady clearly implied a distinction between defined and DEFINITE in his recent comment and, iirc, has always held to that view. What should the doc say?

[22:17] *** tokuhiro_ joined
[22:17] <mohij> .tell tadzik: I'm more or less done with putting *env functionality into rakudobrew. Most commands work including local, global and shell switching.

[22:17] <yoleaux> 4 Sep 2015 22:31Z <tadzik> mohij: Wow, thanks man!

[22:17] <yoleaux> mohij: What kind of a name is "tadzik:"?!

[22:18] <raiph> .oO ( I guess .DEFINITE could be False for non type objects that aren't instances )

[22:18] *** lizmat left
[22:18] <mohij> .tell tadzik I'm more or less done with putting *env functionality into rakudobrew. Most commands work including local, global and shell switching.

[22:18] <yoleaux> mohij: I'll pass your message to tadzik.

[22:18] *** [Sno] left
[22:18] *** spider-mario left
[22:19] <mohij> .tell tadzik I have only tested on linux so far. Will do some Windows testing soon. What do you think about merging?

[22:19] <yoleaux> mohij: I'll pass your message to tadzik.

[22:20] <mohij> .tell tadzik Tradeoff: Slight startup time decrease because the shims are perl and not bash anymore.

[22:20] <yoleaux> mohij: I'll pass your message to tadzik.

[22:22] *** tokuhiro_ left
[22:25] *** laouji joined
[22:26] *** laouji left
[22:28] *** mohij left
[22:37] *** n0tjack joined
[22:40] <psch> raiph: aiu .defined depends on the type, while DEFINITE checks "does it have a value"

[22:41] <psch> raiph: as in, .defined is allowed to return False for DEFINITE values which the type itself calls undefined

[22:41] <psch> s/have a value/have any value/

[22:41] *** vendethiel left
[22:41] <psch> m: say so 0

[22:41] <camelia> rakudo-moar 16d366: OUTPUT«False␤»

[22:41] <psch> m: say 0.defined; say 0.DEFINITE

[22:41] <camelia> rakudo-moar 16d366: OUTPUT«True␤True␤»

[22:42] <psch> ...that understanding doesn't quite survive this output though

[22:42] *** n0tjack left
[22:42] <psch> wait, that got changed recently, didn't it?  Mu.defined calls .Bool, which for Int now returns True for 0 because it was inconsistent before

[22:45] <psch> m: class A { has $.a; method defined { return False if $.a == 0; True }; }; my ($a, $b) = A.new(:a(0)), A.new(:a(1)); say $a.defined, $b.defined; say $a.DEFINITE, $b.DEFINITE # this is what .defined is allowed to do aiu, in any case

[22:45] <camelia> rakudo-moar 16d366: OUTPUT«FalseTrue␤TrueTrue␤»

[22:45] <ugexe> the Proc constructor does a pretty good job of showing .DEFINITE usage i thought https://github.com/ugexe/rakudo/blob/nom/src/core/Proc.pm#L14

[22:47] <psch> m: say $*IN.defined; say $*IN.DEFINITE

[22:47] <camelia> rakudo-moar 16d366: OUTPUT«True␤True␤»

[22:47] *** nowan_ joined
[22:47] <psch> ugexe: i'm still wondering why those calls couldn't be to .defined

[22:47] <psch> i'll just try that i guess, i got stumped with jvm and let myself be distracted anyway :)

[22:49] <ugexe> perl6 -e 'my $h = IO::Handle.new; say $h.DEFINITE; say IO::Handle.DEFINITE'

[22:49] <ugexe> True

[22:49] <ugexe> False

[22:50] <timotimo> psch: i'm glad you're putting some effort into the jvm again :)

[22:50] <ugexe> i guess .defined is the same result there

[22:50] *** nowan left
[22:51] *** geever left
[22:51] <psch> ugexe: yeah, the difference was raiph++s question

[22:51] <psch> i laid out my understanding from the design above, but the impl doesn't quite seem to reflect it

[22:51] <psch> timotimo: i try, thanks for the encouragement :)

[22:51] <timotimo> .DEFINITE also goes directly to the underlying virtual machine's definition of definiteness

[22:52] <raiph> I think current p6doc wording, taken precisely, as I quoted earlier, logically entails that .defined and .DEFINITE, called on a type object, return False, and called on an instance, return True, and called on a value that is neither type object nor instance, return True for .defined and False for .DEFINITE.

[22:52] <timotimo> i.e. an nqp::isconcrete check

[22:52] <timotimo> um

[22:52] <timotimo> how can something be neither type object nor instance?

[22:52] <timotimo> hm, well, nqp::null i suppose?

[22:52] <timotimo> but those aren't supposed to show up in perl6 space at all

[22:52] <raiph> I think I'm definite about that, but it's possible the definitions aren't exactly meant to be precise :)

[22:54] <psch> fwiw, replacing all .DEFINITE calls with .defined gives me PASS for all files in t/spec/procasync

[22:55] <psch> i think that's the right files to run, anyway :)

[22:56] <psch> raiph: called on an object that is neither type object nor instance, from your quote .DEFINITE should be undefined, as i read it

[22:56] <psch> ...which most likely just makes all of this worse :)

[22:57] <raiph> Hmm. Correction. I think p6doc wording logically entails that *some* values that are neither type object nor instance *may* return False.

[22:57] <raiph> (for .DEFINITE)

[22:58] <psch> in any case, i can't think of any code that produces differing results between .defined and .DEFINITE

[22:59] <psch> well, except something that overrides .defined

[22:59] <psch> which is covered by what i wrote above

[23:00] <timotimo> we could do a quick survey of what implementations of method defined exist in core

[23:00] <raiph> psch: Yes. Per the p6doc lines I quoted, .defined and .DEFINITE are the same for all values -- except that for non type object / non instance it's True for .defined and undefined for .DEFINITE which means it can at most be different by being False

[23:01] <timotimo> raiph: you're wrong

[23:01] <raiph> timotimo: OK. :)

[23:01] <timotimo> raiph: defined may also return 1, "hello", IO::Handle.new("/etc/passwd"), or -> { 1.rand }

[23:02] <raiph> timotimo: note that I'm not speaking of how things actually are in the spec or rakudo or how they're meant to be, just what I infer from the p6doc lines I quoted (which are presumably slightly off)

[23:03] *** FROGGS joined
[23:04] *** KCL left
[23:06] <timotimo> OK

[23:06] <raiph> Heh. I'm blind.

[23:08] <raiph> So p6doc says for Mu.defined "Returns False on the type object, and True otherwise." I believed that. But then a couple lines later "Very few types (like Failure) override defined to return False even for instances".

[23:10] <raiph> Which totally makes sense of course. I'd even read that before and enjoyed it. Part of the P6 approach to maybes/exceptions. And very  simple, really.

[23:15] *** Peter_R left
[23:15] <psch> m: { 1 + "a"; CATCH { default { .defined.say; .DEFINITE.say } } } # i'm still confused

[23:15] <camelia> rakudo-moar 16d366: OUTPUT«True␤True␤»

[23:16] <psch> m: { 1 + "a"; CATCH { default { .defined.say; .DEFINITE.say; .say } } } # i think

[23:16] <camelia> rakudo-moar 16d366: OUTPUT«True␤True␤Cannot convert string to number: base-10 number must begin with valid digits or '.' in '⏏a' (indicated by ⏏)␤  in block <unit> at /tmp/MbtNvTOfch:1␤␤»

[23:16] <psch> yeah, i am

[23:16] <timotimo> so a failure being defined is confusing to you?

[23:16] <timotimo> er, i mean

[23:16] <timotimo> is that the object of confusion?

[23:16] <psch> timotimo: in conjunction with raiph++'s quote, yes

[23:17] <psch> iff p6doc says Failure overrides .defined to be False and its True in the impl, that's confusing

[23:17] *** FROGGS left
[23:18] <psch> of course it might be that p6doc is wrong, i'm not precluding that possibility

[23:18] <psch> i also think that p6devs mostly do things right, which means that the impl is probably correct

[23:19] <pink_mist> I seem to recall reading something like that in one of the early synopses

[23:19] *** Peter_R joined
[23:20] <pink_mist> ah right, here: http://design.perl6.org/S02.html#Undefined_types

[23:20] <raiph> My latest thinking is that what is intended is: DEFINITE == True for what I'll call normal objects and False for abnormal objects, and .defined is the same with the exception that some objects that want to be normal can pretend for a while to be abnormal until maybe normal code notices -- or doesn't, in which case it throws itself as an abnormality

[23:21] <raiph> (for above purposes type objects are considered abnormal objects)

[23:21] *** n0tjack joined
[23:21] <timotimo> psch: though, inside a CATCH, wouldn't it actually be the exception rather than the failure?

[23:22] <timotimo> m: my $result = 1 + "a"; say $result.DEFINITE; say $result.defined

[23:22] <camelia> rakudo-moar 16d366: OUTPUT«Cannot convert string to number: base-10 number must begin with valid digits or '.' in '⏏a' (indicated by ⏏)␤  in block <unit> at /tmp/N1z4SIkNm_:1␤␤Actually thrown at:␤  in block <unit> at /tmp/N1z4SIkNm_:1␤␤»

[23:22] <timotimo> m: my $result = try 1 + "a"; say $result.DEFINITE; say $result.defined

[23:22] <camelia> rakudo-moar 16d366: OUTPUT«False␤False␤»

[23:22] <timotimo> m: my $result = try 1 + "a"; say $result.WHAT; say $result.DEFINITE; say $result.defined

[23:22] <camelia> rakudo-moar 16d366: OUTPUT«(Any)␤False␤False␤»

[23:22] <timotimo> m: my $result = try 1 + "a"; say $result

[23:22] <camelia> rakudo-moar 16d366: OUTPUT«(Any)␤»

[23:22] <timotimo> huh?

[23:22] <timotimo> that ... doesn't seem right to me?

[23:23] <psch> m: my $s = Failure.new; say $s.defined; say $s.DEFINITE 

[23:23] <camelia> rakudo-moar 16d366: OUTPUT«False␤True␤»

[23:23] <psch> timotimo: you're right about Exception inside the CATCH, yeah

[23:24] <psch> timotimo: but try leaking the Failure was deemed a bug a few months back, iirc

[23:24] <timotimo> try leaking the failure?

[23:24] <timotimo> you mean why $result didn't have the failure?

[23:25] <timotimo> hmm

[23:25] <psch> yeah, try is { ... { CATCH { default { } } }

[23:25] <psch> where ... is the code appended

[23:25] *** n0tjack left
[23:25] <timotimo> mhm

[23:30] *** laouji joined
[23:35] *** FROGGS joined
[23:37] <psch> timotimo: http://irclog.perlgeek.de/perl6/2014-10-25#i_9564960 "a few months back" actually means "almost a year", in some cases... :)

[23:38] <dalek> nqp/js: 65169c8 | (Pawel Murias)++ | src/vm/js/QAST/Compiler.nqp:

[23:38] <dalek> nqp/js: Store ctx in $*CTX in preparation for implementing nqp::handle.

[23:38] <dalek> nqp/js: review: https://github.com/perl6/nqp/commit/65169c8728

[23:38] <dalek> nqp/js: 43fc557 | (Pawel Murias)++ | src/vm/js/QAST/Compiler.nqp:

[23:38] <dalek> nqp/js: When compiling a return make it have a $T_VOID type instead of a $T_OBJ one.

[23:38] <dalek> nqp/js: review: https://github.com/perl6/nqp/commit/43fc55766e

[23:38] <dalek> nqp/js: d67f2a1 | (Pawel Murias)++ | src/vm/js/ (3 files):

[23:38] <dalek> nqp/js: Pass test 44.

[23:38] <dalek> nqp/js: 

[23:38] <dalek> nqp/js: Implement throwing, resuming, catching and rethrowing exceptions.

[23:38] <dalek> nqp/js: 

[23:38] <dalek> nqp/js: try/catch has a hefty performance penalty under v8 as it turns of optimalizations.

[23:38] <dalek> nqp/js: Benchmarking and thinking things over is necessary if we want to minimalize the impact of that.

[23:38] <dalek> nqp/js: This commit implement exceptions naively.

[23:38] <dalek> nqp/js: review: https://github.com/perl6/nqp/commit/d67f2a1ab3

[23:38] <dalek> nqp/js: f282ebe | (Pawel Murias)++ | src/vm/js/nqp-runtime/runtime.js:

[23:38] <dalek> nqp/js: Fix bug when an exception is unhandled.

[23:38] <dalek> nqp/js: review: https://github.com/perl6/nqp/commit/f282ebe53b

[23:38] <dalek> nqp/js: ca3389d | (Pawel Murias)++ | src/vm/js/ (2 files):

[23:38] <dalek> nqp/js: Make seekfh throw exceptions when passed an invalid offset or whence 0 and a negative offset.

[23:38] <dalek> nqp/js: review: https://github.com/perl6/nqp/commit/ca3389d935

[23:38] <dalek> nqp/js: fabfc28 | (Pawel Murias)++ | src/vm/js/ (2 files):

[23:38] <dalek> nqp/js: Stub nqp::getstdin.

[23:38] <dalek> nqp/js: review: https://github.com/perl6/nqp/commit/fabfc28cf1

[23:40] <labster> m: 1/128 == (1/128).perl.EVAL

[23:40] <camelia> rakudo-moar 16d366: OUTPUT«WARNINGS:␤Useless use of "==" in expression "/128 == (1/128).perl.EVAL" in sink context (line 1)␤»

[23:40] <labster> m: say 1/128 == (1/128).perl.EVAL

[23:40] <camelia> rakudo-moar 16d366: OUTPUT«False␤»

[23:42] *** telex left
[23:42] *** mprelude left
[23:42] <grondilu> glad to see the js backend is still on its way

[23:44] <labster> yes.  pmurias++

[23:44] *** telex joined
[23:49] <grondilu> lately I've been learning a bit of HTML5/WebGL and a js backend is my only hope to ever use it with Perl 6, isn't it?

[23:49] <grondilu> thus a js backend would really be cool

[23:52] *** FROGGS left
[23:52] <psch> grondilu: you probably could write a p6 server-side webapp that dynamically serves webgl, but i think that'd be somewhat backwards...

[23:59] *** BenGoldberg left
