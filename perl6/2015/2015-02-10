[00:03] *** baest left
[00:04] <dalek> rakudo/nom: 0cb22e8 | hoelzro++ | src/core/Str.pm:

[00:04] <dalek> rakudo/nom: Simplify easter egg for Str.WHY

[00:04] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/0cb22e87a3

[00:04] *** colomon joined
[00:06] <Util> timotimo: uniq is deprecated in Rakudo in favor of unique.

[00:06] <timotimo> yes, i was using a quite old rakudo

[00:07] *** clkao joined
[00:08] *** baest joined
[00:09] *** vendethiel left
[00:10] *** vendethiel joined
[00:21] *** Possum left
[00:24] *** Possum joined
[00:28] <lumimies> m: class A { class B is A { } }

[00:28] <camelia> rakudo-moar 7b39da: OUTPUT¬´[31m===[0mSORRY![31m===[0m Error while compiling /tmp/2DxvyXuavR‚ê§'B' cannot inherit from 'A' because 'A' isn't compose yet (maybe it is stubbed)‚ê§at /tmp/2DxvyXuavR:1‚ê§------> ‚ê§¬ª

[00:29] <lumimies> Shouldn't that say "composed", and not "compose"?

[00:31] <skids> Yeah probably.

[00:31] *** Spot__ joined
[00:31] <timotimo> right

[00:31] *** vendethiel left
[00:32] <timotimo> gnite #perl6

[00:32] *** vendethiel joined
[00:33] <raydiak> g'night timotimo 

[00:33] *** Possum left
[00:40] *** Possum joined
[00:43] *** dayangkun joined
[00:44] <dalek> nqp/js: 0df6ef3 | hoelzro++ | tools/build/Makefile-JS.in:

[00:44] <dalek> nqp/js: Add a dummy install rule for JS backend

[00:44] <dalek> nqp/js: review: https://github.com/perl6/nqp/commit/0df6ef33da

[00:44] <dalek> nqp/js: f9660d0 | hoelzro++ | tools/build/Makefile-JS.in:

[00:44] <dalek> nqp/js: Make sure nqp-m is built before trying to build MoarVM files

[00:44] <dalek> nqp/js: 

[00:44] <dalek> nqp/js: This allows us to build nqp-js in parallel via the -j option

[00:45] <dalek> nqp/js: review: https://github.com/perl6/nqp/commit/f9660d032d

[00:46] *** baest left
[00:48] *** jack_rabbit joined
[00:50] <masak> 'night, #perl6

[00:52] <raydiak> good night masak 

[00:58] *** baest joined
[01:02] *** dayangkun left
[01:08] <japhb> Am I correctly interpreting that we're in the process of merging nqp-js back to the main nqp repo?

[01:09] <japhb> (from the commits dalek posted ~25 min ago)

[01:10] *** colomon left
[01:12] *** colomon joined
[01:15] *** vendethiel left
[01:17] *** vendethiel joined
[01:21] <TimToady> well, insofar as a branch is considered part of the repo, yes

[01:21] <TimToady> even got mentioned in the weekly

[01:25] *** DarthGandalf joined
[01:25] *** adu joined
[01:25] <raydiak> m: my $a; BEGIN { $a := 1; say $a; }; say $a; # binding at BEGIN time doesn't seem to stick around for runtime...is this a bug?

[01:25] <camelia> rakudo-moar 0cb22e: OUTPUT¬´1‚ê§(Any)‚ê§¬ª

[01:26] <raydiak> m: my $a; BEGIN { $a = 1; say $a; }; say $a; # works with assignment

[01:26] <camelia> rakudo-moar 0cb22e: OUTPUT¬´1‚ê§1‚ê§¬ª

[01:27] <japhb> Oh, weekly out?  Cool, didn't expect it this early in the week!

[01:28] <TimToady> raydiak: seems like a bug to me, but someone might come up with a reason not to fix it

[01:29] <raydiak> thanks TimToady, I'll report it then

[01:30] <raydiak> m: my @a; BEGIN { @a = 1; say @a; }; say @a; # I didn't get any feedback on this similar one earlier today, but I've decided it's also a (separate) bug, should work, and will report it too

[01:30] <camelia> rakudo-moar 0cb22e: OUTPUT¬´1‚ê§1‚ê§¬ª

[01:30] <raydiak> it works?

[01:30] <raydiak> m: my @a; BEGIN { @a = 1; }; say @a; 

[01:30] <camelia> rakudo-moar 0cb22e: OUTPUT¬´This type does not support elems‚ê§  in method REIFY at src/gen/m-CORE.setting:9891‚ê§  in method REIFY at src/gen/m-CORE.setting:10357‚ê§  in method reify at src/gen/m-CORE.setting:8942‚ê§  in block  at src/gen/m-CORE.setting:8967‚ê§  in method reify at s‚Ä¶¬ª

[01:30] <raydiak> yeah that...heisenbug I guess, something about the lazyness and the phaser

[01:30] <raydiak> *laziness

[01:33] *** rurban left
[01:39] *** vendethiel left
[01:41] <raydiak> r: my $a; BEGIN { $a := 1; say $a; }; say $a;

[01:41] <camelia> rakudo-{parrot,moar} 0cb22e: OUTPUT¬´1‚ê§(Any)‚ê§¬ª

[01:41] <raydiak> r-j: my $a; BEGIN { $a := 1; say $a; }; say $a;

[01:41] <camelia> rakudo-jvm 0cb22e: OUTPUT¬´Can't open perl script "/home/camelia/jvm-rakudo/eval-client.pl": No such file or directory‚ê§¬ª

[01:41] *** vendethiel joined
[01:42] <raydiak> r: my $a; BEGIN { $a = 1; say $a; }; say $a;

[01:42] <camelia> rakudo-{parrot,moar} 0cb22e: OUTPUT¬´1‚ê§1‚ê§¬ª

[01:42] <raydiak> r: my @a; BEGIN { @a = 1; say @a; }; say @a;

[01:42] <camelia> rakudo-{parrot,moar} 0cb22e: OUTPUT¬´1‚ê§1‚ê§¬ª

[01:42] <raydiak> r: my @a; BEGIN { @a = 1; }; say @a;

[01:42] <camelia> rakudo-moar 0cb22e: OUTPUT¬´This type does not support elems‚ê§  in method REIFY at src/gen/m-CORE.setting:9891‚ê§  in method REIFY at src/gen/m-CORE.setting:10357‚ê§  in method reify at src/gen/m-CORE.setting:8942‚ê§  in block  at src/gen/m-CORE.setting:8967‚ê§  in method reify at s‚Ä¶¬ª

[01:42] <camelia> ..rakudo-parrot 0cb22e: OUTPUT¬´This type does not support elems‚ê§  in method REIFY at gen/parrot/CORE.setting:9828‚ê§  in method REIFY at gen/parrot/CORE.setting:10301‚ê§  in method reify at gen/parrot/CORE.setting:8940‚ê§  in block  at gen/parrot/CORE.setting:8927‚ê§  in method reif‚Ä¶¬ª

[01:46] *** yeahnoob joined
[01:47] *** kaleem joined
[01:47] <raydiak> r: my @a; BEGIN { @a = 1; @a.reify; }; say @a;

[01:47] <camelia> rakudo-{parrot,moar} 0cb22e: OUTPUT¬´===SORRY!===‚ê§No such method 'reify' for invocant of type 'Array'‚ê§¬ª

[01:48] <raydiak> r: my @a; BEGIN { @a = 1; @a.REIFY; }; say @a;

[01:48] <camelia> rakudo-parrot 0cb22e: OUTPUT¬´===SORRY!===‚ê§Not enough positional parameters passed; got 1 but expected 3‚ê§¬ª

[01:48] <camelia> ..rakudo-moar 0cb22e: OUTPUT¬´===SORRY!===‚ê§Too few positionals passed; expected 3 arguments but got 1‚ê§¬ª

[01:49] <raydiak> r: my @a; BEGIN { @a = 1; @a.REIFY(1); }; say @a;

[01:49] <camelia> rakudo-moar 0cb22e: OUTPUT¬´===SORRY!===‚ê§Too few positionals passed; expected 3 arguments but got 2‚ê§¬ª

[01:49] <camelia> ..rakudo-parrot 0cb22e: OUTPUT¬´===SORRY!===‚ê§Type check failed in binding parcel; expected 'Parcel' but got 'Int'‚ê§¬ª

[01:49] <raydiak> r: my @a; BEGIN { @a = 1; @a.REIFY(1,1); }; say @a;

[01:49] <camelia> rakudo-{parrot,moar} 0cb22e: OUTPUT¬´===SORRY!===‚ê§Type check failed in binding parcel; expected 'Parcel' but got 'Int'‚ê§¬ª

[01:51] <raydiak> r: my %a; BEGIN { %a = 1 => 1 }; say %a;

[01:51] <camelia> rakudo-{parrot,moar} 0cb22e: OUTPUT¬´1 => 1‚ê§¬ª

[01:57] *** baest left
[01:59] *** gr33n7007h left
[02:02] *** baest joined
[02:21] *** eternaleye left
[02:24] *** vendethiel left
[02:25] <dalek> doc: ccc9213 | util++ | lib/Language/5to6.pod:

[02:25] <dalek> doc: Initial version of Perl 5 to Perl 6 translation index.

[02:26] <dalek> doc: review: https://github.com/perl6/doc/commit/ccc9213d79

[02:26] <dalek> doc: 0514cd2 | util++ | lib/Language/5to6.pod:

[02:26] <dalek> doc: Add "Other sources of translation knowledge" to Language/5to6

[02:26] <dalek> doc: review: https://github.com/perl6/doc/commit/0514cd2fc3

[02:26] <dalek> doc: b3e5709 | util++ | lib/Perl6/TypeGraph/Viz.pm:

[02:26] <dalek> doc: Change Viz to work with Rakudo Star 2014.12

[02:26] <dalek> doc: review: https://github.com/perl6/doc/commit/b3e570960c

[02:27] *** eternaleye joined
[02:28] <dalek> ecosystem: a62f748 | (Andrew Egeler)++ | META.list:

[02:28] <dalek> ecosystem: Add SOAP::Client

[02:28] <dalek> ecosystem: review: https://github.com/perl6/ecosystem/commit/a62f748dc1

[02:29] *** vendethiel joined
[02:31] *** kaleem left
[02:33] *** fhelmberger joined
[02:35] *** baest left
[02:36] *** novice123 joined
[02:37] *** eternaleye left
[02:37] *** fhelmberger left
[02:38] *** novice123 left
[02:38] *** eternaleye joined
[02:45] *** baest joined
[02:49] *** eternaleye_ joined
[02:51] *** eternaleye left
[02:51] *** eternaleye_ is now known as eternaleye

[02:59] *** colomon left
[02:59] *** colomon joined
[03:11] *** amaliapomian joined
[03:12] *** noganex_ joined
[03:15] *** noganex left
[03:18] *** Psyche^ joined
[03:22] *** Patterner left
[03:49] <dalek> perl6-most-wanted: 1392c27 | Adrian++ | most-wanted/bindings.md:

[03:49] <dalek> perl6-most-wanted: Mention some WIPs

[03:49] <dalek> perl6-most-wanted: review: https://github.com/perl6/perl6-most-wanted/commit/1392c27afa

[03:58] *** vendethiel left
[03:58] <dalek> nqp/js: d50cf6d | hoelzro++ | src/vm/js/QAST/Compiler.nqp:

[03:58] <dalek> nqp/js: Actually use setup array in callmethod

[03:58] <dalek> nqp/js: review: https://github.com/perl6/nqp/commit/d50cf6d069

[04:00] <dalek> perl6-most-wanted: f12ee35 | Adrian++ | most-wanted/modules.md:

[04:00] <dalek> perl6-most-wanted: Update modules.md

[04:00] <dalek> perl6-most-wanted: 

[04:00] <dalek> perl6-most-wanted: Add a few wanted modules, mention a few WIPs.

[04:00] <dalek> perl6-most-wanted: review: https://github.com/perl6/perl6-most-wanted/commit/f12ee35533

[04:00] *** panchiniak joined
[04:02] <raiph> .tell timotimo: http://nbviewer.ipython.org/github/zmughal/zmughal-iperl-notebooks/blob/master/IPerl-demos/20150209_IPerl_display_demo.ipynb

[04:02] <yoleaux> raiph: What kind of a name is "timotimo:"?!

[04:02] <raiph> .tell timotimo http://nbviewer.ipython.org/github/zmughal/zmughal-iperl-notebooks/blob/master/IPerl-demos/20150209_IPerl_display_demo.ipynb

[04:02] <yoleaux> raiph: I'll pass your message to timotimo.

[04:06] *** vendethiel joined
[04:13] <dj_goku> so I am trying to use NativeCall. how can I represent a null pointer?

[04:16] <tony-o> probably an undefined instance of "is repr('CPointer')"

[04:18] <skids> Yes use the type of the pointer.

[04:19] <skids> e.g. CArray[int] or buf8 or your CPointer class's name or whatnot.

[04:22] <dj_goku> so class ANull is repr('CPointer') {}

[04:23] <dj_goku> sub test(ANull()) is native('lib') { * }

[04:23] <dj_goku> ?

[04:23] <skids> I think you can just jam OpaquePointer in there, but I generally try to match the type.

[04:25] *** BenGoldberg left
[04:25] <dj_goku> well the docs just says NULL so.

[04:25] <dj_goku> method(NULL)

[04:25] <dj_goku> not sure why you would just pass in NULL.

[04:26] <skids> dj_goku: https://github.com/skids/perl6sum/blob/master/lib/Sum/libmhash.pm6 see lines 182 and 239

[04:28] *** vendethiel left
[04:31] *** telex left
[04:31] <tony-o> you could also just try passing an int32 in

[04:32] <TimToady> what if it's a 64-bit pointer?

[04:32] *** telex joined
[04:32] <tony-o> int64

[04:32] <skids> What if it's a 32 bit pointer?

[04:32] *** vendethiel joined
[04:33] <tony-o> just do an array of int8s of guesstimated size

[04:33] <TimToady> not that pointers are guaranteed to match integer sizes under C anyway

[04:33] <TimToady> void* isn't even guarangeed to match int*

[04:33] <TimToady> *teed

[04:34] <TimToady> modern machines mostly let us cheat on that, of course, but it was not always so

[04:36] <TimToady> but on the old word-based machines, a word pointer could be smaller than something that has to point into a word

[04:37] <skids> C is indeed a "swordfight on a greased floor"

[04:38] <dj_goku> I am trying to start here: gearman_client_st *client= gearman_client_create(NULL);

[04:38] <dj_goku> lol

[04:38] <dj_goku> I have no idea what I am doing.

[04:39] <skids> First you need the prototype of gearman_client_create.

[04:40] <skids> Appears to be 'gearman_client_st *gearman_client_create(gearman_client_st *client)'

[04:40] <dj_goku> my sub client(CArray[int8]) returns Instance is native('libgearman') is symbol('gearman_client_create') { * }

[04:42] <skids> my sub client(Instance) returns Instance is native('libgearman') is symbol('gearman_client_create') { * }

[04:42] <skids> and class Instance is REPR('Cpointer') { stuff }

[04:42] <skids> You can choose another name other than "Instance" if you like.

[04:43] <skids> But then you'd e.g. my Instance $i = client(Instance);

[04:43] <skids> Then check $i.defined to make sure you got something.

[04:43] <dj_goku> hmm

[04:47] <dj_goku> m: class Instance is repr('CPointer') { my sub client(Instance) returns Instance is native('libgearman') is symbol('gearman_client_create') { * } }

[04:47] <camelia> rakudo-moar 0cb22e: OUTPUT¬´[31m===[0mSORRY![31m===[0m Error while compiling /tmp/pk3pihuJhN‚ê§Can't use unknown trait 'is native' in a sub declaration.‚ê§at /tmp/pk3pihuJhN:1‚ê§------> ‚ê§    expecting any of:‚ê§        rw parcel hidden_from_backtrace hidden_from_USAGE‚ê§       ‚Ä¶¬ª

[04:48] <skids> star: use NativeCall; class Instance is repr('CPointer') { my sub client(Instance) returns Instance is native('libgearman') is symbol('gearman_client_create') { * } }

[04:48] <camelia> star-{m,p} 2015.01: ( no output )

[04:48] <dj_goku> whoops

[04:48] <dj_goku> use NativeCall; :D

[04:49] <skids> (Actually surprised that did not die by not finding libgearman.)

[04:49] <avuserow_> it won't die until first use

[04:50] <skids> It does in some scenarios IIRC, like if you use the file that uses NativeCall.

[04:50] <avuserow_> star-m: use NativeCall; class Instance is repr('CPointer') { }; my sub client(Instance) returns Instance is native('libgearman') is symbol('gearman_client_create') { * }; client(Instance)

[04:50] <camelia> star-m 2015.01: OUTPUT¬´Cannot locate native library 'libgearman.so'‚ê§  in method postcircumfix:<( )> at /home/camelia/rakudo-star-2015.01/install/languages/perl6/lib/NativeCall.pm6:130‚ê§  in block <unit> at /tmp/E7NxWAzias:1‚ê§‚ê§¬ª

[04:54] <dj_goku> so $i.defined is true.

[04:54] <dj_goku> !

[04:54] <skids> \o/

[04:58] <dj_goku> so that means if found the method in the library libgearman right?

[05:00] <skids> Most probably, yes.  Next find a sub that takes a gearman_client_st and returns something recognizeable, and you can be sure.

[05:01] <skids> e.g. see if you can set and then get the gearman_client_timeout

[05:04] *** chenryn joined
[05:14] *** raiph left
[05:20] <dj_goku> skids: thanks, still kind of lost.

[05:41] *** kaleem joined
[05:45] *** kaleem left
[05:50] <dj_goku> so the return of gearman_client_add_server() is an enum: https://github.com/jeffreyhorner/gearman/blob/master/src/libgearman-1.0/return.h#L44 how would I represent that in NativeCall int?

[05:58] <avuserow_> dj_goku: so there, GEARMAN_SUCCESS would be 0, and 1 additional for each enum item until you get to the ones with =

[05:59] <avuserow_> I've had success with copy/pasting those enum lists and reworking it to be P6 syntax

[05:59] *** vendethiel left
[06:00] <avuserow_> let me take a stab at this one for an example

[06:01] *** diana_olhovik_ joined
[06:04] *** mr-foobar left
[06:06] <jdv79> Gearman can be a pain because it uses blocking sockets.  It does not appreciate network instability.  And i do not appreciate babysitting it during those times.

[06:08] *** vendethiel joined
[06:09] <avuserow_> dj_goku: https://gist.github.com/avuserow/d015dd9a34891880de37 # one way of doing it

[06:09] <avuserow_> if you didn't want to keep the comments, then you can use a qw-style list which is a lot easier to convert

[06:10] *** xfix joined
[06:11] *** wicope joined
[06:12] <avuserow_> not sure if there's a way to add in the aliased ones, haven't had to deal with that one before

[06:22] *** diana_olhovik_ left
[06:26] *** bjz joined
[06:30] *** crux left
[06:31] *** bjz left
[06:42] *** Rounin joined
[06:45] *** jack_rabbit left
[06:54] *** kaleem joined
[06:55] *** jack_rabbit joined
[06:59] *** Akagi201 left
[07:00] *** Akagi201 joined
[07:01] *** crux joined
[07:06] *** dayangkun joined
[07:11] *** jack_rabbit left
[07:13] *** darutoko joined
[07:15] *** rindolf joined
[07:15] *** diana_olhovik joined
[07:20] *** Akagi201_ joined
[07:20] *** dayangkun left
[07:22] *** Akagi201 left
[07:31] *** bjz joined
[07:36] *** _mg_ joined
[07:39] *** espadrine joined
[07:42] <_mg_> homebrew is updated to Rakudo Star 2015.01

[07:47] *** FROGGS joined
[07:51] *** vendethiel left
[07:53] *** _mg_ left
[07:55] *** _dolmen_ joined
[07:57] <[Tux]> https://gist.github.com/Tux/79249758ad2a5ae78984 <= I think this is a new segv

[07:57] *** vendethiel joined
[07:58] <FROGGS> [Tux]: no, it is the same

[07:58] <[Tux]> ok

[07:58] <FROGGS> see https://github.com/MoarVM/MoarVM/issues/175

[07:58] <FROGGS> m: use Test; class Foo { method bar { } }; my $foo = Foo.new; my @a = <a b c d>; sub baz(|) { ok $foo.bar, "bar" }; for @a { for @a { baz @a } }

[07:58] <camelia> rakudo-moar 0cb22e: OUTPUT¬´(signal SEGV)not ok 1 - bar‚ê§‚ê§# Failed test 'bar'‚ê§# at /tmp/7H6x0jeroR line 1‚ê§not ok 2 - bar‚ê§‚ê§# Failed test 'bar'‚ê§# at /tmp/7H6x0jeroR line 1‚ê§not ok 3 - bar‚ê§‚ê§# Failed test 'bar'‚ê§# at /tmp/7H6x0jeroR line 1‚ê§not ok 4 - bar‚ê§‚ê§# Faile‚Ä¶¬ª

[07:59] <FROGGS> this is the golfed version

[08:00] *** _dolmen_ left
[08:02] *** prime- joined
[08:04] *** prime left
[08:05] *** Ven_ joined
[08:09] *** xfix left
[08:11] <FROGGS> [Tux]: can you check that this also "solves" the problem for you? https://gist.github.com/FROGGS/1effa794a059e6e4eddd

[08:12] <[Tux]> $ locate spesh/log.c

[08:12] <[Tux]>  /pro/3gl/CPAN/rakudobrew/moar-nom/nqp/MoarVM/src/spesh/log.c

[08:12] <[Tux]>  /pro/3gl/CPAN/rakudobrew/git_reference/MoarVM/src/spesh/log.c

[08:12] <[Tux]> which of the two?

[08:14] <FROGGS> the former I guess

[08:14] <FROGGS> the latter is the cloned repo, not your build root for moarvm

[08:15] <FROGGS> after patching you'd have to: cd /pro/3gl/CPAN/rakudobrew/moar-nom/nqp/MoarVM && make install

[08:15] <FROGGS> and leave nqp and rakudo untouched

[08:16] *** abraxxa joined
[08:16] <[Tux]> unless I did something wrong, it doesn't fix the issue

[08:16] <[Tux]> https://gist.github.com/Tux/e398c043a80ecf498a05

[08:18] <FROGGS> strange

[08:18] <FROGGS> but possible, given that my "patch" is more then weird also

[08:19] *** _mg_ joined
[08:19] *** vendethiel left
[08:20] *** zakharyas joined
[08:22] *** vendethiel joined
[08:24] <avuserow_> m: sub foo(*%h) {say %h.perl}; foo(a => 1); my $a = "foo"; foo($a => 1); # is it possible to make the latter call work?

[08:24] <camelia> rakudo-moar 0cb22e: OUTPUT¬´("a" => 1).hash‚ê§Too many positionals passed; expected 0 arguments but got 1‚ê§  in sub foo at /tmp/Zeym0JsAkS:1‚ê§  in block <unit> at /tmp/Zeym0JsAkS:1‚ê§‚ê§¬ª

[08:25] <Ven_> hoelzro: are you interested in racket :)?

[08:26] <avuserow_> m: sub foo(*%h) {say %h.perl}; foo(a => 1); my $a = "foo"; foo(|{$a => 1}); # this works, is there a better way?

[08:26] <camelia> rakudo-moar 0cb22e: OUTPUT¬´("a" => 1).hash‚ê§("foo" => 1).hash‚ê§¬ª

[08:27] <moritz> good morning

[08:28] <moritz> ftr, I now know why ilbot and me disappeared yesterday night

[08:28] <moritz> the VM had to be shut down and restarted because the hypervisor on which it ran was broken

[08:29] <Ven_> .oO( I certainly missed ilbot )

[08:30] <moritz> such a good, silent companion

[08:30] <[Tux]> I asked in Brussel: is the method that shows perl6 errors in full color with the eject character also available to scripts?

[08:31] <[Tux]> show_colored_error("Message", $position);

[08:31] <moritz> [Tux]: it's in X::Comp.gist

[08:32] <moritz> [Tux]: I geuess it could be factored out a bit better

[08:37] *** xinming joined
[08:39] *** pdcawley joined
[08:41] *** Ven_ left
[08:45] *** espadrine left
[08:45] *** Alina-malina left
[08:49] *** Alina-malina joined
[09:00] <sergot> morning :)

[09:04] *** baest left
[09:04] *** vendethiel left
[09:07] *** vendethiel joined
[09:07] *** panchiniak left
[09:08] *** _mg_ left
[09:12] *** yeahnoob left
[09:13] <moritz> serg\ot

[09:13] <jnthn> o/

[09:19] *** araujo joined
[09:19] <tadzik> hello hello

[09:23] *** lue is now known as ShimmerFairy

[09:25] *** Ven_ joined
[09:27] *** yoleaux left
[09:30] *** Ven_ left
[09:35] *** andreoss joined
[09:35] *** [Sno] left
[09:38] *** rurban joined
[09:40] *** espadrine joined
[09:40] <dalek> doc: 6d0c745 | paultcochrane++ | lib/Language/regexes.pod:

[09:40] <dalek> doc: Typographical etc. corrections in regexes.pod

[09:40] <dalek> doc: review: https://github.com/perl6/doc/commit/6d0c745672

[09:40] <dalek> doc: d06a7a5 | paultcochrane++ | lib/Language/regexes.pod:

[09:40] <dalek> doc: Unicode categories now group with parens in Rakudo

[09:40] <dalek> doc: review: https://github.com/perl6/doc/commit/d06a7a5b4c

[09:40] <dalek> doc: 116cefa | paultcochrane++ | lib/Language/regexes.pod:

[09:40] <dalek> doc: Wrap paragraphs more consistently in regexes.pod

[09:40] <dalek> doc: review: https://github.com/perl6/doc/commit/116cefa536

[09:46] *** f3ew left
[09:46] *** dakkar joined
[09:48] <JimmyZ> paultcochrane++

[09:49] *** vendethiel left
[09:53] *** vendethiel joined
[09:54] <masak> good anteno\on, #perl6

[09:56] *** pdcawley left
[09:57] *** f3ew joined
[09:59] *** stux|RC-only left
[10:03] *** stux|RC-only joined
[10:03] <masak> colomon++ # https://justrakudoit.wordpress.com/2015/02/02/rakudo-to-do-list/

[10:05] <jnthn> First two are high on my list too, though want to get through the natives stuff and dig into NFG first.

[10:06] <jnthn> I'll leave the third one for the mathematically inclined to ponder. :)

[10:16] *** sqirrel_ joined
[10:19] *** coffee` joined
[10:24] *** adu left
[10:25] *** [Sno] joined
[10:29] *** pdcawley joined
[10:33] *** chenryn left
[10:33] *** Ven_ joined
[10:34] *** _mg_ joined
[10:35] *** myp joined
[10:35] *** fhelmberger joined
[10:37] *** adu joined
[10:39] *** fhelmberger left
[10:41] *** mvuets joined
[10:41] <masak> the third one is workaroundable.

[10:43] <masak> (though of course all these would be nice to have in core)

[10:46] *** kaleem left
[10:55] *** fhelmberger joined
[10:56] *** alini joined
[10:58] *** vendethiel left
[11:00] *** vendethiel joined
[11:02] *** sqirrel_ left
[11:05] <Ven_> hoelzro introduced the :) smiley...

[11:05] <Ven_> m: sub ('hey':){}

[11:05] <camelia> rakudo-moar 0cb22e: ( no output )

[11:13] *** chenryn joined
[11:13] <tadzik> :D

[11:13] <masak> I just realized something I want before 6.0.0^W6-day.

[11:14] <masak> I want us to dogfood parsing, and make something like PPI moot/core.

[11:14] <masak> (a) allow https://github.com/moritz/perl6-all-modules to perform searches on the AST level

[11:15] <masak> (b) same, but with all the spectests

[11:16] *** _mg_ left
[11:16] <masak> granted, colomon++'s list is more important because it's about stability. and this is a feature request.

[11:16] <masak> but it's one I feel isn't frivolous -- it's within our grasp, and it's *sorely lacking*. people come in and ask for it on a regular basis.

[11:16] <masak> it feels like a loop that we ought to close this year.

[11:18] <jnthn> masak: That ties in strongly with the AST stuff we need for macros, which as we've pondered will want compiler changes (to build the higher level tree in actions instead).

[11:20] <jnthn> It's at least as much work as the NSA/NFG/GLR things, and we'll do well to address those 3 and deal with the key stability issues we still have this year.

[11:20] <jnthn> Not to mention a lot of polishing.

[11:21] <masak> *nod*

[11:21] <masak> I'm not claiming this has priority over NSA/NFG/GLR.

[11:21] <FROGGS> yeah, I also dont expect that we will have time to grok macros this year too

[11:22] <masak> let me revise my stance to this: just as I want us to have worked out a way forward with macros in 2015, I want us to have worked out a way forward with self-parsing.

[11:22] <jnthn> Me either. I'm fine with it being worked out, but we don't have the time/resources to do it as well as it wants doing this year.

[11:22] <masak> and yes, Qtrees are the common feature of these two.

[11:23] *** jack_rabbit joined
[11:25] <jnthn> masak: I think "self parsing" should really end up being "pass the compiler source, get back a QTree"

[11:26] <masak> right.

[11:27] * masak is searching for the right word

[11:27] <masak> "get back a Qtree" doesn't completely cover it.

[11:27] <masak> because the Qtree is attached to a World.

[11:28] <masak> I think "messy" or "organic" or something like that is what I'm grasping for.

[11:28] <jnthn> Surely a QTree contains references to objects representing declarations

[11:28] <jnthn> Just as QAST::WVal does

[11:28] <masak> yes, that's what I mean.

[11:29] <masak> hm, so maybe the Qtree stands in for the World, actually.

[11:29] * masak .oO( Qtree, you mean the World to me )

[11:29] <jnthn> Dunno

[11:29] <jnthn> What I *do* know is that to really do this will need substantial changes in Perl6::[Actions&World]

[11:30] <masak> nodnodnod

[11:30] <masak> this is so much an experimental branch, it's silly

[11:30] <masak> I see it as a "two sides of the same coin" kind of thing. it makes sense both to ask "what's the method object for thie method Qtree?" *and* "what's the method Qtree for this method object?"

[11:32] *** chenryn left
[11:32] <jnthn> Yes, experimental branch indeed

[11:32] <masak> nice, one of my favorite programming books is on HN: http://www.vintage-basic.net/games.html -- https://news.ycombinator.com/item?id=9026063

[11:33] *** chenryn joined
[11:34] <jnthn> I'm fine with "work out a way forward"

[11:34] <masak> I think even that work could be quite exciting.

[11:34] <masak> and it might inform some of the work that needs to be done this year, too.

[11:34] *** tardisx joined
[11:34] <jnthn> But I'm against significant architectural changes to the heart of the compiler this year. It's too much risk/distraction.

[11:35] <masak> agree completely.

[11:35] <masak> but I think, taking a step back, that Perl 6 needs to have these kinds of concrete but lofty goals that push the envelope a little.

[11:35] <jnthn> For something that I'm confident, with time and care, we can do in a non-breaking way later.

[11:35] <El_Che> don't take away Christmas ;)

[11:35] <masak> I'm not proposing delaying Christmas, don't worry :P

[11:36] <El_Che> :)

[11:36] <jnthn> masak: Yes, it's important to keep the lofty goals, but also keep our eye on the more immediate prize too. :)

[11:36] <masak> I think the dream of self-parsing was sown early in me, and I consider it part of my mission in the Perl 6 community to bring it to fruition.

[11:36] <masak> that primarily means implementing macros, but there's other stuff involved too.

[11:37] <itz_> "of course we meant orthodox xmas using another way of counting years"

[11:38] <El_Che> "we meant the original Christmas, so come again when you've constructed a time machine"

[11:40] *** pmurias joined
[11:41] *** jack_rabbit left
[11:45] *** jack_rabbit joined
[11:45] <masak> actually I care much more about Perl 6 being able to *parse* Perl 6 than Perl 6 being implemented purely in Perl 6.

[11:48] <arnsholt> Agreed. Although arguably, Perl 6 parsing Perl 6 is sort of a prerequisite for Perl 6 in Perl 6

[11:54] <colomon> +6

[11:56] *** chenryn left
[11:56] *** Ven_ left
[11:56] *** chenryn joined
[12:01] *** alini left
[12:02] *** alini joined
[12:05] <timotimo> .botsnack

[12:07] *** jack_rabbit left
[12:16] *** raiph joined
[12:18] *** andreoss left
[12:18] <dalek> perl6-most-wanted: c00881d | timo++ | most-wanted/bindings.md:

[12:18] <dalek> perl6-most-wanted: add cairo and sdl2 bindings to the WIP parade

[12:18] <dalek> perl6-most-wanted: review: https://github.com/perl6/perl6-most-wanted/commit/c00881d500

[12:25] *** Kristien joined
[12:25] <Kristien> good morning

[12:29] *** telex left
[12:29] *** Kristien left
[12:30] *** telex joined
[12:31] *** vendethiel left
[12:32] *** vendethiel joined
[12:35] *** dayangkun joined
[12:36] <|Tux|> Text::CSV just passes an extra 17000 tests and does not dump core anymore

[12:39] *** rmgk_ joined
[12:39] *** rmgk left
[12:39] *** rmgk_ is now known as rmgk

[12:39] *** xfix joined
[12:42] *** rurban left
[12:43] *** sqirrel_ joined
[12:45] <hoelzro> o/ #perl6

[12:45] <masak> \o

[12:46] <masak> |Tux|: wow.

[12:46] <masak> |Tux|: I don't have enough context for that, but it sounds rather big.

[12:46] <|Tux|> what it does is checking all allowed (and not allowed) combinations of sep, quo, esc and options

[12:46] <pmurias> hoelzro: hi

[12:47] <|Tux|> sep *must* be defined, but e.g. cannot be '\t' if allow-whitespace is true

[12:47] <hoelzro> morning masak, pmurias 

[12:47] <pmurias> masak: re Qtree macros one sensible approach would be to prototype things out using 007

[12:47] <|Tux|> I think I now need lizmat for new ideas about how to deal with streams and incomplete lines

[12:48] <masak> pmurias: that's what 007 is there for, yes.

[12:48] <masak> pmurias: it runs directly on Qtrees.

[12:50] <pmurias> masak: and re performing searches on the ast level can't we do in with the existing stuff (by using the existing parse tree/QAST)

[12:56] *** [Sno] left
[12:57] *** chenryn left
[12:58] <pmurias> findmethod is inconsistent across nqp-j and nqp-m

[12:58] <pmurias> it returns null on nqp-j

[12:58] <pmurias> and raises an exception on nqp-m

[13:00] <nwc10> pmurias: sorry if I'm asking a daft or obviosu question - nqp-js hasn't yet closed the bootstrap loop has it? And that's a big chunk of work?

[13:00] *** raiph left
[13:03] <pmurias> nwc10: the pre-rewrite nqp-js could compile itself and pass the tests, the current one can't

[13:04] <nwc10> ah OK.

[13:05] <nwc10> I'm very impressed with it all, but really not in a position to help, other than to bounce around enthusiastically and say "Well done"

[13:05] <pmurias> it's still a fair amount of stuff left for a bootstrap

[13:05] *** sqirrel_ left
[13:07] *** Ven_ joined
[13:07] *** adu left
[13:11] *** skids left
[13:15] <FROGGS> |Tux|: how did you work around the segfault?

[13:15] <|Tux|> by not causing an error

[13:16] <FROGGS> hmmmm

[13:16] *** vendethiel left
[13:16] <|Tux|> the error was caused by a stupid mistake: the parser is not allowed to start parsing when the attribute combination is not valid

[13:17] <|Tux|> remember why I need BUILD?

[13:17] <FROGGS> no, I dont

[13:17] <|Tux|> I forgot to check $sep being whitespace on whitespace allowed

[13:17] <dalek> nqp/js: d653ba7 | hoelzro++ | src/vm/js/nqp-runtime/runtime.js:

[13:17] <dalek> nqp/js: Handle undefined when to-stringing

[13:17] <dalek> nqp/js: review: https://github.com/perl6/nqp/commit/d653ba799d

[13:17] <FROGGS> ahh

[13:18] <|Tux|> short summary: ¬´my $csv = Text::CSV.new (sep => "\t", allow-whitespace => True);¬ª should fail

[13:18] <|Tux|> new assigns *directly* to the attributes, so I need a check after all attributes have been set

[13:18] <FROGGS> aye

[13:19] <|Tux|> combine that with the fact that I want (sep =>? ",") to be exactly the same as (sep_char => ",") and (sep-char => ",")

[13:19] <|Tux|> you'll probably see my need for BUILD

[13:20] <|Tux|> I need new (sep => ",") to be exactly the same as new().sep(",");

[13:20] <Ven_> .tell masak http://www.theerlangelist.com/2014/07/understanding-elixir-macros-part-6.html more insight on elixir's macros with macro-at-compile-time..."stuff"

[13:21] <|Tux|> every attribute has a setter and a getter, so every access can be checked for validity

[13:21] <FROGGS> m: class Foo { has $.sep; has $.allow-ws where { $_ && $!sep !~~ /^\s+$/ } }; Foo.new( :sep<\t>, :allow-ws ) # sad that this is NYI :o)

[13:21] <camelia> rakudo-moar 0cb22e: OUTPUT¬´[31m===[0mSORRY![31m===[0m Error while compiling /tmp/o2VFR1hUR7‚ê§Post-constraints on variables not yet implemented. Sorry. ‚ê§at /tmp/o2VFR1hUR7:1‚ê§------> [32mow-ws where { $_ && $!sep !~~ /^\s+$/ } [33m‚èè[31m}; Foo.new( :sep<\t>, :allow-ws ) #‚Ä¶¬ª

[13:21] <|Tux|> the where clauses will be a new temptation :)

[13:22] <Ven_> no bot?

[13:22] <Ven_> no tell..

[13:22] <FROGGS> once it is implemented, aye

[13:22] *** vendethiel joined
[13:22] <|Tux|> https://github.com/Tux/CSV/blob/master/test-t.pl#L229

[13:23] <FROGGS> |Tux|: the good thing about attribute where conditions is that even when you expose an attribute via different names, the check will happen at a single place

[13:23] * jnthn away for l'afternoon &

[13:23] <timotimo> have a good one, jnthn :)

[13:23] <|Tux|> additional conditions apply

[13:25] *** dayangkun left
[13:31] *** kaleem joined
[13:31] *** kaleem left
[13:38] *** _mg_ joined
[13:41] *** Kristien joined
[13:41] <Kristien> do non-webdev jobs still exist?

[13:42] <timotimo> plumbers have died out completely

[13:42] <timotimo> and all bakeries have closed down as well

[13:43] <timotimo> economic experts have concluded that humanity can sustain its existence solely on building more web sites and web apps

[13:43] <FROGGS> :D

[13:43] <Kristien> TIL web apps aren't websites.

[13:43] <timotimo> .o( i'd read a short story about that concept )

[13:43] <dalek> nqp/js: 17944b7 | hoelzro++ | src/vm/js/ (4 files):

[13:43] <dalek> nqp/js: Implement nqp::reprname

[13:43] <dalek> nqp/js: review: https://github.com/perl6/nqp/commit/17944b7002

[13:44] <timotimo> well, economic experts aren't really good at the technical things

[13:44] <Kristien> A non-webdev job would be nice but I can't find any.

[13:45] <hoelzro> pmurias: I noticed something in nqp-js yesterday; callmethod just uses regular JS property lookup to find the method

[13:45] <hoelzro> (ex. https://github.com/perl6/nqp/blob/js/src/vm/js/QAST/Compiler.nqp#L605)

[13:45] <hoelzro> should it be using something like findmethod?

[13:45] <masak> pmurias: re http://irclog.perlgeek.de/perl6/2015-02-10#i_10091073 -- could you create (or indicate how to go about creating) a proof of concept of that? I'd be really interested in what's possible today, and I don't quite see it myself.

[13:45] *** [Sno] joined
[13:45] *** [particle]1 joined
[13:46] *** Kristien left
[13:46] *** [particle] left
[13:46] <pmurias> hoelzro: it currently doesn't work for objects that don't have a set method cache

[13:46] <hoelzro> ah ha

[13:47] <hoelzro> ok, just making sure that wasn't a bug!

[13:47] <pmurias> findmethod does't work on ones without a method cache too :/

[13:48] <hoelzro> =(

[13:49] <pmurias> I still haven't fully figured out how to implement calling methods on objects without method caches without a performance penalty

[13:51] <pmurias> we should be able to bootstrap nqp and run most of Perl 6 without that ability

[13:51] <moritz> why would you not want method caches?

[13:53] *** _mg_ left
[13:54] <dalek> nqp/js: 01e9dae | hoelzro++ | src/vm/js/nqp-runtime/runtime.js:

[13:54] <dalek> nqp/js: Handle nulls in stringification too

[13:54] <dalek> nqp/js: review: https://github.com/perl6/nqp/commit/01e9dae43b

[13:55] <pmurias> moritz: CANDO

[13:56] *** Mouq joined
[13:56] <moritz> pmurias: if that means what I think it does, it's only an argument against caches that are authoritative for the absense of methods

[14:02] <pmurias> moritz: nqp-js assumes that caches always exists and are authorative

[14:02] <moritz> pmurias: and I think that's fine

[14:05] *** tardisx left
[14:07] <moritz> pmurias: at least for bootstrapping

[14:08] <moritz> pmurias: for rakudo, it probably needs other cache authorativity levels, but it's fine if they are slower

[14:11] <jnthn> pmurias: For a JS method cache, I suggest building a JS object with the methods put in the cache on it

[14:11] <jnthn> And then just doing the call like an object call on that, with a "is it there" check first

[14:11] <jnthn> I would imagine that' the kinda thing a JS impl can do well on today

[14:12] *** Kristien joined
[14:12] * jnthn turned out to be not so away yet :)

[14:14] <hoelzro> pmurias: is there a reason that P6Opaque doesn't have basic_type_object_for?

[14:14] *** Kristien left
[14:14] * masak .oO( Less Than Away )

[14:15] <FROGGS> hehe

[14:20] <Ven_> .tell masak http://www.theerlangelist.com/2014/07/understanding-elixir-macros-part-6.html more insight on elixir's macros with macro-at-compile-time..."stuff"

[14:20] * Ven_ didnt want to tell, but was too lazy to remove it...

[14:20] <masak> Ven++

[14:20] * masak .oO( .show, don't .tell )

[14:22] *** kaare_ left
[14:23] <dalek> nqp/js: 63f9212 | hoelzro++ | src/vm/js/nqp-runtime/core.js:

[14:23] <dalek> nqp/js: Fix indent

[14:23] <dalek> nqp/js: review: https://github.com/perl6/nqp/commit/63f92121d8

[14:23] <masak> Ven_: I take it that `unquote(action)` takes the symbol `action` and inserts it as an identifier in that part of the code.

[14:23] <masak> ...intriguing.

[14:26] *** vendethiel left
[14:28] <dalek> nqp/js: 14a7fb9 | hoelzro++ | src/vm/js/ (3 files):

[14:28] <dalek> nqp/js: Implement nqp::newtype

[14:28] <dalek> nqp/js: review: https://github.com/perl6/nqp/commit/14a7fb954d

[14:29] <masak> I think having such an `unquote()` primitive in the language might carry us quite far.

[14:29] *** vendethiel joined
[14:29] <Ven_> well, that's {{{ }}}/

[14:29] <masak> yes.

[14:30] <Ven_> and quote is obviously :quasi

[14:30] <Ven_> quasi*

[14:30] <Ven_> and then we can think of modifiers for bindings and/or auto-unquoting

[14:30] <masak> we'd still need to marry it to the notion of grammatical category, though.

[14:31] <dalek> rakudo-star-daily: 2977ff6 | coke++ | log/ (14 files):

[14:31] <dalek> rakudo-star-daily: today (automated commit)

[14:31] <dalek> rakudo-star-daily: review: https://github.com/coke/rakudo-star-daily/commit/2977ff6818

[14:32] <masak> "When it comes to macro execution, it's important to distinguish between the macro context and the caller's context" -- ayup.

[14:32] <Mouq> Hey, masak, on that topic, I have a proposal for an alternative to "macro swap($a, $b)" in that post from December

[14:32] <masak> oh, the substitution one?

[14:33] <masak> this one? http://strangelyconsistent.org/blog/macros-placeholdeeers

[14:33] <Mouq> macro swap($a, $b) { Q.codeToNode(-> $x, $y { ($x, $y) = $x, $y })($a, $b) }

[14:33] <Mouq> masak: Yup

[14:33] * masak thinks

[14:33] * Ven_ has just been throwing stuff at the poor masak about macros for quite some time now... :P

[14:33] <masak> you need to revise your swap implementation, but let's ignore that... :)

[14:34] <Mouq> oop, well I never said it was a bug-free alternative :9

[14:34] *** rurban joined
[14:35] <Ven_> masak: elixir uses var!() to have you refer to a.. "variable name"

[14:35] *** Ven_ left
[14:36] *** chenryn joined
[14:38] *** chenryn left
[14:42] <Mouq> masak: If you want, I'll try to write up more about that and why I think it's a good step later‚Ä¶ I've been meaning to set up a blog (which would include stuff like the Q issue proposal) (though right now I need to do homework and get ready for class)

[14:42] *** Ven_ joined
[14:43] *** chenryn joined
[14:49] <masak> ++Mouq # I would very much like that

[14:51] *** skids joined
[14:52] *** vendethiel left
[14:52] *** darutoko left
[14:53] <pmurias> hoelzro: no there isn't, I have added it in my working copy

[14:55] <pmurias> hoelzro: I should have commited partially done stuff before going out for lunch ;)

[14:56] <pmurias> merge conflicts :(

[14:56] <[Coke]> TimToady++ # interview with miyagawa

[14:57] *** darutoko joined
[14:57] *** chenryn left
[14:59] *** vendethiel joined
[15:00] <[Coke]> .seen miyagawa

[15:00] *** Rounin left
[15:00] <Mouq> [Coke]: Bot's not up :(

[15:03] <dalek> nqp/js: b6e301f | (Pawel Murias)++ | / (3 files):

[15:03] <dalek> nqp/js: Implement nqp::can.

[15:03] <dalek> nqp/js: review: https://github.com/perl6/nqp/commit/b6e301f8f5

[15:03] <dalek> nqp/js: cf09917 | (Pawel Murias)++ | / (4 files):

[15:03] <dalek> nqp/js: Implement nqp::setcodename/nqp::getcodename.

[15:03] <dalek> nqp/js: review: https://github.com/perl6/nqp/commit/cf0991743e

[15:03] <dalek> nqp/js: aaa2166 | (Pawel Murias)++ | src/vm/js/QAST/Compiler.nqp:

[15:03] <dalek> nqp/js: Implement nqp::setwho.

[15:03] <dalek> nqp/js: review: https://github.com/perl6/nqp/commit/aaa216661f

[15:07] <pmurias> jnthn: my current idea is to have an object "class" that implements all the method names used (without the ones constructed at runtime) and wrap the objects without method caches in it

[15:08] <[Coke]> wow, I was going to say nice outro music on the interview.... until I realized that it was itunes going to the next track. whoops.

[15:09] <[Coke]> pmurias++

[15:09] <[Coke]> hoelzro++

[15:09] <[Coke]> alright, I added a blocking ticket for the release. That's one. :)

[15:14] <pmurias> hoelzro: I'm now working on nqp::where

[15:15] *** chenryn joined
[15:19] <jnthn> [Coke]: Tag, or ticket that we'll add dependencies to?

[15:20] <FROGGS> https://rt.perl.org/Ticket/Display.html?id=123766 - [META] Tickets blocking the 2015 release of Perl 6

[15:20] *** Mouq left
[15:21] <jnthn> Cool

[15:21] <jnthn> [Coke]++

[15:21] <FROGGS> m: (6;)

[15:21] <camelia> rakudo-moar 0cb22e: OUTPUT¬´===SORRY!===‚ê§Cannot find method 'returns'‚ê§¬ª

[15:21] <FROGGS> interesting one

[15:22] *** mr-foobar joined
[15:22] <jnthn> Do we have an idea of the criteria for adding things as blockers?

[15:22] <FROGGS> gut feeling?

[15:22] <FROGGS> so, "no"

[15:23] <[Coke]> well, I figure if you, pmichaud, or TimToady say so, that's one.

[15:24] <[Coke]> Anything that is only broken on "not moar" isn't eligible.

[15:24] <FROGGS> I'd say that all perl6-m segfaults should be on that list

[15:24] <jnthn> [Coke]: Yes, thta sounds like a centralized democracy approach :)

[15:24] <[Coke]> segfaults are always bad.

[15:24] <jnthn> FROGGS: +1

[15:24] <[Coke]> heh, I typed that before scrolling down to see FROGGS's note. :)

[15:24] <FROGGS> :o)

[15:25] <FROGGS> consensus

[15:25] <[Coke]> but it's always possible to tag first and we can disagree later.

[15:25] <dalek> nqp/js: 8f91ff9 | (Pawel Murias)++ | src/vm/js/ (3 files):

[15:25] <FROGGS> sure

[15:25] <dalek> nqp/js: Implement nqp::where for object that have an STable.

[15:25] <dalek> nqp/js: review: https://github.com/perl6/nqp/commit/8f91ff9ba5

[15:25] <PerlJam> [Coke]++

[15:25] <PerlJam> [Coke]++   (Again, because I'm just catching up  :)

[15:25] <jnthn> True :)

[15:26] <dalek> nqp/js: c636caf | (Pawel Murias)++ | src/vm/js/nqp-runtime/core.js:

[15:26] <dalek> nqp/js: Remove leftover console.log.

[15:26] <dalek> nqp/js: review: https://github.com/perl6/nqp/commit/c636caf22c

[15:26] <dalek> nqp/js: f938fc6 | (Pawel Murias)++ | src/vm/js/bin/run_tests:

[15:26] <dalek> nqp/js: Add test 91 to run_tests.

[15:26] <dalek> nqp/js: review: https://github.com/perl6/nqp/commit/f938fc66ed

[15:27] <PerlJam> "Anything that makes everyday mistakes surprising"?   (The LTA error on non-existent role for instance)

[15:27] <PerlJam> (and the one FROGGS just showed)

[15:27] *** kaleem joined
[15:27] <timotimo> as i expected, that error message comes from the optimizer, FROGGS 

[15:28] <jnthn> PerlJam: LTA is, well, what it says.

[15:28] <FROGGS> timotimo: look: https://rt.perl.org/Ticket/Display.html?id=123696

[15:28] <jnthn> Not as good as it should be isn't equal to blocker.

[15:28] <pmurias> IMHO getting automatic precompilation seems like something that shoulld be done before the big release

[15:29] <FROGGS> timotimo: it is possible that the optimizer sneaks in that NQPMu here, but I would bet that the actions are to blame

[15:29] <FROGGS> pmurias: that sounds more like a nice to have feature

[15:29] <timotimo> what m)

[15:29] <jnthn> I'd consider pre-comp bugs as worthy of blocking. Automatic management of that is certainly nice to have.

[15:29] <PerlJam> jnthn: then maybe we need another meta-ticket for "nice to haves" as well.

[15:30] <jnthn> PerlJam: Perhaps so.

[15:30] <pmurias> It's more "embarassing not to have"

[15:30] <pmurias> but not a bug in a strict sense

[15:30] <FROGGS> *g*

[15:32] * lizmat is too knackered to read the backlog and goes back to bed

[15:32] *** colomon left
[15:33] * FROGGS waves at lizmat

[15:33] <jnthn> lizmat: Aww...get well soon!

[15:33] *** colomon joined
[15:34] <timotimo> sorry to hear that, liz

[15:34] <timotimo> best of luck :)

[15:34] <hoelzro> pmurias: ooc, how are you going to implement that?

[15:35] <pmurias> hoelzro: that?

[15:35] <pmurias> hoelzro: the object wrapping?

[15:35] <hoelzro> sorry, nqp::where

[15:36] *** kaleem left
[15:36] <hoelzro> ah, I see

[15:36] *** Ven_ left
[15:37] <pmurias> hoelzro: WeakMaps would be a cleaner way to implement that

[15:37] <pmurias> unfortunately they are hidden being a flag in node

[15:37] <hoelzro> =(

[15:37] <[Coke]> of course, nothing stoping folks from fixing bugs that bug them in time for the release. :)

[15:39] <masak> get well soon, lizmat 

[15:40] <jnthn> [Coke]: Absolutely, fixing just about anything is encouraged. Blockers are more about "what do we absolutely not want to knowingly let slip out" 

[15:44] <[Coke]> There are currently 936 fudge lines that match a generic rakudo or rakudo.moar in roast.

[15:47] <sivoais> timotimo: if you want to work on the iperl6kernel more, let me know. I've got it working with Perl5.

[15:48] <timotimo> i don't really know how exactly to progress with my version

[15:48] <timotimo> i may want to start over, or maybe implement the protocol first and then see what's next

[15:49] *** Kristien joined
[15:49] *** Kristien left
[15:51] *** Kristien joined
[15:51] <Kristien> m: 0..* Z+> 1 xx *

[15:51] <camelia> rakudo-moar 0cb22e: OUTPUT¬´(timeout)¬ª

[15:51] *** Ven_ joined
[15:51] <Kristien> m: (0..* Z+> 1 xx *)[^10].say

[15:51] <camelia> rakudo-moar 0cb22e: OUTPUT¬´0 0 1 1 2 2 3 3 4 4‚ê§¬ª

[15:52] <Kristien> most interesting

[15:52] *** chenryn left
[15:52] <masak> sink context, I guess.

[15:52] <TimToady> m: say 0..* Z+> 1 xx *

[15:52] <camelia> rakudo-moar 0cb22e: OUTPUT¬´0 0 1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9 10 10 11 11 12 12 13 13 14 14 15 15 16 16 17 17 18 18 19 19 20 20 21 21 22 22 23 23 24 24 25 25 26 26 27 27 28 28 29 29 30 30 31 31 32 32 33 33 34 34 35 35 36 36 37 37 38 38 39 39 40 40 41 41 42 42 43 43 44 44 45 45 ‚Ä¶¬ª

[15:52] <sivoais> timotimo: I'll take a look later this week. It'll give me a chance to rethink my design in Perl5 too.

[15:52] <TimToady> say will automatically stop at 100

[15:52] <timotimo> cool

[15:52] <TimToady> well, .gist

[15:52] <timotimo> do you have perl6 experience? i'm not sure i've seen your nick here before

[15:53] <sivoais> timotimo: a little. I've been lurking here for years and reading all the Perl6 blogs. Just haven't done any major contribs yet.

[15:53] <Kristien> masak: I mean the output is interesting

[15:53] <timotimo> a good point to work on would probabl ybe making Net::ZMQ more complete and much more tested

[15:53] <timotimo> OK :)

[15:53] <Kristien> the timeout was a failure on my end

[15:54] <sivoais> ah, that sounds fun! I've wanted to play with the native call functionality

[15:54] <sivoais> especially since FFI is getting better in Perl5 land too

[15:55] <timotimo> ah? did something kind of like zavolaj appear in perl5 land?

[15:56] <sivoais> timotimo: <https://metacpan.org/pod/FFI::Platypus>. Don't know enough to compare it with zavolaj

[15:56] <hoelzro> not #perl6, but I know others here like human languages, and someone did a great writeup on Norwegian: http://www.reddit.com/r/languagelearning/comments/2vercv/velkommen_this_weeks_language_of_the_week

[15:57] <FROGGS> sivoais / timotimo: that is using libffi and it supports C, C++, FORTRAN and what not

[15:58] <FROGGS> sivoais: though, having a proper type system pays of here... 

[15:58] <sivoais> yeah, I can imagine :-P

[15:58] <Kristien> libffi is good

[15:59] <FROGGS> sivoais: using Platypus you deal with strings a lot, and in Perl 6 you declare a class with uint8 attributes for example and then you just instanciate or return that

[15:59] *** Kristien left
[16:00] <sivoais> I'm reading through <https://github.com/perl6/specs/blob/master/S21-calling-foreign-code.pod> and liking what I see

[16:00] <FROGGS> sivoais: this one is up-to-date: https://github.com/jnthn/zavolaj

[16:01] <FROGGS> (because it is the working implementation)

[16:01] *** mr-foobar left
[16:01] <FROGGS> for example, the last paragraph mentions a hypothetical reinterpret() sub... that implemented nowadays and called nativecast()

[16:02] <arnsholt> Yeah, the tests give a better view of the available functionality than the docs

[16:02] <FROGGS> ... or the synopsis

[16:03] *** vendethiel left
[16:03] <timotimo> and global variables ...

[16:04] <abraxxa> what i'm missing is a pass-by-reference string type

[16:04] <FROGGS> buffers should do I think

[16:04] *** vendethiel joined
[16:04] <abraxxa> FROGGS: was that at me?

[16:05] <FROGGS> abraxxa: aye

[16:05] <abraxxa> FROGGS: we discovered a bug some days ago that .bytes doesn't return what it should

[16:05] <abraxxa> i'm waiting on the next release to continue with DBDish::Oracle

[16:05] <FROGGS> hmmm, do you have it at hand?

[16:06] <FROGGS> m: say "f√∂√∂√∂".encode.bytes

[16:06] <camelia> rakudo-moar 0cb22e: OUTPUT¬´7‚ê§¬ª

[16:06] <abraxxa> this dance is annoying if you have to do it for almost each parameter: https://github.com/abraxxa/DBIish/blob/master/lib/DBDish/Oracle.pm6#L459

[16:07] <retupmoca> FROGGS: the bug has been fixed and tested, it's just not in a release yet

[16:07] <abraxxa> m: say "f√∂√∂√∂".encode('utf-16').bytes

[16:07] <camelia> rakudo-moar 0cb22e: OUTPUT¬´8‚ê§¬ª

[16:07] <abraxxa> i guess the bot runs the fixed version

[16:07] <FROGGS> yes, camelia here is up-to-date

[16:07] <FROGGS> star-m: say "f√∂√∂√∂".encode('utf-16').bytes

[16:07] <camelia> star-m 2015.01: OUTPUT¬´4‚ê§¬ª

[16:07] <abraxxa> it outputs 4 here

[16:08] <FROGGS> ohh, I see :o)

[16:08] <abraxxa> i often need a pointer to something and like a one-line construct in NativeCall for it

[16:09] <FROGGS> abraxxa: yes, I also thought about allowing OpaquePointer[Int] for example

[16:09] *** Kristien joined
[16:09] *** mr-foobar joined
[16:09] <jnthn> I think with the native references work I'm going we may be able to get "int $x is rw" to work out 

[16:10] <jnthn> (and similar)

[16:10] <FROGGS> and that will pass a pointer to int?

[16:10] <jnthn> Yes

[16:10] <timotimo> jnthn: how about "my int $x is native('libfoobar')"?

[16:10] <abraxxa> jnthn: that would be AWESOME

[16:10] <jnthn> timotimo: That one is...trickier.

[16:10] <jnthn> *trickier

[16:10] <FROGGS> timotimo: you are talking about C globals?

[16:10] <Kristien> "my int $x is mine and only mine stay off it"

[16:11] <timotimo> yes

[16:11] <jnthn> m: my int $x is mine and only mine stay off it

[16:11] <camelia> rakudo-moar 0cb22e: OUTPUT¬´[31m===[0mSORRY![31m===[0m Error while compiling /tmp/vw2wKJH_UA‚ê§Can't use unknown trait 'is mine' in a variable declaration.‚ê§at /tmp/vw2wKJH_UA:1‚ê§------> [32mmy int $x is mine [33m‚èè[31mand only mine stay off it[0m‚ê§    expecting any of:‚Ä¶¬ª

[16:11] <jnthn> :P

[16:11] <jnthn> OK, gotta go :)

[16:11] <FROGGS> timotimo: I tried that :o)

[16:11] <jnthn> &

[16:11] <Kristien> goodby jonathan

[16:11] <timotimo> well, you tried it back then, but nowadays we have native refs. well, we almost have them

[16:11] <FROGGS> timotimo: one problem is that you only get a QAST::Var or so in the trait to mess with

[16:12] <timotimo> oh

[16:13] <timotimo> hmm

[16:13] <timotimo> perhaps my int $x := cglobal('abc') instead?

[16:13] <timotimo> better than having a proxy, IMO

[16:14] *** Kristien left
[16:18] *** zakharyas left
[16:21] <japhb> So I've got a couple files with essentially email addresses in them, one domain per file and one address per line (1e5 to 1e6 lines), and I want to load them both into memory with a view to relatively quick lookup in the future (O(log N) is good enough).  How do I use the least amount of memory to do this using current Rakudo?

[16:22] *** araujo left
[16:22] <japhb> (Note: they're not actually email addresses, and no, I'm not sending people emails.  It's actually ACL lists.)

[16:23] <moritz> least amount of memory sounds like it should be an Array[str] (and sorted for faster lookup)

[16:24] <japhb> I discovered to my chagrin that 'my @users = "users.txt".IO.lines.map(*.split("@")[0]);' is fairly memory hungry, and 'my @users = "users.txt".IO.lines>>.split("@")>>[0];' even more so.  And that only gets me O(N) lookup.

[16:24] <japhb> Hmmm, I guess I could implement binary search on the arrays ....

[16:24] <PerlJam> It's a tad odd that there isn't a binary search built-in in some way.

[16:25] *** _mg_ joined
[16:25] *** _mg_ left
[16:26] <japhb> PerlJam: Makes me wonder if we need a module of just basic algorithms on simple data structures.

[16:26] <japhb> In Rakudo Star, I mean.

[16:27] <moritz> maybe colomon++'s List::Util (iirc) has one?

[16:27] *** vendethiel left
[16:27] <PerlJam> Sounds like a good idea to me.

[16:27] *** diana_olhovik left
[16:27] <PerlJam> https://github.com/colomon/List-Utils/blob/master/lib/List/Utils.pm#L108

[16:28] <skids> The core will need such things when implementation gets past naiveity about certain things, so it may rise to that level, but maybe the more APIish stuff in a module.

[16:28] <moritz> fwiw p5 managed just fine without a binary search in core

[16:28] <timotimo> one of the things that's not very optimal is that we're always storing string data 4x as big as they need to be if you have pure-ascii data

[16:29] <timotimo> in moarvm, that is

[16:29] <PerlJam> colomon++ (sliding window and binary search are probably all I'd every use in that module, but they would make it worth it :)

[16:29] <timotimo> sliding window ... is that kind of what rotor does nowadays?

[16:29] <PerlJam> moritz: and junctions and uniq and ... :)

[16:30] * japhb notices line 137 of List::Utils, and makes an Ewww face

[16:30] <japhb> timotimo: Yes, I'd forgotten about the 4x blowup.

[16:31] <japhb> Though it's annoying that the idioms I came up with to just save the usernames, instead of the entire address line, actually ate a lot *more* memory.

[16:31] *** vendethiel joined
[16:31] <nwc10> why would one want O(log n) search on an array (and I forget what O() on insert to keep it sorted) when a hash is amortised O(1) ?

[16:31] * moritz idly wonders if utf8 blobs take up less memory

[16:31] *** Ven_ left
[16:31] *** fhelmberger left
[16:32] <moritz> nwc10: to save the memory overhead from a hash

[16:32] <japhb> nwc10: I'm willing to go O(1) -> O(log N) in order to save RAM.

[16:32] <PerlJam> moritz: I was just thinking that Blob + an index would probably be smaller, but I'm not sure that blobs are really smaller

[16:32] <nwc10> moritz: OK. I suspect that that is not common enough to justify being in core core

[16:33] <japhb> nwc10: That's why I suggested having it be a Star module.

[16:33] <dalek> perl6-roast-data: aa488d8 | coke++ | / (5 files):

[16:33] <dalek> perl6-roast-data: today (automated commit)

[16:33] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/aa488d8c35

[16:33] <japhb> Is List::Utils in Star?

[16:33] <nwc10> japhb: I totally missed that bit. Sorry

[16:33] * japhb forgets where to look.

[16:33] <nwc10> somewhere blantantly visible in the ecosystem seems cool

[16:34] <nwc10> s/cool/useful and appropriate/; # do it once, and do it well

[16:34] <japhb> Right

[16:34] <moritz> japhb: nope

[16:34] * nwc10 shuts up and goes back to "eeww, what are these 200 unversioned files on the live work server"?

[16:34] <moritz> japhb: and IMHO List::Utils would need a bit of cleaning before going into star

[16:35] <moritz> like, it offers permutations and other stuff that's been in core for quite some time now

[16:35] <japhb> nwc10: eeww is right

[16:35] <japhb> moritz: Yeah, agreed.

[16:36] <PerlJam> nwc10: they're the ones generated by the versioned stuff :)

[16:37] <PerlJam> Are permutations more "core worthy" than binary search?

[16:37] <japhb> I'd really love sub-bufs, so I could just read in the file raw and make an array of sub-bufs from it.

[16:37] <dalek> nqp/js: b437293 | (Pawel Murias)++ | t/nqp/91-codename.t:

[16:37] <dalek> nqp/js: Remove debugging say.

[16:37] <dalek> nqp/js: review: https://github.com/perl6/nqp/commit/b4372935fa

[16:37] <dalek> nqp/js: 95efca0 | (Pawel Murias)++ | / (2 files):

[16:37] <dalek> nqp/js: Make P6opaque have their attributes set to null when they are created.

[16:37] <dalek> nqp/js: review: https://github.com/perl6/nqp/commit/95efca089b

[16:37] <dalek> nqp/js: 9dcb959 | (Pawel Murias)++ | src/vm/js/QAST/Compiler.nqp:

[16:37] <dalek> nqp/js: Implement nqp::isconcrete.

[16:37] <dalek> nqp/js: review: https://github.com/perl6/nqp/commit/9dcb959cb1

[16:38] *** spider-mario joined
[16:38] <moritz> japhb: you could store the Buf once, and offsets into it as integers

[16:40] <japhb> moritz: True.  I was thinking about something that would be transparent to the caller (meaning, they just see a normal array of sub-bufs (or sub-strs)) without having to write a whole class around it.

[16:40] <japhb> But *shrug*, I'm just dreaming at the moment.

[16:41] * japhb is happy to see pmurias++ able to work in-repo

[16:44] <[Coke]> pmurias++ indeed. 

[16:45] *** eternaleye left
[16:45] *** literal joined
[16:46] <japhb> Why does IO::Path.slurp(:bin) use a loop and nqp::readfh, but IO::Path.slurp(:$enc) use nqp::readallfh?

[16:46] <pmurias> hoelzro++

[16:47] <dalek> nqp/js: 1a5eeb9 | (Pawel Murias)++ | / (5 files):

[16:47] <dalek> nqp/js: Implement nqp::istype.

[16:47] <dalek> nqp/js: review: https://github.com/perl6/nqp/commit/1a5eeb95d0

[16:48] *** davido_ joined
[16:48] <moritz> japhb: but imagine the great comments you could write :-)

[16:48] <literal> can anything be done to speed up these subroutines? why is the gather/take one so much slower than the rest? https://gist.github.com/hinrik/7cf05941c6b32d667c39

[16:48] <moritz> japhb: class MemoryEfficientBufSet { # dear future self, you are not going to like this, but I *had* to save memory here

[16:49] <moritz> japhb: # once that needs goes away, replace this whole thing with a simple Set. Apologies.

[16:49] <moritz> japhb: # your truely, past self.

[16:49] <japhb> moritz: :-D

[16:49] <japhb> SO TRUE

[16:52] *** grondilu joined
[16:52] <grondilu> literal: consider using for 1 ..^ 1000 {...}

[16:53] *** dj_goku left
[16:53] *** dj_goku joined
[16:54] <japhb> This all comes from needing some rapid lookups where the backend systems are very slow, but the data sets aren't gigantic, so I can just cache in-memory -- but I've got a lot of data sets to look at, so memory is constrained.

[16:54] <grondilu> m: my @p; for 1 ..^ 1000 -> $a { for 1 ..^ 1000 -> $b { push @p, $a*$b } }; say @p[*-1]; say now - BEGIN now

[16:54] * japhb considers the wisdom of just binding a memcached client, and exporting the problem

[16:54] <camelia> rakudo-moar 0cb22e: OUTPUT¬´998001‚ê§3.4862511‚ê§¬ª

[16:55] <moritz> japhb: the problem is that memcached assumes it can throw away things when memory gets sparse

[16:55] <moritz> japhb: I'd rather throw it into a sqlite3 db

[16:55] <moritz> japhb: or a berkeleydb or so

[16:56] <japhb> Oh, hmmm, good point.

[16:57] <japhb> Is the sqlite binding pretty stable these days?

[16:57] <moritz> japhb: ask masak++, he has been using it, I hear

[16:57] <literal> grondilu: I'm not sure I understand your suggestion. You're suggesting "100 ..^ 1000" instead of "100..999" ? I tried that and there's no difference in execution time.

[16:57] <grondilu> literal: I thought there would be.  My bad.

[16:57] <grondilu> oops.

[16:58] <grondilu> I meant as opposed to the C-style loop, not the ..^ vs ..

[16:59] <literal> yeah, you can see I tried 3 versions in Perl 6, and one of them uses a range

[16:59] <japhb> .ask masak How stable is the sqlite binding?  And what do I need to panda install to get it?

[16:59] <japhb> No yoleaux?

[16:59] <japhb> awwww

[16:59] <moritz> japhb: I can answer the latter, 'panda install DBIish'

[17:00] <moritz> japhb: though you need your own libsqlite3-dev (that's the debian package name)

[17:00] <japhb> moritz: Ah, so sqlite is one of teh bindings included with DBIish, cool.

[17:00] <moritz> japhb: yes

[17:00] <japhb> moritz: Right, I figured as much.  Thankfully I still get to use Debian derivatives.  :-)

[17:01] <grondilu> m: my @p; for ^1_000_000 { push @p, ($_ div 1000)*($_ mod 1000) }; say now - BEGIN now

[17:01] <camelia> rakudo-moar 0cb22e: OUTPUT¬´5.523003‚ê§¬ª

[17:02] <moritz> m: my @p; loop (my int $i = 0; $i < 1_000_000; $i = $i + 1) { push @p, ($_ div 1000)*($_ mod 1000) }; say now - BEGIN now

[17:02] <camelia> rakudo-moar 0cb22e: OUTPUT¬´Cannot call 'infix:<div>'; none of these signatures match:‚ê§:(Int:D \a, Int:D \b)‚ê§:(int $a, int $b --> int)‚ê§  in block <unit> at /tmp/zl_4b0ci8W:1‚ê§‚ê§¬ª

[17:02] <moritz> m: my @p; loop (my int $i = 0; $i < 1_000_000; $i = $i + 1) { push @p, ($i div 1000)*($i mod 1000) }; say now - BEGIN now

[17:02] <camelia> rakudo-moar 0cb22e: OUTPUT¬´5.2385717‚ê§¬ª

[17:02] *** PZt left
[17:02] <moritz> m: my @p; loop (my int $i = 0; $i < 1_000_000; $i = $i + 1) { my $dummy = ($i div 1000)*($i mod 1000) }; say now - BEGIN now

[17:02] <camelia> rakudo-moar 0cb22e: OUTPUT¬´2.2391307‚ê§¬ª

[17:03] <moritz> half of the time is spent pushing to that array

[17:03] <grondilu> indeed

[17:03] * japhb chuckles that sqlite3-doc depends on sqlite3.  Because of course, right?  Why would you ever want the docs without the CLI?

[17:03] <TimToady> why do people use "now - BEGIN" now when it's shorter and more accurate to say "now - INIT now"?

[17:04] <moritz> japhb: it's not about wanting. It needs sqlite3 to.... show the docs!

[17:04] <japhb> Heh

[17:04] <moritz> TimToady: old habits die hard

[17:04] <japhb> So do old hobbits, I hear

[17:04] <masak> TimToady: I can only speak for myself. I'm very well aware of BEGIN, and haven't thought much at all about INIT.

[17:04] <TimToady> INIT is older than some of the people on this channel

[17:04] <hahainternet> oh no japhb, that old story died extremely hard

[17:04] <masak> will try to use INIT from now on :)

[17:05] <PerlJam> BEGIN is better understood than INIT I'd wager

[17:05] <TimToady> it'll work better with delayed execution too

[17:05] <masak> the "Die Hard" franchaise dies hard.

[17:05] <japhb> No better time to break a habit than now.

[17:05] <geekosaur> I thought it was just people saw the BEGIN one being used (for a specific purpose) and adopted it for the general one?

[17:05] <TimToady> yes, INIT?

[17:05] <japhb> masak: It just got renamed RED, added a few heroes, and got more fun.  :-)

[17:06] <TimToady> geekosaur: probably

[17:06] <grondilu> TimToady: I wrote 'now - BEGIN now' because that's what I've read once here.  I thought it was a P6 idiom.

[17:06] *** diana_olhovik_ joined
[17:06] <moritz> geekosaur: that's what they call cargo cult programming :-)

[17:06] <geekosaur> yep

[17:06] <grondilu> :/

[17:06] <geekosaur> welcome to the real world

[17:06] <japhb> grondilu: the concept is idiomatic, but the choice of phaser is incorrect.

[17:06] <geekosaur> monkey see, monkey do --- we're still primates at heart

[17:07] <japhb> ook ok ok

[17:07] <PerlJam> .oO( and brain too )

[17:07] <TimToady> it's not really incorrect, just...not quite optimal

[17:07] <PerlJam> TimToady: it is incorrect wrt delated execution.

[17:07] <PerlJam> er, delayed even

[17:07] <japhb> TimToady: With your point about delayed execution ... what PerlJam++ said

[17:08] <TimToady> then it's only potentially incorrect :)

[17:08] <japhb> heh

[17:08] <TimToady> unless you actually want to measure the time since compilation, then it's correct :)

[17:08] <geekosaur> that was in fact what was being checked originally

[17:09] <TimToady> mostly I was appealing to laziness though :)

[17:10] *** FROGGS left
[17:10] <TimToady> m: say now - BEGIN now; say now - CHECK now; say now - INIT now;

[17:10] <camelia> rakudo-moar 0cb22e: OUTPUT¬´0.0657528‚ê§0.02904647‚ê§0.0144280‚ê§¬ª

[17:10] <grondilu> also, I just forgot about INIT.  I don't know all phasers at all.

[17:10] <PerlJam> m: say INIT now - BEGIN now;

[17:10] <camelia> rakudo-moar 0cb22e: OUTPUT¬´0.0211896‚ê§¬ª

[17:10] <japhb> TimToady: Try those in reverse order.  :-)

[17:10] <[Coke]> "how does this phaser interact with precomp" might be a nice paragraph somewhere.

[17:11] <TimToady> japhb: I did them in that order to get a conservative number

[17:11] *** noganex_ left
[17:11] <TimToady> m: say now - INIT now; say now - CHECK now; say now - BEGIN now;

[17:11] <camelia> rakudo-moar 0cb22e: OUTPUT¬´0.0043353‚ê§0.03064941‚ê§0.07359549‚ê§¬ª

[17:11] <moritz> [Coke]: https://github.com/perl6/doc/issues/47 we have a TODO for that for doc.perl6.org

[17:11] <pmurias> it seems a lot of people haven't yet got used to our new precomp reality

[17:12] <pmurias> the fact that precomp doesn't work properly doesn't help ;)

[17:12] * raydiak did not know until yesterday that wrapping stuff in BEGIN can fix precomp failures

[17:12] <PerlJam> m: say BEGIN now - INIT now;  # might be surprising :)

[17:12] <camelia> rakudo-moar 0cb22e: OUTPUT¬´===SORRY!===‚ê§Cannot call 'infix:<->'; none of these signatures match:‚ê§:(Any $x = { ... })‚ê§:(Any \a, Any \b)‚ê§:(Real \a, Real \b)‚ê§:(Int:D \a, Int:D \b --> Int)‚ê§:(int $a, int $b --> int)‚ê§:(Num:D \a, Num:D \b)‚ê§:(num $a, num $b)‚ê§:(Rational \a,‚Ä¶¬ª

[17:13] <grondilu> makes sense

[17:13] <grondilu> INIT now can not run at compile time, can it?

[17:13] <TimToady> it just schedules it for later

[17:13] *** Kristien joined
[17:14] <grondilu> m: BEGIN INIT say "hi"

[17:14] <camelia> rakudo-moar 0cb22e: OUTPUT¬´hi‚ê§¬ª

[17:14] <flussence> m: say (BEGIN now) - (INIT now)

[17:14] <camelia> rakudo-moar 0cb22e: OUTPUT¬´-0.0228491‚ê§¬ª

[17:14] <TimToady> m: say INIT now - BEGIN now

[17:14] <camelia> rakudo-moar 0cb22e: OUTPUT¬´0.0202317‚ê§¬ª

[17:14] <TimToady> works that dirction

[17:14] <dalek> nqp/js: aeb83b2 | (Pawel Murias)++ | src/vm/js/ (3 files):

[17:14] <dalek> nqp/js: Implement nqp::rebless.

[17:14] <dalek> nqp/js: review: https://github.com/perl6/nqp/commit/aeb83b2e68

[17:14] <dalek> nqp/js: 577220d | (Pawel Murias)++ | / (2 files):

[17:14] <dalek> nqp/js: Add a test for various OO related ops.

[17:14] <dalek> nqp/js: review: https://github.com/perl6/nqp/commit/577220d333

[17:14] <dalek> nqp/js: c7bf3d2 | (Pawel Murias)++ | t/nqp/61-mixin.t:

[17:14] <dalek> nqp/js: Test what the test description describes.

[17:14] <dalek> nqp/js: review: https://github.com/perl6/nqp/commit/c7bf3d24a0

[17:15] <PerlJam> I figured it was a precedence problem.

[17:15] <dalek> nqp/js: 9cd6a34 | (Pawel Murias)++ | t/nqp/92-where.t:

[17:15] <dalek> nqp/js: Add missing file.

[17:15] <dalek> nqp/js: review: https://github.com/perl6/nqp/commit/9cd6a34634

[17:15] <TimToady> well, they parse identically

[17:16] <japhb> TimToady: That makes me curious where those 20ms go between BEGIN and INIT in that darn-near minimal case

[17:17] <timotimo> must be the optimizer! :P

[17:17] <flussence> garbage collection maybe?

[17:17] <japhb> timotimo: Ewww.  :-D

[17:17] <timotimo> flussence: shouldn't even have a single gc cycle on that example

[17:17] <[Coke]> m: STAT CHECK BEGIN LEAVE INIT now;

[17:17] <camelia> rakudo-moar 0cb22e: OUTPUT¬´[31m===[0mSORRY![31m===[0m Error while compiling /tmp/J4mHmsSenv‚ê§Undeclared name:‚ê§    STAT used at line 1‚ê§‚ê§¬ª

[17:17] <[Coke]> m: START CHECK BEGIN LEAVE INIT now;

[17:18] <camelia> rakudo-moar 0cb22e: OUTPUT¬´[31m===[0mSORRY![31m===[0m Error while compiling /tmp/HDjnIAuPGJ‚ê§Undeclared name:‚ê§    START used at line 1‚ê§‚ê§¬ª

[17:18] <TimToady> START got demoted

[17:18] <TimToady> it's not a phaser

[17:18] <timotimo> oh, interesting

[17:18] <[Coke]> awww.

[17:18] <timotimo> in that example, 50% of the run time is actually dynamic optimization

[17:18] <[Coke]> m: LEAVE now!;

[17:18] <camelia> rakudo-moar 0cb22e: OUTPUT¬´[31m===[0mSORRY![31m===[0m Error while compiling /tmp/qddZ7klWG8‚ê§Negation metaoperator not followed by valid infix‚ê§at /tmp/qddZ7klWG8:1‚ê§------> [32mLEAVE now![33m‚èè[31m;[0m‚ê§    expecting any of:‚ê§        infix stopper‚ê§        infix or m‚Ä¶¬ª

[17:18] <TimToady> it's now just "once"

[17:19] <timotimo> it does over a thousand jitted frame invocations in that time

[17:19] * [Coke] gives up on poetry and goes for a walk.

[17:19] <TimToady> m: so LEAVE now

[17:19] <camelia> rakudo-moar 0cb22e: ( no output )

[17:19] <Kristien> hi

[17:19] <TimToady> m: KEEP Cool

[17:19] <camelia> rakudo-moar 0cb22e: ( no output )

[17:19] *** abraxxa left
[17:19] <TimToady> Kristien: o/

[17:20] <timotimo> about half the run time is spent somewhere inside or under from-posix

[17:21] <flussence> .oO( gettimeofday considered harmful )

[17:21] *** alini left
[17:21] * japhb chuckles at the first query arg in his github search URL: https://github.com/search?utf8=%E2%9C%93&q=DBIish ... it shows up in Chrome's URL bar as a Unicode checkmark.  :-)

[17:22] <timotimo> m: say time

[17:22] <camelia> rakudo-moar 0cb22e: OUTPUT¬´1423588930‚ê§¬ª

[17:22] <timotimo> m: say (INIT nqp::time_n) - BEGIN nqp::time_n

[17:22] <camelia> rakudo-moar 0cb22e: OUTPUT¬´0.0133426189422607‚ê§¬ª

[17:22] <PerlJam> TimToady: btw, something I noticed the other day ... the section of S04  that talks about gather, once, do, etc. says "Constructs marked with a C<*> have a run-time value", yet ... they're *all* marked with a *    Is that some kind of editing accident?  (i.e. some were, some weren't but now they all are?)

[17:22] <timotimo> m: say (INIT time) - BEGIN time

[17:22] <camelia> rakudo-moar 0cb22e: OUTPUT¬´0‚ê§¬ª

[17:22] <timotimo> m: say (INIT now) - BEGIN now

[17:22] <camelia> rakudo-moar 0cb22e: OUTPUT¬´0.0190897‚ê§¬ª

[17:23] <TimToady> END doesn't have a *

[17:23] <timotimo> wait, i've been measuring the wrong thing

[17:23] <PerlJam> TimToady: no, the phasers have a separate statement about * marking from the not-quite-phasers

[17:24] <PerlJam> or maybe I'm just mis-reading

[17:24] <timotimo> i should have done --profile-compile instead

[17:25] <PerlJam> S04:1395 and S04:1434 seem to be saying different things about the *-marking

[17:25] <synopsebot> Link: http://design.perl6.org/S04.html#line_1395

[17:25] <TimToady> it's the same *

[17:25] <PerlJam> ok

[17:25] <TimToady> it is, admittedly, misleading

[17:26] *** dakkar left
[17:27] <flussence> r: eager for ^1_000_000 { Nil }; say 1 / (now - INIT now) # bogoMIPS

[17:27] <camelia> rakudo-parrot 0cb22e: OUTPUT¬´(timeout)¬ª

[17:27] <camelia> ..rakudo-moar 0cb22e: OUTPUT¬´0.676328731465798‚ê§¬ª

[17:28] * raydiak has been reviewing literal's question and notes that even an empty p6 loop(;;) over 1e7 elems w/a native int counter, timing from INIT, takes about as long as the entire execution time of the equivalent p5 running over 2e8 elems

[17:29] <raydiak> (though maybe we don't optimize for the empty case so much)

[17:30] <pmurias> we should have the optimizer detect silly benchmarks

[17:31] <moritz> raydiak: that's a factor 20 off. That's not too bad, actually 

[17:31] <moritz> raydiak: two years ago, the factor was > 200 regularly

[17:31] <raydiak> moritz: no, not bad at all considering where we've come from...I just hope literal has the same contextual attitude :)

[17:33] *** slavik joined
[17:33] <timotimo> raydiak: seems like a good case for rakudo-jvm perhaps?

[17:33] <raydiak> timotimo: last time I tried it, jvm wasn't faster at anything any more

[17:33] <raydiak> since moar got better and got jit and etc

[17:34] <moritz> TBH, moar's JIT isn't too great

[17:35] <TimToady> yes, in my infoworld interview I said we still have a lot of "headroom" :)

[17:35] *** Kristien left
[17:36] * raydiak has no idea where the performance improvements actually come from internally

[17:37] <raydiak> only that moar has gotten very much faster over the past year

[17:37] *** vendethiel left
[17:40] <timotimo> something's going wrong with the for benchmark up there

[17:40] <timotimo> it seems to allocate an Int for each iteration

[17:40] *** vendethiel joined
[17:41] <japhb> raydiak: Some from spesh/JIT/etc., but also some from just being less naive and from putting moderate tuning effort into really common stuff

[17:41] <timotimo> it should have done the for-to-loop optimization

[17:42] <TimToady> but maybe it needs to notice that it can do it in int64 rather than Int, or maybe it's comparing int64 < Int and promoting every time

[17:47] <timotimo> it's not doing the optimization, i have a clue why it might not be doing it, but i'm not 100% sure

[17:47] <timotimo> and it already does the int vs Int check :)

[17:48] *** noganex joined
[17:48] <moritz> seems those optimizer writers aren't too dumb after all :-)

[17:48] *** Sqirrel left
[17:50] *** espadrine left
[17:53] *** pmurias left
[17:54] *** mvuets left
[17:55] *** Kristien joined
[17:55] <Kristien> hi

[17:55] <timotimo> haha

[17:55] <timotimo> oh that's silly

[17:56] <timotimo> the optimization is looking for "sink", here it gets "eager"

[17:56] <timotimo> leaving out the "eager" part makes it more than 2x faster

[17:56] <raydiak> heh, that's...less than optimal

[17:57] <timotimo> and saves about 70 megabytes of ram used

[18:07] *** Mouq joined
[18:08] <dalek> rakudo/nom: 08941a3 | timotimo++ | src/Perl6/Optimizer.nqp:

[18:08] <dalek> rakudo/nom: not only sink, but also eager triggers for->loop opt

[18:08] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/08941a36e2

[18:11] * timotimo is AFK for a bit

[18:11] *** raiph joined
[18:12] <japhb> Does 'eager for' save values still?  Or do you need 'eager do for' to get that?

[18:12] *** adu joined
[18:13] *** alini joined
[18:14] *** _mg_ joined
[18:14] <Mouq> japhb: I believe so; as I understand that opt just transforms for + a range into something faster

[18:14] <raydiak> m: say eager for ^3 {$_}

[18:14] <camelia> rakudo-moar 0cb22e: OUTPUT¬´0 1 2‚ê§¬ª

[18:16] <vendethiel> wow :o) timotimo++

[18:19] <Kristien> is there a tool that converts perl5 regex into perl6 regex?

[18:21] <Mouq> Kristien: You could always use the :Perl5 mod, though I don't think that'll work inside grammars. I'm not sure if "Perlito" ever made it to doing regexes

[18:21] <Mouq> 6to5: 1 + 1

[18:21] <Kristien> I can't find documentation on how to negate a char class

[18:21] <Mouq> 5to6: 1 + 1

[18:21] <Mouq> hm

[18:21] <PerlJam> Kristien: <-[...]>

[18:21] <Kristien> ah thanks

[18:22] <Mouq> This came up a few weeks ago, I'm not sure how to make it more visible. Maybe changing the title here: http://doc.perl6.org/language/regexes#Enumerated_character_classes_and_ranges ?

[18:25] <raydiak> m: 1

[18:25] <camelia> rakudo-moar 0cb22e: ( no output )

[18:25] <Kristien> Yay, I wrote a parser for my programming language in 6 LOC!

[18:25] <raydiak> \o/

[18:27] <timotimo> oh, lait

[18:27] <timotimo> wait

[18:27] <timotimo> loops return their values, too, right?

[18:27] <PerlJam> Mouq: um ... is it true that you can use |, &, and ^ to combine character classes?

[18:28] <raydiak> timotimo: yes I tried it its broken if the eager isn't in sink context :)

[18:28] <timotimo> damn

[18:28] <timotimo> yeah, i'm going to revert that comment

[18:29] <dalek> rakudo/nom: f73c3f2 | timotimo++ | src/Perl6/Optimizer.nqp:

[18:29] <dalek> rakudo/nom: Revert "not only sink, but also eager triggers for->loop opt"

[18:29] <dalek> rakudo/nom: 

[18:29] <dalek> rakudo/nom: This reverts commit 08941a36e289fc1209e919cdffd5effcebbde043.

[18:29] <dalek> rakudo/nom: 

[18:29] <dalek> rakudo/nom: a loop doesn't return its values, so this breaks "do for ^..."

[18:29] <dalek> rakudo/nom: and friends

[18:29] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/f73c3f24e3

[18:31] *** FROGGS joined
[18:34] <Mouq> PerlJam: NYI. I'm writing more about regexes in 5to6.pod right now, btw

[18:35] <Mouq> timotimo: No way we can salvage that opt?

[18:35] * raydiak was wondering how hard it'd be to check if the eager is in sink context

[18:36] *** adu left
[18:36] <timotimo> Mouq: we'd have to create an array locally and have the "value of the block" push'd into that and then give that back to the caller of "eager"

[18:36] <timotimo> the GLR will make this workh better, though ... i'm hoping

[18:37] *** eternaleye joined
[18:39] * raydiak is still wondering how hard it'd be to still do the opt for eager, just only if the eager is in sink context

[18:40] *** KCL_ joined
[18:43] *** diana_olhovik_ left
[18:47] <timotimo> if the eager is in sink context, it actually loses the "eager" and it gets replaced by "sink"

[18:47] <timotimo> but the optimizer only goes into one of the two branches of the Want node

[18:49] * timotimo wishes for boxed data tracking :\

[18:49] *** Rounin joined
[18:50] <raydiak> ah, so it'll already optimize a sunken eager...

[18:51] <raydiak> or.../me goes to figure out what QAST::Want is

[18:52] <timotimo> the code in slow.p6 will inline <, which boxes its result into a Bool object, then the code that gets the result will guard against the value being concrete (first WTF), then unbox the value as an int and if based on that

[18:52] <Kristien> if I have rule <term> { <identifier> | <stirng> } and I want the AST do I really have to say method term($/) { make ($<identifier> | $<string>).ast }?

[18:54] <timotimo> http://t.h8.lv/slow.p6.svg - check this out

[18:54] <timotimo> block 15 is the inlined < block

[18:55] <FROGGS> Kristien: method term($/) { make ($<identifier> || $<string>).ast }

[18:55] <Kristien> yeah that's what I mean

[18:55] <FROGGS> that should work, yes

[18:55] <Kristien> having to repeat the alternation in the action is devious

[18:56] <FROGGS> but you could also do: rule <term> { <TERM=.identifier> | <TERM=.string> }; method term($/) { make $<TERM>.ast }

[19:00] <Kristien> nope

[19:00] <FROGGS> nope?

[19:00] <Kristien> hmm yeah it works

[19:00] <Kristien> but that's also devious

[19:00] <Mouq> rule term { ( <identifier> | <string> ) }; method term($/) { make $0.keys[0].ast } has worked for me in cases where I have a big alternation with very similar rules, though it's not optimal

[19:00] <Kristien> there must be a better way

[19:01] <Mouq> Err, I guess just rule term { ( <identifier> | <string> ) }; method term($/) { make $0.keys[0].ast }

[19:01] <Mouq> Dam

[19:01] <FROGGS> rule term { ( <.identifier> | <.string> ) }; method term($/) { make $0.ast }

[19:01] <Mouq> * rule term { <identifier> | <string> }; method term($/) { make $/{*}[0].ast }

[19:01] <vendethiel> Kristien: also, { $<alter>=[ <identifier> | ...

[19:01] <vendethiel> ah, too spooky..

[19:02] <Mouq> FROGGS: I don't think that'll work, will it?

[19:02] *** ninjazach joined
[19:02] <FROGGS> let's see

[19:02] <Kristien> vendethiel: nope

[19:02] *** ninjazach left
[19:03] <Kristien> Mouq: that works

[19:03] <vendethiel> $/{*}?

[19:04] <Mouq> Oh wait

[19:05] <timotimo> http://t.h8.lv/slow_native.p6.svg ‚Üê this is the same slow function but with natives and += instead of ++, but it seems to be about 50% slower

[19:05] <raydiak> timotimo: I have been looking at it, but...it's a lot to take in if you aren't already familiar with those bits :)

[19:05] <vendethiel> Mouq: what $/{*} :P? a slice?

[19:06] <masak> probably wrong...

[19:06] <masak> m: my %h = foo => 1, bar => 2; say %h{*}

[19:06] <camelia> rakudo-moar 0cb22e: OUTPUT¬´1 2‚ê§¬ª

[19:06] <masak> m: my %h = foo => 1, bar => 2; say %h{}

[19:06] <camelia> rakudo-moar 0cb22e: OUTPUT¬´bar => 2, foo => 1‚ê§¬ª

[19:06] <masak> hm.

[19:06] <TimToady> can't use .values

[19:06] <Mouq> m: grammar T { token TOP { <ident> | <str> }; token str { \"~\" <-["]>*  }}; class TActions { method TOP { make %() }; method ident { make "foo" }; method str { make "bar" }}; say T.parse("abcd",:actions(TActions)).ast

[19:06] <camelia> rakudo-moar 0cb22e: OUTPUT¬´Too many positionals passed; expected 1 argument but got 2‚ê§  in method TOP at /tmp/eJXgGXdA1w:1‚ê§  in regex TOP at /tmp/eJXgGXdA1w:1‚ê§  in method parse at src/gen/m-CORE.setting:15062‚ê§  in block <unit> at /tmp/eJXgGXdA1w:1‚ê§‚ê§¬ª

[19:07] <Mouq> m: grammar T { token TOP { <ident> | <str> }; token str { \"~\" <-["]>*  }}; class TActions { method TOP($/) { make %() }; method ident($/) { make "foo" }; method str($/) { make "bar" }}; say T.parse("abcd",:actions(TActions)).ast

[19:07] <camelia> rakudo-moar 0cb22e: OUTPUT¬´EnumMap.new("ident" => Match.new(orig => "abcd", from => 0, to => 4, ast => Any, list => ().list, hash => EnumMap.new()))‚ê§¬ª

[19:07] <Mouq> Isn't that supposed to call .ast or am I missing something? I'm guessing that's NYI

[19:07] <Mouq> (Talking about %() )

[19:08] <FROGGS> %() is meant to be $/.hash.ast // $/.hash.Str IIRC

[19:08] <FROGGS> m: grammar G { token TOP { <top=.foo> | <foo=.bar> }; token foo { foo }; token bar { bar } }; class A { method TOP($/) { make $<foo>.made }; method bar($/) { make 42 } }; say G.parse('bar', :actions(A)).made

[19:08] <camelia> rakudo-moar 0cb22e: OUTPUT¬´42‚ê§¬ª

[19:09] <FROGGS> I prefer that one

[19:09] <timotimo> i think i have a suspicion what makes that version slower

[19:09] <timotimo> actually calling the innermost block requires more Int objects to be allocated

[19:09] <Mouq> FROGGS: I do too, but it depends on your needs

[19:10] <FROGGS> as usual :o)

[19:10] <timotimo> same amount of Scalar allocations, but the _native version i made allocates 1218104 Int objects, whereas the original just allocates 811800

[19:10] <timotimo> m: say (1218104 / 811800)

[19:10] <camelia> rakudo-moar 0cb22e: OUTPUT¬´1.5004977‚ê§¬ª

[19:10] <timotimo> 50% more, eh?

[19:11] <Mouq> O.o

[19:12] *** wicope left
[19:15] <timotimo> AFK again

[19:15] *** telex left
[19:16] *** telex joined
[19:27] *** diana_olhovik joined
[19:29] *** gfldex joined
[19:36] *** Possum left
[19:36] <Kristien> m: say [+] ['1', '2', '3', '4']

[19:36] <camelia> rakudo-moar f73c3f: OUTPUT¬´4‚ê§¬ª

[19:36] <Kristien> :|

[19:36] <Kristien> m: say '1' + '2' + '3' + '4'

[19:36] <camelia> rakudo-moar f73c3f: OUTPUT¬´10‚ê§¬ª

[19:36] <TimToady> [] itemizes

[19:37] <Kristien> m: say [+] ['1', '2', '3', '4'].list

[19:37] <camelia> rakudo-moar f73c3f: OUTPUT¬´10‚ê§¬ª

[19:37] <Kristien> ah right

[19:37] <FROGGS> m: say [+] '1', '2', '3', '4'

[19:37] <camelia> rakudo-moar f73c3f: OUTPUT¬´10‚ê§¬ª

[19:37] <TimToady> m: say [+] [<1 2 3 4>][]

[19:37] <camelia> rakudo-moar f73c3f: OUTPUT¬´10‚ê§¬ª

[19:38] <TimToady> Perl tends to take it's singular/plural distinctions very seriously

[19:38] <Kristien> interpreter in Perl 6: https://gist.github.com/rightfold/a1df69c68cfb7f18a94e

[19:38] <TimToady> it's a little odd that .[] as a subscript turns a singular [] into a plural

[19:39] <TimToady> but that's a tradeoff we made when we ditched the P5 idea of slice contexts

[19:39] *** molaf joined
[19:42] <Kristien> concatenative programming is great

[19:45] <TimToady> reverse(@$code) can probably be just $code.reverse

[19:46] <dalek> doc: 516704d | Mouq++ | lib/Language/5to6.pod:

[19:46] <dalek> doc: Add a little more about regex translation

[19:46] <dalek> doc: review: https://github.com/perl6/doc/commit/516704db0c

[19:46] *** molaf_ joined
[19:47] * nine_ marvels at the power of modern computing. Installing > 3GB of updates while doing a system backup while playing a 3D action game on the same machine.

[19:48] <Mouq> m: say [+](|[<1 2 3 4>])

[19:48] <camelia> rakudo-moar f73c3f: OUTPUT¬´10‚ê§¬ª

[19:48] <Mouq> m: say [+] |[<1 2 3 4>]

[19:48] <camelia> rakudo-moar f73c3f: OUTPUT¬´10‚ê§¬ª

[19:49] <TimToady> Kristien: also, your constructors will be more inheritable if instead of PushString.bless(:$value) you say self.bless(:$value)

[19:49] <Kristien> shiny

[19:49] <TimToady> since self should contains something that has the virtual class

[19:49] *** molaf left
[19:51] <Kristien> I like how things like def and if can just be normal functions.

[19:51] * TimToady wonders whether it would be worth having a default single-arg constructor for single-attribute classes

[19:52] <colomon> TimToady: seems like it might be pretty easy to do that as a trait or something?

[19:53] <TimToady> wouldn't even need that if it were there by default

[19:53] <masak> TimToady: as long as it can be turned off :)

[19:53] <TimToady> it's not like it's ambiguous with named args

[19:53] <colomon> TimToady: understood, I‚Äôm just looking for an easy solution that doesn‚Äôt require changing the spec.  ;)

[19:53] <TimToady> well, one could even make the argument that a class with N attributes should have an N-arg positional constructor, and it's the user's responsibility if they try to compose badly

[19:54] <TimToady> that's kinda the approach most languages take, after all :)

[19:54] *** brrt joined
[19:54] <TimToady> forcing named args always is just a wee bit nanny-state-ish

[19:55] *** wicope joined
[19:56] <TimToady> but then one would have to think about how to splice off a base class's positional args, I suppose, and thinking is hard

[19:57] <nine_> TimToady: classes tend to grow and soon single-attribute classes have two and then all callers of the constructor would have to change.

[19:57] <TimToady> otoh, having a default positional constructor capability would make it easier to construct something like class IntStr is Int is Str {}; IntStr.new(42,"forty two")

[19:58] <TimToady> nine_: yes, there are certainly downsides

[19:59] *** KCL_ left
[19:59] <TimToady> but currently we have to write IntStr.new(Int{:value(42)},Str{:value("forty two")}) and that's not even implemented yet

[19:59] <TimToady> assuming "value" is the key there for both

[20:00] <TimToady> you can't just use the same key for different parent classes when they need different values

[20:00] <Kristien> time to shower, bye!

[20:00] *** Kristien left
[20:00] <flussence> I agree that constructors do feel pretty awkward right now

[20:01] <flussence> I don't have any great ideas of my own though :)

[20:01] <nine_> It's only default constructers though, isn't it?

[20:01] <TimToady> that was what I was proposing

[20:02] <TimToady> adding a default behavior for positional args as well as for named args

[20:02] <nine_> oh missed the line about N-arg constructors

[20:02] <Mouq> m: say :Int{:value(42)}.perl

[20:02] <camelia> rakudo-moar f73c3f: OUTPUT¬´"Int" => {"value" => 42}‚ê§¬ª

[20:03] <TimToady> after noting all the single-arg constructors in Kristien's gist

[20:03] <TimToady> m: say Int{:value(42)}.perl

[20:03] <camelia> rakudo-moar f73c3f: OUTPUT¬´Any‚ê§¬ª

[20:03] <TimToady> that's supposed to be a WHENCE thingie

[20:03] <colomon> throwing out a random thought I had today: should we be working on a perl 6 ‚Äúcookbook‚Äù, perhaps in the form of a group blog?

[20:03] <masak> currently we don't have anything which assumes an ordering of the attributes, I think.

[20:03] <colomon> afk # picking up son from school

[20:04] <TimToady> and we don't use the :Int syntax because that would be ambiguous if there were an :$Int parameter

[20:04] <masak> colomon: sounds interesting. what would distinguish the cookbook from, say, the advent calendar?

[20:04] <colomon> masak: focus on small practical things, not occurring in December. 

[20:04] <nine_> masak: presumably that it's all year round :)

[20:05] <moritz> colomon: fwiw there's room for cookbook-style contents on doc.perl6.org

[20:05] <moritz> *shameless plug*

[20:09] *** jakesyl left
[20:09] <moritz> and I've been meaning to blog about doc highlights for a while

[20:10] <dalek> doc: aa2c225 | moritz++ | type-graph.txt:

[20:10] <dalek> doc: Add some more exception types to type-graph.txt

[20:10] <dalek> doc: 

[20:10] <dalek> doc: also sort some entries in there

[20:10] <dalek> doc: review: https://github.com/perl6/doc/commit/aa2c225111

[20:11] <moritz> [ptc], Mouq: if you find any pages on doc.perl6.org with particularly good coverage, or better-than-usual examples, alert me to them, and I'll hilight them on my blog

[20:12] <moritz> same goes for others here, of course :-)

[20:14] *** Possum joined
[20:16] <masak> you'll highlight others on your blog? :P

[20:17] *** grondilu left
[20:17] <ab5tract> there's a fair amount of interesting perl 6 material which has been published on other blogs

[20:18] <ab5tract> including yours, moritz :)

[20:19] <moritz> jnthn, lizmat, TimToady: why are channels .close()d and Supplies .done()?

[20:19] <dalek> doc: 806a373 | paultcochrane++ | lib/Language/setbagmix.pod:

[20:19] <dalek> doc: Correct unicode codepoint value for ‚àâ

[20:19] <dalek> doc: review: https://github.com/perl6/doc/commit/806a37379c

[20:19] <dalek> doc: 170f2b9 | paultcochrane++ | / (2 files):

[20:19] <dalek> doc: Merge branch 'master' of github.com:perl6/doc

[20:19] <dalek> doc: review: https://github.com/perl6/doc/commit/170f2b90d9

[20:19] <[ptc]> moritz: will do

[20:19] *** Sqirrel joined
[20:21] <ab5tract> i wonder if it makes sense to re-publish as many of them on doc.perl6.org as we can attain permission for (within the given set of articles which are still correct/relevant)

[20:21] <dalek> zavolaj/cpp: fe9b6ff | FROGGS++ | / (3 files):

[20:21] <dalek> zavolaj/cpp: add support for C++ structures and their methods

[20:21] <dalek> zavolaj/cpp: 

[20:21] <dalek> zavolaj/cpp: The name mangling routine only works for clang and g++ so far, and only

[20:21] <dalek> zavolaj/cpp: for a subset of parameter and return types. Though it is enough to pass

[20:21] <dalek> zavolaj/cpp: our first test.

[20:21] <dalek> zavolaj/cpp: review: https://github.com/jnthn/zavolaj/commit/fe9b6ffb64

[20:21] <dalek> zavolaj/cpp: a575495 | FROGGS++ | lib/NativeCall.pm6:

[20:21] <dalek> zavolaj/cpp: Merge branch 'master' of github.com:jnthn/zavolaj into cpp

[20:21] <dalek> zavolaj/cpp: review: https://github.com/jnthn/zavolaj/commit/a5754953c7

[20:21] <itz_> colomon: there is the start of a PLEAC like cookbook in perl6-examples

[20:22] <ab5tract> for instance, the advent calendar articles could be re-published and categorized by topic as first class documentation

[20:22] <moritz> ab5tract: the problem is that blog posts often aim more for effect than for technical depth/completeness

[20:22] <moritz> ab5tract: but where the technical depth is there, I'm all in favor of doing that

[20:23] <ab5tract> moritz: yes, re-publishing would be based on a curatorial choice

[20:23] <masak> I think a concerted cookbook effort might want to start with a thorough enumeration of the topics to write about.

[20:23] <ab5tract> but links to blogs should definitely be there

[20:23] <masak> basically setting the scope and goals of the project up front.

[20:24] <itz_> PLEAC is based on the 2nd edition Perl (5) Cookboox

[20:25] <ab5tract> moritz: even as a way to document/explain the perl 6 search results. we should probably explain that much of the wiki efforts are outdated

[20:25] <itz_> ^ Cookbook

[20:25] <ab5tract> this kind of thing

[20:25] *** Kristien joined
[20:25] <dalek> specs: 72242eb | moritz++ | S17-concurrency.pod:

[20:25] <dalek> specs: Fix example for $s.tap, mentioned in #77

[20:25] <dalek> specs: review: https://github.com/perl6/specs/commit/72242eb997

[20:26] *** Mouq left
[20:26] <ab5tract> it's been 15 years, for people who haven't been paying much attention it could be really useful to have a sort of "surfer's guide" to the perl 6 online resources

[20:27] <itz_> https://github.com/perl6/perl6-examples/tree/master/cookbook

[20:27] <moritz> that's what perl6.org is supposed to be

[20:27] <ab5tract> moritz: but that's the problem

[20:27] <ab5tract> it's not

[20:27] <TimToady> moritz: on the one hand, channels need both a .close and a .done method because .done returns a promise; the real issue I think is that supplies have a .done method that means something else entirely

[20:27] <moritz> except that we don't give negative advice ("don't go there") on perl6.org

[20:27] <ab5tract> tons of other things come up in google search results

[20:27] <ab5tract> so if perl6.org had a page that could explain exactly the contexts of some of these things

[20:27] <TimToady> maybe we should rename the channel's method .whendone or such

[20:27] <moritz> TimToady: rakudo's Channel.closed gives the promise

[20:28] <ab5tract> i can even browse a book from apress about perl 6 via google books

[20:28] <TimToady> and then we could close a channel with .done as well

[20:28] <ab5tract> from about 10 years ago

[20:28] <Kristien> Stack-based languages are interesting.

[20:28] <ab5tract> it's not about "don't go there". "considered outdated", though, could save some heart break

[20:29] <TimToady> moritz: there is no .closed documented in S17

[20:29] <moritz> TimToady: so .closed should be renamed to .done?

[20:30] <moritz> TimToady: but then .done in Supply does something quite different than Supply.done

[20:30] <TimToady> S17:276 indicates that is named .done

[20:30] <synopsebot> Link: http://design.perl6.org/S17.html#line_276

[20:30] <ab5tract> but even if you would prefer to keep the negative out, i think there is still a place for a "these resources are great" page :)

[20:30] <TimToady> lunch &

[20:31] <moritz> TimToady: X::Channel::SendOnDone after it's .close()d. Another done/closed confusion

[20:31] *** darutoko left
[20:32] <jnthn> evening, #perl6

[20:32] <moritz> it should be SendAfterClose and ReceiveAfterDone, no?

[20:33] *** ninjazach joined
[20:34] <jnthn> moritz: I think Supplies got a lot of attention design wise, and Channel has had rather less.

[20:36] <[ptc]> moritz: re: good docs: maybe grammars.pod and regexes.pod?  I liked the idea that a complete JSON parser could be implemented in 100 lines :-)

[20:38] <moritz> jnthn: also it seems like Supply.done is suposed to shut down the supply in any way

[20:38] <jnthn> moritz: .done tells the receiver "That's the last thing you're getting"

[20:38] <moritz> but it's not, is it?

[20:38] <dalek> doc: a20bdc5 | paultcochrane++ | lib/Language/setbagmix.pod:

[20:38] <dalek> doc: Correct minor typographical issues in setbagmix.pod

[20:38] <dalek> doc: review: https://github.com/perl6/doc/commit/a20bdc57fe

[20:38] <dalek> doc: 7cc2fcf | paultcochrane++ | lib/Language/setbagmix.pod:

[20:38] <dalek> doc: Wrap paragraphs consistently in setbagmix.pod

[20:38] <dalek> doc: review: https://github.com/perl6/doc/commit/7cc2fcf3e4

[20:38] <jnthn> moritz: Only if the sender breaks protocol.

[20:39] <moritz> m: my $s = Supply.new; my $t = $s.tap(&say, :done({ say "done" })); $s.done; $s.emit(42)

[20:39] <camelia> rakudo-moar f73c3f: OUTPUT¬´done‚ê§42‚ê§¬ª

[20:39] <jnthn> You broke protocol.

[20:39] <moritz> jnthn: Channel enforces the protocol, why not Supply?

[20:40] <moritz> jnthn: also if neither .close($tap) nor .done actually shut down the supply, why do we have both?

[20:40] <jnthn> .done and .close flow in opposite directions

[20:41] <jnthn> .done is the senders way of saying "end of iteration"

[20:41] <jnthn> .close is the receiver saying "I'm finished"

[20:41] <moritz> jnthn: then .close should only be on the tap, not on Supply

[20:41] *** Mouq joined
[20:41] <jnthn> Correct

[20:42] <moritz> that's not how it's implemented right now

[20:42] <jnthn> I'm sure I only implemented .close on a Tap.

[20:43] *** beastd joined
[20:43] <moritz> ok, but then Channels should also be shut down with .done

[20:43] <jnthn> Hm, there is a method close on Supply. Did I *really* do that?

[20:43] <moritz> because it's the sender who signals it

[20:43] <jnthn> :S

[20:43] <jnthn> moritz: Yes, that'd be consistent.

[20:44] <moritz> jnthn: seem it was lizmat++

[20:44] <jnthn> moritz: Well, git blame assigns lizmat++ blame for much in that file, but I think she did a lot of moving/refactoring.

[20:45] <jnthn> Anyway, guess I should put having a review of this stuff on my todo list...

[20:46] <jnthn> I think in Rx they've gone in the direction of enforcing protocol in some places where the user has a chance to break it, but allowing the built-ins to not require sanity checks all the way down the chain.

[20:46] <jnthn> Which is probably a sane way to go.

[20:47] <[ptc]> how does one work out if something is a Parcel?

[20:48] <[ptc]> .WHAT doesn't help and I'm not sure what to use

[20:48] <masak> m: say (1, 2, 3) ~~ Parcel

[20:48] <camelia> rakudo-moar f73c3f: OUTPUT¬´True‚ê§¬ª

[20:48] <masak> m: say "OH HAI" ~~ Parcel

[20:48] <camelia> rakudo-moar f73c3f: OUTPUT¬´False‚ê§¬ª

[20:48] <[ptc]> masak: sweet, thanks!

[20:49] <ab5tract> smart match is so great :D

[20:50] <masak> smart match is a very laid-back form of conformance checking.

[20:50] *** Akagi201 joined
[20:51] <ab5tract> indeed. in a way it sort of crystallizes some of (what i see in) the "spirit of perl"  (perlus spiritus?)

[20:51] <moritz> jnthn: and the :closing callback on Tap isn't needed either, right?

[20:52] <masak> ab5tract: yes, exactly.

[20:52] <jnthn> moritz: Uh...yeah, I think that matters.

[20:52] <jnthn> moritz: That's the way that things that need to free up resources on close do so

[20:52] <moritz> jnthn: because if it's the receiver who closes down, he doesn't need a callback for an action he himself initiated

[20:52] *** Akagi201_ left
[20:52] *** bjz left
[20:52] <jnthn> moritz: .close cascades up the chain.

[20:53] <moritz> jnthn: uhm, which chain?

[20:53] <ab5tract> "this is almost always what you want, and if it's not, well learn infix:<this-other-op>"

[20:54] <ab5tract> no, it will actually take many words to try and describe how ~~ makes me feel :)

[20:54] <jnthn> my $t = Supply.interval(1).map(...).grep(...).tap(...); $t.close; # We tap the grep, which taps the map, which taps the Interval, which starts the flow of ticks. When we .close $t, it will .close its sources, etc., up to the interval supply whose closing cancels the timer.

[20:55] *** diana_olhovik left
[20:56] <moritz> jnthn: my $s = Supply.interval(1).map(...).grep(...); $s.tap(...); my $t = $s.tap(...); $t.close; # does the first .tap still live?

[20:56] <jnthn> moritz: Yes

[20:57] <[Coke]> "My Patronus is a Camel"

[20:57] <ab5tract> [Coke]: lol

[20:58] <FROGGS> [Coke]++

[20:58] *** mohij joined
[20:58] *** _mg_ left
[20:59] * masak 's patronus is a giant pastel-colored butterfly

[20:59] <PerlJam> My patronus is Larry Wall  ;)

[20:59] <dalek> roast: 7e89188 | usev6++ | S12-class/stubs.t:

[20:59] <dalek> roast: Add tests for RT #81060

[20:59] <dalek> roast: review: https://github.com/perl6/roast/commit/7e89188444

[20:59] <synopsebot> Link: https://rt.perl.org/rt3//Public/Bug/Display.html?id=81060

[20:59] <skids> A drooling Camel?

[20:59] <hahainternet> i gotta say i don't understand how the first tap would live, but i don't know what the hell i'm talking about so ignore me

[21:00] <TimToady> masak: funny that you think those colors are pastel

[21:00] <moritz> hahainternet: a supply has a list of taps, so it can know whether the last one closed down

[21:00] <masak> TimToady: "pastel" is probably the wrong word, on second thought.

[21:00] <hahainternet> oh right i see

[21:00] <moritz> ... but I don't see that logic in Supply.pm

[21:00] *** bluescreen joined
[21:01] <masak> the colors in camelia are far too saturated to be pastel.

[21:01] *** Guest45 joined
[21:01] <TimToady> they were picked to be primary colors, basically

[21:01] <masak> the hues are all over the place, and contrast-y.

[21:01] <masak> TimToady: ah. I've noticed the same trend in children's toys.

[21:02] <PerlJam> maybe masak's patronus is camelia's little-known sister  :)

[21:02] * masak .oO( Perl 7 ) o.O

[21:02] <TimToady> maybe camelia just needed a few vitimins that day

[21:02] *** bluescreen left
[21:02] * timotimo hues all over the place

[21:02] * TimToady cries

[21:03] * PerlJam wonders what crime was committed.

[21:04] *** pmurias joined
[21:04] <TimToady> crime and pun-ishment

[21:05] <moritz> PerlJam: I dunno, but we can always revert it :-)

[21:05] *** ninjazach left
[21:06] <masak> if you didn't push, you can even reset the crime.

[21:06] *** bluescreen joined
[21:06] <moritz> but thre reflog never forgets! (unless when it does, actually)

[21:07] *** bluescreen left
[21:07] *** ninjazach joined
[21:09] *** _dolmen_ joined
[21:10] <Kristien> I hope my book arrives tomorrow.

[21:10] <Kristien> Amazon's prediction was wrong.

[21:11] <TimToady> it's cause we announced Christmas, it's distorting all the delivery dates

[21:13] <Kristien> that takes about 10.6 months :(

[21:13] <moritz> another mismatch between S17 and rakudo: S17 say Supply.delayed, rakudo says .delay

[21:13] <moritz> I'm assume S17 is correct here

[21:13] <moritz> *correcter

[21:13] *** Demerzel joined
[21:20] *** xfix left
[21:21] <[ptc]> is 'time' an identifier term in the same way that 'now' is?

[21:21] <moritz> [ptc]: yes

[21:21] <moritz> m: say &term:<time>

[21:21] <camelia> rakudo-moar f73c3f: OUTPUT¬´sub term:<time> () { #`(Sub|53959824) ... }‚ê§¬ª

[21:21] <TimToady> m: say time time

[21:21] <camelia> rakudo-moar f73c3f: OUTPUT¬´[31m===[0mSORRY![31m===[0m Error while compiling /tmp/ELR6EbIjrW‚ê§Two terms in a row‚ê§at /tmp/ELR6EbIjrW:1‚ê§------> [32msay time [33m‚èè[31mtime[0m‚ê§    expecting any of:‚ê§        infix stopper‚ê§        infix or meta-infix‚ê§        postfix‚Ä¶¬ª

[21:21] <[ptc]> ah, that's how one works that out!

[21:22] <[ptc]> moritz: cool, thanks.  Now I can add that to terms.pod

[21:22] <TimToady> m: say rand 42

[21:22] <camelia> rakudo-moar f73c3f: OUTPUT¬´[31m===[0mSORRY![31m===[0m Error while compiling /tmp/V3Vg5A3l0s‚ê§Unsupported use of rand(N); in Perl 6 please use N.rand or (1..N).pick‚ê§at /tmp/V3Vg5A3l0s:1‚ê§------> [32msay rand[33m‚èè[31m 42[0m‚ê§¬ª

[21:22] <TimToady> that should probably say (^N).pick

[21:24] <dalek> doc: 4fd0ef0 | paultcochrane++ | lib/Language/terms.pod:

[21:24] <dalek> doc: Correct typographical etc. issues in terms.pod

[21:24] <dalek> doc: review: https://github.com/perl6/doc/commit/4fd0ef01c3

[21:24] <dalek> doc: 2cef029 | paultcochrane++ | lib/Language/terms.pod:

[21:24] <dalek> doc: Wrap paragraphs consistently in terms.pod

[21:24] <dalek> doc: review: https://github.com/perl6/doc/commit/2cef0294da

[21:24] <dalek> doc: 37c4b74 | paultcochrane++ | lib/Language/terms.pod:

[21:24] <dalek> doc: Document the identifier term 'time'

[21:24] <dalek> doc: review: https://github.com/perl6/doc/commit/37c4b74d22

[21:24] *** Rounin left
[21:27] *** vendethiel left
[21:29] *** alini left
[21:29] *** adu joined
[21:29] *** Guest45 left
[21:30] <dalek> roast: 0830070 | moritz++ | S17-supply/delay (2 files):

[21:30] <dalek> roast: Supply.delay -> .delayed

[21:30] <dalek> roast: review: https://github.com/perl6/roast/commit/0830070b49

[21:30] <dalek> rakudo/nom: 4eac7e0 | moritz++ | / (3 files):

[21:30] <dalek> rakudo/nom: Deprecate Supply.delay in favor of Supply.delayed

[21:30] <dalek> rakudo/nom: 

[21:30] <dalek> rakudo/nom: that is what S17 says, and it sounds cleaner for a method that returns

[21:30] <dalek> rakudo/nom: a modified copy instead of modifying in-place

[21:30] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/4eac7e0b2a

[21:31] <dalek> doc: 3697772 | moritz++ | lib/Type/Supply.pod:

[21:31] <dalek> doc: Supply.delayed

[21:31] <dalek> doc: review: https://github.com/perl6/doc/commit/3697772ef8

[21:31] *** vendethiel joined
[21:32] <dalek> rakudo/nom: f53a94d | TimToady++ | src/Perl6/Grammar.nqp:

[21:32] <dalek> rakudo/nom: fix rand(N) redirect to precise replacement

[21:32] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/f53a94d211

[21:33] <moritz> oh, and btw, I find 'earliest' to be very confusing

[21:33] <TimToady> maybe we should change to something like, oh, winner...

[21:34] <moritz> in  earliest $something { ... },   what exactly is that $something?

[21:35] *** _dolmen_ left
[21:36] <dalek> rakudo/native-ref: 05d8627 | jnthn++ | src/Perl6/Metamodel/BOOTSTRAP.nqp:

[21:36] <dalek> rakudo/native-ref: Further work on multi-dispatch on native refs.

[21:36] <dalek> rakudo/native-ref: review: https://github.com/rakudo/rakudo/commit/05d8627793

[21:36] <moritz> there are two examples with 'earliest $channel { ... }' and the rest is 'earliest * { }'

[21:36] *** jakesyl joined
[21:36] <TimToady> it's meant to be a list of contestants over which * matches if you wildcard the cases

[21:37] <moritz> so if I write 'earliest * { ... }' then the potential sources are the channels listed inside

[21:37] <vendethiel> moritz: the earlier value?

[21:37] <vendethiel> oh, the opposite

[21:37] <TimToady> moritz: yes

[21:38] <moritz> but that's just a degenerate (but very common) case of stating the sources first, and matching inside?

[21:39] <TimToady> you can see it as a kind of given when, sorta

[21:39] <moritz> except that it inverts itself when you give it a *

[21:40] <TimToady> not really

[21:40] <TimToady> it just broadens the constraint at that point

[21:40] <moritz> uhm, which constraint?

[21:40] <TimToady> the constraint of which channels it has to check

[21:40] <TimToady> "you only have to check $ch1"

[21:42] <moritz> m: earliest * { more * { say 42 } }

[21:42] <camelia> rakudo-moar f73c3f: OUTPUT¬´Nothing todo for earliest‚ê§  in sub EARLIEST at src/gen/m-CORE.setting:23305‚ê§  in block <unit> at /tmp/mK333znhts:1‚ê§‚ê§¬ª

[21:42] <TimToady> with implicit ORing on the lists of channels, and an implicit ANDing between the outer constrant and the inner

[21:42] <TimToady> maybe it's looking for all the channels and finding none

[21:43] <TimToady> not sure we want to be tracking all the channels globally like that though

[21:43] <TimToady> so probably we make that illegal

[21:44] <moritz> uhm

[21:45] <moritz> I thought the * in   "earliest * { more $c1 { ... }; more $c2 { ... } };"  meant $ch1, $ch2, not "all the channels globally"

[21:45] <moritz> m: earliest * { more Channel.new() { }; more * { say 42 } }

[21:45] <moritz> yeah, that'll hang

[21:45] <camelia> rakudo-moar f73c3f: OUTPUT¬´(timeout)¬ª

[21:46] <TimToady> as an ANDed constraint, there's no conflict there

[21:46] <TimToady> * admits anything that was selected elsewhere

[21:46] <TimToady> the only question is how we determine the universe of discourse

[21:47] <moritz> and how we explain that sometimes the sources are afterh the 'earliest', and sometimes they are in the 'more' clauses

[21:47] <moritz> *after

[21:48] <TimToady> better designs welcome :)

[21:48] <TimToady> but only if they're better...

[21:49] <FROGGS> TimToady: there should be more than one way to design

[21:49] *** espadrine joined
[21:50] <moritz> Supply.earliest($channel1, $channel2, ...) # thinking out loud

[21:51] <moritz> and if you only want one value, Promise.anyof(@channels)

[21:53] <moritz> maybe I should start by asking what use cases 'earliest' is supposed to cover

[21:53] <dalek> nqp/js: 0abed2d | (Pawel Murias)++ | / (3 files):

[21:53] <dalek> nqp/js: Implement nqp::settypecache.

[21:53] <dalek> nqp/js: review: https://github.com/perl6/nqp/commit/0abed2d0c1

[21:53] <moritz> polling over $N source?

[21:53] <moritz> *sources

[21:54] *** _dolmen_ joined
[21:59] <moritz> if you want to act in response to new values being available, Supply seems to be a much easier approach than Channel + earliest

[21:59] <jnthn> Indeed

[22:00] <jnthn> Channel is more useful when you're building a SEDA-style thing and you *want* to have threads blocking.

[22:00] <jnthn> And you have threads doing different stages of the pipeline

[22:01] <dalek> nqp/js: 2a199d1 | (Pawel Murias)++ | / (3 files):

[22:01] <dalek> nqp/js: Implement nqp::setmethcache.

[22:01] <dalek> nqp/js: review: https://github.com/perl6/nqp/commit/2a199d1ccd

[22:01] <jnthn> Which is quite different from the thread-affinity of supplies

[22:01] *** Kristien left
[22:02] <Demerzel> nqp::setmethcache heh

[22:03] <timotimo> m)

[22:04] * moritz looks up https://en.wikipedia.org/wiki/Staged_event-driven_architecture

[22:04] *** FROGGS_ joined
[22:05] *** skids left
[22:05] <moritz> not much there :(

[22:05] * japhb did the same, with the same assessment

[22:06] * moritz goes to sleep now

[22:06] *** Sqirrel left
[22:07] <japhb> o/

[22:08] *** FROGGS left
[22:09] *** adu left
[22:11] <brrt> sleep well moritz

[22:11] <brrt> SEDA seems like what people do with goroutines

[22:12] <masak> and Unix pipes.

[22:12] <pmurias> masak: by AST based search you meant: typing say(* ~ "World") and finding say("Hello" ~ "World")?

[22:13] <pmurias> with * being replace by a suitable placeholder

[22:13] <masak> pmurias: that's one example, I guess.

[22:13] <masak> pmurias: also things like "find all occurrences of this variable" (in order to rename it safely)

[22:13] <masak> pmurias: or "give me the declaration site for this class/sub/method/enum"

[22:15] *** Sqirrel joined
[22:16] <brrt> yeah, unix pipes are another really good example

[22:16] <brrt> this was the counterpoint to my last GC rant

[22:16] *** kaare_ joined
[22:17] <brrt> rather than build big systems that use lots of moving parts, best build your tools small and your algorithms online, so that they may fit in a pipeline

[22:18] <brrt> (i.e. if your tools are small there is no need to build advanced garbage collectors and similar things)

[22:18] <masak> the seems to be the gist both of microservices and the recent surge in promises/futures libraries.

[22:20] *** spider-mario left
[22:20] <brrt> one of the wondrous things of IT is that you can simply move the same task - e.g. garbage collection - from one space to the other (userspace or kernel) and that it then makes a difference

[22:21] <dalek> doc: 2c674a9 | paultcochrane++ | lib/Language/traps.pod:

[22:21] <dalek> doc: Correct minor typographical issues in traps.pod

[22:21] <dalek> doc: review: https://github.com/perl6/doc/commit/2c674a948d

[22:21] <dalek> doc: fa8f12f | paultcochrane++ | lib/Language/traps.pod:

[22:21] <dalek> doc: Wrap paragraphs consistently in traps.pod

[22:21] <dalek> doc: review: https://github.com/perl6/doc/commit/fa8f12fbb3

[22:21] <dalek> doc: c3ae3ca | paultcochrane++ | lib/Language/traps.pod:

[22:21] <dalek> doc: Separate output by a comma in containers versus values gotcha

[22:21] <dalek> doc: 

[22:21] <dalek> doc: This makes the output a little clearer and thus hopefully the point which is

[22:21] <dalek> doc: being made clearer.

[22:21] <dalek> doc: review: https://github.com/perl6/doc/commit/c3ae3ca057

[22:21] <dalek> doc: e8b7d41 | paultcochrane++ | lib/Type/Supply.pod:

[22:21] <dalek> doc: Merge branch 'master' of github.com:perl6/doc

[22:21] <dalek> doc: review: https://github.com/perl6/doc/commit/e8b7d4167d

[22:22] *** Demerzel left
[22:24] <pmurias> brrt: I would prefer to have a decent garbage collector rather then restructure my apps to work around crappy ones

[22:24] <masak> pmurias: do you consider Perl 5's "decent"?

[22:24] *** beastd left
[22:25] <pmurias> masak: it doesn't annoy me much

[22:26] <brrt> yes, but my point was not that current GC's are crappy, just that work seems to have ceased in making them better; better typically meaning more complex

[22:26] <brrt> at least if i consider the recent work on the JVM

[22:27] *** raiph left
[22:27] <brrt> and i personally don't know anybody who really *likes* working with the JVM

[22:28] * pmurias has very little JVM experience

[22:29] *** pdcawley left
[22:31] <pmurias> brrt: the recentish graal stuff makes be interested in the JVM, but getting Perl 6 on JS seems more important

[22:31] <brrt> well, it has it's nice points; it has all sorts of debugging and monitoring and logging hooks

[22:31] <masak> pmurias: getting Perl 6 on JS is important. ++pmurias

[22:32] <brrt> yes indeed ++pmurias

[22:33] <brrt> anyway, i have a really nice compliment: one of my colleagues recently said that 'the first page of (Ovid++)s slide already contained more interesting things than alll of swift'

[22:33] <hahainternet> got a link?

[22:39] <pmurias> wasn't the interesting part of swift that it's not objective-c?

[22:39] <brrt> yeah, pretty much, and they also had some ruby-isms

[22:40] <brrt> but believe it or not the possible introduction of swift is causing pretty great consternation among @colleagues

[22:41] *** ninjazach left
[22:45] <raydiak> hahainternet: I think this one http://www.slideshare.net/Ovid/perl-6-for-mere-mortals

[22:46] *** Kristien joined
[22:46] * raydiak was fond of the mechanical fuel injection pic :)

[22:46] <hahainternet> raydiak: ah, i've read that one and is excellent

[22:46] <hahainternet> read a bunch of fosdem stuff too, wondered what i missed

[22:47] *** locsmif joined
[22:49] <ab5tract> i've created a PR. the description is pretty descriptive, but the tl;dr is "what do you think of this approach" and "something pretty weird is happening when declaring an infix:<(^+)> in core"

[22:49] <ab5tract> https://github.com/rakudo/rakudo/pull/362

[22:50] * brrt afk

[22:50] *** brrt left
[22:50] <ab5tract> "description is pretty descriptive" ... indication that i need $sleep

[22:52] *** rindolf left
[22:52] *** raiph joined
[22:53] *** dustinm` left
[22:53] *** rurban left
[22:55] *** adu joined
[22:55] <japhb> Oh man, I just got a request from a friend to teach him "object-oriented Perl" ... he writes a lot of Perl 5 code, but it's not far from "Perl 4 with references and lexical variables" ... completely procedural.

[22:56] <japhb> I gave him a whirlwind tour of Perl 6, but I think I might have overwhelmed him a bit.

[22:56] <masak> :)

[22:56] <japhb> Need to figure out how to take it down a notch and get him on a gentle ramp.  :-)

[22:56] <masak> japhb: I feel I know a fair bit of OOP at this point, but I'd be hard-pressed to summarize that knowledge. it's all a bit ineffable.

[22:56] <Kristien> japhb: teach him FP in Perl instead

[22:56] <Kristien> then tell him objects are just tuples of functions

[22:57] <masak> japhb: perhaps find a suitable domain and model it out, to make it all very concrete?

[22:57] *** dustinm` joined
[22:57] <japhb> masak: Hmmm, that might work.

[22:57] * raydiak was originally introduced to P5 like that too, by some guy who regarded OO as a bunch of needless complexity

[22:58] <masak> japhb: and make sure to hit important keywords like "responsibility", "pre/postconditions", "invariants", "delegation" and "hiding".

[22:58] <japhb> He knows C++ pretty well, so at least the OO concept in general is there.

[22:58] <japhb> Hmmm, yes.

[22:58] <raydiak> (and I concur with masak++'s suggestion, is how I learned my way out of that hole too)

[22:58] <japhb> But he's used to doing things really long-hand (because C++), so I'm hoping to show him the value of concision.

[22:59] <masak> japhb: I've come to hate most OOP introductions, which basically give a tour of how the language of the day (mis)understands OOP.

[22:59] <japhb> Nodnod

[22:59] <masak> and don't get me started on dogs inheriting from mammals and car has_a engine.

[22:59] <japhb> Heh

[22:59] <Kristien> Nobody knows C++ pretty well.

[23:00] <japhb> Kristien: There is at least one person within 50 feet of me who is on the C++ spec committee.  :-)

[23:00] <masak> in fact, I think 99% of the OOP tutorials out there are the blind leading the blind.

[23:00] <Kristien> Committee members tend to not know C++ pretty well. :)

[23:00] <japhb> (It's not him, mind you, but I'm arguing your point.  ;-)

[23:00] <japhb> Heh

[23:01] <Kristien> cue std::dynarray

[23:01] <hahainternet> i'd love to see a take on perl6 from a hardcore haskell programmer or similar

[23:01] <hahainternet> be interested to see what the thoughts are from that side of the aisle

[23:01] <japhb> hahainternet: It's called Pugs.  ;-)

[23:02] <japhb> There was even a name for that particular group: lambdacamels

[23:02] <hahainternet> japhb: I mean more a review of the spec as it stands, but yeah

[23:02] <hahainternet> haha nice

[23:02] <Kristien> hahainternet: I know one.

[23:02] <hahainternet> Kristien: yeah i know a few but it's not easy to ask someone to do a detailed review of an unfamiliar language :)

[23:03] <Kristien> He dismisses Perl 6 based on what he heard about Perl 5 code being line noise and unmaintainable.

[23:03] <japhb> Says a *Haskell* programmer?  Sheesh.

[23:03] <Kristien> (he knows absolutely nothing about Perl)

[23:03] <hahainternet> well i was asking a friend his thoughts, and one of his rules for example was 'immutability by default'

[23:03] <hahainternet> which starts to get real hard real quick

[23:04] <Kristien> He once said "perl is fucking terrible" and "Java > C > Perl > PHP"

[23:05] <japhb> In any case, I'll have to think of a good domain for him to look at and learn on.  Some of my code would be easily in his domain, but I'm using too much idiom for a beginner, methinks.

[23:05] <Kristien> japhb: compiler construction

[23:06] <japhb> Kristien: That's sortof like learning chemistry by studying cellular biology

[23:06] <geekosaur> anyone who thinks C is better than perl has a rather skewed view of the world

[23:06] <geekosaur> C's a *horrible* language

[23:07] <Kristien> C is definitely better than Perl in domains where C is better than Perl.

[23:07] <japhb> Kristien: Like writing Perl VMs ...

[23:07] <Kristien> For example, when the target platform has only a C implementation and no Perl implementation.

[23:07] <Kristien> japhb: we desperately need PePe a la PyPy

[23:08] <japhb> masak, jnthn: Do you guys teach OO courses amongst your many?  If so, what problem domain do you bootstrap the class with?

[23:09] <Kristien> I wrote a VM in Perl today!

[23:09] <masak> japhb: it varies. we have a couple of them.

[23:10] <japhb> Oh, and masak, I was going to ask you earlier, on a separate note: Is SQLite support in DBIish pretty stable at this point?  If not, what are the gotchas?

[23:10] * TimToady yawns after a sudden nap

[23:10] * Kristien thinks about rewriting VM in C++ using LLVM

[23:10] <masak> japhb: one domain that comes to mind is a company that arranges tour guides. some nice interesting problems can arise with pairing up tourists, tours, vehicles, and drivers.

[23:11] <masak> japhb: my only pain point was that error messages were crappy and not reflected well back in Perl 6 land. but moritz++ fixed that.

[23:12] *** vendethiel left
[23:14] <japhb> masak: Hmmm, interesting idea, that.

[23:14] <japhb> masak: Oh, good.  My early tests were working, so that seemed promising.  Good to hear it's pretty stable now.

[23:15] <masak> in fact, anything that involves scheduling of some kind seems to be a domain ripe for OOP explanations.

[23:15] <masak> such domains are also naturally "collaborative" and OOP tends to shine there.

[23:16] *** _dolmen_ left
[23:16] *** vendethiel joined
[23:20] <b2gills> japhb: I would recommend anyone trying to learn about Perl5 objects read the recently revised/replaced http://perldoc.perl.org/perlootut.html and http://perldoc.perl.org/perlobj.html pages

[23:20] <b2gills> perlootut now mentions Moose/Moo Class::Tiny and Role::Tiny

[23:21] *** mohij left
[23:21] <masak> \o/

[23:22] <japhb> b2gills: Very good to hear that they're modernizing that.

[23:23] <japhb> A quick scan shows a somewhat confusing mix of different levels though (raw v. Moose-style)

[23:24] <b2gills> Actually perlootut was removed, then Tom Christiansen complained

[23:25] * masak .oO( <tchrist> oo! tut! )

[23:26] <b2gills> The point for the new perlootut was to be an onramp to further information, namely the docs for Moose etc

[23:26] <dalek> rakudo-star-daily: 0041e9d | coke++ | log/ (14 files):

[23:26] <dalek> rakudo-star-daily: today (automated commit)

[23:26] <dalek> rakudo-star-daily: review: https://github.com/coke/rakudo-star-daily/commit/0041e9da8e

[23:27] <raydiak> Kristien: I noticed a "reverse($@result)" in there, which won't in fact reverse anything :)

[23:27] <Kristien> oh

[23:28] <Kristien> raydiak: here's the uptodate version: https://github.com/rightfold/stok/blob/master/stok

[23:28] *** ahamilton joined
[23:28] <raydiak> on nice

[23:29] <raydiak> *oh

[23:29] <Kristien> code examples are also in the repo

[23:31] <Kristien> interesting: say "hello" say "world" -- prints "world hello"

[23:31] <masak> m: say "hello" say "world"

[23:31] <camelia> rakudo-moar f53a94: OUTPUT¬´[31m===[0mSORRY![31m===[0m Error while compiling /tmp/mWQpFcH0_u‚ê§Two terms in a row‚ê§at /tmp/mWQpFcH0_u:1‚ê§------> [32msay "hello" [33m‚èè[31msay "world"[0m‚ê§    expecting any of:‚ê§        infix stopper‚ê§        infix or meta-infix‚ê§       ‚Ä¶¬ª

[23:31] <masak> ...nope.

[23:31] <geekosaur> makes sense... parse as say("hello", say("world"))

[23:32] <geekosaur> if you write it as parseable in p6 at least

[23:32] <geekosaur> (2 terms in a row rule)

[23:32] <Kristien> no I mean in the tool I linked raydiak :P

[23:32] <Kristien> it evaluates code backwards

[23:33] <masak> innermost-first.

[23:33] <Mouq> masak: I believe it's stack based, so innermost may not be the right term :P

[23:33] <b2gills> I just noticed 'yas' is the reverse of 'say'

[23:34] <Kristien> I made it that way so you can say def "foo" [ ‚Ä¶ ] instead of [ ‚Ä¶ ] "foo" def XD

[23:35] <raydiak> heh "for reverse(@$code) { ... }"

[23:35] <raydiak> maybe I'll understand better if I read the interpreter's source from the bottom to the top :)

[23:36] <Kristien> It should be Turing-complete so you can write a stok interpreter in stok :P

[23:37] <raydiak> that'd be a cool example...

[23:37] <Mouq> .oO( Lazy stack-based language )

[23:37] *** vendethiel left
[23:40] *** _dolmen_ joined
[23:42] *** vendethiel joined
[23:42] *** ahamilton left
[23:50] <Kristien> { and } for constructing lists are actually just functions!

[23:51] *** _dolmen_ left
[23:52] <[Coke]> pmurias, hoelzro: should "make js-test" be clean?

[23:52] *** gfldex left
[23:56] *** Kristien left
[23:59] *** pmurias left
