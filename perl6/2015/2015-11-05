[00:00] *** kid51 joined
[00:00] *** khw left
[00:00] <osto> True, but head and body elements allow different child elements. It would be nice if there was a way to write a pattern for a generic element, and then extend it for a more specific element.

[00:00] *** Peter_R left
[00:01] <osto> I might be looking at this the wrong way.

[00:02] <timotimo> there's no reason you'd have to use <sym> inside the regex

[00:02] <timotimo> or use it only once

[00:03] *** sprocket joined
[00:04] <osto> But that gives you only one parameter. I can't specify an element by both name and allowed content patterns.

[00:05] <osto> Maybe I'm misunderstanding something about proto

[00:05] <RabidGravy> BooK, the http://docs.perl6.org/language/grammars and the co-located regex page

[00:05] <RabidGravy> beyond that dunno

[00:06] <osto> Thanks, I'll take a look

[00:11] <kmel> Hola!

[00:13] <ugexe> osto: i think something like this might be what you are looking for https://github.com/ugexe/Perl6-Grammar--HTTP/blob/master/lib/Grammar/HTTP/RFC7230.pm6#L95

[00:14] <ugexe> it will attempt to apply a rule that matches the name of the header itself, and if one does not exist it uses a generic rule

[00:15] <ugexe> and then the matches all come back as name => value, not some-rule3 => somevalue-4

[00:16] <RabidGravy> is there any reason that the constants PIO::* in IO::Socket::INET are "my" scoped?

[00:16] <ugexe> the rules used to match those headers are in another file, but each one has different match logic

[00:17] *** raiph joined
[00:17] <osto> Thanks! I'll probably have to play around with it to understand it better, but this is helpful.

[00:19] <BooK> RabidGravy: thanks

[00:21] *** leont left
[00:23] *** BenGoldberg left
[00:25] *** firstdayonthejob left
[00:31] *** aborazmeh joined
[00:31] *** aborazmeh left
[00:31] *** aborazmeh joined
[00:32] *** lichtkind left
[00:36] *** kmel left
[00:42] <RabidGravy> right it's bed time

[00:42] <RabidGravy> toodle pip

[00:47] *** RabidGravy left
[00:47] *** espadrine left
[00:51] <AlexDaniel> Timbus: thank you very much :)

[00:52] *** MadcapJake left
[00:58] <timotimo> osto: the sym<foobar> part is actually part of the name, not really a parameter; each regex/token/rule you have that has the same name before the :sym<...> part as a proto token/rule/regex would be attempted to match against when the proto token/regex/rule is invoked

[00:58] <timotimo> osto: inside the regex's definition, you can put whatever you like

[00:59] <timotimo> https://github.com/moritz/json/blob/master/lib/JSON/Tiny/Grammar.pm <- osto, BooK, this is a good example grammar, BTW. the "Actions.pm" file in the same folder belongs to it, too.

[01:00] * timotimo signs off

[01:07] <osto> timotimo: That's the exact module I've been looking at for a while.

[01:08] <osto> I just found that amusing :)

[01:09] *** yeahnoob joined
[01:14] *** telex left
[01:16] *** telex joined
[01:18] *** sufrostico left
[01:19] *** Actualeyes joined
[01:23] *** khw joined
[01:24] *** khw left
[01:27] *** MilkmanD1n is now known as MilkmanDan

[01:28] *** lizmat left
[01:43] *** tokuhiro_ joined
[01:47] *** tokuhiro_ left
[01:57] *** [Tux] left
[01:59] *** nightfrog left
[02:03] *** raiph left
[02:03] *** nightfrog joined
[02:05] *** lizmat joined
[02:15] *** [Tux] joined
[02:15] *** nightfrog left
[02:15] *** nightfrog joined
[02:16] *** AlexDaniel left
[02:17] *** tokuhiro_ joined
[02:24] <osto> Dumb question: What's the best way to use a conditional in a regex? Something like:

[02:25] <osto> token example($arg) { $arg == 42 ?? a* :: b* }

[02:25] *** yqt left
[02:27] *** chenryn joined
[02:31] <tokuhiro_> hmm

[02:31] <tokuhiro_> m: dd("\x0d\x0a".encode('latin1').decode('latin1') ~~ /\x0d?\x0a/)

[02:31] <camelia> rakudo-moar 183d69: OUTPUT«Any $var = Any␤»

[02:31] <tokuhiro_> why?

[02:36] <ugexe> because \x0d\x0a its encoded as 1 grapheme but you are comparing it against 2 i would guess

[02:37] <ugexe> as in, i can see how the ? could imply its 2 characters

[02:38] <ugexe> maybe /[\x0a | \x0d\x0a]/ would work

[02:39] <ShimmerFairy> m: say ?("\r\n".encode("latin1").decode("latin1") ~~ /\r?\n/)

[02:39] <camelia> rakudo-moar 183d69: OUTPUT«True␤»

[02:39] <ShimmerFairy> m: say ?("\r\n".encode("latin1").decode("latin1") ~~ /\x0d?\x0a/)

[02:39] <camelia> rakudo-moar 183d69: OUTPUT«False␤»

[02:39] <ShimmerFairy> m: say ?("\r\n".encode("latin1").decode("latin1") ~~ /"\r"? "\n"/)

[02:39] <camelia> rakudo-moar 183d69: OUTPUT«False␤»

[02:40] <ShimmerFairy> tokuhiro_: note that /\n/ will match any kind of newline, beyond just ^J and ^M^J  :)

[02:41] <ShimmerFairy> m: say ?("\r\n".encode("latin1").decode("latin1") ~~ /^ \n $/)

[02:41] <camelia> rakudo-moar 183d69: OUTPUT«True␤»

[02:42] <tokuhiro_> hmm

[02:42] *** kid51 left
[02:43] <ugexe> if its your http parser grammar CRLF you could look at grammar::http, as its code works with the new changes

[02:43] *** softmoth left
[02:44] *** ilbot3 left
[02:44] <ShimmerFairy> I get the feeling /\r?\n/ only works because the \r? is ignored, what with the question mark :)

[02:44] <ShimmerFairy> m: say ?("\r\n" ~~ /\r\n/)

[02:44] <camelia> rakudo-moar 183d69: OUTPUT«True␤»

[02:44] <ShimmerFairy> huh, apparently not.

[02:46] <zengargoyle> m: "\r\n".encode('latin1')

[02:46] <camelia> rakudo-moar 183d69: ( no output )

[02:46] <zengargoyle> m: say "\r\n".encode('latin1')

[02:46] <camelia> rakudo-moar 183d69: OUTPUT«Blob[uint8]:0x<0d 0a>␤»

[02:46] *** ilbot3 joined
[02:47] <zengargoyle> that just has the 0d on my moar built just early this morning...

[02:47] <ShimmerFairy> which means somebody (most likely jnthn++) fixed non-Unicode encodings since then :)

[02:47] *** eliasr left
[02:48] <zengargoyle> yeah, i'mma going to wait a couple of days until everything settles. :P

[02:49] <ugexe> my ocd will not allow such a thing

[02:51] <osto> Another dumb question.... I can't find the syntax for how to reference a unicode character by name in a regex...

[02:54] <zengargoyle> "\c[LATIN CAPITAL LETTER A, COMBINING RING ABOVE]"

[02:55] <osto> Awesome, thanks

[02:55] <zengargoyle> <:name(/^LATIN LETTER.*P$/)>

[02:55] <zengargoyle> from quick ack of specs

[02:55] <zengargoyle> no guarantees...

[02:57] <zengargoyle> m: say 'A' ~~ /<:name('LATIN CAPITAL LETTER A')>/

[02:57] <ShimmerFairy> The <:name()> version is particularly useful if you need to match any character with a particular kind of name, as shown in the paste :)

[02:57] <camelia> rakudo-moar 183d69: OUTPUT«｢A｣␤»

[02:58] <zengargoyle> m: say 'A' ~~ /"c[LATIN CAPITAL LETTER A]"/

[02:58] <camelia> rakudo-moar 183d69: OUTPUT«Nil␤»

[02:58] <zengargoyle> m: say 'A' ~~ /"\c[LATIN CAPITAL LETTER A]"/

[02:58] <camelia> rakudo-moar 183d69: OUTPUT«｢A｣␤»

[02:58] <zengargoyle> m: say 'A' ~~ /\c[LATIN CAPITAL LETTER A]/

[02:58] <camelia> rakudo-moar 183d69: OUTPUT«｢A｣␤»

[03:00] *** kaare_ joined
[03:00] <osto> Interesting, although I imagine over a set of characters whose names match a regex is never a good idea.

[03:00] <osto> *matching over

[03:01] <osto> Besides matching the exact name of course

[03:02] <osto> m: say 'A' ~~ /<:name('')>/

[03:02] <camelia> rakudo-moar 183d69: OUTPUT«Nil␤»

[03:02] <osto> m: say 'A' ~~ /<:name('LETTER')>/

[03:02] <camelia> rakudo-moar 183d69: OUTPUT«Nil␤»

[03:02] <osto> m: say 'A' ~~ /<:name('LATIN CAPITAL LETTER A')>/

[03:02] <camelia> rakudo-moar 183d69: OUTPUT«｢A｣␤»

[03:05] <osto> m: say "\t" ~~ /<:name('CHARACTER TABULATION')>/

[03:05] <camelia> rakudo-moar 183d69: OUTPUT«｢    ｣␤»

[03:05] <osto> m: say "\t" ~~ /<:name('TAB')>/

[03:05] <camelia> rakudo-moar 183d69: OUTPUT«Nil␤»

[03:05] <osto> m: say "\t" ~~ /<:name('tab')>/

[03:05] <camelia> rakudo-moar 183d69: OUTPUT«Nil␤»

[03:12] *** kid51 joined
[03:13] <osto> Another question: Is there a way to match every item in a list, but in any order?

[03:15] <osto> say "b, a, c" ~~ /{.join(', ') for <a b c>.permutations}/

[03:15] <osto> m: say "b, a, c" ~~ /{.join(', ') for <a b c>.permutations}/

[03:15] <camelia> rakudo-moar 183d69: OUTPUT«｢｣␤»

[03:16] <osto> m: say "bac" ~~ /{<a b c>.permutations}/

[03:16] <camelia> rakudo-moar 183d69: OUTPUT«｢｣␤»

[03:16] <osto> m: say <a b c>.permutations

[03:16] <camelia> rakudo-moar 183d69: OUTPUT«((a b c) (a c b) (b a c) (b c a) (c a b) (c b a))␤»

[03:17] <osto> m: say /{<a b c>.permutations}/

[03:17] <camelia> rakudo-moar 183d69: OUTPUT«/{<a b c>.permutations}/␤»

[03:17] <osto> m: say .join for <a b c>.permutations

[03:17] <camelia> rakudo-moar 183d69: OUTPUT«abc␤acb␤bac␤bca␤cab␤cba␤»

[03:18] <osto> m: say "bac" ~~ /{.join for <a b c>.permutations}/

[03:18] <camelia> rakudo-moar 183d69: OUTPUT«｢｣␤»

[03:19] *** ostomachion joined
[03:21] <ostomachion> say (.join for <a b c>.permutations).WHAT

[03:21] <ostomachion> m: say (.join for <a b c>.permutations).WHAT

[03:21] <camelia> rakudo-moar 183d69: OUTPUT«(List)␤»

[03:21] *** kid51 left
[03:23] <ostomachion> m: my @a = <x y>; say "x" ~~ /x/;

[03:23] <camelia> rakudo-moar 183d69: OUTPUT«｢x｣␤»

[03:23] <ostomachion> m: my @a = <x y>; say "x" ~~ /@a/;

[03:23] <camelia> rakudo-moar 183d69: OUTPUT«｢x｣␤»

[03:23] <ostomachion> m: my @a = <x y>; say "x" ~~ /{@a}/;

[03:23] <camelia> rakudo-moar 183d69: OUTPUT«｢｣␤»

[03:23] <ostomachion> m: my @a = <x y>; say "x" ~~ /<@a>/;

[03:23] <camelia> rakudo-moar 183d69: OUTPUT«｢x｣␤»

[03:24] <ostomachion> m: my @a = <x y>; say "x" ~~ /<{@a}>/;

[03:24] <camelia> rakudo-moar 183d69: OUTPUT«｢x｣␤»

[03:24] <ostomachion> m: say "bac" ~~ /<{.join for <a b c>.permutations}>/

[03:24] <camelia> rakudo-moar 183d69: OUTPUT«Nil␤»

[03:24] <ostomachion> m: say "x" ~~ /<{<x y>}>/

[03:24] <camelia> rakudo-moar 183d69: OUTPUT«｢x｣␤»

[03:25] <ostomachion> m: say .join for <a b c>.permutations

[03:25] <camelia> rakudo-moar 183d69: OUTPUT«abc␤acb␤bac␤bca␤cab␤cba␤»

[03:26] <ostomachion> m: say .join for <a b>.permutations

[03:26] <camelia> rakudo-moar 183d69: OUTPUT«ab␤ba␤»

[03:27] <ostomachion> m: my $x = .join for <a b>.permutations; my $y = <ab ba>; say $x == $y

[03:27] <camelia> rakudo-moar 183d69: OUTPUT«Cannot convert string to number: base-10 number must begin with valid digits or '.' in '7⏏5ba' (indicated by 7⏏)␤  in block <unit> at /tmp/wTX7Ud4W4c:1␤␤Actually thrown at:␤  in block <unit> at /tmp/wTX7Ud4W4c:1␤␤»

[03:27] <ostomachion> m: my $x = .join for <a b>.permutations; my $y = <ab ba>; say $x eq $y

[03:27] <camelia> rakudo-moar 183d69: OUTPUT«False␤»

[03:27] <ostomachion> m: say <a b>.permutations

[03:27] <camelia> rakudo-moar 183d69: OUTPUT«((a b) (b a))␤»

[03:28] <ostomachion> m: say .join for <a b>.permutations

[03:28] <camelia> rakudo-moar 183d69: OUTPUT«ab␤ba␤»

[03:28] <ostomachion> m: say <ab ba>

[03:28] <camelia> rakudo-moar 183d69: OUTPUT«(ab ba)␤»

[03:29] <ostomachion> m: say @(.join for <a b>.permutations) # ???

[03:29] <camelia> rakudo-moar 183d69: OUTPUT«(ab ba)␤»

[03:30] <ostomachion> m: say "bac" ~~ /<{@(.join for <a b>.permutations)}>/

[03:30] <camelia> rakudo-moar 183d69: OUTPUT«｢ba｣␤»

[03:30] *** Actualeyes left
[03:30] <ostomachion> m: say "bac" ~~ /<{@(.join for <a b c>.permutations)}>/

[03:30] <camelia> rakudo-moar 183d69: OUTPUT«｢bac｣␤»

[03:30] <ostomachion> m: say ":D"

[03:30] <camelia> rakudo-moar 183d69: OUTPUT«:D␤»

[03:30] *** dmitri joined
[03:31] <ostomachion> Now... is there a way to do this without calling .permutations? I imaging it doesn't scale well

[03:36] <ostomachion> m: say "bbaa" ~~ /<{@(.join for (/a*/, /b+/, /c?/).permutations)}>/

[03:36] <camelia> rakudo-moar 183d69: OUTPUT«Regex object coerced to string (please use .gist or .perl to do that)  in block  at /tmp/jWm70vGjJI:1␤Regex object coerced to string (please use .gist or .perl to do that)  in block  at /tmp/jWm70vGjJI:1␤Regex object coerced to string (please use .gist…»

[03:36] <ostomachion> m: say "bbaa" ~~ /<{@((/a*/, /b+/, /c?/).permutations)}>/

[03:36] <camelia> rakudo-moar 183d69: OUTPUT«Regex object coerced to string (please use .gist or .perl to do that)  in block <unit> at /tmp/EIRSj9Fo5q:1␤Regex object coerced to string (please use .gist or .perl to do that)  in block <unit> at /tmp/EIRSj9Fo5q:1␤Regex object coerced to string (plea…»

[03:38] <dmitri> is there a real Perl6 module (for example, one listed on modules.perl6.org) that uses macros?

[03:38] <dmitri> s/real//

[03:39] *** ostomachion left
[03:39] *** osto left
[03:48] *** kaare_ left
[03:55] *** Oatmeal left
[03:56] *** chenryn left
[03:56] *** bpmedley left
[03:56] *** bpmedley joined
[03:57] *** bpmedley left
[03:57] *** bpmedley joined
[04:01] *** khw joined
[04:07] *** domm left
[04:08] *** Oatmeal joined
[04:17] *** chenryn joined
[04:20] *** BenGoldberg joined
[04:28] *** softmoth joined
[04:32] *** dmitri left
[04:32] *** softmoth left
[04:34] *** Actualeyes joined
[04:52] *** BenGoldberg left
[04:58] *** xpen left
[05:07] *** khw left
[05:15] *** sprocket left
[05:19] *** vendethiel joined
[05:31] *** cognominal joined
[05:31] *** skids left
[05:43] *** vendethiel left
[05:49] *** Oatmeal left
[05:49] *** aborazmeh left
[05:59] *** yeahnoob left
[06:01] *** xpen joined
[06:01] *** Oatmeal joined
[06:17] *** softmoth joined
[06:18] <moritz> #ÄÄBN N ÄSÄAÖ-´P#9~9~+ẞ4~+TXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX9~XX9~XXXXXGVFVT8NLOULPÄ#

[06:18] <moritz> -

[06:19] <moritz> good morning from Ida (and now also from me) :-)

[06:20] *** xfix joined
[06:21] *** softmoth left
[06:28] *** aindilis left
[06:32] <tadzik> good morning :D

[06:36] <Hotkeys> m: say "test".chars;

[06:36] <camelia> rakudo-moar 183d69: OUTPUT«4␤»

[06:37] <Hotkeys> m: 1 + 1

[06:37] <camelia> rakudo-moar 183d69: OUTPUT«WARNINGS:␤Useless use of "+" in expression "1 + 1" in sink context (line 1)␤»

[06:37] <Hotkeys> m: "test".chars

[06:37] <camelia> rakudo-moar 183d69: ( no output )

[06:38] <Hotkeys> doing "test".chars in my repl makes it stop working

[06:38] <Hotkeys> but doing say "test".chars is fine

[06:38] <Hotkeys> it also doesn't exit when I type exit

[06:38] <Hotkeys> but it does if I do "say exit"

[06:39] <Hotkeys> did I break something

[06:39] *** domidumont joined
[06:40] <timotimo> does it perhaps think you want to put more things on the same line? or something?

[06:42] <timotimo> hm. or perhaps the warning makes it break

[06:44] *** domidumont left
[06:44] *** domidumont joined
[06:45] <dalek> ecosystem: d4b1b6f | (Fayland Lam)++ | META.list:

[06:45] <dalek> ecosystem: Add Business::CreditCard to ecosystem

[06:45] <dalek> ecosystem: 

[06:45] <dalek> ecosystem: See https://github.com/fayland/perl6-Business-CreditCard

[06:45] <dalek> ecosystem: review: https://github.com/perl6/ecosystem/commit/d4b1b6ff98

[06:46] <mrf> good * #perl6

[06:50] <timotimo> hey mrf

[06:50] *** domidumont left
[06:51] <Hotkeys> timotimo: http://i.imgur.com/7d3YxkU.png

[06:51] <Hotkeys> the big spaces before terminating are me hitting enter

[06:51] <Hotkeys> I also tried putting a semicolon and that didn't do anything

[06:52] <timotimo> can you try just "warn 'foo'"?

[06:52] <Hotkeys> > warn 'foo'

[06:52] <Hotkeys> foo  in block <unit> at <unknown file>:1

[06:52] <Hotkeys> 0

[06:52] <timotimo> hum.

[06:53] <Hotkeys> http://i.imgur.com/G1HWGZY.png

[06:53] <Hotkeys> weird

[06:54] <Hotkeys> ignore my strange directory structure

[06:55] *** andreoss joined
[06:56] <mrf> timotimo: are you able to merge things into rakudo?

[06:56] <timotimo> i don't have a clue what's going wrong there

[06:56] <timotimo> yeah, i am

[06:57] <mrf> timotimo: any chance you could look at https://github.com/rakudo/rakudo/pull/573 as the spec tests for it have already been merged so are likely failing

[06:57] <Hotkeys> i also tried rebuilding rakudo

[06:57] <Hotkeys> didn't help

[06:58] * mrf heads to work

[06:58] *** geraud left
[06:59] <Hotkeys> also just restarted

[06:59] <Hotkeys> still doing it

[07:00] <Hotkeys> also does it in both powershell and the command prompt

[07:00] <timotimo> mrf: done it :)

[07:00] <dalek> rakudo/nom: c698e20 | (Mike Francis)++ | src/Perl6/Actions.nqp:

[07:00] <dalek> rakudo/nom: Add support for 1^..^10 non inclusive range quantifiers in regexs

[07:00] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/c698e20d6b

[07:00] <dalek> rakudo/nom: 55d55f3 | timo++ | src/Perl6/Actions.nqp:

[07:00] <dalek> rakudo/nom: Merge pull request #573 from ungrim97/feature/non_inc_range_quantifier

[07:00] <dalek> rakudo/nom: 

[07:00] <dalek> rakudo/nom: Add support for 1^..^10 non inclusive range quantifiers in regexs

[07:00] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/55d55f3cab

[07:00] <Hotkeys> and perl6 has no problem executing files

[07:00] <Hotkeys> just a repl problem it seems

[07:00] <timotimo> yeah, our repl is a strange beast

[07:01] <timotimo> the way it works wants a redesign ... at least partially

[07:01] <andreoss> m: class Foo { has &!code ; submethod CALL-ME(|z) { &!code.(||z) } }; my $x = Foo.new(code => { say "hi" })

[07:01] <camelia> rakudo-moar 183d69: ( no output )

[07:01] <andreoss> m: class Foo { has &!code ; submethod CALL-ME(|z) { &!code.(||z) } }; my $x = Foo.new(code => { say "hi" }) ; $x()

[07:01] <camelia> rakudo-moar 183d69: OUTPUT«Cannot invoke this object␤  in submethod CALL-ME at /tmp/RnomBOAjft:1␤  in block <unit> at /tmp/RnomBOAjft:1␤␤»

[07:02] <timotimo> huh, ||?

[07:03] <timotimo> class Foo { has &!code ; submethod CALL-ME(|z) { &!code.(|z) } }; my $x = Foo.new(code => { say "hi" }); $x()

[07:03] <timotimo> m: class Foo { has &!code ; submethod CALL-ME(|z) { &!code.(|z) } }; my $x = Foo.new(code => { say "hi" }); $x()

[07:03] <camelia> rakudo-moar 183d69: OUTPUT«Cannot invoke this object␤  in submethod CALL-ME at /tmp/oQwC2Qbd7w:1␤  in block <unit> at /tmp/oQwC2Qbd7w:1␤␤»

[07:03] <timotimo> huh.

[07:03] <andreoss> m: class Foo does Callable { has &!code ; submethod CALL-ME(*@a) { &!code.(|@a) } }; my $x = Foo.new(code => { say "hi" }) ; $x()

[07:03] <camelia> rakudo-moar 183d69: OUTPUT«Cannot invoke this object␤  in submethod CALL-ME at /tmp/SjXpCfkcwi:1␤  in block <unit> at /tmp/SjXpCfkcwi:1␤␤»

[07:04] <mrf> timotimo++ thanks

[07:04] *** domidumont joined
[07:05] *** domidumont left
[07:08] <timotimo> thank you for contributing :)

[07:09] *** diana_olhovik_ joined
[07:09] <andreoss> m: class Foo does Callable { has &.code ; submethod CALL-ME(*@a) { &.code.(|@a) } }; my $x = Foo.new(code => { say "hi" }) ; $x()

[07:09] <camelia> rakudo-moar 183d69: OUTPUT«5===SORRY!5=== Error while compiling /tmp/2RGUbNiwBR␤Virtual call &.code may not be used on partially constructed objects␤at /tmp/2RGUbNiwBR:1␤------> 3&.code ; submethod CALL-ME(*@a) { &.code7⏏5.(|@a) } }; my $x = Foo.new(code => { sa␤  …»

[07:10] <andreoss> m: class Foo does Callable { has &.code ; submethod CALL-ME(*@a) { self.code.(|@a) } }; my $x = Foo.new(code => { say "hi" }) ; $x()

[07:10] <camelia> rakudo-moar 183d69: OUTPUT«hi␤»

[07:10] <andreoss> m: class Foo does Callable { has &.code ; submethod CALL-ME(|z) { self.code.(|z) } }; my $x = Foo.new(code => { say "hi" }) ; $x()

[07:10] <camelia> rakudo-moar 183d69: OUTPUT«hi␤»

[07:11] <andreoss> why this doesn't work with private attribute?

[07:15] <andreoss> also why the second deference is needed since it already has & sigil?

[07:17] <dalek> perl6-most-wanted: 33fa25b | azawawi++ | most-wanted/modules.md:

[07:17] <dalek> perl6-most-wanted: Added Selenium::WebDriver as a WIP

[07:17] <dalek> perl6-most-wanted: review: https://github.com/perl6/perl6-most-wanted/commit/33fa25bc99

[07:19] *** domidumont joined
[07:19] *** vendethiel joined
[07:24] <Timbus> class Fdsa does Callable { has &.code; submethod CALL-ME(|z) { &!code(|z) } }; my $x = Fdsa.new(code => { say "hi" }); $x()

[07:24] <Timbus> m: class Fdsa does Callable { has &.code; submethod CALL-ME(|z) { &!code(|z) } }; my $x = Fdsa.new(code => { say "hi" }); $x()

[07:24] <camelia> rakudo-moar 55d55f: OUTPUT«hi␤»

[07:25] <Timbus> andreoss, the public accessor is a method that returns the code block, if that's what you mean about 'dereferencing'

[07:25] <andreoss> m: class Wrap does Callable { has &!code;  submethod BUILD(:&!code) { * }   submethod CALL-ME(|z) { &!code.(|z) } } ; my Wrap $x .= new(code => { say "hi @_[]" }) ; $x(10);

[07:25] <andreoss>  

[07:25] <camelia> rakudo-moar 55d55f: OUTPUT«5===SORRY!5=== Error while compiling /tmp/LVDkwdDP8i␤Strange text after block (missing semicolon or comma?)␤at /tmp/LVDkwdDP8i:1␤------> 3 &!code;  submethod BUILD(:&!code) { * }7⏏5   submethod CALL-ME(|z) { &!code.(|z) }␤    expecting an…»

[07:26] <andreoss> m: class Wrap does Callable { has &!code;  submethod BUILD(:&!code) { * }   ; submethod CALL-ME(|z) { &!code.(|z) } } ; my Wrap $x .= new(code => { say "hi @_[]" }) ; $x(10);

[07:26] <camelia> rakudo-moar 55d55f: OUTPUT«hi 10␤»

[07:28] <andreoss> m: class Wrap does Callable { has &!code; submethod CALL-ME(|z) { &!code.(|z) } } ; my Wrap $x .= new(code => { say "hi @_[]" }) ; $x(10);

[07:28] <camelia> rakudo-moar 55d55f: OUTPUT«Cannot invoke this object␤  in submethod CALL-ME at /tmp/56Ce9s0696:1␤  in block <unit> at /tmp/56Ce9s0696:1␤␤»

[07:28] <andreoss> m: class Wrap does Callable { has &!code = { say "bye" }; submethod CALL-ME(|z) { &!code.(|z) } } ; my Wrap $x .= new(code => { say "hi @_[]" }) ; $x(10);

[07:28] <camelia> rakudo-moar 55d55f: OUTPUT«bye␤»

[07:29] <andreoss> private attributes are not handled by default constructor? 

[07:29] *** darutoko joined
[07:31] <TimToady> if you want the name to be part of the public API, you must declare it with . instead of !

[07:33] <TimToady> "private" means you can change the name and nobody's program will break

[07:33] <TimToady> so don't use ! unless you mean that

[07:34] *** eone joined
[07:34] <andreoss> what if i just don't want an accessor for a variable?

[07:35] *** firstdayonthejob joined
[07:35] <moritz> andreoss: what's the use case for letting a user set an attribute, but not read it?

[07:39] <tadzik> perhaps it's not a variable after all, just a good name to have in .new()

[07:39] *** Actualeyes left
[07:39] *** Actualeyes joined
[07:40] *** RabidGravy joined
[07:44] <andreoss> moritz: i want a wrapper/decorator class, so i don't need these accessors at all 

[07:45] <andreoss> may be there is a better way to achieve  that

[07:47] *** _mg_ joined
[07:47] *** vendethiel left
[07:55] <[Tux]> test             50000    36.543    36.428

[07:55] <[Tux]> test-t           50000    36.848    36.733

[07:59] <nine> [Tux]: nice numbers! I wonder what helped there

[07:59] <[Tux]> noise

[08:00] <[Tux]> but yes, nice numbers

[08:02] <nine> .tell jnthn I wonder if PackageHOW would be a good place for the global merging code. Then it would just be a matter of GLOBALish.merge-symbols($handle.globalish-package);

[08:02] <yoleaux> nine: I'll pass your message to jnthn.

[08:06] *** softmoth joined
[08:10] *** softmoth left
[08:12] *** rindolf joined
[08:23] *** Actualeyes left
[08:24] *** firstdayonthejob left
[08:27] <andreoss> m: Parcel.WHAT.say

[08:27] <camelia> rakudo-moar 55d55f: OUTPUT«5===SORRY!5=== Error while compiling /tmp/kj8qUzHel3␤Undeclared name:␤    Parcel used at line 1␤␤»

[08:28] *** leont joined
[08:32] *** ely-se joined
[08:33] <nine> andreoss: Parcel's gone

[08:33] <lizmat> good *, #perl6!

[08:34] <nine> Good #perl6, lizmat!

[08:34] <lizmat> nine o/

[08:36] *** chenryn left
[08:37] *** chenryn joined
[08:39] *** zakharyas joined
[08:46] *** leont left
[08:49] *** abraxxa joined
[08:50] *** yeahnoob joined
[08:52] *** g4 joined
[08:55] *** eone left
[09:02] *** Jonis joined
[09:17] <andreoss> had Rakudo::Perl6::Format ever been working or that's some kind of draft?

[09:23] *** abaugher` left
[09:23] *** dakkar joined
[09:23] *** abaugher` joined
[09:29] <lizmat> andreoss: not sure what that's for beast

[09:30] <lizmat> oops, dutchism:

[09:30] <lizmat> not sure what kind of beast that is

[09:31] *** Psyche^ joined
[09:31] <BooK> mmm, formats

[09:33] *** lab joined
[09:34] *** lab is now known as nadim

[09:35] *** Psyche^_ left
[09:36] <lizmat> afk for a few hours&

[09:50] *** yeahnoob left
[09:51] <mrf>  m: say "ll" ~~ /l ** ^3/

[09:51] <camelia> rakudo-moar 55d55f: OUTPUT«｢ll｣␤»

[09:51] <mrf> :D

[09:55] *** softmoth joined
[09:59] *** softmoth left
[10:00] *** rindolf left
[10:03] *** grondilu left
[10:03] <RabidGravy> andreoss, it looks like it may work to some extent if some of the pull requests were merged

[10:04] <RabidGravy> it needs a bit of love

[10:04] * RabidGravy isn't even going to touch it with a bargepole

[10:04] *** grondilu joined
[10:05] <RabidGravy> seem to be spending more time working on other modules than the ones I want to make

[10:05] <RabidGravy> ho-hum

[10:06] <RabidGravy> there's a lot of stuff which is like 80% there for my needs ;-)

[10:14] *** espadrine joined
[10:23] *** rarara__ joined
[10:23] *** rarara__ left
[10:27] *** ollej left
[10:29] *** virtualsue joined
[10:30] *** chenryn left
[10:34] <RabidGravy> .tell tadzik as discussed last night I've sent https://github.com/tadzik/JSON-Unmarshal/pull/10 to make some things easier to unmarshall nicely

[10:34] <yoleaux> RabidGravy: I'll pass your message to tadzik.

[10:34] <tadzik> awesome, I'll try get around it today :)

[10:34] <yoleaux> 10:34Z <RabidGravy> tadzik: as discussed last night I've sent https://github.com/tadzik/JSON-Unmarshal/pull/10 to make some things easier to unmarshall nicely

[10:34] <tadzik> hey, thanks yolo!

[10:35] <RabidGravy> cool, all working and everything

[10:35] *** llfourn left
[10:39] <RabidGravy> this is why I started with a "nice and simple" idea like making a META.info parser, more special cases than I could have imagined before I started

[10:40] <tadzik> you know what'd be fun?

[10:40] <tadzik> use this to create a JSON schema vaildator

[10:41] <RabidGravy> that would be cool

[10:42] <tadzik> maybe even *the* JSON schema

[10:43] <RabidGravy> what I am actually aiming toward is getting https://github.com/jonathanstowe/JSON-Infer working nicely so the generate classes Just Work™

[10:44] *** pdcawley left
[10:45] <RabidGravy> anyway off out to the supermarket now

[10:45] <RabidGravy> have fun

[10:50] *** RabidGravy left
[10:59] *** chenryn joined
[10:59] *** pippo joined
[10:59] <pippo> o/ #perl6!

[11:01] <pippo> m: grammar G {…}; G.parse("AA"); grammar G {rule TOP {.*}};

[11:01] <camelia> rakudo-moar 55d55f: OUTPUT«5===SORRY!5=== Error while compiling /tmp/yLZxYEKcrs␤Redeclaration of symbol G␤at /tmp/yLZxYEKcrs:1␤------> 3grammar G {…}; G.parse("AA"); grammar G7⏏5 {rule TOP {.*}};␤    expecting any of:␤        generic role␤»

[11:02] <pippo> ^^Bug? That used to work with '…' and now no more. It works with '...' though.

[11:02] <pippo> m: grammar G {...}; G.parse("AA"); grammar G {rule TOP {.*}};

[11:02] <camelia> rakudo-moar 55d55f: ( no output )

[11:05] <grondilu> (TIL I learnt that on irssi you can type "/msg" by just pressing tab)

[11:05] <pippo> .tell lizmat Bug? http://irclog.perlgeek.de/perl6/2015-11-05#i_11487475

[11:05] <yoleaux> pippo: I'll pass your message to lizmat.

[11:07] *** pippo left
[11:11] <jnthn> afternoon, #perl6

[11:11] <yoleaux> 4 Nov 2015 18:58Z <nine> jnthn: I just love these moments, when working on the implementation reveals another piece of the rationale behind your design, even when you didn't spell it out. It's like reading a good book, only in a more active way :)

[11:11] <yoleaux> 4 Nov 2015 19:09Z <lizmat> jnthn: perhaps .ords should return a List of List of codepoints

[11:11] <yoleaux> 4 Nov 2015 19:36Z <lizmat> jnthn: S15:148 may need some rewording, as it specifically states ord can return negative numbers

[11:11] <yoleaux> 08:02Z <nine> jnthn: I wonder if PackageHOW would be a good place for the global merging code. Then it would just be a matter of GLOBALish.merge-symbols($handle.globalish-package);

[11:11] <synbot6> Link: http://design.perl6.org/S15.html#148_may_need_some_rewording

[11:11] <jnthn> o.O

[11:11] <tadzik> :D

[11:16] <grondilu> m: say |<a b c> xx 3  # pretty cool that this works as expected

[11:16] <camelia> rakudo-moar 55d55f: OUTPUT«(a b c a b c a b c)␤»

[11:17] <jnthn> TIL kidney beans expand a lot when left to soak overnight

[11:17] <grondilu> m: say 1, |<a b c> xx 3 # not sure about that though

[11:17] <camelia> rakudo-moar 55d55f: OUTPUT«1(a b c a b c a b c)␤»

[11:18] <jnthn> .tell lizmat Seems the .ords question was answered by TimToady++, and yeah, S15 will want aligning with the tests

[11:18] <yoleaux> jnthn: I'll pass your message to lizmat.

[11:18] <stmuk> I once confused wet and dry weight with chickpeas and ended up with a 5 nines % chickpea casserole

[11:20] <jnthn> My recipe says 350g of dried beans, soaked overnight :)

[11:21] <jnthn> So I'm pretty sure I've got it right :)

[11:21] <gfldex> how heavy are they now?

[11:22] <TEttinger> stmuk: that sounds entertaining

[11:22] <jnthn> .tell nine Glad you're having fun with! ;) I don't know PackageHOW would be the right place; it's a meta-object. And GLOBALish is just a type object. It's GLOBALish:: that is the actual Stash to merge things in to. So Stash may be a better place.

[11:22] <yoleaux> jnthn: I'll pass your message to nine.

[11:22] <TEttinger> for the entire homeless shelter you could feed with it, I'm sure

[11:23] <jnthn> gfldex: Not sure, they're still in the water for now :)

[11:24] <jnthn> Though I kinda just realized that when I've been buying kidney beans in tins I've been mostly paying for water...

[11:25] <TEttinger> not even very drinkable water

[11:29] <lizmat> .botsnack

[11:29] <yoleaux> 11:05Z <pippo> lizmat: Bug? http://irclog.perlgeek.de/perl6/2015-11-05#i_11487475

[11:29] <synbot6> om nom nom

[11:29] <yoleaux> :D

[11:29] <yoleaux> 11:18Z <jnthn> lizmat: Seems the .ords question was answered by TimToady++, and yeah, S15 will want aligning with the tests

[11:30] *** nightfro` joined
[11:31] *** nightfrog left
[11:31] *** nightfro` is now known as nightfrog

[11:31] *** nadim left
[11:31] *** nadim joined
[11:32] <stmuk> I do sort of wish .chars was .wchars or .graphemes

[11:32] <lizmat> stmuk: why ?

[11:33] * grondilu wonders if we could not have |op] as a shortcut for |[op]

[11:33] *** kid51 joined
[11:33] <grondilu> (or rather |\op] for |[\op])

[11:34] <ilmari> eww, non-matched brackets

[11:34] <stmuk> lizmat: because it's more obvious and explicit

[11:35] <grondilu> ilmari: yeah, non-matching brackets are LTA, granted.

[11:35] <ilmari> LTA?

[11:35] <grondilu> Less Than Awesome, see S99

[11:35] <DrForr> Well, .wchars could easily mean 16-bit characters like you get out of the curses library, not UTF-8.

[11:36] <ilmari> DrForr: there's no such thing as a utf8 character

[11:36] <tadzik> I think synbot6 can do that

[11:36] <gfldex> m: say 1, |( |<a b c> xx 3) # i want my spaces back!

[11:36] <camelia> rakudo-moar 55d55f: OUTPUT«1abcabcabc␤»

[11:36] <tadzik> synbot6: LTA

[11:36] <ilmari> </peeve>

[11:36] <tadzik> S99:LTA

[11:36] <synbot6> Link: http://design.perl6.org/S99.html#LTA

[11:36] <tadzik> aha!

[11:37] <grondilu> gfldex: use slip

[11:37] <grondilu> m: say 1, slip |<a b c> xx 3

[11:37] <camelia> rakudo-moar 55d55f: OUTPUT«1abcabcabc␤»

[11:37] <gfldex> m: dd (1, |( |<a b c> xx 3))

[11:37] <camelia> rakudo-moar 55d55f: OUTPUT«List $var = $(1, "a", "b", "c", "a", "b", "c", "a", "b", "c")␤»

[11:37] <stmuk> DrForr: well wikipedia says A wide character is a computer character datatype that generally has a size greater than the traditional 8-bit character

[11:37] <DrForr> ilmari: Yes, I'm aware. Graphemes are more correct than any of the alternatives like .char or .wchar, because of how Unicode designates "characters".

[11:37] <gfldex> grondilu: confess! you took my spaces!

[11:38] <grondilu> oh I get what you meant now

[11:38] <DrForr> And I'm just *today* back from vacation, need time to take up slack.

[11:38] <ilmari> DrForr: my point is that the character set is unicode, utf-8 is merely the encoding

[11:38] <grondilu> m: say 1, 2, 3

[11:38] <camelia> rakudo-moar 55d55f: OUTPUT«123␤»

[11:38] <DrForr> Ah, yes.

[11:39] <ilmari> DrForr: you probably meant unicode character

[11:39] <grondilu> m: say .WHAT given 1, 2, 3

[11:39] <camelia> rakudo-moar 55d55f: OUTPUT«(List)␤»

[11:39] <DrForr> I thought the standard preferred the term 'glyph'?

[11:40] <ilmari> no, glyph is how it's rendered

[11:40] <ilmari> fonts have glyphs

[11:41] <DrForr> Okay, I sit corrected.

[11:42] *** rindolf joined
[11:43] <gfldex> m: say 1,2,3; say (1,2,3); that's a little confusing

[11:43] <camelia> rakudo-moar 55d55f: OUTPUT«5===SORRY!5=== Error while compiling /tmp/MPKNDKH8ao␤Undeclared routines:␤    a used at line 1␤    confusing used at line 1␤    little used at line 1␤    that's used at line 1␤␤»

[11:43] <gfldex> m: say 1,2,3; say (1,2,3); # that's a little confusing

[11:43] <camelia> rakudo-moar 55d55f: OUTPUT«123␤(1 2 3)␤»

[11:43] *** softmoth joined
[11:45] <gfldex> m: say 1,2,3; my $a := 1,2,3; say $a; # even more so

[11:45] <camelia> rakudo-moar 55d55f: OUTPUT«123␤(1 2 3)␤»

[11:47] *** pippo joined
[11:47] <pippo> m: say (1, slip (|<a b c>) xx 3).Str;

[11:47] <camelia> rakudo-moar 55d55f: OUTPUT«1 a b c a b c a b c␤»

[11:48] <pippo> gfldex: ^^Is that what you were looking for?

[11:48] *** softmoth left
[11:49] <gfldex> pippo: i'm looking for bugs, your last version works

[11:52] <grondilu> it's a bit awkard that stringification looks better than gist

[11:53] <grondilu> *awkward

[11:53] *** xfix left
[11:53] <grondilu> m: say (1, slip |<a b> xx 3).Str

[11:53] <camelia> rakudo-moar 55d55f: OUTPUT«1 a b a b a b␤»

[11:53] <grondilu> m: say (1, slip |<a b> xx 3).gist

[11:53] <camelia> rakudo-moar 55d55f: OUTPUT«(1 a b a b a b)␤»

[11:53] <grondilu> ??

[11:53] <grondilu> m: say (1, slip |<a b> xx 3)

[11:53] <camelia> rakudo-moar 55d55f: OUTPUT«(1 a b a b a b)␤»

[11:53] <grondilu> wth

[11:54] <grondilu> m: say 1, slip |<a b> xx 3

[11:54] <camelia> rakudo-moar 55d55f: OUTPUT«1ababab␤»

[11:54] <grondilu> I have no idea what's going on here

[11:55] <grondilu> not the same say multi candidate I guess

[11:55] *** pmurias joined
[11:56] <dalek> nqp: 0223e6a | jnthn++ | src/QRegex/P5Regex/Actions.nqp:

[11:56] <dalek> nqp: Fixes to :P5 to match magical \n behavior.

[11:56] <dalek> nqp: 

[11:56] <dalek> nqp: Discovered when making \n on Windows default to \r\n.

[11:56] <dalek> nqp: review: https://github.com/perl6/nqp/commit/0223e6acd0

[11:56] <nine> Hi jnthn!

[11:56] <yoleaux> 11:22Z <jnthn> nine: Glad you're having fun with! ;) I don't know PackageHOW would be the right place; it's a meta-object. And GLOBALish is just a type object. It's GLOBALish:: that is the actual Stash to merge things in to. So Stash may be a better place.

[11:56] <nine> jnthn: Ah, so it _is_ a Stash? That's what I thought at first, but introspection confused me:

[11:56] <nine> m: use nqp; say "WHAT: {GLOBAL.WHAT.gist}, ^name: {GLOBAL.^name}, HOW: {GLOBAL.HOW}, isa Stash? {GLOBAL ~~ Stash} nqp::istype Stash? {nqp::istype(GLOBAL, Stash)}"

[11:56] <camelia> rakudo-moar 55d55f: OUTPUT«WHAT: (GLOBAL), ^name: GLOBAL, HOW: Perl6::Metamodel::PackageHOW<140198113318904>, isa Stash? False nqp::istype Stash? 0␤»

[11:57] *** andreoss left
[11:57] <nine> m: use nqp; say "WHAT: {GLOBALish.WHAT.gist}, ^name: {GLOBALish.^name}, HOW: {GLOBALish.HOW}, isa Stash? {GLOBALish ~~ Stash} nqp::istype Stash? {nqp::istype(GLOBALish, Stash)}"

[11:57] <camelia> rakudo-moar 55d55f: OUTPUT«WHAT: (GLOBAL), ^name: GLOBAL, HOW: Perl6::Metamodel::PackageHOW<139854194657272>, isa Stash? False nqp::istype Stash? 0␤»

[11:57] <jnthn> nine: GLOBALish isn't. GLOBALish.WHO is.

[11:58] <jnthn> nine: GLOBALish:: just being sugar for GLOBALish.WHO

[11:58] <grondilu> .oO(  multi say(**@args is raw) { say (@args) } )

[11:59] <nine> jnthn: ah I see now that in Perl6::ModuleLoader::merge_globals only $target.WHO is accessed

[12:01] <dalek> roast: 72bb826 | jnthn++ | S32-exceptions/misc.t:

[12:01] <dalek> roast: Harden test against different newline formats.

[12:01] <dalek> roast: review: https://github.com/perl6/roast/commit/72bb82658d

[12:01] <nine> So it becomes GLOBALish.WHO.merge-symbols($handle.globalish-package.WHO) which is still very nice

[12:03] <jnthn> nine: Yes :)

[12:03] <jnthn> Phew, down to two test files with regressions before I can push magical \n

[12:04] *** TEttinger left
[12:05] <nine> I think the key to untangling this mess was really to completely separate loading the BOOTSTRAP from loading plain modules. Now we can easily move the code into places where it belongs.

[12:09] *** xpen left
[12:09] <lizmat> nine++  # the great untangler

[12:10] <jnthn> nine++ # making sense of my designs

[12:11] <nine> lizmat: I think it's actually an advantage that I knew almost nothing about this part of Rakudo when I started. Since I don't know what has been difficult historically, I just naively try things and some of them work out well :)

[12:12] *** AlexDaniel joined
[12:13] <stmuk> m: Buf.new(13, 10).decode("ascii").chars

[12:13] <camelia> rakudo-moar 55d55f: ( no output )

[12:13] <stmuk> m: say Buf.new(13, 10).decode("ascii").chars

[12:13] <camelia> rakudo-moar 55d55f: OUTPUT«1␤»

[12:14] *** virtualsue left
[12:21] *** abraxxa left
[12:21] *** abraxxa joined
[12:21] *** andreoss joined
[12:21] <andreoss> m: my %h = a => 1; my $z = %h<a>:exists || %h<b>:exists; say $z;

[12:21] <camelia> rakudo-moar 55d55f: OUTPUT«5===SORRY!5=== Error while compiling /tmp/8UcGS60Xx8␤You can't adverb &infix:<||>␤at /tmp/8UcGS60Xx8:1␤------> 3 1; my $z = %h<a>:exists || %h<b>:exists7⏏5; say $z;␤    expecting any of:␤        pair value␤»

[12:22] <andreoss> m: my %h = a => 1; my $z = %h<a>:exists or %h<b>:exists; say $z;

[12:22] <camelia> rakudo-moar 55d55f: OUTPUT«True␤»

[12:25] <andreoss> RabidGray: seems working after few fixes 

[12:25] *** pippo left
[12:25] *** bpmedley left
[12:27] *** Actualeyes joined
[12:28] *** chenryn left
[12:28] *** chenryn joined
[12:28] <dalek> roast: 238fd35 | jnthn++ | S32-io/IO-Socket-INET. (3 files):

[12:28] <dalek> roast: Make IO::Socket tests not sensitive to magical \n.

[12:28] <dalek> roast: review: https://github.com/perl6/roast/commit/238fd3559c

[12:29] <dalek> nqp: 570054a | jnthn++ | tools/build/MOAR_REVISION:

[12:29] <dalek> nqp: Get MoarVM with various normalization fixes.

[12:29] <dalek> nqp: review: https://github.com/perl6/nqp/commit/570054afc0

[12:30] <andreoss> though it doesn't do much indenting, just basic stuff like blocks 

[12:31] *** kaare_ joined
[12:31] <andreoss> also it does compile the code

[12:31] <andreoss> i guess it need some special action class to prevent it from doing so

[12:43] <jnthn> lizmat: Ah, I think the Supply.lines tests may be a little bogus

[12:43] <jnthn> They do this:

[12:43] <jnthn>               $s.emit( "\nc\rd\n" );

[12:43] <jnthn>               $s.emit( "\ne" );

[12:43] <lizmat> that could well be

[12:43] <jnthn> oops, wrong 2

[12:43] <jnthn>               $s.emit( "a\nb\r" );

[12:43] <jnthn>               $s.emit( "\nc\rd\n" );

[12:43] <jnthn> But that could actually never be emitted by incoming data 'cus we'd never split a grapheme

[12:43] <lizmat> well, that was intentional

[12:44] <jnthn> Well, either Supply.lines needs to change to concatenate the leftover with the new

[12:44] <lizmat> ah, but that would also be true for sockets ?

[12:44] <jnthn> Right, if you read chars from a socket, if we see a \r in one packet, we'll not give you it back until we've seen the next packet doesn't have a \n at the start (and if it does, then we turn it into the grapheme)

[12:44] <lizmat> if we receive at the end of a CR and the next chunk starts with a LF, would that work ?

[12:45] <lizmat> ok, so that was what that test was checking

[12:45] <jnthn> Ah

[12:45] <jnthn> If we want that test to work, then the best way is to have Supply.lines concatenate new stuff to old

[12:45] <lizmat> and afaik, it will concat the chunks

[12:45] *** chenryn left
[12:45] <lizmat> doesn't it do that ?

[12:45] <jnthn> I don't see a concat in there

[12:46] <jnthn> oh, or...hmm

[12:46] <lizmat> $str   = $str ~ nqp::unbox_s(val);

[12:46] <jnthn> Yeah

[12:46] <lizmat> line 458

[12:46] <jnthn> So what on earth else is it doing to end up leaking the \r out...

[12:46] <lizmat> maybe concat is busted in that respect ?

[12:47] <jnthn> No

[12:47] <jnthn> That I'm very sure works :)

[12:47] <jnthn> m: say ("\r" ~ "\n").chars

[12:47] <camelia> rakudo-moar 55d55f: OUTPUT«1␤»

[12:47] *** nadim left
[12:48] *** nadim joined
[12:48] <jnthn> Hmm

[12:48] <jnthn> It's really odd

[12:49] <ilmari> m: ("\r" ~ "\n").codes

[12:49] <camelia> rakudo-moar 55d55f: ( no output )

[12:49] <ilmari> m: say ("\r" ~ "\n").codes

[12:49] <camelia> rakudo-moar 55d55f: OUTPUT«2␤»

[12:49] <jnthn> lizmat: Maybe I should just push the change I have and tell you how to reproduce the issue? :)

[12:50] <lizmat> sure, that will work for me  :-)

[12:50] <jnthn> ++lizmat :)

[12:50] <lizmat> then will get back to you if I can't figure it out  :-)

[12:50] *** kid51 left
[12:51] <dalek> rakudo/nom: 772cb2a | jnthn++ | tools/build/NQP_REVISION:

[12:51] <dalek> rakudo/nom: Bump NQP_REVISION in preparation for magical \n.

[12:51] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/772cb2ac22

[12:51] <dalek> rakudo/nom: 4f276be | jnthn++ | src/Perl6/Actions.nqp:

[12:51] <dalek> rakudo/nom: Make \n resolve to $?NL.

[12:51] <dalek> rakudo/nom: 

[12:51] <dalek> rakudo/nom: This means it produces \r\n on Windows, \n elsewhere, and can be

[12:51] <dalek> rakudo/nom: controlled using the `use newline` pragma.

[12:51] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/4f276be3c0

[12:51] <jnthn> First try S17-supply/lines.t with that. It'll probably pass. Then try the test file with `use newline :crlf;` added at the top.

[12:52] <lizmat> oki

[12:53] * jnthn wonders where the stick tests for the newline pragma

[12:54] <nine> So much work just to make software do the "obviously right thing"

[12:55] *** Actualeyes left
[12:55] <ilmari> the hardest part is often figuring out what that actually is

[12:56] <flussence> some things are obviously right until you re-read them 6 months later :)

[12:56] <stmuk> LWP::Simple::parse_chunks is broken but I guess investigation might be best when current work is completed?

[12:57] <lizmat> stmuk: I would at least try post the latest NQP_REVISION bump

[12:58] <dalek> roast: 6785742 | jnthn++ | S16-io/newline.t:

[12:58] <dalek> roast: Basic tests for newline pragma.

[12:58] <dalek> roast: review: https://github.com/perl6/roast/commit/67857429e7

[12:58] <stmuk> lizmat: OK I'll update again

[12:58] <dalek> rakudo/nom: af78ecc | jnthn++ | t/spectest.data:

[12:58] <dalek> rakudo/nom: Run S16-io/newline.t.

[12:58] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/af78eccd04

[13:01] *** aborazmeh joined
[13:01] *** aborazmeh left
[13:01] *** aborazmeh joined
[13:04] *** rindolf left
[13:04] <jnthn> There's RT #88674 done

[13:04] <synbot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=88674

[13:06] <lizmat> an oldie but goodie :-)

[13:08] <ShimmerFairy> .oO(ChangeLog: "\n" now has correct historical baggage    :P)

[13:09] <jnthn> :P

[13:11] <jnthn> Darn, could really use even a cheating nqp::readlinechompfh on JVM...

[13:11] <lizmat> jnthn: is readlinechompfh already a thing ?

[13:11] * jnthn adds one

[13:12] <jnthn> lizmat: On Moar yes

[13:12] <jnthn> lizmat: I pushed a branch that uses it even

[13:12] <jnthn> (Unconditionally)

[13:12] <lizmat> cool, looking forward to eradicating a lot of code 

[13:12] <ShimmerFairy> Though I happen to think Windows got \r\n right, based on my understanding of what the control codes originally meant :)   (and considering they probably didn't have NEL yet)

[13:13] <jnthn> If I do a cheating one on JVM then we can use it on all backends

[13:13] <jnthn> It's no worse than it was before

[13:13] <jnthn> And then I can de-shag IO::Socket::INET.get a bit too

[13:16] *** aneumann joined
[13:17] <jnthn> ooh, lunch! &

[13:19] *** virtualsue joined
[13:20] *** sufrostico joined
[13:31] *** xpen joined
[13:32] <dalek> rakudo/nom: bf00046 | (Steve Mynott)++ | src/core/Exception.pm:

[13:32] <dalek> rakudo/nom: fix typo

[13:32] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/bf00046cf5

[13:32] <dalek> rakudo/nom: 1a60da9 | lizmat++ | src/core/Exception.pm:

[13:32] <dalek> rakudo/nom: Merge pull request #574 from stmuk/nom

[13:32] <dalek> rakudo/nom: 

[13:32] <dalek> rakudo/nom: fix typo

[13:32] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/1a60da970b

[13:32] *** softmoth joined
[13:33] *** pmurias left
[13:34] *** _steve joined
[13:34] *** _steve left
[13:35] *** xpen left
[13:36] *** lab_ joined
[13:36] *** nadim left
[13:36] <abraxxa> jnthn: did you find time to look at my DBDish::Oracle issue?

[13:36] *** softmoth left
[13:37] <lizmat> abraxxa: jnthn is off to lunch atm, but I don't think he has, as he's worked on making \n magical

[13:38] <abraxxa> lizmat: ok, thanks

[13:41] *** pmurias joined
[13:42] *** AlexDaniel left
[13:42] <dalek> rakudo/nom: 85033f7 | lizmat++ | src/core/Str.pm:

[13:42] <dalek> rakudo/nom: Allow Str.split to take more than one needle

[13:42] <dalek> rakudo/nom: 

[13:42] <dalek> rakudo/nom: This should make most of the cases that Text::CSV handles a *lot* faster.

[13:42] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/85033f77ec

[13:42] * |Tux| runs to test …

[13:43] <lizmat> |Tux|: just throw in the delimiters as a list into Str.split

[13:44] <lizmat> don't need to bother to check whether they're Regex or not, it should do the right thing

[13:44] <|Tux|> I first test as-is. see if it chages

[13:44] <|Tux|> can you pate what you mean?

[13:44] <|Tux|> paste

[13:44] *** ecocode joined
[13:44] <lizmat> you're now building a regex

[13:44] *** blooohdy joined
[13:44] <lizmat> tight?

[13:45] <lizmat> right?

[13:45] <|Tux|> yes

[13:45] <lizmat> :-)

[13:45] <|Tux|>             $str.split ($re, :all).map: {

[13:45] <|Tux|>                 if $_ ~~ Str {

[13:45] <|Tux|>                     $_   if .chars;

[13:45] <|Tux|>                     }

[13:45] <|Tux|>                 else {

[13:45] <|Tux|>                     .Str if .Bool;

[13:46] <|Tux|>                     };

[13:46] <|Tux|>                 };

[13:46] <lizmat> the $re should be a list

[13:46] <|Tux|> @re ?

[13:46] <lizmat> yes, that would be best

[13:46] <|Tux|> give it a moment for building

[13:46] <lizmat> and you probably want :keep-indices

[13:46] <lizmat> instead of :all

[13:47] <lizmat> so you get the index of the delimiter that matched for that chunk

[13:48] <lizmat> |Tux| hmmm... seems I haz a bug when migrating from test sub to final method  :-(

[13:49] <lizmat> argh

[13:49] <lizmat> yes

[13:49] *** Actualeyes joined
[13:50] *** xpen joined
[13:51] <JimmyZ> exit

[13:51] <lizmat> |Tux|  lemme first run some checks again  :-(

[13:52] *** blooohdy left
[13:53] *** JimmyZ joined
[13:57] *** aborazmeh left
[14:01] <lizmat> $ 6 'dd "foobarbaz".split(<a o>,:keep-indices)'

[14:01] <lizmat> List $var = $("f", 1, "", 1, "b", 0, "rb", 0, "z")

[14:01] <lizmat> |Tux| ^^^

[14:01] <dalek> rakudo/nom: cdf2521 | lizmat++ | src/core/Str.pm:

[14:01] <dalek> rakudo/nom: Fix some oopsies in Str.split(@needles)

[14:01] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/cdf2521171

[14:03] *** zacts joined
[14:03] <zacts> so I guess is Perl6 officially released now? :-)

[14:03] <JimmyZ> lizmat: there is another multi method split(Str:D \string there

[14:03] <moritz> zacts: it's officially in beta

[14:03] <lizmat> argh, yes, the limit case

[14:04] <zacts> ah, I see. ok

[14:04] <zacts> :-)

[14:04] <zacts> cool

[14:04] <zacts> what are the main things that need to be done for it to be stable and out of beta?

[14:04] *** RabidGravy joined
[14:04] <lizmat> JimmyZ++

[14:04] <zacts> and I've heard like about 6 months ago that optimization of perl6 was kind of slow

[14:05] <zacts> has this improved?

[14:05] *** zengargoylee joined
[14:05] <DrForr> See also: beta :)

[14:05] <zacts> and is there a potential for rakudo to also be able to parse and execute perl5 code one day?

[14:05] <DrForr> zacts: See also: Inline::Perl5.

[14:06] <zacts> oh cool ok

[14:07] <dalek> rakudo/nom: de715e9 | lizmat++ | src/core/Str.pm:

[14:07] <dalek> rakudo/nom: Another oopsie, JimmyZ++ for spotting

[14:07] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/de715e914d

[14:07] <zacts> DrForr: although, is rakudo actually executing the Perl5 code in that case, or is it calling an external Perl5 interpreter?

[14:08] <pmurias> it's calling an external Perl5 interpreter

[14:08] <zacts> ah ok

[14:09] <lizmat> well, embedded Perl5 interpreter would be a better description

[14:09] <zacts> yeah I think I was just curious as to if it would be possible for rakudo to ever parse and execute perl5 code natively in the future

[14:09] <zacts> although,, that still sounds cool

[14:09] <pmurias> there is a partial implementation of that

[14:09] * jnthn back

[14:09] <lizmat> zacts: that's still on the list, but not before Xmas

[14:09] <zacts> ah yeah... I wasn't expecting this by Xmas

[14:09] <zacts> :-P

[14:09] <pmurias> zacts: XS code is also a problem for that

[14:10] <zacts> what is XS?

[14:11] <nine> zacts: Perl 5's interface to native libraries. I basically exposes all the internals of the perl interpreter, which is why nothing else has a chance of being compatible.

[14:11] <zacts> ah ok

[14:12] <zacts> regardless I'm really excited about the betaness now of Perl6, and hopefully soon a full release

[14:13] *** rindolf joined
[14:13] <dalek> nqp: 05d7b20 | jnthn++ | src/vm/jvm/ (2 files):

[14:13] <dalek> nqp: Implement cheating nqp::readlinechompfh on JVM.

[14:13] <dalek> nqp: review: https://github.com/perl6/nqp/commit/05d7b20f41

[14:13] <RabidGravy> but a lot of things that required XS code in Perl 5 probably can be done directly with NativeCall in Perl 6 and no additional C code required

[14:14] <pmurias> RabidGravy: a lot of perl 5 code (in)directly depends on an XS module

[14:14] <abaugher`> I don't find anything SSH on the modules directory or 'modules wanted' pages, which surprises me. Is there a different way to do that now, that I'm not thinking of, or is doing SSH just not as common as I figured?

[14:15] <nine> zacts: we're, too ;)

[14:15] <RabidGravy> yes, but a lot of those are just because there was no way to bind a native library

[14:15] <RabidGravy> directly

[14:15] *** aneumann left
[14:16] <lizmat> abaugher`: actually, I'm not sure, maybe it just needs adding to modules wanted

[14:16] <nine> RabidGravy: it's hard to say, because we have no numbers. There's also a lot of modules that poke around in internals or are just using XS for the performance benefit.

[14:16] <RabidGravy> this is also true

[14:16] <abaugher`> lizmat: thanks, I'll take a look at whether I can handle it first.

[14:18] <RabidGravy> I'm almost tempted to make Linux::SvgaLib for P6 just because I can

[14:18] <lizmat> not SVGALib ?

[14:19] *** abraxxa left
[14:19] <RabidGravy> It was the first XS thing I made for P5 I think

[14:20] <RabidGravy> and no that was almost the capitalisation I used https://metacpan.org/pod/Linux::Svgalib

[14:20] <jnthn> m: say 3.26 / 4.81

[14:20] <camelia> rakudo-moar de715e: OUTPUT«0.677755␤»

[14:21] <andreoss> RabidGravy: consider my pull requests

[14:21] <RabidGravy> andreoss, which pull requests for what?

[14:21] <andreoss> if i assume correcly that perl6format is your stuff

[14:21] <RabidGravy> no, no. Nothing to do with me

[14:22] <RabidGravy> :)

[14:22] <RabidGravy> the party involved goes by the handle "jaffa" here but not seen for ages

[14:23] <RabidGravy> .seen jaffa

[14:23] <yoleaux> I haven't seen jaffa around.

[14:23] <|Tux|> lizmat, dd "foobarbaz".split(<a o>,:keep-indices)' should return $("f","o", "o", "b", "a", "rb", "a", "z")

[14:23] <lizmat> why ?

[14:23] <|Tux|> your split removes all "a"'s and "o"'s

[14:24] <|Tux|> Ahh, now I see! :)

[14:24] <lizmat> yes, and puts 0 or 1 instead

[14:24] <|Tux|> 0 => "a" and 1 => "o"

[14:24] <|Tux|> right!

[14:24] <lizmat> yup

[14:24] * |Tux| has something to play with

[14:24] <|Tux|> I'll come back to that

[14:24] <lizmat> :-)  looking forward to new timings

[14:25] <|Tux|> now debugging a serious SQLite IPF problem

[14:25] <|Tux|> sqlite> create table foo (c_foo integer, foo varchar (4));

[14:25] <|Tux|> sqlite> insert into foo values (-2147483646, "foo");

[14:25] <|Tux|> sqlite> select * from foo;  

[14:25] <|Tux|> 2147483650|foo

[14:26] <RabidGravy> andreoss, strategy in these cases is find the email of the author and ask them to examine the PR, if they don't get back to you in some period of time (depending on your patience,) fork the project apply the patches and release it yourself

[14:26] *** skids joined
[14:26] <lizmat> |Tux|: underflow ?

[14:27] <ilmari> -2**31 => 2**31 + 2 # weird

[14:27] <RabidGravy> I'm quite patient, eventually nearly all the PRs I have sent have got applied (seven months is the longest ;-)

[14:28] *** aasasdd joined
[14:28] <|Tux|> Calc > -2147483646

[14:28] <|Tux|> 01777777777760000000002 / -2147483646 / 0xFFFFFFFF80000002

[14:28] <|Tux|> Calc > 2147483650

[14:28] <|Tux|> 020000000002 / 2147483650 / 0x80000002

[14:28] *** telex left
[14:29] <|Tux|> 64bitint bigendian

[14:29] *** aasasdd left
[14:30] *** telex joined
[14:31] *** xpen left
[14:31] *** xpen joined
[14:31] * flussence wonders when/if sqlite4 will ever see the light of day

[14:32] *** abraxxa joined
[14:35] <dalek> rakudo-star-daily: 20608b2 | coke++ | log/ (8 files):

[14:35] <dalek> rakudo-star-daily: today (automated commit)

[14:35] <dalek> rakudo-star-daily: review: https://github.com/coke/rakudo-star-daily/commit/20608b299c

[14:35] <dalek> perl6-roast-data: ccdd2e2 | coke++ | / (9 files):

[14:35] <dalek> perl6-roast-data: today (automated commit)

[14:35] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/ccdd2e2d22

[14:36] <flussence> hm... reading https://sqlite.org/versionnumbers.html it seems more of an "if" and the answer's "no".

[14:36] <flussence> “one can expect that all future versions of SQLite for the next several decades will begin with "3."”

[14:38] <ilmari> maybe they'll pull a solaris/java and drop the leading digit

[14:39] * ilmari reads the page and realises that's unlikely

[14:43] <RabidGravy> well when they went from 2 -> 3 ten years ago or so, the universe nearly ended

[14:43] <moritz> it did? I didn't notice :-)

[14:43] *** zengargoyle left
[14:43] *** pRiVi_ left
[14:43] <RabidGravy> "nearly"

[14:44] <stmuk> what does a single | do now in a regexp .. I know the || is alternation?

[14:44] *** sprocket joined
[14:44] *** rhr_ left
[14:44] <jnthn> stmuk: Alternation with LTM semantics

[14:44] <RabidGravy> they're both alternation

[14:44] <PerlJam> We need to have a "planned end-of-support date" that either doesn't really end or is future-thinking enough to be on the order of 50 years in the future

[14:44] *** zengargoyle joined
[14:44] <jnthn> m: say 'abc' ~~ /a || ab/

[14:44] *** leedo joined
[14:44] <jnthn> m: say 'abc' ~~ /a | ab/

[14:44] <jnthn> camelia? :)

[14:44] *** ashleydev joined
[14:45] *** krakan joined
[14:45] *** ponbiki joined
[14:45] *** rhr joined
[14:45] *** yqt joined
[14:45] *** salva left
[14:45] *** ponbiki is now known as Guest70635

[14:46] <camelia> rakudo-moar de715e: OUTPUT«｢a｣␤»

[14:46] *** obra left
[14:46] <camelia> rakudo-moar de715e: OUTPUT«｢ab｣␤»

[14:46] *** esh left
[14:46] *** esh joined
[14:46] <iv> do grammars specify the parsing algo, ie. can I assume packrat or something else? 

[14:46] *** obra joined
[14:47] *** Timbus joined
[14:47] *** salva joined
[14:47] <iv> can I hook my own algorithm in there?

[14:47] <stmuk> under Niceville say so "\r\n" ~~ /[";"|"\r\n"]/ returned True and now it's False

[14:47] <stmuk> is this correct or a bug?

[14:47] <stmuk> m: say so "\r\n" ~~ /[";"|"\r\n"]/

[14:47] <camelia> rakudo-moar de715e: OUTPUT«False␤»

[14:47] <stmuk> m: say so "\r\n" ~~ /["\r\n"]/

[14:47] <camelia> rakudo-moar de715e: OUTPUT«True␤»

[14:48] *** pRiVi joined
[14:48] *** charsbar joined
[14:48] <stmuk> m: say so "\r\n" ~~ /[";"||"\r\n"]/

[14:48] <camelia> rakudo-moar de715e: OUTPUT«True␤»

[14:48] <flussence> that's definitely not right...

[14:48] <PerlJam> surely that's a bug.

[14:48] <jnthn> I'd expect that to work

[14:48] <stmuk> this is why LWP::Simple doesn't work

[14:49] <jnthn> m: m: say so "\r\n" ~~ /[";"||\r\n]/

[14:49] <camelia> rakudo-moar de715e: OUTPUT«True␤»

[14:49] <jnthn> m: m: say so "\r\n" ~~ /[";"||"\r\n"]/

[14:49] <camelia> rakudo-moar de715e: OUTPUT«True␤»

[14:49] <jnthn> grmbl

[14:50] <flussence> ...I don't think that's worked for a long time, actually

[14:50] * jnthn wonders if this is the "NFAs don't groks synthetics yet" issue rearing its head

[14:50] <flussence> RT #123452

[14:50] <synbot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=123452

[14:51] *** sprocket left
[14:51] <stmuk> it worked in Niceville

[14:51] *** broquaint joined
[14:51] *** raiph joined
[14:53] <jnthn> stmuk: It shoudl work, but it won't be fixed this week.

[14:53] <RabidGravy> a lot of places like that in various code I've just removed the quotes

[14:53] <jnthn> After dealing with the NFG/IO stuff, I don't hve the energy this week to go hack up the LTM stuff

[14:53] <stmuk> OK I'll RT and suggest || in LWP::Simple

[14:54] <RabidGravy> I actually did a PR that fixed the problem there last night

[14:54] <RabidGravy> or is this a new one?

[14:54] <stmuk> RabidGravy: I couldn't get that fix to work .. maybe things have changed since then

[14:54] <RabidGravy> removed the quotes and made it \r?\n in the chunk parsing code

[14:55] <RabidGravy> it definitely worked for me

[14:55] <RabidGravy> don't be telling me the music has started again on this stuff

[14:55] *** zakharyas left
[14:56] <raiph> stmuk: http://irclog.perlgeek.de/perl6/2015-11-02#i_11466546

[14:58] *** sprocket joined
[14:58] <RabidGravy> BTW anyone who really cares strongly about LWP::Simple may want to copy the chunk parsing code out of H::UA as it's pretty much twice as fast

[14:58] <|Tux|> lizmat, I had to rebuild rakudo. looks like I was too fast

[14:59] <lizmat> ah, yes, a rebuild would be in order  :-)

[14:59] <|Tux|> the split still returns too much for me. Easy to change though

[14:59] <lizmat> |Tux| too much in how ?

[14:59] <stmuk> RabidGravy: ah your workaround does work .. I missed the quote change when I manually patched

[14:59] <|Tux|> if the string *starts* with an entry from @re, the first returned element is ""

[14:59] <stmuk> but I will still RT the changed behaviour since Niceville

[15:00] <lizmat> yes, that's split

[15:00] <|Tux|> hmm

[15:00] <lizmat> there was nothing before it

[15:00] <stmuk> RabidGravy: I wasn't a big fan of the chunk parsing code in LWP::Simple :)

[15:00] <lizmat> so the first element is empty

[15:00] * |Tux| needz :non-empty

[15:00] <lizmat> only at beginning / end ?

[15:00] <stmuk> raiph: I assume it was hit by a bot or something

[15:00] <|Tux|> same for two elements of @re next to eachother

[15:01] <|Tux|> so no, everywhere

[15:01] *** Guest70635 is now known as ponpon

[15:01] <lizmat> and non-empty would put a type object in there, or no element at all?

[15:01] <RabidGravy> stmuk, I fixed up the H::UA code then I think takihurom or someone came and muchly improved it's efficiency

[15:02] <RabidGravy> but it's all in a single method now so someone could basically lift it wholesale and adjust the interface

[15:03] <flussence> oh, "Stage parse" has gotten a tiiiiny bit faster since I last paid attention to it... that's promising.

[15:03] <raiph> stmuk: seems odd none of the other counts went up but fair enough, re the oct 21 spike

[15:04] <|Tux|> "ofrobaardo".split(<a o>, :keep-indices, :non-empty) => $( 1, "fr", 1, "b", 0, 0, "rd", 1 )

[15:04] <|Tux|> maybe :skip-emty would be better

[15:05] <|Tux|> :skip-empty

[15:05] <dalek> rakudo/nom: 64bd8a5 | lizmat++ | src/core/Str.pm:

[15:05] <dalek> rakudo/nom: Don't bother handling the $limit case

[15:05] <dalek> rakudo/nom: 

[15:05] <dalek> rakudo/nom: We need to build the entire structure in memory anyway.

[15:05] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/64bd8a5279

[15:05] <lizmat> yeah

[15:06] <stmuk> https://rt.perl.org/Ticket/Display.html?id=126573

[15:06] <RabidGravy> the "Stage parse" is a good canary for the speed of rakudo, it leapt up because the increase in the size of CORE and then went down as people improved

[15:07] *** ChoHag left
[15:08] <jdv79> CORE went up after GLR?

[15:08] <flussence> was about ~50s pre-GLR, shot up to 90+, is 89 today

[15:09] <dalek> mu: bbd2a94 | PerlJam++ | docs/Perl6/Perl5/Differences.pod:

[15:09] <dalek> mu: [docs] remove implication about the reality of other object systems

[15:09] <dalek> mu: review: https://github.com/perl6/mu/commit/bbd2a942d3

[15:10] <lizmat> $ 6 'dd "ofrobaardo".split(<a o>, :keep-indices, :skip-empty)'

[15:10] <lizmat> List $var = $(1, "fr", 1, "b", 0, 0, "rd", 1, "")

[15:10] <dalek> rakudo/nom: d7a817a | lizmat++ | src/core/Str.pm:

[15:10] <dalek> rakudo/nom: Introduce Str.split :skip-empty

[15:10] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/d7a817a0df

[15:10] <lizmat> |Tux| ^^^

[15:10] <|Tux|> :)

[15:11] <jdv79> that doesn't sound like a good correlation then cause a few bits of code have gotten markedly faster than pre-glr

[15:11] *** sprocket left
[15:12] <|Tux|> m: my @re = "a", "o"; dd "afoobar".split(@re,:keep_indices, :skip-empty)

[15:12] <camelia> rakudo-moar 64bd8a: OUTPUT«List $var = $("", "f", "", "b", "r")␤»

[15:12] <|Tux|> m: my @re = "a", Str, "o"; dd "afoobar".split(@re,:keep_indices, :skip-empty)

[15:12] <camelia> rakudo-moar 64bd8a: OUTPUT«Use of uninitialized value of type Str in string context␤Any of .^name, .perl, .gist, or .say can stringify undefined things, if needed.  in regex  at /home/camelia/rakudo-m-inst-2/share/perl6/runtime/CORE.setting.moarvm:1␤Use of uninitialized value $t…»

[15:12] <|Tux|> OUCH

[15:12] *** sprocket joined
[15:13] <RabidGravy> BOOM! BOOM! SHAKE THE ROOM!

[15:13] <ugexe> keep-indices?

[15:14] * PerlJam hopes someone is updating the docs for these things too

[15:15] *** ChoHag joined
[15:15] *** dhj joined
[15:16] *** dhj left
[15:16] <jnthn> lizmat: What's the difference between :keep-indices and :all?

[15:17] *** pmurias left
[15:17] <raiph> stmuk: ok, theory=bot for the oct 21 spike. any theory about why around half the hits in the last year are 404s?

[15:18] *** pmurias joined
[15:18] <RabidGravy> stale blog entries

[15:18] <lizmat> jnthn: with :all you get the separator strings, with :keep-indices you get the index in the separator list

[15:18] *** ecocode left
[15:18] <lizmat> PerlJam: will do so later tonight, and add tests :-)

[15:19] <stmuk> raiph: there are bots which just send spam sites in referers

[15:19] <lizmat> |Tux| camelia is not up to date yet

[15:19] *** khw joined
[15:19] <|Tux|> try Str in @re

[15:19] *** ChoHag left
[15:20] <lizmat> |Tux| that's DIHWIDT

[15:20] <RabidGravy> que?

[15:20] <|Tux|> does it hurt when I do this?

[15:20] *** ChoHag joined
[15:20] <RabidGravy> :)

[15:20] <dalek> specs: 990d526 | (Anthony Parsons)++ | S99-glossary.pod:

[15:20] <lizmat> doctor, it h...

[15:20] <dalek> specs: Add "XS" to glossary

[15:20] <dalek> specs: review: https://github.com/perl6/specs/commit/990d526065

[15:21] *** xpen left
[15:21] <PerlJam> S99:DIHWIDT

[15:21] <synbot6> Link: http://design.perl6.org/S99.html#DIHWIDT

[15:21] <nine> stmuk: even creepier there are bots which send site in referers that have actually interesting content, no links to any other sites, no virus  and no ads. I don't get why they do that.

[15:21] <jnthn> We don't usually just disregard type objects when a value is expected, as their presence often indicates a mistake

[15:21] *** xpen joined
[15:21] <ugexe> are $*THREAD.id's reused? as in if i start a program and get a $*THREAD.id of 4 and the script runs for awhile will it ever get another $*THREAD.id of 4? 

[15:21] *** softmoth joined
[15:22] *** pmurias left
[15:22] <PerlJam> |Tux|: what would you expect to happen with a Str in @re ?

[15:22] <|Tux|> skip

[15:22] *** xpen_ joined
[15:22] <|Tux|> ignore

[15:22] <RabidGravy> nine, that's to defeat spam checking heuristics that are more clever than "is this referer mine"

[15:22] <PerlJam> okay, then ... what jnthn said :)

[15:22] <lizmat> @r.map: .defined

[15:23] <jnthn> ugexe: Yes, they may be

[15:23] <jnthn> lizmat: .grep, no? :)

[15:23] <lizmat> @r.grep: .defined   # duh

[15:23] <lizmat> yeah

[15:23] <|Tux|> that is what happens with my $rx = qr( "a" | Str | "o" ); "string".split($rx,...)

[15:23] <lizmat> than that is a bug

[15:24] <lizmat> it should at least warn about Str being used in a string context

[15:24] * |Tux| is just playing the canary in the coalmine here

[15:24] <lizmat> m: say "{Str}"  # similar to this

[15:24] <camelia> rakudo-moar 64bd8a: OUTPUT«Use of uninitialized value of type Str in string context␤Any of .^name, .perl, .gist, or .say can stringify undefined things, if needed.  in block <unit> at /tmp/iBSSQr5kDM:1␤␤»

[15:24] *** sprocket left
[15:24] <PerlJam> um ... in a regex, it's not a Str object, it's just the text "Str", no?

[15:24] <|Tux|> that is what it does now: it only slows doen the whole process :P

[15:25] <nine> RabidGravy: sounds like a whole lot of effort for little gain. We haven't even found good referer spam filters, so we developed our own daemon that checks if the refering site actually has a link to our customer's. That's how we discovered those

[15:25] <|Tux|> my Str $a; my Str $b = "a"; my $rx = rx{ $a | $b }

[15:26] <lizmat> m: my @a = Str; dd "Str" ~~ / @a /

[15:26] <camelia> rakudo-moar 64bd8a: OUTPUT«Use of uninitialized value of type Str in string context␤Any of .^name, .perl, .gist, or .say can stringify undefined things, if needed.  in block <unit> at /tmp/0XBqQxCuLD:1␤Use of uninitialized value $topic of type Str in string context␤Any of .^na…»

[15:26] <|Tux|> so yes, Str as object, not as "Str"

[15:26] *** xpen left
[15:26] <lizmat> well apparently it becomes "Str"

[15:26] * |Tux| strats the drumroll ………

[15:26] <lizmat> the line above ends with "Match $var = Match.new(ast => Any, list => (), hash => Map.new(()), orig => "Str", to => 0, from => 0)"

[15:26] <lizmat> dor me

[15:26] *** softmoth left
[15:26] <lizmat> *for me

[15:26] <|Tux|> fail :/

[15:27] * jnthn has a fix for the socket .get issue that has busted Panda

[15:27] <PerlJam> |Tux|: where did you get qr() from btw?  P6 doesn't have that quoter

[15:27] <lizmat> cycling while it's still light &

[15:27] <|Tux|> s/qr/rx/

[15:28] <PerlJam> okay, just checking that there wasn't something else I was missing :)

[15:28] <raiph> stmuk, nine, RabidGravy: thanks, catch y'all later

[15:28] <stmuk> bbfn

[15:28] *** raiph left
[15:28] <RabidGravy> :-*

[15:29] <ugexe> mah artisinally bespoke hand crafted irc client

[15:30] <RabidGravy> as long as it's organic and gluten free

[15:30] <daxim> language design discussion:  https://news.ycombinator.com/item?id=10508935

[15:30] <flussence> .oO( the most effective deterrent I've found to logspam is simply to not listen on port 80. Most of 'em are too dumb to try HTTPS. )

[15:30] <RabidGravy> but you probably need to have a beard and some tweed clothing

[15:32] <|Tux|> somthing *else* also changed, as my reference also got faster

[15:32] <|Tux|> test             50000    33.354    33.245

[15:32] <|Tux|> test-t      ***  40000    20.680    20.572

[15:32] <RabidGravy> I did a talk about ten years ago (at Y::E in Braga) about using the DNSBL to block this kind of crap but I can't find the slides anymore

[15:32] <nine> Wow, that's.....quite some improvement!

[15:32] <nine> |Tux|: I assume it passes the tests?

[15:32] <|Tux|> this means thatr I have some work to do, as 40000 should be 50000

[15:32] <|Tux|> nope

[15:32] <nine> darn

[15:33] <|Tux|> most of the tests, but basics still fail

[15:33] <|Tux|> tests++

[15:33] <|Tux|> should be easy to track

[15:33] <|Tux|> but 20 looks promising

[15:35] <zengargoylee> m: my $a = 2; say join ',', ($a, ++$a)

[15:35] <camelia> rakudo-moar d7a817: OUTPUT«3,3␤»

[15:35] <zengargoylee> m: my $a = 2; say join ',', (+$a, ++$a)

[15:35] <camelia> rakudo-moar d7a817: OUTPUT«2,3␤»

[15:37] <zengargoylee> m: my $a = 2; say join ',', $a, ++$a

[15:37] <camelia> rakudo-moar d7a817: OUTPUT«3,3␤»

[15:37] <zengargoylee> m: my $a = 2; say join ',', +$a, ++$a

[15:37] <camelia> rakudo-moar d7a817: OUTPUT«2,3␤»

[15:38] <PerlJam> zengargoylee: value vs. container

[15:38] <zengargoylee> would never have thunk that except for reading the traps doc.

[15:39] <zengargoylee> which calls that () a Capture

[15:39] *** pmurias joined
[15:41] <PerlJam> heh ... I didn't realize we had a traps doc :)

[15:41] <PerlJam> (whoever started that)++

[15:41] <zengargoylee> which sorta makes that bit of http://doc.perl6.org/language/traps confusing since it appears to have nothing to do with the Capture '()' part.

[15:43] * zengargoylee sorta thought Captures were gone or made something you never really dealt with diretly most of the time.

[15:43] *** andreoss left
[15:45] *** _mg_ left
[15:47] *** pippo joined
[15:48] <|Tux|> .tell lizmat if *not* using :skip-empty, I now get the error Cannot unbox a type object

[15:48] <yoleaux> |Tux|: I'll pass your message to lizmat.

[15:48] <pippo> m: say "a,b,c,d,,e,f,g,,,,h,i".split(',', :skip-empty);

[15:48] <camelia> rakudo-moar d7a817: OUTPUT«(a b c d  e f g    h i)␤»

[15:49] * pippo I wonder what :skip-empty is supposed to do?

[15:49] <|Tux|> say "a,b,c,d,,e,f,g,,,,h,i".split(<,>, :skip-empty)

[15:49] <|Tux|> m: say "a,b,c,d,,e,f,g,,,,h,i".split(<,>, :skip-empty)

[15:49] <camelia> rakudo-moar d7a817: OUTPUT«(a b c d  e f g    h i)␤»

[15:49] <|Tux|> it is supposed to skip the empty elements

[15:49] <|Tux|> what's in a name :)

[15:49] <|Tux|> m: say "a,b,c,d,,e,f,g,,,,h,i".split(<, ,>, :skip-empty)

[15:49] <camelia> rakudo-moar d7a817: OUTPUT«(a b c d e f g h i)␤»

[15:50] <|Tux|> the one-arg-rule played up here

[15:50] <|Tux|> m: say "a,b,c,d,,e,f,g,,,,h,i".split(<, d>, :skip-empty)

[15:50] <camelia> rakudo-moar d7a817: OUTPUT«(a b c e f g h i)␤»

[15:50] <|Tux|> m: say "a,b,c,d,,e,f,g,,,,h,i".split(<, d>, :skip-empty, :keep-indices)

[15:50] <camelia> rakudo-moar d7a817: OUTPUT«(a 0 b 0 c 0 1 0 0 e 0 f 0 g 0 0 0 0 h 0 i)␤»

[15:50] <pippo> |Tux|: why it does not work for my first example?

[15:51] <|Tux|> because it is a single arg

[15:51] * pippo scrathes his head :-))

[15:51] <|Tux|> liz implemented split(@re, …)

[15:52] <|Tux|> if @re has more than one entry, keep-indices returns the index into @re for each matched item split upon

[15:52] <|Tux|> m: say "a,b,c,d,,e,f,g,,,,h,i".split(<, d>, :keep-indices)

[15:52] <camelia> rakudo-moar d7a817: OUTPUT«Cannot unbox a type object␤  in block <unit> at /tmp/cFxawulWik:1␤␤»

[15:52] <pippo> Hah OK. I understand now. It would be nice to also have my first example work.

[15:53] <|Tux|> WIP

[15:53] <PerlJam> What's the use-case for this feature btw?

[15:53] <|Tux|> and that last fail is not intended

[15:53] <|Tux|> PerlJam Text::CSV

[15:53] <pippo> |Tux|: TY.

[15:53] <|Tux|> I explained a few things to Lix last Tuesday and she heard a penny drop

[15:54] <|Tux|> s/Lix/lizmat/

[15:54] <flussence> .oO( this looks vaguely like strtok(3), when you squint at it... )

[15:54] *** g4 left
[15:54] <pippo> |Tux|: Yes me too was lokking for that for parsing CSVs.

[15:54] <pippo> s/lokking/looking/

[15:55] <|Tux|> parsing CSV is way more complicated than splitting on ,

[15:57] * [Coke] chuckles at "< stmuk> it worked in Niceville". :)

[15:57] *** andreoss joined
[15:58] <zengargoylee> doesn't seem to be true: No space allowed around the method call operator.

[15:58] <|Tux|> .tell lizmat :skip-empty leaves the trailing ""

[15:58] <yoleaux> |Tux|: I'll pass your message to lizmat.

[15:59] *** kaare_ left
[15:59] *** kaare_ joined
[15:59] <zengargoylee> m: my $x = [1,2,3]; $x .= reverse; say $x;

[15:59] <camelia> rakudo-moar d7a817: OUTPUT«[3 2 1]␤»

[16:00] <dalek> rakudo/nom: 93e301f | coke++ | docs/release_guide.pod:

[16:00] <dalek> rakudo/nom: Claim another release.

[16:00] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/93e301f5f8

[16:00] <|Tux|> new drumroll …

[16:01] <RabidGravy> I used .() for the first absolutely necessary time today

[16:01] <|Tux|> All tests successful.

[16:01] <|Tux|> Files=25, Tests=19732, 59 wallclock secs ( 2.95 usr  0.16 sys + 206.15 cusr  2.40 csys = 211.66 CPU)

[16:01] <|Tux|> Result: PASS

[16:01] <RabidGravy> [Tux]++ # winning

[16:02] * [Coke] wonders how 59s compares to the early 3x s?

[16:02] <|Tux|> the 59 is not interesting, but this is: :) :)

[16:02] <|Tux|> test             50000    33.379    33.270

[16:02] <|Tux|> test-t           50000    20.784    20.676

[16:02] <|Tux|> WE HAVE A WINNER!

[16:02] <flussence> whoa

[16:03] <[Coke]> lizmat++ |Tux|++

[16:03] <jnthn> Nice!

[16:03] <RabidGravy> everyone++

[16:03] <|Tux|> jnthn, what is the chance lizmat++' work stays? If so, I'll commit and push

[16:04] <jnthn> |Tux|: Given the speedup, pretty high ;) TimToady may have something to say on naming.

[16:04] <psch> hi #perl6 o/

[16:04] <|Tux|> OK, then I will wait for that verdict

[16:04] <psch> the jvm breakage is weird and scary

[16:05] <[Coke]> psch: looks like something broke, something else broke, the first thing was fixed, so the bisect is haaard. figuring out where it's broken now is hard because ENOLINENUMBER.

[16:05] <dalek> nqp: af5c625 | jnthn++ | tools/build/MOAR_REVISION:

[16:05] <dalek> nqp: Bump for Moar fixes with chomping and EOF.

[16:05] <dalek> nqp: review: https://github.com/perl6/nqp/commit/af5c625b04

[16:05] *** bpmedley joined
[16:05] <[Coke]> My next plan was maybe to bisect, but after each git checkout, apply the various "fix the JVM" build patches that have gone in since and see if we can pinpoint when it breaks then.

[16:06] <psch> [Coke]: well, what i can see from inside jdb looks like we encounter a P6int without a HOW while trying to build a P6Opaque

[16:06] <psch> i don't know how we can have a sixmodel type without a HOW

[16:09] *** andreoss left
[16:09] <jnthn> psch: That really  shouldn't happen...

[16:09] *** diana_olhovik_ left
[16:12] *** ely-se left
[16:12] <pippo> "a,d,e,,,f,g,h".split(<, ,>, :keep-indices, :skip-empty)

[16:13] <pippo> m: "a,d,e,,,f,g,h".split(<, ,>, :keep-indices, :skip-empty)

[16:13] <camelia> rakudo-moar 93e301: ( no output )

[16:13] <psch> is there another way to get at the type name than Ops.typeName..?  'cause that also NPEs because the delegate is null...

[16:13] <pippo> m: say "a,d,e,,,f,g,h".split(<, ,>, :keep-indices, :skip-empty)

[16:13] <camelia> rakudo-moar 93e301: OUTPUT«(a 1 d 1 e 1 1 1 f 1 g 1 h)␤»

[16:13] <pippo> |Tux|: ^^Do we want to have the indices for the skipped matches?

[16:14] <pippo> |Tux|: I mean for the empty ones?

[16:14] <hoelzro> o/ #perl6

[16:14] <PerlJam> pippo: I wouldn't.

[16:14] <dalek> rakudo/nom: 9cc7465 | jnthn++ | tools/build/NQP_REVISION:

[16:14] <dalek> rakudo/nom: Get JVM support for readlinechompfh and Moar fix.

[16:14] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/9cc746566e

[16:14] <dalek> rakudo/nom: 13936ab | jnthn++ | src/core/IO/Handle.pm:

[16:14] <dalek> rakudo/nom: Use nqp::readlinechompfh for .get and .lines.

[16:14] <dalek> rakudo/nom: 

[16:14] <dalek> rakudo/nom: Saves us chomping the strings that come from the VM, decreasing the

[16:14] <dalek> rakudo/nom: amount of GC-able objects me make when reading lines.

[16:14] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/13936ab5e0

[16:15] <pippo> PerlJam: me too :-))

[16:15] <nine> lizmat++ # epic speedup!

[16:15] <|Tux|> pippo, no, what should it have? the indices point to the entries in the list to split on

[16:16] <|Tux|> m: say "a,b,c,d,,e,f,g,,,,h,i".split(<, d>, :skip-empty, :keep-indices)

[16:16] <camelia> rakudo-moar 93e301: OUTPUT«(a 0 b 0 c 0 1 0 0 e 0 f 0 g 0 0 0 0 h 0 i)␤»

[16:16] <jnthn> m: say 3.42 / 4.81

[16:16] <camelia> rakudo-moar 93e301: OUTPUT«0.711019␤»

[16:16] <|Tux|> every 0 in there is a ",", and every 1 is a "d"

[16:16] <|Tux|> empty elements have no index

[16:16] <jnthn> On performance, `for 'foo'.IO.lines { }` just got ~30% cheaper with 13936ab

[16:17] <pippo> m: say "a,d,e,,,f,g,h".split(<, ,>, :keep-indices, :skip-empty)

[16:17] <camelia> rakudo-moar 93e301: OUTPUT«(a 1 d 1 e 1 1 1 f 1 g 1 h)␤»

[16:17] *** xpen_ left
[16:17] <dalek> rakudo/nom: 2e3da75 | jnthn++ | src/core/IO/Socket/INET.pm:

[16:17] <dalek> rakudo/nom: Fixes/improvements to IO::Socket::INET.get.

[16:17] <dalek> rakudo/nom: 

[16:17] <dalek> rakudo/nom: * Bring API in line with IO::Handle, using nl-in for the input

[16:17] <dalek> rakudo/nom:   separator and allowing multiple separators

[16:17] <dalek> rakudo/nom: * Make default separators CR and CRLF, like other handles (this fixes

[16:17] <dalek> rakudo/nom:   the recent Panda regression)

[16:17] <dalek> rakudo/nom: * Use VM-backed chomped line reading, and remove custom logic for it.

[16:17] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/2e3da7534f

[16:17] <dalek> roast: c5cfb6a | jnthn++ | S32-io/IO-Socket-INET.pl:

[16:17] <dalek> roast: Default separator for socket includes \r\n.

[16:17] <dalek> roast: 

[16:17] <dalek> roast: Covers RT #126553.

[16:17] <dalek> roast: review: https://github.com/perl6/roast/commit/c5cfb6aa38

[16:17] <synbot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=126553

[16:17] <pippo> |Tux|: You see there the consecutive 1 without letters? They should not appear I think.

[16:18] <PerlJam> I guess the implementation of :keep-indices always takes the last one that matches?

[16:18] <|Tux|> probably, that is an implementation detail

[16:19] <PerlJam> it might be an important one if the items you're splitting over can partially match each other

[16:19] <|Tux|> I think that as you specify keep-idices, you should either get 0 0 0 0 OR 1 1 1 1

[16:19] <jnthn> RabidGravy: 2e3da75 should mean the Panda workaround can go away

[16:20] <|Tux|> but that is the purpose of the keep-indices: return a match for what was split upon

[16:20] <|Tux|> PerlJam, that is covered by my tests :)

[16:20] <|Tux|> at least I think it does

[16:21] <|Tux|> m: say "a,b,c,d,,e,f,g,,,,h,i".split(<,, ,>, :skip-empty, :keep-indices)

[16:21] <camelia> rakudo-moar 93e301: OUTPUT«(a 1 b 1 c 1 d 0 e 1 f 1 g 0 0 h 1 i)␤»

[16:21] <|Tux|> :)

[16:22] <dalek> roast: 9d9cf0b | jnthn++ | S32-io/io-handle.t:

[16:22] <dalek> roast: Correct wrong test that hid a Rakudo bug.

[16:22] <dalek> roast: 

[16:22] <dalek> roast: We're meant to chomp separators by default, but previously only did

[16:22] <dalek> roast: chomp \r\n and \n. Now that's fixed in Rakudo, and this wrong test

[16:22] <dalek> roast: came to light.

[16:22] <dalek> roast: review: https://github.com/perl6/roast/commit/9d9cf0baf6

[16:22] <dalek> roast: 98054a2 | jnthn++ | S32-io/IO-Socket-INET.pl:

[16:22] <dalek> roast: Avoid using deprecated method.

[16:22] <dalek> roast: review: https://github.com/perl6/roast/commit/98054a20d8

[16:22] <pippo> Everything OK except "g 0 0 h" that second zero is the index of an empy match.

[16:23] <|Tux|> no, it is two double-comma matches

[16:23] <|Tux|> g ,, ,, h

[16:23] <flussence> «Stage parse      :  87.437» - dropped another 2 seconds since earlier today

[16:23] <|Tux|> m: say "a,b,c,d,,e,f,g,,,,h,i".split(<,,, ,, ,>, :skip-empty, :keep-indices)

[16:23] <camelia> rakudo-moar 93e301: OUTPUT«(a 2 b 2 c 2 d 1 e 2 f 2 g 0 2 h 2 i)␤»

[16:24] <|Tux|> that one is weird. I'd expect 2 0 not 0 2

[16:24] <|Tux|> but an edge case

[16:25] <pippo> |Tux|: Ha. Sorry did not notice you cahnged the <…> part.

[16:26] <jnthn> |Tux|: Could you see if https://rt.perl.org/Ticket/Display.html?id=123888 is now fixed for you?

[16:26] <jnthn> |Tux|: Note that it's call nl-in now

[16:26] <jnthn> *called

[16:26] <|Tux|> 123888 is already fixed

[16:27] <jnthn> OK, cool

[16:27] <|Tux|> one thing still bothers me though

[16:27] <jnthn> Oh?

[16:27] <|Tux|> m: $*IN.nl-in = "";

[16:27] <camelia> rakudo-moar 93e301: ( no output )

[16:27] <|Tux|> m: $*IN.nl-in = Str;

[16:27] <camelia> rakudo-moar 93e301: OUTPUT«Use of uninitialized value $ending of type Str in string context␤Any of .^name, .perl, .gist, or .say can stringify undefined things, if needed.  in block <unit> at /tmp/CgkttKaqIO:1␤»

[16:27] <|Tux|> Yuck!

[16:27] <jnthn> $*IN.nl-in = [] # no separators

[16:27] <|Tux|> m: $*IN.nl-in = [];

[16:27] <camelia> rakudo-moar 93e301: ( no output )

[16:28] <jnthn> But yeah, maybe it's reasonable to be able to set it to a type object to have another way to say "no separator"

[16:28] <|Tux|> that must be a :D signature :)

[16:28] <jnthn> Especially given the "undef $/" meme will probably lead people to try such things

[16:29] <|Tux|> https://github.com/Tux/CSV/commit/42b177ee643430992cc0354835a4edf4a4cc0f30 <= that was the .in => .in-nl commit

[16:29] <PerlJam> m: say "a,b,c,d,,e,f,g,,,,,,,,h,i".split(<,,, ,, ,>, :skip-empty, :keep-indices)

[16:29] <camelia> rakudo-moar 93e301: OUTPUT«(a 2 b 2 c 2 d 1 e 2 f 2 g 0 0 1 h 2 i)␤»

[16:29] <PerlJam> m: say "a,b,c,d,,e,f,g,,,,,,,,h,i".split(<,, ,,, ,>, :skip-empty, :keep-indices)

[16:29] <camelia> rakudo-moar 93e301: OUTPUT«(a 2 b 2 c 2 d 0 e 2 f 2 g 1 1 0 h 2 i)␤»

[16:29] <|Tux|> nl-in

[16:30] <dakkar> I was looking at the way libxml2 builds and frees its trees. each node has a pointer to the parent, a pointer to the first child, and a pointer to the next sibling

[16:30] <PerlJam> huh, it doesn't take the "last" one, it takes the longest one

[16:30] <dakkar> which means that the whole tree is full of reference loops

[16:30] *** kmel joined
[16:30] *** isBEKaml joined
[16:30] <|Tux|> longest one is in0line with how regexes work

[16:30] <dakkar> xmlFreeNode releases the memory for a node, and *all its children*

[16:30] <PerlJam> yep

[16:30] <|Tux|> I just expect them to match left-to-right, not right-to-left

[16:31] <|Tux|> test             50000    33.462    33.353

[16:31] <|Tux|> test-t           50000    20.900    20.791

[16:31] <stmuk> should an ecosystem module die or fail on error? probably the latter?

[16:31] <|Tux|> (after jnthn++ IO patch)

[16:31] <dakkar> how badly is it going to interfere with the garbage collector, if I just wrap each pointer in a repr<CStruct> ?

[16:31] <pippo> m: $*ERR.nl-out = [];

[16:31] <camelia> rakudo-moar 93e301: OUTPUT«Type check failed in assignment to $!nl-out; expected Str:D but got Array␤  in block <unit> at /tmp/3fR7ec85jx:1␤␤»

[16:31] <PerlJam> anyway ... as long as it's documented well and we can agree on the semantica 

[16:31] <|Tux|> not a real difference for me

[16:31] <PerlJam> er, semantics

[16:31] <dakkar> also, how am I ever going to test memory leaks / double free / garbage in structs ??

[16:35] *** ChoHag left
[16:36] *** ChoHag joined
[16:36] <dalek> roast: e108d9d | jnthn++ | S32-io/IO-Socket-INET. (2 files):

[16:36] <dalek> roast: Test to cover RT #109306.

[16:36] <dalek> roast: review: https://github.com/perl6/roast/commit/e108d9d860

[16:36] <synbot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=109306

[16:40] *** dwarring joined
[16:41] <flussence> m: my @l = «foo bar '' baz»; for @l { .say when '' ff * }

[16:41] <camelia> rakudo-moar 2e3da7: OUTPUT«Cannot convert string to number: base-10 number must begin with valid digits or '.' in '7⏏5baz' (indicated by 7⏏)␤  in block <unit> at /tmp/4hYgv8AJuz:1␤␤Actually thrown at:␤  in block <unit> at /tmp/4hYgv8AJuz:1␤␤»

[16:42] <flussence> that doesn't look sane, but I'm never sure what I'm doing when it comes to «ff»

[16:42] <dalek> roast: dd6a85f | jnthn++ | S16-filehandles/argfiles.t:

[16:42] <dalek> roast: Test to cover RT #123888.

[16:42] <dalek> roast: review: https://github.com/perl6/roast/commit/dd6a85f1e6

[16:42] <synbot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=123888

[16:44] <flussence> star-m: my @l = «foo bar '' baz»; for @l { .say when '' ff * }

[16:44] <camelia> star-m 2015.09: OUTPUT«Cannot convert string to number: base-10 number must begin with valid digits or '.' in '7⏏5baz' (indicated by 7⏏)␤  in block <unit> at /tmp/l7duRkvAAE:1␤␤Actually thrown at:␤  in block <unit> at /tmp/l7duRkvAAE:1␤␤»

[16:44] <flussence> j: my @l = «foo bar '' baz»; for @l { .say when '' ff * }

[16:44] <camelia> rakudo-jvm 273e89: ( no output )

[16:45] <flussence> p: my @l = «foo bar '' baz»; for @l { .say when '' ff * } # long shot...

[16:45] <flussence> thought not :)

[16:47] *** mr_ron joined
[16:47] <RabidGravy> jnthn, the cool thing about that change is that it *doesn't have to* come out even when the reason it went in goes away

[16:49] <jnthn> RabidGravy: Aye, though I'd be happy to know if it's no longer needed, e.g. I really did fix the regression that hit it :)

[16:50] <RabidGravy> let me check

[16:50] <mr_ron> In an IETF spec for http chunked transfer CRLF is specified as a terminating marker http://tools.ietf.org/html/rfc7230#section-4.1

[16:50] <dalek> rakudo/curli: cc06108 | (Stefan Seifert)++ | src/ (6 files):

[16:50] <dalek> rakudo/curli: Lift GLOBALish merging code out of CompUnit

[16:50] <dalek> rakudo/curli: 

[16:50] <dalek> rakudo/curli: Moved the Perl 6 code to Stash::merge-symbols and the call site to

[16:50] <dalek> rakudo/curli: CompUnitRepo::load_module so we no longer need to pass around GLOBALish.

[16:50] <dalek> rakudo/curli: Just loading a CompUnit should no longer influence the environment.

[16:50] <dalek> rakudo/curli: That's up to the user.

[16:50] <dalek> rakudo/curli: review: https://github.com/rakudo/rakudo/commit/cc061085ae

[16:50] <nine> Of course jnthn++ has already foreseen this. Powerful the force is in him...

[16:51] *** CommonSense joined
[16:51] <jnthn> :)

[16:51] <mr_ron> The rash of \r?\n patches look like bypasses to me.  A more likely fix might be 'use newline :lf'.  still looking ...

[16:51] *** perlawhirl_ joined
[16:51] <RabidGravy> jnthn, do I need to manually bump moar is that all in the rakudo now

[16:52] <jnthn> RabidGravy: I think I did all the necesary bumps

[16:52] *** lab__ joined
[16:52] <dalek> specs: aa5522b | jnthn++ | S29-functions.pod:

[16:52] <dalek> specs: Update run/shell design to match reality.

[16:52] <dalek> specs: review: https://github.com/perl6/specs/commit/aa5522b92b

[16:52] *** hoelzro_ joined
[16:52] *** skids1 joined
[16:52] *** Actualeyes1 joined
[16:52] <RabidGravy> mr_ron, probably but better having working stuff

[16:52] *** virtualsue left
[16:52] *** JimmyZ_ joined
[16:52] *** inokenty1 joined
[16:53] *** lue joined
[16:53] *** sprocket joined
[16:53] *** advwp left
[16:53] *** apejens_ joined
[16:54] *** perlpilot joined
[16:54] *** KotH_ joined
[16:54] *** arnsholt_ joined
[16:54] *** b^_^d joined
[16:54] *** sunnavy_ joined
[16:54] *** zengargo1le joined
[16:54] *** ilbelkyr_ joined
[16:54] <mr_ron> RabidGravy thanks for looking at my comments and thank you for patching things so they work.  Just want them fixed right eventually.

[16:54] *** CommonSense left
[16:55] *** Gothmog_1 joined
[16:55] <RabidGravy> but it;s also in the way that "\r\n" differs from \r\n now as far as I understand it

[16:55] <mr_ron> I didn't understand that last comment ...

[16:55] <RabidGravy> right

[16:56] *** _sri_ joined
[16:56] <RabidGravy> I look forward to seeing the correct fixes

[16:56] <mr_ron> thx

[16:57] *** stmuk_ joined
[16:57] <psch> m: say so "\n" ~~ /\r\n/; say so "\n" ~~ /"\r\n"/

[16:57] <camelia> rakudo-moar 2e3da7: OUTPUT«False␤False␤»

[16:57] *** rvchangue_ joined
[16:58] *** eviltwin_b joined
[16:58] *** xfix joined
[16:59] *** bartolin_ joined
[16:59] <RabidGravy> who knows, somethings have to be fixed to work rather than be right

[17:00] * psch didn't really pay attention to those changes... vOv

[17:00] *** arnsholt_ left
[17:00] *** Oatmeal left
[17:00] *** robins joined
[17:00] <stmuk_> spekul cases all the things!

[17:00] <stmuk_> :)

[17:01] *** Fleurety_ joined
[17:01] <RabidGravy> :)

[17:01] *** dgl joined
[17:02] *** mattn_jp joined
[17:04] *** lsm-desktop_ joined
[17:04] <dalek> roast: 55d2cae | jnthn++ | S29-os/system.t:

[17:04] <dalek> roast: Flesh out tests for run/shell a bit.

[17:04] <dalek> roast: 

[17:04] <dalek> roast: We had not tests that checked the return type of run and shell at all.

[17:04] <dalek> roast: This codifies that they return Proc and along the way covers the final

[17:04] <dalek> roast: design that RT #117039 was complaining about.

[17:04] <dalek> roast: review: https://github.com/perl6/roast/commit/55d2cae203

[17:04] <synbot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=117039

[17:04] *** zengargoyle left
[17:04] *** skids left
[17:04] *** JimmyZ left
[17:04] *** Actualeyes left
[17:04] *** lab_ left
[17:04] *** ShimmerFairy left
[17:04] *** lsm-desktop left
[17:04] *** olinkl left
[17:04] *** mattn_jp_ left
[17:04] *** perlawhirl left
[17:04] *** stmuk left
[17:04] *** hoelzro left
[17:04] *** d^_^b left
[17:04] *** robinsmidsrod left
[17:04] *** sunnavy left
[17:04] *** geekosaur left
[17:04] *** dg left
[17:04] *** Gothmog_1 is now known as Gothmog_

[17:04] *** JimmyZ_ is now known as JimmyZ

[17:04] *** rvchangue_ is now known as rvchangue

[17:05] *** perlawhirl_ is now known as perlawhirl

[17:05] *** eviltwin_b is now known as geekosaur

[17:05] *** pmurias left
[17:06] <jnthn> .ask TimToady Should a Proc object in sink context, for a failed process, perhaps die? So a plain run('foo-that-fails') would die rather than silent failure? (Note: run and shell both return Proc.)

[17:06] <yoleaux> jnthn: I'll pass your message to TimToady.

[17:06] *** llfourn joined
[17:07] *** arnsholt_ joined
[17:09] *** advwp joined
[17:10] *** abraxxa left
[17:10] *** olinkl joined
[17:10] *** softmoth joined
[17:12] <RabidGravy> jnthn, in short the get is no longer getting all the stuff, in long I think the way that panda does that is more broken than that problem

[17:12] <dalek> Heuristic branch merge: pushed 34 commits to rakudo/curli by niner

[17:12] *** Oatmeal joined
[17:14] *** domidumont left
[17:14] *** Fleurety_ is now known as Fleurety

[17:14] *** softmoth left
[17:15] <jnthn> RabidGravy: OK, that's good enough for me :) Thanks!

[17:15] <TimToady> wow, what a question

[17:15] <yoleaux> 17:06Z <jnthn> TimToady: Should a Proc object in sink context, for a failed process, perhaps die? So a plain run('foo-that-fails') would die rather than silent failure? (Note: run and shell both return Proc.)

[17:17] <jnthn> I guess I should asked "or did you really want a Failure in that case, and it's an interesting enough Failure that we can get the exit code"...

[17:17] <jnthn> But then it becomes $proc.exception.exitcode or so I guess...

[17:18] <jnthn> (Where $proc ain't actually a proc at all in this case...)

[17:18] <jnthn> But worse, you couldn't read from stderr if you didn't get the proc back

[17:18] <jnthn> So I think it has to be a Proc, so guess my question stands :)

[17:19] <RabidGravy> jnthn, the problem with (what panda is doing) is that some variant of "while  ... $socket.get" will stop at the empty line at the end of the header

[17:19] <TimToady> certainly Unix shell culture says to ignore such errors unless tested for, and people use it all the time to do guanrantee the result of an idempotent operation; otoh treating the system as an extension of the language says we don't want to lose failures

[17:19] <moritz> and bash has set -e

[17:20] <jnthn> RabidGravy: Does it intend to stop at the end of the header? :)

[17:20] <flussence> RabidGravy: $socket.lines works sanely now, you might want to use that instead

[17:21] <TimToady> so I think I'm okay with throwing failure in sink context, as long as we can manage the time travel

[17:21] <RabidGravy> jnthn, no, flussence, yes

[17:21] <jnthn> TimToady: What time travel are you thinking about? :)

[17:22] <TimToady> I guess these are sync, so not a problem

[17:22] <jnthn> I mean, I was just going to put a sink method on Proc that throws a typed exception containing the Proc...

[17:22] <jnthn> Yes, sync

[17:22] <TimToady> you shouldn't ask me to sync this early in the morning

[17:22] <moritz> well, if you do some piping options, the program hasn't exited yet, right?

[17:23] <jnthn> .oO( This is the German coastguard. What are you syncing about? )

[17:23] <moritz> but it's pretty useless to set up a pipe in sink context

[17:24] <dalek> roast: 2180af7 | (Ronald Schmidt)++ | S16-io/newline.t:

[17:24] <dalek> roast: expand S16-io/newline.t tests to include Buf decoding

[17:24] <dalek> roast: review: https://github.com/perl6/roast/commit/2180af7474

[17:24] <dalek> roast: 3378706 | (Zoffix Znet)++ | S16-io/newline.t:

[17:24] <dalek> roast: Merge pull request #75 from ronaldxs/master

[17:24] <dalek> roast: 

[17:24] <dalek> roast: expand S16-io/newline.t tests to include Buf decoding

[17:24] <dalek> roast: review: https://github.com/perl6/roast/commit/3378706b71

[17:24] * TimToady now imagines a lot of programs with 'so run ...' commands

[17:24] <dalek> rakudo/curli: 78c7c56 | (Stefan Seifert)++ | src/core/CompUnit/Repository/ (2 files):

[17:24] <dalek> rakudo/curli: Promote $precomp to a positional argument again

[17:24] <dalek> rakudo/curli: 

[17:24] <dalek> rakudo/curli: CompUnit::Repository requires $precomp to be positional.

[17:24] <dalek> rakudo/curli: These have only been nameds while we needed to pass GLOBALish, too.

[17:24] <dalek> rakudo/curli: review: https://github.com/rakudo/rakudo/commit/78c7c569b4

[17:25] <flussence> I've noticed adding :nl-in<\r\n> causes that panda HTTP request to hang indefinitely, leaving it out works fine. Not sure if I'm using it right or not.

[17:26] <RabidGravy> flussence, yep lines works

[17:26] <jnthn> m: say <\r\n>.perl

[17:26] <camelia> rakudo-moar 2e3da7: OUTPUT«"\\r\\n"␤»

[17:26] <jnthn> flussence: <...> quoters don't interpolate backslashy things

[17:26] <flussence> okay, I'm dumb :)

[17:26] *** dgl is now known as dg

[17:27] <ilmari> m: «\r\n».perl.say

[17:27] <camelia> rakudo-moar 2e3da7: OUTPUT«()␤»

[17:27] <ilmari> whereas in «» it gets discarded as whitespace separator

[17:28] <jnthn> :nl-in("\r\n") :P

[17:28] <ilmari> yeah

[17:28] <jnthn> Or <<"\r\n">>

[17:28] * |Tux| can not resist to point TimToady to http://tux.nl/Talks/CSV6/speed4.html

[17:29] * ilmari hopes the y axis is time, not rate

[17:30] <|Tux|> correct. time in seconds

[17:30] <ilmari> label your axes, damnit

[17:30] <ilmari> or a dwarf might mistake it for theirs

[17:30] <|Tux|> but then there is no use in explaining them in a talk :)

[17:30] <ilmari> s/it/them/

[17:31] * |Tux| dives into the documentation if the module used to check for labels ...

[17:31] <jnthn> moritz: Seems that when you specify :in then the exit code isn't set until you close .in

[17:32] <jnthn> Well, you gotta close all the handles you take, it seems

[17:33] <stmuk_> I'm seeing problems with "panda update"

[17:34] <|Tux|> ilmari, better?

[17:35] <flussence> jnthn: I think that's a side effect at the OS level. IIRC daemontools' `fghack` makes use of that weirdness too.

[17:35] <stmuk_> I don't think its getting the body of the json response

[17:35] <|Tux|> stmuk_, does $ wget http://ecosystem-api.p6c.org/projects.json -O .../rakudobrew/moar-nom/install/share/perl6/site/panda/projects.json

[17:35] <ilmari> |Tux|: yes, except the first one

[17:35] <|Tux|> help you out?

[17:36] <stmuk_> probably :)

[17:36] <|Tux|> ilmari, fixed

[17:37] *** gnomad joined
[17:37] <ilmari> |Tux|++ # labeling his axes

[17:39] <RabidGravy> stmuk_, ye

[17:39] <RabidGravy> yes

[17:40] <RabidGravy> jnthn has fixed the behavior of  ".get", thus exposing the shortcomings of the very, very dumb HTTP client in Panda::Ecosystem

[17:42] *** espadrine left
[17:43] <ugexe> how can i tell if the thread im in is actually the same as a previous thread? moarvm compares the handles but i'm not sure how to do it in perl6

[17:43] *** KotH_ is now known as Koth

[17:43] *** lichtkind joined
[17:43] <stmuk_> oh I see 1719

[17:45] <flussence> m: say $*THREAD; await Promise.allof(start { say $*THREAD; sleep 1 }, start { sleep 1; say $*THREAD });

[17:45] <camelia> rakudo-moar 2e3da7: OUTPUT«Thread.new(app_lifetime => Bool::False, name => "Initial thread")␤Thread.new(app_lifetime => Bool::True, name => "<anon>")␤Thread.new(app_lifetime => Bool::True, name => "<anon>")␤»

[17:45] *** isBEKaml left
[17:45] <flussence> there's a "name" thing there, dunno how to set it off the top of my head though.

[17:45] <ugexe> the name can get reused, as can the id

[17:46] <jnthn> ugexe: The $*THREAD object's identity will be unique

[17:47] <ugexe> aha ok

[17:48] <dalek> roast: a0da155 | jnthn++ | S29-os/system.t:

[17:48] <dalek> roast: Test run with something portable.

[17:48] <dalek> roast: 

[17:48] <dalek> roast: `true` won't work out on Windows.

[17:48] <dalek> roast: review: https://github.com/perl6/roast/commit/a0da155059

[17:49] <RabidGravy> stmuk_, can you confirm that panda is truly broken before I push this change, it's dumber than a dumb thing but will work

[17:49] <|Tux|> today we passed the point that Text::CSV is more than 12.5 times faster than in oktober 2014

[17:50] * |Tux| goes home

[17:50] *** pippo left
[17:50] <RabidGravy> |Tux|++

[17:50] <RabidGravy> or can someone else confirm that to mee

[17:51] <RabidGravy> I think the proper answer here is to make a proper HTTP::Tiny and bundle it with panda

[17:51] <RabidGravy> but I've got it fixed

[17:52] *** domidumont joined
[17:53] <dalek> roast: 311f8cb | jnthn++ | S02-magicals/env.t:

[17:53] <dalek> roast: Fix test that passed for the wrong reason on Win.

[17:53] <dalek> roast: review: https://github.com/perl6/roast/commit/311f8cb7cf

[17:53] <ugexe> i'd say the proper answer is to pull in the project list via git since everything else already requires git to be pulled in

[17:55] <jdv79> git all the things?

[17:55] <ugexe> git git git it

[17:57] *** mr_ron left
[18:00] <dalek> rakudo/nom: 289fdc5 | jnthn++ | src/core/ (2 files):

[18:00] <dalek> rakudo/nom: Sinking an unsuccessful Proc should throw.

[18:00] <dalek> rakudo/nom: 

[18:00] <dalek> rakudo/nom: This means `run` anad `shell` in sink context will not fail silently

[18:00] <dalek> rakudo/nom: if they are not successful.

[18:00] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/289fdc5238

[18:00] <dalek> roast: 377eb35 | jnthn++ | S29-os/system.t:

[18:00] <dalek> roast: Test run/shell in sink context throw on failure.

[18:00] <dalek> roast: 

[18:00] <dalek> roast: Covers RT #117039.

[18:00] <dalek> roast: review: https://github.com/perl6/roast/commit/377eb35314

[18:00] <synbot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=117039

[18:01] <dalek> specs: 3b936eb | jnthn++ | S29-functions.pod:

[18:01] <dalek> specs: Mention sink behavior of Proc.

[18:01] <dalek> specs: review: https://github.com/perl6/specs/commit/3b936eb530

[18:02] <stmuk_> RabidGravy: push all the things

[18:02] *** espadrine joined
[18:02] *** cfloare joined
[18:05] *** Axord joined
[18:05] <jnthn> Another xmas RT down :)

[18:06] <colomon> \o/

[18:06] <jnthn> Enough for today :)

[18:07] <stmuk_> jnthn++

[18:07] *** xpen joined
[18:07] *** dakkar left
[18:09] *** sufrostico left
[18:09] * stmuk_ wonders if RabidGravy's fix involves $g ~~ /^'['/ :)

[18:10] *** robins is now known as robinsmidsrod

[18:10] <RabidGravy> no regex involved whatsoever

[18:11] <jdv79> RabidGravy: you are near london?

[18:11] <RabidGravy> well in "greater london" yes

[18:11] * stmuk_ is in zone 2

[18:12] <RabidGravy> I think I'm in zone 4

[18:12] *** xpen left
[18:12] <jdv79> i will likely be there shortly.  looking for craft beer bars.  any of note?

[18:12] * TimToady is zoned out

[18:12] *** espadrine left
[18:12] <RabidGravy> anyone got commit on panda? tadzik, moritz, timotimo anyone?

[18:13] <stmuk_> https://thecraftbeerco.com/

[18:14] *** firstdayonthejob joined
[18:14] <RabidGravy> jdv79, Greenwich Old brewery http://www.oldbrewerygreenwich.com/

[18:14] <RabidGravy> frankly too many to mention

[18:14] <jdv79> nice.

[18:15] <RabidGravy> Greenwich has several microbreweries

[18:15] <RabidGravy> the Union bar, zero bar etc

[18:15] <jdv79> i know i could rattle off the best dozen or so in nyc.  maybe london is crazier.

[18:16] <jnthn> jdv79: If you like BrewDog's stuff, they have a bar in Camden. Have had good guest ones one when I've been there too (sadly, only occasionally)

[18:16] * TimToady wonders if :keep-indices should just be :k, and :all should just be :v

[18:16] <RabidGravy> couple of brewdog places

[18:16] <jnthn> Oh, there's more than one in London?

[18:16] * jnthn only knew about the Camden one

[18:16] <RabidGravy> one in shoreditch too

[18:16] <jdv79> i was just at their bar alot in edinburgh.  brewdog that is.

[18:16] <stmuk_> I believe there is a new one opening tomorrow in Soho

[18:16] * jnthn has no idea where shoreditch is :)

[18:16] <RabidGravy> one in brighton now as well

[18:17] <jdv79> but may check it out anyways

[18:17] <stmuk_> http://jollybutchers.co.uk/ is about 300 yards away from me :)

[18:17] <RabidGravy> jnthn, carry on bishopsgate beyond the "city" and turn right

[18:18] *** _mg_ joined
[18:19] <jnthn> ah

[18:19] <RabidGravy> sort of north of brick lane I guess

[18:19] <jnthn> :)

[18:20] <stmuk_> just follow the beards

[18:20] * jnthn never lived in London, just visited it a bunch

[18:20] <RabidGravy> :)

[18:20] <psch> so apparently the STable at index 7 in CORE.setting is what's broken

[18:20] <psch> my attempts at figuring out which one that is over the last hour or so prove fruitless

[18:20] * jnthn goes to tend to tonight's curry

[18:21] *** lab__ left
[18:21] <RabidGravy> anyone in the house who has a comit on panda?

[18:22] <RabidGravy> don't want a third day of this

[18:23] <perlpilot> maybe panda should be brought under the perl6 org

[18:23] *** perlpilot is now known as PerlJam

[18:24] *** leont joined
[18:25] <nine> RabidGravy: I think I do

[18:26] <RabidGravy> be a love and merge the PR, 'cause with the latest rakudo it's borked

[18:27] <nine> RabidGravy: done

[18:27] *** Actualeyes1 left
[18:27] <RabidGravy> :-*

[18:29] <RabidGravy> it's completely poxy but works for me

[18:31] <RabidGravy> (I'd rather have a bit of shit code that works than a squillion people pictching up complaining about it not working)

[18:33] *** FROGGS joined
[18:34] *** yqt left
[18:34] *** zakharyas joined
[18:35] <nine> .tell jnthn fun starts when people do use Test; use lib 't/spec/packages'; use Test::Util; because then we load a precomped Test from one repo and a precomped Test::Util from another and the latter is based on a different precomp version of Test.

[18:35] <yoleaux> nine: I'll pass your message to jnthn.

[18:46] *** arnsholt_ left
[18:46] *** pink_mist left
[18:46] *** arnsholt joined
[18:46] *** pink_mist joined
[18:49] *** cognominal left
[18:49] *** cognominal joined
[18:55] *** stmuk_ is now known as stmuk

[18:59] *** softmoth joined
[19:00] *** n0tjack joined
[19:03] *** softmoth left
[19:04] <[Coke]> POD on SO: https://stackoverflow.com/questions/33531838/always-show-subs-methods-in-doc

[19:04] <lizmat> .botsnack

[19:04] <yoleaux> :D

[19:04] <synbot6> om nom nom

[19:04] <yoleaux> 15:48Z <|Tux|> lizmat: if *not* using :skip-empty, I now get the error Cannot unbox a type object

[19:04] <yoleaux> 15:58Z <|Tux|> lizmat: :skip-empty leaves the trailing ""

[19:06] <n0tjack> if I weren't fundamentally lazy, I'd make a bot that posted all [perl6] SO questions here.

[19:07] <lizmat> n0tjack: it's not a prerequisite  :-)

[19:07] <n0tjack> well, more accurately: if programming tasks were sometimes as easy as they seemed, I'd make a bot...

[19:09] *** _mg__ joined
[19:09] <psch> it should be failry easy with Syndication and Net::IRC::Bot, depending on how SO/SE do their bot auth...

[19:09] <psch> also the former might still have GLR fallout, last update was 28th of august

[19:10] <psch> but yes, the same caveat applies

[19:10] *** _mg_ left
[19:10] *** _mg__ is now known as _mg_

[19:11] <psch> part of the jvm breakage comes from 5349d05c, fwiw

[19:11] <psch> reverting that is still broken, though, with an SOE

[19:12] <nine> lizmat: any thoughts on use Test; use lib 't/spec/packages'; use Test::Util; which will load a precomped Test from one repo and a precomped Test::Util from another and the latter is based on a different precomp version of Test.

[19:13] <lizmat> nine: it loads it from a different repo because of the use lib ?

[19:13] <nine> lizmat: yes

[19:14] <nine> upstream repos will always use the precomp store of the head in the list and use lib changes the head

[19:14] <lizmat> isn't the problem really that the check for candidates doesn't match the Test that is already loaded 

[19:14] <lizmat> ?

[19:14] <psch> doesn't that assume we start distribution a precompd Test::Util?

[19:14] <psch> with roast that is

[19:14] <lizmat> psch: you can't, because Test::Util is roast, ergo perl 6 implementation independent

[19:14] <nine> psch: the way I see it, we will always precompile used modules automatically on load

[19:15] <lizmat> nine: hmmmm..... that doesn't feel right

[19:15] <psch> nine: oh, yes, that actually makes the problem appear, i wasn't aware of any kind of plan like that

[19:15] <nine> lizmat: there is no candidate for Test::Util that is compiled against the loaded Test because in the repo Test is from there is no Test::Util

[19:16] <lucs> How do I do the perl5 regex equivalent of  .+?  (frugal)?

[19:17] <lizmat> nine: but Test::Util is source, right?

[19:17] <psch> m: say "aaa" ~~ /.+?/ # lucs 

[19:17] <camelia> rakudo-moar 289fdc: OUTPUT«｢a｣␤»

[19:17] <lucs> Heh.

[19:17] <lizmat> .oO( some things never change )

[19:17] <lucs> psch: Thanks, something else must be wrong my code.

[19:17] <lucs> in*

[19:18] <nine> lizmat: it starts out as source but we precomp it and then load the precomped version 

[19:18] <lizmat> I'm not sure it's a good idea to precomp it

[19:19] <nine> lizmat: the alternative is to prohibit precompilation after a use lib

[19:19] *** spider-mario joined
[19:19] <lizmat> ok, looking at it differently: isn't it the real problem then that Test.pm is not precompiled for that repo ?

[19:20] <nine> lizmat: is there in general, apart from my current issue a reason not to precompile everything we encounter? Unless it says no precompilation; of course.

[19:20] <leont> Since rakudo upgrade I'm getting a "Cannot unbox a type object" error (for an attribute that's declared Promise:D)

[19:20] <lizmat> leont: gist ?

[19:21] <lizmat> nine: well, for core developers, it would mean a *lot* of precomped files laying around 

[19:21] <nine> lizmat: we change the repo after loading Test. So of course Test is not precompiled for that repo

[19:21] <leont> Code is too big for that, and it seems it only gets that error after a while

[19:21] <nine> lizmat: cronjobs can clean that up easily

[19:21] <leont> Wait, the "error messages get wrong locations when awaiting" bug is probably at play, should investigate further

[19:22] <lizmat> nine: fwiw, it doesn't feel right

[19:22] <lizmat> this will cause problems on some OS's that are pretty paranoid about writing files

[19:23] <psch> jvm has something about an Exception occuring during print_exception, probably...

[19:23] <psch> well, that is when reverting 5349d05c

[19:23] <nine> lizmat: from jnthn++'s gist: The file system compilation unit repository is used when the -I flag is specified. It is initialized with a prefix. It assumes it will be able to create and write to a .precomp directory beneath that path.

[19:24] <psch> and without that it's a deserialization issue

[19:24] <nine> lizmat: even having that directory makes no sense unless we precomp automatically. Noone is gonna precomp manually in a plain lib dir.

[19:24] *** yqt joined
[19:24] <lizmat> ok, then let's shelve that discussion for now

[19:25] <nine> lizmat: of course, we can check if the .precomp dir is writable and if not just skip precompilation. That could also be an opt-out

[19:25] <lizmat> then I think the problem is that the "use Test" inside the Test/Util.pm should be precomped in that repo

[19:26] <nine> lizmat: it is. But we loaded another precomped version of Test before changing the repo. Of course it's easy to fix on the user's side: use lib 't/spec/packages'; use Test; use Test::Util;

[19:26] <bartolin_> psch: don't know if that helps, but 5349d05c was motivated by this: http://irclog.perlgeek.de/perl6/2015-11-02#i_11471212

[19:26] <n0tjack> m: say (hi => 2) ~~ {hi => 2};

[19:26] <camelia> rakudo-moar 289fdc: OUTPUT«Type check failed in binding &call; expected Callable but got Method+{<anon|74220816>}␤  in block <unit> at /tmp/0GV4NFqJws:1␤␤»

[19:26] <lizmat> hmmm.... and if they don't, it starts failing  :-(

[19:27] *** Skarsnik joined
[19:28] <nine> Unless we just don't precompile after a use lib

[19:28] *** Sqirrel joined
[19:29] <psch> bartolin_: i saw the discussion.  i tried giving $!handled a default instead, which has the same problem as not declaring it int, so something else broke anyway

[19:29] <lizmat> nine: there's a subtle difference between "use lib" and -I

[19:30] <psch> bartolin_: which is to say 5349d05c is probably not at fault, but reverting it unmasks some other breakage

[19:30] <lizmat> with -I, you can be sure there is no code executed before the inclusion of the dir

[19:30] <lizmat> with "use lib", you can have BEGIN blocks run before the use

[19:30] <nine> lizmat: absolutely true

[19:31] *** sufrostico joined
[19:31] <lizmat> so maybe we should treat these differently anyway

[19:31] <bartolin_> psch++ # investigating jvm breakage

[19:32] <lizmat> nine: are we handling a "if 42 { use lib; use mod }"  ??

[19:32] <leont> It seems adding a default value and/or a :D smiley solved my issue, but it's still weird

[19:39] <n0tjack> did "grammatical" regexes appear in p5 of p6 first?

[19:39] <n0tjack> I mean in actual executing interpreters/compilers

[19:40] <lizmat> afaik, standars p5 doesn't have grammars

[19:40] <lizmat> *standard*

[19:40] <n0tjack> no, but in p5.10+ plus you do have m/<?&foo>/ etc

[19:40] <n0tjack> (forgetting the exact syntax, but you know what I mean)

[19:41] <lizmat> that's not a grammar, that is text substiution afaik

[19:42] <nine> Perl 5.10 introduced named captures which is an imporant step towards grammars

[19:42] <nine> lizmat: if I just don't precompile after a use lib, we should be fine again

[19:42] <leont> p5 has something grammar like, and I thought they weren't textual, but I'm not sure. The syntax is horrible

[19:42] <leont> Only place I've seen it used it a damian module

[19:43] <n0tjack> this SO answer lumps such syntaxes under the heading "grammatical patterns": http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address/201378#201378

[19:43] <bartolin_> psch: hmm, with both 5349d05c _and_ f5276ca2 reverted I can build rakudo.jvm \o/

[19:43] <lizmat> nine: unless we specifically precomp, and then it should be for that repo

[19:45] <dalek> rakudo/nom: 9fad7b4 | lizmat++ | src/core/Str.pm:

[19:45] <dalek> rakudo/nom: Fix several issues reported by Tux++

[19:45] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/9fad7b407a

[19:52] <stmuk> I think there an ingyware p5 grammars too

[19:55] <[Coke]> bartolin, psch : worst case, we can #if those two patches for moar vs. jvm

[19:55] <[Coke]> bartolin_: might be able to reduce the scope of f5276ca2 that causes the breakage...

[19:56] <n0tjack> m: [max] (-Inf,-1,0,1,Inf,NaN);

[19:56] <camelia> rakudo-moar 9fad7b: ( no output )

[19:56] <n0tjack> m: say [max] (-Inf,-1,0,1,Inf,NaN);

[19:56] <camelia> rakudo-moar 9fad7b: OUTPUT«Inf␤»

[19:56] <n0tjack> I don't like that.

[19:57] <psch> bartolin_: nice find, i guess that means i can abort my bisect :)

[19:57] <n0tjack> m: say Inf max NaN;

[19:57] <camelia> rakudo-moar 9fad7b: OUTPUT«NaN␤»

[19:57] <n0tjack> m: say Nan max Inf;

[19:57] <camelia> rakudo-moar 9fad7b: OUTPUT«5===SORRY!5=== Error while compiling /tmp/ObSjdJOZPS␤Undeclared name:␤    Nan used at line 1␤␤»

[19:57] <n0tjack> m: say NaN max Inf;

[19:57] <camelia> rakudo-moar 9fad7b: OUTPUT«Inf␤»

[19:57] <psch> m: say NaN < -Inf

[19:57] <camelia> rakudo-moar 9fad7b: OUTPUT«False␤»

[19:57] * bartolin_ also had to revert ad08a1d7, actually -- but that changed only one line which was touched by f5276ca2 also

[19:57] <psch> m: say NaN > -Inf

[19:57] <camelia> rakudo-moar 9fad7b: OUTPUT«False␤»

[19:57] <[Tux]> hm, :( tests now breaking

[19:58] <lizmat> [Tux]: how ?  gist ?

[19:58] *** zakharyas left
[19:58] <bartolin_> [Coke]: yes, that looks fixable now ...

[19:58] <n0tjack> I think technically, Num <infix> NaN and NaN <infix> Num should be NaN.

[19:59] <psch> m: say Inf max NaN, :by(&infix:<==>)

[19:59] <camelia> rakudo-moar 9fad7b: OUTPUT«Unexpected named parameter 'by' passed␤  in block <unit> at /tmp/Ja10DUgS9Q:1␤␤»

[19:59] <psch> aww

[19:59] <n0tjack> Certainly for communitative <infix> the result should be consistently NaN

[19:59] <n0tjack> *commutative

[19:59] <psch> n0tjack: max by default doesn't do infix:<==>, but infix:<cmp>

[19:59] <psch> m: say Inf cmp NaN

[19:59] <camelia> rakudo-moar 9fad7b: OUTPUT«Same␤»

[19:59] <psch> m: say -Inf cmp NaN

[19:59] <camelia> rakudo-moar 9fad7b: OUTPUT«Same␤»

[20:00] <n0tjack> yuck yuck yuck

[20:00] * n0tjack closes eyes

[20:00] <psch> m: say max (-Inf,-1,0,1,Inf,NaN), :by(&infix:<==>)

[20:00] <camelia> rakudo-moar 9fad7b: OUTPUT«-Inf␤»

[20:00] <psch> uhh

[20:00] <psch> m: say max -Inf,-1,0,1,Inf,NaN, :by(&infix:<==>)

[20:00] <camelia> rakudo-moar 9fad7b: OUTPUT«-Inf␤»

[20:00] <PerlJam> m:  say NaN cmp 5

[20:00] <camelia> rakudo-moar 9fad7b: OUTPUT«Same␤»

[20:00] <psch> ah, infix:<==> doesn't fit infix:<cmp> return values i guess

[20:01] <psch> i.e. Less, Same, More

[20:01] <n0tjack> yeah, it's more or less the same

[20:01] <[Tux]> ok 30 - parse () tests

[20:01] <[Tux]> not ok 31 - Single newline

[20:01] <[Tux]> lizmat, lemme check

[20:01] <psch> m: say max -Inf,-1,0,1,Inf,NaN, :by(&infix:['<=>'])

[20:01] <camelia> rakudo-moar 9fad7b: OUTPUT«Cannot call infix:«<=>»(Int); none of these signatures match:␤    (\a, \b)␤    (Real \a, Real \b)␤    (Int:D \a, Int:D \b)␤    (int $a, int $b)␤    (Num:D \a, Num:D \b)␤    (num $a, num $b)␤    (Rational:D \a, Rational:D \b)␤    (Rational…»

[20:02] <psch> you'd think (Any \a, Any \b) would fit

[20:02] <psch> m: say Inf <=> NaN

[20:02] <camelia> rakudo-moar 9fad7b: OUTPUT«Same␤»

[20:02] <psch> m: say -1 <=> NaN

[20:02] <camelia> rakudo-moar 9fad7b: OUTPUT«Same␤»

[20:02] <psch> m: say -1 <=> Inf

[20:02] <camelia> rakudo-moar 9fad7b: OUTPUT«Less␤»

[20:02] <n0tjack> really the only safe thing to do with NaNs is relentlessly propogate them like weaponized ebola

[20:02] <n0tjack> so that people learn to avoid them

[20:03] * PerlJam wonders if NaN will be how we get the equivalent of PDL's bad values 

[20:03] <[Tux]> :keep-indices + :skip-empty now always returns an empty list :(

[20:04] <psch> well, infix:<cmp> special-cases for Inf and -Inf, it probably should for NaN as well

[20:04] <[Tux]> https://gist.github.com/Tux/fa07246e4b3368c62932

[20:04] <psch> as in, i agree with "NaNs should never get disappeared by CORE operations"

[20:06] <lizmat> $ 6 'dd "ofrobaardo".split(<a o>, :keep-indices, :skip-empty)'

[20:06] <lizmat> List $var = $("fr", 1, "b", 0, "rd", 1)

[20:06] <lizmat> [Tux] ^^^

[20:06] <lizmat> [Tux]: so not always

[20:07] <bartolin_> [Coke], psch: looks like it's enough to revert 5349d05c and ad08a1d7 to get rakudo.jvm to build. And both are small patches ...

[20:07] <lizmat> [Tux]: looking at your code, would it make more sense to return the chunk as a pair: delim => string ?

[20:08] <lizmat> and this make it :p as the parameter ?

[20:09] <[Coke]> bartolin_: you want the honors?

[20:09] <lizmat> or perhaps *add* :p as a parameter as an alternative to :all

[20:09] *** geraud joined
[20:10] <bartolin_> [Coke]: thanks, but it will be much faster if you commit something directly

[20:10] <psch> those two patches seem to point at something inherently wrong with how R-J does exceptional stuff... :/

[20:11] <[Coke]> ok.

[20:11] <psch> might be somewhat related to those UnwindException leaks we get from e.g. match(:ex)

[20:11] <psch> although i don't immediately see how, it just seems to deal with similar stuff vOv

[20:12] <psch> m: say NaN.Stringy ~~ Str

[20:12] <camelia> rakudo-moar 9fad7b: OUTPUT«True␤»

[20:13] <psch> m: say 1 le NaN

[20:13] <camelia> rakudo-moar 9fad7b: OUTPUT«True␤»

[20:14] <[Tux]> lizmat, https://gist.github.com/Tux/41263465dcb3b12ded2f

[20:15] <[Tux]> that *should* be 3 4 "I said" 3 4 4 "Ji!" 4 4 4 3

[20:15] <[Tux]> that *should* be 3 4 "I said" 3 : " 4 4 "Hi!" 4 4 4 3

[20:16] <[Tux]> before you went biking it was

[20:16] <[Tux]> 3 4 "I said" 3 : " 4 4 "Hi!" 4 4 4 3 ""

[20:16] <[Tux]> 3 4 "I said" 3 " " 4 4 "Hi!" 4 4 4 3 ""

[20:16] * lizmat is looking

[20:17] <[Tux]> afk a bit

[20:17] *** zengargoylee left
[20:17] *** domidumont left
[20:18] * [Coke] does a build on both to make sure his partial undoing works.

[20:20] *** xxx joined
[20:20] *** xxx is now known as Guest41208

[20:21] *** Guest41208 left
[20:22] <lizmat> [Tux]: Ah, I think that's caused by the fact that :skip-empty now also drops the delimiter index

[20:22] <lizmat> [Tux]: I was under the impression that you wanted it that way ??

[20:24] <mrf>  

[20:25] <mrf> m: say "\r\n" ~~ /\xA\xD/

[20:25] <camelia> rakudo-moar 9fad7b: OUTPUT«Nil␤»

[20:26] <mrf> ruddy cat

[20:26] <mrf> ^ am I wrong in thinking that that should match

[20:27] <lizmat> not anymore

[20:27] <lizmat> m: say "\r\n".chars

[20:27] <camelia> rakudo-moar 9fad7b: OUTPUT«1␤»

[20:27] <lizmat> m: say "\xA\xD".chars

[20:27] <camelia> rakudo-moar 9fad7b: OUTPUT«2␤»

[20:27] <mrf> Oh. I was aware that jnthn had done some work in this area but not the full ramifications

[20:28] <lizmat> "\r\n" is now a synthetic

[20:28] <FROGGS> m: say "\xD\xA".chars

[20:28] <yoleaux> 4 Nov 2015 19:48Z <mrf> FROGGS: for some reason 1^..10 doesn't work in a codeblock as a quantifier. I have no idea why

[20:28] <camelia> rakudo-moar 9fad7b: OUTPUT«1␤»

[20:28] <PerlJam> mrf: it'll probably need a blog post or two explaining it to the masses (especially those who are used to other, very similar languages)

[20:28] <FROGGS> m: say "\r\n" ~~ /\xD\xA/

[20:28] <camelia> rakudo-moar 9fad7b: OUTPUT«｢

[20:28] <FROGGS> mrf: ^^

[20:28] <lizmat> Hmmm... FROGGS : good point

[20:28] <lizmat> :-)

[20:28] <FROGGS> :o)

[20:28] *** darutoko left
[20:29] *** Oatmeal left
[20:29] <lizmat> still, I wonder how we can now e.g. check HTTP headers for actually returning CRLF, and not just LF

[20:29] <stmuk> m: say so  "\r\n" ~~ /\xD\xA/

[20:29] <camelia> rakudo-moar 9fad7b: OUTPUT«True␤»

[20:29] <FROGGS> lizmat: buffers

[20:29] <mrf> Indeed. I am curious how I should now handle a grammar that should explicitly match CRLF. (ABNF RFCs)

[20:29] <lizmat> or should we care ?

[20:29] <mrf> lizmat++ this

[20:30] <FROGGS> lizmat: the receiving end should be lax, but the transmitting end should be strict

[20:30] <lizmat> so we don't care (much) :-)

[20:30] <FROGGS> m: say so "\n" ~~ /\xD\xA/

[20:30] <camelia> rakudo-moar 9fad7b: OUTPUT«False␤»

[20:30] <FROGGS> m: say so "\r" ~~ /\xD\xA/

[20:30] <camelia> rakudo-moar 9fad7b: OUTPUT«False␤»

[20:30] <FROGGS> mrf: you see? it works

[20:31] <stmuk> Postel's Law of smart matchs ?

[20:31] <FROGGS> m: say so "\r\n" ~~ /^\xD\xA$/

[20:31] <camelia> rakudo-moar 9fad7b: OUTPUT«True␤»

[20:31] <mrf> FROGGS: not really seeing it

[20:31] <FROGGS> m: say so "\r\n\n" ~~ /^\xD\xA$/

[20:31] <camelia> rakudo-moar 9fad7b: OUTPUT«False␤»

[20:31] <FROGGS> m: say so "\r\r\n" ~~ /^\xD\xA$/

[20:31] <camelia> rakudo-moar 9fad7b: OUTPUT«False␤»

[20:31] <FROGGS> mrf: you can match CRLF by matching against \xD\xA

[20:32] <mrf> I have to go. Will check back later. Sorry. Thanks anyway

[20:32] <FROGGS> o/

[20:32] <mrf> FROGGS: ???? Will ask later when I have time

[20:32] <mrf> thanks

[20:32] *** aindilis joined
[20:32] <nine> FROGGS: that approach is what inflicted endless pain on the net

[20:32] <[Coke]> arg: Nested conditionals not supported

[20:32] <FROGGS> nine: well, that's how the RFC state it, no?

[20:33] <lucs> Question: http://fpaste.scsys.co.uk/501039

[20:33] <nine> FROGGS: not everything written into RFCs turned out to be wise :)

[20:33] <FROGGS> nine: true :o)

[20:34] <lizmat> lucs: given $some_var_name { when 1 {} when 2 {} when 3 {}

[20:34] <nine> If you're lax on the receiving end, you're forcing every other receiver to be lax in the same way. Because the sender will not be all that strict anymore as it did work in the tests

[20:34] <PerlJam> lucs: given $some_var_name { when 1 { "one" } when 2 { "two" } when 3 { "three" } default "wut" } }

[20:34] <stmuk> there probably needs to be a gotcha faq about "\r\n"

[20:34] <lizmat> yes

[20:34] <moritz> lucs: my $foo = ('one', 'two', 'three')[ $some_var_name - 1] // 'wut';

[20:35] <PerlJam> moritz++ :)

[20:35] <FROGGS> P5 style :o)

[20:35] <moritz> looks like both valid p5.10+ and p6

[20:36] <[Tux]> lizmat, I want < 3 4 "I said" 3 " " 4 4 "Hi!" 4 4 4 3 > on the combo, and that implementation made perfect sense

[20:37] *** hoelzro_ is now known as hoelzro

[20:37] <[Tux]> the only problem before yout bike run was a trailing ""

[20:37] <lizmat> ah, ok

[20:37] <lizmat> [Tux]: how about the pair idea?

[20:37] <lucs> I can't get it working with  my $foo = given ...  , and unfortunately, moritz's example, although it works, is perhaps not general enough (my example used 1, 2, 3, but my real code matches on something more complex).

[20:37] <PerlJam> lucs: also, you could do  my $foo = do given $some_var_name { $_ == 1 ?? "one" !! $_ == 2 ?? "two" !! $_ == 3 ?? "three" !! "wut"; }

[20:37] * [Tux] has no idea what a pair would yield

[20:38] <lizmat> only one elem per chunk

[20:38] <lucs> PerlJam: Aha, closer, yes.

[20:38] <[Tux]> so far it doesn't appeal to me

[20:38] <[Tux]> I don't think I like it

[20:38] <[Tux]> but I can be convinced otherwise if it makes sense

[20:38] <lizmat> you have a map somewhere now, right ?

[20:39] <[Tux]> no

[20:39] <[Tux]> not in the split(@re, :skip-empty, :keep-indices) version

[20:39] <[Tux]>             my @c = $str.split (@re, :keep-indices, :skip-empty).map ({

[20:39] <[Tux]>                 $_ ~~ Int ?? @re[$_] !! $_ });

[20:39] <[Tux]> that one?

[20:40] <lizmat> I see a map there

[20:40] <lizmat> yes

[20:40] <lucs> PerlJam: Works great, thanks. (basically, I was just missing the 'do')

[20:40] <PerlJam> lizmat, Tux:  looking on from the peanut gallery, I'm starting to get a creeping featurism feeling about this new split.

[20:40] <[Tux]> is to translate the indices back to what it matched

[20:40] *** rindolf left
[20:40] <lizmat> PerlJam: I agree to an extent  :-)

[20:41] <[Coke]> ok, what dumb thing am I missing here: https://gist.github.com/coke/599e725e9c9251ac1a08

[20:41] <lizmat> [Tux]: hmmm... but with :all, you wouldn't have to ?

[20:42] <FROGGS> [Coke]: #?endif  ?

[20:42] <[Coke]> ARGLEBARGLE.

[20:42] <[Coke]> thank you!

[20:42] <lizmat> I thought having the index of the delimiter would make it easier for you to determine *what* to do (is it an escape, is it an delimiter, is it a newline ?)

[20:42] <[Tux]> result of split(@re,:all) = Array $var = $["", ",", "", "\"", "I said", ",", " ", "\"", "", "\"", "Hi!", "\"", "", "\"", "", "\"", "", ",", ""]

[20:42] *** Oatmeal joined
[20:42] *** telex left
[20:43] <[Tux]> my @chunks = $str.split(@re, :all).grep(* ne "");

[20:43] <[Tux]> will work fine

[20:43] <lizmat> well, that is what :skip-empty will do again

[20:44] <[Tux]> so, :all, :skip-empty

[20:44] <lizmat> I'm confused though: shouldn't you handle things differently depending on the delimiter encountered ??

[20:44] *** telex joined
[20:44] <[Coke]> FROGGS: I haad already gotten it right about 100 lines away from there, too. :)

[20:44] <FROGGS> *g*

[20:44] <[Tux]> not in the split

[20:45] <[Tux]> :all, :skip-empty is currently broken

[20:45] <lizmat> yeah, fixing that now

[20:45] <lizmat> or maybe I should just drop skip-empty completely

[20:46] <[Tux]> fine with me

[20:46] <[Coke]> bartolin++

[20:46] <PerlJam> huh.

[20:46] <[Coke]> whoops. too soon. :|

[20:46] <PerlJam> :keep-indices seems the weird one to me.  :all and :skip-empty make more sense

[20:46] *** AlexDaniel joined
[20:47] <n0tjack> what's the syntactic rationale behind adverbs, instead of just using named params everywhere?

[20:48] * TimToady has a fix for the foo:bar problem and then some

[20:48] <n0tjack> more convenient, fewer parens?

[20:48] <[Tux]> my @chunks = $str.split(@re, :all).grep(* ne ""); =>

[20:48] <[Tux]> All tests successful.

[20:48] *** softmoth joined
[20:49] <PerlJam> n0tjack: what do you mean by "using named params everywhere" ?

[20:49] <n0tjack> PerlJam: in my (potentially mixed up) head, adverbs are just anotehr way to pass named parameters to functions

[20:50] <nine> Do we have any file locking support?

[20:50] <n0tjack> like m:g/blah blah/ could easily be m/blah blah/, :g

[20:50] <psch> adverbs are named arguments to irregular-looking subs, in my understanding

[20:50] <bartolin_> [Coke]: do you get new failures after jvm-specific reverts?

[20:50] <n0tjack> but you'd have to do more parenthesizing

[20:50] <lizmat> PerlJam: why is the keep-indices the weird one?

[20:51] <lizmat> PerlJam: if you're splitting and depending on the delimiter, you need to do different things

[20:51] <PerlJam> lizmat: because it's more about the @re than the string or the actual splitting.

[20:51] <lizmat> surely a number would be easier to use (like an index into a dispatch table) than the string of the delimiter ?

[20:51] <[Tux]> test             50000    36.624    36.508

[20:51] <[Tux]> test-t           50000    21.728    21.611

[20:52] <[Coke]> updated https://gist.github.com/coke/599e725e9c9251ac1a08 with my two local patches and the current fail mode of "make"

[20:52] <dalek> rakudo/nom: 3eb2460 | lizmat++ | src/core/Str.pm:

[20:52] <dalek> rakudo/nom: Return :skip-empty to previous semantics

[20:52] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/3eb2460a53

[20:52] <lizmat> [Tux]: that should allow you to remove the grep and make it in the 20 sec range again

[20:53] <PerlJam> lizmat: I also agree with different delimiter, different actions, but the :keep-indices variant feels like it should be a special-purpose split-with-indices or something

[20:53] *** softmoth left
[20:53] <[Tux]> I just pushed the grep version

[20:53] * [Tux] retries

[20:54] <bartolin_> [Coke]: I just saw that I was only on commit 6cb35b40b4 when reverting those commits. so probably a recent commit mixed something up (again)?

[20:54] <bartolin_> sorry for not looking more carefully!

[20:55] <PerlJam> n0tjack: so ... adverbs are a way to pass names parameters.  But I don't quite see the distinction you're trying to make.

[20:55] <PerlJam> s/names/named/

[20:55] <[Coke]> I imagine that we will eventually have a git policy where commits have to go on a branch indicating which VM they were tested on, so we can test them on other VMs before merging them bcak to mainline.

[20:56] <TimToady> lizmat: I think instead of :keep-indices/:all we should do the :k/:v/:kv trick

[20:56] <bartolin_> [Coke]: on the other hand I'm able to build rakudo.jvm when I had that NPE without a line number before.

[20:56] <nine> [Coke]: isn't that a problem that CI was invented for?

[20:56] <TimToady> then we can get both the index and the delim

[20:57] *** nys joined
[20:57] <lizmat> ok, so :kv would be :all

[20:57] <lizmat> :v would be :!all

[20:57] <TimToady> I thought :all meant :v

[20:57] * PerlJam too

[20:57] <TimToady> anyway, I think consistency with other kv things is nice here

[20:57] <lizmat> yeah, agree

[20:57] <TimToady> not to mention shorter :)

[20:57] <n0tjack> PerlJam: They're explicitly supported as a separate aspect of p6's grammar.  Work was put in to support them.  I'm interested in the original and ongoing motivation to include them above-and-beyond normal named-parameter syntax.

[20:58] <[Tux]> I find that not logical, as @re does not have to be even-counted and there can be several items from @re adjacent

[20:58] <[Tux]> demo code pls, so I can see what you mean

[20:59] <lizmat> TimToady: :v means a filtering for values

[20:59] <PerlJam> n0tjack: sorry, I'm probably being thick right now, but it reads like "why do we even have adverbs?" and my answer is ... for the same reason we have them in English  :)

[20:59] *** cygx joined
[20:59] <cygx> o/

[21:00] <lizmat> so, no adverb means only the strings between the delimiters

[21:00] <lizmat> :v means the non-empty strings between delimiters

[21:00] <n0tjack> PerlJam: There's a lot of stuff we have in English we don't have in Perl6, and vice-versa. 

[21:00] <lizmat> :kv means the delimiter, then the string ?

[21:01] <n0tjack> PerlJam: Though I'd be very interested in wht corresponds to the subjunctive in Perl6

[21:01] <lizmat> it feels a bit weird, as the delimiter is after the string it separates

[21:01] <TimToady> :kv means index then delimiter

[21:01] <TimToady> the "combed" parts are independent of the delim's k or v

[21:01] <lizmat> ah, you mean the position in the string ?

[21:01] <TimToady> no

[21:02] <TimToady> same as :keep-indices is now

[21:02] <[Tux]> but the index as currently used is that the parts that matched from @re are returned as an index into @re. Nothing to do with the parts *between* the matches

[21:02] <cygx> nine: we support O_CREAT via :x

[21:02] <TimToady> that's what I'm talking about

[21:02] <cygx> totally not unrelated: https://github.com/rakudo/rakudo/pull/575

[21:03] <[Tux]> TimToady, so :k returns the index for matched parted, :v the matched part and :kv both (for whoever needs it)

[21:04] <dalek> rakudo/nom: c5b3538 | TimToady++ | src/Perl6/ (3 files):

[21:04] <dalek> rakudo/nom: regularize and canonicalize pairs on names

[21:04] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/c5b3538298

[21:04] <lizmat> and what happens to the strings that were separated ?

[21:04] <[Tux]> "frobnitz".split(<o i>, :k) => < fr 0 bn 1 tz>

[21:04] <[Tux]> "frobnitz".split(<o i>, :v) => < fr o bn i tz>

[21:04] <TimToady> they're interspersed every 3rd instead of every 2nd, if you have :kv

[21:04] <[Tux]> "frobnitz".split(<o i>, :kv) => < fr 0 o bn 1 i tz>

[21:05] <TimToady> so you could do a switch on the number and then use the value of the delimiter differently depending on the number

[21:05] <lizmat> TimToady: ^^^ is that how you meant it ?

[21:05] <cygx> nine: that should have read O_EXCL, of course ;)

[21:05] <TimToady> yes

[21:05] <[Coke]> nine;if this probably was fixable with CI, then a git bisect would have made it easy to solve, no?

[21:05] <lizmat> ok, consider it done  :-)

[21:06] <[Tux]> so :all becomes :v

[21:06] <[Coke]> if there was a stopper between "commit is in the repo" and "commit is in mainline", then sure.

[21:06] <lizmat> yup

[21:06] <[Tux]> note that :all was there for a long time, so it will be a deprecation cyle

[21:07] <TimToady> I suppose one could have a :p too...

[21:07] <lizmat> yes, that would make sense

[21:07] <[Tux]> "frobnitz".split(<o i>, :p) => < fr 0:o bn 1:i tz> ?

[21:08] <lizmat> "frobnitz".split(<o i>, :p) => < fr 0 => o bn 1 => i tz>

[21:08] <[Tux]> yes, that

[21:08] <[Tux]> sounds sane

[21:08] <[Tux]> and :skip-empty will stay?

[21:09] <[Tux]> lizmat, are you sitting?

[21:09] <lizmat> yes

[21:09] <[Tux]> test             50000    34.725    34.611

[21:09] <[Tux]> test-t           50000    17.972    17.859

[21:09] <lizmat> whee!

[21:09] <TimToady> o_O

[21:09] <[Tux]> $str.split (@re, :all, :skip-empty);

[21:09] <TimToady> m: foo:bar["x" ~ 42]

[21:09] <camelia> rakudo-moar 9fad7b: OUTPUT«5===SORRY!5=== Error while compiling /tmp/R7wgT0XPvz␤Undeclared routine:␤    foo used at line 1␤␤»

[21:09] <nine> woah!

[21:10] <nine> [Coke]: well, once we get JVM 100% working again, CI should notify us of regressions in a timely manner

[21:10] *** Celelibi_ joined
[21:11] <lizmat> just playing devil's advocate: shouldn't :k return the delimiter strings ?   

[21:11] <TimToady> m: foo:bar["x" ~ 42]

[21:11] <camelia> rakudo-moar c5b353: OUTPUT«5===SORRY!5=== Error while compiling /tmp/qnvDGSJbuD␤Undeclared routine:␤    foo:bar<x42> used at line 1␤␤»

[21:11] <lizmat> and :v the indices ?

[21:12] <lizmat> "delim" => $num feels a bit more natural to me than $num => "delim"

[21:12] <TimToady> well, it's the key into the table

[21:12] <TimToady> the one you passs

[21:12] *** Celelibi left
[21:12] <lizmat> ok

[21:12] *** gnomad left
[21:12] <TimToady> and the value is in the table if it's literal

[21:13] * [Tux] also feels more comfortable with keys being the numerics and values the strings

[21:13] <TimToady> so that seemed more natural to me

[21:13] <lizmat> ok

[21:13] <lizmat> now, the combination :v and :skip-empty is dangerous

[21:13] <[Tux]> why? (that would be what I'd use in T::C)

[21:13] <lizmat> because you cannot tell the difference between a delimiter string and a missing chunk

[21:14] <TimToady> well, sure, don't do that

[21:14] <TimToady> unless you want to test the next thing for integerness

[21:14] <lizmat> [Tux]: :v would be the *string* we just decided

[21:14] <lizmat> *delimiter string"

[21:14] <[Tux]> yes, which is what I wanted

[21:14] <[Tux]> indeed

[21:15] <TimToady> right, ;v; isn't the integer

[21:15] <TimToady> *:

[21:15] <[Tux]> correct, so what is the problem?

[21:15] <lizmat> ok, I guess I don't understand the Text::CSV internals well enough

[21:15] <TimToady> how do you tell if the , is data or delim?

[21:16] <TimToady> m: my $today:<😂>= “Does this work?”; say $today:<😂>

[21:16] <camelia> rakudo-moar c5b353: OUTPUT«Does this work?␤»

[21:16] <[Tux]> it is delim unless I am in quoted state

[21:16] <cygx> em... why doesn't $*OUT.IO return something I can do i/o with?

[21:16] <[Tux]> TimToady, the split is not the entire engine

[21:17] <TimToady> okay

[21:17] * AlexDaniel wow, what's that

[21:17] <TimToady> anyway, I think it's in the DIH category

[21:17] <lizmat> [Tux]: and how do you get to quoted state ?

[21:18] <TimToady> with a quote in non-quoted state

[21:18] <[Tux]> I split the string into chunks: every chunk is either one of EOL, SEP, QUOTE, ESCAPE, or something else

[21:18] <lizmat> TimToady: but there can be multiple quote strings, and it doesn't have to be a "  :-)

[21:18] *** flussence joined
[21:18] <[Coke]> nine - we do have it on a day interval at the moment, btw.

[21:18] <[Tux]> then I run through the chunks

[21:19] <lizmat> [Tux]: but how do you know what a chunk is ?

[21:19] <TimToady> m: my $today:foo<😂>= “Does this work?”; say $today:foo<😂>   # still a bug here

[21:19] <camelia> rakudo-moar c5b353: OUTPUT«5===SORRY!5=== Error while compiling /tmp/U4qOjejmlb␤Variable '$today' is not declared␤at /tmp/U4qOjejmlb:1␤------> 3y $today:foo<😂>= “Does this work?”; say 7⏏5$today:foo<😂>   # still a bug here␤»

[21:19] <[Tux]> if it is an EOL, then if I am in quoted state, it is an embedded EOL (data), otherwise it is end of record

[21:19] <lizmat> yes, but *how* do you know it's an EOL ???

[21:20] <[Tux]> then if it is a SEP, if I am in quoted state it is data, otherwise the start of a new field

[21:20] <grondilu> wow this character 😂 shows  up in color on my terminal.

[21:20] <[Tux]> for my $chunk @chunks { if $chunk eq $eol { ...}

[21:20] <lizmat> [Tux]: but *how* do you know it's a SEP

[21:20] <lizmat> right

[21:20] <[Tux]> if $chunk eq $sep { ... }

[21:21] <lizmat> so, if you could change the "if $chunk eq $eol" to a dispatch table depending on the index ?

[21:21] <lizmat> that would make it faster. no?

[21:21] <[Tux]> possible, but hard (at the moment)

[21:21] <[Tux]> 1. I want to support regular expressions for eol/sep/quo/esc later on

[21:22] <[Tux]> 2. if eol is undefined I add \r\n, \r and \n

[21:22] <[Tux]> so the indices will change

[21:22] <lizmat> so you change the dispatch table ?

[21:22] <[Tux]> additionally, by default QUO and ESC are identical

[21:23] <[Tux]> but the idea of a dispatch table, using :k instead of :v (once implemented) will cause a new branche to play with

[21:23] <lizmat> ok, and I just realize my argument for "how do you know if it's a delim and not a string

[21:24] <lizmat> is because the string can never be the same as the delimiter

[21:24] <[Tux]> :)

[21:24] <zengargo1le> i should be able to recurse usion &?ROUTINE(...) right?

[21:24] <lizmat> ok

[21:24] <lizmat> I shall implement :k and friends, and we'll take it from there

[21:24] <[Tux]> top! lizmat++

[21:25] <zengargo1le> i'm getting Too many positionals passed; expected 0 arguments but got 4

[21:25] <zengargo1le> when i use &?ROUTINE vs actual-sub-name

[21:26] <TimToady> are you really in a block instead of a routine?

[21:26] <FROGGS> zengargo1le: is that &?ROUTINE in a for loop or in a statement modifying for loop?

[21:26] <TimToady> is there anything in the outer scope that expects 0 args?

[21:26] *** _mg_ left
[21:27] <[Tux]> Thanks all involved for today. I'm ending mine here

[21:27] <zengargo1le> both in a: if &?ROUTINE { blah } and in the actual elsif $foo { &?ROUTINE }

[21:27] <zengargo1le> within a surrounding sub actual-name() { ... } of course.

[21:27] <lizmat> good night, [Tux] 

[21:28] <FROGGS> zengargo1le: can you no-paste it?

[21:29] <zengargo1le> https://gist.github.com/zengargoyle/17f9e4f62ea8cdccfef0

[21:30] <zengargo1le> in sub next-num(), works when i use next-num() vs &?ROUTINE()

[21:32] <FROGGS> m: sub foo(Int) { if 1 { &?ROUTINE(42) } }; foo 42

[21:32] <camelia> rakudo-moar c5b353: OUTPUT«Too many positionals passed; expected 0 arguments but got 1␤  in block <unit> at /tmp/um_QNQ37Pc:1␤  in sub foo at /tmp/um_QNQ37Pc:1␤  in block <unit> at /tmp/um_QNQ37Pc:1␤␤»

[21:32] <hobbs> masak: I just read the 007 README. I didn't realize you were actually Tom Stoppard.

[21:32] <FROGGS> that's the bug I was remembering

[21:32] <FROGGS> m: sub foo(Int) { if 1 { &?ROUTINE(42) if 1 } }; foo 42

[21:32] <camelia> rakudo-moar c5b353: OUTPUT«Too many positionals passed; expected 0 arguments but got 1␤  in block <unit> at /tmp/jrYuZaobT0:1␤  in sub foo at /tmp/jrYuZaobT0:1␤  in block <unit> at /tmp/jrYuZaobT0:1␤␤»

[21:32] <FROGGS> m: sub foo(Int) { if 1 { { &?ROUTINE(42) }() } }; foo 42

[21:32] <camelia> rakudo-moar c5b353: OUTPUT«Too many positionals passed; expected 0 arguments but got 1␤  in block <unit> at /tmp/XqXOuML4xk:1␤  in sub foo at /tmp/XqXOuML4xk:1␤  in block <unit> at /tmp/XqXOuML4xk:1␤␤»

[21:32] <ugexe> wrap your &?ROUTINE bit like ($ = &?ROUTINE($args)) and it works

[21:33] <FROGGS> m: sub foo(Int) { if 1 { $= &?ROUTINE(42) } }; foo 42

[21:33] *** Celelibi_ is now known as Celelibi

[21:33] <FROGGS> O.o

[21:33] <camelia> rakudo-moar c5b353: OUTPUT«Memory allocation failed; could not allocate 8388608 bytes␤»

[21:33] <FROGGS> hah!

[21:33] <FROGGS> \o/

[21:33] <FROGGS> m: sub foo(Int) { if 1 { $ = &?ROUTINE(42) } }; foo 42

[21:33] <camelia> rakudo-moar c5b353: OUTPUT«Memory allocation failed; could not allocate 8388608 bytes␤»

[21:33] <FROGGS> ohh...

[21:34] <FROGGS> well

[21:34] <FROGGS> FROGGS--

[21:34] <zengargo1le> ugexe: that worked.  so it's a bug of some sort?

[21:34] <FROGGS> zengargo1le: and it is already ticketed

[21:34] <zengargo1le> cool.

[21:39] <dalek> rakudo/nom: c880f16 | TimToady++ | src/Perl6/Actions.nqp:

[21:39] <dalek> rakudo/nom: attach adverbs to variables too

[21:39] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/c880f1641c

[21:39] *** n0tjack left
[21:41] <dalek> roast: 7390453 | TimToady++ | S32-hash/delete.t:

[21:41] <dalek> roast: $var:adverb now dies

[21:41] <dalek> roast: review: https://github.com/perl6/roast/commit/7390453602

[21:41] *** Oatmeal left
[21:43] <dalek> roast: aa4ba57 | TimToady++ | S03-operators/ternary.t:

[21:43] <dalek> roast: adverbs now attach to identifiers

[21:43] <dalek> roast: review: https://github.com/perl6/roast/commit/aa4ba57677

[21:43] <TimToady> and another divergence from STD bites the dust...

[21:43] *** kaare_ left
[21:46] <TimToady> errantry &

[21:50] *** eliasr joined
[21:54] *** Oatmeal joined
[22:01] *** Oatmeal left
[22:05] <zengargo1le> hrm, refactoring and i hit: dp($t,$a,$s).defined or dp($t,$a,$s) = do if … # works

[22:05] <zengargo1le> dp($t,$a,$s) //= do if … # doesn't

[22:07] <zengargo1le> and the &?ROUTINE thing errored out again even with the ($ = …) hack. :(

[22:07] *** perlawhirl left
[22:08] *** solarbunny left
[22:08] *** synbot6 left
[22:08] *** dalek left
[22:08] *** xpen joined
[22:09] *** lsm-desktop_ left
[22:09] *** zengargo1le is now known as zengargoyle

[22:10] *** TEttinger joined
[22:11] *** skids1 left
[22:12] *** kmel left
[22:14] *** xpen left
[22:18] *** Oatmeal joined
[22:21] *** perlawhirl joined
[22:24] *** lsm-desktop_ joined
[22:25] *** kmel joined
[22:31] *** Oatmeal left
[22:33] *** spider-mario left
[22:35] *** Skarsnik left
[22:37] *** softmoth joined
[22:38] *** RabidGravy left
[22:39] <TimToady> m: my $today:foo<😂>= “Does this work?”; say $today:foo<😂>

[22:39] <camelia> rakudo-moar c880f1: OUTPUT«Does this work?␤»

[22:40] <TimToady> m: my $today:foo:bar:baz<😂>= “Does this work?”; say $today:foo:bar:baz<😂>

[22:40] <camelia> rakudo-moar c880f1: OUTPUT«Does this work?␤»

[22:40] <TimToady> m: my $today:foo«a b»:bar:baz<😂>= “Does this work?”; say $today:foo«a b»:bar:baz<😂>

[22:40] <camelia> rakudo-moar c880f1: OUTPUT«5===SORRY!5=== Error while compiling /tmp/qnf8h8gQPi␤Variable '$today:foo<a b>:bar:baz<😂>' is not declared. Did you mean '$today:foo«a b»:bar:baz<😂>'?␤at /tmp/qnf8h8gQPi:1␤------> 3a b»:bar:baz<😂>= “Does this work?”; say 7⏏5$…»

[22:40] <TimToady> cool, another bug :)

[22:42] *** softmoth left
[22:43] *** FROGGS left
[22:44] *** Oatmeal joined
[22:45] <lizmat> :)

[22:45] * lizmat is almost done with split :k and friends, but needs to debug the $parts case still

[22:45] <lizmat> I will do that tomorrow, first some sleep

[22:45] *** hlafarge joined
[22:45] <zengargoyle> m: sub d($i) is rw { state @; @[$i] }; d(1)=12; say d(1);

[22:45] <camelia> rakudo-moar c880f1: OUTPUT«[1]␤»

[22:45] <lizmat> so good night, #perl6!

[22:46] <TimToady> o/

[22:46] <zengargoyle> m: sub d($i,$j) is rw { state @; @[$i][$j] }; d(1,2)=12; say d(1,2);

[22:46] <camelia> rakudo-moar c880f1: OUTPUT«(Any)␤»

[22:46] <zengargoyle> m: sub d($i,$j) is rw { state @x; @x[$i][$j] }; d(1,2)=12; say d(1,2);

[22:46] <camelia> rakudo-moar c880f1: OUTPUT«12␤»

[22:47] <TimToady> each sigil is its own state var

[22:47] <zengargoyle> so, doesn't need explicit state?

[22:47] <pink_mist> indeed not

[22:48] <zengargoyle> m: sub d($i,$j) is rw { @[$i][$j] }; d(1,2)=12; say d(1,2);

[22:48] <camelia> rakudo-moar c880f1: OUTPUT«(Any)␤»

[22:48] <zengargoyle> m: sub d($i) is rw { @[$i] }; d(1)=12; say d(1);

[22:48] <camelia> rakudo-moar c880f1: OUTPUT«[1]␤»

[22:48] <zengargoyle> but still doesn't @[$x][$y]

[22:49] <sprocket> how would i declare a function sig, where the only parameter is an array of specific type?

[22:49] *** abaugher` left
[22:49] <zengargoyle> maybe not Perl 5 like autovivication?

[22:49] <TimToady> zengargoyle: it probably oughta work there

[22:49] *** advwp left
[22:50] *** abaugher` joined
[22:50] <TimToady> m: sub foo(Int @bar) {...}

[22:50] <camelia> rakudo-moar c880f1: ( no output )

[22:50] <zengargoyle> i would expect it to, but it doesn't :)  wonder if it's rakudobugged yet?

[22:50] <TimToady> but note you can't just pass [1,2,3] to that

[22:51] <sprocket> TimToady: thank you!

[22:51] <sprocket> why wouldn’t [1,2,3] work in that case?

[22:51] <TimToady> because that's just an array containing it's, it's not declared to be an array returning Int

[22:51] <TimToady> *ints

[22:51] <zengargoyle> Array[Int].new(1,2,3)

[22:52] <TimToady> that would work better

[22:52] <zengargoyle> that's in the tricks/traps on doc.perl6.org

[22:52] <TimToady> m: sub foo(Int @bar) {say @bar}; foo my Int @ = 1,2,3;

[22:52] <camelia> rakudo-moar c880f1: OUTPUT«[1 2 3]␤»

[22:53] <TimToady> or like that

[22:53] <TimToady> m: sub foo(Int @bar) {say @bar}; foo anon Int @ = 1,2,3;

[22:53] <camelia> rakudo-moar c880f1: OUTPUT«5===SORRY!5=== Error while compiling /tmp/zJWfQSi6hk␤anon scoped variables not yet implemented. Sorry. ␤at /tmp/zJWfQSi6hk:1␤------> 3foo(Int @bar) {say @bar}; foo anon Int @7⏏5 = 1,2,3;␤    expecting any of:␤        constraint␤»

[22:53] <TimToady> m: sub foo(Int @bar) {say @bar}; foo my @ of Int = 1,2,3;

[22:53] <camelia> rakudo-moar c880f1: OUTPUT«Type check failed in binding @bar; expected Positional[Int] but got Array[Int]␤  in sub foo at /tmp/LSlALQKT57:1␤  in block <unit> at /tmp/LSlALQKT57:1␤␤»

[22:53] <TimToady> hmm

[22:55] <TimToady> anyway, strong typing is nominal, not structural, in Perl 6

[22:56] <zengargoyle> when do shaped arrays come?  sometime after xmas...

[22:56] *** kmel left
[22:56] <TimToady> no, should be in a week or two

[22:57] <zengargoyle> oh, yay!

[22:57] <TimToady> we have them implemented, just not hooked up to the declarator yet

[22:57] *** xfix left
[22:57] <TimToady> I think jnthn++ will be working on that next, now that NFG is finally wrapping up

[22:57] <TimToady> m: sub foo(Int @bar) {say @bar}; foo Array[Int](1,2,3);

[22:57] <camelia> rakudo-moar c880f1: OUTPUT«[1 2 3]␤»

[22:57] <TimToady> a coercion also works there

[22:58] <psch> m: sub d($i) is rw { @.[$i] }; d(1)=12; say d(1); 

[22:58] <camelia> rakudo-moar c880f1: OUTPUT«12␤»

[22:58] <psch> m: sub d($i,$j) is rw { @.[$i].[$j] }; d(1)=12; say d(1); 

[22:58] <camelia> rakudo-moar c880f1: OUTPUT«5===SORRY!5===␤Calling d(int) will never work with declared signature ($i, $j)␤at /tmp/0hmQuus97E:1␤------> 3sub d($i,$j) is rw { @.[$i].[$j] }; 7⏏5d(1)=12; say d(1);␤Calling d(int) will never work with declared signature ($i, $j)␤at /t…»

[22:58] <psch> m: sub d($i,$j) is rw { @.[$i].[$j] }; d(1)=12; say d(1, 2); 

[22:58] <camelia> rakudo-moar c880f1: OUTPUT«5===SORRY!5=== Error while compiling /tmp/gNtLKkDWOY␤Calling d(int) will never work with declared signature ($i, $j)␤at /tmp/gNtLKkDWOY:1␤------> 3sub d($i,$j) is rw { @.[$i].[$j] }; 7⏏5d(1)=12; say d(1, 2);␤»

[22:58] *** rarara__ joined
[22:58] <psch> m: sub d($i,$j) is rw { @.[$i].[$j] }; d(1, 2)=12; say d(1, 2); 

[22:58] <camelia> rakudo-moar c880f1: OUTPUT«12␤»

[22:58] <zengargoyle> ah...

[22:58] *** advwp joined
[22:58] <rarara__> will shaped array be fast reshapable ?

[22:58] <yoleaux> 29 Oct 2015 00:07Z <lizmat> rarara__: I've completed GLRifying Str.split, but still need to look at a few spectest fails, will continue after some sleep

[22:59] <psch> m: say (@[1]).perl; say (@.[1]).perl

[22:59] <camelia> rakudo-moar c880f1: OUTPUT«[1]␤Any␤»

[22:59] <rarara__> like change the number of rows and column without any data touching

[23:00] *** lab__ joined
[23:00] <zengargoyle> psch: thanks, a bit closer to expected.

[23:00] <TimToady> those aren't the same @

[23:01] <TimToady> rarara__: pretty fast

[23:01] <psch> [Coke]: did the <#if jvm>-ing work out?

[23:01] <TimToady> maybe not quite as fast as APL

[23:01] <TimToady> but if the data layout is the same, it's just changing the descriptor

[23:02] <TimToady> m: sub d($i,$j) is rw { @[$i;$j] }; d(1,2)=12; say d(1,2);

[23:02] <camelia> rakudo-moar c880f1: OUTPUT«[1 2]␤»

[23:02] <psch> ah, found the gist in the backlog...

[23:02] <TimToady> hmm, there's an odd failure mode

[23:02] <bartolin_> psch, [Coke]: After reverting 5349d0 and ad08a1 it looks like cc4d72c4 was the first commit resulting in the current error

[23:02] *** hlafarge left
[23:02] <zengargoyle> @.[].[].[] appears to work as well as state @x; @x[][][].  what does not the same @ mean?

[23:03] <psch> @[1] is the array-interpretation of a new array with 1 as only elements

[23:03] <TimToady> if you meantion @ twice it's two different varaibles

[23:03] <psch> @.[1] is the 2nd element of an anonymous state array

[23:03] <TimToady> m: sub d($i,$j) is rw { @.[$i;$j] }; d(1,2)=12; say d(1,2);

[23:03] <camelia> rakudo-moar c880f1: OUTPUT«12␤»

[23:03] <TimToady> there we go

[23:03] <TimToady> psch++

[23:04] * TimToady apologized for misread psch's intent above

[23:04] <TimToady> *zes

[23:06] * TimToady is even the guy that added the @[] syntax :)

[23:06] <bartolin_> psch, [Coke]: since cc4d72c4 only adds two lines, maybe you have an idea apply a patch for JVM

[23:06] <zengargoyle> i'm lost.

[23:06] * bartolin_ goes to bed, now

[23:06] <bartolin_> o/

[23:07] <TimToady> @[1,2,3] is a special form that coerces to @

[23:07] <TimToady> m: say %[1,2,3,4]

[23:07] <camelia> rakudo-moar c880f1: OUTPUT«1 => 2, 3 => 4␤»

[23:07] <zengargoyle> @.[$x;$y;$z] is working in my case also.

[23:07] <TimToady> so it needs a .

[23:08] <TimToady> note that, at the moment, the ; form is slower than the [][] form, but we expect that to change

[23:08] <zengargoyle> so @[] is a special case of some sort and @.[] is the real deal?

[23:09] <TimToady> @[] is fallout from when we enabled $[1,2,3] to make an itemized array

[23:09] <zengargoyle> ah, so not really bug

[23:09] <TimToady> I suppose we could restrict those forms to $

[23:10] <zengargoyle> i totally expected @[][][] to work.

[23:10] <TimToady> metoo

[23:11] *** xpen joined
[23:11] <TimToady> m: say %{1,2,3,4}

[23:11] <camelia> rakudo-moar c880f1: OUTPUT«5===SORRY!5=== Error while compiling /tmp/XwtIzPxrMM␤Unsupported use of %{1,2,3,4}; in Perl 6 please use %(1,2,3,4)␤at /tmp/XwtIzPxrMM:1␤------> 3say %{1,2,3,4}7⏏5<EOL>␤»

[23:14] *** Oatmeal left
[23:15] <psch> @[] should probably throw similary to %{}

[23:15] <psch> +l

[23:16] *** xpen left
[23:18] <TimToady> well, maybe it should just work like we expected

[23:18] <psch> TimToady: that is, install an anon state and index on that?

[23:19] * TimToady is testing a patch

[23:19] <psch> feels a bit overly magical to me, but i'm not inherently opposed

[23:20] <psch> as in, it's certainly symetric with how $ for an anon state works

[23:20] <psch> well, i don't have anything but a feeling as object is my point, so yeah :)

[23:20] <psch> *objection

[23:20] <TimToady> well, it blew up compiling NativeCall for some reason, so I'll leave it be for now

[23:26] *** Oatmeal joined
[23:27] *** rarara__ left
[23:28] *** abaugher` is now known as abaugher

[23:34] *** Oatmeal left
[23:35] *** advwp left
[23:37] *** lsm-desktop_ left
[23:39] *** pippo joined
[23:41] <pippo> m: grammar G {rule TOP {<G1>}; token G1 {A}}; my $g = G.parse("A"); say $g.Str; say $g».Str;

[23:41] <camelia> rakudo-moar c880f1: OUTPUT«A␤()␤»

[23:41] <pippo> ^^Bub?

[23:41] <pippo> ^^Bug?

[23:42] <pippo> Why $g».Str = ()?

[23:42] <zengargoyle> m: grammar G {rule TOP {<G1>}; token G1 {"A"}}; my $g = G.parse("A"); say $g.Str; say $g».Str;

[23:42] <camelia> rakudo-moar c880f1: OUTPUT«A␤()␤»

[23:43] <psch> m: grammar G {rule TOP {<G1>}; token G1 {A}}; my $g = G.parse("A"); say $g.perl

[23:43] <camelia> rakudo-moar c880f1: OUTPUT«Match.new(ast => Any, list => (), hash => Map.new((:G1(Match.new(ast => Any, list => (), hash => Map.new(()), orig => "A", to => 1, from => 0)))), orig => "A", to => 1, from => 0)␤»

[23:43] <psch> pippo: "list => ()"

[23:43] <pippo> psch: ?

[23:43] <psch> pippo: » calls .list to do out-of-sequence map on it

[23:44] *** skids joined
[23:44] <psch> ...camelia is somewhat slow today, isn't she?

[23:45] <psch> pippo: i think it's because you don't have any submatches, but i can only verify via camelia, and that apparently takes a moment... :)

[23:45] <zengargoyle> m: grammar G {rule TOP {<G1>}; token G1 {"A"}}; my $g = G.parse("A"); say $g.Str; say $g<G1>.Str;

[23:45] <camelia> rakudo-moar c880f1: OUTPUT«A␤A␤»

[23:45] *** kid51 joined
[23:46] <pippo> m: grammar G {rule TOP {<G1>}; token G1 {A}}; my $g = G.parse("A");  say $g.list;

[23:46] <camelia> rakudo-moar c880f1: OUTPUT«()␤»

[23:46] *** diegok joined
[23:46] <zengargoyle> m: grammar G {rule TOP {(<.G1>)}; token G1 {"A"}}; my $g = G.parse("A"); say $g.Str; say $g>>.Str

[23:46] <camelia> rakudo-moar c880f1: OUTPUT«A␤(A)␤»

[23:47] <pippo> zengargoyle: rationale?

[23:48] <zengargoyle> <named> go into %

[23:48] <psch> ah, not submatches, pos captured, right

[23:48] <psch> zengargoyle++

[23:48] <psch> *captures

[23:48] <zengargoyle> m: grammar G {rule TOP {(<.G1>)}; token G1 {"A"}}; my $g = G.parse("A"); say $g.Str; say %($g):v

[23:48] <camelia> rakudo-moar c880f1: OUTPUT«A␤Map.new(())␤»

[23:48] <zengargoyle> bah

[23:48] <zengargoyle> m: grammar G {rule TOP {(<.G1>)}; token G1 {"A"}}; my $g = G.parse("A"); say $g.Str; say %($g).values

[23:48] <camelia> rakudo-moar c880f1: OUTPUT«A␤()␤»

[23:48] <psch> m: my $match = "abc" ~~ /(a) . $<c>=c/; say $match.list; say $match.hash

[23:48] <camelia> rakudo-moar c880f1: OUTPUT«(｢a｣)␤Map.new((:c(Match.new(ast => Any, list => (), hash => Map.new(()), orig => "abc", to => 3, from => 2))))␤»

[23:49] <zengargoyle> bah xx 2

[23:49] <pippo> m: grammar G {rule TOP {<G1> % ','}; token G1 {A}}; my $g = G.parse("A, A");  say $g».Str;

[23:49] <camelia> rakudo-moar c880f1: OUTPUT«5===SORRY!5=== Error while compiling /tmp/RngiUxhXD2␤Missing quantifier on the left argument of %␤at /tmp/RngiUxhXD2:1␤------> 3grammar G {rule TOP {<G1> %7⏏5 ','}; token G1 {A}}; my $g = G.parse("A␤»

[23:50] <pippo> m: grammar G {rule TOP {<G1>+ % ','}; token G1 {A}}; my $g = G.parse("A, A");  say $g».Str;

[23:50] <camelia> rakudo-moar c880f1: OUTPUT«Use of uninitialized value of type Any in string context␤Any of .^name, .perl, .gist, or .say can stringify undefined things, if needed.  in block <unit> at /tmp/z4M2Sn_OK8:1␤()␤»

[23:50] <zengargoyle> <G1>+ % ','

[23:50] *** sufrostico left
[23:51] <zengargoyle> can only % things that can capture multiples

[23:51] *** olinkl left
[23:51] <pippo> m: grammar G {rule TOP {<G1>+ % ','}; token G1 {A}}; my $g = G.parse("A,A");  say $g».Str;

[23:51] <camelia> rakudo-moar c880f1: OUTPUT«()␤»

[23:51] <pippo> m: grammar G {rule TOP {<G1>+ % ','}; token G1 {A}}; my $g = G.parse("A,A");  say $g<G1>».Str;

[23:51] <camelia> rakudo-moar c880f1: OUTPUT«[A A]␤»

[23:51] <psch> m: grammar G {rule TOP {<G1>+ % ','}; token G1 {A}}; my $g = G.parse("A,A");  say %($g)».Str;

[23:51] <camelia> rakudo-moar c880f1: OUTPUT«G1 => A␤»

[23:52] <pippo> m: grammar G {rule TOP {<G1>+ % ','}; token G1 {A}}; my $g = G.parse("A,A");  say $g<G1>.list;

[23:52] <camelia> rakudo-moar c880f1: OUTPUT«[｢A｣ ｢A｣]␤»

[23:52] <psch> maybe the lag was me all along, actually...

[23:52] *** olinkl joined
[23:53] <pippo> m: grammar G {rule TOP {<G1>+ % ','}; token G1 {A}}; my $g = G.parse("A,A");  say $g<G1>.list.perl;

[23:53] <camelia> rakudo-moar c880f1: OUTPUT«[Match.new(ast => Any, list => (), hash => Map.new(()), orig => "A,A", to => 1, from => 0), Match.new(ast => Any, list => (), hash => Map.new(()), orig => "A,A", to => 3, from => 2)]␤»

[23:53] <pippo> m: grammar G {rule TOP {<G1>+ % ','}; token G1 {A}}; my $g = G.parse("A,A");  say $g<G1>.list.Str.perl;

[23:53] <camelia> rakudo-moar c880f1: OUTPUT«"A A"␤»

[23:53] <psch> m: grammar G {rule TOP {<G1>+ % ','}; token G1 {A}}; my $g = G.parse("A,A");  say $g.caps>>.Str;

[23:53] <camelia> rakudo-moar c880f1: OUTPUT«(G1  A G1    A)␤»

[23:54] <pippo> m: grammar G {rule TOP {<G1>}; token G1 {A}}; my $g = G.parse("A");  say $g<G1>.list;

[23:54] <camelia> rakudo-moar c880f1: OUTPUT«()␤»

[23:54] <pippo> m: grammar G {rule TOP {<G1>}; token G1 {A}}; my $g = G.parse("A");  say $g<G1>.list.perl;

[23:54] <camelia> rakudo-moar c880f1: OUTPUT«()␤»

[23:55] <psch> pippo: the notable thing happening is that (1) >> coerces to Positional (i.e. calls .list) and (2) named captures aren't positional

[23:55] <psch> pippo: .list only makes sense when you know that you have multiple, not-matched-with-a-name captures

[23:55] <zengargoyle> m: grammar G {rule TOP {<G1>+ % ','}; token G1 {A}}; my $g = G.parse("A,A");  say $g{}>>.Str

[23:55] <camelia> rakudo-moar c880f1: OUTPUT«()␤»

[23:56] <Hotkeys> remember when I said last week that I wrote circumstantial with a k sound on my llinguistics midterm

[23:56] <Hotkeys> I lied

[23:56] <Hotkeys> that wasn't even on my midterm

[23:56] <Hotkeys> for some reason I thought I remembered it was

[23:57] <zengargoyle> m: grammar G {rule TOP {<G1>+ % ','}; token G1 {A}}; my $g = G.parse("A,A");  say $g.{*}

[23:57] <camelia> rakudo-moar c880f1: OUTPUT«(｢A｣ ｢A｣)␤»

[23:57] <zengargoyle> m: grammar G {rule TOP {<G1>+ % ','}; token G1 {A}}; my $g = G.parse("A,A");  say $g.{*}.values

[23:57] <camelia> rakudo-moar c880f1: OUTPUT«(｢A｣ ｢A｣)␤»

[23:57] <pippo> psch: I am parsing a file. And sometimes on a line there is one match and sometimes more. I wanted to get the values and push them on an array. The fact that it behaves differently if you have one or more than one match complicats things :-))

[23:57] <zengargoyle> m: grammar G {rule TOP {<G1>+ % ','}; token G1 {A}}; my $g = G.parse("A,A");  say $g.{*}.values>>.Str

[23:57] <camelia> rakudo-moar c880f1: OUTPUT«(A A)␤»

[23:58] <zengargoyle> m: grammar G {rule TOP {<G1>+ % ','}; token G1 {A}}; my $g = G.parse("A,A");  say ($g.{*}.values>>.Str).join("\n")

[23:58] <camelia> rakudo-moar c880f1: OUTPUT«A␤A␤»

[23:59] <psch> m: say (m/@<a>=A+/)<a> for <A AAAA AAAAAAA>

[23:59] <camelia> rakudo-moar c880f1: OUTPUT«｢A｣␤｢AAAA｣␤｢AAAAAAA｣␤»

