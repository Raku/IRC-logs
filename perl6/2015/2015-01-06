[00:01] <japhb> lizmat: re: p6weekly, The low-level concurrency test that crashes does so on *nqp-j*, not *nqp-p*.

[00:02] <japhb> On nqp-p, all of the concurrency tests should gracefully exit with a skip message.

[00:17] <vendethiel> masak: Shen is going BSD :-)

[00:17] <masak> vendethiel: "Shen"?

[00:18] <vendethiel> masak: lisp with incredibly nice type system :p

[00:18] <masak> oh, rings a weak bell.

[00:18] <vendethiel> masak: org

[00:18] <vendethiel> well.

[00:18] <masak> what does "going BSD" mean in this context? gains BSD support?

[00:18] <vendethiel> masak: http://www.shenlanguage.org/ better with full link

[00:18] <vendethiel> masak: open-source license ahead. code source and all

[00:19] <masak> ooh!

[00:19] <masak> right. licensing.

[00:19] <masak> what was it before? closed?

[00:19] <vendethiel> masak: the source code was very, very old, back when it was called Qi

[00:20] <masak> oh, Shen === Qi. got it.

[00:20] <vendethiel> masak: https://groups.google.com/forum/#!msg/qilang/e4-PcL2K2WQ/5OLaUdEFwXAJ

[00:20] *** jack_rabbit joined
[00:20] <masak> I was just thinking of macros, in a 007 context.

[00:20] <masak> I think I've discovered an important phenomenon, which I've provisionally called "stuttering".

[00:21] <masak> it doesn't happen in Lisp, because Lisp doesn't really have grammatical categories like Perl 6 and 007 do.

[00:21] <vendethiel> my keyboard does that as well :)

[00:22] <masak> reason it happen is this: say `foo()` is a macro call. it expands to a statement. that means a statement just expanded into the slot of an expression.

[00:22] <masak> in 007, that means Something Bad Happened.

[00:22] <masak> because statements can contain expressions, but statements cannot (arbitrarily) contain statements.

[00:23] <masak> so I think some part of the macro expansion has to go "ok, this came out a little wrongish, but we can fix this if we're just a wee bit lenient..."

[00:23] <moritz> why does the macro call expand to a statement?

[00:23] <masak> because a quasi block evaluates to an actual block is a statement.

[00:24] <masak> (sorry for writing using chaining verbs. it's late.)

[00:24] <moritz> in p6, blocks are expressions, right?

[00:25] <moritz> so it's a 007-only problem, I hope

[00:25] <masak> I suspect this is one of those cases where it depends on your definition of "are".

[00:25] <masak> anyway, it might be 007-specific in this case, but I think it's worth investigating.

[00:26] <masak> 007 is a small, closed universe, which might give clues about how to lay out macros in Perl 6.

[00:26] * vendethiel doesn't really follow

[00:26] <vendethiel> 007 is your perl6 macro thing?

[00:26] <masak> oh, it's a little language sergot++ and I built over Christmas.

[00:26] <masak> http://masak.github.io/007/

[00:26] <vendethiel> found it :)

[00:27] * vendethiel had a cat on his lap with a nice chair yesterday, felt like a bond villain

[00:27] <masak> I should add that 007 hasn't really reached its full potential yet. I feel about a dozen commits away from that.

[00:27] <moritz> masak: well, in p6 we even have a syntax thingy for turning statements into expressions, so the distinction seems to be syntax-only

[00:28] <vendethiel> okay, looking at what 007 does

[00:29] <masak> moritz: I think we're heading in a direction where in macros we need to care more about what the thing is we're inserting, and what the slot is we're inserting it into. at least the parser will want to care a lot.

[00:29] <moritz> masak: that's possible

[00:29] <masak> moritz: the trick is how to do this without it feeling restrictive/draconian to the user. grammar category stuttering sort of explores that a bit.

[00:30] <masak> it'll *definitly* be possible to insert a program fragment that doesn't fit. the compiler should complain in that case.

[00:31] <masak> like, what if you did `foo() + foo()`, with the `foo` macro expanding to a statement?

[00:31] <masak> now you have an expression with a binary operator adding two statements. bzzt.

[00:31] <adu> r: @("a", "b").join()

[00:31] <vendethiel> masak: so, it's "only" to try your Q:: AST you described me earlier? amazing!

[00:31] <camelia> rakudo-{parrot,moar} 80b912: ( no output )

[00:31] <adu> r: say @("a", "b").join()

[00:31] <camelia> rakudo-{parrot,moar} 80b912: OUTPUT«ab␤»

[00:32] <masak> vendethiel: yes!

[00:32] <vendethiel> okay, very glad that comes into form

[00:32] <masak> vendethiel: it's one big laboratory for playing with Q::

[00:32] <vendethiel> s/form/shape. pardon my french

[00:32] <masak> patches awesome^Wwelcome

[00:33] *** adu left
[00:34] <masak> another piece of terminology that has fallen out of 007 (but that I sort of mentioned on the channel while 007 was still secret): parsed ASTs versus synthetic ASTs.

[00:34] <masak> a parsed AST is one that comes from parsing code. like, with a quasi, or parsed as a macro parameter.

[00:35] *** sirdancealot joined
[00:35] <masak> a synthetic AST is one that you painstakingly put together by calling constructors on Q:: things.

[00:35] <vendethiel> .oO( syntactic AST )

[00:35] <vendethiel> ^ which is why you want quoting :P

[00:35] *** gfldex left
[00:35] <masak> the distinction is important, because some checks happen at parsing, and presumably synthetic ASTs will have to do those checks "later". like, at insertion time.

[00:36] *** gfldex joined
[00:36] <masak> from what I can see with my limited, not-standing-on-giants'-shoulders vision, synthetic ASTs also don't carry around an environment.

[00:37] <masak> (because you built them, and you didn't supply one.)

[00:38] <vendethiel> masak: you need some kind of environment for certain types of check, like type checking and other stuff

[00:38] <masak> oh, I'm not disputing that one bit.

[00:39] <masak> I'm just saying that synthetic ASTs are (sadly) born without them. so it goes.

[00:39] <moritz> I guess synthetic ASTs get their environments from the macro call site

[00:39] <vendethiel> well, you *need* to "pass" them somehow ;-)

[00:39] <masak> they have to be *given* an environment ALAP as they are inserted in some place.

[00:39] <masak> what moritz++ said.

[00:39] <vendethiel> scala macros carry around an "universe"

[00:39] <moritz> so that a Q::Var(:name<$blerg>) is like COMPILING::<$blerg>

[00:40] <masak> yeah, seems so.

[00:40] <masak> interesting.

[00:41] <moritz> is there a Q::Scope or so that introduces a new scope?

[00:41] <masak> (wanted: a verb describing the process of carrying out all the checks that the parser usually does, such as variable/type/function consistency, but that was never done one a synthetic AST until now.)

[00:41] <masak> moritz: in 007? nope.

[00:42] <moritz> I'm thinking of ways to create macro-private variables in synthetic ASTs without resolving to gensymming

[00:42] <moritz> "deferred checks"?

[00:42] <moritz> well, more like "deferred checking"

[00:43] <masak> ok, provisionally accepted.

[00:44] *** araujo left
[00:45] *** araujo joined
[00:47] <masak> I was thinking of something like "temper" or "toughen". the problem with arbitrary synthetic ASTs is that they are too "soft".

[00:47] <masak> interestingly, we have this problem in the 007 test suite, completely orthogonally from macros.

[00:48] <masak> right now parsing is responsible for creating static lexpads -- the deferred checks process would need to do that, too.

[00:49] <moritz> note that rakudo also only catches some form of undeclared symbol usages in the optimizer

[00:49] <masak> that's news to me but I'm not surprised.

[00:50] <moritz> usage of undeclared subroutines, iirc

[00:50] <moritz> hm, nope

[00:50] * vendethiel is too tired to follow

[00:50] <masak> thank blog for backlogs :)

[00:50] * masak will likely backlog this tomorrow

[00:51] * moritz tried to sleep, without much success :(

[00:51] <masak> aww

[01:16] <masak> actually, "checking" is probably the ideal term for what we're doing with the synthetic ASTs. because it ties in very well with the CHECK parser.

[01:18] <Mouq> masak: [007] "There is a difference, though: subroutines can return values, and blocks can't." does this mean that, unlike subs, blocks should return the last value by default?

[01:19] <masak> Mouq: no.

[01:19] <masak> Mouq: blocks always "return" None.

[01:20] <Mouq> So how do you write a map?

[01:20] <masak> Mouq: but (borrowing terminology from Perl 6 here) blocks don't really have a "return" operation at all. they just "leave". and in 007, they always "leave" None.

[01:20] <masak> Mouq: you pass the map a sub.

[01:21] <masak> Mouq: the only reason we have blocks in the first place is that they show up all over the place anyway. in `if`, `for`, `while`, etc.

[01:21] <masak> Mouq: but note that we don't expect any of those to have their own `return` operation.

[01:21] *** adu joined
[01:21] <masak> when they do (as with loops), they are called other things, with other keywords.

[01:21] <vendethiel> how hard would it be to implement "leave" :-)?

[01:22] <masak> vendethiel: hard. 007 doesn't expose control flow.

[01:22] <vendethiel> in perl6, I mean

[01:22] <vendethiel> .oO( did I mention you have to decrypt what I'm saying, for once? )

[01:22] <masak> I think Niecza might have it.

[01:22] <masak> n: say "OH HAI"

[01:22] <camelia> niecza v24-109-g48a8de3: OUTPUT«(signal ABRT)Stacktrace:␤␤  at <unknown> <0xffffffff>␤  at (wrapper managed-to-native) object.__icall_wrapper_mono_gc_alloc_string (intptr,intptr,int) <0xffffffff>␤  at (wrapper alloc) object.AllocString (intptr,int) <0xffffffff>␤  at string…»

[01:22] <masak> o.O

[01:22] <moritz> vendethiel: just a bit of codegen

[01:23] <moritz> masak: so return() from a block in 007 returns from the outer routine?

[01:23] <masak> yep.

[01:23] <masak> that's even mentioned in http://masak.github.io/007/

[01:23] <masak> which also means you can have the "stale subroutine" issue in 007.

[01:24] <Mouq> masak: K, well, just saying that ATM, you can't do, e.g., `map(sub { return 42 }, range(0, 20))` because sub is statement-level. Also because they can't be anonymous

[01:24] <masak> (subroutine returns an inner block, inner block contains a `return`, gets called, `return` has to fail because subroutine already exited)

[01:24] <masak> Mouq: all part of the plan.

[01:24] <Mouq> k

[01:24] <masak> Mouq: the invoncenience is there because 007 is not Perl 6. :)

[01:25] <masak> Mouq: Perl 6 goes out of its way to be convenient to the user.

[01:25] <masak> 007 is convenient to the person thinking about ASTs. :)

[01:25] <Mouq> masak: Fair lol, I just expected it to be more FP-oriented for some reason

[01:25] <masak> it is, but it has its own sort of harsh austerity to it.

[01:26] <Mouq> Gotcha :)

[01:26] <masak> I think the strict distinction between statement and expr will serve us well in the end.

[01:26] <masak> it will force us to consider certain boundaries sooner than if the language were more lax.

[01:34] <Mouq> masak: I have a lot of nit-picky questions I could spam you with :9 But one thing I'm not sure I totally get is why are there so many Q:: classes?

[01:35] *** yeahnoob joined
[01:35] <Mouq> masak: For example, with whatever syntax is come up with for it, when a user adds an infix (I assume such a thing would eventually be possible) do they have to create a Q::Infix::* class as well?

[01:36] <masak> they don't have to.

[01:36] <masak> this is where macros and slangs diverge, IMHO.

[01:37] <Mouq> okay

[01:37] <masak> as a Perl 6 end user, you just want to declare your awesome operator and get on with life. you decidedly don't want to mess with declaring new Q:: types.

[01:38] <masak> which means you get some kind of default under the hood. probably a generic Q::Infix of some kind.

[01:38] <masak> but as a slang author, you emphatically *do* care about Q:: types, and about creating your own.

[01:39] <masak> why? because you're probably gonna grep for them a lot in your own slang analysis code.

[01:39] <adu> Mouq: also, I noticed you're following C::Parser

[01:39] <masak> Mouq: you're correct in observing that the more specialized operator Q:: classes are strictly unnecessary.

[01:40] <masak> Mouq: the (unproven) idea behing that is that they're good handles for grepping.

[01:41] <masak> Mouq: i.e. it's more conenient to grep for `Q::Infix::Concat` than it is to grep for `Q::Infix where { .type eq '~' }`

[01:41] *** Hor|zon joined
[01:44] <lue> masak: I have to say, I think that's the first time I've heard of a language feature being designed with external utilities in mind :P .

[01:45] <masak> not really "external".

[01:45] <masak> remember, we're changing our Perl 6 program from within Perl 6 here.

[01:45] <masak> that's what macros are, basically.

[01:46] <masak> if they aren't that, then they're really no better than functions.

[01:46] <lue> I was referring to <masak> Mouq: the (unproven) idea behing that is that they're good handles for grepping.

[01:46] *** Hor|zon left
[01:46] <masak> aye.

[01:47] <masak> I mean grepping from inside of a macro in Perl 6 code.

[01:47] <masak> sorry if that was unclear :)

[01:47] <masak> well, s/Perl 6/007/ in this case.

[01:47] <masak> but the same principle applies for both languages.

[01:48] <adu> masak: I personally divide the world of programming into 4 distinctions: run-time expressions, declarations for run-time expressions, compile-time expressions, and declarations for compile-time expressions.

[01:48] <Mouq> I was going to suggest something like Q::Infix['~'] being the Q::Infix role/trait implemented for '~', but I was confusing my object systems :P

[01:48] <masak> adu: curious. I'll have to mull over that, I think.

[01:49] <masak> Mouq: also, that's not gonna cut it if you have two different infix:<~> operators defined in different scopes.

[01:49] <lue> To me,  where { .type eq '~' }  feels like you're doing something underhanded somehow, not so with  ::Concat

[01:49] <adu> masak: they correspond roughly to expressions, declarations, macros, and macro-transformers respectively

[01:49] <masak> Mouq: the symbol is not a unique-enough distinguisher for the operator.

[01:49] <Mouq> masak: Yeah

[01:49] <moritz> masak: the usual lookup rules apply, no?

[01:49] <masak> lue: indeed -- see my last point to Mouq.

[01:50] <masak> moritz: well, the problem (as usual) is that you're in two places at once: in the macro, and in the code being analyzed by the macro. the "default" lookup is from the macro itself, which is probably not what you want.

[01:50] <lue> But with Q::Infix::Concat, how would user-defined operators be referred to? Would have to make Q::Infix::Foo yourself?

[01:50] <masak> adu: interesting.

[01:51] <lue> s/Would have/Would you have/

[01:51] <Mouq> adu: Though "compile time" is even more divided here between "parse time" and "ast-building time"

[01:51] <masak> lue: yeah. haven't really thought that through.

[01:51] <adu> Mouq: oOo

[01:51] <masak> lue: the "logical" place to introduce the Q:: type would be with the definition of the new operator. but I'm not sure if that's a great idea.

[01:52] <masak> lue: also, funnily, 007 can't declare new types yet.

[01:52] <adu> Mouq: theoretically, any time a representation of a program is "touched" could be a chance to attach actions

[01:53] *** tinyblak left
[01:53] <lue> Q::Infix<~> may not be unique enough, but that doesn't seem any worse than  sub operator:infix<~>  on the surface.

[01:54] <masak> Mouq: currently in 007, AST building (and macro calls with their own AST building) happens as part of the parsing, not as a separate step.

[01:54] <Mouq> adu: True. C, for example, has it's Preprocessor stage as well

[01:54] *** tinyblak joined
[01:54] <masak> lue: the problem, as I mentioned to moritz, is that you're not *in* the environment you're analyzing. so lookup doesn't necessarily go to the right place.

[01:55] <adu> Mouq: Scheme and Rust both have excellent macro transformers

[01:55] <masak> lue: put differently, doing `&infix:<~>` in the program that the macro analyzes might give a different operator than doing `&infix:<~>` from the macro code.

[01:56] <adu> Mouq: C has a pretty bad macro transformer

[01:56] <lue> masak: Yeah. That suggests to me that things like operators may naturally require more information, unless there was some sane way of generating a default name (perhaps Q::Infix::Foo.pm6::L42 ??)

[01:56] <Mouq> masak: Maybe <~> wants to be namespaced, in that case

[01:57] <masak> lue: the name isn't necessary. there will always be a long way, like `Q::Infix where { ... }`

[01:57] <masak> lue: it's just that we provide convenient hooks for the operators that we know are there in the core language.

[01:58] <moritz> masak: I wonder how well you get along with the current model, and if at some point you'll have to stick a pointer to the environment into the Q:: nodes

[01:58] <masak> lue: of course, as always, we like to make it possible for the library author to feel that they are playing by the same rules as the language authors.

[01:58] * lue admittedly hasn't looked at 007 and related all that closely yet, she's just working from what's been mentioned so far :P .

[01:58] <masak> moritz: yes. that's what the `check` discussion was about.

[01:58] <moritz> masak: so that you can do a $q.scope.lookup('infix:<~>')

[01:58] <lue> Hearing that the  where {...}  will be available anyway makes me feel better about the various names the builtins would get :) .

[01:59] <masak> moritz: the main insight in the past few days is that synthetic ASTs were not created biologically, so they need to have an environment inseminated into them by artificial means.

[01:59] <masak> moritz: a ghost in the shell, if you will.

[02:00] <adu> masak: one of the reasons why I don't distinguish between expressions and statements is that there are too many places to "draw the line", for example, do you draw the line in the fact that statements have no return value? or the fact that expressions can be pure of side effects? or that statements generally require access to variable names, or at least mutable variables, but if the object is changing and not the variable, then statements 

[02:00] <adu> are equivalent to lambda calculus...

[02:00] <moritz> cells without connective tissue

[02:00] <masak> yeah.

[02:00] <masak> adu: all very good points. 007 is unapologetic in its opinions there.

[02:01] <masak> it strikes a balance that makes it easy to implement and do AST manipulations.

[02:03] <adu> masak: but decls are funky, you can't wrap up the universe in a lambda

[02:04] <masak> can I ask you to be more concrete? how is this a problem?

[02:05] <adu> so, when you declare something, you are creating a binding to an identifier, and the scope of that identifier is usually everywhere (minus all of the package/module stuff)

[02:06] <adu> with lambdas, the scope identifiers for the parameters are bound to is the lambda body

[02:06] <dalek> specs: 48af140 | TimToady++ | S02-bits.pod:

[02:06] <dalek> specs: Mention unspace disallowed in regex (except \#)

[02:06] <dalek> specs: 

[02:06] <dalek> specs: The current engine disallows unspace in regexex as too ambiguous.

[02:06] <dalek> specs: This is fine for actual whitespace, but is counterintuitive when people

[02:06] <dalek> specs: try to backslash the # character.  So \# is now specifically allowed

[02:06] <dalek> specs: to match a literal # character.

[02:06] <dalek> specs: review: https://github.com/perl6/specs/commit/48af140e23

[02:06] <adu> masak: hence, you can't wrap up the universe in a lambda

[02:06] <Mouq> TimToady: Ooo

[02:07] <dalek> nqp: b0a2372 | TimToady++ | src/QRegex/P6Regex/Grammar.nqp:

[02:07] <dalek> nqp: Allow \# in regex to match '#'

[02:07] <dalek> nqp: review: https://github.com/perl6/nqp/commit/b0a2372fe2

[02:07] <dalek> roast: b108dab | TimToady++ | S02-lexical-conventions/unspace.t:

[02:07] <dalek> roast: Test that \# is allowed in regex, and means '#'

[02:07] <dalek> roast: review: https://github.com/perl6/roast/commit/b108dab8bf

[02:07] <masak> adu: ok, I'll have to mull over that, too.

[02:08] <masak> :)

[02:08] <masak> 'night, #perl6

[02:08] <adu> :)

[02:08] <Mouq> 'night masak

[02:08] <vendethiel> 'night!

[02:08] <dalek> rakudo/nom: 2165a69 | TimToady++ | tools/build/NQP_REVISION:

[02:08] <dalek> rakudo/nom: bump nqp

[02:08] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/2165a69353

[02:09] <adu> anyways, classes and modules are examples

[02:10] <lue> ♞ masak o/

[02:18] *** chenryn joined
[02:23] *** rmgk_ joined
[02:23] *** rmgk left
[02:23] *** rmgk_ is now known as rmgk

[02:23] <moritz> TimToady++

[02:24] <moritz> it always felt weird that you could backslash non-word characters n regexes, except #

[02:51] *** kurahaupo1 joined
[02:57] *** kurahaupo1 left
[02:58] *** yeahnoob left
[03:09] *** raiph left
[03:11] *** yeahnoob joined
[03:11] *** yeahnoob left
[03:12] *** yeahnoob joined
[03:12] *** yeahnoob left
[03:12] *** yeahnoob joined
[03:13] *** yeahnoob left
[03:13] *** yeahnoob joined
[03:13] *** yeahnoob left
[03:14] *** yeahnoob joined
[03:14] *** yeahnoob left
[03:14] *** yeahnoob joined
[03:15] *** yeahnoob left
[03:15] *** yeahnoob joined
[03:15] *** yeahnoob left
[03:16] *** yeahnoob joined
[03:16] *** yeahnoob left
[03:16] *** yeahnoob joined
[03:16] *** yeahnoob left
[03:17] *** yeahnoob joined
[03:17] *** yeahnoob left
[03:17] *** yeahnoob joined
[03:17] *** yeahnoob left
[03:18] *** yeahnoob joined
[03:18] *** yeahnoob left
[03:18] *** yeahnoob joined
[03:19] *** yeahnoob left
[03:19] *** yeahnoob joined
[03:19] *** yeahnoob left
[03:19] *** yeahnoob joined
[03:20] *** yeahnoob left
[03:20] *** yeahnoob joined
[03:20] *** yeahnoob left
[03:21] *** yeahnoob joined
[03:21] *** yeahnoob left
[03:21] *** yeahnoob joined
[03:22] *** yeahnoob left
[03:22] *** yeahnoob joined
[03:22] *** yeahnoob left
[03:22] *** yeahnoob joined
[03:23] *** yeahnoob left
[03:30] *** Hor|zon joined
[03:34] *** Hor|zon left
[03:36] *** noganex_ joined
[03:39] *** noganex left
[03:40] *** fhelmberger joined
[03:42] *** tinyblak left
[03:43] *** tinyblak joined
[03:44] *** fhelmberger left
[03:48] *** konsolebox joined
[03:50] *** adu left
[03:56] *** kurahaupo1 joined
[04:06] *** anaeem1_ joined
[04:06] *** anaeem1_ left
[04:07] *** ssutch joined
[04:07] *** anaeem1_ joined
[04:10] *** Rounin joined
[04:10] *** raiph joined
[04:17] *** kaleem joined
[04:51] *** vendethiel left
[04:52] *** Rounin left
[04:56] *** hersoncr joined
[04:58] *** hersoncr left
[05:01] *** kaleem left
[05:03] *** adu joined
[05:03] *** chenryn left
[05:06] *** tinyblak_ joined
[05:08] *** tinyblak_ left
[05:08] *** tinyblak_ joined
[05:09] *** tinyblak left
[05:10] *** tinyblak joined
[05:13] *** tinyblak left
[05:13] *** tinyblak joined
[05:14] *** tinyblak_ left
[05:19] *** Hor|zon joined
[05:19] *** tinyblak_ joined
[05:20] *** tinyblak_ left
[05:20] *** tinyblak_ joined
[05:22] *** tinyblak left
[05:23] *** Hor|zon left
[05:26] *** chenryn joined
[05:33] *** raiph left
[05:47] *** sirdancealot left
[05:56] *** Rounin joined
[06:10] *** adu left
[06:12] *** sirdancealot joined
[06:40] *** adu joined
[06:49] *** mr-foobar left
[06:50] <FROGGS> adu: v5 has a lot (about 500) packages as Perl5::* because these are Perl 5 core modules, like List::Util and so on... most of them are just stubs though atm

[06:51] <adu> FROGGS: ok

[06:52] <FROGGS> the slang itself is Perl5.pm (for registering a module loader, grammar and actions), Perl5/Grammar.pm, */Actions.pm, */ModuleLoader.pm and */World.pm

[06:53] <adu> what is the purpose of World?

[06:53] <adu> oh "class Perl5::World;"

[06:53] <adu> I can do that

[06:53] <FROGGS> it mostly acts as a collection of helper functions... finding lexical variables, declaring these, merging symbols etc

[06:54] <adu> https://github.com/rakudo-p5/v5/blob/master/src/Perl5/World.pm

[06:54] <FROGGS> normally you just need the Foo.pm, Foo/Grammar.pm and Foo/Actions.pm, at least for a start

[06:54] <adu> FROGGS: ah, I call those modules {...}Utils

[06:55] <adu> well, I would if I were to write one

[06:55] <adu> my current Perl6 code probably has the God class anti-pattern

[06:55] <FROGGS> adu: it also keeps some values, so it builds up our worlds (that architecture is taken from Perl6/rakudo directly)

[06:57] <adu> so I got stuck on my C parser

[06:59] <adu> it now parses about 25% of glib/gbytes.c, but it gets stuck on "struct _GArray { ... } GArray", but then when I put that declaration in a separate file with the appropriate typedefs, then it parses correctly, and so I ran the whole file again and it got stuck again, I'm so confused

[06:59] <adu> it's almost like it's a buffer overflow problem

[07:02] *** kaleem joined
[07:03] <FROGGS> well, that's the problem of one pass parsing... probably this statement has several rules that could parse them, and the wrong one is picked

[07:05] <adu> possible

[07:08] *** Hor|zon joined
[07:11] <adu> FROGGS: I think I've done a pretty good job

[07:12] *** Hor|zon left
[07:16] *** Mouq left
[07:21] <adu> FROGGS: what is p6-Inline-C?

[07:29] <b2gills> I think that most of the stub Perl5::* modules should just be removed, and have v5 try to load the ones that are actually written in Perl5 as a way of finding bugs ( at least initially )

[07:30] *** xfix joined
[07:33] <FROGGS> b2gills: sort of, it helped having the stubs in place, to be able to run more of the spectest to get basic functionality in place

[07:33] <FROGGS> adu: it compiles a string of C to a dll, and makes it available via a perl 6 level subroutine

[07:33] *** Sqirrel left
[07:33] <FROGGS> adu: it passes it off to cc

[07:34] <adu> hmm

[07:34] <b2gills> The biggest problem I encountered was most Perl5 modules don't start with `use v5;`

[07:34] *** Mouq joined
[07:34] <adu> FROGGS: I wonder if it would be of any use to combine it with my C parser

[07:34] <FROGGS> well, I can fudge them... or we recognize the semicolon form pf package declarators

[07:34] <FROGGS> of*

[07:35] <FROGGS> adu: it would be very sweet to not have to put the C code in a string, so yeah, that'd be awesome

[07:35] <FROGGS> brb

[07:35] *** FROGGS left
[07:41] *** FROGGS[mobile] joined
[07:47] <moritz> \o

[07:48] *** tinyblak_ left
[07:48] *** rurban joined
[07:48] *** tinyblak joined
[07:54] *** FROGGS joined
[08:04] <FROGGS> hi moritz 

[08:04] *** zakharyas joined
[08:07] *** adu left
[08:08] *** vendethiel joined
[08:13] *** [Sno] left
[08:16] <moritz> 4 hours of sleep is not enough for me :(

[08:19] <FROGGS> :o(

[08:19] *** darutoko joined
[08:20] <FROGGS> I slept six hours on a beanbag chair, that's also not ideal as it turns out

[08:27] *** yeahnoob joined
[08:33] *** Mouq left
[08:36] *** tinyblak left
[08:38] *** Hor|zon joined
[08:42] <dalek> doc: ec60a18 | moritz++ | lib/Type/Supply.pod:

[08:42] <dalek> doc: Supply: explain on-demand vs. live supplies

[08:42] <dalek> doc: 

[08:42] <dalek> doc: partially taken directly from S17

[08:42] <dalek> doc: review: https://github.com/perl6/doc/commit/ec60a18967

[08:43] *** Hor|zon left
[08:44] *** tinyblak joined
[08:46] *** avalenn joined
[08:53] <arnsholt> adu 

[08:54] <arnsholt> Derp. Wifi hiccup

[09:01] *** [Sno] joined
[09:01] <FROGGS> pr0n

[09:02] <FROGGS> Ohh damn wigi hiccup :o)

[09:02] <FROGGS> wifi*

[09:02] *** virtualsue joined
[09:03] *** mvuets joined
[09:04] <lizmat> japhb++ for pointing out nqp-j crashes concurrency tests, rather than nqp-p

[09:08] *** Hor|zon joined
[09:08] *** tinyblak left
[09:08] *** tinyblak joined
[09:19] *** molaf_ joined
[09:23] *** molaf__ left
[09:27] *** vendethiel left
[09:29] *** sirdancealot left
[09:32] *** vendethiel joined
[09:32] *** yeahnoob left
[09:32] *** dakkar joined
[09:34] *** xinming_ left
[09:34] *** xinming joined
[09:37] *** xfix left
[09:40] *** telex left
[09:40] *** telex joined
[09:47] *** rindolf joined
[09:49] *** vendethiel left
[09:50] *** bjz joined
[09:50] *** tinyblak left
[09:50] *** tinyblak joined
[09:53] *** tinyblak left
[09:53] *** tinyblak joined
[09:55] *** bjz left
[09:58] *** JimmyZ joined
[09:58] <btyler_> answering my own question from yesterday: the problem I was having with Inline::Perl5 not finding libperl.so was -actually- libperl.so being from a perl version that was too old (5.14.2). hooking everything up with 5.18.2 and I::P5 worked perfectly out of the panda-box.

[10:00] *** tinyblak_ joined
[10:00] <btyler_> in particular, I::P5 looks for an identifier that's absent from 5.14's headers (av_top_index) but present in 5.18

[10:02] *** tinyblak left
[10:09] *** tinyblak_ left
[10:09] *** tinyblak joined
[10:18] *** bjz joined
[10:28] *** Psyche^ joined
[10:28] *** tinyblak left
[10:29] *** tinyblak joined
[10:32] *** cognominal left
[10:32] *** Patterner left
[10:32] *** cognominal joined
[10:33] *** chenryn left
[10:38] *** cognominal left
[10:47] *** denis_boyun_ joined
[10:49] *** chenryn joined
[10:52] *** andreoss joined
[10:54] <andreoss> grep {}, ... seems broken in latest build 

[10:54] <andreoss> m: my @x = grep {$_ < 5}, 1...100; say @x.perl;

[10:54] <camelia> rakudo-moar 80b912: OUTPUT«Array.new()␤»

[10:56] <andreoss> meanwhile

[10:56] <andreoss> m: my @x = grep {$_ < 5}, @(1...100); say @x.perl;

[10:56] <camelia> rakudo-moar 80b912: OUTPUT«Array.new(1, 2, 3, 4)␤»

[10:57] <psch> m: my @x = grep {$_ < 5}, 1..100; say @x.perl

[10:57] <camelia> rakudo-moar 80b912: OUTPUT«Array.new(1, 2, 3, 4)␤»

[10:57] <psch> infix:<...> is lazy i think

[10:57] <psch> although grep should probably reify that

[10:57] <psch> m: say (1...100).grep: {$_ < 5}

[10:57] <camelia> rakudo-moar 80b912: OUTPUT«1 2 3 4␤»

[10:57] <andreoss> psch: i think it worked some time ago

[10:58] <FROGGS> star-m: my @x = grep {$_ < 5}, 1...100; say @x.perl;

[10:58] <camelia> star-m 2014.12: OUTPUT«Array.new()␤»

[11:04] <psch> m: my @x = grep {$_ < 5}, eager 1...100; say @x.perl

[11:04] <camelia> rakudo-moar 80b912: OUTPUT«Array.new(1, 2, 3, 4)␤»

[11:05] <FROGGS> m: say grep * < 5, 1...100; say grep * < 5, eager 1...100

[11:05] <camelia> rakudo-moar 80b912: OUTPUT«␤1 2 3 4␤»

[11:06] <andreoss> why operations on lazy lists produce empty lists? 

[11:06] <FROGGS> andreoss: because it is a bug

[11:06] <FROGGS> and the bug is in grep somewhere...

[11:06] *** Alina-malina left
[11:08] <FROGGS> m: say map { $_ }, 1...100 # that's also funny

[11:08] <camelia> rakudo-moar 80b912: OUTPUT«Cannot call 'map'; none of these signatures match:␤:(&code, *@values)␤:(Whatever, Any \a)␤:(&code, Whatever)␤  in block <unit> at /tmp/sbAzBgGIk1:1␤␤»

[11:08] <FROGGS> m: say map { $_ }, 1..100 # but this works

[11:08] <camelia> rakudo-moar 80b912: OUTPUT«1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 8…»

[11:08] <FROGGS> very strange

[11:08] <FROGGS> I wonder

[11:08] <FROGGS> m: say map { $_ }, (1...100)

[11:08] <camelia> rakudo-moar 80b912: OUTPUT«1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 8…»

[11:08] <FROGGS> ahh!

[11:08] <FROGGS> precedence

[11:09] <FROGGS> m: my @x = grep {$_ < 5}, (1...100); say @x.perl;

[11:09] <camelia> rakudo-moar 80b912: OUTPUT«Array.new(1, 2, 3, 4)␤»

[11:09] <FROGGS> andreoss: so, it is not a bug, just surprising

[11:10] <FROGGS> the ',' has a higher precedence than '...', to allow: 1, 2, 4 ... 32

[11:10] <FROGGS> so  grep {$_ < 5}, 1...100  ended up as: (grep {$_ < 5}, 1)...100

[11:11] *** Alina-malina joined
[11:11] <FROGGS> m: my @x = (grep {$_ < 5}, 1...100); say @x.perl;

[11:11] <camelia> rakudo-moar 80b912: OUTPUT«Array.new()␤»

[11:11] <FROGGS> m: say (grep {$_ < 5}, 1)...100

[11:11] <camelia> rakudo-moar 80b912: OUTPUT«1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 8…»

[11:11] <FROGGS> but then I'd expected this ---^

[11:13] <FROGGS> I guess it ends up being: grep (({$_ < 5}, 1)...100)

[11:13] <psch> m: say grep { $_ < 5 }, 1

[11:13] <camelia> rakudo-moar 80b912: OUTPUT«1␤»

[11:14] <FROGGS> m: say grep 1...2

[11:14] <camelia> rakudo-moar 80b912: OUTPUT«␤»

[11:14] <FROGGS> what should that do?

[11:14] <psch> m: say eager grep { $_ < 5 }, 1 ... 100

[11:14] <camelia> rakudo-moar 80b912: OUTPUT«␤»

[11:14] <Rounin> m: sub lol{eval("lol();");}; lol();

[11:14] <camelia> rakudo-moar 80b912: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/UAlFwxFW6y␤Undeclared routine:␤    eval used at line 1␤␤»

[11:14] <Rounin> Aw

[11:15] <FROGGS> Rounin: use single quotes?

[11:15] <Rounin> m: sub lol{eval('lol();');}; lol();

[11:15] <camelia> rakudo-moar 80b912: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/SUPfyfALMN␤Undeclared routine:␤    eval used at line 1␤␤»

[11:15] <psch> EVAL 

[11:15] <FROGGS> err, EVAL

[11:15] <Rounin> It doesn't like eval it seems

[11:15] <Rounin> m: sub lol{EVAL('lol();');}; lol();

[11:15] <Rounin> Something seems to be happening

[11:15] <FROGGS> a timeout

[11:15] *** tinyblak_ joined
[11:16] <camelia> rakudo-moar 80b912: OUTPUT«(timeout)»

[11:16] <Rounin> Ah :)

[11:16] <Rounin> Thanks, both of you

[11:16] *** andreoss left
[11:16] *** andreoss joined
[11:17] <FROGGS> m: sub foo { say 42 }; "foo()" # <--- that will call it, and will interpolate the result of foo() into the string

[11:17] <camelia> rakudo-moar 80b912: ( no output )

[11:17] <FROGGS> err

[11:17] <FROGGS> m: sub foo { say 42 }; say "foo()" # <--- that will call it, and will interpolate the result of foo() into the string

[11:17] <camelia> rakudo-moar 80b912: OUTPUT«foo()␤»

[11:17] <FROGGS> O.o

[11:17] <Rounin> :D

[11:17] <FROGGS> ohh, we need a block there, my bad :D

[11:17] <FROGGS> m: sub foo { say 42 }; say "{foo()}"

[11:17] <camelia> rakudo-moar 80b912: OUTPUT«42␤True␤»

[11:17] *** andreoss left
[11:18] <FROGGS> weird, I was (for unkown reasons) under the impression that ident+parens would be enough

[11:19] *** tinyblak left
[11:22] <psch> m: sub foo { say 42 }; "&foo()"

[11:22] <camelia> rakudo-moar 80b912: OUTPUT«42␤»

[11:22] <psch> m: sub foo { say 42 }; "&foo"

[11:22] <camelia> rakudo-moar 80b912: ( no output )

[11:24] <FROGGS[mobile]> ahh

[11:41] *** kaleem left
[11:44] <arnsholt> Anyone happen to know if a QAST::Var with :scope<package> will also be found by a ::Var with :scope<lexical>?

[11:48] <FROGGS> we have scope<package>?

[11:48] <FROGGS> arnsholt: do that: perl6-m --target=ast -e 'our $foo'

[11:49] <FROGGS> and look at the bind at the top

[11:49] <arnsholt> Thought we had. Maybe we don't

[11:49] <FROGGS> bbiab

[11:50] <arnsholt> Aha. We don't!

[11:50] <arnsholt> There's a top-level package object that stores it

[11:51] <arnsholt> So I'll probably have to do something similar to get Python's "global" to work properly

[11:54] *** Ugator joined
[11:54] *** bjz left
[11:54] *** bjz joined
[11:58] *** darutoko left
[12:10] *** sirdancealot joined
[12:13] *** eternaleye joined
[12:16] *** colomon left
[12:16] *** chenryn left
[12:23] *** bjz left
[12:25] <masak> good afternoon, #perl6

[12:26] <moritz> good noon, masak 

[12:26] <masak> moritz: thinking one more turn about synthetic ASTs and COMPILING::

[12:26] <masak> moritz: I think that kind of dishygiene is the wrong default.

[12:26] <masak> moritz: better to say that a synthetic AST has *no* outer.

[12:27] <masak> and then we could very well provide an .attach (magic) method on synthetic ASTs, that you could call *once* and it'd get the caller's outer.

[12:28] <masak> or, in Harry Potter terms, you can only apparate to places you've been.

[12:28] <moritz> :-)

[12:28] <masak> (which is still very powerful a notion, when you multiply in passing ASTs to closures)

[12:29] <moritz> or supply a :scope on the outer-most Q::Thingy.new()

[12:29] <moritz> *to

[12:31] <masak> I don't immediately like that alternative better.

[12:31] <masak> scopes aren't first-class, so one'd have to pass in a callable or something.

[12:31] <masak> I think .attach is a little easier to think about. "pretend the AST is rooted *here*."

[12:32] <moritz> agreed

[12:32] <lizmat> reading all this, I can't help but think "coro's"

[12:32] <lizmat> is that a mistake ?

[12:32] <moritz> though we have to take care that scopes, not being first-class, don't become magical

[12:33] *** colomon joined
[12:44] <masak> moritz: indeed.

[12:44] *** bjz joined
[12:44] <masak> moritz: I don't see the bottom, but this rabbit hole looks promising.

[12:45] <lizmat> .oO( oh no, he's going to fall all the way to China :-)

[12:45] <masak> lizmat: dunno if it's a mistake or not. quasis and ASTs are a little bit like a lot of things.

[12:45] <lizmat> it also reminds me of a similar issue with perl 5 ithreads

[12:46] <masak> lizmat: they are a little bit like closures, too. except closures doesn't have the failure modes ASTs do.

[12:46] <lizmat> yeah, gotcha

[12:46] <masak> lizmat: and oftentimes I get the feeling that while closures have *one* surrounding context, ASTs have *two*. I have yet to formalize/concretize that.

[12:47] <lizmat> one of my Perl 5 ithreads modules started a thread at BEGIN time, simply to get a relatively "clean" thread from which to start other threads

[12:47] <masak> hygiene hinges on not crossing the streams of the two contexts.

[12:47] *** kaleem joined
[12:47] <lizmat> but that had more to do with the Perl 5 ithreads implementation

[12:47] <lizmat> (which uses the fork() emulation of Perl on Windows to emulate threads on Unix)

[12:48] *** kaare__ joined
[12:53] *** bjz left
[12:54] *** anaeem1_ left
[12:55] *** tinyblak_ left
[12:55] *** tinyblak joined
[12:59] <masak> coroutines: "you have code A and code B, possibly by different authors, and we allow them to interleave effortlessly in dynamic execution"

[12:59] <masak> ASTs/macros/quasis: "you have code A and code B, possibly by different authors, and we allow them to interleave effortlessly in the textual representation of the program"

[12:59] <masak> maybe that's the similarity.

[13:00] *** tinyblak_ joined
[13:00] <lizmat> possibly, I usually don't understand why things prop up in my mind when reading  :)

[13:02] *** tinyblak left
[13:03] *** eternaleye left
[13:07] *** eternaleye joined
[13:13] *** Sqirrel joined
[13:17] *** vendethiel joined
[13:18] <FROGGS> masak: did you already think about the distinction between a slang and a macro?

[13:18] <FROGGS> ... and at what time they come into play

[13:19] <FROGGS> because for me, a slang hooks in before we parse anything, though it probably has access to the current language(s) and can mess with them

[13:20] <FROGGS> macros come into play after the source was parsed, and after the ast was built, so their input is an AST, where a slang is still in charge to actually built an ast

[13:20] *** bjz joined
[13:22] *** tinyblak_ left
[13:23] *** tinyblak joined
[13:23] <FROGGS[mobile]> masak: do you agree?

[13:23] *** FROGGS left
[13:28] *** tinyblak left
[13:30] <masak> I think I agree, yes.

[13:30] <masak> though I am experiencing with notions of letting a macro do its own parsing sometimes.

[13:31] <masak> this is especially attractive (and perhaps necessary) for things like prefix and infix operators, where (some of) the arguments aren't ASTs yet.

[13:31] <masak> and in this sense, a macro could probably be seen as a "slang lite".

[13:32] *** tinyblak joined
[13:33] <lizmat> .oO( a slite )

[13:34] *** Akagi201 left
[13:35] *** anaeem1_ joined
[13:38] <dalek> rakudo/nom: 3c9fd0e | lizmat++ | src/core/Inc.pm:

[13:38] <dalek> rakudo/nom: Fix another precomp issue

[13:38] <dalek> rakudo/nom: 

[13:38] <dalek> rakudo/nom: Apparently, we need $*DISTRO to be populated to create valid precomp on Moar

[13:38] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/3c9fd0ed8d

[13:38] <dalek> rakudo/nom: 5fb9467 | lizmat++ | src/core/CompUnit.pm:

[13:38] <dalek> rakudo/nom: Allow specification of @*INC in CompUnit.precomp again

[13:38] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/5fb9467456

[13:39] *** vendethiel left
[13:41] *** denis_boyun_ left
[13:41] *** bjz left
[13:42] *** denis_boyun_ joined
[13:44] *** anaeem1_ left
[13:44] *** bjz joined
[13:45] *** anaeem1 joined
[13:46] <dalek> rakudo/nom: 370b3cd | lizmat++ | src/core/Inc.pm:

[13:46] <dalek> rakudo/nom: Actually, it appears we only need $*VM on Moar

[13:46] <dalek> rakudo/nom: 

[13:46] <dalek> rakudo/nom: To be able to create valid precomp

[13:46] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/370b3cde88

[13:47] <btyler_> is there any expectation that Inline::Perl5 is threadsafe, or not so much? trying to hack up a multithreaded DB client based on p5 libraries, and getting SIGSEGVs/"attempt to free unreferenced scalar"

[13:47] <lizmat> nine could probably tell you more

[13:48] <lizmat> btyler_: are you using ithreads for that, or lower level OS threads ?

[13:48] <btyler_> cool, I'll try it out on some personal code this evening, try to set up a minimal case

[13:50] <btyler_> lizmat: await (list of DB ids).map: -> $id { start { say "getting $id"; <corporate code db library>.retrieve($id) } }

[13:50] <lizmat> btyler_: that *feels* like pushing the envelope there....

[13:50] <btyler_> just playing around a bit, I got some simple db access working yesterday with Inline::Perl5 and was very excited

[13:51] <lizmat> btyler_++

[13:51] *** vendethiel joined
[13:52] <dalek> rakudo/newio: 353141f | lizmat++ | src/core/Deprecations.pm:

[13:52] <dalek> rakudo/newio: s/some time/sometime/  woolfy++

[13:52] <dalek> rakudo/newio: review: https://github.com/rakudo/rakudo/commit/353141fb34

[13:52] <dalek> rakudo/newio: 2165a69 | TimToady++ | tools/build/NQP_REVISION:

[13:52] <dalek> rakudo/newio: bump nqp

[13:52] <dalek> rakudo/newio: review: https://github.com/rakudo/rakudo/commit/2165a69353

[13:52] <dalek> rakudo/newio: 3c9fd0e | lizmat++ | src/core/Inc.pm:

[13:52] <dalek> rakudo/newio: Fix another precomp issue

[13:52] <dalek> rakudo/newio: 

[13:52] <dalek> rakudo/newio: Apparently, we need $*DISTRO to be populated to create valid precomp on Moar

[13:52] <dalek> rakudo/newio: review: https://github.com/rakudo/rakudo/commit/3c9fd0ed8d

[13:52] <dalek> rakudo/newio: 5fb9467 | lizmat++ | src/core/CompUnit.pm:

[13:52] <dalek> rakudo/newio: Allow specification of @*INC in CompUnit.precomp again

[13:52] <dalek> rakudo/newio: review: https://github.com/rakudo/rakudo/commit/5fb9467456

[13:52] <dalek> rakudo/newio: 370b3cd | lizmat++ | src/core/Inc.pm:

[13:52] <dalek> rakudo/newio: Actually, it appears we only need $*VM on Moar

[13:52] <dalek> rakudo/newio: 

[13:52] <dalek> rakudo/newio: To be able to create valid precomp

[13:52] <dalek> rakudo/newio: review: https://github.com/rakudo/rakudo/commit/370b3cde88

[13:52] <dalek> rakudo/newio: d63bb37 | lizmat++ | / (3 files):

[13:52] <dalek> rakudo/newio: Merge branch 'nom' into newio

[13:52] <dalek> rakudo/newio: review: https://github.com/rakudo/rakudo/commit/d63bb373de

[13:52] <lizmat> afk for a bit&

[13:54] *** bjz left
[13:54] *** chenryn joined
[13:55] *** Rounin left
[13:57] *** eternaleye left
[13:58] *** Sqirrel left
[13:59] *** FROGGS joined
[14:01] *** mvuets left
[14:05] *** ptc_p6 joined
[14:06] *** ptc_p6 left
[14:12] *** eternaleye joined
[14:26] *** bjz joined
[14:28] *** tinyblak left
[14:32] <dalek> roast: b2ffd2f | lizmat++ | S10-packages/precompilation.t:

[14:32] <dalek> roast: We don't need to specify PERL6LIB anymore

[14:32] <dalek> roast: review: https://github.com/perl6/roast/commit/b2ffd2f031

[14:34] *** skids left
[14:41] <dalek> roast/newio: da2561a | usev6++ | S03-metaops/reverse.t:

[14:41] <dalek> roast/newio: Add test for RT #118793

[14:41] <dalek> roast/newio: review: https://github.com/perl6/roast/commit/da2561a8b6

[14:41] <dalek> roast/newio: 700e0a5 | lizmat++ | S10-packages/precompilation.t:

[14:41] <dalek> roast/newio: Revert "Should work with just @*INC"

[14:41] *** dalek left
[14:41] <synopsebot> Link: https://rt.perl.org/rt3//Public/Bug/Display.html?id=118793

[14:41] <lizmat> sorry dalek

[14:41] *** dalek joined
[14:41] *** ChanServ sets mode: +v dalek

[14:48] <FROGGS> moritz: what do you think would that do: shell 'ls -l', :err(*.out)

[14:48] <FROGGS> (as the potentially new api)

[14:50] <[Coke]> if I want to use a perl from perlbrew in cron, do I need anything other than the PATH?

[14:52] *** bjz left
[14:52] *** anaeem1 left
[14:54] <FROGGS> [Coke]: look at that: https://github.com/agorman/perlbrew-cron

[14:54] <dalek> rakudo/nom: 0154f13 | lizmat++ | src/core/CompUnit.pm:

[14:54] <dalek> rakudo/nom: Allow scalar values to be specified with :INC

[14:54] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/0154f13aa3

[14:54] *** anaeem1_ joined
[15:00] *** virtualsue left
[15:00] *** FROGGS[mobile] left
[15:00] <lizmat> commute to Amsterdam.pm meeting&

[15:01] *** vendethiel left
[15:01] *** adu joined
[15:03] *** eternaleye left
[15:04] *** vendethiel joined
[15:06] *** bjz joined
[15:14] *** eternaleye joined
[15:14] <masak> FROGGS: what other values make sense to pass to :err, besides *.out ?

[15:15] <FROGGS> that'd be a hint :o)

[15:15] *** [Sno] left
[15:15] *** kurahaupo1 left
[15:15] <masak> no, I'm seriously wondering.

[15:15] <FROGGS> but.... :err would be valid, also :err($fh) and :err($*OUT) for example

[15:16] *** [Sno] joined
[15:16] <masak> ok.

[15:16] <FROGGS> default would be :!err I guess

[15:16] <FROGGS> dunno if that is a P5 thinking or state of the art

[15:16] <masak> ah, so :err would mean :err($*ERR) ?

[15:16] <FROGGS> no

[15:17] <masak> what would it mean?

[15:17] <FROGGS> it just means: yes, I wanna capture the children's stderr

[15:18] <FROGGS> to for example do: shell('foo --bar', :err).pipe-to( shell... )

[15:18] *** anaeem1_ left
[15:18] <FROGGS> more like this I think: shell('foo --bar', :err).pipe-to({ shell...  })

[15:19] <masak> oh, I think I see.

[15:19] <FROGGS> because it would make a new $*IN to the second shell evailable

[15:19] <FROGGS> ... which is the stderr of the first

[15:20] <betterwo1ld> r: class C { method foo { () }}; C.new.+foo

[15:20] <camelia> rakudo-moar 80b912: OUTPUT«No such method 'foo' for invocant of type 'C'␤  in method dispatch:<.+> at src/gen/m-CORE.setting:1334␤  in block <unit> at /tmp/tmpfile:1␤␤»

[15:20] <camelia> ..rakudo-parrot 80b912: OUTPUT«No such method 'foo' for invocant of type 'C'␤  in method dispatch:<.+> at gen/parrot/CORE.setting:1338␤  in block <unit> at /tmp/tmpfile:1␤␤»

[15:20] <betterwo1ld> that looks like rakudo tries to check if the method exists, but actually it checks whether it returns any values

[15:21] <FROGGS> masak: so is that self explaining? shell 'ls -l', :err(*.out)

[15:22] *** bjz left
[15:23] *** bjz joined
[15:26] *** bjz left
[15:27] *** vendethiel left
[15:27] *** bjz joined
[15:30] *** kurahaupo joined
[15:31] *** treehug88 joined
[15:33] <masak> FROGGS: when I first saw it, I had an idea what it might mean, but I was mystified as to the mechanism that made *.out do the right thing...

[15:35] <FROGGS> well, it is a callable so we pass the (to be constructed) Proc::Status

[15:35] <masak> oh, ok.

[15:36] <FROGGS> so it is meant to be 2>&1

[15:36] <masak> yes. that's the original meaning I got from it.

[15:36] <FROGGS> k

[15:36] <FROGGS> that's what I wanted to achieve :o)

[15:36] <masak> the reason I asked about other things that can be passed to :err, is that 2>&1 is what I *overwhelmingly* do, and I was wondering if you were perhaps overgeneralizing that very common use case.

[15:37] *** treehug88 left
[15:37] <masak> and should maybe have :err2out or something instead.

[15:37] *** vendethiel joined
[15:37] <FROGGS> or let that be the default?

[15:37] *** eternaleye left
[15:38] *** konsolebox left
[15:38] *** chenryn left
[15:38] *** sirdancealot left
[15:38] <FROGGS> I mean, we are strict by default, why should we sweep the error messages under the rug then?

[15:39] <FROGGS> but then the question is: what do we do with :out by default... print it?

[15:40] <FROGGS> and all these in/err/out fiddling results in one important decision: do we nqp::openpipe or do we nqp::shell / nqp::run

[15:40] *** eternaleye joined
[15:41] *** chenryn joined
[15:44] *** virtualsue joined
[15:49] *** treehug88 joined
[15:51] *** rurban left
[15:52] *** darutoko joined
[15:53] <ugexe> lizmat++ for bringing back rakudo_precomp_with stuff

[15:53] *** eternaleye left
[15:54] *** bjz left
[15:55] *** eternaleye joined
[15:55] *** treehug88 left
[15:56] *** treehug88 joined
[15:56] *** araujo left
[15:56] *** itz_ joined
[15:56] *** kaleem left
[15:58] *** vendethiel left
[16:01] *** bjz joined
[16:02] *** eternaleye left
[16:04] *** araujo joined
[16:04] *** araujo left
[16:04] *** araujo joined
[16:05] *** kaare__ left
[16:06] *** anaeem1_ joined
[16:06] <ugexe> after installing panda, i did 'panda install JSON::Tiny' (i know it gets installed with panda but still) and am getting const_iX NYI in sub to-json

[16:08] <FROGGS> hmmmm, I've seen a ticket about that recently...

[16:09] *** anaeem1_ left
[16:09] <ugexe> at the end it says SORRY! Missing or wrong version of dependency 'lib/JSON/Tiny.pm'

[16:09] <FROGGS> ugexe: can you upgrade your moarvm installation?

[16:09] <ugexe> is panda linking to an old version maybe?

[16:09] <FROGGS> well, it is your box :o)

[16:09] <ugexe> FROGGS: i just reinstalled the latest of rakudo/moar/nqp

[16:09] *** anaeem1_ joined
[16:09] *** denis_boyun_ left
[16:10] *** skids joined
[16:10] <FROGGS> let me try to reproduce

[16:11] <ugexe> my exact command line dance: sudo rm -rf moar-HEAD-HEAD-HEAD; rakudobrew triple; rakudobrew build-panda; panda install HTTP::UserAgent IO::Socket::SSL JSON::Tiny

[16:13] *** anaeem1_ left
[16:13] *** bjz left
[16:24] *** zakharyas left
[16:24] *** eternaleye joined
[16:27] *** Mouq joined
[16:31] *** bjz joined
[16:33] *** treehug88 left
[16:33] <Mouq> masak: re: http://irclog.perlgeek.de/perl6/2015-01-06#i_9894349 perhaps in this sense, it's more important to nail down the more general case, slangs, first, and then worry about the special cases like macro infixes...

[16:34] <masak> maybe, maybe not.

[16:34] <masak> the notion of "nail down X before Y" is not so well-defined in a whirlpool design process.

[16:34] <TimToady> .oO(make sure you have a story about it)

[16:34] *** spider-mario joined
[16:35] <masak> yeah.

[16:36] *** treehug88 joined
[16:39] *** kaleem joined
[16:39] *** vendethiel joined
[16:41] <FROGGS> ugexe: I can reproduce you problem:

[16:41] <FROGGS> Copying blib/lib/JSON/Tiny/Actions.pm.moarvm to /home/froggs/dev/nqp/install/languages/perl6/site/lib/JSON/Tiny/Actions.pm.moarvm

[16:41] <FROGGS> const_iX NYI

[16:41] <FROGGS>   in sub to-json at /home/froggs/dev/nqp/install/languages/perl6/site/lib/JSON/Tiny.pm.moarvm:1572895

[16:41] <FROGGS>   in method flush-states at lib/Panda/Ecosystem.pm:16

[16:42] <FROGGS> bbiab

[16:42] *** bjz left
[16:43] <ugexe> the submodule JSON::Tiny in the panda repo is from like august... i suppose it could be broken on a newer rakudo so it cant install a more modern json::tiny?

[16:45] <ugexe> Bytecode validation error at offset 4, instruction 2:

[16:45] <ugexe> operand type 16 does not match register type 64 in method flush-states at lib/Panda/Ecosystem.pm:16

[16:52] *** bjz joined
[16:53] <masak> Mouq: secondly, my main concern is macros. I don't mind discussing things with whatever group of people are figuring out slangs, but I won't figure out slangs on my own just to be able to get to macros. ;)

[16:54] *** rurban joined
[16:57] <TimToady> well, we'll just take whatever semantics you figure out and poke them into a 'make' :)

[16:57] *** mr-foobar joined
[16:58] <TimToady> or a make-oid

[17:04] * flussence notes aloud that HTML in current browsers now has a real "import" mechanism, complete with scoping and exports, while JS *still* has nothing of the sort...

[17:05] <vendethiel> o/, #perl6

[17:05] * vendethiel still would like "make" to be changed :p

[17:06] <[Coke]> ok. Pretty sure I have all the setup stuff done for perl6-roast-data to run on hack.

[17:06] <[Coke]> flussence: does require.js not cover it for you?

[17:08] <flussence> I know there's a million and one ways to make it work, I just find it funny the programming language is the only one without batteries included :)

[17:09] *** kaleem left
[17:21] <moritz> public service announcement: I've just configured the cyphers/MACs that sshd on hack.p6c.org will accept; if you experience ssh connectivity issues, please let me know

[17:22] <moritz> compare https://stribika.github.io/2015/01/04/secure-secure-shell.html

[17:22] *** bjz left
[17:23] *** bjz_ joined
[17:23] * TimToady thinks of macros as a planned hyperspace bypass, and this is the point at which we want to make sure the plans put the on and off ramps near Planet Perl, such that the bypass wipes out something else like Planet QAST instead of Planet Perl.

[17:23] <[Coke]> moritz: tested, seems fine here.

[17:23] <moritz> [Coke]: thanks

[17:25] * TimToady thinks about how best to bribe the Macro Planning Commission...

[17:28] <moritz> TimToady: bribe them with a working design? :-)

[17:29] <pyrimidine> Is there any way I can run debugging or some stack tracing on panda?  I'm seeing odd issues off my laptop where it hangs when trying to grab the latest projects.json.

[17:29] <pyrimidine> Seems to be something to do with IO::Socket::INET.  It doesn't time out, strangely

[17:31] <pyrimidine> Only thing I can trace it back to is the switch from feather to the new http://ecosystem-api.p6c.org

[17:32] <ugexe> add --ll-exception to panda's shell command and run rebootstrap.pl

[17:33] <moritz> pyrimidine: can you wget http://ecosystem-api.p6c.org/projects.json without any problem?

[17:33] <pyrimidine> moritz: yep, and placing it in the panda install folder fixes the problem

[17:35] *** chenryn left
[17:35] <pyrimidine> moritz: odd thing is, my desktop (imac) works fine

[17:35] <pyrimidine> Seems like it's maybe a port issue on the laptop; both are Mac OS X

[17:36] <pyrimidine> if I switch the URL in panda to the old one (feather) it also works.

[17:37] <ugexe> m: $s = IO::Socket::INET.new(:host<ecosystem-api.p6c.org>, :port(80)); $s.send("GET /projects.json HTTP/1.0\nHost: ecosystem-api.p6c.org\n\n");

[17:37] <camelia> rakudo-moar 80b912: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/palJZ0lrPq␤Variable '$s' is not declared␤at /tmp/palJZ0lrPq:1␤------> [32m$s[33m⏏[31m = IO::Socket::INET.new(:host<ecosystem-[0m␤    expecting any of:␤        postfix␤»

[17:37] <moritz> ugexe: camelia disables most forms of IO

[17:37] <ugexe> m: my $s = IO::Socket::INET.new(:host<ecosystem-api.p6c.org>, :port(80)); $s.send("GET /projects.json HTTP/1.0\nHost: ecosystem-api.p6c.org\n\n");

[17:37] <camelia> rakudo-moar 80b912: ( no output )

[17:38] <ugexe> i used to be able to test feather a month ago that way

[17:38] <ugexe> when the DNS stuff changed

[17:38] <moritz> huh.

[17:39] <moritz> that's not good.

[17:39] <masak> TimToady: finding out what macros mean *for Perl* and *in Perl* is very much what I feel I'm currently doing. :)

[17:39] *** virtualsue left
[17:39] *** [Sno] left
[17:40] <masak> even if it were possible to give Perl C's macro system, or Lisp's, or (I dunno) Dylan's, it would not be as fun as fitting the macro system to Perl's needs and capabilities.

[17:41] <ugexe> moritz: http://irclog.perlgeek.de/perl6/2014-11-29#i_9736137

[17:41] <vendethiel> dylan's is prrtty much lisp's

[17:41] <masak> this is why I talk a fair bit about grammars. macros should acknowledge them in a number of ways that it couldn't really when S06 was written, because grammars weren't mature/solid enough.

[17:42] <flussence> moritz: that ssh article was very informative, thanks!

[17:42] <TimToady> having had an interchange rebuilt within three blocks of my house (took six years!), I'm just interested in how the local on and off ramps will look in my neighborhood :)

[17:42] <vendethiel> dya

[17:42] <vendethiel> uh; seems like I have two text fields in my irc window now...

[17:45] <Mouq> FROGGS: Hey, I seem to have gotten p6-Slangy *mostly* fixed

[17:47] *** xfix joined
[17:51] *** cognominal joined
[17:51] <Mouq> FROGGS: https://github.com/FROGGS/p6-Slangy/pull/1

[17:54] *** bjz_ left
[17:54] *** telex left
[17:56] *** telex joined
[17:56] *** bjz joined
[17:57] *** dakkar left
[18:01] *** anaeem1 joined
[18:01] *** denis_boyun_ joined
[18:04] *** eternaleye left
[18:05] *** Hor|zon left
[18:06] *** anaeem1 left
[18:12] *** eternaleye joined
[18:12] <tony-o> sergot_: does IO::Socket::SSL handle server connections?  from the code it appears to but the tests don't show it ..

[18:12] <yoleaux> 5 Jan 2015 09:24Z <azawawi> tony-o: https://github.com/tony-o/perl6-http-server-async/issues/7 is very strange since a sleep with non-zero value seems to break the implementation of .recv

[18:13] *** FROGGS_ joined
[18:13] <tony-o> sergot_: nvm, just saw the POD at the bottom of the src

[18:13] <tony-o> .tell azawawi that sounds more like a rakudo bug :-)

[18:13] <yoleaux> tony-o: I'll pass your message to azawawi.

[18:14] *** bjz left
[18:16] *** FROGGS left
[18:17] <FROGGS_> Mouq++

[18:17] *** FROGGS_ is now known as FROGGS

[18:21] *** bjz joined
[18:24] *** denis_boyun_ left
[18:27] *** [Sno] joined
[18:27] *** raiph joined
[18:30] *** jack_rabbit left
[18:35] *** anaeem1 joined
[18:52] *** bjz left
[18:54] <_sri> tony-o: how fast is your http server?

[18:55] <_sri> (compared to say, some perl5 server)

[18:56] <jdv79> p5 is still very much faster than p6 in general i think, right?

[18:56] <FROGGS> it is

[18:57] <jdv79> at least all the random p5 to p6 cmps i've done in the last few months have supported that

[18:57] <_sri> we were promised a production ready perl6 soonish! ;p

[18:57] <jdv79> soon != now

[18:57] <FROGGS> well, perhaps Perl 6 is faster when it comes to bigints and bignums

[18:57] <jdv79> i'm not sure that factors largely in a typical webserver scenario though;)

[18:58] <_sri> true, you still got 3 weeks https://fosdem.org/2015/schedule/event/get_ready_to_party/

[18:58] <FROGGS> and I don't think that Perl 6 is mostly there for webservers tbh

[18:59] <ugexe> yea last thing tony-o was trying to figure out how to prefork it

[18:59] <_sri> judgign by reactions from perl5 beginners on the mojolicious mailing list... expectations for the fosdem talk are super high

[19:00] <_sri> to the point where people start asking again if its worth learning perl5

[19:00] <jdv79> i think its safe to learn perl5 by now

[19:01] <masak> learning is never safe.

[19:01] <FROGGS> learning is always safe.

[19:01] *** bjz joined
[19:01] <FROGGS> :P

[19:01] <FROGGS> whatever safe means

[19:01] <jdv79> i was all excited to learn perl 6 "for real" a bit ago and then i noted that the json parsing is an order of mag slower or more than p5 so i lost some excitement

[19:02] *** Ugator left
[19:02] *** Hor|zon joined
[19:02] <jdv79> and that's using a c lib - the native parser is even worse

[19:03] <FROGGS> jdv79: well, I often have tears of pain in my eyes when I have to write P5 at work, because I know that the P6 code would be more readable and just a fraction in size

[19:03] <jdv79> size vs speed tradeoff thought right now...

[19:03] <ugexe> newbies should probably learn whatever language has a larger established code base... if they want a job anyway

[19:03] <jdv79> yeah, i can see that

[19:03] <_sri> perl5 is getting faster too

[19:03] <FROGGS> speed is not everything, at least for me... the apps we have at work tend to live at least ten years, so maintainability is pretty important

[19:03] *** eternaleye left
[19:04] <_sri> your average mojolicious app will be 30% faster with perl 5.22

[19:04] <FROGGS> that's a lot

[19:04] <jdv79> yeah but i can't write a web service that takes seconds to respond when cached when in p5 its a few hundred ms.

[19:04] <jdv79> if that

[19:06] <ugexe> you could always use nativecall with libmicrohttpd

[19:06] *** Hor|zon left
[19:06] *** notjack joined
[19:06] <ugexe> unless tony-o beats you to it

[19:06] <adu> how do I use a module so that only the last part if available?

[19:07] <_sri> haha

[19:07] <_sri> think i'd use Go or Rust instead then ;p

[19:07] <adu> _sri: why?

[19:07] <ugexe> well if i was writing a production app id probably use a production ready language too

[19:09] <_sri> adu: using perl6 to glue together a bunch of c libraries is not my definition of fun

[19:09] <arnsholt> Also, NAtiveCall still incurs non-trivial overhead

[19:09] <adu> _sri: are they gobject based libraries?

[19:09] <FROGGS> adu: "how do I use a module so that only the last part if available?" - can you restate that question?

[19:09] <_sri> adu: so, might as well use a lower level language that almost feels like a scripting language

[19:10] <jdv79> exactly.  an awesone json parser written in p6 would be fantastic.

[19:10] <adu> FROGGS: ok, when you write "use A::B::C;" then C::x is an error, but A::B::C::x works, but how do I write "C::x" and have it mean the same thing?

[19:11] <_sri> jdv79: but is that possible yet?

[19:11] <notjack> I'm not familiar with FOSDEM; will I be able to listen to Larry's talk online?

[19:11] *** rindolf left
[19:11] <_sri> jdv79: also, what is awesome?

[19:13] <FROGGS> adu: you could access x just like that if that helps...

[19:13] <FROGGS> m: my $foo := IO::Socket; say $foo.WHO<INET>

[19:13] <camelia> rakudo-moar 80b912: OUTPUT«(IO::Socket::INET)␤»

[19:13] <FROGGS> m: my $foo := IO::Socket; say $foo::<INET>

[19:13] <camelia> rakudo-moar 80b912: OUTPUT«Cannot call 'postcircumfix:<{ }>'; none of these signatures match:␤:(Any \SELF, Any \key)␤:(Any \SELF, Any \key, \ASSIGN)␤:(Any \SELF, Any \key, :BIND($BIND)!)␤:(Any \SELF, Any \key, Any :SINK($SINK)!, *%other)␤:(Any \SELF, Any \key, Any :delete(…»

[19:13] <FROGGS> hmmm

[19:13] <FROGGS> that's not really better I guess

[19:14] <FROGGS> m: my \foo := IO::Socket; say foo::<INET>

[19:14] <camelia> rakudo-moar 80b912: OUTPUT«(IO::Socket::INET)␤»

[19:14] <FROGGS> I'm not sure that I'd like it :o)

[19:14] <jdv79> _sri: no its not possible - very slow

[19:14] *** eternaleye joined
[19:14] * _sri has actually been experimenting with pure perl5 json parsers a lot

[19:14] <jdv79> because p6 grammars...

[19:15] *** bjz left
[19:15] <_sri> one surprising discovery was that single regex parsers (like the famous one merlyn wrote) are terribly slow in perl5

[19:15] <FROGGS> the grammar is not the slowest thing in JSON::Tiny atm... it is the actions

[19:16] <jdv79> imagine if p6 could handle json as good as p5's JSON::XS - that would just be cool to me

[19:16] <FROGGS> very true

[19:16] <_sri> made me wonder if grammar based parsers can actually ever be fast

[19:17] *** virtualsue joined
[19:17] *** liztormato joined
[19:17] <tony-o> _sri: there are some threading things that make the async server unstable, from simple benchmarks it looked like it was serving within ~10ms of nginx on the same machine serving a static file

[19:19] <liztormato> Why do we actually have IO::Socket::INET.new. Why not IO::Socket.new?

[19:20] <notjack> _sri: Since grammar-based parsers maximize information provided to the parsing engine, in theory (theory!) they should be the fastest, no?

[19:20] <PerlJam> _sri: I bet people wondered if Fortran would ever be fast too, then after a few decades of experience and optimizations, they were   :-)

[19:21] <PerlJam> *Fortran compilers 

[19:21] <PerlJam> (maybe :)

[19:21] *** lizmat joined
[19:22] *** liztormato left
[19:26] <PerlJam> notjack: There's probably some sort of law relating the relative speed of processing with all of the information versus having a few heuristics with incomplete information that would tell us that more information does not always mean faster

[19:27] <_sri> notjack: i don't know, i'm here to find out :)

[19:28] <notjack> PerlJam: I'm not an information-theorist (IANAIT) but it seems to me that there will be a trade-off triangle of some kind (information provided, processing speed, reliability or optimality of results) and you can choose to optimize two legs at the expense of the third

[19:29] <notjack> PerlJam: Certainly the heuristics you imagine will themselves embed information, which means it needn't be carried by the input itself (which is essentially the definition of heuristic)

[19:29] <flussence> lizmat: INET == ipv4 (and 6?), there's also various flavours of local sockets people might like to use

[19:30] <flussence> (plus, the name makes it very clear to a reader the code's doing network connections)

[19:30] *** bjz joined
[19:31] <notjack> I suppose if I can't watch the FOSDEM talk online, I might persuade TimToady to send me his slides afterwards?

[19:34] * masak laughs

[19:34] <ugexe> id be surprised if someone doesnt record it

[19:34] <lizmat> I'm pretty sure an attempt at recording and streaming will be made  :-)

[19:34] <jdv79> streaming would be excellent

[19:34] <PerlJam> masak: for some reason I mentally inserted "maniacally" at the end of your sentence.  It reads better that way  :)

[19:35] *** virtualsue left
[19:35] <lizmat> flussence: but would it really be a problem if IO::Socket would be the default, as it is the thing that people use most ?

[19:36] <masak> PerlJam: that's the modifier I was looking for -- thanks

[19:36] <flussence> hm, you're probably right...

[19:36] <PerlJam> lizmat: +1 to that

[19:37] <lizmat> ok, I'll spec it like that in the spec/newio branch

[19:37] <skids> flussence: IPv6 is "INET6" (or AF_INET6 in C).

[19:37] <flussence> ah, my bad.

[19:37] <moritz> wanted: UDP socket support

[19:38] <lizmat> moritz: PROTO_UDP is defined in IO::Socket::INET at the moment

[19:39] <lizmat> so what is missing

[19:39] <moritz> does it actually work? tests?

[19:39] <dalek> perl6-roast-data: 0df9205 | coke++ | / (5 files):

[19:39] <dalek> perl6-roast-data: today (automated commit)

[19:39] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/0df9205263

[19:39] <dalek> perl6-roast-data: cdc241a | coke++ | perl6_pass_rates.csv:

[19:39] <dalek> perl6-roast-data: note new location of test server.

[19:39] <dalek> perl6-roast-data: 

[19:39] <dalek> perl6-roast-data: moritz++

[19:39] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/cdc241acc7

[19:39] <lizmat> I have no idea...  I'm just the poor girl trying to make some sense of the current mess  :-)

[19:39] *** KCL_ joined
[19:41] <[Coke]> moritz++ finally have perl6-roast-data running out of a cron job again.

[19:42] *** krunen left
[19:42] * PerlJam just looked at socket.h ...

[19:42] <PerlJam> I didn't realize there were so many address families

[19:43] <skids> Yup.

[19:43] <lizmat> :-)

[19:43] <lizmat> but how many do people actually use?

[19:43] <skids> Without knowing it, or on purpose?

[19:43] <lizmat> :-)

[19:43] <lizmat> both  :-)

[19:44] <PerlJam> I've only ever used 2 or 3 in my own code (and i only knew of about 4)

[19:44] <moritz> on an unrelated tangent, I think I'd like to put some of /etc/ dirs from some of the new hsots on github

[19:44] <skids> About half of those I would say without knowing it.

[19:44] <moritz> any suggests for repo names? and should I add it to the perl6 org, or rather a new organizations for it?

[19:44] *** bjz left
[19:44] <moritz> *suggestions

[19:44] <lizmat> PF_LOCAL,PF_UNIX,PF_INET, PF_INET6, PF_MAX are the ones that IO::Socket::INET knows about atm

[19:46] <PerlJam> moritz: no suggestion on the name, but I think it should be part of perl6.org

[19:47] <PerlJam> er , ... you know what I mean :)

[19:47] <moritz> yes

[19:47] *** Sqirrel joined
[19:49] <FROGGS> p6c-etc ?

[19:50] <moritz> hack.p6c.org-etc maybe

[19:50] <FROGGS> a bit long, but it perhaps should be :o)

[19:51] <moritz> I guess including host key files would be a bad idea :-)

[19:51] <PerlJam> moritz: how were you planning on deploying the etc things?  Is there some tool like ingy's ... but for system files?

[19:51] <[Coke]> seen trying to run the r* daily test: https://gist.github.com/coke/fa0fa47728162f6b753c

[19:51] <PerlJam> moritz: or were you thinking of just doing it "by hand"?

[19:54] <moritz> PerlJam: I see it more as backup and history tracking than as a deployment tool

[19:54] *** bjz joined
[19:55] <moritz> PerlJam: hack.p6c.org uses etckeeper, the rest plain git repos

[19:55] <PerlJam> ah

[19:56] <dalek> star: a8a88f1 | FROGGS++ | tools/build/panda-state.p6:

[19:56] <dalek> star: unbreak hash initializer

[19:56] <dalek> star: review: https://github.com/rakudo/star/commit/a8a88f141c

[19:56] <FROGGS> [Coke]++

[19:56] <moritz> uhm

[19:57] <moritz> I just managed to kill hack's ssh keys

[19:57] <PerlJam> FROGGS: I would have just put a Nil before the ; and left the commented line alone to serve as an example for future mappings.

[19:59] <FROGGS> bad moritz!

[20:00] <FROGGS> PerlJam: too late :D

[20:02] <dalek> star: cc27628 | PerlJam++ | tools/build/panda-state.p6:

[20:02] <dalek> star: unbreak hash initializer better

[20:02] <dalek> star: review: https://github.com/rakudo/star/commit/cc27628007

[20:02] <PerlJam> no it's not!  :)

[20:03] <xfix> Wow, Perl 5.22 has <<>> operator that fixes a security issue in <>. I'm not sure what to think about it.

[20:03] *** Hor|zon joined
[20:04] <moritz> can somebody (preferably who hasn't tried in the last 10 minutes) try to log in into hack.p6c.org?

[20:04] <PerlJam> moritz: I just logged in successfully.

[20:04] <moritz> xfix: "why the fuck didn't they just fix <>, and cope with the fallout"?

[20:04] <moritz> PerlJam: ok, great

[20:04] *** eternaleye left
[20:04] <timotimo> me, too

[20:04] *** darutoko left
[20:05] <PerlJam> xfix: got a link to a description of <<>> ?

[20:05] <xfix> moritz, because the "security issue" is is considered a feature.

[20:05] <xfix> https://metacpan.org/pod/release/CORION/perl-5.21.7/pod/perl5215delta.pod#New-double-diamond-operator

[20:05] *** itz joined
[20:05] <PerlJam> thanks

[20:05] <xfix> In short, <> used two args open.

[20:05] <xfix> So if you specified argument like "|foo", it ran a program.

[20:05] <FROGGS> moritz: it worked

[20:05] <PerlJam> aye.  That's a feature I've used in the past too.

[20:06] <FROGGS> Please respect the code of conduct and the notice the disclaimers on

[20:06] <FROGGS> http://www.p6c.org/

[20:06] <FROGGS> Last login: Tue Dec 23 19:29:25 2014 from...

[20:07] *** itz_ left
[20:08] <pyrimidine> moritz++ # re: <>

[20:09] <[Coke]> am now getting Fetching roast

[20:09] <[Coke]> fatal: unable to access 'https://github.com/perl6/roast.git/': Problem with the SSL CA cert (path? access rights?)

[20:09] <xfix> But yeah, this <> behaviour always bothered me.

[20:10] <xfix> Leading me to manually open the specified files, and special case - file.

[20:11] <[Coke]> that's just on a git clone on p6c now.

[20:12] <moritz> [Coke]: my fault

[20:13] <moritz> fixing...

[20:14] <moritz> [Coke]: please try again

[20:15] <[Coke]> moritz++

[20:20] <tony-o> sergot_: ping

[20:21] <PerlJam> moritz is now like Microsoft ... he gets credit for fixing problems that he created  ;)

[20:21] *** eternaleye joined
[20:21] <flussence> xfix: it's not enough to special case "-", you need to make sure the code's opening an on-disk file too, or else someone can just pass "/dev/stdin".

[20:21] <xfix> flussence, That doesn't concern me.

[20:22] <xfix> The reason why I did that is to allow people to use files named '    abc' or '|cab'.

[20:22] <dalek> snake: 13e935e | arnsholt++ | src/Snake/Actions.nqp:

[20:22] <dalek> snake: Towards a better variable model implementation.

[20:22] <dalek> snake: review: https://github.com/arnsholt/snake/commit/13e935e3dd

[20:24] *** bjz left
[20:24] <flussence> oh right, whitelisting -, not blacklisting...

[20:24] <adu> ahh, much better

[20:24] <adu> http://pastie.org/9816859

[20:25] <xfix> flussence, yes, I wanted it to behave more like UNIX utilies.

[20:25] <xfix> utilities*

[20:35] *** bjz joined
[20:42] <jnthn> evening, #perl6

[20:43] <vendethiel> o/, jnthn

[20:43] *** bjz left
[20:43] <[Coke]> this appears to be hanging in the rakudo star daily build:

[20:43] <[Coke]> /home/coke/sandbox/rakudo-star-daily/star-parrot/rakudo-star-daily/install/bin/perl6-p --target=pir --output=/home/coke/sandbox/rakudo-star-daily/star-parrot/rakudo-star-daily/install/lib/6.11.0-devel/languages/perl6/lib/Pod/To/HTML.pm.pir /home/coke/sandbox/rakudo-star-daily/star-parrot/rakudo-star-daily/install/lib/6.11.0-devel/languages/perl6/lib/Pod/To/HTML.pm

[20:44] <moritz> [Coke]: yes, I found that too :(

[20:44] <[Coke]> currently taking up 15.7% of memory on hack

[20:44] <[Coke]> so, that's the current blocker to getting the daily star stuff building again.

[20:45] * [Coke] kills the run.

[20:48] *** kaare__ joined
[20:49] <ugexe> is the order modules get compiled in using CompUnit.precomp important?

[20:49] <jnthn> ugexe: Well, a modules dependencies must always be compiled before the module itself.

[20:51] * [Coke] removes parrot from the run and tries just moar/jvm

[20:52] *** virtualsue joined
[20:52] *** Mouq left
[20:54] <nwc10> this is moritz -- http://dilbert.com/strips/comic/1995-11-13/  ?

[20:55] <ugexe> jnthn: actually i just discovered i can compile just that single module (in my repo) and it will precompile. but if i precompile one of the modules it uses first, i get a 'No object at index ###' error

[20:56] <jnthn> ugexe: That error almost always indicates some kind of mis-ordering or statle pre-comp.

[20:56] <ugexe> dependency deserialization. i see

[20:56] <adu> can I use backreferences in a $out.=subst() call?

[20:57] <timotimo> i've at least once tried to put the name of the module that "caused" the loading of a precomp'd module in the error message, but i couldn't do it

[20:58] <jnthn> adu: As in, use them in the regex givne to subst? Dont' see why not, it's evaluated using the normal regex engine.

[20:58] <adu> should I use "$1" or '$1' ?

[20:59] <IllvilJa> I just installed rakudo/perl6 version 2013.12 on my Ubuntu machine (using apt-get). If I want to install some perl6 module for it, is that straightforward (like it is for perl5 on ubuntu) or do I have to download and build those modules myself?

[20:59] <IllvilJa> FYI, the latest rakudo perl6 on Ubuntu is 2013.12 which I admit is a bit old...

[20:59] <timotimo> yeah, have you looked into rakudobrew yet? :S

[21:00] <timotimo> maybe we have a PPA actually?

[21:00] <IllvilJa> Is rakudobrew something available via apt-get?

[21:00] <tadzik> no

[21:00] <tadzik> but it's very easy to set up :)

[21:00] <IllvilJa> Ok.

[21:00] <timotimo> oh, ouch, debian has 2012.01-1

[21:00] <timotimo> that's pretty harsh

[21:00] <tadzik> classic debian

[21:01] <IllvilJa> I'm having this as a (perhaps crappy) way of checking the 'readiness' of perl6.  I download the thing using the distro's standard packaging system, and then see if I can get the packages easily installed.

[21:01] <tadzik> damnit debian

[21:02] <tadzik> well, to our defense rakudobrew is for building perl6 from scratch

[21:02] <IllvilJa> Perl5 passes that test.  Perl6 does not, but OTOH, the test is perhaps misleading.

[21:02] <timotimo> tadzik: yeah, but that's hardly good enough

[21:02] *** jack_rabbit joined
[21:02] <tadzik> timotimo: agreed

[21:02] <timotimo> IllvilJa: packaging can feel like very thankless work ... and i don't know the first thing about it yet, either ;(

[21:03] *** eternaleye left
[21:03] <timotimo> IllvilJa: what version of ubuntu do you have?

[21:03] <moritz> timotimo: I know the first thing about it: it's sloooow to make progress, and often badly documented, and generally sucks

[21:03] <timotimo> i see utopic unicorn actually has 2014.03

[21:03] <skids> Yeah packaging puts you at the "nexus of blame"

[21:03] <timotimo> and trusty tahr has 2013.12

[21:04] <IllvilJa> Ubuntu 14 LTS.  I think it is 14.04 or something.

[21:04] <timotimo> oh, LTS

[21:04] <timotimo> i don't think LTS will get anything new-ish feature-wise

[21:04] <moritz> LTS updates much more than debian :-)

[21:04] <timotimo> we could try to build rakudo long term support versions that get "only bug fixes" but that's a very weird thing to do

[21:05] <IllvilJa> True.  I ran the "cutting-edgish" non-LTS version of Ubuntu 12, installed it 12 months ago (ca) only to find it being totally impossible to update ca 6 months later (I could not even have a sane way to upgrade to Ubuntu 13 or 14 without breaking things).

[21:05] <moritz> considering that some bug fixes might need a newer NQP or MoarVM...

[21:05] <timotimo> also, building modern modules on old-but-unbugged rakudos would not work much more ...

[21:05] <adu> jnthn: it's not working, I see a literal $1$2 in the replacement

[21:05] *** brrt joined
[21:06] <brrt> \o

[21:06] * moritz just broke his laptop's power supply

[21:06] <IllvilJa> moritz: ouch!

[21:06] *** ab5tract joined
[21:06] <moritz> I'll probably be less online in the next 1-3 days

[21:06] <ugexe> a ubuntu/deb binary would make travis ci testing a lot more viable though. too bad the process probably cant be completely automated :/

[21:06] <brrt> thas sucks moritz

[21:06] <moritz> aye

[21:07] <adu> jnthn: does it only work with s/a/b/g?

[21:07] *** eternaleye joined
[21:07] <timotimo> moritz: d'oh, sorry to hear that

[21:07] <adu> s/a/b/g also doesn't work

[21:07] <IllvilJa> I wish I had more time for hacking around with Perl6, but right now I really cannot until Perl6 get to the point I can treat it like Perl5 (download with distro tools, download needed perl6 packages and then just use it).

[21:08] <FROGGS> moritz: what type of laptop and what problem exactly?

[21:08] <IllvilJa> And I really wished I had time to contribute getting Perl6 + Perl6 package management in such a position :-(

[21:08] <ugexe> no next day amazon delivery in germany?

[21:08] *** brrt left
[21:09] <jnthn> adu: Oh, you mean you're using captures in the replacement part?

[21:09] * jnthn doesn't call that a backref... :)

[21:09] *** brrt joined
[21:09] <adu> jnthn: is $1 a capture? I though it was called backref

[21:09] <ugexe> IllvilJa you can automate all that (on linux) with rakudobrew as was mentioned before. it takes me like 5 minutes to build my daily rakudo+nqp+moarvm. I mean if you want it to be like Perl5 you should be using perlbrew anyway, right? :)

[21:10] <jnthn> m: "omg".subst(/\w/, {"$0!"}, :g).say

[21:10] <camelia> rakudo-moar 80b912: OUTPUT«use of uninitialized value of type Any in string context  in block <unit> at /tmp/Bqf4CZCJZd:1␤␤use of uninitialized value of type Any in string context  in block <unit> at /tmp/Bqf4CZCJZd:1␤␤use of uninitialized value of type Any in string context…»

[21:10] <brrt> IllvilJa: what would make you treat it like perl5?

[21:10] <jnthn> Oh, duh

[21:10] <ugexe> which, btw, building rakudo+nqp+moar is way faster for me than building perl5

[21:10] *** bjz joined
[21:10] <jnthn> m: "omg".subst(/(\w)/, {"$0!"}, :g).say

[21:10] <camelia> rakudo-moar 80b912: OUTPUT«o!m!g!␤»

[21:11] <ugexe> a basic travis test that builds perl6, installs package manager, installs dependencies, and tests a basic module takes 6.5 minutes on travis-ci vm currently

[21:12] <IllvilJa> ugexe: what I have in mind is not to make it easy for me to get perl6 + packages installed on my machine, but rather for someone else who want to run my perl6 program to get the stuff quickly in place.

[21:13] <brrt> i see

[21:13] <IllvilJa> If someone using ubuntu want to run my perl6 program, many of them appreciate if they can follow the same procedure currently required for a perl5 program (which means ensure perl5 is installed (comes with Ubuntu, I know) and then install any needed modules and then run the code)

[21:14] <IllvilJa> Eventually, perl6 will be there.

[21:14] <brrt> what would help you more, of the following options: apt-get install in All Major Distros (including mac os x, e.g. by homebrew)

[21:14] <brrt> an Official Docker Image repository (like for php, python, ruby, dunno about perl5)

[21:14] <timotimo> ugexe: not a fair comparison, the standard library of perl5 is not as small as our core setting

[21:14] <ugexe> IllvilJa: thats what a travis.yml file does

[21:14] *** jack_rabbit left
[21:14] *** lestrrat joined
[21:15] <ugexe> you can abstract the commands any way you want

[21:15] <brrt> a Static Perl6 Binary, or even a Precompiled Perl6 Fakexecutable

[21:15] <timotimo> we do have docker repositories for rakudo stars

[21:15] <timotimo> the fakecutables are going to be nice to have

[21:15] <IllvilJa> Maybe that's a way forward in the meanwhile.

[21:15] <brrt> what would it take to make those official?

[21:16] <brrt> how nice precisely, timotimo? :-)

[21:16] <ugexe> i think no one wants to put in the effort for packaing something that will get broken often

[21:16] <brrt> jnthn: i take that perl6 regexes don't capture at all if you don't use parentheses?

[21:17] <jnthn> brrt: Aye, short of ~$/ giving you all the text that matched of course.

[21:17] <jnthn> brrt: Well, and hen there's named captures.

[21:17] <jnthn> <foo>, $<bar>=[...], etc.

[21:17] <jnthn> *then

[21:18] <timotimo> brrt: if we can even make statically linked fakecutables and have bunches of dependencies in the executable, too ...

[21:18] <jnthn> .oO( really cocked up with that typo... )

[21:18] <timotimo> perl6 in a single file, panda in a single file :P

[21:18] <brrt> jnthn stop making me laugh :-D

[21:18] <lizmat> Amsterdam.pm meeting shutting down...

[21:18] * jnthn considers another pun, but chickens out...

[21:18] <brrt> timotimo - the only thing i see against that is people not wanting us to ship our own libuv

[21:18] <lizmat> decommute&

[21:19] <timotimo> oh

[21:19] <timotimo> right

[21:19] <brrt> bye lizmat

[21:19] <timotimo> on the other hand

[21:19] * jnthn should look at the various fakeexecutable patches for Moar...

[21:19] <timotimo> statically linked perl6 could work on "non-distributions" :P

[21:19] <adu> jnthn: I figured it out! http://pastie.org/9816955

[21:19] <brrt> on the other hand many distro versions of libuv would break

[21:19] <brrt> but that's true for the docker containers as well timotimo

[21:19] <timotimo> aye

[21:20] <brrt> i started building a fakexecutable version of perl6 $time ago, but that was just perl6, and that still required the loading of dependencies from the file system

[21:21] <timotimo> right

[21:22] *** avuserow_ left
[21:22] *** lizmat left
[21:22] *** bjz left
[21:22] <timotimo> shouldn't using libuv make making that "pluggable" easy?

[21:25] *** IllvilJa left
[21:25] <bartolin> ls

[21:26] <bartolin> oops, wrong window

[21:26] *** IllvilJa joined
[21:29] <brrt> whaddayamean timotimo

[21:29] <brrt> :-)

[21:30] * brrt wonders how to check the version of his libuv installation

[21:30] <brrt> 0.10.29

[21:31] *** bjz joined
[21:31] *** xfix left
[21:32] <[Coke]> moritz: ^^ there, first run. will make it more automated later, but for now, can easily kick it off again.

[21:32] <brrt> moar ships with a significanlty newer version

[21:32] <[Coke]> ... /me apparently never updated the webhook for that project.

[21:33] <timotimo> brrt: have some kind of clever ... i have no clue actually

[21:34] <[Coke]> https://github.com/coke/rakudo-star-daily/tree/master/log - updated for moar & jvm

[21:35] <brrt> anyway, i have fedora twenty one, the very shiniest and latest, and it ships with libuv 0.10.29

[21:35] *** avuserow_ joined
[21:36] <ugexe> is there a more elegant way to check a module for dependencies without parsing the source, or parsing the result of EVAL { use Whatever::Module } ?

[21:36] <brrt> which is silly, that version isn't even tagged in libuv

[21:36] <brrt> ugexe - i don't think there is right now, because of the dynamic loading possibilities

[21:37] <brrt> (0.10.28 though is from july 31 2014, that is 6 months old)

[21:39] <ab5tract> nine: is it possible to create multiple Inline::Perl5 objects?

[21:39] *** bjz left
[21:39] <brrt> which isn't - iirc - even the correct version of libuv for the version of moar that is shipped (2014.04)

[21:43] <ab5tract> i was hoping i would be able to build intepreter pools and do thready-stuff

[21:43] <skids> Heh.  Using Inline::P5 I can't keep myself from using -> for P5 method invokes because I know it's a P5 object.

[21:44] <ab5tract> skids: it could be nice to have that in a slang

[21:44] <timotimo> it would seem to me that libperl would possibly have some global state

[21:44] <timotimo> that would make it not be reentrant, so to speak

[21:44] <ab5tract> timotimo: i see.

[21:45] <jnthn> timotimo: I think there's a flag (multiplicity?) that makes it not have global state; I may be mis-remembering.

[21:45] <timotimo> that would be helpful, but you need to rebuild libperl?

[21:45] <skids> ab5tract: No I think that's down to just devloping discipline.

[21:46] <ab5tract> i'm fine with rebuilding

[21:46] <ab5tract> but yeah, it would be better if that would not be necessary

[21:46] <ab5tract> skids: i don't know.. i could imagine it being useful to visually differentiate method calls on p5 objects using -> 

[21:47] <ab5tract> so that one would never lose track of what's really a $p5-obj and what isn't

[21:50] <ab5tract> i see a multiplicity configure option

[21:50] * ab5tract digs

[21:50] <jnthn> timotimo: I dunno if it's a default or not.

[21:51] <timotimo> 'k

[21:58] *** Mouq joined
[22:01] *** skids left
[22:05] *** spider-mario left
[22:06] *** denis_boyun_ joined
[22:08] *** anaeem1__ joined
[22:09] *** rurban left
[22:11] *** anaeem1 left
[22:13] *** sqirrel_ joined
[22:14] <ab5tract> jnthn: bingo!!

[22:15] *** notjack left
[22:15] <ab5tract> it a) does not appear to be default, and b) fixes the segfaults

[22:17] <ab5tract> very cool

[22:17] <ab5tract> thanks for the help

[22:18] <ab5tract> i'm going to still be scarce for another week or so, but that doesn't mean i'm not thinking of you #perl6

[22:18] <ab5tract> good night for now!

[22:18] *** ab5tract left
[22:18] <jnthn> ab5tract: Happy it helped :) 'night

[22:26] *** KCL_ left
[22:29] *** Rounin joined
[22:30] *** jack_rabbit joined
[22:32] *** davido_ left
[22:33] *** davido_ joined
[22:34] *** treehug88 left
[22:35] *** sqirrel_ left
[22:37] *** denis_boyun_ left
[22:39] *** raiph left
[22:51] *** IllvilJa left
[22:53] *** raiph joined
[22:53] *** rurban joined
[23:00] *** IllvilJa joined
[23:20] *** rmgk left
[23:20] *** [Coke] left
[23:20] *** pyrimidine left
[23:20] *** Possum left
[23:20] *** ribasushi left
[23:20] *** Pleiades` left
[23:20] *** zoosha left
[23:20] *** sjn left
[23:20] *** kshannon left
[23:20] *** pochi left
[23:20] *** avar left
[23:20] *** betterwo1ld left
[23:20] *** yoleaux left
[23:20] *** wtw left
[23:20] *** woshty left
[23:20] *** apejens left
[23:20] *** mls left
[23:20] *** _sri left
[23:20] *** huf left
[23:20] *** osfameron left
[23:20] *** mst left
[23:20] *** tony-o left
[23:20] *** eMBee left
[23:20] *** jantore left
[23:20] *** risou left
[23:20] *** lestrrat left
[23:20] *** Psyche^ left
[23:20] *** pecastro left
[23:20] *** vike left
[23:20] *** Woodi left
[23:20] *** Khisanth left
[23:20] *** labster left
[23:20] *** tadzik left
[23:20] *** ponbiki left
[23:20] *** epochbell left
[23:21] *** betterworld joined
[23:21] *** _sri joined
[23:21] *** sjn joined
[23:21] *** [Coke] joined
[23:21] *** pochi joined
[23:21] *** tony-o joined
[23:21] *** Possum joined
[23:21] *** osfameron joined
[23:21] *** huf joined
[23:21] *** risou joined
[23:21] *** FlipBill joined
[23:21] *** zoosha joined
[23:21] *** ribasushi joined
[23:21] *** PerlJam joined
[23:21] *** jferrero joined
[23:22] *** jantore joined
[23:22] *** rmgk joined
[23:22] *** lestrrat joined
[23:22] *** Psyche^ joined
[23:22] *** pecastro joined
[23:22] *** vike joined
[23:22] *** Woodi joined
[23:22] *** Khisanth joined
[23:22] *** labster joined
[23:22] *** vukcrni joined
[23:22] *** ruoso_ joined
[23:22] *** felher joined
[23:22] *** tadzik joined
[23:22] *** ponbiki joined
[23:22] *** epochbell joined
[23:22] *** kshannon joined
[23:22] *** torbjorn joined
[23:22] *** Pleiades` joined
[23:23] *** pyrimidine joined
[23:23] *** apejens joined
[23:24] *** vukcrni left
[23:25] *** vukcrni joined
[23:26] *** anaeem1__ left
[23:26] *** broquaint joined
[23:26] *** mst__ joined
[23:27] *** jercos joined
[23:34] *** anaeem1 joined
[23:34] *** mls joined
[23:34] *** Mouq left
[23:34] *** jantore left
[23:34] *** jantore joined
[23:39] *** mephinet left
[23:41] *** mephinet joined
[23:44] *** Mouq joined
[23:46] *** eMBee joined
[23:48] *** jakesyl_insomnia joined
[23:50] *** brrt left
[23:51] *** telex left
[23:52] *** telex joined
[23:55] *** yoleaux joined
[23:55] *** ChanServ sets mode: +v yoleaux

[23:56] *** avar joined
[23:56] *** avar left
[23:56] *** avar joined
[23:56] *** wtw joined
[23:57] *** woshty joined
[23:57] *** adu left
