[00:00] *** captain-adequate left
[00:00] *** pdurbin joined
[00:02] <pdurbin> Does Perl 6 support tail call optimization? TCO is being discussed at https://botbot.me/freenode/pyladies/msg/44749357/

[00:32] <skids> pdurbin: it looks like "not in 6.0" according to http://irclog.perlgeek.de/perl6/2015-06-29#i_10823364

[00:33] <pdurbin> skids: ah. ok. thanks

[00:43] *** khw joined
[00:44] *** aborazmeh joined
[00:44] *** aborazmeh left
[00:44] *** aborazmeh joined
[00:50] <timo1> pdurbin: i seem to recall at some point there was a bytecode-modifying hack for python that could do TCO, but i could be confusing it with something else

[00:50] *** Brock is now known as awwaiid

[00:51] <timo1> pdurbin: i *think* at some point GvR explicitly said he wouldn't want TCO to be supported by CPython at least, no clue how out of date that information is, though

[00:51] *** timo1 is now known as timotimo

[00:51] <timotimo> i wonder if a tracing JIT will make TCO very easy to do

[00:52] *** roguelazer joined
[00:52] *** khw left
[00:59] <pdurbin> timotimo: I just heard in #pyladies that Guido still opposes it

[00:59] <timotimo> ok

[01:00] <timotimo> perl6 is on kind of the opposite side of the "functional programming" spectrum

[01:00] <timotimo> that may be a bad way to express it, though

[01:04] *** llfourn joined
[01:04] *** BenGoldberg joined
[01:04] *** vendethiel joined
[01:08] *** llfourn left
[01:09] *** dha left
[01:13] *** khw joined
[01:14] *** roguelazer left
[01:15] *** dccn joined
[01:15] *** dccn left
[01:18] *** b2gills joined
[01:18] *** rmgk left
[01:19] *** rmgk joined
[01:22] *** meisl left
[01:28] *** vendethiel left
[01:45] *** ilbot3 left
[01:47] *** ilbot3 joined
[01:49] *** dayangkun joined
[01:49] *** dayangkun left
[01:52] *** dayangkun joined
[01:52] *** dayangkun left
[01:53] *** dayangkun joined
[01:54] *** dayangkun left
[01:59] *** dayangkun joined
[01:59] *** dayangkun left
[02:07] *** dayangkun joined
[02:08] *** dayangkun left
[02:08] *** noganex_ joined
[02:10] *** kaila joined
[02:11] *** noganex left
[02:13] *** kaila left
[02:14] *** dayangkun joined
[02:14] *** dayangkun left
[02:15] *** nys left
[02:16] *** dayangkun joined
[02:16] *** gfldex left
[02:17] *** dayangkun left
[02:27] *** dayangkun joined
[02:28] *** dayangkun left
[02:28] *** dayangkun joined
[02:29] *** dayangkun left
[02:39] *** colomon left
[02:39] *** colomon joined
[02:41] *** dayangkun joined
[02:42] *** dayangkun left
[02:43] *** dayangkun joined
[02:44] *** dayangkun left
[02:44] *** dayangkun joined
[02:45] *** dayangkun left
[02:49] *** atweiden left
[02:50] *** aborazmeh left
[02:52] *** prammer left
[02:56] *** dayangkun joined
[02:57] *** dayangkun left
[03:00] *** prammer joined
[03:00] *** dayangkun joined
[03:01] *** dayangkun left
[03:05] *** prammer left
[03:10] *** coffee`_ left
[03:13] *** dayangkun joined
[03:14] *** dayangkun left
[03:14] *** prammer joined
[03:16] *** BenGoldberg left
[03:18] *** AlexDaniel left
[03:25] *** BenGoldberg joined
[03:25] *** BenGoldberg left
[03:28] *** dayangkun joined
[03:29] *** dayangkun left
[03:31] *** yqt left
[03:31] *** dayangkun joined
[03:31] *** dayangkun left
[03:32] *** dayangkun joined
[03:33] *** dayangkun left
[03:34] *** dayangkun joined
[03:34] *** dayangkun left
[03:40] *** VinceDee joined
[03:43] *** dayangkun joined
[04:26] *** atroxaper joined
[04:49] *** ShimmerFairy left
[05:00] *** skids left
[05:03] *** ShimmerFairy joined
[05:04] *** llfourn joined
[05:04] *** jack_rabbit joined
[05:06] *** khw left
[05:08] *** VinceDee left
[05:17] *** kaare_ joined
[05:22] *** mr-fooba_ joined
[05:22] *** dustinm`_ joined
[05:22] *** SmokeMachine_ joined
[05:22] *** daxim_ joined
[05:23] *** mr-foobar left
[05:23] *** SmokeMachine left
[05:23] *** isacloud left
[05:23] *** ilbot3 left
[05:23] *** avuserow joined
[05:23] *** robins joined
[05:24] *** SmokeMachine_ is now known as SmokeMachine

[05:25] <dalek> roast: 22873ae | PerlJam++ | S16-filehandles/io.t:

[05:25] <dalek> roast: Add some tests for lines(*) and lines(Inf)

[05:25] <dalek> roast: review: https://github.com/perl6/roast/commit/22873aeeb8

[05:25] <dalek> roast: 2f299af | PerlJam++ | S32-str/words.t:

[05:25] <dalek> roast: Add tests for words sub

[05:25] <dalek> roast: review: https://github.com/perl6/roast/commit/2f299af96c

[05:25] *** lizmat joined
[05:27] *** isacloud joined
[05:27] *** ilbot3 joined
[05:39] *** pyrimidine joined
[05:46] *** bjz joined
[05:52] *** llfourn left
[05:53] *** gfldex joined
[06:16] *** FROGGS joined
[06:17] *** mr-fooba_ left
[06:18] *** _mg_ joined
[06:20] *** [Sno] left
[06:22] *** daxim_ left
[06:23] *** justaguy_ joined
[06:23] *** justaguy_ left
[06:24] *** daxim_ joined
[06:26] *** dj_goku_ left
[06:27] <dalek> rakudo/nom: c0f03bf | lizmat++ | src/core/List.pm:

[06:27] <dalek> rakudo/nom: Streamline xx handling + fix #125627

[06:27] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/c0f03bf9b6

[06:27] <synbot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=125627

[06:29] <lizmat> m: "x" x Inf  # huh?

[06:29] <camelia> rakudo-moar b606f9: ( no output )

[06:29] <lizmat> m: say "x" x Inf  # huh?

[06:29] <camelia> rakudo-moar b606f9: OUTPUT«␤»

[06:30] <lizmat> m: "x" x *

[06:30] <camelia> rakudo-moar b606f9: ( no output )

[06:30] <lizmat> m: say "x" x *

[06:30] <camelia> rakudo-moar b606f9: OUTPUT«WhateverCode.new␤»

[06:32] *** dj_goku joined
[06:34] <FROGGS> lizmat: I've marked your ticket testneeded

[06:36] <lizmat> FROGGS++

[06:37] <lizmat> Looking at #125628, I think we need to make the "foo" x Inf/* case fail with a NYI

[06:37] <synbot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=125628

[06:38] <lizmat> NYI as in 'Infinite strings (Cat) are NYI

[06:38] <FROGGS> probably good idea, yeah

[06:39] <lizmat> I'll look at that tomorrow (well, in ~ 10 hours) when I'm less tired and had some sleep

[06:39] <FROGGS> :o)

[06:39] <lizmat> unless someone beats me to it  :-)

[06:39] *** froppi joined
[06:39] <FROGGS> I probably won't :o(

[06:40] <lizmat> .oO( I was more thinking lurkers on the channels :-)

[06:40] <lizmat> anyways, time to go to bed

[06:40] <lizmat> so good night, #perl6!

[06:41] <FROGGS> gnight lliz

[06:41] <FROGGS> err

[06:41] <FROGGS> lizmat: 

[06:41] <FROGGS> hmpf

[06:41] <FROGGS> -.-

[06:42] <FROGGS> sleep well, seems I'd need that too

[06:43] *** domidumont joined
[06:43] *** espadrine joined
[06:43] *** abraxxa joined
[06:47] *** domidumont left
[06:48] *** domidumont joined
[06:48] *** abraxxa left
[06:52] *** colomon left
[06:52] *** robins is now known as robinsmidsrod

[06:52] *** bjz left
[06:52] *** colomon joined
[06:54] *** bjz joined
[06:55] *** st_iron joined
[06:55] <st_iron> good morning

[06:57] <FROGGS> morning st_iron 

[07:03] *** abraxxa joined
[07:08] *** atroxaper left
[07:11] *** atroxaper joined
[07:12] *** llfourn joined
[07:13] *** mr-foobar joined
[07:20] *** amurf left
[07:26] *** bjz left
[07:30] *** [Sno] joined
[07:37] *** diana_olhovik_ joined
[07:40] *** brrt joined
[07:51] *** diana_olhovik_ left
[07:57] *** g4 joined
[07:58] *** laouji left
[07:58] *** laouji joined
[08:01] *** yeahnoob joined
[08:02] *** laouji left
[08:02] *** laouji joined
[08:02] *** zakharyas joined
[08:03] *** nightfrog left
[08:10] *** atroxaper left
[08:11] <cdc> Hello #perl6

[08:11] <FROGGS> hi cdc

[08:11] <cdc> m: sub f1 { default { return { :test1, :test2 } } }; sub f2 { default { { :test1, :test2 } } }; say 'f1:'; .WHAT.say for f1; say 'f2:'; .WHAT.say for f2;

[08:11] <camelia> rakudo-moar c0f03b: OUTPUT«f1:␤(Hash)␤f2:␤(Pair)␤(Pair)␤»

[08:11] <cdc> FROGGS: o/

[08:12] <cdc> is this ^^ expected?

[08:12] <cdc> the return value is flattened in f2

[08:13] *** Foxcool_ joined
[08:15] *** Foxcool left
[08:19] *** virtualsue joined
[08:19] *** atroxaper joined
[08:22] *** RabidGravy joined
[08:25] <FROGGS> cdc: to be honest, I often enough do not know what to expect wrt flattening

[08:25] <FROGGS> but as we know this is meant to change

[08:27] *** shmibs joined
[08:28] *** darutoko joined
[08:29] *** atroxaper left
[08:31] <RabidGravy> marning!

[08:31] <cdc> FROGGS: even if flattening is currently a moving target, I wonder if this is a bug wrt explicit/implicit return.  It's OK to me to wait for the GLR before submitting a ticket, however maybe this test/bug deserves to be added to roast (to know when/if this behavior changes).

[08:35] *** ely-se joined
[08:35] <ely-se> Konnichiwa.

[08:35] <FROGGS> cdc: you can also mention your case here https://github.com/perl6/specs/issues/70

[08:35] <FROGGS> hi ely-se 

[08:36] <DrForr> ohaayo.

[08:37] <cdc> FROGGS: ok, thanks!

[08:42] <froppi> if I learn Perl 5 now (for its reliablility and documentation) how iritating will it be for me with my intermediate knowledge of the language to switch to Perl 6 in the future?

[08:42] <FROGGS> froppi: hmmm, you can transpose some of the knowledge from P5 to P6

[08:43] <ely-se> depends on how good you are at learning multiple distinct languages

[08:43] <FROGGS> froppi: Perl 6 is a Perl after all, both languages share the same idea of how a language should be like

[08:43] <froppi> so I should just treat them as distinct languages?

[08:43] <FROGGS> froppi: ohh yes

[08:43] <ely-se> there is http://doc.perl6.org/language/5to6 which highlights some of the differences

[08:44] *** bjz joined
[08:45] <froppi> I've seen that actually. Perl 6 looks more like a meta-programming language to me. SO Perl 5 as a text-processing language might still even be relevant in the future?

[08:47] <ely-se> Perl 5 might become the new COBOL!

[08:47] <El_Che> froppi: I love perl 5. Very useful here to get things done (I also use Java and Ruby depending on the setting)

[08:48] <masak> good morning, #perl6!

[08:48] <masak> Perl 6 day today! \o/

[08:48] <JimmyZ> why not learn the two together, and you can use anyone that you want :P

[08:48] * ely-se hugs masak

[08:48] <El_Che> is it christmas already? :)

[08:48] <ely-se> Inline::Perl5

[08:49] <froppi> ely-se: I thought Java was?

[08:49] *** espadrine left
[08:51] <masak> El_Che: technically, it's not Christmas already.

[08:51] *** telex left
[08:51] <ely-se> hmm, Java

[08:51] <FROGGS> cool beans

[08:51] * FROGGS gets coffee

[08:51] <ely-se> El_Che: unless you are Christmas, you can't even tell whether Christmas exists

[08:51] <masak> El_Che: Christmas is planned for Christmas.

[08:52] <El_Che> wel it the Eid, that's islams' correspondant holiday for christmas :)

[08:52] *** telex joined
[08:55] *** froppi left
[08:57] *** brrt left
[08:59] *** estrabd left
[09:02] <cdc> m: sub f1 { my %h = :a, :b; %h }; sub f2 { my %h = :a, :b; { %h } }; .say for f1; .say for f2;

[09:02] <camelia> rakudo-moar c0f03b: OUTPUT«a => True␤b => True␤a => True, b => True␤»

[09:03] <cdc> FROGGS, all: another example where I don't understand why f2 returns a Hash, but f1 returns a List ^

[09:04] <FROGGS> well, one is itemized, the other isnt

[09:05] *** atroxaper joined
[09:05] <cdc> m: sub f3 { my %h = :a, :b; %h.item }; .say for f3;  

[09:05] <camelia> rakudo-moar c0f03b: OUTPUT«a => True, b => True␤»

[09:06] <cdc> FROGGS: thanks! :)

[09:07] <cdc> I guess "%h.item" will become "%h" in post-GLR.

[09:07] <cdc> I mean, in this case

[09:07] <FROGGS> hmmm, I'm not so sure

[09:07] <FROGGS> sigils have a meaning

[09:09] *** amurf joined
[09:09] <cdc> FROGGS: oh right: S02 -> "Array and Hash variables can be evaluated in item context by prefixing them with a single dollar sign"

[09:09] <cdc> my mistake!

[09:10] *** espadrine joined
[09:11] *** _mg_ left
[09:11] <masak> m: say dir(".").elems

[09:11] <camelia> rakudo-moar c0f03b: OUTPUT«36␤»

[09:12] <masak> m: sub find($dir) { return gather for dir($dir) -> $file { take $file; if $file.IO ~~ :d { take find($file) } } }; say find(".").elems

[09:12] <camelia> rakudo-moar c0f03b: OUTPUT«(timeout)»

[09:12] <masak> hm.

[09:13] *** amurf left
[09:15] <masak> oh, it's working -- it's just taking its time on a rakudo directory.

[09:16] *** dustinm`_ is now known as dustinm`

[09:16] <ely-se> dustbin

[09:16] *** espadrine_ joined
[09:16] <masak> many things in Rakudo have gotten faster, but file I/O and directory traversal is still slow.

[09:16] <ely-se> get an SSD!

[09:17] <masak> like, noticeably so.

[09:17] <masak> I'm on an SSD...

[09:17] <nwc10> get two, and RAID them!

[09:17] <masak> :P

[09:20] <masak> anyway, I think we can be faster there. not sure what it would take withoout benchmarking, though.

[09:20] *** laouji left
[09:20] *** espadrine left
[09:20] <nwc10> I/O will matter by Christmas

[09:20] <nwc10> directories not as much

[09:21] *** laouji joined
[09:21] <nwc10> but I/O speed and failure-to-cope-with-an-8-bit-world were the two things that Python 3.0 got wrong on release, and hence why 3.1 was quite soon.

[09:21] <nwc10> IIRC

[09:22] *** vendethiel joined
[09:28] *** brrt joined
[09:32] <masak> I think tree traversal is slow because it creates many heavy objects. (that's an un-benched opinion, though, so caveat lector.)

[09:34] <masak> while I have your attention -- this is a thing I've asked before, but never quite got a good answer for:

[09:34] <RabidGravy> ah-ha! find out what had broken "panda gen-meta"

[09:34] <masak> why are the delimiters for quasi blocks spec'd to be variable?

[09:34] <RabidGravy> hackety hack hack

[09:34] <masak> like `quasi { ... }`, `quasi [ ... ]`, `quasi < ... >`

[09:35] <jnthn> masak: I suspect simply 'cus all forms of quoting are

[09:35] <masak> jnthn: we need to figure out how much a quasi block is actually a *block*, and how much we believe in the rule that "{} means block"

[09:36] <masak> in this case it'd be more "block means {}"

[09:36] <jnthn> Well, it doesn't when it's about a hash... 

[09:36] <jnthn> But yeah, I see where you're going. 

[09:36] <masak> hashes get a special exception :)

[09:36] <jnthn> I don't know it is a block

[09:36] <vendethiel> well, it'd make sense if it were string-ish, but it's block-ish

[09:37] <jnthn> I mean, we don't see the quasi as introducing a new lexical scope...

[09:37] <masak> jnthn: me neither. it's one of those "on some days yes, on some days no"

[09:37] <masak> jnthn: currently in Rakudo, that's what they do.

[09:37] <jnthn> *nod*

[09:37] <masak> jnthn: turns out that's the shortest way to hygiene by default.

[09:37] <jnthn> Right

[09:37] <masak> duddn' mean we'll keep it, 'f'course

[09:37] <masak> I buy into the "quoting delimiters can be anything" -- sometimes that's a lifesaver for things like s!!! and q<>

[09:37] <DrForr> You have my attention now :)

[09:38] <masak> I don't automatically buy it for quasis.

[09:38] *** yeahnoob left
[09:38] <masak> even if they're not *blocks*, they're certainly *block-like*

[09:39] <masak> there used to be a time when I was all-in for quasis having different delimiters. that's when I still believed you could nest quasis to great effect: `quasi { ... quasi < ... > ... }`

[09:40] <masak> then you could distinguish your unquotes to "beling" to the right quasi!

[09:40] <masak> but TimToady has assured me that's not how quoting works, and that doesn't make sense.

[09:40] <masak> so now I simply don't see the point.

[09:40] <masak> belong*

[09:44] *** ely-se left
[09:45] *** laouji left
[09:45] <ShimmerFairy> masak: since quasis aren't part of Q (that is, it's not like 'quasi' is short for 'Q :quasi' or anything), I don't think having different delimiters makes too much sense.

[09:46] <masak> that, too.

[09:46] <masak> it's called "quasi*quoting*", but ti's certainly not a kind of string quoting.

[09:47] <masak> I do acknowledge that we have the problem of collisions between Perl 6 syntax and macro/quasi metasyntax.

[09:47] <ShimmerFairy> .oO(quasiblocking)

[09:47] <masak> that's why we are talking about horrors like {{{ }}} and ¤, after all.

[09:48] <ShimmerFairy> ¤?

[09:49] <masak> suggested replacement for {{{ }}}

[09:49] <masak> I'm not a big fan, but it does solve some problems

[09:49] <masak> I'm constantly on the hunt for something less jarring

[09:49] <masak> m: sub find($file) { @($file, $file.IO.d && @(dir($file)».&find)) }; say find(".").elems

[09:49] <masak> ^ turns out the above was what I wanted.

[09:50] <DrForr> Also, {{{ }}} are default code markers for code folding in vim.

[09:50] <camelia> rakudo-moar c0f03b: OUTPUT«(timeout)»

[09:50] *** laouji joined
[09:50] <masak> I'm a bit dissapointed I needed two @() to make that work

[09:50] <masak> anyone know how to write it just as short but slightly nicer?

[09:50] <ShimmerFairy> masak: question: what can macros do outside of quasi blocks? (that is,  macro foo { #`(what can be done here?) quasi { ... } #`(here too) }  )

[09:50] <jnthn> Why'd you need the second one?

[09:51] <masak> I don't know. just doesn't work without it :/

[09:51] <jnthn> sub find($file) { flat $file, $file.IO.d && dir($file)».&find } ?

[09:51] <masak> can't show it on camelia, unfortunately. not without finding a smaller subdirectory to run it on :)

[09:51] * masak tries

[09:51] <masak> works \o/ jnthn++

[09:52] <jnthn> m: sub find($file) { flat $file, $file.IO.d && dir($file)».&find }; say find('t').elems

[09:52] <camelia> rakudo-moar c0f03b: OUTPUT«2␤»

[09:52] <masak> that's... wrong.

[09:53] <ShimmerFairy> If you can't do anything besides quasi blocks inside a macro, then I'd suggest 1) turning the macro body into what quasi is, and 2) maybe then use  quasi { }  for unquoting??

[09:53] <masak> huh, why does it work here but give the wrong answer on camelia?

[09:53] <vendethiel> m: sub find($file) { flat $file, $file.IO.d && dir($file)».&find }; say find('t')

[09:53] <masak> ShimmerFairy: suggestion (1) is a bad idea.

[09:53] <camelia> rakudo-moar c0f03b: OUTPUT«t Failed to find 't' while trying to do '.d'␤  in sub find at /tmp/6_PuvNA7sF:1␤  in block <unit> at /tmp/6_PuvNA7sF:1␤␤»

[09:53] <jnthn> Probably selective copying of stuff?

[09:53] <vendethiel> huh.

[09:53] <jnthn> (camelia doesn't run in a build directory of Rakudo iirc)

[09:54] <masak> aha.

[09:54] <masak> could be it.

[09:54] <vendethiel> m: sub find($file) { flat $file, $file.IO.d && dir($file)».&find }; say find('t').elems # the elem fixes it?!

[09:54] <camelia> rakudo-moar c0f03b: OUTPUT«2␤»

[09:54] <jnthn> So I was lucky wherever it does run has a t :)

[09:54] * vendethiel wats

[09:54] <ShimmerFairy> masak: well, if you are supposed to be able to do stuff outside of quasi blocks in a macro, then obviously it's a bad idea :)  (but then what _do_ you do beyond quasi blocks?)

[09:55] <jnthn> Oh...or it's not there and I get a Failure? :P

[09:55] <jnthn> m: sub find($file) { flat $file, $file.IO.d && dir($file)».&find }; say find('t').perl

[09:55] <camelia> rakudo-moar c0f03b: OUTPUT«("t", Failure.new(exception => X::IO::DoesNotExist.new(path => "t", trying => "d", os-error => Any), backtrace => Backtrace.new))␤»

[09:55] <jnthn> haha

[09:55] <vendethiel> oooh...

[09:55] <jnthn> Yeah, masak's original assumes the initial directory you give it exists :P

[09:55] <vendethiel> that seems pretty bad

[09:55] <masak> ShimmerFairy: the quasi block is "and here's the code I want to splice into the mainline". the rest of the macro body is all the rest: analysis, checks, dynamic generation of code.

[09:56] <masak> ShimmerFairy: returning a simple quasi block is just the most basic use case of macros.

[09:56] <jnthn> Oh, but that still doens't explain it all

[09:56] <jnthn> Oddness

[09:56] <ShimmerFairy> And unfortunately the only use case I've seen so far :)

[09:56] <masak> ShimmerFairy: that's not true, you've most likely seen DEBUG

[09:57] <ShimmerFairy> I have not, actually.

[09:57] <masak> it's in my talk on macros.

[09:59] <masak> m: say (flat 42).elems; say (flat ()).elems; say (flat (42 if False)).elems

[09:59] <camelia> rakudo-moar c0f03b: OUTPUT«1␤0␤0␤»

[10:00] <masak> m: sub find(IO() $file) { flat ($file if $file.e), (dir($file)».&find if $file.d) }; say find("t").elems

[10:00] <camelia> rakudo-moar c0f03b: OUTPUT«0␤»

[10:00] <masak> that's better.

[10:00] *** laouji left
[10:00] <jnthn> ah, yes :)

[10:01] <vendethiel> I wonder why "flat" doesn't trigger the failure. should it? maybe not

[10:14] *** laouji joined
[10:16] *** laouji left
[10:18] <jnthn> vendethiel: Don't think so

[10:20] <Woodi> hallo #perl6 :)

[10:20] <Woodi> so what that find() should do ? recurse into subdirs ?

[10:23] <masak> m: say qq:to<FOO> for 1..5;␤  The current value is $_.␤    FOO

[10:23] <camelia> rakudo-moar c0f03b: OUTPUT«Asked to remove 4 spaces, but the shortest indent is 2 spaces  in any descend at src/gen/m-Perl6-Actions.nqp:100␤The current value is 1.␤␤The current value is 2.␤␤The current value is 3.␤␤The current value is 4.␤␤The current value is 5.…»

[10:23] <Woodi> http://english.stackexchange.com/questions/19474/pseudo-quasi-semi-and  :)

[10:23] <masak> m: say qq:to<FOO> for 1..5;␤    The current value is $_.␤    FOO

[10:23] <camelia> rakudo-moar c0f03b: OUTPUT«The current value is 1.␤␤The current value is 2.␤␤The current value is 3.␤␤The current value is 4.␤␤The current value is 5.␤␤»

[10:24] <masak> wow. I didn't really expect that to work... :)

[10:24] <masak> Woodi: find() is from File::Find. I just removed parts I didn't need.

[10:25] <masak> Woodi: interesting, I didn't know that "pseudo" meant "false/lie". that makes a whole lot of sense, though.

[10:26] <masak> "quasi" is a very good word for quasiquoting. it's almost quoting, except when there's an unquote. :)

[10:26] <Woodi> I always thinked quasi- menas what semi- mins but with some ugliness...

[10:26] <Woodi> s/mins/means/

[10:27] <masak> yes, quasi is often used as a perogative. that's not how it's meant in "quasiquote", though.

[10:27] *** ely-se joined
[10:27] <masak> er, derogative*

[10:27] <ShimmerFairy> quasi is similar to pseudo for me, both of which are not similar to "semi" at all :)

[10:27] *** TEttinger left
[10:27] *** cognominal left
[10:27] <arnsholt> IIRC pseudo- is Greek and quasi- is Latin, but otherwise pretty much the same

[10:28] <Woodi> so, what quasiquotes are ? :)

[10:28] <ShimmerFairy> I tend to interpret pseudo as "kinda" and quasi as "almost"

[10:29] <masak> Woodi: they're a way to create an AST denoting some code, instead of just writing the code.

[10:29] <ely-se> quasiquotes are like, AST literals

[10:29] *** cognominal joined
[10:30] <masak> Woodi: kind of similar to what a block/closure is. except that blocks prevent immediate execution, whereas quasiquotes prevent immediate compilation.

[10:30] *** ely-se left
[10:33] * Woodi imagine macros as playing CoreWars over source code arena. and macros using macros are quite high on "source control" skill...

[10:33] <Woodi> in that mood there is nothing special in self-modifing code :)

[10:34] <Woodi> can be pretty sparse and "perfect" code :)

[10:34] *** pdurbin left
[10:35] *** xiaomiao left
[10:38] *** brrt left
[10:38] <masak> m: say qq:to<FOO> for 1..5;␤    The current value is {$_}.␤    FOO

[10:38] <camelia> rakudo-moar c0f03b: OUTPUT«Use of uninitialized value $_ of type Any in string context  in block  at /tmp/UNX8gcIBrf:1␤The current value is .␤␤Use of uninitialized value $_ of type Any in string context  in block  at /tmp/UNX8gcIBrf:1␤The current value is .␤␤Use of unini…»

[10:38] <masak> hm, maybe it's not reasonable to expect that one to work...

[10:39] *** xiaomiao joined
[10:49] *** atroxaper left
[10:50] *** dayangkun left
[10:54] *** atroxaper joined
[10:58] *** amurf joined
[11:01] <masak> what's the Unicode-safe way to compare two strings case-insensitively. I always .lc both operands and then eq, but ISTR that doesn't always work.

[11:01] <jnthn> .fc

[11:01] <masak> m: say "Y".fc

[11:01] <camelia> rakudo-moar c0f03b: OUTPUT«Method 'fc' not found for invocant of class 'Str'␤  in block <unit> at /tmp/mKxfUC1aS2:1␤␤»

[11:01] <jnthn> Which somebody apparently needs to implement.

[11:01] <masak> well, .fc you too

[11:01] <masak> :P

[11:01] <jnthn> :D

[11:01] <jnthn> I was thinking the same :P

[11:01] <masak> grapevines think alike

[11:02] <jnthn> You heard that through the grapevine?

[11:02] <nwc10> you could just use Perl 5 :-)

[11:02] <masak> touché

[11:03] *** amurf left
[11:03] <nwc10> anyway, cool, we find somethign Perl 5 does better

[11:03] <jnthn> But then your strings are NFG for the other meaning... :P

[11:03] <nwc10> it's been a long time.

[11:03] <nwc10> some bugger fixed state in Perl 6.

[11:03] <jnthn> Somebody filed an RT calling us on not handling SpecialCasing.txt from Unicode too

[11:03] <masak> what was wrong with state in Perl 6?

[11:03] <nwc10> IIRC it couldn't do initialisers correctly

[11:04] <nwc10> ie the implied (as was) START on the right of the =

[11:04] <masak> oh!

[11:04] <masak> not sure I remember that.

[11:06] <jnthn> Yeah, we always assigned, not just on first time through

[11:06] <jnthn> This was back when "state $x = 42" parsed the = as an infix:<=>

[11:06] <jnthn> Which made everything hard, just about

[11:06] <nwc10> Perl 5 still can't do list assignment

[11:07] <nwc10> because TimToady says that (state @a) = (...) is not a START

[11:07] <nwc10> whereas state @a = (...) is

[11:07] <nwc10> and I couldn't figure out how to distinguish the two in the Perl 5 parser

[11:07] <masak> huh.

[11:07] <nwc10> (lex, yacc, smoke, mirrors - it has to be somewhere)

[11:08] <masak> m: sub foo { (state $n) = now; say $n }; foo; foo

[11:08] <camelia> rakudo-moar c0f03b: OUTPUT«Instant:1437131332.943274␤Instant:1437131332.947233␤»

[11:08] <masak> m: sub foo { state $n = now; say $n }; foo; foo

[11:08] <camelia> rakudo-moar c0f03b: OUTPUT«Instant:1437131351.818585␤Instant:1437131351.818585␤»

[11:09] <jnthn> That falls out of the intializer thing I mentioned before. :)

[11:10] *** atroxaper left
[11:13] <masak> "Shaped variable declarations not yet implemented. Sorry."

[11:13] <jnthn> Working on it :P

[11:13] <masak> this was actually due to a typo in my code. (leftover `my`)

[11:13] *** abraxxa left
[11:13] <masak> but that "Sorry." at the end breaks my heart </3

[11:13] <jnthn> :P

[11:14] <ShimmerFairy> You could also take it as a rude "Sorry" :P

[11:15] *** ely-se joined
[11:19] *** laouji joined
[11:23] <cdc> m: List.new(0).grep(0)

[11:23] <camelia> rakudo-moar c0f03b: ( no output )

[11:23] <cdc> m: List.new(0).grep(0).say

[11:23] <camelia> rakudo-moar c0f03b: OUTPUT«0␤»

[11:23] <cdc> m: Buf.new(0).grep(0).say

[11:23] <camelia> rakudo-moar c0f03b: OUTPUT«␤»

[11:23] <cdc> is this ^ a known issue?

[11:24] <masak> m: Buf.new(0).grep(1).say

[11:24] <camelia> rakudo-moar c0f03b: OUTPUT«Buf:0x<00>␤»

[11:24] <masak> there's your problem.

[11:24] <masak> Buf doesn't implement .grep

[11:24] <jnthn> Do .list on it to coerce it to a list so you can grep it

[11:24] <masak> arguably there should be a .grep that does .list for you in Buf

[11:25] <jnthn> Arguably; kinds depends how TimToady++ rules on one of my S09 questions :)

[11:25] <jnthn> *kinda

[11:25] <cdc> jnthn, masak: ok, thanks!

[11:30] <cdc> masak: I don't understand why Buf.new(0).grep(1).say returns Buf:0x<00>

[11:30] <jnthn> cdc: Because a Buf acts as a single item

[11:30] <ely-se> Buffet

[11:30] <jnthn> Just like a Str acts as a single item

[11:34] <cdc> m: Buf.new(0, 1).grep(1).say

[11:34] <camelia> rakudo-moar c0f03b: OUTPUT«␤»

[11:34] *** pecastro_ is now known as pecastro

[11:35] <cdc> jnthn: I'm still confused.

[11:36] <jnthn> cdc: .grep(1) is the same as .grep(* ~~ 1)

[11:37] <jnthn> Smart-match with a number on the RHS coerces the LHS to a numeric too

[11:37] <jnthn> A Buf in numeric context is the number of things in it

[11:37] <JimmyZ> m: Buf.new(0, 1).grep(Buf.new(0, 1)).say

[11:37] <camelia> rakudo-moar c0f03b: OUTPUT«␤»

[11:38] *** laouji left
[11:39] <RabidGravy> is there someone with commit on panda fancy merging https://github.com/tadzik/panda/pull/184

[11:39] <cdc> m: Buf.new(0, 1).grep(2).say

[11:39] <camelia> rakudo-moar c0f03b: OUTPUT«Buf:0x<00 01>␤»

[11:39] <cdc> jnthn: yeah, thanks :D

[11:41] <RabidGravy> the regular expression to get the provides isn't quite right but that was broken before

[11:42] <FROGGS> RabidGravy: wouldn't it make more sense if $deps was an array of package names?

[11:42] <FROGGS> instead of a boolean I mean

[11:46] <RabidGravy> possibly, it would enable other things to happen without the Builder/Tester having to know about it

[11:46] <RabidGravy> let me have a look

[11:53] *** okperl joined
[11:53] *** xfix joined
[11:53] *** xfix left
[11:53] *** xfix joined
[11:55] <masak> by the way, I don't dislike `quasi < ... >` because I'm the one (most likely) tasked with implementing it. :)

[11:55] <masak> it's not trivial to implement, but there's plenty of prior art, what with other quoting mechanisms in the Perl 6 grammar.

[11:56] <masak> I'm arguing against the feature because it seems both unnecessary and confusing.

[11:56] *** okperl left
[11:58] <ShimmerFairy> masak: And I agree with you :) . To me, it seems like one of those potential features that just seems nice to have, but not necessary at all.

[11:59] <arnsholt> Yeah. The body of a macro is very code-y, so it should look like code too.

[11:59] <masak> not even syre about the "nice to have"

[12:03] <vendethiel> having the opportunity to decide on how you want to quote is interesting for strings *because strings might contain the delimiter*

[12:03] <vendethiel> that can't happen in quasi blocks. what's the purpose?

[12:04] <RabidGravy> FROGGS, yeah that worked - changed it ;-)

[12:05] <masak> vendethiel: that's a really good point. maybe *the* point.

[12:06] *** cschwenz joined
[12:06] <cschwenz> o/ #perl6

[12:07] <vendethiel> \o

[12:07] <cschwenz> How would one go about correcting a minor error in the http://doc.perl6.org/language/syntax docs?

[12:08] <vendethiel> cschwenz: a pull request for this file. https://github.com/perl6/doc/blob/master/lib/Language/syntax.pod

[12:09] <cschwenz> thanks! :-)

[12:10] *** nightfrog joined
[12:10] *** atroxaper joined
[12:12] *** cschwenz left
[12:15] *** atroxaper left
[12:17] *** breinbaas joined
[12:20] *** yqt joined
[12:29] *** VinceDee joined
[12:30] *** jack_rabbit left
[12:33] *** lucasb joined
[12:36] <masak> m: my %h = <foo 1 baz 3>; say %h<foo bar baz>:k

[12:36] <camelia> rakudo-moar c0f03b: OUTPUT«foo baz␤»

[12:36] <masak> that is so nice.

[12:36] <jnthn> :)

[12:36] <masak> m: my %h = <foo 1 baz 3>; say %h<foo bar baz>:p.perl

[12:36] <camelia> rakudo-moar c0f03b: OUTPUT«foo => 1 baz => 3␤»

[12:37] *** llfourn left
[12:37] <masak> m: my %h = <foo 1 baz 3>; say %h<foo bar baz>:p>>.^name.perl

[12:37] <camelia> rakudo-moar c0f03b: OUTPUT«5===SORRY!5=== Error while compiling /tmp/3eijuFc6Nu␤Missing infix inside HYPER␤at /tmp/3eijuFc6Nu:1␤------> 3= <foo 1 baz 3>; say %h<foo bar baz>:p>>7⏏5.^name.perl␤    expecting any of:␤        infix␤        infix stopper␤»

[12:37] <masak> m: my %h = <foo 1 baz 3>; say %h<foo bar baz>:p.map(*.name).perl

[12:37] <camelia> rakudo-moar c0f03b: OUTPUT«foo => 1 baz => 3␤Method 'name' not found for invocant of class 'Bool'␤  in block <unit> at /tmp/Dt8OtHYwV_:1␤␤»

[12:37] <masak> m: my %h = <foo 1 baz 3>; say (%h<foo bar baz>:p).map(*.^name).perl

[12:37] <camelia> rakudo-moar c0f03b: OUTPUT«("Pair", "Pair")␤»

[12:37] <masak> note to self: precedence is tricky.

[12:39] *** andreoss joined
[12:44] <gfldex> m: my %h = <foo 1 baz 3>; say %h<foo bar baz>:p ==> map(*.^name).perl

[12:44] <camelia> rakudo-moar c0f03b: OUTPUT«5===SORRY!5=== Error while compiling /tmp/S0zeygebJV␤Sorry, do not know how to handle this case of a feed operator yet.␤at /tmp/S0zeygebJV:1␤------> 3 %h<foo bar baz>:p ==> map(*.^name).perl7⏏5<EOL>␤»

[12:44] <gfldex> should it know that or am i asking to much?

[12:46] <masak> how do I match "end of paragraph" in a regex?

[12:46] <jnthn> masak: Define "paragraph"?

[12:47] <masak> (a sequence of non-blank lines that doesn't have a non-blank line after it)

[12:48] <dalek> rakudo-star-daily: 09be539 | coke++ | log/ (9 files):

[12:48] <dalek> rakudo-star-daily: today (automated commit)

[12:48] <dalek> rakudo-star-daily: review: https://github.com/coke/rakudo-star-daily/commit/09be5399f2

[12:48] <jnthn> token end-para { <?before \n [\n || $]> } # ?

[12:49] <[Coke]>  -> (22:47) From Garance [@vcc], to coding:

[12:49] <[Coke]>  -  ``Put #Haskell on your resume even if you don't know it. When asked, say

[12:49] <[Coke]>  - that your resume is lazy, and you'll learn Haskell when results are needed''

[12:49] <masak> jnthn: yeah, that's what I ended up with.

[12:49] <_itz> [Coke]: hahaha

[12:50] <jnthn> You can also comfort your potential employer that this approach will have no bad side-effects :P

[12:50] <masak> unless your employer is in a monad, then all bets are off

[12:50] <_itz> *groan*

[12:51] <cdc> Is this a known defect? https://gist.github.com/anonymous/b794343a6e6713fca614

[12:52] <masak> cdc: first off, nice golf.

[12:52] <masak> cdc: I didn't know it, but I'm not up to speed on precompilation woes.

[12:52] <jnthn> Bugger, another pre-comp bug.

[12:52] <masak> guess that answers it.

[12:52] <jnthn> I can't guess who'll have to fix that one :P

[12:52] <masak> cdc: you you want to submit it to rakudobug, or shall I?

[12:53] <cdc> masak: I will, thanks.

[12:53] <masak> cdc++

[12:55] *** cognominal left
[12:59] <cdc> RT #125634 (with the right code/output this time)

[12:59] <synbot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=125634

[13:03] <masak> pro tip: don't write ^ when you mean ^^. your regex won't match most of the time. :)

[13:05] <cdc> m: say ?('most of the time.' ~~ /^/)

[13:05] <camelia> rakudo-moar c0f03b: OUTPUT«True␤»

[13:05] <cdc> it matches most of the time \

[13:05] <cdc> \o/

[13:05] <jnthn> :D

[13:06] <masak> bwha. ha. :)

[13:06] <cdc> :)

[13:13] <masak> m: $*PROGRAM-NAME = "foo"

[13:13] <camelia> rakudo-moar c0f03b: OUTPUT«Cannot modify an immutable Str␤  in block <unit> at /tmp/KZrMAJJp7R:1␤␤»

[13:13] <masak> is there a good reason for $*PROGRAM-NAME to be immutable?

[13:14] <masak> would make a lot of sense to me if it were mutable.

[13:14] <jnthn> What do you expect mutating it to do?

[13:14] <masak> oh, just change its contents.

[13:14] <masak> nothing more magical than that.

[13:14] <jnthn> Trouble is, folks may expect more magic...

[13:14] <masak> I have code here that makes it seem like it worked, and I had use for it.

[13:14] <masak> now I'll have to copy it into another variable and use that...

[13:15] <jnthn> masak: Look up $0 in http://perldoc.perl.org/perlvar.html

[13:16] *** llfourn joined
[13:16] <masak> jnthn: um, yes. point taken.

[13:16] * masak tries not to want that, then

[13:17] * ShimmerFairy still thinks kebab-casing looks utterly wrong on allcaps names :)

[13:18] *** [Sno] left
[13:20] <Juerd> ShimmerFairy: Besides, [shift] + [-] ==> "_"

[13:20] <masak> ShimmerFairy: as I changed my code, I accidentally wrote $*PROGRAM_NAME somewhere, and got a deprecation warning at the end of my run :/

[13:20] <Juerd> So _ is prettier and easier to type (on a US keyboard, at least)

[13:20] <Juerd> That is, for allcaps identifiers

[13:20] <ShimmerFairy> Juerd: exactly my reasoning.

[13:21] <Juerd> And if when reading [shift], your first thought is "shift is not infix", you may have been using Perl 6 for too long already :D

[13:21] <ShimmerFairy> I find the kebab-case renaming to be utterly pointless in general, but with UPPER_CASE names it's detrimental (and I think $*PROGRAM_NAME is a good example of where the classic "but it'll make it rightly harder to type" really shines as the non-reason it is)

[13:22] <Juerd> $non-reason

[13:22] * masak is glad that someone else is arguing against kebab-case, but is also willing to accept that we changed it once, it was bad, now let's just regret that and not change it back, which would be worse

[13:23] <Juerd> use _;  # fixed! ;-)

[13:23] <masak> haha

[13:23] <[Coke]> I like kebab case.

[13:23] <ShimmerFairy> masak: I got an idea, just give me a moment :P

[13:23] <[Coke]> whatever we do should be consistent.

[13:24] <Juerd> Who will write _.pm?

[13:24] <[Coke]> not me. ;)

[13:24] <[Coke]> so, if you want to change it back, great, but a compromise of stopping changing things now is bad.

[13:24] <ShimmerFairy> [Coke]: I like it for lowercase names (like sub do-thing) , but not for uppercase (like sub DO-THING). Perl 6 has made me think of _ as an uppercase - , so DO-THING is eqv. to DOtHING in my mind

[13:25] *** mr-foobar left
[13:25] <[Coke]> ShimmerFairy: and I think TimToady already mentioned that making it harder to type things like MONKEY-TYPING is a -good- thing.

[13:25] <masak> I don't like that line of reasoning.

[13:25] <ShimmerFairy> but PROGRAM_NAME is a good example of where that doesn't even make sense

[13:25] <[Coke]> (making it harder to type PROGRAM-NAME is arguably bad.)

[13:26] <ShimmerFairy> And, frankly, when it comes to -/_, "harder to type" is just bullshit.

[13:26] *** st_iron left
[13:26] <masak> "yup, we thought about it, and we decided we *want* the language to be inaccessible. just so that you will stop and think how bad you are for wanting that particular feature. (because we know better.)"

[13:26] <[Coke]> I don't think it's that harder to type. Especially with an IDE.

[13:27] <lucasb> Since I turn caps on/off to type ALLCAPS, it is actually easier :)

[13:27] <[Coke]> masak: some times there is a wrong way to do it.

[13:27] <[Coke]> ... caps... on and off? like a ... capslock? 

[13:27] <lucasb> yes

[13:27] <[Coke]> first thing I do on a new system is map capslock to control. :)

[13:28] *** FROGGS left
[13:28] <masak> [Coke]: but you just said "(making it harder to type PROGRAM-NAME is arguably bad.)"

[13:28] <masak> [Coke]: my point is that it's presumptuous of us to pessimise all future uses of something.

[13:29] <[Coke]> masak: I was pointing out what timtoady said, and then anticipating the argument. that's all.

[13:29] <[Coke]> masak: ... we are making something new, we kind of have to be presumptuous.

[13:30] <[Coke]> anyway: I don't care so much either way this ends, except: pick a consistent set of rules and let's follow them.

[13:30] <masak> usually I like the flavor of presumptuousness we employ. this is the exception.

[13:30] <[Coke]> don't have some stuff use _ and some use - if they are otherwise lookalike. if this means uppercase gets _ and lowercase gets -, that's OK to me. but I don't want some-stuff and some_other_stuff.

[13:31] <masak> [Coke]: yeah, I also don't have a corgi in this race. there are two competing notions of consistency here, is all.

[13:31] <[Coke]> if it means that some COMMON_STUFF and some UNCOMMON-STUFF, I'm also ok with that. it's teachable.

[13:34] *** yqt left
[13:39] <ShimmerFairy> I can't help but feel like FOO-BAR is entirely based in a desire to show off the fact that we can use dashes in our identifiers.

[13:39] *** skids joined
[13:41] *** ely-se left
[13:41] <PerlJam> good morning!

[13:42] * PerlJam reads scrollback to see what's new on the - vs _ front

[13:43] *** g4 left
[13:45] <timotimo> tbh, i'd like $PROGRAM-NAME to be rw

[13:45] <timotimo> and have the semantics $0 had in perl5

[13:49] <RabidGravy> doesn't it depend on the behaviour of the OS on p5?

[13:50] <DrForr> m: "a{uc("foo")}b"

[13:50] <camelia> rakudo-moar c0f03b: ( no output )

[13:51] <DrForr> Oddly it works from the CLI..

[13:52] <PerlJam> What are the really good reasons that people want to over-write the name of the program?  I can think of reasons, but nothing that compels me to argue for (or against) the feature.

[13:52] <geekosaur> generally it's so a daemon can show its current state via ps

[13:53] *** FROGGS joined
[13:53] <PerlJam> yeah, that doesn't strike me as good enough.  :)

[13:54] <lucasb> If it was meant to be immutable, shouldn't it be $?PROGRAM-NAME ? but $*PROGRAM-NAME gives the impression that it *is* mutable

[13:54] <lucasb> Yes there any constant-like thing in P6 that is sigilless?

[13:55] <lucasb> *Is there any...

[13:55] <cdc> m: pi

[13:55] <camelia> rakudo-moar c0f03b: ( no output )

[13:55] <cdc> m: pi.say

[13:55] <camelia> rakudo-moar c0f03b: OUTPUT«3.14159265358979␤»

[13:56] <masak> DrForr: `say`

[13:56] <masak> m: say "a{uc("foo")}b"

[13:56] <camelia> rakudo-moar c0f03b: OUTPUT«aFOOb␤»

[13:56] <ShimmerFairy> Well, $? is for compile-time constants, $* for run-time

[13:57] <timotimo> we could keep the original PROGRAM-NAME around in the $? one

[13:57] <DrForr> I'm just surprised at thee nested quoting, though I suppose it's the {} keeping things together.

[13:57] <timotimo> well, "keep around" isn't really correct, is it? if it's substituted at compile time :)

[13:57] <timotimo> DrForr: yeah, inside { } we parse regular perl6 code again

[13:57] <jnthn> Yeah, $?PROGRAM-NAME would be the program name we compiled

[13:57] <DrForr> Yep, I'll call that a feature.

[13:57] <jnthn> DrForr: It's certainly a feature :)

[13:57] <masak> PerlJam: my use case was "if $*PROGRAM-NAME is a symlink, then follow the symlink and assign back to $*PROGRAM-NAME. later, use the directory of $*PROGRAM-NAME to find a data directory in the directory of the original script file"

[13:58] <jnthn> That we can do that is actually one of the key things about Perl 6 parsing.

[13:58] <jnthn> We always know what langauge we're in.

[13:58] <masak> DrForr: I used to hate that you could have "" in {} in ""

[13:58] <masak> DrForr: I've since come around.

[13:58] <ShimmerFairy> If we had $?PROGRAM_NAME, I'm not sure if I'd want $*PROGRAM_NAME to be writable (as it stands, I currently think it's better to not have it writable)

[13:59] <PerlJam> masak: but you only needed $*PROGRAM-NAME assigned internally, not externally?

[13:59] *** atroxaper joined
[13:59] <masak> PerlJam: yes, it wasn't necessary for me to have any side-effects.

[13:59] <timotimo> ShimmerFairy: can you explain a bit more?

[13:59] <geekosaur> wait, is this the actual executable name / argv0 or the script?

[13:59] <timotimo> it's supposed to be that, yeah

[13:59] <masak> PerlJam: it was just convenient. and generally with $*FOO variables I expect to be able to assign to them.

[13:59] <DrForr> Well, I'm sold only if it's because it saved me about 40 minutes of work.

[14:00] <[Coke]> why would you need to override it internally instead of providing your own $* variable to track whatever it is you're tracking?

[14:00] <ShimmerFairy> timotimo: if we had $?PROGRAM_NAME as a non-writable copy of the original program name, then I could see both arguments for $*PROGRAM_NAME's writability. But since we only have $*, I think it's better to not let someone accidentally toss that info forever.

[14:00] <DrForr> Explaining that the translation actually works in the doco will be .. fun, though.

[14:01] <timotimo> oh, i think i misread, ShimmerFairy 

[14:01] <timotimo> i thought you were against $* being writable if $? exists

[14:01] <masak> [Coke]: that's what I rewrote it as.

[14:02] <ShimmerFairy> timotimo: if $? exists, then I could see both sides for $* being writable or not, and further if it should do more than just change a string.

[14:02] <masak> [Coke]: just noting that it (most probably) used to work the way I had used it.

[14:03] <[Coke]> masak: roger

[14:03] *** atroxaper left
[14:04] <masak> errand &

[14:07] *** khw joined
[14:12] *** someone_ joined
[14:13] *** someone_ left
[14:21] *** [Sno] joined
[14:24] *** cschwenz joined
[14:24] *** cschwenz left
[14:34] *** estrabd joined
[14:36] *** amurf joined
[14:36] <_itz> I'm using .perl and EVALFILE to serialize and it's slow .. are there any obvious tricks to speed up?

[14:37] *** brrt joined
[14:40] *** amurf left
[14:43] *** AlexDaniel joined
[14:51] <timotimo> at some point we'll likely want a "sereal" implementation

[14:59] <masak> what's a "sereal" implementation?

[15:00] <PerlJam> masak: https://metacpan.org/pod/Sereal

[15:00] * masak .oO( ah, the spelling was actually sereous )

[15:03] <AlexDaniel> if some sub is cached, is there any way to force it run again?

[15:05] <PerlJam> have a non-cached version and run that?

[15:08] <AlexDaniel> oooooohh...

[15:09] <AlexDaniel> "This trait is a suggestion to the compiler that caching is okay. The compiler is free to choose any kind of caching algorithm (including non-expiring, random, lru, pseudo-lru, or adaptive algorithms, or even no caching algorithm at all)."

[15:09] <AlexDaniel> "Proper use of this trait should not change semantics of the program"

[15:09] <AlexDaniel> it seems like I misunderstood it

[15:09] <AlexDaniel> I mean, I've always thought that it is something I can rely on

[15:10] <AlexDaniel> and S06 says that I shouldn't, well, ok

[15:10] <PerlJam> you can rely on it!  It will always be there for you.  :)

[15:11] <PerlJam> AlexDaniel: Why do you want to use "is cached" in the first place?  What are you trying to do?

[15:11] *** yqt joined
[15:11] <dalek> doc: 76d6ae3 | (Steve Mynott)++ | lib/Language/5to6.pod:

[15:11] <dalek> doc: correct example to unit module

[15:11] <dalek> doc: review: https://github.com/perl6/doc/commit/76d6ae323a

[15:13] <AlexDaniel> PerlJam: nothing right now. But I remember doing something like sub getId(...) is cached { rand }

[15:13] *** VinceDee left
[15:13] *** JimmyZ_ joined
[15:13] <ugexe> it means you shouldnt change your program to act differently based on adding that trait. so taking into account side effects its not usually as easy as just adding 'is cached' or 'memoize(func)'

[15:17] <AlexDaniel> well, what are the chances that this will be a pitfall...

[15:17] <PerlJam> I suppose it would be nice if "is cached" had a way to say "call this sub without caching" for the case where you want to debug your code to make it side effect free or something.

[15:17] <ugexe> memoize was always a pitfall for me personally. but it was always an afterthought add-on

[15:22] *** brrt left
[15:28] <ugexe> the use of '--ll-exception' allows Test.pm to give a proper non-0 exitcode when it fails to find a dependency. maybe we can now figure out how to accomplish this without the huge stacktrace

[15:31] <ugexe> examples can be seen here: https://gist.github.com/ugexe/ea87a90e4fd04fe74986

[15:34] *** andreoss left
[15:34] <ugexe> this appear to have led to many modules being marked as passing although they wont install unless you luckily have whatever depends they didnt put in their meta already

[15:35] * [Coke] prefers Pickle over Sereal.

[15:36] <jnthn> Note that since "is cached" is simply a trait, you can easily write modules that export alternative implementations.

[15:36] <jnthn> To get the policy/control you want

[15:37] *** ][Sno][ joined
[15:37] * _itz prefers milk over cereal

[15:38] *** [Sno] left
[15:39] * nwc10 is thinking about beer

[15:40] * [Coke] sips quietly on his diet soda. :P

[15:40] <nwc10> I have a timezone advantage.

[15:40] <nwc10> which will be a disadvantage in about 60 hours :-)

[15:44] * ugexe arm7 jvm rakudo has been building for... 14 hours and counting heh

[15:44] <_itz> I keep meaning to try QEMU arm

[15:45] *** FROGGS left
[15:47] *** captain-adequate joined
[15:47] *** recojax left
[15:48] *** zakharyas left
[15:48] *** mr-foobar joined
[15:49] <PerlJam> :q

[15:49] <PerlJam> :":q!

[15:49] <PerlJam> blah

[15:52] <[Coke]> nwc10: you may also have a carb advantage :)

[15:54] *** webstrand joined
[15:58] *** atroxaper joined
[15:58] <webstrand> Has perl6 done away with temporary values, as provided by perl5's local? Dynamic variables aren't quite the same, because they require the $*twigil

[15:58] <PerlJam> webstrand: nope, just changed the declarator.  It's "temp" now.

[16:00] <PerlJam> m: my $foo = 27;  { temp $foo = 14; say $foo; }; say $foo;  # for example

[16:00] <camelia> rakudo-moar c0f03b: OUTPUT«14␤27␤»

[16:02] <[Coke]> m: say 237-183

[16:02] <camelia> rakudo-moar c0f03b: OUTPUT«54␤»

[16:03] * vendethiel is not sure when $* twigil + temp is useful?

[16:04] <[Coke]> m: my $*FOO = 3; sub bar { $*FOO = 4 } ; bar; say $*FOO;

[16:04] <camelia> rakudo-moar c0f03b: OUTPUT«4␤»

[16:04] *** atroxaper left
[16:04] <[Coke]> m: my $*FOO = 3; sub bar { temp $*FOO = 4 } ; bar; say $*FOO;

[16:04] <camelia> rakudo-moar c0f03b: OUTPUT«3␤»

[16:04] <ugexe> temp $*CWD

[16:04] *** diana_olhovik_ joined
[16:04] <[Coke]> that's a much better sample variable, aye. :)

[16:04] <jnthn> vendethiel: Often when you want to keep the existing value, allowing modification in deeper dynamic scopes, but restore the value on exit

[16:04] <vendethiel> m: my $*a = 5; sub f { say $*a; }; f; { $*a = 6; f; say ';;;;'; { my $*a = 7; f; }; '||||'.say; f; }; f; # [Coke]

[16:04] <camelia> rakudo-moar c0f03b: OUTPUT«5␤6␤;;;;␤7␤||||␤6␤6␤»

[16:05] <vendethiel> jnthn: ^ isn't that already the case with a "my"?

[16:05] <vendethiel> oh, yes, sorry.

[16:05] <jnthn> vendethiel: my $*FOO gives you an empty $*FOO

[16:05] <vendethiel> then, $* twigil + temp + assignment

[16:05] <jnthn> Oh, right

[16:05] <jnthn> Yeah, if you're assigning right off and using temp on a dynamic it's a bit odd :)

[16:06] *** domidumont left
[16:08] <dalek> rakudo/nom: 48c0ba5 | PerlJam++ | src/core/Any.pm:

[16:08] <dalek> rakudo/nom: Fix RT #116731

[16:08] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/48c0ba5d63

[16:08] <synbot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=116731

[16:12] *** nys joined
[16:14] <dalek> roast: a8a86ef | PerlJam++ | S32-list/map.t:

[16:14] <dalek> roast: Add a test for RT #116731

[16:14] <dalek> roast: review: https://github.com/perl6/roast/commit/a8a86ef608

[16:14] <synbot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=116731

[16:15] *** diana_olhovik_ left
[16:20] *** ChoHag joined
[16:21] <webstrand> Has rakudo implemented class DESTROY methods yet? The roast's S12-construction/destruction.t doesn't pass on my machine, but occasionally segfaults

[16:21] *** espadrine_ left
[16:27] <jnthn> webstrand: Only on MoarVM, and they're apparently not especially well tested. You shouldn't be able to get a SEGV though...

[16:28] <jnthn> webstrand: Also important to note that we don't make any promise about how timely their being called will be, or promise to call them at all at shutdown. Also if an object is resurected DESTROY won't be called a second time.

[16:29] * jnthn has run it a bunch of times but can't get a SEGV out of it.

[16:29] <webstrand> I'm using moarvm, though I don't know if i'm using JIT or not. I know there's no calling guarentee.

[16:29] <webstrand> try increasing the iterations from 100 to 1000? it's consistant segv for me then

[16:30] <jnthn> I have to increase it to 10000 before it actually GCs, and then I get two more passes...

[16:31] <JimmyZ_> maybe he is on OSX?

[16:31] <jnthn> heh :)

[16:31] <jnthn> Well, running it under ASAN might be informative.

[16:31] <jnthn> The GC code isn't platform specific in this area.

[16:32] <JimmyZ_> I dont know why it is easy to get a seg on OSX...

[16:32] <webstrand> I'm running on archlinux with rakudo, moarvm, nqp version 2015.06

[16:34] <jnthn> Even bumping it up to millions of iterations I don't segv it on Windows.

[16:35] <jnthn> Will have to try it on Linux.

[16:35] <jnthn> Or if somebody's got an ASAN'd build to hand...

[16:35] * jnthn glances at nwc10 :)

[16:35] <webstrand> How would I use asan? I can rebuild anything i need to

[16:36] <nwc10> I got "not ok" for tests 3 to 6

[16:36] <nwc10> but ASAN was barf free

[16:36] <jnthn> Aww

[16:36] <jnthn> nwc10: And if you bump the for loop up to 10000 iteratinos or so?

[16:37] <jnthn> webstrand: Just re-configuring MoarVM with the ASAN option and rebuilding/installing MoarVM should do it...you don't need to rebuild NQP and Rakudo iirc

[16:39] *** domidumont joined
[16:40] <nwc10> jnthn: http://paste.scsys.co.uk/493506

[16:40] <nwc10> vanilla SEGV

[16:40] * nwc10 rebuilds to see what valgrind thinks

[16:40] <nwc10> so. there is *something* wrong here.

[16:40] <jnthn> yowser

[16:44] *** webstrand left
[16:57] *** webstrand joined
[17:00] *** atroxaper joined
[17:05] *** telex left
[17:05] *** atroxaper left
[17:06] *** telex joined
[17:10] <lizmat> good *, #perl6!

[17:10] <nwc10> good UGT, lizmat 

[17:10] <lizmat> YAWWP6W   :-(

[17:11] <lizmat> Yet Another Week Without Perl 6 Weekly

[17:13] <lizmat> nwc10 o/

[17:13] <geekosaur> aka WATWEEK?

[17:13] *** FROGGS joined
[17:14] <masak> o/, lizmat 

[17:14] <lizmat> masak \o

[17:15] <masak> ok, this use case turned up today -- see if #perl6 can help with it :) I have $topdir, $subdir, and $otherdir, all of them directories and IO::Path objects. we happen to know that $subdir is a few levels nested under $topdir.

[17:15] <masak> now I want the following operation: "the 'same' subdirectory as $subdir relative to $topdir, but under $otherdir"

[17:16] <masak> and I want this in a safe way that doesn't include messing with path strings. and that works regardless of whether each of the three is a relative or absolute path.

[17:17] <masak> example: have `foo/bar/`, `foo/bar/a/b/c/`, and `baz/` -- want `baz/a/b/c/`

[17:18] <masak> i.e. $topdir is the "common prefix" of $topdir itself and $subdir. remove that common prefix and replace it with $otherdir.

[17:19] <tony-o> is rakudo build broken on moar right now?

[17:19] <tony-o> https://gist.github.com/tony-o/951c2342c4e656547212

[17:20] *** diana_olhovik_ joined
[17:20] <ugexe> i do this for /path/lib/ -> /path/blib/lib by catdir the relative paths and then call .absolute($basedir), although its hard for me to explain better

[17:20] * masak gets the spooky sensation that the problem he's describing is categorially a https://en.wikipedia.org/wiki/Pushout_(category_theory)

[17:24] *** domidumont left
[17:24] <ugexe> oh the common part i overlooked. for that i look at .parts

[17:24] <ShimmerFairy> masak: Something hypothetical I thought up of would be  $subdir.chroot($topdir)  and then however you actually do  $otherdir ~ $subdir

[17:25] <ChoHag> Check your assumption. HOW do you know $subdir is under $topdir? The means of determining that HOW should provide enlightenment.

[17:25] *** xinming joined
[17:25] <ugexe> if your paths are resolved the same then you just extract the unique pairs of the 2 .parts array

[17:27] <ugexe> if they are IO::Paths then you have the cwd to determine that

[17:27] <ugexe> or abs path. if passed as a string then you wouldnt be able true

[17:28] *** domidumont joined
[17:29] <geekosaur> tony-o, fwiw build just succeeded here

[17:29] <tony-o> geekosaur++ ty

[17:32] <webstrand> jnthn: The segfault disappears if I edit Test::is to remove the Mu:U annotation, like  multi sub is(Mu $got, $expected, $desc = ''). Moreover, if I redefine is in my local file, the compiler claims that Mu:U doesn't match type Str and refuses to compile.

[17:34] *** xinming left
[17:35] *** xinming joined
[17:35] *** Foxcool_ left
[17:36] *** pnu left
[17:36] *** Foxcool joined
[17:38] *** pnu joined
[17:38] *** yqt left
[17:39] *** JimmyZ_ left
[17:39] *** atroxaper joined
[17:41] <atroxaper> Hello, #perl6 !

[17:42] <masak> atroxaper: \o

[17:42] *** domidumont left
[17:42] <masak> ChoHag: a very good point.

[17:43] <atroxaper> Do somebody know some literature about rating systems? Like ELO. Something else. Maybe for not two people.

[17:43] <atroxaper> masak: o/

[17:43] <masak> ChoHag: I guess one way is to start at $subdir and keep peeling off the last path component until either $topdir is reached, or we're trying to peel '/' and the hypothesis is disproved.

[17:43] *** Foxcool left
[17:44] *** llfourn left
[17:44] <masak> ChoHag: and then (assuming success) we kind of want to "un-peel" those path components, in reverse, onto $otherdir.

[17:44] * masak feels like writing some tests

[17:44] *** Foxcool joined
[17:47] <timotimo> did i write anything to the channel? cat lounged on the keyboard for a bit ...

[17:47] <timotimo> seems not so

[17:48] <timotimo> lizmat: the good news is i already have a tab open with he wordpress editor :S

[17:48] <_itz> https://github.com/RichyRich/AntiCat <=- OS X specific

[17:51] <webstrand> What is the meaning of :U in a subroutine declaration like `sub example(Mu:U $a) {}`?

[17:53] <timotimo> the sub requires the parameter $a to be undefined, i.E. a Type Object

[17:53] <timotimo> the opposite is :D, which requires a defined value to be passed

[17:54] <ugexe> m: sub foo(Mu:U $x) { say $x.WHAT }; my $a = Mu.new; my $b; foo($b); foo($a);

[17:54] <camelia> rakudo-moar 48c0ba: OUTPUT«(Any)␤Parameter '$x' requires a 'Mu' type object, but an object instance was passed␤  in sub foo at /tmp/cvwlpU2Bjh:1␤  in block <unit> at /tmp/cvwlpU2Bjh:1␤␤»

[18:03] <nwc10> jnthn: valgrind doesn't add much: http://paste.scsys.co.uk/493524

[18:04] *** llfourn joined
[18:04] <nwc10> well, other than "no undefined behaviour before the NULL pointer dereference"

[18:05] <timotimo> so, we have a MVMString that's actually null get MVM_string_graphs called on it?

[18:06] <timotimo> might want to go into #moarvm?

[18:07] *** atroxaper left
[18:08] <webstrand> timotimo: How is :U defined? Can I add custom :<arbitrary> to my own classes?

[18:09] <timotimo> no, those are defined by the language; they are called "Type Smileys"

[18:10] *** diana_olhovik_ left
[18:10] <PerlJam> webstrand: see S12:1616

[18:10] <synbot6> Link: http://design.perl6.org/S12.html#line_1616

[18:10] *** cognominal joined
[18:10] <cdc> webstrand: you can use constraint on parameter instead

[18:11] <timotimo> right, or subset types

[18:11] <cdc> m: multi sub foo($a where * > 3) { say '> 3' }; multi sub foo($a where * <= 3) { say '> 3' }; foo(2)

[18:11] <camelia> rakudo-moar 48c0ba: OUTPUT«> 3␤»

[18:11] <cdc> m: multi sub foo($a where * > 3) { say '> 3' }; multi sub foo($a where * <= 3) { say '<= 3' }; foo(2)

[18:11] <camelia> rakudo-moar 48c0ba: OUTPUT«<= 3␤»

[18:11] <cdc> better :)

[18:11] <cdc> m: multi sub foo($a where * > 3) { say '> 3' }; multi sub foo($a where * <= 3) { say '<= 3' }; foo(5)

[18:11] <camelia> rakudo-moar 48c0ba: OUTPUT«> 3␤»

[18:13] *** amurf joined
[18:17] *** diana_olhovik joined
[18:18] *** amurf left
[18:18] * TimToady should probably not make any decisions today, since he's without caffiene before his endoscopy, and will undoubtedly be looped out after it...

[18:19] * ShimmerFairy wonders if that counts as a decision...

[18:19] <PerlJam> but ... isn't your decision to not make any decisions itself a decision?

[18:19] <nwc10> without caffeine - isn't there something in the constitution about "cruel and unusual punishment"?

[18:19] * TimToady suspects it falls in the category of no-brainer

[18:20] <timotimo> TimToady: i wish you the best of luck with that

[18:20] * TimToady doesn't know what to wish, for them to find something, or not...

[18:21] <timotimo> hopefully they'll find you do still have a colon

[18:21] <[Coke]> May you get the best result possible.

[18:22] *** llfourn left
[18:22] <timotimo> [Coke]: they find some gold in there and make him lots of money?

[18:23] <TimToady> whoops, they just called and said come in early, which I don't mind at all

[18:23] <TimToady> catch y'all on the flip side

[18:23] <ShimmerFairy> return $*BEST_CHOICE;

[18:23] <TimToady> afk &

[18:24] <TimToady> :)

[18:24] <ShimmerFairy> see ya! o/

[18:24] <PerlJam> TimToady: good luck!

[18:31] <masak> good luck, wish for a happy endoscopy!

[18:38] *** yqt joined
[18:39] *** eternaleye joined
[18:59] *** coachshea joined
[18:59] *** coachshea left
[19:09] <timotimo> god damn you, wordpress

[19:12] <lucasb> Let's make the p6weekly in blog.perl6.org using jekyll :)

[19:12] <timotimo> it almost nommed my post

[19:12] <timotimo> fortunately, i could get it back

[19:12] <timotimo> but for two minutes it seemed like the text was gone foreverr

[19:13] <timotimo> and i forgot to write a title %)

[19:16] <cdc> timotimo++  # p6weekly

[19:16] <masak> timotimo: the jaded web user always Ctrl+C before pressing "Submit". :)

[19:16] <timotimo> yeah

[19:16] <timotimo> fortunately, javascript has these things called "localstorage" and "session storage" that can keep stuff around

[19:23] * masak notices in passing that what Dependency::Sort does in 163 lines, ufo used to do in 20

[19:23] <masak> https://github.com/jaffa4/Dependency-Sort/blob/master/lib/Dependency/Sort.pm6#L54-L216

[19:24] <masak> https://github.com/masak/ufo/blob/bd412a11d2653cc44b86fbcb4ae8b97f954e07fd/bin/ufo#L162-L181

[19:24] <ugexe> the rosetta code one also sorts them into parallizable levels

[19:24] <masak> what I'm saying is, jaffa4 would probably love patches from all of us.

[19:24] <masak> we could help turn his code shorter and more idiomatic.

[19:25] <masak> also note there's a test() sub below that code, which probably should go into a t/*.t file using Test.pm instead

[19:26] <masak> oh, and if someone wants to PR this line (which now should work), I will happily merge that PR: https://github.com/masak/ufo/blob/master/bin/ufo#L215

[19:36] <ugexe> the fun part of the topo sort on p6 modules is taking into account multiple package names inside the same file

[19:37] <ugexe> otherwise you end up coloring the same module multiple times while inside a single file

[19:38] *** diana_olhovik__ joined
[19:39] *** FROGGS left
[19:39] *** diana_olhovik left
[19:41] <ugexe> i modified the rosetta code version to work with an array of meta files, and then treat provides as their actual file names

[19:43] *** espadrine_ joined
[19:44] <ugexe> that way %seen{A::B} and %seen{A::C} and treated properly if they are both packages in the same file, ala %seen{/lib/A.pm}

[19:47] <ugexe> ive also found it helpful for when i want to build a distribution but not install each repo before attempting to build/test the module that was explicitly requested

[19:56] *** espadrine_ left
[19:57] *** lucasb left
[19:59] *** _itz_ joined
[20:01] *** kyclark joined
[20:03] *** amurf joined
[20:07] *** amurf left
[20:08] *** bin_005 joined
[20:11] *** webstrand left
[20:18] *** llfourn joined
[20:20] *** kyclark left
[20:21] *** kyclark joined
[20:21] *** kyclark left
[20:22] *** xfix left
[20:22] *** llfourn left
[20:23] *** darutoko left
[20:24] *** webstrand joined
[20:31] *** diana_olhovik__ left
[20:36] *** raiph joined
[20:57] <PerlJam> Is there a functioning "try perl6 in the browser" thingy somewhere?

[21:01] <masak> no.

[21:01] <masak> I guess we are all waiting for pmurias++ to surprise us with one, one of these days :>

[21:02] *** webstrand left
[21:06] *** lucasb joined
[21:09] *** bin_005 left
[21:10] *** bin_005 joined
[21:12] *** skids left
[21:16] *** webstrand joined
[21:30] <lucasb> About what ugexe said in the backlog about Test.pm, I just want to add my understanding of the issue:

[21:31] <lucasb> Since Test.pm has and END phasers with exit(0), one can type any arbitrary text and the script will always exit successfully

[21:32] <lucasb> With the --ll-exception option, the END phasers are not run

[21:32] <lucasb> perl6 -e 'use Test; asdf' && echo ok

[21:32] <lucasb> perl6 -e 'die; END { exit 0 }' && echo ok

[21:32] <lucasb> perl6 --ll-exception -e 'die; END { say "hi" }'

[21:35] <lucasb> So I guess the question is: should END phasers run when an exception/failure is throw?

[21:36] <PerlJam> lucasb: what if sometimes the answer is "yes" and sometimes it's "no"?  :)

[21:39] <lucasb> PerlJam: yeah, I don't know how this should be handled :)

[21:49] *** dolmen joined
[21:51] *** webstrand left
[21:56] *** vendethiel left
[22:19] *** TEttinger joined
[22:19] *** vendethiel joined
[22:28] *** lucasb left
[22:30] *** Arpho joined
[22:30] *** Arpho left
[22:38] <timotimo> i think we want something somewhere that gets rid of assignments to $?ROUTINE if it's not needed ...

[22:40] <masak> that sounds like it could be statically knowable.

[22:44] *** vendethiel left
[22:47] <timotimo> right, i think it ought to be

[22:47] <timotimo> don't really know why it shows up in the code we gen

[22:48] <timotimo> possibly because we want CALLER::('$?ROUTINE') or something?

[22:55] *** kaare_ left
[23:09] *** skids joined
[23:16] *** RabidGravy left
[23:19] *** llfourn joined
[23:19] *** dolmen left
[23:19] *** nightfrog left
[23:23] *** nightfrog joined
[23:23] *** llfourn left
[23:32] <timotimo> i'm too dumb to use the act user management

[23:32] <timotimo> when i try to register, it says there's already a user similar to that, when i try to "forgot password", it says "no such user"

[23:33] <geekosaur> "similar to"

[23:40] *** amurf joined
[23:41] <timotimo> well, that one is me :)

[23:42] <timotimo> and it has the login that i'm trying to use to recover my passwor

[23:44] <masak> software. it sucks.

[23:45] *** amurf left
[23:45] <ugexe> lucasb: its more complicated than that. otherwise it would be trivial to add a BEGIN $start = 1; and inside END add unless $start exit(255)

[23:45] <masak> timotimo: this might be relevant: https://github.com/blogs-perl-org/blogs.perl.org/issues/285 https://github.com/blogs-perl-org/blogs.perl.org/issues/206

[23:46] *** jordman joined
[23:46] <ugexe> the reason it happens is because of the code to handle tests without a plan

[23:47] <masak> wow, reading through that issues list, I have the feeling that blogs.perl.org has All The Issues.

[23:48] *** raiph left
[23:48] *** xiaomiao left
[23:49] <masak> "My password is compromised, I need to change it.." -- from November 2013 :/

[23:49] *** raiph joined
[23:50] <timotimo> ~it seems like that's not the same thing?

[23:50] <timotimo> masak: different kind of account perhaps?

[23:51] *** jordman left
[23:51] <masak> quite possibly.

[23:51] <masak> those were the two I found from a quick scan of the issues list.

[23:51] <timotimo> ooooh

[23:51] <timotimo> it says "login or email address"

[23:52] <timotimo> with just the login it works though

[23:52] *** xiaomiao joined
[23:52] *** vendethiel joined
[23:53] <timotimo> signing up for the swiss perl workshop ... finally

[23:53] <timotimo> i should have thought of a talk to give to make it less expensive :P

[23:53] <masak> \o/

[23:53] *** virtualsue left
[23:54] <masak> timotimo: looking forward to meeting you at swiss

[23:55] <timotimo> likewise :)

[23:57] <masak> 'night, #perl6

