[00:10] *** tinyblak joined
[00:11] <raydiak> good afternoon, #perl6

[00:13] <vendethiel> o/ raydiak

[00:14] <raydiak> \o vendethiel; working on anything interesting?

[00:14] <vendethiel> raydiak: not really, no, I was playing games with friends :P

[00:15] <raydiak> what game?  I ought to try one again some time...

[00:18] <vendethiel> raydiak: borderlands 2 :)

[00:19] * raydiak realizes his age as he has no idea what borderlands is, and goes to read :)

[00:19] *** TEttinger left
[00:20] *** mohij joined
[00:22] *** rurban left
[00:23] *** mohij_ left
[00:24] <raydiak> neat, I think my laptop might even handle it once I clean out the fan again (scorching summer here, setting records for my city)

[00:29] <raydiak> haven't been very active here lately myself, got some work painting a house for a few weeks, so spending part of a day off checking to see if all my modules still work on latest rakudo and so forth

[00:35] *** amurf joined
[00:36] <ugexe> m: my $path1; my $path2 = ''; say $path1.?IO.is-absolute; say $path2.?IO.is-absolute; # could it be more useful if $path2.?IO did not die?

[00:36] <camelia> rakudo-moar 2e612a: OUTPUT«Nil␤Must specify something as a path: did you mean '.' for the current directory?␤  in block <unit> at /tmp/7i2MBik27k:1␤␤»

[00:42] <cognominal> ...travelling to see the World.nqp instead of sleeping

[00:43] <raydiak> ugexe: that die for '' is something lizmat++ put in after one of my projects rm -rf'd itself due to a GLR change...so I'd argue that it'd be better if $path1 *did* die :)

[00:47] <ugexe> i dont want to actually do anything. i want to check if a path is absolute, but not being able to check "" doesnt seem correct

[00:47] *** tinyblak left
[00:49] <ugexe> or a better way than saying !$path || $path.IO.is-absolute ?? $path !! $path.IO.abspath

[00:55] <vendethiel> raydiak: well, I did manage to get a few more compile-time NULLRepr

[01:00] *** BenGoldberg joined
[01:01] *** laouji joined
[01:04] *** tinyblak joined
[01:05] *** dayangkun left
[01:15] *** Hor|zon joined
[01:16] *** rmgk_ joined
[01:16] *** rmgk is now known as Guest36324

[01:16] *** rmgk_ is now known as rmgk

[01:20] *** Guest36324 left
[01:20] *** Hor|zon left
[01:26] *** vendethiel left
[01:29] <raydiak> ugexe: myself, I'd rather that any attempt to treat an empty string or undefined value as a path died immediately...if I'm seeing any of those things where I should see a path string, something has probably gone wrong upstream

[01:30] <raydiak> though I can see an argument for wanting to treat it as the current directory (which is how my project self-destructed)

[01:30] <raydiak> but I wouldn't be in favor of it working for certain operations (like .is-relative), but not others

[01:39] *** amurf left
[01:46] *** yeahnoob joined
[01:56] *** TEttinger joined
[02:09] *** yeahnoob left
[02:13] *** noganex_ joined
[02:14] *** aborazmeh joined
[02:14] *** aborazmeh left
[02:14] *** aborazmeh joined
[02:15] *** noganex left
[02:17] *** atroxaper joined
[02:21] *** atroxaper left
[02:23] *** dayangkun joined
[02:24] *** dayangkun left
[02:25] *** laouji left
[02:25] *** dayangkun joined
[02:25] *** dayangkun left
[02:25] *** dayangkun joined
[02:25] *** dayangkun left
[02:28] *** dayangkun joined
[02:35] *** yeahnoob joined
[02:37] *** laouji joined
[02:48] *** colomon left
[02:48] *** vendethiel joined
[02:50] <ugexe> in this case the string is going to get absolute-ified one way or another, which involves $*CWD during the $*SPEC. methods (since a string cant carry its $*CWD around with it)

[02:50] *** colomon joined
[03:04] *** Hor|zon joined
[03:09] *** Hor|zon left
[03:11] *** telex left
[03:12] *** telex joined
[03:14] *** xinming joined
[03:22] *** xinming left
[03:22] *** xinming joined
[03:23] *** amurf joined
[03:25] *** colomon left
[03:28] *** amurf left
[03:29] *** colomon joined
[03:31] *** BenGoldberg left
[03:39] *** colomon left
[03:40] *** colomon joined
[03:45] *** tinyblak left
[03:45] *** laouji left
[03:47] *** colomon left
[03:47] *** nys left
[03:51] *** amurf joined
[03:55] *** molaf_ left
[03:56] *** amurf left
[03:59] *** kaare_ joined
[04:03] *** vendethiel left
[04:04] *** kaare__ joined
[04:07] *** kaare_ left
[04:53] *** atroxaper joined
[04:53] *** Hor|zon joined
[04:55] *** aborazmeh left
[04:57] *** khw left
[04:58] *** Hor|zon left
[04:58] *** tinyblak joined
[05:05] *** skids left
[05:08] *** tinyblak left
[05:20] *** baest_ is now known as baest

[05:22] *** vendethiel joined
[05:38] *** [Sno] left
[05:43] *** raiph left
[05:45] *** vendethiel left
[05:59] *** araujo_ left
[06:01] *** araujo joined
[06:01] *** araujo left
[06:01] *** araujo joined
[06:04] *** rurban joined
[06:09] *** dalek left
[06:09] *** dalek joined
[06:09] *** ChanServ sets mode: +v dalek

[06:11] *** xinming left
[06:21] *** geekosaur left
[06:23] *** geekosaur joined
[06:27] *** vendethiel joined
[06:33] *** espadrine_ joined
[06:40] *** FROGGS joined
[06:42] *** Hor|zon joined
[06:44] *** atroxaper left
[06:46] *** FROGGS left
[06:47] *** Hor|zon left
[06:49] *** tinyblak joined
[06:49] *** vendethiel left
[06:51] *** vendethiel joined
[06:53] *** atroxaper joined
[06:57] *** zakharyas joined
[07:01] *** brrt joined
[07:05] *** [Sno] joined
[07:08] *** RabidGravy joined
[07:09] <brrt> \o

[07:11] <cognominal> brrt o/

[07:11] <brrt> good.. monday, i guess :-)

[07:12] <cognominal> m:  my token ws { \h* };  say qq|a\n| ~~  m:s/  a $   /;

[07:12] <cognominal> ｢a

[07:12] <camelia> rakudo-moar 2e612a: OUTPUT«｢a␤｣␤»

[07:12] *** atroxaper left
[07:12] <cognominal> m:  my token ws { \h* };  say qq|a\n| ~~  m:s/  a \n   /;

[07:12] <camelia> rakudo-moar 2e612a: OUTPUT«False␤»

[07:13] <cognominal> I wonder why the second does not match

[07:14] *** vendethiel left
[07:14] <moritz> cognominal: because the whitespace before the \n in the regex already slurped up the newline in the string

[07:14] <TEttinger> m:  my token ws { \h* };  say qq|a\n| ~~  m:s/  a\n   /;

[07:14] <camelia> rakudo-moar 2e612a: OUTPUT«｢a␤｣␤»

[07:15] * moritz wonders if the lexical ws is picked up

[07:15] <ShimmerFairy> m: my token ws { <digit>* }; say qq|a3| ~~  m:s/a /; say qq|a3| ~~ m:s/a<digit>/

[07:15] <camelia> rakudo-moar 2e612a: OUTPUT«False␤｢a3｣␤ digit => ｢3｣␤»

[07:15] <ShimmerFairy> m: my token ws { <digit>* }; say qq|a3| ~~  m:s/a /; say qq|a3| ~~ m:s/a<ws>/

[07:15] <camelia> rakudo-moar 2e612a: OUTPUT«False␤｢a3｣␤ ws => ｢3｣␤  digit => ｢3｣␤»

[07:15] <ShimmerFairy> ^ lexical ws is not being picked up by :s whitespace

[07:15] <moritz> m: grammar A { token ws { \h* }; token TOP { a \n } }; say A.parse("a\n")

[07:15] <camelia> rakudo-moar 2e612a: OUTPUT«｢a␤｣␤»

[07:15] *** atroxaper joined
[07:16] *** darutoko joined
[07:16] *** vendethiel joined
[07:16] <moritz> cognominal: ^^ works fine inside a grammar

[07:17] <cognominal> ShimmerFairy diagnostic seems accurate.

[07:17] *** xfix joined
[07:18] <masak> good morning, #perl6!

[07:18] <cognominal> I waited masak to wake up to file the bug :)

[07:18] * moritz isn't sure that's a bug

[07:19] * moritz isn't sure it's not a bug either

[07:20] <ShimmerFairy> on the one hand, it does feel a bit inconsistent with how it works in grammars, on the other hand it feels like this is the kind of thing where you should be using grammars already.

[07:23] <ShimmerFairy> I'm not sure if non-grammar regex/token/rule declarations should "attach" to whatever implicit grammar regexes pull from when not in grammars, overriding declarations and such.

[07:23] <cognominal> https://github.com/perl6/specs/blame/master/S05-regex.pod#L342

[07:24] <masak> I'm too drowsy to backlog :) I'll leave that for later.

[07:25] *** FROGGS joined
[07:25] <cognominal> the given examples use m:s// so they are not grammars

[07:26] <cognominal> could we blame the greeks for that too?

[07:27] <ShimmerFairy> Said examples show how to _use_ sigspace, but I don't see any explicit example showing how to _change_ sigspace's behavior.

[07:29] <DrForr> Heh. I just fixed handling of RE modifiers in Perl-Mogrify last night. (with the exception of /x :) )

[07:30] *** abraxxa joined
[07:39] *** vendethiel left
[07:39] *** nnms left
[07:40] *** vendethiel joined
[07:42] <masak> does Rakudo have something like Perl 5's `readlink`?

[07:43] <moritz> masak: resolve, I think

[07:43] <moritz> IO::Path.resolve

[07:43] *** Hor|zon joined
[07:44] <moritz> m: say '/usr/bin/editor'.IO.resolve

[07:44] <camelia> rakudo-moar 2e612a: OUTPUT«"/usr/bin/editor".IO␤»

[07:46] <masak> oh, nice.

[07:46] <masak> japhb++ # implementation

[07:46] <moritz> $ ./perl6-m -e ' say "/usr/bin/editor".IO.resolve'

[07:46] <moritz> "/usr/bin/vim.gtk".IO

[07:48] *** Hor|zon left
[07:54] *** Hor|zon joined
[07:58] *** dakkar joined
[07:59] *** dalek left
[08:00] *** dalek joined
[08:00] *** ChanServ sets mode: +v dalek

[08:02] *** vendethiel left
[08:04] <[TuxCM]> Inline::Perl5 broken: Merging GLOBAL symbols failed: duplicate definition of symbol HLL

[08:05] <DrForr> Just as an aside I had good luck sending him a github issue as well :)

[08:05] *** g4 joined
[08:05] *** g4 left
[08:05] *** g4 joined
[08:24] *** vendethiel joined
[08:30] *** espadrine_ left
[08:47] <[TuxCM]> test             50000    46.251    46.162

[08:47] <[TuxCM]> test-t           50000    46.427    46.337

[08:47] <[TuxCM]> there has been time that it was 36!

[09:06] *** verzz joined
[09:11] *** brrt left
[09:13] *** bin_005 joined
[09:16] *** andreoss joined
[09:20] *** brrt joined
[09:22] <kanl> m: my @a = 1 .. 3; my @b = < a b c >; my @c = @a Z @b; for @c -> $a, $b { $a.say; $b.say; }; for @a Z @b -> $a, $b { $a.say; $b.say; }

[09:22] <camelia> rakudo-moar 2e612a: OUTPUT«1␤a␤2␤b␤3␤c␤1 a␤2 b␤Too few positionals passed; expected 2 arguments but got 1␤  in block <unit> at /tmp/TW7_7hQB4q:1␤␤»

[09:22] <kanl> m: my @a = 1 .. 2; my @b = < a b >; my @c = @a Z @b; for @c -> $a, $b { $a.say; $b.say; }; for @a Z @b -> $a, $b { $a.say; $b.say; }

[09:22] <camelia> rakudo-moar 2e612a: OUTPUT«1␤a␤2␤b␤1 a␤2 b␤»

[09:23] <kanl> so Z seems to be buggy with odd sized lists

[09:24] <masak> nope.

[09:25] <kanl> masak: care to elaborate on that "nope"? :)

[09:25] <vendethiel> what's buggy here?

[09:26] <kanl> am i misunderstanding the usage of Z then?

[09:26] <vendethiel> flattening, I think

[09:26] <vendethiel> m: my @a = 1 .. 3; my @b = < a b c >; for @a Z @b -> ($a, $b) { $a.say; $b.say; }

[09:26] <camelia> rakudo-moar 2e612a: OUTPUT«1␤a␤2␤b␤3␤c␤»

[09:27] <vendethiel> kanl: for @a Z @b -> $a, $b {} will have $a = @a[0], @b[0]

[09:27] <vendethiel> and $b be @a[1], @b[1] (<- this comma is the lsit one)

[09:28] <kanl> vendethiel: ic. so @c = @a Z @b flattened?

[09:29] <vendethiel> kanl: yes, list assignment flattens :)

[09:29] <kanl> got it, thanks!

[09:30] <ShimmerFairy> But if list assignment flattens, then how come:

[09:30] <ShimmerFairy> m: my @a = [0,1], [2,3]; my @b = @a[0]; say @b.perl;

[09:30] <camelia> rakudo-moar 2e612a: OUTPUT«[[0, 1]]<>␤»

[09:31] <vendethiel> ShimmerFairy: [] is an itemized list (currently)

[09:31] <vendethiel> GLR will (most probably) change this

[09:32] <ShimmerFairy> That is the first time I have ever heard of [] being that.

[09:32] <vendethiel> m: for 1, [2, 3, 4], (5, 6) -> $a { say "hey $a" };

[09:32] <camelia> rakudo-moar 2e612a: OUTPUT«hey 1␤hey 2 3 4␤hey 5 6␤»

[09:33] <vendethiel> m: my @a = 1, [2, 3, 4], (5, 6); for @a -> $a { say "hey $a" };

[09:33] <camelia> rakudo-moar 2e612a: OUTPUT«hey 1␤hey 2 3 4␤hey 5␤hey 6␤»

[09:33] <kanl> so then when is GLR happening? wouldn't it break tons of existing code?

[09:34] <vendethiel> it probably will, yes

[09:34] <ShimmerFairy> I haven't seen an explicit description of GLR yet, but I'm _hoping_ it'll make lists sane in Perl 6.

[09:34] * vendethiel much the same

[09:34] <vendethiel> there's one draft, though

[09:35] <DrForr> And just a few months before release :)

[09:35] <vendethiel> ShimmerFairy: https://github.com/perl6/specs/blob/master/S07-glr-draft.pod

[09:35] <vendethiel> DrForr: I'm ready to trade a bit of my time to fix my code for sanity 

[09:36] <DrForr> Oh, I am too, it's just the whole "just before release" bit.

[09:37] <ShimmerFairy> Well, I can't say I've kept quiet about how dumb lists can be in Perl 6 over the years :P

[09:37] *** vendethiel left
[09:39] <DrForr> Just stability issues, and worried that it's going to go in just before YAPC::EU and potentially break demo code when we should be touting successes :)

[09:42] *** brrt left
[09:45] *** yeahnoob left
[09:45] *** rindolf joined
[09:46] *** Ven joined
[09:51] *** andreoss left
[09:51] *** espadrine_ joined
[09:51] *** espadrine_ is now known as espadrine

[09:59] *** bin_005 left
[09:59] *** bin_005_i joined
[10:04] *** tinyblak left
[10:04] *** tinyblak joined
[10:07] *** tinyblak left
[10:09] *** brrt joined
[10:15] *** vendethiel joined
[10:20] *** xinming joined
[10:21] <kanl> wouldn't it be nice to be able to @a Z -> [ $a, $b ] { } @b, directly?

[10:22] <kanl> otherwise have to overload an operator

[10:23] <kanl> or, -> $a, $b {}, post GLR

[10:27] *** gfldex joined
[10:31] *** dayangkun left
[10:32] *** Ven left
[10:33] *** virtualsue joined
[10:33] *** pecastro left
[10:36] <dalek> rakudo/nom: 6967186 | (Nick Logan)++ | .travis.yml:

[10:36] <dalek> rakudo/nom: non-legacy travis-ci config

[10:36] <dalek> rakudo/nom: 

[10:36] <dalek> rakudo/nom: buildtime--

[10:36] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/6967186499

[10:36] <dalek> rakudo/nom: 533d1a9 | lizmat++ | .travis.yml:

[10:36] <dalek> rakudo/nom: Merge pull request #469 from ugexe/travis-nolegacy

[10:36] <dalek> rakudo/nom: 

[10:36] <dalek> rakudo/nom: non-legacy travis-ci config

[10:36] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/533d1a9f0f

[10:44] *** TEttinger left
[10:47] <kanl> m: my %h  = a => 1; %h.push: a => 1; %h.say;

[10:47] <camelia> rakudo-moar 2e612a: OUTPUT«a => 1␤»

[10:48] <kanl> http://doc.perl6.org/routine/push

[10:49] <kanl> my %h  = a => 1; %h.push: b => 1; %h.say;

[10:49] <kanl> m: my %h  = a => 1; %h.push: b => 1; %h.say;

[10:49] <camelia> rakudo-moar 2e612a: OUTPUT«a => 1␤»

[10:50] <kanl> so .push on hash no longer autovivify either?

[10:50] <moritz> m: my %h  = a => 1; %h.push: (b => 1); %h.say;

[10:50] <camelia> rakudo-moar 533d1a: OUTPUT«a => 1, b => 1␤»

[10:51] <moritz> kanl: it's the named vs. positional argument thingy again

[10:51] <ShimmerFairy> m: my $a = a => 1; my %h = $a; say %h.perl; %h.push($a); say %h.perl

[10:51] <camelia> rakudo-moar 533d1a: OUTPUT«{:a(1)}<>␤{:a([1, 1])}<>␤»

[10:51] <ShimmerFairy> That example in the docs assumes that implicit *%_ doesn't exist (and it shouldn't)

[10:53] <kanl> moritz: got it. thanks! i seem to keep falling over the same spot :p

[10:55] <nine> [TuxCM]: cannot reproduce an Inline::Perl5 failure here

[10:58] * [TuxCM] will retry

[10:58] *** verzz left
[11:01] <kanl> m: my @a = < a b c >; my %h = a => 1; @a.map: { %h.push: $_ => 1 }; %h.say;

[11:01] <camelia> rakudo-moar 533d1a: OUTPUT«a => 1 1, b => 1, c => 1␤»

[11:02] <kanl> so in $_ is not treated as named in this case?

[11:03] <lizmat> m: my @a = < a b c >; my %h = a => 1; @a.map: { %h.push: $_ => 1 }; %h.perl.say

[11:03] <yoleaux> 12 Jul 2015 22:49Z <japhb> lizmat: I was referring to the fact that perl6's command line options don't seem to affect the REPL (or at least, not all of them).  In my particular class, -I wasn't affecting @*INC in the REPL, and ugexe seemed to indicate --ll-exception was problematic as well.

[11:03] <camelia> rakudo-moar 533d1a: OUTPUT«{:a([1, 1]), :b(1), :c(1)}<>␤»

[11:03] <lizmat> kanl: I'm not sure what you expected?  Seems to work as planned to me

[11:04] <kanl> further back,  my %h  = a => 1; %h.push: b => 1; %h.say;

[11:04] <[TuxCM]> nine, still got it

[11:04] <ShimmerFairy> The question is why %thing.push(a => 1) goes to *%_ but %thing($_ => 1) doesn't.

[11:05] * [TuxCM] prepares gist (waiting for test to finish)

[11:07] <nine> [TuxCM]: I do see random test failures running make test in a loop. But they're very infrequent :/ And they are all of the "No subtests run" kind

[11:07] <kanl> lizmat: things like this confuse a newbie like me. because it _seems_ to be inconsistent, when actually there are actually sound reasons behind the seemingly inconsistency.

[11:07] <[TuxCM]> but you run locally, not from an installed Inline::Perl5

[11:08] *** tinyblak joined
[11:08] <lizmat> kanl: yeah, I see what you mean, but I'm on record not to rant about that anymore

[11:08] <kanl> i'll shut up :)

[11:09] * ShimmerFairy would argue the extent to which implicit *%_ is a sound reason :P

[11:09] <[TuxCM]> https://gist.github.com/Tux/2a769f16bd5505be78b6

[11:10] <lizmat> kanl: please don't

[11:10] <lizmat> you strengthen my point

[11:11] <lizmat> it's just that if you feel as strongly about it as I do, you should let yourself be heard

[11:11] <nine> I see the same errors locally and with the installed Inline::Perl5. But not your's. Though considering the randomness of my failures, it looks like some memory corruption. Like the heisenbug I tracked a couple of months ago that turned out to be a GC bug in NativeCall

[11:12] <ShimmerFairy> lizmat: oh, are you talking about that time you argued against the conflation of pairs and named parameters? If so, this is definitely a case where I'm left wondering why it's like this.

[11:12] <lizmat> there's nothing more *I* can say about it

[11:12] <lizmat> ShimmerFairy: indeed

[11:13] <ShimmerFairy> m: sub foo(:$bar) { say $bar }; my $baz = "bar"; foo(bar => "Hello!"); foo($baz => "World!")

[11:13] <camelia> rakudo-moar 533d1a: OUTPUT«Hello!␤Too many positionals passed; expected 0 arguments but got 1␤  in sub foo at /tmp/oFlm1yBicd:1␤  in block <unit> at /tmp/oFlm1yBicd:1␤␤»

[11:14] <ShimmerFairy> I've never encountered this before, but it feels very, very wrong.

[11:15] <FROGGS> jnthn: ping

[11:15] <kanl> lizmat: from a user adoption pov, these so-called inconsistencies may be offputting to people and turn some of them away, just saying. but speaking for myself, i'm not that easily frustrated/discouraged :)

[11:15] <ShimmerFairy> Those two calls should definitely be consistent, though how so is another point :)

[11:15] *** tinyblak left
[11:16] <FROGGS> jnthn: what does a for loop return in statement level? this here? https://github.com/rakudo/rakudo/blob/nom/src/core/MapIter.pm#L201

[11:17] <lizmat> kanl ShimmerFairy : teaching and user adoption are the most important reasons to separate :a(42) and a => 42 in meaning

[11:18] <lizmat> especially since you cannot use a => 42 as an adverb in @a[42]:exists and the like

[11:18] <kanl> *nod*

[11:18] <lizmat> so newbies are first taught to use :a(42) notation for slices and the like

[11:19] <lizmat> and then learn they can also use a => 42 for custom code to indicate  a named parameter

[11:19] <lizmat> but not for slices

[11:19] <ShimmerFairy> lizmat: I'm on board with not mixing pairs and named params. I've actually thought about it before, but never complained about it much (if at all). They're such different things, I wonder why they deserve to share syntax, and in a not-always-clear fashion to boot.

[11:19] *** rurban left
[11:20] <kanl> as a user with some p5 experience, i'd have to agree with ShimmerFairy on that 

[11:21] <ShimmerFairy> lizmat: And I mentioned a few days ago how my mind sees  a => 42  as a Pair-ish thing, and  :a(42)  as a named param-ish thing. I'm not too likely to write  foo(a => 42)  , and I definitely wouldn't write  %h = :a(42)

[11:21] <kanl> old p5 habbits can be quite harmful

[11:22] *** atroxaper left
[11:25] <tadzik> 25 years from now we'll still be afraid to use $a and $b so we don't break sort

[11:26] <tadzik> it'll be like with goto. "Ancients told us to never use goto!" "But it was completely different back then!" "LOL, doesn't matter, stay away from it anyway!"

[11:26] <tadzik> (yes, I'm pretty sure prefix:<LOL> will still be around in 25 years)

[11:26] <tadzik> (maybe for the same reason)

[11:26] <ShimmerFairy> What's this about breaking sort?

[11:31] <lizmat> $a and $b have a special meaning in P5 wrt to sort

[11:31] *** bjz joined
[11:31] <ShimmerFairy> Ah, that explains why I don't know about it :)

[11:32] <lizmat> in p5 one can say sort @a, { $a cmp $b } where $a and $b would be the two parameters to the code block

[11:32] <lizmat> similar to P6's { $^a cmp $^b }

[11:33] <lizmat> except in P5 they are fixed to the names "$a" and "$b"

[11:33] <lizmat> hence you can use $a and $b anywhere in P5 code without defining them, even with "use strict"

[11:33] <lizmat> so they're really pretty magical

[11:33] <lizmat> in P5

[11:35] <itz__> is compiling to mbc on OS X several times slower than a couple of days ago or is it me?

[11:35] *** itz__ is now known as itz

[11:36] <lizmat> itz: not sure, could be

[11:36] *** FROGGS left
[11:37] <itz> I'll nuke .rakudobrew just in case

[11:42] *** tinyblak joined
[11:52] *** pecastro joined
[11:56] *** kurahaupo left
[12:02] *** bin_005_i left
[12:10] <itz> hmm it seems to affect certain modules only

[12:17] <jnthn> afternoon, #perl6

[12:17] <yoleaux> 11 Jul 2015 21:02Z <japhb> jnthn: What are your thoughts on http://irclog.perlgeek.de/perl6/2015-07-11#i_10881267 and http://irclog.perlgeek.de/perl6/2015-07-11#i_10881334 ?  Having no good resolution kinda gets in the way of a nice refactoring (for now, I'm copying the required private methods into each role that would want to consume them, and then changing the names to not collide between the roles which is ... blech.)

[12:17] <yoleaux> 12 Jul 2015 20:46Z <FROGGS> jnthn: I think MVMExceptionBody needs an MVMObject *label, so the payload can be used for: LABEL.leave(42)

[12:17] *** rurban joined
[12:19] <jnthn> .tell japhb I think the one at http://irclog.perlgeek.de/perl6/2015-07-11#i_10881271 should indeed DWYM; feel free to file a ticket on that

[12:19] <yoleaux> jnthn: I'll pass your message to japhb.

[12:22] *** atroxaper joined
[12:25] * lizmat tries to catch some more sleep

[12:26] *** rindolf left
[12:27] *** atroxaper left
[12:28] <arnsholt> jnthn: How accessible is the multi-dim stuff from Perl 6 currently? I've got an idea which might be a good fit for giving it a real-worldish spin

[12:28] <timotimo> o/

[12:28] <jnthn> arnsholt: It ain't yet, but I intend for it to be later this week.

[12:29] <arnsholt> Spiffy! I'll keep an eye out for it =)

[12:32] *** yakudza joined
[12:35] *** itz is now known as _itz

[12:35] *** itz joined
[12:38] <RabidGravy> remember kids, doing "sub trait_mod:<is> .... " without a multi will get you really confused ...

[12:38] <RabidGravy> well the symptons are somewhat confusing to me anyway

[12:42] *** FROGGS joined
[12:43] <FROGGS> $ perl6 -e 'say (FOO: for ^3 { FOO.leave(123); say "alive" }); say "ho!"'

[12:43] <FROGGS> 123

[12:43] <FROGGS> ho!

[12:43] <FROGGS> masak: ^^

[12:43] <FROGGS> dunno how sane my implementation is though

[12:43] <FROGGS> jnthn: ^^

[12:44] <masak> woo! \o/

[12:44] <masak> FROGGS, you nice person you!

[12:44] <FROGGS> :D

[12:45] <jnthn> FROGGS++

[12:45] <FROGGS> I'll push my stuff in a minute

[12:45] <jnthn> Would be interested to see that stuf,f yes

[12:45] <jnthn> *stuff

[12:45] <FROGGS> jnthn: please review then :o)

[12:51] *** telex left
[12:52] *** aborazmeh joined
[12:52] *** aborazmeh left
[12:52] *** aborazmeh joined
[12:52] *** telex joined
[12:54] *** verzz joined
[13:03] *** christovchristov joined
[13:06] *** amurf joined
[13:09] *** brrt left
[13:10] *** amurf left
[13:12] <dalek> nqp/leave: 10af152 | FROGGS++ | src/vm/moar/QAST/QASTOperationsMAST.nqp:

[13:12] <dalek> nqp/leave: map {get,set}label, and handle CONTROL_RETURN + label

[13:12] <dalek> nqp/leave: review: https://github.com/perl6/nqp/commit/10af152761

[13:12] * masak looks, too

[13:14] *** raiph joined
[13:14] <masak> so the handler name is called RETURN on the nqp level? even though it's a leave?

[13:16] *** andreoss joined
[13:18] <andreoss> with token { <line> ** 9 } what separator is assumed?

[13:19] *** bjz left
[13:20] *** bjz joined
[13:20] <dalek> rakudo/leave: 6744251 | FROGGS++ | src/core/ (2 files):

[13:20] <dalek> rakudo/leave: and handle CONTROL_RETURN + label in MapIter

[13:20] <dalek> rakudo/leave: review: https://github.com/rakudo/rakudo/commit/67442510f3

[13:20] <FROGGS> masak / jnthn: I pushed all the things

[13:20] *** lucasb joined
[13:21] <FROGGS> masak: aye, CONTROL_RETURN already existed

[13:21] <FROGGS> andreoss: none

[13:23] <masak> FROGGS: here my ignorance of the specifics is showing, but...

[13:23] <FROGGS> masak: I just can tell that it works for the one-liner I posted, I'm not sure the implementation is sensible

[13:23] *** kaare__ is now known as kaare_

[13:23] <masak> FROGGS: ...it seems to me that a `return` and a `leave` might take you to different locations. how does that square with using CONTROL_RETURN for both?

[13:24] <oha> isn't LEAVE a phaser executed before exiting? like a guard? why for 1..3 { FOO.leave(); say "alive" } doesn't print "alive" 3 times?

[13:24] <FROGGS> return does not use CONTROL_RETURN AFAICS

[13:24] <FROGGS> it invokes a lexical &RETURN or so

[13:24] <oha> is leave in this context different than the phaser

[13:25] <oha> shouldn't be .last() ?

[13:25] <masak> FROGGS: maybe make sure that the lexical &RETURN doesn't use CONTROL_RETURN...?

[13:25] <masak> m: sub foo { sub return(|c) { say "nuh-uh!" }; return 42; say "alive" }; foo

[13:25] <camelia> rakudo-moar 533d1a: OUTPUT«nuh-uh!␤alive␤»

[13:26] <jnthn> I don't think it uses it at the moment, but it maybe should eventually

[13:26] <dalek> roast: 570c8cc | (Steve Mynott)++ | S32-io/spurt.t:

[13:26] <dalek> roast: fix spurt on file handle deprecation

[13:26] <dalek> roast: review: https://github.com/perl6/roast/commit/570c8cc952

[13:26] <jnthn> The history on this is that Parrot never got lexical exception handler lookup

[13:26] <jnthn> But it had a different, and rather convenient, way to implement it

[13:27] <masak> if there is a CONTROL_RETURN, but only &leave uses it, maybe rename it CONTROL_LEAVE? :P

[13:27] <jnthn> And we've kinda carried that forward

[13:27] <jnthn> Path of least resistance and all that

[13:27] <andreoss> FROGGS: why does it work with \n and whitespaces between <line>?

[13:27] <FROGGS> andreoss: maybe your token/rule line allows it?

[13:28] <andreoss> i specified nothing about whitespaces

[13:28] <FROGGS> andreoss: is line a rul?

[13:28] <andreoss> some default rule is applied 

[13:28] <FROGGS> rule*

[13:29] <FROGGS> or is it a token?

[13:29] <andreoss> rule

[13:29] <FROGGS> see

[13:29] <andreoss> with token it's actually the same 

[13:29] <FROGGS> a rule allows arbitrary whitespace at the end

[13:29] <FROGGS> hmm, should not be

[13:31] *** colomon joined
[13:32] <andreoss> sorry, i've been mistaken and changed rule to token only for TOP

[13:36] *** andreoss left
[13:41] <dalek> nqp: cd7a532 | jnthn++ | src/vm/jvm/runtime/org/perl6/nqp/sixmodel/reprs/MultiDimArray (3 files):

[13:41] <dalek> nqp: Get multi-dim object arrays working on JVM.

[13:41] <dalek> nqp: review: https://github.com/perl6/nqp/commit/cd7a5322ed

[13:43] *** jaffa4 joined
[13:43] <jaffa4> hi

[13:43] <jaffa4> How would you copy a hash?

[13:44] <PerlJam> jaffa4: my %hash = %other-hash;

[13:44] <jaffa4> as a reference?

[13:44] <jaffa4> and make it a reference?

[13:44] <jaffa4> my $h = %hash;

[13:45] <El_Che> jercos: a reference is not a copy, but an alias (changes to the "copy" will change the original)

[13:46] <jaffa4> I would ike to have reference to a copy

[13:46] <geekosaur> what

[13:47] <geekosaur> why do you need a reference? for the most part references are a perl5-ism

[13:47] <jaffa4> my %h2 = %h; my $r = %h2;

[13:47] <jaffa4> Is there an easier way?

[13:48] <geekosaur> things you shouldn't need to do don;t generally come with easier ways

[13:48] <jnthn> $(my % = %h) probably works

[13:48] *** molaf joined
[13:49] <El_Che> (lol this is the #perl6 tab, I thought I was in #perl)

[13:49] <jnthn> Well, but {%h} does copy too :)

[13:49] *** aborazmeh left
[13:49] <jnthn> so my $r = {%h} or so

[13:51] <nine> m: my %a = a => 1, b => 2; my $b = $(my % = %a); $b<b> = 1; say %a.perl; say $b.perl;

[13:51] <camelia> rakudo-moar 533d1a: OUTPUT«{:a(1), :b(2)}<>␤{:a(1), :b(1)}␤»

[13:51] *** khw joined
[13:51] <[Coke]> Note: the TPF grants committee is looking for grants to fund. Historically we haven't gotten many perl 6 grant requests. If someone has a good idea for a grant, don't let the fact that it's six instead of five stop you.

[13:52] <jaffa4> like what?

[13:52] <jaffa4> Coke

[13:54] <jaffa4> Coke, what is the url?

[13:55] <PerlJam> jaffa4: http://news.perlfoundation.org/2015/07/call-for-grant-proposals-july-1.html

[13:55] <jaffa4> jnthn:  I getr postcircumfix:<{ }> not defined for type Bloc

[13:59] <jaffa4> jnthn: thanks for the other version, that works

[13:59] <christovchristov> hey Im consideirng using perl for a webspider but concerned about performance vs using php.. does anyone have any performance info where I can read more?

[14:00] <PerlJam> christovchristov: sounds like you want #perl rather than #perl6 

[14:01] *** colomon left
[14:01] <christovchristov> ah. my bad. Ofcourse it was a more generic question :) cheers

[14:01] <PerlJam> christovchristov: no worries

[14:02] <PerlJam> christovchristov: though, if I were you, I would do some profiling myself  :)

[14:04] *** colomon joined
[14:04] *** itz left
[14:06] *** n0tjack joined
[14:07] *** colomon left
[14:09] <tadzik> I'm continually surprised that Perl is one of the very few languages apparently that get stuff like https://gist.github.com/tadzik/80987d58011eeff3d96f right

[14:09] <tadzik> TIL that C# and Go don't either

[14:09] <moritz> christovchristov: in general, web spidering is IO (network) limited, not performance limit

[14:09] <tadzik> I thought only Python is like that

[14:09] <moritz> christovchristov: so you don't have to worry much about the performance of the implementation language

[14:10] <PerlJam> moritz: #perl is enthusiastically telling him that. :)

[14:10] <moritz> ok :-)

[14:10] <jnthn> A language that lets you manage multiple concurrent requests easily is worth having for it, though :)

[14:10] <nine> Which I guess would be pretty much any language except PHP

[14:11] *** christovchristov left
[14:13] *** skids joined
[14:15] <dalek> nqp: 11dd464 | jnthn++ | src/vm/jvm/runtime/org/perl6/nqp/sixmodel/reprs/MultiDimArray (10 files):

[14:15] <dalek> nqp: Support native/packed multi-dim arrays on JVM.

[14:15] <dalek> nqp: review: https://github.com/perl6/nqp/commit/11dd4647c6

[14:18] *** g4 left
[14:21] <masak> nine: but PHP has other nice/redeeming features, such as... ah...

[14:21] <masak> ...

[14:24] <arnsholt> It's not BrainFuck, I guess?

[14:25] <jaffa4> I found some weird behaviour concerning and and &&  see http://codepaste.net/yier8s

[14:25] <jaffa4> Could anyone explain that?

[14:25] <nine> But BrainFuck should be easily compilable to a very fast binary, shouldn't it?

[14:26] <arnsholt> Not necessarily

[14:26] *** lizmat left
[14:27] <arnsholt> It can actually be harder to optimise very low-level stuff

[14:27] <masak> jaffa4: before I opened that link, I went "oh, I bet jaffa4 got precedence wrong"

[14:27] <masak> jaffa4: I was right :D

[14:27] <DrForr> jaffa4: && and 'and' have differing precedence.

[14:27] <masak> m: say True and False

[14:27] <camelia> rakudo-moar 533d1a: OUTPUT«True␤»

[14:27] <masak> m: say (True and False)

[14:27] <camelia> rakudo-moar 533d1a: OUTPUT«False␤»

[14:27] <masak> jaffa4: ^

[14:28] <masak> jaffa4: if you don't understand precedence, and the differing precedence between `&&` and `and`, I would heartily recommend not using `and`

[14:28] *** VinceDee joined
[14:28] <masak> jaffa4: it *has* a good use, but people who don't understand its precedence won't use it right.

[14:29] *** colomon joined
[14:29] <jaffa4> masak: in the example, && gave bad result and, AND gave good one

[14:29] <DrForr> jaffa4: && is binding tighter than you expected.

[14:30] <jaffa4> a change from Perl 5?

[14:30] <DrForr> They're different languages, yes.

[14:31] <dalek> nqp: 0da71d8 | jnthn++ | src/vm/jvm/runtime/org/perl6/nqp/sixmodel/reprs/MultiDimArrayInstanceBase.java:

[14:31] <dalek> nqp: Good errors for size-changing ops.

[14:31] <dalek> nqp: review: https://github.com/perl6/nqp/commit/0da71d88ed

[14:31] <dalek> nqp: 0743f03 | jnthn++ | src/vm/jvm/runtime/org/perl6/nqp/sixmodel/reprs/MultiDimArrayInstanceBase.java:

[14:31] <dalek> nqp: Do rest of positional API in MultiDimArray on JVM.

[14:31] <dalek> nqp: review: https://github.com/perl6/nqp/commit/0743f03253

[14:31] <jnthn> Phew, 140 out of 188 tests. :)

[14:32] <jaffa4> masak: I assumed it stayed the same for Perl6, some things did not change

[14:32] <tadzik> I think it's the same as in Perl 5, this particular thing

[14:32] <vendethiel> tadzik: you'll be pleased to know C#5 fixes that :)

[14:32] <tadzik> vendethiel: oh, I am :)

[14:32] <tadzik> vendethiel: I'

[14:32] <tadzik> vendethiel: I'm also sad to realize that Unity is not likely to adopt it any time soon :P

[14:33] <vendethiel> tadzik: Unity uses a butchered version of C# already :)

[14:33] <tadzik> yeah, I noticed :P

[14:33] <tadzik> on ancient mono

[14:33] <tadzik> *shudder*

[14:33] <vendethiel> .oO( "let's remove access modifiers, they look too confusing" )

[14:33] <RabidGravy> I thought that 'and' was lower precedence than '&&' in perl 5 too

[14:33] <tadzik> access modifiers?

[14:34] <masak> jaffa4: it did stay the same.

[14:34] <masak> jaffa4: Perl 5 has exactly the same distinction between `&&` and `and`. I suggest you learn it.

[14:34] <skids> jnthn++ cruising along on native multidim... guess I'd better dust off the Keccak specs.

[14:34] <masak> jaffa4: or, if you don't feel like learning it (which is fine), I suggest only using `&&`.

[14:34] <vendethiel> tadzik: "public void X()" <- only "void X()" works in unity#

[14:35] <hoelzro> o/ #perl6

[14:35] <lucasb> Good monday to everyone. I can use .subst directly, but sometimes I felt like wanting to use s/// with .subst semantics, not .subst-mutate. Do you think there is room for an adverb that does that, just like P5's s///r ? (I know that :r is already taken for something else)

[14:36] <vendethiel> lucasb: I asked about the same some time ago  :P

[14:36] <tadzik> vendethiel: nah, both work

[14:36] <skids> Wasn't that S///?

[14:36] <jaffa4> masak: I used &&, that did not seem to work

[14:36] <vendethiel> tadzik: really? there's something they changed wrt that, but I can't remember right now :). I only used unity for 2 weeks

[14:36] <tadzik> I mean, I even think that the latter might not, if you expect it to be public

[14:37] <tadzik> vendethiel: certain magic methods do that, yeah :D

[14:37] <tadzik> like void Awake(), void Update() etc

[14:37] <tadzik> those Unity fetches via reflection and stuff

[14:37] <jaffa4> masak: as in Perl 5

[14:37] <ShimmerFairy> jaffa4: As I understand the code, you need parens around  defined (stuff)  , so    (defined (stuff)) && morestuff

[14:37] <tadzik> actually, not sure if they break if you make them public explicitely, but knowing Unity, they might :P

[14:37] <vendethiel> tadzik: no, I was right. it doesn't work like that in c#.

[14:38] <vendethiel> tadzik: in unity#, no access modifier = public, not in c#

[14:38] <tadzik> oh

[14:38] <tadzik> huh

[14:38] <tadzik> class attributes for example don't show up in the editor if they're not public

[14:38] <lucasb> vendethiel: I must read the logs more often. :) What was the answer when you asked about this?

[14:38] *** tinyblak left
[14:38] <tadzik> I'd be surprised if it recognized private methods as public and callable then

[14:39] *** lizmat joined
[14:39] <masak> jaffa4: you're not 100% successful in providing golfed examples. this makes it harder to help you.

[14:40] <masak> jaffa4: it also makes it harder for *you* to see what the problem is with your code, since it's still tangled with all these inessentials.

[14:40] <masak> jaffa4: if you put whitespace between `defined` and the `(...)` thing, that means something different than `defined(...)`

[14:40] <masak> jaffa4: *that* is the difference between Perl 5 and Perl 6 that's tripping you up.

[14:40] <lucasb> skids: I tried S///, but I don't understand how it works

[14:41] <masak> jaffa4: thanks to ShimmerFairy for putting me on the right track. I didn't see that before.

[14:41] <lucasb> skids: I didn't know it existed :)

[14:41] <vendethiel> tadzik: not sure. but all the methods you define for unity are declared with "public"

[14:41] <vendethiel> aren't*

[14:42] <masak> m: my $a = True; my $b; say defined $a && $b; say defined($a) && $b # jaffa4: see the difference?

[14:42] <camelia> rakudo-moar 533d1a: OUTPUT«False␤(Any)␤»

[14:42] <dalek> nqp: 9ccd292 | jnthn++ | src/vm/jvm/runtime/org/perl6/nqp/sixmodel/reprs/MultiDimArrayInstance (11 files):

[14:42] <dalek> nqp: Support cloning multi-dim arrays on JVM.

[14:42] <dalek> nqp: review: https://github.com/perl6/nqp/commit/9ccd29269c

[14:42] <masak> m: my $a = True; my $b = 4; say defined $a && $b; say defined($a) && $b

[14:42] <camelia> rakudo-moar 533d1a: OUTPUT«True␤4␤»

[14:43] <jercos> El_Che: good to know :p

[14:44] *** aborazmeh joined
[14:44] *** aborazmeh left
[14:44] *** aborazmeh joined
[14:45] <jaffa4> masak: here is the more complete example http://codepaste.net/gw4fh1

[14:45] <masak> *sigh* :)

[14:46] <masak> jaffa4: hold on, going to repeat the explanation I wrote to you above.

[14:46] <ohb> tadzik, (about closures) i believe in java it will complain that you need to make it final (to avoid differentiating between shallow and deep binding) alghouth they are more anon-classes that could be used as closures

[14:46] <masak> jaffa4: if you put whitespace between `defined` and the `(...)` thing, that means something different than `defined(...)`

[14:46] <masak> jaffa4: *that* is the difference between Perl 5 and Perl 6 that's tripping you up.

[14:46] <skids> m: my $f = "aaa"; my $g = $f ~~ S/a/b/; $f.say; $g.say # lucasb.  It's in release notes but apparently broken?

[14:46] <camelia> rakudo-moar 533d1a: OUTPUT«aaa␤False␤»

[14:47] *** tinyblak joined
[14:47] <jaffa4> masak: I see... so it is not about precedence

[14:47] *** tinyblak left
[14:47] <jaffa4> I think many will trip after me

[14:47] <masak> in a way it is

[14:47] <masak> jaffa4: so, in essence, you're confused by two things: (a) different precedence between `&&` and `and`, and (b) the fact that function calls become listops if they have whitespace after them

[14:48] *** rindolf joined
[14:48] <masak> jaffa4: learn the rules of the language. don't just say "I think many will trip after me"

[14:48] <masak> jaffa4: Perl 6 is not a random set of rules. it's a well-thought-out set of rules. learn them.

[14:49] <jaffa4> I know many , even this one, I just tend to think in Perl5

[14:49] <masak> jaffa4: there are good reasons behind this change of parsing.

[14:49] <jaffa4> I used Perl5 for 13 years

[14:49] <masak> jaffa4: if you don't learn the new behavior, you will keep being surprised and your programs will have bugs.

[14:49] <lucasb> skids: Thanks! I'm only getting booleans as return too, that's why I didn't understand.

[14:50] <masak> jaffa4: to be on the safe side, always write `foo()`, not `foo ()`

[14:50] <masak> jaffa4: but better than that is learning the rules.

[14:50] <jaffa4> What does define () do?

[14:51] <masak> m: sub foo(|c) { say "{c.elems} arguments passed" }; foo(); foo ()

[14:51] <camelia> rakudo-moar 533d1a: OUTPUT«0 arguments passed␤1 arguments passed␤»

[14:51] <masak> jaffa4: see the above?

[14:51] <masak> jaffa4: does it explain things?

[14:53] <jaffa4> m: sub foo(|c) { say "{c.elems} arguments passed" }; foo(); foo (),()

[14:53] <camelia> rakudo-moar 533d1a: OUTPUT«0 arguments passed␤2 arguments passed␤»

[14:53] <masak> right.

[14:53] <masak> in `foo()`, the parentheses are just there for grouping the arguments.

[14:54] <masak> in `foo ()`, the parentheses are an argument (an empty list)

[14:55] <jaffa4> ok

[14:55] *** JimmyZ_ joined
[14:55] <ShimmerFairy> m: sub foo(|c) { say "{c.elems} argument{"s" if c.elems - 1} passed: {c.perl}" }; foo(); foo (); foo (), ();  # just showing off what  c  gets

[14:55] <camelia> rakudo-moar 533d1a: OUTPUT«0 arguments passed: \()␤1 argument passed: \(())␤2 arguments passed: \((), ())␤»

[14:55] *** khw left
[14:55] <masak> jaffa4: the second for is called a "listop". it exists in Perl 5 too, like `print 1, 2, 3;`

[14:56] *** amurf joined
[14:56] <masak> jaffa4: the difference is that if you do `print (1, 2, 3)` in Perl 5, the parens just become a delimiter, like `print(1, 2, 3)`

[14:56] *** colomon left
[14:56] <dalek> nqp: 3f9c111 | jnthn++ | src/vm/jvm/runtime/org/perl6/nqp/runtime/Ops.java:

[14:56] <dalek> nqp: Implement special 2D/3D ops on JVM.

[14:56] <dalek> nqp: review: https://github.com/perl6/nqp/commit/3f9c111423

[14:56] <masak> jaffa4: not so in Perl 6. if you put in the whitespace in Perl 6, the parens always mean "list"

[14:57] <masak> jaffa4: the rule is much more consistent in Perl 6, and avoids certain kinds of Perl 5 mistakes, like `print ($a + $b ) * $c;`

[14:58] <masak> $ perl -Mstrict -wE'my ($a, $b, $c) = (1, 1, 100); say ($a + $b) * $c'

[14:58] <masak> say (...) interpreted as function at -e line 1.

[14:58] <masak> Useless use of multiplication (*) in void context at -e line 1.

[14:58] <masak> 2

[14:58] <masak> $ perl6 -e'my ($a, $b, $c) = (1, 1, 100); say ($a + $b) * $c'

[14:58] <masak> 200

[14:59] <masak> m: my ($a, $b, $c) = 1, 1, 100; say ($a + $b) * $c  # without the superstitious parentheses this time ;)

[14:59] <camelia> rakudo-moar 533d1a: OUTPUT«200␤»

[15:00] *** amurf left
[15:09] *** khw joined
[15:12] *** itz joined
[15:13] *** aborazmeh left
[15:20] *** zakharyas left
[15:22] *** tinyblak joined
[15:24] *** captain-adequate joined
[15:28] *** FROGGS left
[15:32] <lucasb> I found about S/// :) It was mentioned in the changelog for June, but not in the release announcement, maybe because it wasn't finished. It only works without the "~~"

[15:33] <lucasb> m: $_ = 'abc'; say S/a/x/; .say

[15:33] <camelia> rakudo-moar 533d1a: OUTPUT«xbc␤abc␤»

[15:33] <lucasb> m: $_ = 'abc'; say $_ ~~ S/a/x/; .say

[15:33] <camelia> rakudo-moar 533d1a: OUTPUT«False␤abc␤»

[15:36] <TimToady> m: say S/a/x/ given 'abc'

[15:36] <camelia> rakudo-moar 533d1a: OUTPUT«xbc␤»

[15:36] <TimToady> there's one workaround

[15:36] <TimToady> not sure it's where we want to end up though

[15:36] *** stux|RC-only left
[15:36] *** awwaiid left
[15:36] *** [particle] left
[15:37] *** coffee` left
[15:37] *** asdf12z_ left
[15:37] *** bonsaikitten left
[15:37] *** oha left
[15:37] *** _sri left
[15:37] *** timbunce left
[15:37] *** psch joined
[15:37] *** nwc10 joined
[15:37] *** dagurval joined
[15:37] *** awwaiid joined
[15:37] *** bloonix joined
[15:37] *** krakan joined
[15:37] *** bobkare joined
[15:37] *** xiaomiao joined
[15:37] *** _sri joined
[15:37] *** hahainternet joined
[15:37] *** Pauekn joined
[15:37] *** tony-o joined
[15:37] *** Mouq joined
[15:37] *** revdiablo joined
[15:37] *** oha joined
[15:37] *** timbunce joined
[15:37] *** burnersk joined
[15:37] *** bowtie joined
[15:37] *** tinita joined
[15:37] *** [ptc] joined
[15:37] *** stux|RC-only joined
[15:37] *** [particle] joined
[15:37] *** bowtie is now known as Guest4451

[15:37] *** go|dfish joined
[15:38] *** diegok joined
[15:38] *** dpk joined
[15:38] <itz> m: $*ARGFILES=open "/etc/issue"; say slurp();

[15:38] <camelia> rakudo-moar 533d1a: OUTPUT«open is disallowed in restricted setting␤  in sub restricted at src/RESTRICTED.setting:1␤  in sub open at src/RESTRICTED.setting:9␤  in block <unit> at /tmp/WcTziM8_NQ:1␤␤»

[15:39] *** dg joined
[15:39] <itz> damm :)

[15:39] <lucasb> TimToady: cool :)

[15:39] *** lestrrat joined
[15:39] <itz> anyway of testing a filehandle?

[15:39] *** FROGGS joined
[15:40] <PerlJam> itz: testing it for what?

[15:40] <itz> well I wanted to show the difference between

[15:40] <itz> $*ARGFILES=open "/etc/issue"; say slurp();

[15:40] <itz> $*ARGFILES=open "/etc/issue"; say slurp-rest();

[15:41] <itz> I wonder if the second form should work and replace the first?

[15:42] <itz> instead of having to use $*ARGFILES=open "/etc/issue"; say $*ARGFILES.slurp-rest();

[15:46] <FROGGS> jnthn: I have the suspicion that p6routinereturn is not quite what I want for Block.leave :o)

[15:48] <PerlJam> itz: I'm not even sure why we have slurp and slurp-rest.   I would have just used slurp for both of those things.

[15:48] <lucasb> PerlJam: +1 :)

[15:48] <itz> slurp is deprecated on a file handle

[15:48] <japhb> .tell jnthn Great, glad it makes sense to you too; I filed RT #125606 for the "Role requiring private method" issue.

[15:48] <yoleaux> 12:19Z <jnthn> japhb: I think the one at http://irclog.perlgeek.de/perl6/2015-07-11#i_10881271 should indeed DWYM; feel free to file a ticket on that

[15:48] <yoleaux> japhb: I'll pass your message to jnthn.

[15:49] *** Spot__ joined
[15:49] *** clkao joined
[15:49] <lucasb> To me, .slurp-rest feels like: Why the "rest"? I just opened the filehandle. Has anybody read a little of it before me?

[15:49] <TimToady> you could've

[15:50] <TimToady> but the main reason is to distinguish from .slurp, which implies a close

[15:50] <TimToady> .slurp-rest doesn't

[15:50] <PerlJam> oh, and slurp-rest doesn't close?

[15:50] <ShimmerFairy> I personally never understood (or even heard) the rationale for .slurp-rest

[15:51] <TimToady> hard to understand if you haven't heard it :)

[15:51] <lucasb> I understand, but to me I don't see anything wrong with IO::Path.slurp *closing* and IO::Handle *don't closing* the handle.

[15:51] <TimToady> it was confusing people

[15:51] <lucasb> That's two different classes; they do different things with the messages they receive

[15:52] <itz> should slurp-rest() behave on $*ARGFILES as slurp() did?

[15:52] <ShimmerFairy> TimToady: it did put a hamper in me doing  open("file").slurp  , out of an interest in being explicit about the file opening. I don't know why, but I don't like slurp("file") as much.

[15:53] <itz> actually it doesn't close it so not I guess (?)

[15:53] *** nys joined
[15:54] *** JimmyZ_ left
[15:54] *** JimmyZ_ joined
[15:55] * [Coke] wonders if we'll ever be able to do strict exception handling like in Java.

[15:56] * TimToady has heard very few people claim that was a desirable feature

[15:56] <[Coke]> was just burned by this in another language-on-top-of-jvm, where we had a bit of code that threw an exception outside of any try/catch handlers, and it blew up in prod about 2 years after it was deployed. (whereas in java, it wouldn't even have compiled)

[15:57] <[Coke]> TimToady: well, +1 from me, fwiw. :)

[15:57] <ShimmerFairy> When I was learning Java for a while, it was certainly interesting. But I didn't appreciate being forced to use try { } catch blocks (since I don't like how it makes you add another level of indentation to the happy path).

[15:57] <ShimmerFairy> However, the try-with-resources (or whatever it's termed) thing was a nice touch :)

[15:58] <[Coke]> I also find the boilerplate it demands painful in java sometimes. nice to have the suspenders if you want them, though.

[15:58] *** atroxaper joined
[15:59] <ShimmerFairy> I also find it painful in C++, which is why I don't use exceptions in C++ as much as I would otherwise like. (And it's why I appreciate Perl 6's CATCH { } blocks and how they don't need a try part ☺)

[15:59] *** ggherdov joined
[16:00] *** JimmyZ__ joined
[16:00] * TimToady bows

[16:01] <japhb> Too bad we don't have someone present who can tap you on the shoulder with a sword and bestow a knighthood.

[16:01] <japhb> SerTimToady

[16:01] *** JimmyZ_ left
[16:02] <itz> I think the Ser prefix lessens life expectancy (at least on TV)

[16:02] <japhb> On reflection I wonder if that ceremony was a reminder that the regent could be choosing to remove the head, rather than merely tap them on the shoulder.

[16:03] <TimToady> well, one gets tapped for other duties, which then shortens your life span :)

[16:03] <japhb> Heh

[16:03] *** atroxaper left
[16:03] * TimToady apologizes for mixing one/you

[16:04] <geekosaur> japhb, more or less. (more accurately, that accepting the knighthood specifically puts you in a position where the regent can remove your head)

[16:04] <TimToady> rather than hanging, I suppose...

[16:05] <japhb> geekosaur: Ah, interesting.

[16:05] * PerlJam imagines the french had a hard time knighting people with a guillotine

[16:06] <japhb> That shoulder tap had a hell of a bite.

[16:07] <jaffa4> m: say [1]==[2];

[16:07] <camelia> rakudo-moar 533d1a: OUTPUT«True␤»

[16:08] <jaffa4> m: say [1]==[2,3];

[16:08] <camelia> rakudo-moar 533d1a: OUTPUT«False␤»

[16:08] <jaffa4> m: say (1)==(2,3);

[16:08] <camelia> rakudo-moar 533d1a: OUTPUT«False␤»

[16:08] <geekosaur> mm, is that numifying to the length?

[16:08] <japhb> geekosaur: I'm betting yes.

[16:08] <ShimmerFairy> yep, that's what == does

[16:09] <jaffa4> How can I make full comparison for content as well?

[16:09] <TimToady> eqv

[16:09] <jaffa4> m: say [1] eqv [2];

[16:09] <camelia> rakudo-moar 533d1a: OUTPUT«False␤»

[16:09] <jaffa4> m: say [1] eqv [1];

[16:09] <camelia> rakudo-moar 533d1a: OUTPUT«True␤»

[16:09] <jaffa4> m: say (1) eqv (1);

[16:09] <camelia> rakudo-moar 533d1a: OUTPUT«True␤»

[16:09] <jaffa4> m: say (1) eqv (2);

[16:09] <camelia> rakudo-moar 533d1a: OUTPUT«False␤»

[16:10] <jaffa4> m: say (1,2) eqv (1,2);

[16:10] <camelia> rakudo-moar 533d1a: OUTPUT«True␤»

[16:11] <ShimmerFairy> That reminds me, it'd be nice if [[1,2]] ~~ [[1,2]] DWIMmed

[16:11] <ShimmerFairy> m: say [[1, 2]] ~~ [[1, 2]]

[16:11] <camelia> rakudo-moar 533d1a: OUTPUT«False␤»

[16:11] <ShimmerFairy> (at least 'eqv' works in that case)

[16:11] <TimToady> m: say (1,2) === (1,2)

[16:11] <camelia> rakudo-moar 533d1a: OUTPUT«True␤»

[16:11] <TimToady> m: say [1,2] === [1,2]

[16:11] <camelia> rakudo-moar 533d1a: OUTPUT«False␤»

[16:11] *** diana_olhovik joined
[16:12] <dalek> roast: db20bc7 | (Steve Mynott)++ | S32-io/slurp.t:

[16:12] <dalek> roast: partially fix deprecation

[16:12] <dalek> roast: review: https://github.com/perl6/roast/commit/db20bc7d0c

[16:16] *** itz left
[16:17] *** _itz is now known as itz

[16:20] <jaffa4> What is ("2", 4, 3, "1").list and ("2", 4, 3, "1")?

[16:20] <jaffa4> .perl gives both

[16:20] <jaffa4> What is the difference?

[16:22] <TimToady> that's the List/Parcel distinction that may or may not go away with the GLR

[16:23] <TimToady> Parcel is basically a tuple type, immutable if its parts are immutable

[16:23] <TimToady> lists are a more like arrays, but without enforced containers on each element

[16:24] <TimToady> but the main difference is lists are conceptually lazy, while parcels are not

[16:25] *** tinyblak left
[16:25] <jaffa4> How can I convert a parcel to a list?

[16:25] <TimToady> (a parcel may contain a lazy list, but that's different)

[16:25] <ShimmerFairy> m: say ("2", 4, 3, "1").WHAT; say ("2", 4, 3, "1").list.WHAT

[16:25] <camelia> rakudo-moar 533d1a: OUTPUT«(Parcel)␤(List)␤»

[16:26] <jaffa4> ok

[16:26] <TimToady> parcels are primarily for argument lists, which need to evaluate all the arguments at the top level before doing the call

[16:26] <TimToady> but some of those evaluated arguments can be lazy

[16:27] <jaffa4> I had something like this map {}, @b eqv (1,2,3,4)......

[16:27] <TimToady> (if we didn't evaluate all the arguments, we couldn't do multiple dispatch on the actual type)

[16:27] <jaffa4> and it did not work

[16:27] <TimToady> yeah, eqv requires two arguments of identical type

[16:28] <TimToady> I think ~~ would've worked there

[16:29] <TimToady> m: say map { $_ }, 1,2,3,4 ~~ (1,2,3,4)

[16:29] <camelia> rakudo-moar 533d1a: OUTPUT«1 2 3 False␤»

[16:29] <TimToady> oops

[16:29] <TimToady> m: say (map { $_ }, 1,2,3,4) ~~ (1,2,3,4)

[16:29] <camelia> rakudo-moar 533d1a: OUTPUT«True␤»

[16:29] <TimToady> m: say (map { $_ }, 1,2,3,4) eqv (1,2,3,4).list

[16:29] <camelia> rakudo-moar 533d1a: OUTPUT«True␤»

[16:29] <TimToady> but yeah, that one is a bit of a WAT

[16:30] <jaffa4> and I can see it can be array too

[16:30] <TimToady> m: say [map { $_ }, 1,2,3,4] eqv [1,2,3,4]

[16:30] <camelia> rakudo-moar 533d1a: OUTPUT«True␤»

[16:30] *** TEttinger joined
[16:31] <TimToady> but constructing two arrays is kinda wasted effort, if that's all you do with 'em

[16:31] <jaffa4> it printed Array.new("2", 4, 3, "1")

[16:31] <TimToady> that looks like an old version

[16:32] <jaffa4> m: my @b = ("2",4,3,"1"); say @b.perl;

[16:32] <camelia> rakudo-moar 533d1a: OUTPUT«["2", 4, 3, "1"]<>␤»

[16:32] <TimToady> that's what it's printed for a couple months now

[16:32] <TimToady> and we're hoping to lose the <> soon

[16:33] <TimToady> (more GLR adjustments)

[16:33] <b2gills> kanl: (from backlog) this works: `m: my @a = 1,2; my @b = <a b>; @a Z[&(-> $a, $b { .say for $a, $b, '' })] @b`

[16:33] <b2gills> m: my @a = 1,2; my @b = <a b>; @a Z[&(-> $a, $b { .say for $a, $b, '' })] @b

[16:33] <camelia> rakudo-moar 533d1a: OUTPUT«1␤a␤␤2␤b␤␤»

[16:35] *** JimmyZ_ joined
[16:36] *** JimmyZ__ left
[16:36] <b2gills> The comments in this change: https://github.com/perl6/roast/commit/570c8cc952 don't represent the actual code, as the files aren't open

[16:40] *** dha joined
[16:40] <jaffa4> WHere is the module list<

[16:44] <dha> Not sure how up to date it is, but http://modules.perl6.org

[16:45] <tadzik> as up to date as it gets

[16:45] <jaffa4> Where should I add a new entry to the module list?

[16:46] <tadzik> fork and edit the list on github.com/perl6/ecosystem

[16:48] <dalek> ecosystem/jaffa4-patch-1: 1451955 | jaffa4++ | META.list:

[16:48] <dalek> ecosystem/jaffa4-patch-1: Update META.list

[16:48] <dalek> ecosystem/jaffa4-patch-1: 

[16:48] <dalek> ecosystem/jaffa4-patch-1: added Dependency-Sort

[16:48] <dalek> ecosystem/jaffa4-patch-1: review: https://github.com/perl6/ecosystem/commit/145195566b

[16:57] *** abraxxa left
[16:59] *** JimmyZ_ left
[17:05] *** dakkar left
[17:09] <cognominal> according to Antidote, adouber, the french for "to knight" comes from Frankish "to hit". Apparently used in English, when you want to unmess the chessboard  http://www.chessgames.com/perl/chessgame?gid=1070704&kpage=5   

[17:12] <geekosaur> ...I dub thee... (aha!)

[17:12] *** JimmyZ_ joined
[17:19] <RabidGravy> I may need treatment, I appear to be using "my $foo = do given .... " an awful lot

[17:19] *** JimmyZ_ left
[17:19] <ugexe> you and me both

[17:20] <flussence> wasn't writing it "do given" supposed to be a temporary workaround?

[17:20] <jercos> do given ye for all in some

[17:24] <FROGGS> jnthn: how am I meant to return a value from a block (early)?

[17:26] <skids> Will there be a difference, post-GLR, between how one would MMD multisigs with components like :($a) and :(*@s) when you do func() <== lazy-thing?  i.e. will it always start the iterator to look at the first arguments, or is a feed a special case?

[17:31] *** rurban left
[17:40] *** espadrine left
[17:41] <jnthn> FROGGS: Probably needs an nqp::leave op, which will emit the appropriate VM-level return_* instruction, if it's being done from within the block.

[17:41] <yoleaux> 15:48Z <japhb> jnthn: Great, glad it makes sense to you too; I filed RT #125606 for the "Role requiring private method" issue.

[17:44] <moritz> FROGGS: today I saw a car with license plate FR GS (plus some numbers) and immediatly thought of you :-)

[17:48] *** molaf_ joined
[17:50] <masak> [Coke]: I think traits can get you pretty close to having checked exceptions in Perl 6. the one missing component is having a just-parsed Routine check itself whether it throws exceptions (say) doing a predefined role.

[17:50] <FROGGS> moritz: I've got one with FR-O 665 at home :o)

[17:50] <masak> [Coke]: that last feature (installing hooks on parsing certain code elements) is something I hope to add as part of the macro grant.

[17:51] *** rurban joined
[17:51] <moritz> FROGGS: :-)

[17:52] *** molaf left
[17:54] *** kurahaupo joined
[17:54] <dha> So, in p6 pod, "|" is special inside X<> entries. What do you do if you need a literal "|" inside an X<>?

[17:54] <dha> (and, although I don't see it documented "$!" inside an X<> seems to be problematic as well.

[17:54] <dha> )

[18:02] <lucasb> I like being able to use different syntax for creating the same kind of thing: -> $a,$b { $a+$b }, { $^a + $^b }, (* + *)

[18:02] <lucasb> wrt to pairs vs. named parameters, I wouldn't make them different things, instead I would prefer if they were even more equal.

[18:02] <lucasb> Maybe this wouldn't be technically possible, but in my messy world, I would have enjoyed if things were like these:

[18:02] <lucasb> In sub f(:$a), f('a'=>1) and f($pair) would be a named parameters, since the signature clearly says it doesn't take positionals.

[18:02] <lucasb> In sub f($x), f(a=>1) and f(:a(1)) would be a pair positional, since the signature clearly says it doesn't take named parameters.

[18:02] <lucasb> Don't ask me about other edge cases, because I don't know :)

[18:03] <TimToady> that would be fragile in the face of refactoring to multi, which happens a lot

[18:04] <TimToady> and I don't think you're gonna get jnthn++ to rewrite the binder any time soon :)

[18:05] <masak> we had an extensive discussion the other day.

[18:05] <masak> I'll say again what I said then: I like the local optimum we're in, and I haven't seen an argument so far that makes me want to change things.

[18:06] <masak> the whole thing *is* a bit of a waterbed bump issue. and we're not getting rid of the bump, we can only push it around.

[18:06] *** Hor|zon left
[18:06] <masak> in light of that, let's not.

[18:06] <lucasb> Thanks TimToady++, masak++; I understand my opinion is a dream; just wanted to say it :)

[18:06] *** kurahaupo left
[18:07] <masak> lucasb: you can always have fun in slangs :)

[18:07] <TimToady> to go with Tuxic, we also need Toxic, Texic, Taxic, and Tixic

[18:08] <lucasb> .oO( Masakix and Toadix too? )

[18:09] <TimToady> you've already got Toadix :)

[18:09] <lucasb> yeah, P6 already is Toadix :)

[18:14] <ShimmerFairy> masak: I don't see it as a waterbed issue; what problems would arise from making a => 42 always be a Pair and :a(42) always be a named parameter, and never the other way? ("Would break existing code" doesn't count :P)

[18:14] *** kurahaupo joined
[18:17] <masak> ShimmerFairy: a fair question. let me think about it a bit.

[18:19] <moritz> it would bar :$a for Pair usage

[18:20] <FROGGS> I guess that's nonsense?

[18:20] <FROGGS> ~/dev/MoarVM$ perl6 -e 'use nqp; say (FOO: for ^3 { nqp::leave(123); say "alive" }); say "ho!"'

[18:20] <FROGGS> 123 123 123

[18:20] <FROGGS> ho!

[18:20] <ShimmerFairy> I've never seen that, actually. I can only recall seeing :$a in function calls and the like.

[18:27] <dha> hm... that's unfortunate.

[18:27] <dha> m: my $x = 54;printf "One less than %d is %d\n", $x, --$x;

[18:27] <camelia> rakudo-moar 533d1a: OUTPUT«One less than 53 is 53␤»

[18:28] <dha> Possibly even more unfortunate:

[18:29] <dha> m: my $x = 54;printf "one less than %d is %d\n", $x, $x--;

[18:29] <camelia> rakudo-moar 533d1a: OUTPUT«one less than 53 is 54␤»

[18:29] <TimToady> so don't do that

[18:29] <mst> dha: yeah, that's completely expected

[18:29] <ShimmerFairy> I forget, isn't that kind of stuff traditionally the dreaded "undefined behavior" in C-land ?

[18:29] <mst> I wrote an entire blog post about not doing that

[18:29] <dha> The latter is expected? Ok...

[18:30] <mst> well, more, 'weird stuff happening when you use --$thing and $thing in the same arglist is expected'

[18:30] <dha> Yeah, ok, that I can accept.

[18:30] <ShimmerFairy> (that is, doing stuff with a variable multiple times in an expression, when at one point in the expression you use one of the increment/decrement ops)

[18:30] <dha> BUT THIS MAKES IMPLEMENTING 99 BOTTLES OF BEER ON THE WALL MORE ANNOYING.

[18:31] <dha> Well, this seems to work better...

[18:32] <dha> m: $x = 54;say "one less than $x is {--$x}"

[18:32] <camelia> rakudo-moar 533d1a: OUTPUT«5===SORRY!5=== Error while compiling /tmp/GaKVqDlSjB␤Variable '$x' is not declared␤at /tmp/GaKVqDlSjB:1␤------> 3<BOL>7⏏5$x = 54;say "one less than $x is {--$x}"␤»

[18:32] <dha> m: my $x = 54;say "one less than $x is {--$x}"

[18:32] <camelia> rakudo-moar 533d1a: OUTPUT«one less than 54 is 53␤»

[18:32] <dha> ...but I'm not convinced it's reliable.

[18:33] <dha> And I suspect I'm smart to be so unconvinced.

[18:33] <TimToady> well, there's a statement sequence inside the block, so arguably there's a sequence point

[18:33] *** amurf joined
[18:34] <ShimmerFairy> what about    for 99...1 { say "One less than $x is {$x-1}" }    ?

[18:34] *** Hor|zon joined
[18:34] <dha> So... that *would* be reliable?

[18:35] <TimToady> functional programming without side effects?

[18:35] <masak> m: my $x = 54;printf "one less than %d is %d\n", $x, $x--

[18:35] <camelia> rakudo-moar 533d1a: OUTPUT«one less than 53 is 54␤»

[18:35] <masak> I'm with dha. that's a bug. in sprintf.

[18:35] <masak> m: say $x, $x--

[18:35] <camelia> rakudo-moar 533d1a: OUTPUT«5===SORRY!5=== Error while compiling /tmp/oxfqTHSEPc␤Variable '$x' is not declared␤at /tmp/oxfqTHSEPc:1␤------> 3say 7⏏5$x, $x--␤»

[18:36] <masak> m: my $x = 54; say $x, $x--

[18:36] <camelia> rakudo-moar 533d1a: OUTPUT«5354␤»

[18:36] <masak> hm. or a bug elsewhere?

[18:36] <masak> I've always thought of Perl 6 as having sequence points, and each argument being at least one sequence point, left-to-right.

[18:36] <dha> Well, that definitely smells like a bug to me. Well beyond a result one might expect by altering a term within a statement.

[18:36] <TimToady> you can't depend on the order of side effects like that

[18:37] <ShimmerFairy> If C/C++ considers that kind of usage undefined behavior (wouldn't know offhand), I'm not prepared to call it a bug. I'm sure the ISO guys know what they're doing, most of the time :P

[18:37] *** dwarring joined
[18:37] *** spider-mario joined
[18:37] <dalek> ecosystem: 1451955 | jaffa4++ | META.list:

[18:37] <dalek> ecosystem: Update META.list

[18:37] <dalek> ecosystem: 

[18:37] <dalek> ecosystem: added Dependency-Sort

[18:37] <dalek> ecosystem: review: https://github.com/perl6/ecosystem/commit/145195566b

[18:37] <dalek> ecosystem: fd56d1b | (David Warring)++ | META.list:

[18:37] <dalek> ecosystem: Merge pull request #49 from perl6/jaffa4-patch-1

[18:37] <dalek> ecosystem: 

[18:37] <dalek> ecosystem: Update META.list add Dependency-Sort

[18:37] <dalek> ecosystem: review: https://github.com/perl6/ecosystem/commit/fd56d1be9e

[18:37] <masak> TimToady: I'm surprised to hear that. I'll have to revise my understanding of argument evaluation, then.

[18:37] <TimToady> yes, it evaluates left-to-right, and you still can't depend on the interaction of side effects with references

[18:38] *** amurf left
[18:38] <TimToady> it evaluates $x and returns $x, not it's value

[18:38] <masak> *nod*

[18:38] <TimToady> we can't do otherwise till we know how it's to be bound

[18:38] <masak> oh, that is true.

[18:38] <TimToady> so this is a Will Not Fix

[18:39] * masak silently shuffles over to the "yeah, so don't do that" camp

[18:40] <masak> basically this falls out of having `is rw`

[18:40] <TimToady> or even default ro that can cheat with rw for efficiency

[18:40] <TimToady> which is what the current design is optimized for

[18:41] <TimToady> otherwise we'd have to pessimize everything to 'is copy'

[18:44] <jnthn> heh, was just about to make the points TimToady++ just did, but by the time I caught up wiht backlog he'd made 'em

[18:44] <jnthn> foo($pair) becoming a named breaks the "we always statically/syntactically know what is a named arg and a positional arg"

[18:45] <jnthn> Which would be horrible from a compiler/performance perspective, if I'm wearing that hat.

[18:45] <jnthn> But I don't want it from a refactoring/obvious visual mapping to behavior perspective either ;)

[18:47] *** atroxaper joined
[18:48] <jnthn> Rightly, lets see if I can nail the last 12 VM-level multi-dim tests on JVM...

[18:51] *** khw left
[18:52] *** atroxaper left
[18:57] <[Coke]> what are you using for compact storage on the JVM?

[18:57] <moritz> IO::Notification.watch_path gives me a FileChangeEvent::FileRenamed for both created and deleted files

[18:57] <moritz> is that expected?

[18:58] <jnthn> [Coke]: A depressing amount of copy-paste code...and JVM native arrays.

[18:59] <jnthn> moritz: Good question, iirc it's a fairly direct exposure of what libuv tells us.

[19:04] *** telex left
[19:06] *** telex joined
[19:06] *** khw joined
[19:07] *** nowan_ joined
[19:07] *** pullphinger joined
[19:07] *** pullphinger left
[19:08] <timotimo> it could be that it's platform-dependent, or maybe even dependent on what exactly the application does to create a file or delete it?

[19:08] *** pullphinger joined
[19:08] * timotimo has not done much with filesystem watchers yet

[19:09] *** nowan left
[19:13] <dha> In the p5->p6 doc, in the bit about whitespace, it shows these contrasting examples:

[19:13] <dha> $seen {$_} ++; # Perl 5

[19:13] <dha> $seen{$_}++;   # Perl 6

[19:13] <dha> Should that second one not be C<%seen{$_}++> ?

[19:16] <masak> yes, it should.

[19:17] <masak> today I had a silly idea for a slang -- I thought I'd share.

[19:17] <dha> Oh good. if you haven't beaten me to it, I'll change that. :-)

[19:19] <dalek> doc: e7051e3 | (David H. Adler)++ | lib/Language/5to6.pod:

[19:19] <dalek> doc: Changed Perl 6 example in Whitespace section from C<$seen{$_}++> to

[19:19] <dalek> doc: C<%seen{$_}++>

[19:19] <dalek> doc: review: https://github.com/perl6/doc/commit/e7051e3fa2

[19:19] <dha> masak -  Slang is good. :-)

[19:19] <masak> so, let's say you have a `class C ` and a `my %h{C}` -- then the entries in %h could almost be seen as a kind of "external attribute" or "outside-in attributes". and we could allow `$c.%h` to mean `%h{$c}`.

[19:20] <masak> good idea, or great idea? :P

[19:21] <masak> it would be kind of like `$c.&sub()`, but for data.

[19:24] * jnthn notes that $c.@foo already has a meaning

[19:25] <masak> that somehow doesn't bother me much.

[19:25] <masak> I'd also be fine with the syntax `$c.%h{}`, which mirrors `$c.&foo()` more closely.

[19:30] <RabidGravy> Hmm as it currently stands I think Audio::Encode::LameMP3 is going to be too slow, the copying of large arrays to CArrays and back is really quite costly

[19:30] <jnthn> RabidGravy: What're you copying them from/to?

[19:30] <[Coke]> masak: scoping on that seems.. hard. 

[19:31] <masak> RabidGravy: if only someone was working on compact multidim arrays... :P

[19:32] <masak> [Coke]: how so? `$c` and `%h` must both be in scope, or course. it's literally just sugar for `$h{$c}`.

[19:34] <RabidGravy> masak :)

[19:35] <dalek> nqp: 5c3771f | jnthn++ | t/moar/02-multidim.t:

[19:35] <dalek> nqp: Eliminate bogus test.

[19:35] <dalek> nqp: 

[19:35] <dalek> nqp: nqp::numdimensions op is for use on instances only.

[19:35] <dalek> nqp: review: https://github.com/perl6/nqp/commit/5c3771f129

[19:35] <dalek> nqp: b61ab1e | jnthn++ | src/vm/jvm/runtime/org/perl6/nqp/sixmodel/reprs/MultiDimArray (12 files):

[19:35] <dalek> nqp: Implement serialize/deserialize of MultiDimArray.

[19:35] <dalek> nqp: review: https://github.com/perl6/nqp/commit/b61ab1e341

[19:35] <RabidGravy> jnthn, basically  @array -> CArray[$type]  -> lame_encode(CArray) -> CArray[uint8] -> Buf

[19:35] *** rindolf left
[19:36] <dha> So, in p5's perlsyn, it indicates that all declarations take place at compile time. a) is that still true in p6 and b) is there any reason that should be explicitly pointed out if it isn't?

[19:36] <jnthn> It'd be desriable to eliminate 2 of those steps :)

[19:36] <jnthn> dha: Yes, it's still true in Perl 6; there's also more things that count as declarations.

[19:37] *** bin_005_i joined
[19:37] <jnthn> m: sub foo() { say "I'm here!" }; BEGIN foo;

[19:37] <camelia> rakudo-moar 533d1a: OUTPUT«I'm here!␤»

[19:37] <jnthn> That one I guess is same as Perl 5

[19:37] <jnthn> m: class C { method m() {  say "I'm here!" } }; BEGIN C.m;

[19:37] <camelia> rakudo-moar 533d1a: OUTPUT«I'm here!␤»

[19:38] <jnthn> But classes also come into existence at BEGIN time

[19:38] <jnthn> m: class C { method m() {  say "I'm here!" }; BEGIN C.m; } # this too, even...

[19:38] <camelia> rakudo-moar 533d1a: OUTPUT«I'm here!␤»

[19:38] <jnthn> But don't do that :P

[19:38] <jnthn> (the final one I did, that is)

[19:38] <dha> ok. I think that may be out of the scope of the Declarations section of perlsyn anyway.

[19:39] <jnthn> Maybe so. BEGIN time is very much a thing in Perl 6 though :)

[19:39] <jnthn> So much so I managed to do a whole hour's talk about it :P

[19:41] <[Coke]> masak: oh. meh?

[19:42] <dha> This is why, in the documents I'm working on, I make a point of saying that these documents are meant to guide you from p5 to p6 and, therefore, will not be exhausively documenting p6. :-)

[19:42] <masak> [Coke]: I could see it being useful. I sometimes want to "annotate" my own or other others' objects with externally available information.

[19:45] <masak> [Coke]: like, say, in a DFS algorithm, I want to mark nodes as "seen" or "visited".

[19:46] <dalek> nqp: ef58e0d | jnthn++ | t/jvm/02-multidim.t:

[19:46] <dalek> nqp: Give t/jvm a copy of the multi-dim tests.

[19:46] <dalek> nqp: review: https://github.com/perl6/nqp/commit/ef58e0dcfd

[19:48] *** [Sno] left
[19:48] <RabidGravy> jnthn, yeah, unfortunately you can't do anything with the CArrays without passing the length around

[19:51] <dalek> nqp: 80a51ca | jnthn++ | t/jvm/02-multidim.t:

[19:51] <dalek> nqp: Add uncomposed/type-object edge-case tests.

[19:51] <dalek> nqp: 

[19:51] <dalek> nqp: The JVM implementation nails these, but MoarVM probably won't yet.

[19:51] <dalek> nqp: review: https://github.com/perl6/nqp/commit/80a51ca2e8

[19:52] *** rurban left
[19:57] <hoelzro> when determining the longest literal prefix for a rule, I see that | alternation variants can extend the literal prefix.  Does the same apply for ||?

[19:58] <masak> no.

[19:58] <hoelzro> thanks masak 

[20:00] <jnthn> Yeah, hitting a sequential alternation marks the end of the declarative prefix.

[20:00] <jnthn> (just checked that's exactly what happens in the code)

[20:00] <hoelzro> I saw the behavior, just checking to see that it made sense spec-wise =)

[20:01] <jnthn> aye belive so

[20:01] <jnthn> *aye, I believe so...

[20:01] <FROGGS> 'think so too fwiw

[20:01] <FROGGS> aye feel you forgot something there :P

[20:02] <TimToady> m: say 'food' ~~ / 'foo' | ('food' || 'doof')/

[20:02] <camelia> rakudo-moar 533d1a: OUTPUT«｢foo｣␤»

[20:02] <FROGGS> doof O.o

[20:02] <TimToady> hmm, STD would've picked 'food' there

[20:02] *** TEttinger left
[20:02] <FROGGS> ò.ó

[20:02] <TimToady> it counts the first part of the || as declarative

[20:02] *** darutoko left
[20:03] <jnthn> TimToady: Declarative but optional, I presume?

[20:03] <TimToady> it counts the 'food' as part of LTM, iirc

[20:04] <TimToady> on the assumption that most || are just error throws

[20:05] <TimToady> m: say 'food' ~~ / 'foo' | ('food' <!> || 'doof')/

[20:05] <camelia> rakudo-moar 533d1a: OUTPUT«｢foo｣␤»

[20:05] <dha> Ok, so in Perl 5, C<if>, C<unless>, C<while>, C<until>, C<for>, C<foreach>, and C<when> can be used as statement modifiers. Other than C<do {...} while (blah)> being replaced with C<repeat {...} while(blah)>, are there any restrictions in p6 on these being used as statement modifiers?

[20:05] *** diana_olhovik left
[20:06] <masak> TimToady: well, does that have any support in S05? otherwise S05 should probably mention that...

[20:06] <RabidGravy> dha, and no foreach

[20:06] <hoelzro> fwiw, Grammar::Tracer disagrees with the longest literal prefix conclusion =/

[20:06] <masak> dha: yes, you can only nest conditional modifiers inside loopy ones. no other combination, at least not without parens.

[20:07] <masak> m: .say if $_ %% 2 for 1..10

[20:07] <camelia> rakudo-moar 533d1a: OUTPUT«2␤4␤6␤8␤10␤»

[20:07] <masak> m: .say for 1..10 if True

[20:07] <camelia> rakudo-moar 533d1a: OUTPUT«5===SORRY!5=== Error while compiling /tmp/Q3__3m6Wqy␤Missing semicolon␤at /tmp/Q3__3m6Wqy:1␤------> 3.say for 1..10 if 7⏏5True␤»

[20:07] <dha> RabidGravy -  Well, foreach is now for, and the c-style for is now loop.

[20:08] <dha> masak -  uh... not sure if I'm clear on what you're saying there.

[20:09] <TimToady> masak: depends on how you read it...it says that LTM is terminated by a ||

[20:09] <dha> Are you saying that I can't do C<< foo() if $x > 5 >>? Or possibly that I can do that, but it would have to be C<< foo() if($x > 5 >>?

[20:10] <dha> sorry, ($x > 5)

[20:10] <jnthn> dha: No, you can do C<< foo() if $x > 5 >> just fine

[20:10] <masak> dha: I'm saying it has to be `stmt if .. for ..` in that order, but the `if` can be any conditional (or missing) and the `for` can be any loop (or missing)

[20:10] <jnthn> dha: It's that you can't do like C<< foo() for @a if $x > 5; >> for example

[20:11] <TimToady> masak: actually, it's explicitly required at S05:2885

[20:11] <masak> right, loops may not nest inside confitionals

[20:11] <masak> TimToady: ok, good.

[20:11] <TimToady> so this is a bug, by that

[20:12] * masak submits rakudobug

[20:12] <TimToady> m: say 'food' ~~ / 'foo' | ('food' <!> || die "Should die here")/

[20:12] <camelia> rakudo-moar 533d1a: OUTPUT«｢foo｣␤»

[20:12] * dha considers how to phrase this...

[20:12] <hoelzro> the longest literal prefix is a static property of a Regex, right? would it make sense to expose that as a property on a Regex object, so that users can discover what it is without having to dive into rakudo internals?

[20:13] * masak .oO( well yeah, if it's correctly implemented... ) :P

[20:14] <TimToady> hoelzro: as currently defined, ab [ cd | ef ] has two longest literals

[20:14] <hoelzro> ah, so the longest literal for tie breaking depends on which actually matched, right?

[20:14] *** frobisher joined
[20:15] <TimToady> right

[20:15] <TimToady> it's not clear whether those semantics will survive some of the optimizations I'd like to do, though

[20:15] <hoelzro> alright

[20:16] *** dha left
[20:16] <RabidGravy> right, it took a gnat's cock over an hour to encode a 5:50 WAV file to a 320kbps WAV at moderate quality

[20:16] <RabidGravy> this clearly won't work for streaming

[20:16] <RabidGravy> :-\

[20:17] <TimToady> not yet

[20:17] <RabidGravy> 320kbps MP3 rather

[20:19] *** frobisher is now known as dha

[20:19] <FROGGS> hah, working on leave() almost makes me feel that I know what I'm doing :P

[20:20] <dalek> nqp: bd3a92a | jnthn++ | tools/build/MOAR_REVISION:

[20:20] <dalek> nqp: Bump to MoarVM with some multi-dim fixes.

[20:20] <dalek> nqp: review: https://github.com/perl6/nqp/commit/bd3a92a221

[20:20] <dalek> nqp: 65d85a3 | jnthn++ | t/moar/02-multidim.t:

[20:20] <dalek> nqp: Run some extra multi-dim tests on Moar.

[20:20] <dalek> nqp: review: https://github.com/perl6/nqp/commit/65d85a3c95

[20:22] <dha> I guess my remaining question about statement modifiers is, is there some way in which C<loop> can be used as one?

[20:22] <masak> no.

[20:22] <dha> Didn't think so. ok.

[20:25] <RabidGravy> am I right in saying that the return type plays no role whatsoever in multi dispatch?

[20:26] <FROGGS> correct

[20:26] <FROGGS> would be nice if it was though, IMO

[20:27] <FROGGS> though maybe it would cause too much trouble

[20:28] <FROGGS> like forcing the caller to be strict on the expected return type to not have more than one mmd candidate

[20:28] <RabidGravy> yeah especially chaining multi methods to multi methods

[20:29] <jnthn> Indeed

[20:30] <jnthn> FROGGS: I'll look at your leave work tomorrow :)

[20:31] *** kaare_ left
[20:31] * TimToady still wonders whether a small return should just be called "ret"

[20:31] * jnthn got done with the JVM porting of the multi-dim array underpinnings

[20:33] <dha> Small Prophet, Quick Return.

[20:35] <RabidGravy> not a slight return then

[20:37] *** dwarring left
[20:37] <dha> Quite frankly, I'm still surprised that they let him get away with that title, but wouldn't let him use "Is There A Doctor In The Horse"

[20:37] *** synbot6 joined
[20:38] <FROGGS> jnthn: it changed in the meantime :P

[20:38] <jnthn> FROGGS: Yes, I noticed I've more commits to look at now ;)

[20:39] <FROGGS> jnthn: no, not committed yet, but will do before going to bed

[20:39] *** synbot6 left
[20:40] <jnthn> OK :)

[20:40] <jnthn> Gonna get some rest...had an early morning

[20:40] <jnthn> 'night

[20:41] <FROGGS> gnight jnthn 

[20:42] <RabidGravy> nighty night

[20:42] <masak> 'night, #perl6

[20:44] <FROGGS> m: say Block.^mro

[20:44] <camelia> rakudo-moar 533d1a: OUTPUT«(Block) (Code) (Any) (Mu)␤»

[20:50] *** n0tjack left
[20:51] *** xfix left
[20:53] *** FROGGS left
[20:57] <dha> Are there any significant differences between p5's C<goto> and p6's C<goto>?

[20:58] <PerlJam> dha: yeah, the latter doesn't work yet :)

[20:58] <dha> Heh. But if it *did* work...

[21:02] <dha> Am I safe in saying "It doesn't work. But when it does work, it will be pretty much the same as it was in Perl 5"?

[21:02] <PerlJam> I think p6's goto is a little more structured, but I'd check S04 to be sureer.

[21:02] <dha> Yeah, I looked at S04. It made my brain hurt.

[21:04] <dha> Also, I seem to have found another search bug at doc.perl6.org. Searching for "..." gives a result, but when you go to it the page is not found.

[21:06] *** meisl joined
[21:06] <meisl> hello #perl6

[21:08] *** pullphinger left
[21:08] *** lucasb left
[21:10] *** [Sno] joined
[21:10] *** skids left
[21:13] *** colomon joined
[21:14] *** _sri left
[21:14] *** _sri joined
[21:22] *** espadrine joined
[21:26] *** colomon left
[21:27] *** colomon joined
[21:35] *** ilogger2 joined
[21:35] *** ChanServ sets mode: +v ilogger2

[21:45] *** ][Sno][ joined
[22:05] *** synbot6 joined
[22:11] *** amurf joined
[22:15] *** amurf left
[22:19] *** dha joined
[22:20] <dha> Achievement unlocked: perlsyn finished.

[22:21] <dha> (sort of, anyway.)

[22:23] *** atroxaper joined
[22:28] *** atroxaper left
[22:34] <RabidGravy> right, bed time.

[22:56] *** amurf joined
[23:03] *** skids joined
[23:03] <dha> Do we have a Getopt kind of module for Perl 6 yet? Or some kind of built in capacity for dealing with command line flags in programs?

[23:05] <skids> So, what was the rationale behind having unhandled Failures carp when DESTROYed?

[23:05] *** dha left
[23:06] <skids> dha: sub MAIN does some stuff.  But only if you want to conform to what it does.  Not that that's a bad idea for new apps, but it isn't getopt and can't emulate legacy stuff.

[23:10] <raiph> dha: https://perl6advent.wordpress.com/2010/12/02/day-2-interacting-with-the-command-line-with-main-subs/

[23:11] <skids> Hrm, is there a way to remove a submethod from a parent class when subclassing it?

[23:15] <raiph> I've got 'Foo.pm6' in cwd. Script 'Bar.pl6' contains 'use Foo;'. But 'perl6 Bar.pl6' says "Could not find Foo...". What am I doing wrong?

[23:15] <raiph> skids: submethods don't get inherited

[23:16] * skids trying to figure out how to subclass Failure and remove DESTROY.

[23:16] <skids> I don't want that behavior.

[23:17] <raiph> skids: will shadowing the submethod suffice?

[23:17] <skids> Nope, tried that.

[23:18] <skids> Also tried self.Bool to autohandle it in the subclasse's DESTROY, but that doesn't seem to work either.

[23:19] <skids> I don't see why the behavior is useful to begin with, IMO one should have to use a specially flaovored Failure to get GC warnings.

[23:21] <skids> Just because I create a Failure doesn't mean I want it active.  If I decide otherwise and throw it in the trash it should just go away.

[23:33] * raiph sees that perl6 -I. *does* work after all

[23:42] <skids> Anyway, on more minor Failure related issues, comments/bikeshedding for https://github.com/rakudo/rakudo/pull/470 is welcome.

[23:43] * raiph surprised that perl6 -I. seems to have stopped working again

[23:43] <skids> I've never use -l. specifically.

[23:44] <raiph> ah, just figured it out. was getting extensions wrong.

[23:44] <raiph> skids: do you use PERL6LIB?

[23:44] <skids> sometimes, or "use lib" in the script... the latter especially with t/ directories.

[23:45] <skids> Or -l./something.  I'm usually not working with scripts in the cwd.

