[00:06] * japhb_ is back from an exhausting week abroad

[00:06] *** japhb_ is now known as japhb

[00:06] <japhb> How goes the Perl 6 world?

[00:09] *** ShimmerFairy joined
[00:13] *** yqt left
[00:13] *** BenGoldberg left
[00:13] *** BenGoldberg joined
[00:14] *** BenGoldberg left
[00:14] *** BenGoldberg joined
[00:18] *** tokuhiro_ joined
[00:18] *** uberbaud left
[00:21] *** _28_ria left
[00:22] *** tokuhiro_ left
[00:24] *** adhoc left
[00:25] *** tokuhirom joined
[00:30] *** tokuhirom left
[00:31] *** _28_ria joined
[00:32] *** _28_ria left
[00:34] *** skids joined
[00:35] *** kjs_ joined
[00:42] <timotimo> PerlJam, panda doesn't require something to be in the ecosystem to install it; it just has to have a META.info and then you can just panda install .

[00:43] <timotimo> (just something i picked up in backscroll)

[00:47] *** lichtkind left
[00:51] *** kjs_ left
[00:58] <raiph> FYI #perl6: Perl 6 (6.Advent) online at http://dev.perltuts.com/try

[00:58] <timotimo> PerlJam: did you know you can write "\c[foobar, bazquux]" instead of "\c[foobar]\c[bazquux]"?

[01:00] *** kjs_ joined
[01:00] *** kjs_ left
[01:03] <BenGoldberg> m: say "\c[PILE OF POO, SNOWMAN]"

[01:03] <camelia> rakudo-moar 75ac71: OUTPUT«💩☃␤»

[01:04] <timotimo> raiph: why only advent, not birthday? :)

[01:05] <timotimo> oh, you're not the one responsible for this site

[01:05] <ShimmerFairy> Is there (or should there) be a way to tell an enum declaration not to pollute the surrounding scope? I'd like to have enum declarations where you're required to use the qualified name regardless, and thus also avoid warnings where I specifically don't need them :)

[01:06] <ShimmerFairy> m: enum Foo <quux>; enum Bar <quux>;

[01:06] <camelia> rakudo-moar 75ac71: OUTPUT«Potential difficulties:␤    Redeclaration of symbol quux␤    at /tmp/FLCo0SjiK6:1␤    ------> 3enum Foo <quux>; enum Bar <quux>7⏏5;␤»

[01:07] <raiph> timotimo: if it was .birthday someone would be asking why it isn't .christmas ;) Anyhoo, I only just noticed it and thought it was worth #perl6ers knowing about it...

[01:08] <raiph> timotimo: and presumably it would be best if it was *.birthday rather than just the compiler

[01:08] <timotimo> ah

[01:09] <timotimo> this thing doesn't have any security measures in place, does it? >_>

[01:09] <raiph> shh

[01:10] <timotimo> "hey, u want to run a bash on my server? go ahead, man!"

[01:10] * timotimo writes a bitcoin miner in perl6 :P

[01:11] <BenGoldberg> m: say "\c[WHITE SUN WITH RAYS, PLUS SIGN, SNOWMAN, EQUALS SIGN, POTABLE WATER SYMBOL]"

[01:11] <camelia> rakudo-moar 75ac71: OUTPUT«☼+☃=🚰␤»

[01:12] *** _dolmen_ left
[01:13] <BenGoldberg> camelia will timeout if the code takes too long to complete, so using it's cpu cycles to mine bitcoins might not be worthwhile.

[01:13] <BenGoldberg> m: sleep 10;

[01:14] <camelia> rakudo-moar 75ac71: ( no output )

[01:14] <BenGoldberg> m: say Promise.new

[01:14] <camelia> rakudo-moar 75ac71: OUTPUT«Promise.new(scheduler => ThreadPoolScheduler.new(initial_threads => 0, max_threads => 16, uncaught_handler => Callable), status => PromiseStatus::Planned)␤»

[01:14] <BenGoldberg> m: say Promise.new.await;

[01:14] <camelia> rakudo-moar 75ac71: OUTPUT«Method 'await' not found for invocant of class 'Promise'␤  in block <unit> at /tmp/s7DaklpkEk:1␤␤»

[01:15] <BenGoldberg> m: await Promise.new;

[01:15] <timotimo> BenGoldberg: how about i run a double fork kind of deal and become unparented by the executing process?

[01:15] <camelia> rakudo-moar 75ac71: OUTPUT«(timeout)»

[01:15] <timotimo> unless that evaluation thingie is using cgroups or so, there's not a chance it'll catch that

[01:16] <BenGoldberg> m: say Processes::fork();

[01:16] <camelia> rakudo-moar 75ac71: OUTPUT«Could not find symbol '&fork'␤  in block <unit> at /tmp/Q3Hohi4Cgq:1␤␤Actually thrown at:␤  in block <unit> at /tmp/Q3Hohi4Cgq:1␤␤»

[01:18] <BenGoldberg> m: sub fork() returns Int is native(*) {}; say fork();

[01:18] <camelia> rakudo-moar 75ac71: OUTPUT«5===SORRY!5=== Error while compiling /tmp/tO_qQpqHat␤Can't use unknown trait 'is native' in a sub+{callable[int]} declaration.␤at /tmp/tO_qQpqHat:1␤    expecting any of:␤        rw raw hidden-from-backtrace hidden-from-USAGE␤        cached pu…»

[01:18] <BenGoldberg> m: sub fork() returns Int is Native(*) {}; say fork();

[01:18] <camelia> rakudo-moar 75ac71: OUTPUT«5===SORRY!5=== Error while compiling /tmp/6AzReSVvrY␤Can't use unknown trait 'is Native' in a sub+{callable[int]} declaration.␤at /tmp/6AzReSVvrY:1␤    expecting any of:␤        rw raw hidden-from-backtrace hidden-from-USAGE␤        cached pu…»

[01:18] <timotimo> need to "use NativeCall"

[01:19] <BenGoldberg> m: use NativeCall; sub fork() returns Int is native(*) {}; say fork();

[01:19] <camelia> rakudo-moar 75ac71: OUTPUT«5===SORRY!5=== Error while compiling /tmp/nuuZI4L_4t␤No appropriate parametric role variant available for 'Native'␤at /tmp/nuuZI4L_4t:1␤»

[01:20] <timotimo> you want "is native(Str)"

[01:20] <BenGoldberg> m: use NativeCall; sub fork() returns Int is native {*}; say fork();

[01:21] <camelia> rakudo-moar 75ac71: OUTPUT«(timeout)»

[01:21] <timotimo> an error of some kind i would understand, or even camelia crashing ... but a timeout?

[01:22] <BenGoldberg> m: use NativeCall; sub kill(Int $proc, Int $sig) is native {*}; kill($*PID,SIGINT); sleep 1;

[01:22] <camelia> rakudo-moar 75ac71: OUTPUT«(signal INT)»

[01:24] <AlexDaniel> Hm, some people tend to dislike perl6 logo. I don't get it, it's the best logo I've ever seen…

[01:25] <timotimo> https://drive.google.com/file/d/0B9i8WqXLW451MTIyM2lqR1lpZ3M/view?pli=1 - oh wow

[01:25] <timotimo> AlexDaniel: did you see that amusing poster for some death metal festival or something?

[01:25] <timotimo> where one band had its name spelled in colorful, friendly letters

[01:26] <timotimo> and all others looked like they used the exact same font; or were made by the exact same illustrator? :D

[01:26] <AlexDaniel> nope :D

[01:26] <timotimo> gimme a minute

[01:28] *** yuvipanda_ joined
[01:28] <timotimo> damn you, twitter >:(

[01:29] *** yuvipanda_ left
[01:30] <timotimo> http://www.buzzfeed.com/patricksmith/party-cannon#.kpQrnxplvO  -  a google search found a post about the picture i meant in just seconds

[01:30] <timotimo> why did i even think i could find it faster via my "search twitter for anything perl6 related" thing or even "show me all my tweets please"

[01:33] <BenGoldberg> This poster? http://2.bp.blogspot.com/-QthKHzvz2A8/UexNajg_WgI/AAAAAAAAArI/O3aWsWUUdVM/s1600/flyer.jpg

[01:35] <timotimo> that's not the one i first saw

[01:35] <timotimo> the one i meant was the one i linked to above ^

[01:35] <timotimo> the buzzfeed link

[01:36] <AlexDaniel> awesome

[01:39] <timotimo> though the landscape of programming language logos isn't as dire

[01:41] <AlexDaniel> yeah, some mating snakes here, retarded creature there. Oh look, a butterfly!

[01:41] * timotimo goes to bed now

[01:44] <BenGoldberg> Perl5's logo is an onion.  A joke about pearl onions, iirc.

[01:50] <lucs> Um, reading on regexes, I understand  $/ , but what is the tilde in  say ~$/ ?

[01:51] <ugexe> return $/.Str instead of the match object

[01:51] *** aborazmeh joined
[01:51] *** aborazmeh left
[01:51] *** aborazmeh joined
[01:52] <TEttinger> timotimo: haha, party cannon is legitimate metal despite the logo

[01:53] <lucs> ugexe: Ah, I see. Thanks. (in retrospect, I guess looking up the  ~  operator is what I should have done)

[01:54] <TEttinger> (also, worst logo for a sports team is http://activerain.com/image_store/uploads/3/2/8/5/5/ar122356841855823.jpg )

[01:59] <raiph> apparently an online perl6 has been available at http://dev.perltuts.com/try since 2013

[02:00] <raiph> it looks like it's Star (`use MIME::Base64` worked)

[02:07] <retupmoca> m: my @x = 1, 2, 3; my $foo = @x.flat; $foo.flat;

[02:07] <camelia> rakudo-moar 75ac71: ( no output )

[02:08] <retupmoca> m: my @x = 1, 2, 3; my $foo = @x.flat; $foo.flat; $foo.flat

[02:08] <camelia> rakudo-moar 75ac71: OUTPUT«This Seq has already been iterated, and its values consumed␤  in block <unit> at /tmp/cp4oTlD0rV:1␤␤»

[02:08] <retupmoca> that seems...wrongish

[02:09] <retupmoca> m: my @x = 1, 2, 3; my $foo = @x.flat; $foo.flat; say $foo

[02:09] <camelia> rakudo-moar 75ac71: OUTPUT«This Seq has already been iterated, and its values consumed␤  in block <unit> at /tmp/PLbJB_ZUI6:1␤␤»

[02:09] <retupmoca> m: my @x = 1, 2, 3; my $foo = @x.flat; say $foo

[02:09] <camelia> rakudo-moar 75ac71: OUTPUT«(1 2 3)␤»

[02:09] <gfldex> m: my @x = 1, 2, 3; my @foo = @x.flat; @foo.flat; say @foo

[02:09] <camelia> rakudo-moar 75ac71: OUTPUT«[1 2 3]␤»

[02:09] <gfldex> if you want a list you have to ask for a list

[02:10] <retupmoca> m: my @x = 1, 2, 3; say $foo; my $foo = @x.flat; say $foo

[02:10] <camelia> rakudo-moar 75ac71: OUTPUT«5===SORRY!5=== Error while compiling /tmp/gT1Tvwt_zq␤Variable '$foo' is not declared␤at /tmp/gT1Tvwt_zq:1␤------> 3my @x = 1, 2, 3; say 7⏏5$foo; my $foo = @x.flat; say $foo␤»

[02:10] <retupmoca> m: my @x = 1, 2, 3; my $foo = @x.flat; say $foo; $foo.flat; say $foo

[02:10] <camelia> rakudo-moar 75ac71: OUTPUT«(1 2 3)␤This Seq has already been iterated, and its values consumed␤  in block <unit> at /tmp/rsYV9D8BhT:1␤␤»

[02:10] <retupmoca> sure, but only being able to use $foo once?

[02:11] <retupmoca> or rather, once you call .flat, you can no longer use it

[02:11] <gfldex> that's what a Seq does

[02:12] <retupmoca> ...huh

[02:12] * retupmoca wanders off to read more about GLR changes

[02:18] <raiph> .tell timotimo Looks like the architecture underlying the online perl 6 is https://alexm.github.io/writing-tutorials-for-perltuts/#/6/4

[02:18] <yoleaux> raiph: I'll pass your message to timotimo.

[02:27] *** tokuhirom joined
[02:27] *** mspo left
[02:30] *** tokuhiro_ joined
[02:31] *** tokuhirom left
[02:34] *** tokuhiro_ left
[02:41] *** AlexDaniel left
[02:45] *** bpmedley left
[02:47] *** O47m341 joined
[02:49] *** Oatmeal left
[02:50] *** mattp_ left
[02:50] *** mattp_ joined
[02:54] *** bjz joined
[03:02] *** raiph left
[03:09] *** kid51 left
[03:13] *** BenGoldberg left
[03:28] *** tokuhirom joined
[03:32] *** tokuhirom left
[03:32] *** adu joined
[03:48] *** abaugher left
[03:49] *** abaugher joined
[03:51] *** abaugher left
[03:59] *** abaugher joined
[04:16] *** tokuhiro_ joined
[04:20] *** tokuhiro_ left
[04:21] *** cognominal left
[04:22] *** cognominal joined
[04:27] *** pollei left
[04:34] <Hotkeys> Is there a way to convert from a base in a variable

[04:34] <Hotkeys> m: say :3<22>

[04:34] <camelia> rakudo-moar 75ac71: OUTPUT«8␤»

[04:34] <Hotkeys> vs

[04:34] <Hotkeys> m: my $b = 3; say :$b<22>

[04:34] <camelia> rakudo-moar 75ac71: OUTPUT«(Mu)␤»

[04:35] <Hotkeys> is there another syntax for the second

[04:37] *** risou left
[04:42] *** khw left
[05:01] *** lolisa joined
[05:12] *** zakharyas left
[05:15] *** espadrine_ joined
[05:25] *** espadrine_ left
[05:25] *** adhoc joined
[05:29] *** tokuhirom joined
[05:33] *** llfourn joined
[05:34] *** tokuhirom left
[05:35] *** telex left
[05:36] *** telex joined
[05:43] *** vendethiel joined
[05:44] *** adu left
[05:46] *** bjz left
[05:46] *** softmoth left
[05:47] *** risou joined
[05:51] *** bjz joined
[05:53] *** bjz_ joined
[05:55] *** bjz left
[06:00] *** mattp_ left
[06:01] *** mattp_ joined
[06:04] *** kaare_ joined
[06:06] *** rurban joined
[06:07] *** vendethiel left
[06:09] *** zacts left
[06:13] *** zacts joined
[06:14] <dalek> ecosystem: 6a28722 | PerlJam++ | META.list:

[06:14] <dalek> ecosystem: Add Astro::Sunrise

[06:14] <dalek> ecosystem: review: https://github.com/perl6/ecosystem/commit/6a287225e0

[06:27] *** xiaoyafeng joined
[06:28] <xiaoyafeng> I'm confused about Num and Rat etc.

[06:28] <xiaoyafeng> I tried a example onhttps://en.wikibooks.org/wiki/Perl_6_Programming/Variables_and_Data

[06:28] <xiaoyafeng> my Num $bar = 3.14;

[06:29] <xiaoyafeng> but got an error:Type check failed in assignment to '$dd'; expected 'Num' but got 'Rat'

[06:29] <llfourn> m: my Num $bar = 3.14

[06:29] <camelia> rakudo-moar 75ac71: OUTPUT«Type check failed in assignment to $bar; expected Num but got Rat␤  in block <unit> at /tmp/gOC8ksRUqV:1␤␤»

[06:29] <masak> xiaoyafeng: 3.14 is a Rat

[06:29] <masak> m: say (3.14).^name

[06:29] <camelia> rakudo-moar 75ac71: OUTPUT«Rat␤»

[06:29] <masak> xiaoyafeng: and it does not fit in a Num variable.

[06:30] <masak> m: say Rat ~~ Num

[06:30] <camelia> rakudo-moar 75ac71: OUTPUT«False␤»

[06:30] <masak> xiaoyafeng: this works, though

[06:30] <xiaoyafeng> so what is Num?

[06:30] <masak> m: my Num $bar = 3.14e0

[06:30] <camelia> rakudo-moar 75ac71: ( no output )

[06:30] <masak> m: say 3.14e0.^name

[06:30] <camelia> rakudo-moar 75ac71: OUTPUT«Num␤»

[06:30] <masak> xiaoyafeng: think of Rat as "exact" and Num as "approximate"/float

[06:30] <masak> both are real numbers

[06:31] <llfourn> m: my Numeric $bar = 3.14;

[06:31] <camelia> rakudo-moar 75ac71: ( no output )

[06:31] <masak> m: say Int ~~ Real; say Rat ~~ Real; say Num ~~ Real

[06:31] <camelia> rakudo-moar 75ac71: OUTPUT«True␤True␤True␤»

[06:31] <masak> m: my Real $bar = 3.14

[06:31] <camelia> rakudo-moar 75ac71: ( no output )

[06:31] *** CurtisOvidPoe left
[06:31] <llfourn> m; say Num ~~ Numeric; say Numeric ~~ Num;

[06:31] <llfourn> m: say Num ~~ Numeric; say Numeric ~~ Num;

[06:31] <camelia> rakudo-moar 75ac71: OUTPUT«True␤False␤»

[06:31] <xiaoyafeng> hmmm, If I wan't a parameter maybe 3, 3.0 or 3e0 what type should I say?

[06:32] <masak> "Numeric" is the topmost type. it's anything that feels like a number somehow. including complex numbers.

[06:32] <masak> m: say Complex ~~ Numeric

[06:32] <camelia> rakudo-moar 75ac71: OUTPUT«True␤»

[06:32] <masak> xiaoyafeng: I'd say Real

[06:32] <masak> xiaoyafeng: unless you know you want complex numbers, too.

[06:32] <masak> then I'd say Numeric

[06:33] <llfourn> xiaoyafeng: check out: http://docs.perl6.org/type/Numeric (the type graph down the bottom). It just taught me a lot :)

[06:34] <masak> I agree that people are frequently confused about 3.14 not being a Num.

[06:34] <masak> not so sure what to do about that; we're kind of in a local optimum where we are.

[06:35] <xiaoyafeng> Thanks!!! Please correct the wrong example on wikibooks. :)

[06:35] <masak> url?

[06:36] <llfourn> https://en.wikibooks.org/wiki/Perl_6_Programming/Variables_and_Data

[06:36] *** kmel joined
[06:36] <llfourn> xiaoyafeng: I can't see an example with Num?

[06:36] <xiaoyafeng> https://en.wikibooks.org/wiki/Perl_6_Programming/Types_and_Context

[06:37] <xiaoyafeng> We can also use the type system to catch errors as we move data between variables:

[06:37] <xiaoyafeng> my Int $foo = 5;

[06:37] <xiaoyafeng> my Num $bar = 3.14;

[06:37] <xiaoyafeng> the last few line

[06:37] <llfourn> just changed it :)

[06:37] <llfourn> (anyone can change it)

[06:38] <masak> tha powar of wikih!

[06:38] <llfourn> are we trying to maintain this wikibook?

[06:38] <llfourn> it doesn't mention Rat there...

[06:39] <xiaoyafeng> I notice the last update is on 2013

[06:40] <llfourn> well we're lucky that's the only thing wrong then I guess

[06:40] <masak> keeping tutorials up-to-date takes work :/

[06:41] <masak> the wikibook one has never been all that "core", in the sense of "maintained by people on #perl6", AFAIK

[06:41] <Hotkeys> the docs.perl6.org site is pretty good, not as tutorialy though

[06:42] <Hotkeys> just docs

[06:42] <llfourn> Hotkeys: yes -- that's probably something we need to do something about

[06:42] <xiaoyafeng> wow the type graph is very useful!!!

[06:43] *** Ven joined
[06:47] <Hotkeys> man

[06:47] <Hotkeys> before messing with perl 6 i was messing with rust

[06:48] <Hotkeys> and I can't get let <variable> out of my systemn

[06:48] <llfourn> it is strange that 3.14 is not a Num ie "number" why wasn't Num called Float?

[06:49] <llfourn> Hotkeys: is let the same as my?

[06:49] <Hotkeys> nah

[06:49] <Hotkeys> m: let @a = 1..10

[06:49] <camelia> rakudo-moar 75ac71: OUTPUT«5===SORRY!5=== Error while compiling /tmp/4Jz1PF8Zhe␤Variable '@a' is not declared␤at /tmp/4Jz1PF8Zhe:1␤------> 3let 7⏏5@a = 1..10␤»

[06:49] <Hotkeys> er

[06:49] <Hotkeys> it is in rust

[06:49] <Hotkeys> if that's what you're asking

[06:49] <llfourn> Hotkeys: yeah

[06:49] <Hotkeys> it declares a variable in scope

[06:50] <llfourn> wait we have let in p6?

[06:50] <Hotkeys> yeah

[06:50] <Hotkeys> does something else though

[06:51] <Hotkeys> similar to temp

[06:51] <llfourn> m: my $x = 'foo'; let $x = 'bar'; $x.say;

[06:51] <camelia> rakudo-moar 75ac71: OUTPUT«bar␤»

[06:51] <Hotkeys> but only restores the value if the block fails

[06:51] <llfourn> m: my $x = 'foo'; { let $x = 'bar'; fail }  $x.say;

[06:51] <camelia> rakudo-moar 75ac71: OUTPUT«5===SORRY!5=== Error while compiling /tmp/jAEP1tNPUC␤Strange text after block (missing semicolon or comma?)␤at /tmp/jAEP1tNPUC:1␤------> 3my $x = 'foo'; { let $x = 'bar'; fail }7⏏5  $x.say;␤    expecting any of:␤        infix␤        …»

[06:51] <llfourn> m: my $x = 'foo'; { let $x = 'bar'; fail };  $x.say;

[06:51] <camelia> rakudo-moar 75ac71: ( no output )

[06:52] <llfourn> m: my $x = 'foo'; { let $x = 'bar'; fail 'test'}  $x.say;

[06:52] <camelia> rakudo-moar 75ac71: OUTPUT«5===SORRY!5=== Error while compiling /tmp/SAsQmLRUW9␤Strange text after block (missing semicolon or comma?)␤at /tmp/SAsQmLRUW9:1␤------> 3 = 'foo'; { let $x = 'bar'; fail 'test'}7⏏5  $x.say;␤    expecting any of:␤        infix␤       …»

[06:52] <Hotkeys> I don't have a good example

[06:52] <llfourn> m: my $x = 'foo'; { let $x = 'bar'; fail 'test'};  $x.say;

[06:52] <camelia> rakudo-moar 75ac71: ( no output )

[06:52] <llfourn> Hotkeys: well when you think of one, http://docs.perl6.org/routine/let is begging for it :)

[06:53] <Hotkeys> yeah I know

[06:54] <llfourn> m: my $x = 'foo'; try { let $x = 'bar'; die; };  $x.say;

[06:54] <camelia> rakudo-moar 75ac71: OUTPUT«foo␤»

[06:54] * llfourn bows

[06:54] <Hotkeys> nice

[06:56] *** Ven left
[06:56] <Hotkeys> my $x = 5; try { let $x = 7; $x += 35; }; $x.say;

[06:56] <Hotkeys> er

[06:56] <Hotkeys> no

[06:56] <Hotkeys> m: my $x = 5; try { let $x = 7; $x += $n; }; $x.say;

[06:56] <camelia> rakudo-moar 75ac71: OUTPUT«5===SORRY!5=== Error while compiling /tmp/mdTQJ0dG1Y␤Variable '$n' is not declared␤at /tmp/mdTQJ0dG1Y:1␤------> 3my $x = 5; try { let $x = 7; $x += 7⏏5$n; }; $x.say;␤»

[06:56] <Hotkeys> rip

[06:57] <Hotkeys> m: my $x = 5; my $n; try { let $x = 7; $x += $n; }; $x.say;

[06:57] <camelia> rakudo-moar 75ac71: OUTPUT«Use of uninitialized value of type Any in numeric context  in block  at /tmp/YYcpZRmvmv:1␤7␤»

[06:57] <Hotkeys> I'll just stick to the simple die 

[06:57] <Hotkeys> lol

[06:58] <ShimmerFairy> m: my $a = 4; { temp $a = 5; say $a }; say $a

[06:58] <camelia> rakudo-moar 75ac71: OUTPUT«5␤4␤»

[06:59] <ShimmerFairy> 'temp' will do the "don't touch the outer scope" thing, but I forget how 'let' and 'temp' are spec'd to differ.

[06:59] <Hotkeys> ya

[06:59] <Hotkeys> let only reverts on an error according to docs

[07:00] <Hotkeys> "Like the temp listop, but only restores the value if the block exits unsuccessfully."

[07:01] <ShimmerFairy> I remember the design docs mentioning 'temp' having some temporal fiddling to it, I'll go refresh my memory :P

[07:05] *** abaugher left
[07:06] <ShimmerFairy> yeah, that's more-or-less what S04 says :) . AIUI, 'temp' is, well, temporary, and 'let' sets up a hypothetical value where leaving a block unsuccessfully says "ok, nevermind what I said about $x, _clearly_ that's not how things are supposed to go"  :)

[07:12] *** abaugher joined
[07:12] *** abaugher` joined
[07:13] *** abaugher` left
[07:13] *** abaugher left
[07:14] *** abaugher joined
[07:15] *** abaugher` joined
[07:15] *** abaugher` left
[07:15] *** abaugher left
[07:16] *** bjz joined
[07:17] *** abaugher joined
[07:17] *** bjz_ left
[07:19] *** firstdayonthejob joined
[07:21] *** rurban left
[07:23] <timotimo> o/

[07:23] <yoleaux> 02:18Z <raiph> timotimo: Looks like the architecture underlying the online perl 6 is https://alexm.github.io/writing-tutorials-for-perltuts/#/6/4

[07:23] <timotimo> i wonder if somebody wants to put a graph exploration UI widget thingie onto our doc.per6.org site

[07:24] <dalek> roast: 4ec7087 | usev6++ | S09-typed-arrays/arrays.t:

[07:24] <dalek> roast: Add tests for RT #120071 and RT #123037

[07:24] <dalek> roast: review: https://github.com/perl6/roast/commit/4ec7087158

[07:24] <synbot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=120071

[07:24] <timotimo> http://doc.perl6.org/type/Exception#Routines_supplied_by_class_Any  -  scroll up a few screenfuls to see what i'm talking about ...

[07:25] <timotimo> http://doc.perl6.org/images/type-graph-Exception.png  -  huh, this is even worse!?!

[07:28] *** Ven joined
[07:31] *** tokuhirom joined
[07:35] *** tokuhirom left
[07:38] *** skids left
[07:39] <xiaoyafeng> p6:say 3;

[07:40] <Ven> p6: say 3;

[07:40] <camelia> rakudo-moar 75ac71: OUTPUT«3␤»

[07:40] <Ven> the space matters :)

[07:40] <xiaoyafeng> p6: say 3;

[07:40] <camelia> rakudo-moar 75ac71: OUTPUT«3␤»

[07:40] <xiaoyafeng> Thanks ;)

[07:41] <moritz> \o

[07:42] <timotimo> ohai moritz

[07:43] <timotimo> m: sub do($p) { ::($p.value)($p.key) }; do :3say

[07:43] <camelia> rakudo-moar 75ac71: ( no output )

[07:43] <timotimo> m: sub do($p) { ::('&' ~ $p.value)($p.key) }; do :3say

[07:43] <camelia> rakudo-moar 75ac71: ( no output )

[07:43] <timotimo> m: sub doit($p) { ::('&' ~ $p.value)($p.key) }; doit :3say

[07:43] <camelia> rakudo-moar 75ac71: OUTPUT«Too few positionals passed; expected 1 argument but got 0␤  in sub doit at /tmp/b3XBKZLJAj:1␤  in block <unit> at /tmp/b3XBKZLJAj:1␤␤»

[07:44] *** mike` joined
[07:44] <timotimo> m: sub doit(*%kwargs) { for %kwargs.pairs -> $p { ::('&' ~ $p.value)($p.key) } }; doit :3say

[07:44] <camelia> rakudo-moar 75ac71: OUTPUT«No such symbol '&3'␤  in sub doit at /tmp/JOSraffezM:1␤  in block <unit> at /tmp/JOSraffezM:1␤␤Actually thrown at:␤  in sub doit at /tmp/JOSraffezM:1␤  in block <unit> at /tmp/JOSraffezM:1␤␤»

[07:44] <timotimo> m: sub doit(*%kwargs) { for %kwargs.pairs -> $p { ::('&' ~ $p.key)($p.value) } }; doit :3say

[07:44] <camelia> rakudo-moar 75ac71: OUTPUT«3␤»

[07:44] <timotimo> m: sub doit(*%kwargs) { for %kwargs.pairs -> $p { ::('&' ~ $p.key)($p.value) } }; doit :3say, :9say

[07:44] <camelia> rakudo-moar 75ac71: OUTPUT«9␤»

[07:44] <timotimo> ah, of course

[07:52] <Woodi> hi today :)

[07:52] <Woodi> m: say (1,1,1) Z+ (2,3,4); say (1,1,1) [Z+] (2,3,4); [Z+] (1,1,1), (2,3,4);

[07:52] <camelia> rakudo-moar 75ac71: OUTPUT«(3 4 5)␤(3 4 5)␤»

[07:53] <Woodi> looks [Z+] not doing anything here...

[07:53] <nine> .tell tadzik The answer to your question is probably import signal; signal.signal(signal.SIGINT, signal.SIG_DFL) # because Python is so user friendly

[07:53] <yoleaux> nine: I'll pass your message to tadzik.

[07:54] <Woodi> nine: woo, so many signals ;)

[07:55] <timotimo> SIG_DictatorForLife ?!?

[07:56] <timotimo> Woodi: interestingly, having [Z+] in the middle will generate the exact same AST that having it at the very beginning would

[07:56] <timotimo> and with only two arguments, there's no noticable difference between Z+ and [Z+]

[07:58] <[Tux]> test             50000    37.695    37.576

[07:58] <[Tux]> test-t           50000    38.462    38.343

[07:59] <Woodi> story is: I learned today a bit of Lisp and they bash C++ for duing Z+ in a loop. Lisp do this by constructing anonymous lambda ;)

[08:00] <Woodi> so finally I learned what Z. do in Perl 6. and that [.+] is reduce op :)

[08:02] *** CIAvash joined
[08:02] *** spider-mario joined
[08:02] <timotimo> i was wrong about the AST

[08:03] <Woodi> m: say (1,2,3) ^+ (4,5,6)

[08:03] <camelia> rakudo-moar 75ac71: OUTPUT«one((1 2 3), 3)␤»

[08:03] <Woodi> what this is doing ?

[08:03] *** SuzieQueue joined
[08:04] <timotimo> the one with [Z+] in the middle generates METAOP_ZIP(&infix:<+>, &METAOP_REDUCE_LEFT), the other calls METAOP_REDUCE_LISTINFIX(METAOP_ZIP(&infix:<+>, &METAOP_REDUCE_LEFT)) 

[08:04] <timotimo> until now i didn't even know METAOP_ZIP takes two arguments

[08:04] <moritz> Woodi: prefix:<+> on a list gives the number of elements

[08:04] <moritz> Woodi: and infix:<^> constructs a one() junction

[08:04] <timotimo> that's right, ^+ isn't one operator; you probably mean +^ instead?

[08:04] <timotimo> m: say 1023 +^ 33

[08:04] <camelia> rakudo-moar 75ac71: OUTPUT«990␤»

[08:05] <timotimo> m: say 0b110110110 +^ 0b1001001

[08:05] <camelia> rakudo-moar 75ac71: OUTPUT«511␤»

[08:05] <timotimo> m: say (0b110110110 +^ 0b1001001).base(2)

[08:05] <camelia> rakudo-moar 75ac71: OUTPUT«111111111␤»

[08:05] *** O47m341 left
[08:07] <Woodi> but  [Z+] (1,1,1), (2,3,4)  should return 12 ?

[08:09] <moritz> no

[08:09] <moritz> it reduces the two arguments with Z+

[08:10] <moritz> so it's the same as  (1, 1, 1) Z+ (2, 3, 4)

[08:10] <moritz> which again is the same as (1+2), (1+3), (1+4)

[08:10] <Woodi> [ ] do not "extends" what's inside ?

[08:11] <kmel> m: class Human {

[08:11] <kmel>   has $name;

[08:11] <kmel>   has $age;

[08:11] <kmel>   has $sex;

[08:11] <kmel>   has $nationality;

[08:11] <camelia> rakudo-moar 75ac71: OUTPUT«5===SORRY!5=== Error while compiling /tmp/sSfRwv5drB␤Missing block␤at /tmp/sSfRwv5drB:1␤------> 3class Human {7⏏5<EOL>␤»

[08:11] <kmel> }

[08:11] <kmel> my $john = Human.new('john',23,'M','American');

[08:12] <kmel> m: class Human {has $name; has $age; has $sex;has $nationality;}; my $john = Human.new('john',23,'M','American');

[08:12] <camelia> rakudo-moar 75ac71: OUTPUT«Default constructor for 'Human' only takes named arguments␤  in block <unit> at /tmp/AiTo4R9w5M:1␤␤»

[08:13] <timotimo> Woodi: it does, but you expect it to go one layer beyond what it's actually doing

[08:13] <timotimo> look at it a bit more abstractly:

[08:14] <timotimo> m: say [+] 1, 2, 3, 4

[08:14] <camelia> rakudo-moar 75ac71: OUTPUT«10␤»

[08:14] <timotimo> m: say 1 + 2 + 3 + 4

[08:14] <camelia> rakudo-moar 75ac71: OUTPUT«10␤»

[08:14] <timotimo> that's easy, right?

[08:14] <timotimo> m: say (1, 2, 3) Z+ (9, 9, 9) Z+ (1, 1, 1)

[08:14] <camelia> rakudo-moar 75ac71: OUTPUT«(11 12 13)␤»

[08:14] <timotimo> that's easy, too, right? same thing as this:

[08:14] <timotimo> m: say (1 + 9 + 1, 2 + 9 + 1, 3 + 9 + 1)

[08:14] <camelia> rakudo-moar 75ac71: OUTPUT«(11 12 13)␤»

[08:15] <timotimo> and that'sthe very samething asthis:

[08:15] <timotimo> m:say [Z+] (1,2, 3),(9,9,9), (1, 1, 1)

[08:15] <timotimo> m: say [Z+] (1,2, 3),(9,9,9), (1, 1, 1)

[08:15] <camelia> rakudo-moar 75ac71: OUTPUT«(11 12 13)␤»

[08:15] *** darutoko joined
[08:15] <timotimo> .o( do i need to get a new keyboard or justhit the keys harder?)

[08:16] <timotimo> kmel: did you have a question about that piece of code?

[08:16] <kmel> timotimo: yes

[08:16] <timotimo> m: class Human {has $name; has $age; has $sex;has $nationality;}; say Human.new(:name<John>, :23age, :sex<M>, :nationality<American>)

[08:16] <camelia> rakudo-moar 75ac71: OUTPUT«Human.new␤»

[08:17] <timotimo> m: class Human {has $name; has $age; has $sex;has $nationality;}; say Human.new(:name<John>, :23age, :sex<M>, :nationality<American>).perl

[08:17] <camelia> rakudo-moar 75ac71: OUTPUT«Human.new␤»

[08:17] <kmel> how do i write a new new method that accepts not named arguments?

[08:17] <timotimo> m: class Human {has $.name; has $.age; has $.sex;has $.nationality;}; say Human.new(:name<John>, :23age, :sex<M>, :nationality<American>).perl

[08:17] <camelia> rakudo-moar 75ac71: OUTPUT«Human.new(name => "John", age => 23, sex => "M", nationality => "American")␤»

[08:17] *** TimToady joined
[08:18] <timotimo> m: class Human {has $.name; has $.age; has $.sex;has $.nationality; multi method new ($name, $age, $sex, $nationality) { nextwith(:$name, :$sex,:$age, :$nationality) } }; say Human.new(:name<John>, :23age, :sex<M>, :nationality<American>).perl

[08:18] <camelia> rakudo-moar 75ac71: OUTPUT«Human.new(name => "John", age => 23, sex => "M", nationality => "American")␤»

[08:18] <timotimo> m: class Human {has $.name; has $.age; has $.sex;has $.nationality; multi method new ($name, $age, $sex, $nationality) { nextwith(:$name, :$sex,:$age, :$nationality) } }; say Human.new("John", 23, "M", "American").perl

[08:18] <camelia> rakudo-moar 75ac71: OUTPUT«Too few positionals passed; expected at least 2 arguments but got only 1␤  in any call_with_args at gen/moar/m-Metamodel.nqp:3620␤  in method new at /tmp/Af0frmMmom:1␤  in block <unit> at /tmp/Af0frmMmom:1␤␤»

[08:18] <timotimo> m: class Human {has $.name; has $.age; has $.sex;has $.nationality; multi method new ($name, $age, $sex, $nationality) { self.new(:$name, :$sex,:$age, :$nationality) } }; say Human.new("John", 23, "M", "American").perl

[08:18] <camelia> rakudo-moar 75ac71: OUTPUT«Human.new(name => "John", age => 23, sex => "M", nationality => "American")␤»

[08:18] <timotimo> there we go

[08:19] <kmel> timotimo: many thanks

[08:19] <timotimo> m: class Human {has $.name; has $.age; has $.sex;has $.nationality; multi method new ($name, $age, $sex, $nationality) { self.new(:$name, :$sex,:$age, :$nationality) } }; say Human.new(:name<John>, :23age, :sex<M>, :nationality<American>).perl

[08:19] <camelia> rakudo-moar 75ac71: OUTPUT«Human.new(name => "John", age => 23, sex => "M", nationality => "American")␤»

[08:19] <timotimo> ^- still compatible with named parameters

[08:19] <Woodi> timotimo: thanx. 

[08:19] <Woodi> m: say [+] [Z+] (1,2,3), (4,5,6);

[08:19] <camelia> rakudo-moar 75ac71: OUTPUT«21␤»

[08:19] <dalek> roast: e8fd9d2 | usev6++ | S02-types/pair.t:

[08:19] <dalek> roast: Unfudge passing test (for rakudo.jvm)

[08:19] <dalek> roast: review: https://github.com/perl6/roast/commit/e8fd9d2454

[08:20] * timotimo AFK for a little bit

[08:22] *** RabidGravy joined
[08:26] *** ShimmerFairy left
[08:31] *** FROGGS joined
[08:32] *** tokuhirom joined
[08:32] *** firstdayonthejob left
[08:34] *** Hor|zon left
[08:34] *** Hor|zon joined
[08:35] *** bpmedley joined
[08:36] *** rindolf joined
[08:37] *** tokuhirom left
[08:40] *** ShimmerFairy joined
[08:47] *** Ven left
[08:47] *** Ven joined
[08:48] <mrf> m: grammar G { rule TOP { <[:;]> } }; my $match = G.parse(';'); $match.perl

[08:48] <camelia> rakudo-moar 75ac71: ( no output )

[08:49] *** Ven left
[08:49] <mrf> do you need to escape characters in character classes?

[08:49] <mrf> m: grammar G { rule TOP { <[':' ';']> } }; my $match = G.parse(';'); $match.perl

[08:49] <camelia> rakudo-moar 75ac71: OUTPUT«Potential difficulties:␤    Quotes are not metacharacters in character classes␤    at /tmp/jkxc1RsIZf:1␤    ------> 3grammar G { rule TOP { <7⏏5[':' ';']> } }; my $match = G.parse(';')␤    Repeated character (') unexpectedly found in characte…»

[08:49] *** Ven joined
[08:49] <mrf> guess that answers that

[08:50] <timotimo> yeah, we try pretty hard to make error messages helpful

[08:50] *** Ven left
[08:51] *** Ven joined
[08:52] <mrf> OOI any idea why that first example didn't match?

[08:52] <timotimo> i didn't even look yet! :)

[08:52] <timotimo> m: say ";" ~~ / <[:;]> /

[08:52] <camelia> rakudo-moar 75ac71: OUTPUT«｢;｣␤»

[08:52] <timotimo> m: grammar G { rule TOP { <[:;]> } }; my $match = G.parse(';'); $match.perl.say

[08:52] <camelia> rakudo-moar 75ac71: OUTPUT«Match.new(ast => Any, list => (), hash => Map.new(), orig => ";", to => 1, from => 0)␤»

[08:53] *** Ven left
[08:53] <timotimo> what makes you say that the first example didn't match?

[08:53] <mrf> duh. Missed the .say

[08:53] *** Ven joined
[08:53] <mrf> Naturally you will have no output unless you ask for output....:(

[08:54] *** Ven left
[08:55] *** Ven joined
[08:56] <FROGGS> mrf: aye, camelia is not a REPL :o)

[08:56] <yoleaux> 23 Oct 2015 22:31Z <leont> FROGGS: it seems the syntax I was looking for was: try { EVAL q{ use Terminal::ANSIColor; &colored } } // sub ($text, $) { $text }

[08:57] <FROGGS> .tell leont why EVAL 'use' instead of require? isnt it basically the same?

[08:57] <yoleaux> FROGGS: I'll pass your message to leont.

[08:58] <nine> FROGGS: won't require die if the module could not be found?

[08:59] <FROGGS> .tell psch 'control exception without handler' is more about CX::WARN etc I think

[08:59] <yoleaux> FROGGS: I'll pass your message to psch.

[08:59] <FROGGS> star-m: try require Flubber

[08:59] <camelia> star-m 2015.09: ( no output )

[08:59] <FROGGS> nine: dont think so

[08:59] <leont> FROGGS: no idea. I came across is and it worked

[08:59] <yoleaux> 08:57Z <FROGGS> leont: why EVAL 'use' instead of require? isnt it basically the same?

[09:00] <timotimo> the thing about EVAL is that it fires up a whole compiler :P

[09:00] <FROGGS> leont: yes, though when you think about it, require kinde is a EVAL 'use'

[09:00] <leont> Unlike the other one, that failed as soon as you tried it inside a module { }

[09:00] <FROGGS> kinda*

[09:00] <FROGGS> eww

[09:01] <FROGGS> star-m: module Foo { my $x = try { require Terminal::WTF8Color <&colored> } // sub { } }

[09:01] <camelia> star-m 2015.09: ( no output )

[09:02] <FROGGS> star-m: module Foo { my $x = try { require Terminal::WTF8Color <&colored> } // sub { }; say $x }

[09:02] <camelia> star-m 2015.09: OUTPUT«sub () { #`(Sub|82437368) ... }␤»

[09:02] <FROGGS> star-m: module Foo { my $x = try { require Terminal::WTF8Color <&colored> } // sub { 42 }; say $x() }

[09:02] <camelia> star-m 2015.09: OUTPUT«42␤»

[09:02] <FROGGS> leont: can you give us an example that misbehaves and potentially ticket it?

[09:04] <lizmat> m: say Mu === Any

[09:04] <camelia> rakudo-moar 75ac71: OUTPUT«Cannot call infix:<===>(Mu, Any); none of these signatures match:␤    ($?)␤    ($a, $b)␤    (Int:D \a, Int:D \b)␤    (int $a, int $b)␤    (Num:D \a, Num:D \b)␤    (Num $ where { ... }, Num $ where { ... })␤    (num $a, num $b --> Bool:D)␤  …»

[09:05] <leont> m: my &colored = try { require Terminal::ANSIColor <&colored>; &colored } // sub ($, $) { "fail" }; say colored("Success", "green")

[09:05] <camelia> rakudo-moar 75ac71: OUTPUT«fail␤»

[09:05] <leont> star-m: my &colored = try { require Terminal::ANSIColor <&colored>; &colored } // sub ($, $) { "fail" }; say colored("Success", "green")

[09:05] <camelia> star-m 2015.09: OUTPUT«3Success␤»

[09:05] <leont> star-m: module{ my &colored = try { require Terminal::ANSIColor <&colored>; &colored } // sub ($, $) { "fail" }; say colored("Success", "green") }

[09:05] <camelia> star-m 2015.09: OUTPUT«5===SORRY!5=== Error while compiling /tmp/cfnszx5Oxw␤Whitespace required after keyword 'module'␤at /tmp/cfnszx5Oxw:1␤------> 3module7⏏5{ my &colored = try { require Terminal::␤»

[09:05] <leont> star-m: module Foo { my &colored = try { require Terminal::ANSIColor <&colored>; &colored } // sub ($, $) { "fail" }; say colored("Success", "green") }

[09:05] <camelia> star-m 2015.09: OUTPUT«fail␤»

[09:06] <leont> star-m: module Foo { my &colored2 = try { require Terminal::ANSIColor <&colored>; &colored } // sub ($, $) { "fail" }; say colored2("Success", "green") }

[09:06] <camelia> star-m 2015.09: OUTPUT«fail␤»

[09:06] <leont> star-m: my &colored2 = try { require Terminal::ANSIColor <&colored>; &colored } // sub ($, $) { "fail" }; say colored2("Success", "green")

[09:06] <camelia> star-m 2015.09: OUTPUT«3Success␤»

[09:06] <leont> Hmm, I though that failed too, but first fail/success was my main point

[09:06] <timotimo> that's interesting indeed

[09:07] <timotimo> why would a module { } around it even make a difference, since the require is inside its own { } anyway?

[09:08] <dalek> rakudo/curli: b3918c4 | (Stefan Seifert)++ | / (5 files):

[09:08] <dalek> rakudo/curli: Some bits of CompUnit::PrecompilationStore

[09:08] <dalek> rakudo/curli: review: https://github.com/rakudo/rakudo/commit/b3918c4cac

[09:08] <FROGGS> star-m: module Foo { my &colored = try { require Terminal::ANSIColor <&colored>; &colored } }; say &colored }

[09:08] <camelia> star-m 2015.09: OUTPUT«5===SORRY!5=== Error while compiling /tmp/45GQ5QXCcB␤Unexpected closing bracket␤at /tmp/45GQ5QXCcB:1␤------> 3 <&colored>; &colored } }; say &colored 7⏏5}␤»

[09:08] <FROGGS> star-m: module Foo { my &colored = try { require Terminal::ANSIColor <&colored>; &colored }; say &colored }

[09:08] <camelia> star-m 2015.09: OUTPUT«(Callable)␤»

[09:09] <FROGGS> star-m: module Foo { my &colored = try { require Terminal::ANSIColor <&colored>; &colored } // 42; say &colored }

[09:09] <camelia> star-m 2015.09: OUTPUT«Type check failed in assignment to '&colored'; expected 'Callable' but got 'Int'␤  in block <unit> at /tmp/KHYkjz6qUF:1␤␤»

[09:09] <FROGGS> star-m: module Foo { my &colored = try { require Terminal::ANSIColor <&colored>; &colored }; say colored("Success", "green") }

[09:09] <camelia> star-m 2015.09: OUTPUT«Cannot invoke this object␤  in block <unit> at /tmp/tTpd3bbieg:1␤␤»

[09:10] <FROGGS> star-m: module Foo { my &colored = try { say 1; require Terminal::ANSIColor <&colored>; say 1; &colored }; say &colored }

[09:10] <camelia> star-m 2015.09: OUTPUT«1␤(Callable)␤»

[09:10] <dalek> Heuristic branch merge: pushed 40 commits to rakudo/curli by niner

[09:10] <FROGGS> star-m: module Foo { my &colored = try { say 1; require Terminal::ANSIColor <&colored>; say 1; &colored; CATCH { default { .say } } }; say &colored }

[09:10] <camelia> star-m 2015.09: OUTPUT«1␤Trying to import symbols &colored from 'Terminal::ANSIColor', but it does not export anything␤  in block  at /tmp/wDtw_BLd82:1␤  in block <unit> at /tmp/wDtw_BLd82:1␤␤(Callable)␤»

[09:10] <timotimo> hum

[09:11] <timotimo> perhaps it really tries to grab Foo::Terminal::ANSIColor?

[09:11] <FROGGS> leont: so we are unable to import from it for some weird reason

[09:11] <timotimo> star-m: module Terminal { my &clored = try { say 1; require ANSIColor <&colored>; say 2; &colored }; say &clored

[09:11] <camelia> star-m 2015.09: OUTPUT«5===SORRY!5=== Error while compiling /tmp/g6Qw2N7TeG␤Missing block␤at /tmp/g6Qw2N7TeG:1␤------> 3colored>; say 2; &colored }; say &clored7⏏5<EOL>␤    expecting any of:␤        postfix␤        statement end␤        statement modifier␤ …»

[09:11] <timotimo> star-m: module Terminal { my &clored = try { say 1; require ANSIColor <&colored>; say 2; &colored }; }; say &clored

[09:11] <camelia> star-m 2015.09: OUTPUT«5===SORRY!5=== Error while compiling /tmp/IpWH6hcFES␤Undeclared routine:␤    &clored used at line 1. Did you mean '&close'?␤␤»

[09:11] <timotimo> star-m: module Terminal { my &clored = try { say 1; require ANSIColor <&colored>; say 2; &colored }; say &clored; }

[09:11] <camelia> star-m 2015.09: OUTPUT«1␤(Callable)␤»

[09:12] <timotimo> star-m: module Terminal { my &clored = try { say 1; require ANSIColor <&colored>; say 2; &colored; CATCH { .say } }; say &clored; }

[09:12] <camelia> star-m 2015.09: OUTPUT«1␤Could not find ANSIColor in any of:␤  file#/home/camelia/.perl6/2015.09/lib␤  inst#/home/camelia/.perl6/2015.09␤  file#/home/camelia/star-2015.09/share/perl6/lib␤  file#/home/camelia/star-2015.09/share/perl6/vendor/lib␤  file#/home/camelia/star-2…»

[09:12] <timotimo> star-m: module Terminal { my &clored = try { say 1; require Term::ANSIColor <&colored>; say 2; &colored; CATCH { .say } }; say &clored; }

[09:12] <camelia> star-m 2015.09: OUTPUT«1␤Could not find Term::ANSIColor in any of:␤  file#/home/camelia/.perl6/2015.09/lib␤  inst#/home/camelia/.perl6/2015.09␤  file#/home/camelia/star-2015.09/share/perl6/lib␤  file#/home/camelia/star-2015.09/share/perl6/vendor/lib␤  file#/home/camelia/…»

[09:12] <timotimo> oh derp

[09:12] <timotimo> star-m: module Terminal { my &clored = try { say 1; require Terminal::ANSIColor <&colored>; say 2; &colored; CATCH { .say } }; say &clored; }

[09:12] <camelia> star-m 2015.09: OUTPUT«1␤Trying to import symbols &colored from 'Terminal::ANSIColor', but it does not export anything␤  in block  at /tmp/9u_ufe8fhs:1␤  in block <unit> at /tmp/9u_ufe8fhs:1␤␤Trying to import symbols &colored from 'Terminal::ANSIColor', but it does not exp…»

[09:12] <timotimo> star-m: module Terminal { my &clored = try { say 1; require Terminal::ANSIColor; say 2; &colored; CATCH { .say } }; say &clored; }

[09:12] <camelia> star-m 2015.09: OUTPUT«5===SORRY!5=== Error while compiling /tmp/YFOJbab8ST␤Undeclared routine:␤    &colored used at line 1␤␤»

[09:12] <timotimo> star-m: module Terminal { my &clored = try { say 1; require Terminal::ANSIColor; say 2; say ::.keys; CATCH { .say } }; say &clored; }

[09:12] <camelia> star-m 2015.09: OUTPUT«1␤2␤($_ __HANDLER__1)␤(Callable)␤»

[09:13] <FROGGS> bbl &

[09:13] <timotimo> star-m: module Terminal { my &clored = try { say 1; require Terminal::ANSIColor; say 2; say GLOBAL::.keys; CATCH { .say } }; say &clored; }

[09:13] <camelia> star-m 2015.09: OUTPUT«1␤2␤(Terminal)␤(Callable)␤»

[09:13] <timotimo> star-m: module Terminal { my &clored = try { say 1; require Terminal::ANSIColor; say 2; say GLOBAL::Terminal:.keys }; say &clored; }

[09:13] <camelia> star-m 2015.09: OUTPUT«5===SORRY!5=== Error while compiling /tmp/g7m_EcGMq5␤Confused␤at /tmp/g7m_EcGMq5:1␤------> 3:ANSIColor; say 2; say GLOBAL::Terminal:7⏏5.keys }; say &clored; }␤    expecting any of:␤        colon pair␤»

[09:13] <timotimo> star-m: module Terminal { my &clored = try { say 1; require Terminal::ANSIColor; say 2; say GLOBAL::Terminal::.keys }; say &clored; }

[09:13] <camelia> star-m 2015.09: OUTPUT«1␤2␤(ANSIColor)␤Type check failed in assignment to '&clored'; expected 'Callable' but got 'Bool'␤  in block <unit> at /tmp/6mKCxHnDpp:1␤␤»

[09:13] <timotimo> star-m: module Terminal { my &clored = try { say 1; require Terminal::ANSIColor; say 2; say GLOBAL::Terminal::ANSIColor::.keys }; say &clored; }

[09:13] <camelia> star-m 2015.09: OUTPUT«1␤2␤(EXPORT)␤Type check failed in assignment to '&clored'; expected 'Callable' but got 'Bool'␤  in block <unit> at /tmp/exetbPKBd0:1␤␤»

[09:13] <timotimo> star-m: module Terminal { my &clored = try { say 1; require Terminal::ANSIColor; say 2; say GLOBAL::Terminal::ANSIColor::EXPORT::.keys }; say &clored; }

[09:13] <camelia> star-m 2015.09: OUTPUT«1␤2␤(DEFAULT ALL)␤Type check failed in assignment to '&clored'; expected 'Callable' but got 'Bool'␤  in block <unit> at /tmp/NciOd4sWsU:1␤␤»

[09:13] <timotimo> star-m: module Terminal { my &clored = try { say 1; require Terminal::ANSIColor; say 2; say GLOBAL::Terminal::ANSIColor::EXPORT::ALL::.keys }; say &clored; }

[09:13] <camelia> star-m 2015.09: OUTPUT«1␤2␤(&RESET &BOLD_OFF &UNDERLINE_OFF &UNDERLINE &uncolor &color &colored &colorstrip &BOLD &INVERSE &INVERSE_OFF &colorvalid)␤Type check failed in assignment to '&clored'; expected 'Callable' but got 'Bool'␤  in block <unit> at /tmp/nHBxFpLQP7:1␤␤»

[09:13] <timotimo> star-m: module Terminal { my &clored = try { say 1; require Terminal::ANSIColor; say 2; GLOBAL::Terminal::ANSIColor::EXPORT::ALL::colored }; say &clored; }

[09:13] <camelia> star-m 2015.09: OUTPUT«1␤2␤(Callable)␤»

[09:14] <timotimo> star-m: module Terminal { my &clored = try { say 1; require Terminal::ANSIColor; say 2; GLOBAL::Terminal::ANSIColor::EXPORT::ALL::colored }; clored("fo", "bar") }

[09:14] <camelia> star-m 2015.09: OUTPUT«1␤2␤Cannot invoke this object␤  in block <unit> at /tmp/ZNMNtHxZkP:1␤␤»

[09:14] <timotimo> interesting

[09:14] *** iH2O joined
[09:14] <timotimo> star-m: module Terminal { my &clored = try { say 1; require Terminal::ANSIColor; say 2; GLOBAL::Terminal::ANSIColor::EXPORT::ALL::colored("foo", "bar") };}

[09:14] <camelia> star-m 2015.09: OUTPUT«1␤2␤»

[09:14] <timotimo> star-m: module Terminal { my &clored = try { say 1; require Terminal::ANSIColor; say 2; GLOBAL::Terminal::ANSIColor::EXPORT::ALL::colored("foo", "bar").say };}

[09:14] <camelia> star-m 2015.09: OUTPUT«1␤2␤»

[09:14] <timotimo> star-m: module Terminal { my &clored = try { say 1; require Terminal::ANSIColor; say 2; &GLOBAL::Terminal::ANSIColor::EXPORT::ALL::colored }; say clored("foo", "bar")}

[09:14] <camelia> star-m 2015.09: OUTPUT«1␤2␤Invalid attribute name 'bar'␤  in sub color at /home/camelia/star-2015.09/share/perl6/lib/Terminal/ANSIColor.pm:45␤  in sub colored at /home/camelia/star-2015.09/share/perl6/lib/Terminal/ANSIColor.pm:51␤  in block <unit> at /tmp/WppoXrATXs:1␤␤»

[09:15] <timotimo> star-m: module Test { my &clored = try { say 1; require Terminal::ANSIColor; say 2; &GLOBAL::Terminal::ANSIColor::EXPORT::ALL::colored }; say clored("foo", "bar")}

[09:15] <camelia> star-m 2015.09: OUTPUT«1␤2␤Invalid attribute name 'bar'␤  in sub color at /home/camelia/star-2015.09/share/perl6/lib/Terminal/ANSIColor.pm:45␤  in sub colored at /home/camelia/star-2015.09/share/perl6/lib/Terminal/ANSIColor.pm:51␤  in block <unit> at /tmp/CVisnqB2ik:1␤␤»

[09:15] <timotimo> star-m: module Test { my &clored = try { say 1; require Terminal::ANSIColor <&colored>; say 2; &GLOBAL::Terminal::ANSIColor::EXPORT::ALL::colored eqv &colored }; say clored("foo", "bar")}

[09:15] <camelia> star-m 2015.09: OUTPUT«1␤Cannot invoke this object␤  in block <unit> at /tmp/T3OZncUEii:1␤␤»

[09:16] *** iH2O left
[09:17] <timotimo> okay, so here's a little look at what this code does internally

[09:18] <timotimo> also, a few short lines to give a visual differentiation between all the spam above there and what's coming up

[09:18] <timotimo> short

[09:18] <timotimo> short 2

[09:18] <timotimo> short 3

[09:18] <timotimo> ===========================

[09:18] <timotimo> what require does under the hood:

[09:18] <timotimo> m: sub testsub() { say CALLER::OUR::.keys }; testsub()

[09:18] <camelia> rakudo-moar 75ac71: OUTPUT«()␤»

[09:18] <timotimo> m: sub testsub() { say CALLER::OUR::.keys }; module Foo { testsub() }

[09:18] <camelia> rakudo-moar 75ac71: OUTPUT«()␤»

[09:20] *** pmurias joined
[09:20] <timotimo> seems like the load_module method of CUR (the first thing a require statement translates to) puts things into GLOBALish (getcurhllsym("GLOBAL"))

[09:21] <timotimo> and then REQUIRE_IMPORT looks in CALLER::OUR::.WHO

[09:21] *** rindolf left
[09:22] <timotimo> so perhaps that's where the mismatch happens?

[09:22] *** Ven left
[09:25] * timotimo is really not deep in the whole package/namespace/importation/... business

[09:27] *** iH2O joined
[09:30] *** Psyche^_ joined
[09:31] *** rindolf joined
[09:33] *** Psyche^ left
[09:38] *** leont left
[09:39] *** Ven joined
[09:39] <Ven> what a busy morning :)

[09:41] <timotimo> sorry about that

[09:41] *** simcop2387 left
[09:44] *** rindolf left
[09:44] <dalek> rakudo/curli: cf4233a | (Stefan Seifert)++ | src/core/ (5 files):

[09:44] <dalek> rakudo/curli: Set up the whole chain of CompUnit::Repositorys

[09:44] <dalek> rakudo/curli: 

[09:44] <dalek> rakudo/curli: $*REPO is now the HEAD of the whole list of repositories.

[09:44] <dalek> rakudo/curli: review: https://github.com/rakudo/rakudo/commit/cf4233a2a6

[09:47] *** iH2O left
[09:49] <FROGGS> nine++

[09:50] <timotimo> more jokes about "ten"!

[09:52] <lizmat> if we're going to look at io, I think $!ins is a fossil

[09:53] <timotimo> is "ins" supposed to just be the plural of "in"?

[09:53] <lizmat> now that we have fast .kv methods, I don't think we need the overhead of updating $!ins all of the time

[09:53] <lizmat> no, it's the number of lines read on a handle

[09:53] <timotimo> sorry, i was refering to the name only

[09:54] <timotimo> whether it's just "the number of in'd things" or "Input Number of Separators" or something

[09:55] <lizmat> I have no idea, I didn't come up with the name

[09:55] <timotimo> we have an "outs" variant of that, too, don't we?

[09:55] *** virtualsue joined
[10:00] *** simcop2387 joined
[10:08] *** firstdayonthejob joined
[10:09] <baest> How do you async reads from $*IN? If I put it in a thread I get "Unhandled exception: Tried to read() on a socket from outside its originating thread"

[10:10] *** kid51 joined
[10:10] *** sqirrel joined
[10:10] <timotimo> aye, that's currently problematic; you can work around it by starting the digestion thread and sending lines from $*IN through a Channel to it

[10:11] <baest> timotimo: ah yeah, I was thinking that it was NYI. Thanks

[10:11] <baest> timotimo: How would I do the channel thing?

[10:13] <timotimo> on the other hand .. why is it giving that error for $*IN?

[10:13] *** firstdayonthejob left
[10:13] <timotimo> i know we've run into some limitations with libuv when it comes to sockets, but i think the std handles are sufficiently un-socket-like for this purpose

[10:14] *** firstdayonthejob joined
[10:14] <timotimo> hoelzro: care to comment on this? why did you put the same check you've put into syncsocket.c into syncstream.c as well?

[10:22] *** sqirrel left
[10:22] *** kmel left
[10:29] <dalek> roast: 25daf16 | usev6++ | S12-attributes/clone.t:

[10:29] <dalek> roast: Add tests for RT #125109

[10:29] <dalek> roast: review: https://github.com/perl6/roast/commit/25daf16f55

[10:29] <synbot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=125109

[10:29] *** Ven left
[10:34] *** tokuhirom joined
[10:35] <lizmat> timotimo: no "outs" variant that I know of

[10:35] *** aborazmeh left
[10:36] <dalek> rakudo/nom: 6b8da28 | lizmat++ | src/core/IO/Handle.pm:

[10:36] <dalek> rakudo/nom: Remove fossil

[10:36] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/6b8da28eef

[10:38] *** tokuhirom left
[10:42] *** rindolf joined
[10:43] *** virtualsue left
[10:44] <dalek> rakudo/nom: 77eb4c2 | lizmat++ | src/core/IO/Handle.pm:

[10:44] <dalek> rakudo/nom: Prevent warnings

[10:44] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/77eb4c2983

[10:48] <timotimo> OK

[10:54] <dalek> rakudo/nom: cd77669 | lizmat++ | src/core/ (2 files):

[10:54] <dalek> rakudo/nom: Move method comb prototype

[10:54] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/cd77669d09

[10:55] <dalek> roast: 837d940 | lizmat++ | S16-io/words.t:

[10:55] <dalek> roast: Remove paranoid test

[10:55] <dalek> roast: review: https://github.com/perl6/roast/commit/837d940d19

[10:56] <timotimo> yay, booting into a new kernel

[10:58] <timotimo> wow, what an upgrade

[11:00] *** cfloare left
[11:00] *** rindolf left
[11:01] *** cfloare joined
[11:04] *** CIAvash left
[11:04] <RabidGravy> Off out for a bit, that's enough travis-ci for the time being

[11:06] *** AlexDaniel joined
[11:08] *** RabidGravy left
[11:11] *** ^elyse^ joined
[11:12] *** ^elyse^ left
[11:12] *** BenGoldberg joined
[11:14] <timotimo> it seems like i can't build nqp-j on my laptop at the mment

[11:15] <timotimo> m: my int @foo; @foo.push: 1; say @foo

[11:15] <camelia> rakudo-moar 6b8da2: OUTPUT«1␤»

[11:15] <timotimo> m: my int @foo; @foo.unshift: 1; say @foo

[11:15] <camelia> rakudo-moar 6b8da2: OUTPUT«1␤»

[11:15] <timotimo> m: my CArray[int] $foo; $foo.push: 1; say $foo

[11:15] <camelia> rakudo-moar 6b8da2: OUTPUT«5===SORRY!5===␤Type 'CArray' is not declared. Did you mean any of these?␤    Array␤    array␤␤at /tmp/ba26jWiJdE:1␤------> 3my CArray7⏏5[int] $foo; $foo.push: 1; say $foo␤Malformed my␤at /tmp/ba26jWiJdE:1␤------> 3my7⏏5 CAr…»

[11:15] <timotimo> m: use NativeCall; my CArray[int] $foo; $foo.push: 1; say $foo

[11:15] <camelia> rakudo-moar 6b8da2: OUTPUT«Cannot call push(IntTypedCArray[int]: Int); none of these signatures match:␤    (Any:U \SELF: |values is raw)␤  in block <unit> at /tmp/dn8BSM0AwI:1␤␤»

[11:16] *** TEttinger left
[11:16] <timotimo> hm, at some point i was working on CArray and push and elems and such ... problem is it can potentially be refering to an array we don't know the size of

[11:16] <timotimo> or something like that?

[11:16] *** firstdayonthejob left
[11:18] * lizmat tries to build on JVM

[11:18] <hoelzro> timotimo: regarding sockets, you can't read from a socket on thread B if thread A created that socket and A !=:= B

[11:18] <timotimo> getting an assortment of different problems

[11:18] <timotimo> hoelzro: i know about that part

[11:19] <timotimo> hoelzro: how come that error also appears for $*IN?

[11:19] <hoelzro> iirc, it suffers from the same problem

[11:19] <timotimo> god fucking damnit

[11:20] <lizmat> bless you!

[11:20] <hoelzro> yeah, it's annoying

[11:20] <hoelzro> hang on, lemme dig up the libuv thread

[11:21] <hoelzro> https://groups.google.com/forum/#!topic/libuv/bOOTAS2zV_U

[11:21] <hoelzro> the idea behind the error was that it's better for a user to see "you can't do this right now", rather than always silently get 0 size reads

[11:22] <timotimo> wellllll, we want to replace libuv stuff with direct stdIO stuff for synchronous stuff anyway

[11:24] <timotimo> this just fuels the fire a bit more

[11:24] <timotimo> just like tadzik's decision to remove precompilation from panda ;)

[11:24] <hoelzro> see also https://github.com/MoarVM/MoarVM/issues/165

[11:24] <dalek> rakudo/curli: 9e8ffaa | (Stefan Seifert)++ | src/core/CompUnitRepo/Local/Installation.pm:

[11:24] <dalek> rakudo/curli: Fix next-repo initialization in CompUnitRepo::Local::Installation

[11:24] <dalek> rakudo/curli: review: https://github.com/rakudo/rakudo/commit/9e8ffaadec

[11:24] <dalek> rakudo/curli: 278913e | (Stefan Seifert)++ | src/core/CompUnit (2 files):

[11:24] <dalek> rakudo/curli: Delegate to next-repo if we find no candiate for a module

[11:24] <dalek> rakudo/curli: review: https://github.com/rakudo/rakudo/commit/278913ec6a

[11:25] <nine> And with that I'm off to give some flight lessons :)

[11:25] <timotimo> \o/

[11:25] <timotimo> thank you for your work on this, nine 

[11:25] <hoelzro> timotimo: oh, really? this is the first I'm hearing of that, but I'd be lying if I said I'd miss libuv

[11:25] <lizmat> nine++

[11:25] <hoelzro> nine: enjoy!

[11:25] <timotimo> we'll keep libuv for asynchronous I/O of course

[11:26] <hoelzro> yeah

[11:26] <timotimo> we always explicitly do our async I/O on that one single "for async I/O" thread anyway

[11:26] <hoelzro> true, so there's no need to worry about this bug there

[11:26] <timotimo> in that case, that thread can (probably already does) own all the things

[11:27] <hoelzro> (since it's the uv_loop_t that's really the problem, not threads)

[11:27] <hoelzro> yes

[11:27] *** tokuhirom joined
[11:29] <timotimo> does htmlify use Inline::Python for pygments at the moment?

[11:30] <tadzik> nine: yay, that worked!

[11:30] <yoleaux> 07:53Z <nine> tadzik: The answer to your question is probably import signal; signal.signal(signal.SIGINT, signal.SIG_DFL) # because Python is so user friendly

[11:31] <hoelzro> I thought it did, but I haven't checked in a while

[11:31] *** BenGoldberg left
[11:31] <ShimmerFairy> tadzik: by chance were you trying to use any signals? :)

[11:32] <tadzik> ShimmerFairy: yes indeed :)

[11:32] <timotimo> oh hey tadzik 

[11:32] <tadzik> I mean, I was not

[11:32] *** tokuhiro_ joined
[11:32] <tadzik> but I have a Perl code that uses Inline::Python

[11:32] <lizmat> just control-C perhaps ?

[11:32] <tadzik> and when it does, Python captures SIGINT

[11:32] <timotimo> you're missing from a certain perl6 off-topic channel :)

[11:32] *** tokuhirom left
[11:32] <tadzik> and I can't ^C out of it

[11:32] <tadzik> timotimo: oh, correct!

[11:36] <timotimo> tadzik: do you know what the current state of the qt profiler viewer is?

[11:36] <tadzik> timotimo: I haven't touched it since the QA hackathon

[11:36] *** tokuhiro_ left
[11:36] <timotimo> OK

[11:36] <tadzik> I think sergot_ might have though

[11:36] *** Ven joined
[11:36] <tadzik> I was thinking to try moritz's profile file on it

[11:37] *** lucs left
[11:38] <timotimo> yeah, i'm on the way to do that right now

[11:39] *** lucs joined
[11:40] <timotimo> ah, yeah, "malformed input file"

[11:40] <timotimo> maybe we ought to move from QJSON to a different thing

[11:40] <timotimo> QJsonDocument – "document too large" (looks like the max size is artificially capped at 1 << 27 bytes)

[11:40] <timotimo> Boost.PropertyTree – takes up 30 GB RAM and then segfaults

[11:40] <timotimo> libjson – takes up a few gigs of RAM and then segfaults

[11:40] <timotimo> that looks so promising!

[11:42] <timotimo> maybe i should just throw the json file into an ad-hoc postgres database and use its json operators on it for some analysis %)

[11:43] <timotimo> maybe a good first step would be to figure out which parts of that document are how big and such

[11:48] * timotimo tries to use json_pp on it to be able to see its structure

[11:52] <timotimo> hmm. json_pp is chewing CPU time, but apparently not memory ... and the result file is still empty

[11:54] <hoelzro> timotimo: how big is this JSON file?

[11:55] <timotimo> just a hundred megs

[11:56] <hoelzro> ok, so not huge, really

[11:56] <hoelzro> interesting

[12:00] *** Ven left
[12:05] *** Ven joined
[12:05] <timotimo> ah, json_pp is very, very, very slowly using more ram

[12:21] <dalek> rakudo/nom: e8d7577 | lizmat++ | src/core/ (4 files):

[12:21] <dalek> rakudo/nom: Introduce IO::Path/Handle.comb

[12:21] <dalek> rakudo/nom: 

[12:21] <dalek> rakudo/nom: You can comb for:

[12:21] <dalek> rakudo/nom: - all characters (.comb or .comb(""))

[12:21] <dalek> rakudo/nom: - strings (.comb("foo"))

[12:21] <dalek> rakudo/nom: - blocks of characters (.comb(1024))

[12:21] <dalek> rakudo/nom: - regexes (.comb(/.e./)

[12:21] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/e8d7577b66

[12:21] *** telex left
[12:21] *** kmel joined
[12:22] *** telex joined
[12:23] <moritz> lizmat: same feedback as with .split; I don't like it on IO::Path, because that's a rather stringy type for me

[12:24] <lizmat> same question as before: how would you call it then ?

[12:24] <moritz> .IO.comb

[12:24] <lizmat> FWIW, I tried several hours to rename it yesterday

[12:25] <lizmat> then .IO should not give an IO::Path

[12:25] <lizmat> it's on IO::Path *because* I want .IO.comb to work!

[12:25] <lizmat> m: dd "foo".IO

[12:25] <camelia> rakudo-moar cd7766: OUTPUT«IO::Path $var = q|foo|.IO(:SPEC(IO::Spec::Unix),:CWD</home/camelia>)␤»

[12:25] <moritz> lizmat: I think I lost the handle on the distinction between IO::Path and IO::Handle

[12:26] <lizmat> well, it's a mess

[12:26] <lizmat> and what I tried to fix with newio

[12:26] <lizmat> :-(

[12:26] <lizmat> atm, .IO gives an IO::Path, and that has an .open method

[12:27] <lizmat> which returns an IO::Handle

[12:27] <lizmat> however, you can also do IO::Handle.new

[12:27] <lizmat> which gives you an unopened IO::Handle

[12:27] <lizmat> very useful and consistent  :-(

[12:27] <pink_mist> $*IN and $*OUT, they're IO::Handles right? not IO::Paths?

[12:27] <lizmat> IO::Handle's yes

[12:28] <lizmat> m: dd $*IN

[12:28] <camelia> rakudo-moar cd7766: OUTPUT«IO::Handle $var = IO::Handle.new(path => IO::Special.new(what => "<STDIN>"), ins => 0, chomp => Bool::True)␤»

[12:28] <pink_mist> ah, nice

[12:28] <lizmat> so yes, you can .split and .comb on $*IN

[12:28] *** pmurias left
[12:28] *** tokuhirom joined
[12:28] *** Ven left
[12:28] *** pefpefpef joined
[12:29] <lizmat> m: dd $*IN.split("")

[12:29] <camelia> rakudo-moar cd7766: OUTPUT«Seq $var = ("", "C", "é", "a", "d", " ", "s", "l", "á", "n", " ", "a", "g", " ", "s", "l", "é", "i", "b", "h", "t", "e", " ", "m", "a", "o", "r", "g", "a", " ", "C", "h", "o", "n", "t", "a", "e", " ", "D", "h", "ú", "n", " ", "n", "a", " ", "n", "G", "…»

[12:29] <pink_mist> wut

[12:29] <lizmat> m: dd $*IN.say

[12:29] <camelia> rakudo-moar cd7766: OUTPUT«Failed to write bytes to filehandle: bad file descriptor␤  in block <unit> at /tmp/oOquwjUHoJ:1␤␤»

[12:29] <pink_mist> that looked like irish

[12:29] <lizmat> m: dd $*IN.lines[0].say

[12:29] <camelia> rakudo-moar cd7766: OUTPUT«Céad slán ag sléibhte maorga Chontae Dhún na nGall␤Bool $var = Bool::True␤»

[12:29] <pink_mist> or possibly welsh

[12:30] *** pefpefpef left
[12:30] <lizmat> moritz knows

[12:31] *** ^elyse^ joined
[12:32] *** telex left
[12:32] <lizmat> perhaps .IO should just return an IO object

[12:32] *** xfix joined
[12:32] <lizmat> it would at least make sense from coercer consistency point of view

[12:32] <lizmat> brb

[12:32] *** telex joined
[12:32] *** tokuhirom left
[12:34] *** Ven joined
[12:35] <ilmari> Irish, according to google translate

[12:36] <ilmari> "Farewell to the noble mountains of Donegal"

[12:39] *** patrickz joined
[12:39] *** telex left
[12:40] *** ^elyse^ left
[12:43] <flussence> wait, is .IO.comb(1024) a lazy-list version of the perl5 «stuff while $fh->read(my $buf, 1024)»? ’cause that'd be awesome.

[12:43] *** ^elyse^ joined
[12:45] *** telex joined
[12:46] <flussence> m: $*IN.comb(8)[^5].perl.say

[12:46] <camelia> rakudo-moar cd7766: OUTPUT«Use of uninitialized value of type Any in string context␤Any of .^name, .perl, .gist, or .say can stringify undefined things, if needed.  in block <unit> at /tmp/ySA8WoKQX5:1␤Cannot call comb(IO::Handle, Int); none of these signatures match:␤  in blo…»

[12:49] <lizmat> flussence: yeah, that would be it

[12:49] <flussence> lizmat++ # those mandatory tempvars always bothered me :)

[12:49] <lizmat> also need to wait for camelia to catch up

[12:51] <lizmat> hmmm.. I suddenly realize .comb(size) can be made simpler

[12:51] <lizmat> duh

[12:54] <flussence> aww, it doesn't work on binary files :(

[12:56] * pink_mist will always think of the ^5 notation as 'high-five'

[12:56] <pink_mist> (it falls apart a bit when the number isn't 5, but that's irrelevant :P)

[12:58] *** telex left
[12:58] *** telex joined
[12:59] *** Ven left
[13:00] *** firstdayonthejob joined
[13:05] *** telex left
[13:06] *** kmel left
[13:07] <psch> .botsnack

[13:07] <yoleaux> :D

[13:07] <synbot6> om nom nom

[13:07] <yoleaux> 08:59Z <FROGGS> psch: 'control exception without handler' is more about CX::WARN etc I think

[13:08] <psch> .tell FROGGS yeah, they are.  'control exception without handler' is the new "Unknown control exception type %d"

[13:08] <yoleaux> psch: I'll pass your message to FROGGS.

[13:10] <psch> .tell FROGGS apparently Exception.print_control doesn't deal correctly with compound control exception, e.g. 4104 is redo_label, but print_control only does == nqp::const::CONTROL_*, nothing bitwise

[13:10] <yoleaux> psch: I'll pass your message to FROGGS.

[13:10] *** telex joined
[13:10] <dalek> rakudo/nom: 2f4bfd8 | lizmat++ | src/core/IO/Handle.pm:

[13:10] <dalek> rakudo/nom: Implement .comb(size) lazier

[13:10] <dalek> rakudo/nom: 

[13:10] <dalek> rakudo/nom: flussence++ for inspiration

[13:10] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/2f4bfd89d6

[13:10] <psch> .tell FROGGS of course, those probably still shouldn't arrive there in the first place but properly control...

[13:10] <yoleaux> psch: I'll pass your message to FROGGS.

[13:10] <lizmat> cycling&

[13:19] *** bpmedley left
[13:19] *** rindolf joined
[13:22] *** telex left
[13:22] *** raiph joined
[13:24] *** telex joined
[13:24] *** Ven joined
[13:29] <FROGGS> psch: I will look into this this evening

[13:29] <yoleaux> 13:08Z <psch> FROGGS: yeah, they are.  'control exception without handler' is the new "Unknown control exception type %d"

[13:29] <yoleaux> 13:10Z <psch> FROGGS: apparently Exception.print_control doesn't deal correctly with compound control exception, e.g. 4104 is redo_label, but print_control only does == nqp::const::CONTROL_*, nothing bitwise

[13:29] <yoleaux> 13:10Z <psch> FROGGS: of course, those probably still shouldn't arrive there in the first place but properly control...

[13:29] *** telex left
[13:29] <psch> FROGGS: i'm already looking... :s

[13:29] <FROGGS> okay :o)

[13:30] <FROGGS> I'll pick something else then

[13:31] <psch> UnwindExceptions would be my suggestion :)

[13:31] <psch> it's something regex-y i think

[13:32] *** tokuhiro_ joined
[13:33] <psch> r: my $data = "f fo foo fooo foooo fooooo foooooo"; for 1..7 { say $data.match( /fo+/, :nth($_)) } # curiously works on camelia, but bails locally

[13:33] <camelia> rakudo-{moar,jvm} cd7766: OUTPUT«｢fo｣␤｢foo｣␤｢fooo｣␤｢foooo｣␤｢fooooo｣␤｢foooooo｣␤Nil␤»

[13:34] <psch> might be because of the three tests before that are supposed to throw.. vOv

[13:35] *** telex joined
[13:36] <psch> r: my $data = "f fo foo fooo foooo fooooo foooooo"; try $data.match(/fo; for 1..7 { say $data.match( /fo+/, :nth($_)) } # curiously works on camelia, but bails locally

[13:36] <psch> argh

[13:37] <camelia> rakudo-{moar,jvm} cd7766: OUTPUT«5===SORRY!5===␤Unrecognized regex metacharacter ; (must be quoted to match literally)␤at /tmp/tmpfile:1␤------> 3ooo fooooo foooooo"; try $data.match(/fo7⏏5; for 1..7 { say $data.match( /fo+/, :nt␤Unable to parse regex; couldn't fin…»

[13:37] <psch> r: use Test; my $data = "f fo foo fooo foooo fooooo foooooo"; try $data.match(/fo+/, :nth(-1)); try $data.match(/fo+/, :nth(-2)); for 1..7 { say $data.match( /fo+/, :nth($_)) }  # there is some weird

[13:37] *** tokuhiro_ left
[13:37] <camelia> rakudo-{moar,jvm} cd7766: OUTPUT«｢fo｣␤｢foo｣␤｢fooo｣␤｢foooo｣␤｢fooooo｣␤｢foooooo｣␤Nil␤»

[13:38] <psch> ah, nevermind, just jvm being bogged down then

[13:38] <psch> anyway, i'll leave that lying around now :P

[13:39] <FROGGS> :P

[13:41] <timotimo> json_pp is at 413 megabytes now

[13:41] *** telex left
[13:42] <psch> r: use Test; my $str = "abbb"; my regex rx { ab+ }; ok( $str ~~ m:ex:x(2)/<rx>/, ":x and :ex" ) # this is definitely suspect :P

[13:42] <camelia> rakudo-jvm cd7766: ( no output )

[13:42] <camelia> ..rakudo-moar cd7766: OUTPUT«ok 1 - :x and :ex␤»

[13:43] *** araujo left
[13:46] *** araujo joined
[13:46] *** araujo left
[13:46] *** araujo joined
[13:47] *** araujo left
[13:47] *** Ven left
[13:49] *** FROGGS_ joined
[13:49] *** telex joined
[13:49] *** patrickz left
[13:51] <psch> hm, actually UnwindException and the control exception stuff might both come down to the nqp::handle implementation...

[13:52] *** FROGGS left
[13:54] *** telex left
[13:55] *** araujo joined
[13:55] *** araujo left
[13:55] *** araujo joined
[13:56] *** Ven joined
[13:56] *** araujo left
[13:57] *** softmoth joined
[13:59] *** RabidGravy joined
[14:01] *** softmoth left
[14:02] *** loren joined
[14:02] *** telex joined
[14:08] <dalek> roast: 0e4520a | usev6++ | S03-metaops/hyper.t:

[14:08] <dalek> roast: Add tests for RT #125265

[14:08] <dalek> roast: review: https://github.com/perl6/roast/commit/0e4520aff9

[14:08] <synbot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=125265

[14:11] *** zakharyas joined
[14:13] *** _dolmen_ joined
[14:13] *** patrickz joined
[14:16] *** lolisa left
[14:19] *** suman joined
[14:19] <suman> anyone working on matplotlib API for perl 6

[14:19] <masak> don't think so -- go for it :)

[14:19] <suman> I mean matplotlib(python)

[14:21] <moritz> currently available via Inlne::Python

[14:21] <masak> suman: are you familar with Inline::...what moritz said.

[14:21] *** softmoth joined
[14:21] *** Ven left
[14:26] <timotimo> 2h, 40m almost

[14:26] *** softmoth left
[14:26] <timotimo> will the document ever be pretty-printed?

[14:29] *** tokuhirom joined
[14:32] *** WizJin left
[14:34] *** tokuhirom left
[14:35] <suman> masak no idea how to use Inine::Python Any tutorial?

[14:36] *** Ven joined
[14:36] <suman> Perl 6 and even perl 5 documentation is not elegant as python. Any plan to change? Let's change it for good.

[14:37] *** _dolmen_ left
[14:38] <moritz> suman: that is very much a matter of type

[14:38] <moritz> *taste

[14:39] <moritz> suman: I, for one, don't find string literals in void context very elegant

[14:39] <moritz> suman: much less the lack of an agreed-upon syntax inside these string literals

[14:43] <suman> Perl 6 language, its concepts are yes powerful and new syntax is great. But we need better docummentation and good tutorials.

[14:44] <Ven> that we do need, but we also need to give it a little time :-).

[14:44] <suman> There are MOOC platforms like coursera, edx, udacity. Anyone having plans to deliver one course through those platforms on PErl 6. I would love to see one.

[14:44] <Ven> suman: if you have feedback, it's greatly appreciated (you can ping me for the learnxiny)

[14:46] <suman> Ven Yeah I went through learnxiny, Learned a lot on perl 6 on the site. Thanks!! :-)

[14:46] <Ven> .ask zoffix tell me when I can start treating https://github.com/adambard/learnxinyminutes-docs/issues/1390

[14:46] <yoleaux> Ven: I'll pass your message to zoffix.

[14:46] <Ven> er, is it zoffixnet?

[14:47] <psch> .seen Zoffix

[14:47] <yoleaux> I saw Zoffix 22 Oct 2015 13:21Z in #perl6: <Zoffix> Ah :)

[14:47] <suman> Indeed I very much like the new perl 6 page. Its much elegant.

[14:47] <psch> .seen ZoffixWork

[14:47] <yoleaux> I saw ZoffixWork 9 Oct 2015 19:49Z in #perl6: <ZoffixWork> Hey. What's a usecase for ENTER phaser? Wound't code still run "every time you enter the block"?

[14:47] <psch> Ven: those two most often i think

[14:48] <ugexe> whats a better way to split an array of strings into kv of a hash?

[14:48] <ugexe> my @a = "aaa=bbb","ccc=ddd"; my %h = @a.map.split("=", 2); $x => $y });

[14:48] <moritz> suman: well, I do agree that we need better docs. Contributions are very welcome.

[14:48] <ugexe> er

[14:48] <dalek> ecosystem: c47df97 | retupmoca++ | META.list:

[14:48] <dalek> ecosystem: Add Find::Bundled

[14:48] <dalek> ecosystem: 

[14:48] <dalek> ecosystem: A temporary replacement for %?RESOURCE

[14:48] <dalek> ecosystem: 

[14:48] <dalek> ecosystem: https://github.com/retupmoca/P6-Find-Bundled

[14:49] <dalek> ecosystem: review: https://github.com/perl6/ecosystem/commit/c47df97125

[14:49] <ugexe> my @a = "aaa=bbb","ccc=ddd"; my %h = @a.map({ .split("=", 2); $x => $y });

[14:49] <moritz> m: my @a = "aaa=bbb","ccc=ddd"; my %h = @a.map({ [Z=>] .split('=', 2)})

[14:49] <camelia> rakudo-moar cd7766: ( no output )

[14:49] <moritz> m: my @a = "aaa=bbb","ccc=ddd"; my %h = @a.map({ [Z=>] .split('=', 2)}); say %h.perl

[14:49] <camelia> rakudo-moar cd7766: OUTPUT«{"aaa\tbbb" => (:ccc("ddd"),).Seq}␤»

[14:50] <moritz> not quite :(

[14:50] <ugexe> darn

[14:50] <moritz> m: my @a = "aaa=bbb","ccc=ddd"; my %h = flat @a.map({.split('=', 2)}); say %h.perl

[14:50] <camelia> rakudo-moar cd7766: OUTPUT«{:aaa("bbb"), :ccc("ddd")}␤»

[14:50] <mantovani> guys

[14:50] <moritz> m: my @a = "aaa=bbb","ccc=ddd"; my %h = @a.map({[=>] .split('=', 2)}); say %h.perl

[14:50] <camelia> rakudo-moar cd7766: OUTPUT«{:aaa("bbb"), :ccc("ddd")}␤»

[14:50] <ugexe> nice

[14:51] *** cognominal left
[14:51] <psch> m: my @a = "aaa=bbb", "ccc=ddd"; my %h = @a.map({ |(.split("=", 2)) }); say %h.perl

[14:51] <camelia> rakudo-moar cd7766: OUTPUT«{:aaa("bbb"), :ccc("ddd")}␤»

[14:52] <psch> one char longer, though that's whitespace

[14:52] <psch> and explicit pairing is probably cleaner

[14:52] <moritz> oh, are you golfing? :-)

[14:52] <mantovani> how is this "perl -nE 's/bytes/MB/g;s#(\d+)(\s+MB)#&{sub{(shift)/1024/1024}}($1) . $2#ge;print'" in Perl 6 ?

[14:52] <ugexe> thanks moritz, didnt know about [=>]

[14:52] <psch> moritz: nah, i just wanted to check if %h = |$list actually DWIMs :s

[14:52] <moritz> m: my @a = "aaa=bbb","ccc=ddd"; my %h = | @a.map(*.split('=', 2)); say %h.perl

[14:52] <camelia> rakudo-moar cd7766: OUTPUT«{"aaa bbb" => ("ccc", "ddd").Seq}␤»

[14:53] <psch> m:   my @a = "aaa=bbb", "ccc=ddd"; my %h = @a.map(|*.split("=", 2)); say %h.perl

[14:53] <camelia> rakudo-moar cd7766: OUTPUT«{:aaa("bbb"), :ccc("ddd")}␤»

[14:54] <ugexe> m: my @a = "aaa=bbb","ccc=ddd"; my %h = @a>>.split("=", 2)>>.hash; say %h.perl

[14:54] <camelia> rakudo-moar cd7766: OUTPUT«{:aaa("bbb"), :ccc("ddd")}␤»

[14:55] <psch> vOv

[14:55] <psch> i have bytecode to inspect... 

[14:58] <suman> where can I find resources for regular expression and grammar with perl 6? Easy to follow.

[14:58] <suman> Hey anyone knows good perl 6 IDE?

[14:59] <masak> Emacs with cperl-mode is pretty nice.

[14:59] <ugexe> ive been using your huffman tree blog post btw working on an hpack implementation moritz. it is appreciated

[14:59] <masak> vim with perl6.vim is not bad either.

[15:03] *** zakharyas left
[15:05] <flussence> m: say $_ => S[(\d+) \s+ bytes] = "{$0 / (1+<20)} MiB" given (^10_000_000 .pick)~' bytes';

[15:05] <camelia> rakudo-moar cd7766: OUTPUT«2811001 bytes => 2.68077946 MiB␤»

[15:05] <mantovani> flussence: thank you!

[15:05] <flussence> well that's one way...

[15:11] *** ben left
[15:13] <raiph> suman: https://www.reddit.com/r/perl6/comments/399o82/python_matplotlib_wrapper_in_9_lines_of_perl_6/

[15:13] *** kmel joined
[15:13] <kmel> m: say 'hola!'

[15:13] <camelia> rakudo-moar cd7766: OUTPUT«hola!␤»

[15:17] <jdv79> how can Failures be unhandled when i Booled them?

[15:18] <moritz> jdv79: example?

[15:18] <jdv79> i'd have to try to golf it

[15:18] <moritz> m: sub f() { fail "foo }; unless my $x = f() { say $x }

[15:18] <camelia> rakudo-moar cd7766: OUTPUT«5===SORRY!5=== Error while compiling /tmp/u8mxCDekTU␤Variable '$x' is not declared␤at /tmp/u8mxCDekTU:1␤------> 3sub f() { fail "foo }; unless my 7⏏5$x = f() { say $x }␤»

[15:18] <moritz> m: sub f() { fail "foo" }; unless my $x = f() { say $x }

[15:18] <camelia> rakudo-moar cd7766: OUTPUT«foo␤  in sub f at /tmp/yf5XaVK7qm:1␤  in block <unit> at /tmp/yf5XaVK7qm:1␤␤»

[15:18] <moritz> m: sub f() { fail "foo" }; unless my $x = f() { say $x; say "alive" }

[15:18] <camelia> rakudo-moar cd7766: OUTPUT«foo␤  in sub f at /tmp/CvyaVpvWOe:1␤  in block <unit> at /tmp/CvyaVpvWOe:1␤␤alive␤»

[15:20] * flussence notices «say (1,1,*+*...*)[100000]» runs about 250x faster than a recursive equivalent with «is cached»

[15:21] <jdv79> its a warning from DESTROY.  can that be forced?

[15:21] <flussence> (I get the feeling cached functions don't perform very well, since they .gist their entire arglist on each invocation)

[15:26] <zostay> m: class { has IO::Spec:D $.spec = $*SPEC }.new 

[15:26] <yoleaux> 22 Oct 2015 22:11Z <psch> zostay: some research suggests C# has a ?. operator, which means "if the LHS is not null, call the RHS as method on it"

[15:26] <camelia> rakudo-moar cd7766: OUTPUT«Type check failed in assignment to $!spec; expected IO::Spec:D but got IO::Spec::Unix␤  in block <unit> at /tmp/0fVqCGWoIb:1␤␤»

[15:26] <yoleaux> 22 Oct 2015 22:13Z <psch> zostay: the semantic difference, as i see it, is that we can have methods that work as class methods or instance methods but don't (neccessarily) know before we try to dispatch

[15:26] <yoleaux> 22 Oct 2015 22:14Z <psch> zostay: whereas C# can say "ok this is{,n't} always an instance method" during compile time

[15:28] <zostay> m: $*SPEC.perl.say

[15:28] <camelia> rakudo-moar cd7766: OUTPUT«IO::Spec::Unix␤»

[15:28] <zostay> oh... i see

[15:29] <bartolin> m: my @result = gather { take "foo=bar".split("=") }; say @result.perl # RT #125401

[15:29] <synbot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=125401

[15:29] <camelia> rakudo-moar cd7766: OUTPUT«This Seq has already been iterated, and its values consumed␤  in block <unit> at /tmp/B6_YVZjFwB:1␤␤»

[15:29] <bartolin> m: my @result = flat gather { take "foo=bar".split("=") }; say @result.perl

[15:29] <camelia> rakudo-moar cd7766: OUTPUT«["foo", "bar"]␤»

[15:30] <jdv79> ithink it might be something about multiple failures in a row

[15:30] <bartolin> ^^ is there a better way to get that result from gather/take?

[15:30] <jdv79> :(

[15:30] *** dbrock joined
[15:32] *** suman left
[15:33] <jdv79> i think i'll ignore that one - somehting about calling .new on a failure

[15:33] <jdv79> coded around it

[15:36] <jdv79> is it possible to alias pkgs?  let's say i have Foo and Foo2 and i want to try swapping Foo2 in for Foo.

[15:37] *** ^elyse^ left
[15:39] <flussence> star: use MIME::Base64:name<b64>; # specced in S11

[15:39] <camelia> star-m 2015.09: ( no output )

[15:42] *** khw joined
[15:43] *** n0tjack left
[15:52] *** Ven left
[15:53] *** kmel left
[15:54] <dalek> roast: de87d79 | usev6++ | S04-statements/gather.t:

[15:54] <dalek> roast: Add test for RT #125401

[15:54] <dalek> roast: review: https://github.com/perl6/roast/commit/de87d7958b

[15:54] <synbot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=125401

[16:04] *** dbrock left
[16:05] *** thowe joined
[16:07] *** ^elyse^ joined
[16:11] *** loren left
[16:26] *** smash joined
[16:30] *** kmel joined
[16:40] <timotimo> o/

[16:41] <timotimo> json_pp has been running for 3:16h now and is at 526 megs of ram

[16:41] *** patrickz left
[16:42] <timotimo> still nothing printed to the output file at all ...

[16:42] <FROGGS_> timotimo: what are you doing?

[16:43] *** skids joined
[16:43] <timotimo> i'm trying to pretty-print the result of the htmlify --sparse=200 

[16:43] <timotimo> the --profile result, that is

[16:44] <moritz> timotimo: try json_xs instead

[16:44] <timotimo> oh?

[16:45] <FROGGS_> _pp is Pure Perl™

[16:45] <timotimo> i thought it was "PrettyPrint" 

[16:45] <timotimo> until now i didn't even know it's a perl thing

[16:45] <timotimo> yeah, that's already finished now

[16:46] *** TimToady left
[16:47] <FROGGS_> ohh, maybe it is pretty print?

[16:47] <FROGGS_> where do you got it from?

[16:47] <timotimo> wellllllll

[16:47] <timotimo> given the _xs thing finished in about 1.5s and the other one has been running for hours ..

[16:47] <timotimo> it's probably PurePerl vs XS

[16:47] <moritz> it is

[16:48] <moritz> json_{pp,xs} are command line tools whose default action is to pretty-print, but iirc other actions are available

[16:48] *** TimToady joined
[16:48] <moritz> it can convert to Data::Dumper format, for example

[16:48] <timotimo> a potentially noticable amount of data could probably be saved by only outputting things with non-default values

[16:48] <timotimo> "allocations": []  -  for example

[16:49] <timotimo> and all the : 0 ones, too

[16:49] <RabidGravy> yeah "use JSON::PP ();"

[16:49] <timotimo> those are much less dangerous to remove than the allocations array

[16:54] <psch> r: A: for 1 { for 1 { last A } }

[16:54] <camelia> rakudo-moar cd7766: ( no output )

[16:54] <camelia> ..rakudo-jvm cd7766: OUTPUT«===SORRY!===␤control exception without handler␤»

[16:54] <psch> j: A: for 1 { for 1 { last A }; CONTROL { default { } } } # but also this

[16:54] <camelia> rakudo-jvm cd7766: ( no output )

[16:54] <psch> so far i'm thinking the outer block just doesn't get the catch(ControlException) stuff codegen'd...

[16:55] <psch> the bytecode is really not transparent at all, unfortunately

[16:55] <thowe> So, I saw that a new version of rakudo came out within the last couple of days...  How do I tell Rakudobrew to upgrade to that?

[16:56] <timotimo> you can just "rakudobrew build moar" again to get a bleeding-edge-fresh version

[16:56] <timotimo> alternatively i believe you can "rakudobrew build moar 2015.10" to get the exact release version

[16:58] <psch> timotimo: from the source it looks like the second argument to build is understood as a branch

[16:58] <psch> timotimo: origin/2015.10 doesn't work here, at least

[16:58] <psch> oh, but there's an eval around and a rev-parse

[16:59] * psch looks what git rev-parse means...

[16:59] <timotimo> that'll resolve branch names, tag names, special things like master@{last week} or master^5

[16:59] <timotimo> IIUC

[17:00] <psch> hmm

[17:00] <psch> well, git rev-parse -q --verify origin/2015.10 returns with exitcode 1

[17:00] <psch> so i think that means the run call fails and it doesn't get set to origin/2015.10

[17:00] <psch> so it should just work..?

[17:01] <psch> s/get//

[17:03] <kmel> how do you remove an element from an array?

[17:04] <kmel> and return the new array

[17:04] <kmel> some like push() but in reverse

[17:05] <timotimo> it should probably not be "origin/2015.10", though?

[17:05] *** mike` left
[17:05] <timotimo> pop is the opposite of push

[17:06] <timotimo> and shift is the opposite of unshift

[17:06] <psch> timotimo: that's what i'm saying.  https://github.com/tadzik/rakudobrew/blob/master/bin/rakudobrew#L363

[17:06] <timotimo> m: my @arr = 1,2, 3, 4; @arr.push("pushed"); @arr.unshift("unshifted"); say @arr

[17:06] <camelia> rakudo-moar cd7766: OUTPUT«[unshifted 1 2 3 4 pushed]␤»

[17:06] <psch> timotimo: the run call gets a 1, which i suspect means git says "that's not valid"

[17:06] <timotimo> ah

[17:06] <kmel> timotimo: pop Removes and returns the last item from the array. Fails for an empty array.

[17:07] <timotimo> m: say (my @).pop

[17:07] <camelia> rakudo-moar cd7766: OUTPUT«Cannot pop from an empty Array␤  in block <unit> at /tmp/Vc4gSnRZD0:1␤␤Actually thrown at:␤  in block <unit> at /tmp/Vc4gSnRZD0:1␤␤»

[17:07] <kmel> i want to remove the last item but return the modified array.

[17:07] <kmel> is there a sub for it?

[17:07] <psch> kmel: .slice

[17:08] <psch> or slice notation itself, of course

[17:08] <psch> both work with elements somewhere in the middle, too, in contrast to pop and unshift

[17:08] *** n0tjack joined
[17:09] <kmel> psch: can you give me an example?

[17:10] <kmel> i can't find anything on slice in the docs

[17:11] *** cognominal joined
[17:11] <timotimo> 5638277 2.1G -rw-r--r--. 1 timo timo 2.0G Oct 24 18:45 pretty_printed_htmlify_profile_xs.json

[17:12] *** skids left
[17:12] <RabidGravy> kmel, http://doc.perl6.org/routine/splice#class_List splice

[17:12] <psch> oh

[17:12] <RabidGravy> m: Array.slice

[17:12] <camelia> rakudo-moar cd7766: OUTPUT«Method 'slice' not found for invocant of class 'Array'␤  in block <unit> at /tmp/Kv3AdnURNc:1␤␤»

[17:13] <RabidGravy> m: Array.splice

[17:13] <camelia> rakudo-moar cd7766: OUTPUT«Cannot call splice(Array: ); none of these signatures match:␤    (Array:D \SELF: :$SINK, *%_)␤    (Array:D $: $offset = { ... }, $size = { ... }, @values?, :$SINK, *%_)␤    (Array:D $: $offset = { ... }, $size = { ... }, **@values, :$SINK, *%_)␤  i…»

[17:13] <psch> right, slice is the subscript notation

[17:13] <RabidGravy> just checking ;-)

[17:13] <psch> m: my @a = ^10; @a[0..4, 6..9].flat.perl.say

[17:13] <camelia> rakudo-moar cd7766: OUTPUT«(0, 1, 2, 3, 4, 6, 7, 8, 9).Seq␤»

[17:13] <timotimo> the slimmed down json is only 72 megabytes rather than 97 megabytes

[17:13] <psch> m: my @a = ^10; say |@a[^* (-) 5] # was my original example

[17:13] <camelia> rakudo-moar cd7766: OUTPUT«9␤»

[17:13] <psch> but something is weird there :P

[17:14] <psch> m: say ^10 (-) 5

[17:14] <camelia> rakudo-moar cd7766: OUTPUT«set(9, 7, 8, 4, 3, 6, 1, 0, 2)␤»

[17:14] <psch> m: say (^10 (-) 5).perl

[17:14] <camelia> rakudo-moar cd7766: OUTPUT«set(9,7,8,4,3,6,1,0,2)␤»

[17:14] <psch> m: say (^10 (-) 5).keys

[17:14] <camelia> rakudo-moar cd7766: OUTPUT«(9 7 8 4 3 6 1 0 2)␤»

[17:14] <psch> m: say (^10 (-) 5).keys.sort

[17:14] <camelia> rakudo-moar cd7766: OUTPUT«(0 1 2 3 4 6 7 8 9)␤»

[17:14] <psch> m: my @a = ^10; say |@a[(^* (-) 5).keys.sort] # was my original example

[17:14] <camelia> rakudo-moar cd7766: OUTPUT«012346789␤»

[17:14] <psch> oh, it works too

[17:14] <psch> must've done something weird :)

[17:15] <psch> unfortunate that we need the .keys.sort, would be a cute linenoise idiom otherwise :P

[17:15] <timotimo> but i think there's still a tiny bit of junk left that i can throw out

[17:16] <psch> m: say Set ~~ Iterable

[17:16] <camelia> rakudo-moar cd7766: OUTPUT«False␤»

[17:16] <psch> ah, that's why it doesn't work without .keys.sort

[17:17] <psch> i guess that makes sense, Sets aren't order and thus can't really be iterated

[17:17] <psch> otoh, hashes aren't ordered either...

[17:17] <psch> m: say Hash ~~ Iterable

[17:17] <camelia> rakudo-moar cd7766: OUTPUT«True␤»

[17:19] <kmel> so pop and shift remove the first and last elements of an array.

[17:19] <kmel> what if i want to remove a element in the middle?

[17:19] <psch> *last and first

[17:19] <psch> unless you're chiasmusing

[17:19] <psch> kmel: .splice or subscript

[17:19] <kmel> sorry *last and first

[17:23] <psch> kmel: it depends what exactly you want, actually

[17:23] <psch> kmel: splice modifies in-place, a subscript returns the elements fitting the subscript

[17:27] *** morda joined
[17:29] <psch> m: my @a = ^10; say @a.splice(^5); say @a

[17:29] <camelia> rakudo-moar cd7766: OUTPUT«[5 6 7 8 9]␤[0 1 2 3 4]␤»

[17:29] <kmel> psch: Thanks i got splice to work

[17:29] <psch> eh, that's a misleading example

[17:29] <psch> m: my @a = ^10; say @a.splice(5); say @a

[17:29] <camelia> rakudo-moar cd7766: OUTPUT«[5 6 7 8 9]␤[0 1 2 3 4]␤»

[17:29] <psch> m: my @a = ^10; say @a[0..4]; say @a

[17:29] <camelia> rakudo-moar cd7766: OUTPUT«(0 1 2 3 4)␤[0 1 2 3 4 5 6 7 8 9]␤»

[17:30] <kmel> m: my @array = ['a','b','c','d']; @array.splice(1,2); say @array;

[17:30] <camelia> rakudo-moar cd7766: OUTPUT«[a d]␤»

[17:31] <psch> kmel: "returns the modified array" is what kind of tripped me up, tbh

[17:31] <psch> kmel: afaik, we don't have anything that modifes in-place and returns the invocant

[17:31] <psch> kmel: note that splice returns the elements you remove

[17:31] <kmel> psch: true but i can splice it and say it afterwards no biggie

[17:32] <kmel> psch: .splice; then .say;

[17:33] <timotimo> also, hard drive is full now

[17:34] <kmel> another question, can i delete an element by specifying its name?

[17:34] <kmel> instead of index like splice()

[17:40] *** espadrine_ joined
[17:42] <timotimo> down to 69meg

[17:45] <moritz> kmel: only in a hash

[17:46] <psch> m: my @a = "foo", "bar", "baz"; @a.splice(@a.index("bar")); say @a

[17:46] <camelia> rakudo-moar cd7766: OUTPUT«Offset argument to splice out of range. Is: 4, should be in 0..3␤  in block <unit> at /tmp/Q5ldDniOWW:1␤␤Actually thrown at:␤  in block <unit> at /tmp/Q5ldDniOWW:1␤␤»

[17:46] <psch> oh, that would've been grep-index but that's gone, right?

[17:47] <thowe> is it wrong that I mostly use perl6 at work as an accurate desktop calculator?

[17:47] <moritz> m: my @a = "foo", "bar", "baz"; @a.splice(@a.first(:k, "bar")); say @a

[17:47] <camelia> rakudo-moar cd7766: OUTPUT«[foo]␤»

[17:47] <moritz> m: my @a = "foo", "bar", "baz"; @a.splice(@a.first(:k, "bar"), 1); say @a

[17:47] <camelia> rakudo-moar cd7766: OUTPUT«[foo baz]␤»

[17:47] <psch> moritz++ # completing my half-solution

[17:49] <kmel> ok thanks :)

[17:49] *** ^elyse^ left
[17:51] <timotimo> test test

[17:52] <timotimo> 'k

[17:54] <kmel> m: my @array = ['d','c','b','a']; @array.sort; say @array;

[17:54] <camelia> rakudo-moar cd7766: OUTPUT«[d c b a]␤»

[17:55] <kmel> is this ^ normal?

[17:55] <thowe> I just wish hitting the up arrow scrolled back in my REPL history

[17:56] <TimToady>  m: my @array = ['d','c','b','a']; @array.=sort; say @array

[17:56] <camelia> rakudo-moar cd7766: OUTPUT«[a b c d]␤»

[17:56] *** n0tjack left
[17:57] <TimToady> this isn't python

[17:58] *** softmoth joined
[17:58] <kmel> thanks TimToady

[17:58] <kmel> i am still reading the docs

[17:59] <thowe> how do I change the displayed significant digits of a Rat?

[17:59] <kmel> so what's the difference between = and .= ?

[17:59] <kmel> not in the sort example but in general

[18:00] <timotimo> it's syntactic sugar similar to += and such

[18:00] <gfldex> .= modifies the container on the left, while = doesnt

[18:00] <timotimo> $foo .= uc   ->>   $foo = $foo.uc

[18:01] <kmel> aha thanks

[18:02] <kmel> is there a doc for it? I'd like to read more if possible.

[18:02] *** softmoth left
[18:02] <TimToady> thowe: printf or .fmt or .base(10,$digits)

[18:03] <TimToady> m: say <1/3>.base(10,30)

[18:03] <camelia> rakudo-moar cd7766: OUTPUT«0.333333333333333333333333333333␤»

[18:03] <TimToady> m: say <1/3>.base-repeating

[18:03] <camelia> rakudo-moar cd7766: OUTPUT«(0. 3)␤»

[18:04] <TimToady> m: say <22/7>.base-repeating

[18:04] <camelia> rakudo-moar cd7766: OUTPUT«(3. 142857)␤»

[18:05] *** pmurias joined
[18:05] <pmurias> hi

[18:05] <timotimo> ohai pmurias 

[18:08] <timotimo> down to 66 megabytes

[18:08] <timotimo> now it'll be interesting to see if the html profiler barfs at the missing keys

[18:08] <kmel> m: @array = [4,3,2,1]; @array.push(99); say @array;

[18:08] <camelia> rakudo-moar cd7766: OUTPUT«5===SORRY!5=== Error while compiling /tmp/6HPgufan_i␤Variable '@array' is not declared. Did you mean any of these?␤    array␤    Array␤␤at /tmp/6HPgufan_i:1␤------> 3<BOL>7⏏5@array = [4,3,2,1]; @array.push(99); say␤»

[18:08] <kmel> m: my @array = [4,3,2,1]; @array.push(99); say @array;

[18:08] <camelia> rakudo-moar cd7766: OUTPUT«[4 3 2 1 99]␤»

[18:09] <kmel> m: my @array = [4,3,2,1]; @array.=sort; say @array;

[18:09] <camelia> rakudo-moar cd7766: OUTPUT«[1 2 3 4]␤»

[18:09] <kmel> why does sort require .= and push doesn't

[18:09] <kmel> ?

[18:09] <TimToady> push is naturally a mutator

[18:10] <TimToady> and we don't require all mutators to be written with .=

[18:10] <timotimo> the non-mutator version of .push is ,

[18:10] <timotimo> (coupled with a flat at the beginning)

[18:11] <TimToady> .= is just a convenient way to turn a function into a mutator

[18:12] <kmel> TimToady & timotimo Many thanks

[18:12] <psch> (nearly) everything can be a metaop for infix:<=>

[18:12] <pmurias> m: my @array = [4,3,2,1]; say @array.sort.perl; say @array.sort;

[18:12] <camelia> rakudo-moar cd7766: OUTPUT«(1, 2, 3, 4).Seq␤(1 2 3 4)␤»

[18:12] <timotimo> i've got the profile output down to 66 megabytes, but the html thingie still times out :(

[18:12] <pmurias> m: my @array = [4,3,2,1]; say @array.sort; say @array;

[18:12] <camelia> rakudo-moar cd7766: OUTPUT«(1 2 3 4)␤[4 3 2 1]␤»

[18:12] <psch> where "nearly" probably means "infixes"

[18:13] *** darutoko left
[18:13] *** darutoko joined
[18:13] <timotimo> you can't nest metaop_assign, can you?

[18:13] <gfldex> m: my method twice(Int:D $self:){$self++}; my @many-ints = 1..5; @many-ints>>.=&twice;

[18:13] <camelia> rakudo-moar cd7766: OUTPUT«Parameter '$a' expected a writable container, but got Int value␤  in method twice at /tmp/BWufRzQ3mo:1␤  in block <unit> at /tmp/BWufRzQ3mo:1␤␤»

[18:13] <psch> makes me wonder if there could be a use for "declare this categorical similar to infix:<=> regarding meta-ability"

[18:13] <psch> m: my $x [=]= 5

[18:13] <gfldex> where is '$a' coming from?

[18:13] <camelia> rakudo-moar cd7766: OUTPUT«5===SORRY!5=== Error while compiling /tmp/23lOl1YoGz␤Cannot make assignment out of = because list assignment operators are too fiddly␤at /tmp/23lOl1YoGz:1␤------> 3my $x [=]=7⏏5 5␤»

[18:14] <psch> timotimo: assignment is too fiddly to be made into an assignment, clearly :)

[18:14] <timotimo> :)

[18:14] <psch> gfldex: probably out of whatever postfix:['>>'] translates into

[18:14] <psch> (or "call under the hood")

[18:14] <psch> +s

[18:15] <timotimo> yeah, there's not really a postfix >> because it has to parse a method call afterwards

[18:15] *** FROGGS_ is now known as FROGGS

[18:15] * FROGGS pulls and builds perl6-j

[18:21] <timotimo> xxitpxinput

[18:21] <timotimo> ...

[18:28] *** ifim joined
[18:30] <xinming> http://termbin.com/w6lk

[18:30] <xinming> http://termbin.com/w6lk   <-- Is this a bug, When I try to run this test script, I got value method is found found.

[18:30] <xinming> the error I got is something like Method 'value' not found for invocant of class 'T'

[18:30] <xinming> This test code worked before.

[18:31] <psch> m: class A { has Int $value }; A.new.value.say

[18:31] <camelia> rakudo-moar cd7766: OUTPUT«Method 'value' not found for invocant of class 'A'␤  in block <unit> at /tmp/T08ClB3Dws:1␤␤»

[18:31] <xinming> Maybe the grammer changed.

[18:31] <psch> m: class A { has Int $.value }; A.new.value.say

[18:31] <camelia> rakudo-moar cd7766: OUTPUT«(Int)␤»

[18:31] <xinming> ah

[18:31] <psch> xinming: no idea if anything changed there, but attributes generally want a dot twigil

[18:31] <xinming> bbl

[18:32] <AlexDaniel> xinming: why not ｢for ^$t｣ instead of ｢loop (my $cnt = 0; $cnt < $t; $cnt++)｣

[18:32] <timotimo> the "." is there to signal "please create an accessor method"

[18:33] <pmurias> when a closure is created in nqp is the code object cloned?

[18:33] <timotimo> apparently without a . it will just give you a private attribute without the !

[18:33] <xinming> AlexDaniel I'm not still fully get the all features for perl6 yet.

[18:33] <psch> mm: class A { has $x }; say A.^attributes.perl

[18:33] <psch> m: class A { has $x }; say A.^attributes.perl

[18:33] <camelia> rakudo-moar cd7766: OUTPUT«(Attribute.new,)␤»

[18:33] <psch> m: class A { has $x }; say A.^attributes[0].name

[18:33] <camelia> rakudo-moar cd7766: OUTPUT«$!x␤»

[18:33] <psch> huh, that is interesting

[18:34] *** Skarsnik joined
[18:34] *** yqt joined
[18:35] <psch> pmurias: org.perl6.nqp.runtime.CodeRef:43 seems to suggest so

[18:35] <psch> paraphrased "the name of the coderef is not in the staticinfo because clones might want to change it"

[18:36] <psch> hm, actually i suppose that means the CodeRef is cloned, but the staticInfo isn't

[18:36] *** ^elyse^ joined
[18:37] <psch> yeah, that interpretation is support by CodeRef.clone()

[18:38] *** espadrine_ left
[18:38] <psch> unless i'm confusing java assignment semantics again, which i hope i don't...

[18:38] <pmurias> CodeRef clone doesn't seem to clone the codeObj

[18:39] *** ^elyse^ left
[18:40] <FROGGS> psch: ewww, I get: Stage classfile  : java.lang.RuntimeException: java.lang.RuntimeException: Class file too large!

[18:43] <psch> pmurias: Ops.takeclosure calls the (runtime gen'd) .clone method and casts the result to CodeRef

[18:43] <gfldex> m: say int.max; # i do agree that 64bit makes for large numbers but seams a bit off

[18:43] <camelia> rakudo-moar cd7766: OUTPUT«-Inf␤»

[18:44] <psch> FROGGS: i haven't seen that yet, ever..?

[18:45] <FROGGS> hmmmm

[18:45] <psch> pmurias: actually, it's not runtime gen'd, sorry

[18:46] <psch> pmurias: it should be the clone found in CodeRef.java

[18:46] <psch> well, except if it's something generated that subclasses CodeRef and overwrites .clone...

[18:46] <xinming> http://termbin.com/m7kk

[18:46] <xinming> How about this example then?

[18:47] <xinming> When I try to extract the last array element which is array too?

[18:47] <psch> m: https://gist.github.com/peschwa/4a55a318af570988e67d

[18:47] <camelia> rakudo-moar cd7766: OUTPUT«Method 'value' not found for invocant of class 'Array[T]'␤  in block  at /tmp/CrfyUOnI8u:22␤  in submethod BUILD at /tmp/CrfyUOnI8u:20␤  in block <unit> at /tmp/CrfyUOnI8u:28␤␤»

[18:47] <xinming> I believe this is where it changed.

[18:47] <xinming> Please notice the  @!last   in the last example.

[18:47] <psch> xinming: i copied your latest link to a gist because camelia understands those

[18:48] <xinming> yes, if you have safe env, just do     curl url | perl6    :-)

[18:49] <xinming> But I personally don't do this. Maybe you have better idea.

[18:49] <xinming> ah, xx.gist.say

[18:49] <psch> m: my Array of T @x; say @x.perl

[18:49] <camelia> rakudo-moar cd7766: OUTPUT«5===SORRY!5===␤Type 'Array' is not declared. Did you mean 'array'?␤at /tmp/BQZpsX94ou:1␤------> 3my Array of 7⏏5T @x; say @x.perl␤Malformed my␤at /tmp/BQZpsX94ou:1␤------> 3my Array of 7⏏5T @x; say @x.perl␤␤»

[18:50] <psch> m: class A { has Array of T @x.; }; A.new.x.perl.say

[18:50] <camelia> rakudo-moar cd7766: OUTPUT«5===SORRY!5===␤Type 'Array' is not declared. Did you mean 'array'?␤at /tmp/vOj7c8E4qs:1␤------> 3class A { has Array of 7⏏5T @x.; }; A.new.x.perl.say␤Malformed has␤at /tmp/vOj7c8E4qs:1␤------> 3class A { has Array of 7⏏5T @x.; };…»

[18:50] <FROGGS> m: my T @x; say @x.perl

[18:50] <camelia> rakudo-moar cd7766: OUTPUT«5===SORRY!5===␤Type 'T' is not declared␤at /tmp/r1Lpjzt7St:1␤------> 3my T7⏏5 @x; say @x.perl␤Malformed my␤at /tmp/r1Lpjzt7St:1␤------> 3my7⏏5 T @x; say @x.perl␤␤»

[18:50] <psch> m: class A { has Array of Int @x.; }; A.new.x.perl.say

[18:50] <camelia> rakudo-moar cd7766: OUTPUT«5===SORRY!5=== Error while compiling /tmp/pUIh1LoT9_␤Unsupported use of . to concatenate strings; in Perl 6 please use ~␤at /tmp/pUIh1LoT9_:1␤------> 3class A { has Array of Int @x.;7⏏5 }; A.new.x.perl.say␤»

[18:50] <psch> m: class A { has Array of Int @.x; }; A.new.x.perl.say

[18:50] <camelia> rakudo-moar cd7766: OUTPUT«Array[Array[Int]].new()␤»

[18:50] <psch> that's probably as intended

[18:51] <psch> so last is Array[T]

[18:51] <psch> ph

[18:51] <psch> oh

[18:51] <xinming> Yes, But I just don't know how to unify the array and iterate them.

[18:51] <psch> m: my @a = ^10; my @b = 10..19; for @a, @b { .perl.say }

[18:51] <camelia> rakudo-moar cd7766: OUTPUT«[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]␤[10, 11, 12, 13, 14, 15, 16, 17, 18, 19]␤»

[18:51] <psch> xinming: ^^^ that's your hang-up, flattening rules changed

[18:51] <psch> m: my @a = ^10; my @b = 10..19; for |@a, |@b { .perl.say }

[18:51] <camelia> rakudo-moar cd7766: OUTPUT«0␤1␤2␤3␤4␤5␤6␤7␤8␤9␤10␤11␤12␤13␤14␤15␤16␤17␤18␤19␤»

[18:51] <xinming> Ok, Thanks.

[18:51] <FROGGS> m: my @a = ^10; my @b = 10..19; for flat @a, @b { .perl.say }

[18:51] <camelia> rakudo-moar cd7766: OUTPUT«0␤1␤2␤3␤4␤5␤6␤7␤8␤9␤10␤11␤12␤13␤14␤15␤16␤17␤18␤19␤»

[18:51] <xinming> That's where I got confused. :-)

[18:52] <xinming> the flatten rule.

[18:52] <xinming> so the  $@array syntax is no longer needed.

[18:53] <psch> m: my @a = ^10; my @b = 10..19; @a.push(@b); @a.perl.say

[18:53] <camelia> rakudo-moar cd7766: OUTPUT«[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, [10, 11, 12, 13, 14, 15, 16, 17, 18, 19]]␤»

[18:53] <psch> m: my @a = ^10; my @b = 10..19; @a.push($@b); @a.perl.say

[18:53] <camelia> rakudo-moar cd7766: OUTPUT«[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, [10, 11, 12, 13, 14, 15, 16, 17, 18, 19]]␤»

[18:53] <psch> FROGGS: i've just git clean'd and started building.  curious if i get that error too...

[18:53] <gfldex> m: my @l = [[1], 2, [[3,4], 5], [[[]]], [[[6]]], 7, 8, []]; .perl.say given gather @l.deepmap(*.take); # xinming: lazy recursive version

[18:53] <camelia> rakudo-moar cd7766: OUTPUT«(1, 2, 3, 4, 5, 6, 7, 8).Seq␤»

[18:54] <FROGGS> psch: are you on latest commit?

[18:54] <psch> FROGGS: of rakudo, yes

[18:54] <FROGGS> hmmm

[18:54] <psch> FROGGS: did you build nqp head?

[18:54] <FROGGS> weird

[18:54] <FROGGS> I did

[18:54] <FROGGS> This is nqp version 2015.10-9-gb46902b built on JVM

[18:55] <psch> k, i'll build that instead then

[18:55] <xinming> m: my @a = ^5; my @b = 5..10; @a.push(@b); @a.perl.say;

[18:55] <camelia> rakudo-moar cd7766: OUTPUT«[0, 1, 2, 3, 4, [5, 6, 7, 8, 9, 10]]␤»

[18:56] <xinming> So, for now, @a.push(@b) is the same as @a.push($@b);     will $ is still necessary?

[18:56] <b2gills> m: say int.Range.max; # gfldex

[18:56] <camelia> rakudo-moar cd7766: OUTPUT«9223372036854775807␤»

[18:56] <timotimo> not necessary

[18:58] <gfldex> m: my @a = ^5; my $b = (5..10).Slip; @a.push($b); dd @a;

[18:58] <camelia> rakudo-moar cd7766: OUTPUT«Array $var = $[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]␤»

[18:58] <gfldex> m: my @a = ^5; my @b = 5..10; @a.push(|@b); dd @a;

[18:58] <camelia> rakudo-moar cd7766: OUTPUT«Array $var = $[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]␤»

[18:59] <xinming> too many new things for perl6.

[19:00] <RabidGravy> or

[19:01] <RabidGravy> m: @a = ^5; @b = 5..10; @a.append(@b); say @a.perl

[19:01] <camelia> rakudo-moar cd7766: OUTPUT«5===SORRY!5=== Error while compiling /tmp/xfqPhGp5IN␤Variable '@a' is not declared␤at /tmp/xfqPhGp5IN:1␤------> 3<BOL>7⏏5@a = ^5; @b = 5..10; @a.append(@b); say ␤»

[19:01] <RabidGravy> m: my @a = ^5; my @b = 5..10; @a.append(@b); say @a.perl

[19:01] <camelia> rakudo-moar cd7766: OUTPUT«[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]␤»

[19:02] <Skarsnik> Hello, I am trying to bind the gumbo lib (a html parser lib). But I have weird memory corruption with handling the attribute part http://pastebin.com/TPWA6dy4 

[19:02] <psch> FROGGS: nqp builds fine on HEAD here..?

[19:02] <FROGGS> psch: nqp builds, but rakudo doesnt

[19:03] <psch> ah, okay.  i misunderstood then

[19:03] <psch> started Configure for rakudo now

[19:03] <FROGGS> but I use HEAD, instead of NQP_REVISION

[19:04] <psch> FROGGS: right, i built nqp HEAD and now Configure without --gen-nqp

[19:05] <RabidGravy> Skarsnik, there is a const char * in one of those structs, you may want to use "explicitly-manage" on it

[19:05] <timotimo> moritz: https://i.imgur.com/Ln46hPq.png - how do you like this?

[19:06] <moritz> timotimo: thank you. Doesn't look like there are LHF for optimizing stuff :/

[19:07] <moritz> looks like most of the time is spent iterating lists and constructing match objects

[19:08] <xinming> In this example,  http://termbin.com/yoe2    <--- I got error 

[19:08] <xinming> Cannot look up attributes in a type object      <--- This is the rror

[19:08] <xinming> error

[19:08] <Skarsnik> RabidGravy, hm explicitly-manage is not only when you pass something to the C lib?

[19:09] <xinming> But the plain hash worked fine.

[19:09] <xinming> Do I miss something?

[19:09] *** kmel left
[19:10] <moritz> xinming: $hello is a type object of type Hello

[19:10] <moritz> xinming: since it's a private attribute (no . sigil), the default constructor doesn't let you initialize it from the outside

[19:10] <psch> FROGGS: right, got the error too

[19:11] <xinming> moritz: If I add the .

[19:11] <xinming> I get another error which is something like I forget multi.

[19:11] <xinming> Invocant requires a type object of type List, but an object instance was passed.  Did you forget a 'multi'?    <--

[19:12] <FROGGS> psch: so, since you were on rakudo HEAD but not nqp HEAD it means it must be an nqp change?

[19:14] <psch> FROGGS: i'm not sure.  i think i built rakudo the last time at around 1pm, i.e. 8 hours ago

[19:15] <psch> FROGGS: and e8d7577b662a1ab85d9ed080d3a8eff56036b016 adds quite a lot of code

[19:15] <timotimo> moritz: https://i.imgur.com/BJdcSzv.png - this si with --sparse=75 instead

[19:15] <xinming> Actually, What I'm curious is, wether there is some behavior which hash doesn't work the same as normal in class.

[19:15] <FROGGS> psch: that was my first thought

[19:15] <timotimo> moritz: 20% time spent garbage collectin'

[19:15] <FROGGS> psch: I try to build cd77669d09d38e5ddb89ee8f6c8392bacebdf829 now

[19:18] *** tokuhiro_ joined
[19:18] <xinming> and anonymous sub doesn't support multi keyword

[19:20] <FROGGS> psch: yeah, that works

[19:21] <psch> https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.9.1

[19:21] <psch> "The value of the code_length item must be less than 65536. "

[19:21] <RabidGravy> xinming, multi wouldn't make sense on an anonymous sub

[19:21] <psch> FROGGS: welp, time to split CORE into multiple .class files...

[19:22] <FROGGS> :S

[19:23] *** tokuhiro_ left
[19:24] <psch> FROGGS: we're catching this already for "Method too large"

[19:24] <psch> FROGGS: i guess adapting that to also check for "Classfile too large" could be enough...

[19:24] <xinming> RabidGravy: But my example gave the error about maybe I forgot multi, So, I try to fix it with testing the fixes.

[19:24] <psch> nqp.jast2bc.JASTCompiler.java:38, for reference

[19:25] <gfldex> xinming: s/has Hello $hello/has Hello $.hello/

[19:25] <psch> FROGGS: although maybe we need the same in Ops.java:6272

[19:25] <xinming> gfldex: I do

[19:25] <xinming> BBL

[19:26] <xinming> http://termbin.com/wluq   <--- This version with $.hello  will report    Invocant requires a type object of type List, but an object instance was passed.  Did you forget a 'multi'?

[19:27] <gfldex> m: https://gist.github.com/anonymous/bcd7448642f4d93df39e

[19:27] <camelia> rakudo-moar cd7766: OUTPUT«Hash $var = {:add(sub (Real $x, Real $y) { #`(Sub|60993376) ... }), :mul(sub (Real $x, Real $y) { #`(Sub|60993680) ... })}␤8␤»

[19:28] <gfldex> xinming: i replaced some <> with '' and <<>> with {}

[19:29] <gfldex> xinming: and what does your perl6 --version say? Mine is 'This is perl6 version 2015.10-11-g75ac71b built on MoarVM version 2015.10'.

[19:29] <moritz> m: my %h = a => 1; say %h<<a>>.^name

[19:29] <camelia> rakudo-moar cd7766: OUTPUT«Int␤»

[19:29] <xinming> with rplace of <> to ''

[19:29] <xinming> It worked fine

[19:30] <xinming> This is perl6 version 2015.10-11-g75ac71b built on MoarVM version 2015.10    <--- mine

[19:30] <xinming> I just compiled my new perl?

[19:30] <xinming> Do I find the bug?

[19:30] <xinming> because as far as I understand, the <blabal>   is the same as qw(blabla)   which is the same as  'blabla'  in that case too.

[19:30] <moritz> xinming: func_map<<$t>> returns a List of one element

[19:32] <moritz> xinming: I'm not sure it's so simple; if $t contains a space, it'll be a List

[19:32] <moritz> xinming: maybe that's why the List candidate is picked

[19:33] <xinming> Here, It makes me confused

[19:33] <xinming> something like this

[19:33] <gfldex> m: my %h = '1','a','2 3','b c'; %h<<2 3>>.WHAT.say;

[19:33] <camelia> rakudo-moar cd7766: OUTPUT«(List)␤»

[19:34] <xinming> the my %test_map = (....);        %test_map<<add>>(x,y)   <-- THis worked.

[19:34] <moritz> xinming: the solution is not to use <<>> indexing, unless you really need that

[19:34] <xinming> but the thing with something like   my Str $tname = 'add';   %test_map<<$tname>>(x, y)   doesn't.

[19:34] <xinming> Which feels a bit confusing.

[19:35] *** morda left
[19:35] <xinming> Ok, Got it. But I understand the confustion now.

[19:35] <moritz> I can't judge if this is a rakudobug or not

[19:35] <psch> FROGGS: well, just catching "Classfile to large" there isn't enough

[19:35] <psch> FROGGS: we don't have a AutosplitClassfileWriter...

[19:36] <psch> +n

[19:36] <FROGGS> damn

[19:36] <xinming> moritz: I'll ask this tomorrow.  too late here. I'll go to bed. But thanks for the clarifaction.

[19:37] <psch> 6.christmas-j is looking a tad grim right now :P

[19:37] <gfldex> m: my %h = '1','a','2 3','b c'; my $a = 1; %h<<$a>>.WHAT.say; $a = '2 3'; %h<<$a>>.WHAT.say;

[19:37] <camelia> rakudo-moar cd7766: OUTPUT«(List)␤(List)␤»

[19:37] <psch> fwiu we need to implement an AutosplitClassfileWriter and probably touch classloading to be aware of that

[19:38] <psch> oh, and {,de}serialization probably also needs to know about it

[19:38] <FROGGS> ewww

[19:38] <xinming> m: my %h = '1', 'a', '2 3', 'b c';  %h<<1>>.WHAT.say;

[19:38] <camelia> rakudo-moar cd7766: OUTPUT«(Str)␤»

[19:39] <xinming> This is the tricky bit. they both strings, but behave differently.

[19:39] <xinming> they are both strings *

[19:40] <psch> the alternative might be somehow shrinking or splitting the setting on a p6-level, but i'm pretty confident that's 1) a bad idea and 2) contradicts seperation of concerns

[19:40] <FROGGS> m: my %h = '1','a','2 3','b c'; my $a = 1; %h<<a>>.WHAT.say; %h<<$a>>.WHAT.say;

[19:40] <camelia> rakudo-moar cd7766: OUTPUT«(Any)␤(List)␤»

[19:40] <psch> (it's a bad idea not only because of 2, but 2 seems a significant enough reason on its own...)

[19:40] <FROGGS> m: my %h = '1','a','2 3','b c'; my $a = 1; %h<a>.WHAT.say; %h<<$a>>.WHAT.say;

[19:40] <camelia> rakudo-moar cd7766: OUTPUT«(Any)␤(List)␤»

[19:41] <FROGGS> m: my %h = '1','a','2 3','b c'; my $a = 1; %h<1>.WHAT.say; %h<<$a>>.WHAT.say;

[19:41] <camelia> rakudo-moar cd7766: OUTPUT«(Str)␤(List)␤»

[19:41] <FROGGS> psch: aye

[19:41] <FROGGS> psch: sorry that there is not much input from my side, but I'm tired

[19:43] <psch> FROGGS: tbh, having this happen also suddenly made me quite tired :P

[19:43] <FROGGS> hehe

[19:48] <gfldex> m: my %h = <1 a 2 b>; %h<<1>>.WHAT.say; %h<<1 2>>.WHAT.say; my $a = 1; my @some-list = %h<<$a>>.WHAT.say;

[19:48] <camelia> rakudo-moar cd7766: OUTPUT«(Str)␤(List)␤(List)␤»

[19:50] <gfldex> m: my @l; my %h = <1 a 2 b>; @l = %h<<1>>; dd @l; @l = %h<<1 2>>; dd @l; my $a = 1; @l = %h<<$a>>; dd @l;

[19:50] <camelia> rakudo-moar cd7766: OUTPUT«Array $var = $["a"]␤Array $var = $["a", "b"]␤Array $var = $["a"]␤»

[19:51] <gfldex> i think the problem is that %h<<...>>.WHAT.say is missleading because how often would you use a free floating hash?

[19:51] <timotimo> i don't really get what problem we're handling at the moment

[19:51] <timotimo> i'm distracted

[19:52] <timotimo> but why would you us e<<$foo>> instead of {$foo}

[19:52] <RabidGravy> dunno

[19:52] <gfldex> I wouldn't unless I really want some hash slice. xinming did and got some rather strange error.

[19:53] <gfldex> the error message wasn't really LTA tho.

[19:54] <gfldex> m: my @l; my %h = <1 a 2 b>; %h<<1>>>>.uc.say; %h<<1 2>>>>.uc.say;

[19:54] <camelia> rakudo-moar cd7766: OUTPUT«(A)␤(A B)␤»

[19:55] *** n0tjack joined
[19:55] <timotimo> m: 1>>.uc.say

[19:55] <camelia> rakudo-moar cd7766: OUTPUT«(1)␤»

[19:55] <gfldex> he combined an unintended hash slice with type magic and that blew up

[19:55] <timotimo> this may be the reason it's unexpectedly listy?

[19:57] <timotimo> oh, also, .WHAT doesn't play very nice with many higher-order things

[19:58] * moritz generally prefers .^name for debugging

[20:00] *** FROGGS left
[20:02] *** ecocode joined
[20:03] *** z8 joined
[20:04] *** rindolf left
[20:09] *** ^elyse^ joined
[20:11] *** darutoko left
[20:18] *** ^elyse^ left
[20:19] *** n0tjack left
[20:22] <timotimo> i'm missing some kind of skill or insight that makes looking at these routine timing numbers super helpful

[20:23] *** tokuhirom joined
[20:23] *** FROGGS joined
[20:27] <dalek> rakudo/nom: 3c00699 | usev6++ | lib/Test.pm:

[20:27] <dalek> rakudo/nom: Avoid warnings about uninitialized values (RT #124445)

[20:27] <dalek> rakudo/nom: 

[20:27] <dalek> rakudo/nom: There were 5 such warnings when running 'perl6 --doc lib/Test.pm'

[20:27] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/3c00699759

[20:27] <synbot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=124445

[20:27] <dalek> rakudo/nom: 68dc9ed | lizmat++ | lib/Test.pm:

[20:27] <dalek> rakudo/nom: Merge pull request #560 from usev6/rt124445

[20:27] <dalek> rakudo/nom: 

[20:27] <dalek> rakudo/nom: Avoid warnings about uninitialized values (RT #124445)

[20:27] <synbot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=124445

[20:27] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/68dc9ed29b

[20:27] <moritz> timotimo: well, sometimes (quite often, actually) you get lucky, and one routine takes a significant amount of time (like, 30% to 95%); then it's often quite possible to optimize that one routine, or make sure it gets called fewer times

[20:27] *** tokuhirom left
[20:28] <timotimo> right. one thing that bothers me Right Now is that the numbers it shows are very hard to compare by eye because they are shown with proportional font and left-aligned

[20:28] <timotimo> the entry numbers, i mean

[20:29] *** n0tjack joined
[20:29] <lizmat> .botsnack

[20:29] <yoleaux> :D

[20:29] <synbot6> om nom nom

[20:29] <timotimo> with a constant sized font (or maybe even an antiproportional font?) maybe it'll be better!

[20:32] <dalek> nqp: 5bdb23d | (Pawel Murias)++ | src/vm/js/ (2 files):

[20:32] <dalek> nqp: [js] Refactor block handling in preparation for removal of some hacks.

[20:32] <dalek> nqp: 

[20:32] <dalek> nqp: Handle declaration_static and declaration separately.

[20:32] <dalek> nqp: Needs some debugging to figure out why some hacks are still necessary.

[20:32] <dalek> nqp: review: https://github.com/perl6/nqp/commit/5bdb23d240

[20:32] <AlexDaniel> So what is required for my pull request to be merged? (this one: https://github.com/perl6/specs/pull/102) pmichaud mentioned “agreement” but for that some comments are required, I guess…

[20:33] <pmurias> a random error in MoarVM sometimes makes nqp-js emit incorrect code :(

[20:36] <moritz> pmurias: time to bootstrap, eh? :-)

[20:36] <lizmat> pmurias: if you can make it repeatable, that would be brilliant!

[20:37] <moritz> AlexDaniel: I won't merge that unless TimToady++ gives the green light (or at least doesn't disapprove)

[20:37] <lizmat> because it is probably doing the same thing when emitting moarvm bytecode, but that is probably much harder to debug!

[20:38] <AlexDaniel> moritz: yeah, that's fine. I did not see any reply from him yet

[20:39] <pmurias> lizmat: I'll try to find a way to reproduce that reliably, it seems to be something with strings getting concatenated incorrectly (it causes fragments of generated javascript to go missing) so it might not occur when emitting moarvm

[20:40] <pmurias> OTOH it's likely some other error manifesting (like the last one jnthn++ fixed)

[20:41] <pmurias> moritz: working on the bootstrap, currently fixing bugs that make (nqp-js)-compiled-to-js fail tests

[20:44] *** kaare_ left
[20:44] <bartolin> pmurias: as you wrote 'strings getting concatenated incorrectly' I was reminded of RT #123602

[20:44] <synbot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=123602

[20:44] <bartolin> pmurias: maybe it's related somehow?!

[20:46] <pmurias> bartolin: not sure, mine is random

[20:47] *** FROGGS left
[20:47] <bartolin> pmurias: ok, just wanted to note that there is at least one known problem in this area 

[20:50] *** FROGGS joined
[20:50] <lizmat> FWIW, I seem to recall jnthn telling me that nqp::concat is not actually concatting strings, but creating a linked list internnally

[20:51] *** n0tjack left
[20:54] *** FROGGS left
[20:55] <pink_mist> AlexDaniel: my suggestion would be to rename :x to :shell or :shellout instead, so it's clear both what it does, and it has a worse huffman coding ... and possibly add a :r or :run for runout

[20:55] <bartolin> lizmat: since you worked on the code for squish lately: does the following problem on jvm ring a bell for you?

[20:55] <bartolin> j: say squish("a", "b", "b", "a")

[20:55] <camelia> rakudo-jvm cd7766: ( no output )

[20:55] <bartolin> hmm :/

[20:55] <lizmat> m: say squish("a", "b", "b", "a")   # sanity check

[20:55] <camelia> rakudo-moar cd7766: OUTPUT«(a b a)␤»

[20:55] <bartolin> locally I get '(a b a Mu.new Mu.new Mu.new Mu.new ...)' 

[20:56] <lizmat> ah?

[20:56] <lizmat> no, doesn't ring a bell, but I'll look at it in a mo

[20:56] <pink_mist> AlexDaniel: the :r/:run would be on an array or list then =)

[20:56] <AlexDaniel> pink_mist: well, run takes a list of arguments, so it is pretty hard to get it into a quoting construct (although still possible).

[20:56] <dalek> nqp: 4fd2e45 | (Pawel Murias)++ | src/vm/js/QAST/Compiler.nqp:

[20:56] <dalek> nqp: [js] Implement nqp::callstatic as nqp::call.

[20:56] <dalek> nqp: review: https://github.com/perl6/nqp/commit/4fd2e45412

[20:57] <pink_mist> AlexDaniel: but I'm not really married to the idea ... could easily do without that

[20:57] <bartolin> lizmat: somehow IterationEnd =:= $pulled does not match within 'push-exactly' from src/core/Iterator.pm

[20:58] <AlexDaniel> pink_mist: having :shell instead of :x is actually not too bad, yet I still don't really see many reasons for :x adverb to exist at all…

[20:59] <lizmat> bartolin: well, that *could* be some JVM garbage collect issue maybe ?

[20:59] <AlexDaniel> pink_mist: like, if we had no :x today, what would be the reason to implement it? :)

[20:59] * flussence would like q:x to mean system() instead of shell(), at the very least. For performance reasons if nothing else.

[20:59] <bartolin> lizmat: well, it's not a pressing problem, anyway. just wanted to hear if you have an idea at hand :-)

[21:00] <lizmat> no, that looks like a JVM issue to me..  :-(  and I'm a complete JVM noob

[21:00] <pink_mist> AlexDaniel: I actually didn't even know about it until just now ... and I'm not l

[21:00] <pink_mist> err

[21:01] <bartolin> lizmat: as am I *g*

[21:01] <pink_mist> AlexDaniel: and I'm not liking that it exists either, but now that I do know about it, I would probably miss it if it was completely removed

[21:01] * bartolin was looking for some spectest failures and started with squish.t

[21:02] <AlexDaniel> pink_mist: ok, but is “shellout” sub somehow worse than :x?

[21:02] <dalek> nqp: f3aed7a | (Pawel Murias)++ | src/vm/js/QAST/Compiler.nqp:

[21:02] <dalek> nqp: [js] add coercion from $T_BOOL to $T_INT.

[21:02] <dalek> nqp: review: https://github.com/perl6/nqp/commit/f3aed7a89a

[21:03] <pink_mist> AlexDaniel: it probably isn't, but it's a nice demo of adverbs

[21:03] <pink_mist> *but :x is a ..

[21:04] <pink_mist> AlexDaniel: regarding the names of 'shellout' and 'runout', I do like the 'shellout' name, but 'runout' is really not to my liking

[21:04] <AlexDaniel> flussence: yeah, but I don't think that we can change it right now, since it will break existing code. If :x later comes back in another form, then it is fine, but it seems to be a right thing to deprecate it now.

[21:05] <AlexDaniel> pink_mist: I find it weird too, yet I like the consistency. shell() -> shellout(), run() -> runout()

[21:05] <pink_mist> what precisely does shell() do?

[21:06] <AlexDaniel> pink_mist: returns a Proc object, as far as I can see

[21:06] <AlexDaniel> pink_mist: so that you can run any shell command, and then observe its return code or pass some stdin

[21:06] <pink_mist> gotcha

[21:06] <AlexDaniel> it is very flexible, I love it

[21:07] <AlexDaniel> pink_mist: shell('rm all my files', :out).out.slurp-rest; # that's what shellout does

[21:07] <pink_mist> right

[21:08] <pink_mist> I still don't like runout() as a name :/

[21:08] <AlexDaniel> and there's run(), which works very similarly, but completely without the shell

[21:08] <flussence> also I feel like the current q:x should really have been qw:x, given the way it works.

[21:08] *** vendethiel joined
[21:08] <AlexDaniel> flussence: how would that help?

[21:09] *** raiph left
[21:10] <AlexDaniel> pink_mist: actually, it could be shortened to out()…

[21:10] <pink_mist> ohh, yes!

[21:10] <pink_mist> I like that!

[21:10] <AlexDaniel> hmm

[21:11] <pink_mist> (let's just h

[21:11] <pink_mist> ope everyone else does too)

[21:11] *** _dolmen_ joined
[21:11] <pink_mist> (damn, my enter button gets pressed randomly when I rest my hands on the front of the laptop :/)

[21:11] <flussence> as long as we end up with something shorter to type than "use IPC::System::Simple qw(systemx); systemx(@foo)", I don't care much how this ends :)

[21:12] *** BenGoldberg joined
[21:15] *** ecocode left
[21:16] * vendethiel waves

[21:17] <pink_mist> AlexDaniel: I'll comment on the pull request with what I got out of our discussion here =)

[21:17] <AlexDaniel> pink_mist: yes please

[21:17] * lizmat waves back

[21:20] <flussence> it does feel a bit unfortunate that the most user-friendly way of running external processes is a footcannon...

[21:20] <gfldex> m: sub function { 2 * $^x + 3 }; say [1,2,3]>>.&({ $^x + 1 })

[21:20] <camelia> rakudo-moar cd7766: OUTPUT«[2 3 4]␤»

[21:28] *** tokuhirom joined
[21:29] *** xfix left
[21:31] <lizmat> in the category weird errors, possibly DIHWIDT: https://gist.github.com/lizmat/e6924fd8f39500552286

[21:33] *** tokuhirom left
[21:36] <vendethiel> lizmat: does --ll-exception give a bit more of a clue?

[21:39] <lizmat> it does, but does not make much sense (updated gist with long stack trace)

[21:39] <lizmat> it seems to go bad in if not %*perlseen<TOP> { my %*perlseen = :TOP ; return self.perl(:$arglist) }

[21:48] <lizmat> I'm not spending any more time on this, I just thought jnthn might be interested and I didn't want to forget it

[21:48] <lizmat> because at one point we probably *do* want to make sure that you cannot instantiate Rakudo::Internals

[21:49] *** tokuhiro_ joined
[21:53] *** tokuhiro_ left
[22:03] *** Skarsnik left
[22:03] <timotimo> Program terminated with signal SIGKILL, Killed.

[22:03] <timotimo> The program no longer exists.

[22:04] <timotimo> isn't gdb supposed to ... you know ... keep the program around so i can debug it?

[22:08] <timotimo> seems like it got killed via OOM

[22:15] <geekosaur> nothing can intercept SIGKILL

[22:15] <geekosaur> including debuggers

[22:15] *** raiph joined
[22:16] <lizmat> timotimo: any suggestions on how to check performance of foo xx * ?

[22:17] <timotimo> hm, nothing comes to mind

[22:21] *** pmurias left
[22:22] <lizmat> m: my @a = Slip(1,2,3,4,5) xx 3; dd @a   # is this correct?  I sorta expected @a to only have 3 elements after this

[22:22] <camelia> rakudo-moar cd7766: OUTPUT«Array $var = $[1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 1, 2, 3, 4, 5]␤»

[22:23] *** vendethiel left
[22:23] <lizmat> this feels wrong to me...

[22:23] *** Ben_Goldberg joined
[22:26] *** _dolmen_ left
[22:26] *** BenGoldberg left
[22:28] <japhb> lizmat: Why does that seem strange to you?  I would expect Slip to be exactly the way to not have 3 elements, actually ...

[22:29] <lizmat> but with xx you specify the number of elements that you want, I would think

[22:29] <lizmat> the fact that it is a Slip that happens to be xx'd, shouldn't matter

[22:29] <lizmat> because it could be hidden in an expression

[22:31] <japhb> Sure, but even hidden in an expression, the whole point of a Slip is to disappear into larger lists, right?

[22:31] <japhb> Or am I out of date with the current design?

[22:31] <lizmat> sure... that is correct

[22:31] <lizmat> so I would expect the above to set @a to 1,2,3

[22:32] <lizmat> and leave the rest of the Slip to not be consumed

[22:39] <gfldex> m: constant list = Slip(1,2,3) xx 3; constant seq = slip(1,2,3),slip(1,2,3),slip(1,2,3); dd list; dd seq;

[22:39] <camelia> rakudo-moar cd7766: OUTPUT«Seq $var = (1, 2, 3, 1, 2, 3, 1, 2, 3).Seq␤List $var = $(1, 2, 3, 1, 2, 3, 1, 2, 3)␤»

[22:39] <gfldex> i would expect the slips to be preserved in both cases

[22:40] *** leedo left
[22:41] <timotimo> lizmat: i really wouldn't expect xx to give a shorter list than any data you may have on the LHS

[22:41] *** leedo joined
[22:41] <timotimo> as in, i expect Slip(1, 2, 3, 4) xx 3 to have 4 * 3 elements

[22:42] *** ^elyse^ joined
[22:42] <japhb> Because Slip(...) is the expression that gets thunked and evaluated 3 times

[22:42] <japhb> (Since the LHS of xx is a thunk)

[22:42] <timotimo> that'? how i understand it, aye

[22:43] <lizmat> how many elements do you expect {1,2,3,4] xx 3 to have ?

[22:43] <timotimo> i always hold capslock too long when i want to "'s"

[22:43] <japhb> lizmat: 3

[22:43] <lizmat> how many do you expect $foo xx 3 to have ?

[22:43] <japhb> lizmat: 3 -- $foo being in a scalar container

[22:44] <lizmat> m: my $foo = Slip(1,2,3); dd $foo xx 3

[22:44] <camelia> rakudo-moar cd7766: OUTPUT«Seq $var = (1, 2, 3, 1, 2, 3, 1, 2, 3).Seq␤»

[22:44] <japhb> If it was foo xx 3, I would expect that to depend on whether foo was a Slip (or returned one)

[22:44] <lizmat> this is the same issue as with push/pop

[22:44] <japhb> That surprises me.

[22:44] <japhb> A side effect of single-arg?

[22:45] <lizmat> and why push/pop do not flatten in any way anymore

[22:46] <lizmat> and not making a Slip flatten because it happens to be in a scalar, is really adding magic

[22:46] * japhb gives that a little time to simmer

[22:47] <timotimo> i kind of expect xx ro behave more like "execute thing on lhs X times"

[22:47] <timotimo> rather than "give me a list with X elements"

[22:47] <japhb> timotimo: Yes, correct.

[22:47] <timotimo> but i do see the reason to have it the other way

[22:47] <timotimo> like in array slice assignment

[22:48] <timotimo> except then it would be xx *

[22:48] <japhb> No, otherwise you couldn't say: sub foo() { Slip(1,2,3) }; my @bar = foo() xx 3.

[22:48] <japhb> And get 9 elements in @bar

[22:49] *** bpmedley joined
[22:49] <lizmat> so looking at "xx N" does not guarantee you get N elements ??

[22:49] <japhb> I'm still not sure I agree that Slip-inside-Scalar should still flatten.

[22:49] <lizmat> I find that suprising and action at a distance

[22:50] *** tokuhiro_ joined
[22:50] <japhb> lizmat: But Slip is the only exception -- and it's the *point* of Slip to be that exception

[22:50] <lizmat> I agree it is the exception, but I think we disagree on how  :-)

[22:50] <japhb> Fair enough.

[22:51] <lizmat> I mean, if you *know* that "foo" returns a Slip with 3 elements, and you want 9, what's the problem in saying foo xx 9 ?

[22:51] *** lolisa joined
[22:51] <lizmat> you *want* 9 elements there or not ?

[22:51] *** n0tjack joined
[22:53] <japhb> Because 'xx N' really means "Execute the thing on the left N times" not "Make an N element list"

[22:53] <japhb> *not "Make an N element list from the thing on the left"

[22:53] <ugexe> m: my @a = 1,2,3,4,5; say @a[*-10] # reports that -5 was used as the index

[22:53] <camelia> rakudo-moar cd7766: OUTPUT«Index out of range. Is: -5, should be in 0..Inf␤  in block <unit> at /tmp/2aQcdiklWg:1␤␤Actually thrown at:␤  in block <unit> at /tmp/2aQcdiklWg:1␤␤»

[22:54] <timotimo> ugexe: that's because it is, though

[22:54] *** tokuhiro_ left
[22:55] <lizmat> japhb: I disagree: in the case of Slip(1,2,3) xx *, you do not specify the number of LHS executions either

[22:55] <lizmat> m: dd Slip(1,2,3) xx *

[22:55] <camelia> rakudo-moar cd7766: OUTPUT«Seq $var = (1, 2, 3, 1, 2, 3, 1, 2, 3, 1...Inf)␤»

[22:55] <timotimo> that looks funny

[22:55] *** firstdayonthejob left
[22:56] <ugexe> m: my @a = 1,2,3,4,5; say @a[*-5..1]; say @a[*-10..1]

[22:56] <camelia> rakudo-moar cd7766: OUTPUT«(1 2)␤()␤»

[22:56] <lizmat> well, FWIW, I am working in GLRifying xx again, and that was the one test that failed originally

[22:56] <lizmat> m: dd Slip(1,2,3) xx *    # expected result in spectest

[22:56] <camelia> rakudo-moar cd7766: OUTPUT«Seq $var = (1, 2, 3, 1, 2, 3, 1, 2, 3, 1...Inf)␤»

[23:00] <japhb> lizmat: I don't understand 'in the case of Slip(1,2,3) xx *, you do not specify the number of LHS executions either' -- What are you contending that the * is indicating?

[23:00] <lizmat> you're asking for an Inf number of elements, not Inf * 3

[23:02] *** TEttinger joined
[23:02] <japhb> lizmat: No, you're asking for an Inf number of executions.  Besides which, Inf * 3 == Inf anyway.  :-)

[23:03] <lizmat> well, I guess we agree to disagree then  :-)

[23:03] <lizmat> anyways, *I* think this is the same kind of issue that caused TimToady to create append/prepend

[23:04] <japhb> I guess I see it as parallel to 'foobarbaz' x N, where the character count depends on the length of the thing on the left.

[23:05] <lizmat> x and xx are different beasts, I think, that's why they're different in Perl 6 in the first place  :-)

[23:05] <lizmat> different operators I mean

[23:06] <japhb> Sure.  But my point is that the concept that the (abstract) length of either x or xx should depend on the corresponding length measure.  xx just has the difference that you care about flattening when determining that length.

[23:07] *** pebbles joined
[23:07] <japhb> They are different operators because the produce different things, but clearly they are intended to fit into nearby slots in the brain, or they would look even more different.

[23:07] <japhb> *they produce

[23:08] *** pebbles left
[23:08] <japhb> There were some missing words from my comment at :06, but hopefully you can pull sense out of it.  :-/

[23:10] <lizmat> yeah, I think it's clear we disagree on how we care about the flattening of Slips  :-)

[23:10] *** edehont joined
[23:11] <japhb> Heh

[23:11] <lizmat> running spectest with my pov now...  :)  seems to cause some breakage

[23:12] *** FROGGS joined
[23:12] <japhb> Is TimToady around this weekend to rule?

[23:12] <timotimo> this weekend to rule them all

[23:12] <lizmat> switching from one pov to the other, is fortunately trivial

[23:13] <lizmat> code wise :-)

[23:17] <lizmat> hmmm.. most of the breakage seems to be cause by This Seq has already been iterated, and its values consumed

[23:18] *** ^elyse^ left
[23:24] *** bbarker`` joined
[23:24] *** bbarker`` is now known as bbarker

[23:30] *** tokuhirom joined
[23:31] <lizmat> ok, many spectests disagree with my view...  :-(

[23:31] <lizmat> so I'll just implement it the "right" way  :-)

[23:34] *** tokuhirom left
[23:51] *** FROGGS left
[23:59] *** bjz_ joined
