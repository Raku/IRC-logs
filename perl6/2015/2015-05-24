[00:02] <timotimo> yes

[00:02] <timotimo> sorry for the AFK

[00:02] <timotimo> then you can get a better look at the backtrace

[00:03] <timotimo> and you can also "print MVM_dump_backtrace(tc)" in the gdb session and get a backtrace of nqp and perl6 code

[00:04] *** kurahaupo1 left
[00:08] *** Ven joined
[00:11] <timotimo> it's important to be in a frame where tc is available; sometimes gdb ends up in the wrong frame for me, but "frame 0" will fix that (almost every innermost frame will have tc, otherwise use "up" to find one that does)

[00:12] *** virtualsue left
[00:13] *** kurahaupo1 joined
[00:16] *** colomon joined
[00:24] *** Sqirrel left
[00:28] *** Ven left
[00:28] *** Sqirrel joined
[00:30] <timotimo> now you've gone AFK on me :)

[00:32] <andreoss> i've rebuilt it but still no debug symbols

[00:33] <andreoss> i should try to put this option into rakudobrew somewhere

[00:55] <timotimo> er, huh?

[00:55] <timotimo> rebuilt and "make install"?

[00:55] <timotimo> can you make sure your "perl6" is pointing at the right moarvm?

[00:56] *** fhelmberger joined
[01:00] *** Sqirrel left
[01:01] *** fhelmberger left
[01:04] *** gfldex left
[01:11] *** itz_ joined
[01:11] *** tinyblak joined
[01:12] *** atta_ joined
[01:13] *** sivoais_ joined
[01:13] *** broquain1 joined
[01:14] *** itz left
[01:14] *** atta left
[01:14] *** sivoais left
[01:14] *** zoosha_ joined
[01:15] *** Brock joined
[01:15] *** awwaiid left
[01:17] *** pochi_ joined
[01:17] *** rvchangue joined
[01:17] *** KotH_ joined
[01:21] *** sivoais_ left
[01:23] *** sivoais joined
[01:28] *** pochi left
[01:28] *** KotH left
[01:30] *** sivoais left
[01:33] *** sivoais joined
[01:33] *** xiaomiao left
[01:35] *** xiaomiao joined
[01:42] *** adu joined
[01:55] *** colomon left
[01:58] *** colomon joined
[02:10] *** adu left
[02:10] *** kurahaupo1 left
[02:18] *** andreoss left
[02:21] *** colomon left
[02:50] *** noganex joined
[02:54] *** noganex_ left
[03:19] *** adu joined
[03:24] *** adu left
[03:40] *** ilbelkyr joined
[03:46] *** FROGGS_ joined
[03:49] *** tinyblak left
[03:50] *** kaare__ joined
[03:50] *** FROGGS left
[03:52] *** vendethiel- left
[04:02] *** deepesh_ joined
[04:06] *** skids joined
[04:10] *** tinyblak joined
[04:53] *** Sqirrel joined
[04:57] *** fhelmberger joined
[05:01] *** fhelmberger left
[05:02] *** cognominal joined
[05:21] *** deepesh_ left
[05:24] *** cognominal left
[05:35] <tadzik> timotimo: on it

[05:35] *** BenGoldberg left
[05:40] *** araujo joined
[05:40] <tadzik> Ok, should be all good

[05:52] *** jack_rabbit left
[05:54] *** jack_rabbit joined
[05:55] *** skids left
[06:09] *** jack_rabbit left
[06:23] *** kaare__ is now known as kaare_

[06:46] <FROGGS[mobile]> o/

[06:47] <raydiak> good morning FROGGS

[06:57] *** fhelmberger joined
[07:01] *** diana_olhovik joined
[07:02] *** fhelmberger left
[07:04] *** vendethiel joined
[07:06] *** kaare_ left
[07:06] <raydiak> good night #perl6 

[07:16] *** kurahaupo1 joined
[07:26] *** darutoko joined
[07:27] *** vendethiel left
[07:29] *** quester joined
[07:38] *** espadrine joined
[07:38] *** cognominal joined
[07:51] *** FROGGS[mobile] left
[07:51] *** cognominal left
[08:03] *** KotH_ is now known as KotH

[08:23] <masak> antenoon, #perl6

[08:26] <nwc10> good *, masak

[08:30] *** adu joined
[08:31] *** adu left
[08:32] *** rindolf joined
[08:35] *** kurahaupo1 left
[08:42] *** domidumont joined
[08:45] *** domidumont left
[08:46] *** domidumont joined
[08:51] *** eli-se joined
[08:58] *** quester left
[09:00] *** kaare_ joined
[09:02] *** virtualsue joined
[09:06] *** RabidGravy joined
[09:09] *** vendethiel joined
[09:13] *** virtualsue left
[09:16] *** virtualsue joined
[09:16] <dalek> perl6.org: d1e3d0e | paultcochrane++ | source/documentation/index.html:

[09:16] <dalek> perl6.org: Make documentation location a bit more obvious

[09:16] <dalek> perl6.org: review: https://github.com/perl6/perl6.org/commit/d1e3d0e9ce

[09:16] * masak pre-cmmits to blogging today

[09:16] <masak> commits*

[09:17] <masak> ...with fewer typos than in my /me statements :P

[09:17] <Juerd> Does the search box work for anyone, on doc.perl6.org?

[09:18] <dalek> doc: 5a2cebc | paultcochrane++ | lib/Type/IO/Path.pod:

[09:18] <dalek> doc: Correct minor typo

[09:18] <dalek> doc: review: https://github.com/perl6/doc/commit/5a2cebc7ac

[09:18] <masak> Juerd: works here. searched for 'Array': http://doc.perl6.org/type/Array

[09:19] <Juerd> Ah, there's no feedback when nothing's found, but it does work!

[09:20] <masak> Juerd: please submit an issue about that, kthx

[09:20] *** Alina-malina left
[09:20] *** Alina-malina joined
[09:23] * [ptc] thinks unary hyperoperators rock

[09:23] <[ptc]> just had to say that...

[09:24] <masak> [ptc]: there's something interesting going on in that area, for sure.

[09:24] <masak> [ptc]: jQuery manages to hyperthread over a collection without *any* extra syntax! o.O

[09:25] <masak> (or put differently, jQuery just assumes everything happens inside the List monad)

[09:25] <Juerd> masak: jQuery's silent acceptance of empty collections is annoying, though!

[09:25] <[ptc]> masak: it simplifies the code so much, it's *very* nice to use

[09:25] <masak> Juerd: I only find it annoying on a theoretical level. it's never bothered me in practice.

[09:25] <masak> Juerd: in the cases where I do care, I check for length == 0

[09:26] <[ptc]> masak: reminds me of how one used to have to program Matlab before Matlab got JIT: one *had* to think in terms of vectors in order to have reasonably fast code

[09:26] <Juerd> masak: It's annoying when you meant to match exactly one thing, and you got none

[09:26] <Juerd> $("#foo").bar()

[09:26] *** eli-se left
[09:26] <Juerd> That will just silently do nothing if there is no #foo.

[09:26] <Juerd> While to human readers it's absolutely clear that you meant to match exactly 1 element.

[09:26] <masak> Juerd: sounds like you could use a jQuery plugin .guard() or something, that makes sure something is there, or else dies in a fire.

[09:27] <Juerd> masak: I've been thinking about extending the selector syntax

[09:27] <masak> hm.

[09:27] <Juerd> $("1 #foo"), $("+ .bar"), $("* a")

[09:27] <masak> maybe just add a different method to do selection, but keep the selector syntax?

[09:28] *** gfldex joined
[09:28] <Juerd> * is in use, but the only thing that isn't in * is <html> itself, so only for "* html" it would work slightly differently (it would suddenly match, while normally it shouldn't)

[09:28] <masak> $.selectOne("#foo")

[09:29] <Juerd> masak: In all the jQuery code I've ever written, selecting 1 or + would happen more than *, so a named method would be poor huffman coding

[09:30] <Juerd> In fact, defaulting to + would make sense to me.

[09:30] <masak> $$("#foo")

[09:30] <Juerd> That looks like 2 or more.

[09:30] <masak> hehe

[09:30] <masak> $1("$foo")

[09:31] <Juerd> I don't think you can do that in javascript. Let's try.

[09:31] <Juerd> $1 is a reserved thingy.

[09:31] <masak> I didn't get an error in Chrome Dev console, but the variable doesn't seem to stick, either

[09:32] <Juerd> My Chromium console says $1 is not a function

[09:32] <masak> I think there might be interference with "special" variables that Chrome dev env keeps.

[09:32] <Juerd> When trying to call it, there is

[09:32] <masak> need to try it in a script in the browser.

[09:32] <Juerd> s/there/that/

[09:33] *** vendethiel left
[09:33] <masak> indeed. works in a script in an HTML file.

[09:34] <masak> var $1 = function(s) { alert(s) }; $1("OH HAI"); // alerts "OH HAI"

[09:35] <Juerd> Wow.

[09:41] *** virtualsue left
[09:42] *** Ven joined
[09:43] *** vendethiel joined
[09:54] *** smls joined
[10:00] *** burnersk left
[10:00] *** [ptc] left
[10:08] <smls> Am I imagining that there was some easy&elegant way to 'merge' pair lists into a hash of arrays? I can't remember what is was...

[10:08] <smls> I.e. given something like   (a => 1, a => 2, b => 3)   produce   { a => [1, 2], b => [3] }

[10:08] <smls> (or alternatively   { a => [1, 2], b => 3 }   since items can be treated as single-element lists so it doesn't make much difference.)

[10:09] <smls> going the .classify route ends up being more messy/unelegant then I would like

[10:10] <smls> m: say (a => 1, a => 2, b => 3).Mix.perl

[10:10] <camelia> rakudo-moar 800f70: OUTPUT«("a"=>3,"b"=>3).Mix␤»

[10:10] <smls> ^^ something more like this would be nice, except pushing instead of adding.

[10:13] <smls> Ah, I was probably thinking of .Hash::push

[10:13] <smls> m: my %a; %a.push($_) for (a => 1, a => 2, b => 3); say %a.perl

[10:13] <camelia> rakudo-moar 800f70: OUTPUT«{:a([1, 2]), :b(3)}<>␤»

[10:14] <smls> Not very functional though :(

[10:16] <smls> m: say (a => 1, a => 2, b => 3).reduce({ $^a.hash.push: $^b }).perl

[10:16] <camelia> rakudo-moar 800f70: OUTPUT«{:a([1, 2]), :b(3)}<>␤»

[10:16] <smls> ^^ I suppose this works...

[10:17] <smls> Alright, gonna stop spamming the channel with my monologue now :P

[10:30] *** sue__ joined
[10:48] *** mj41 joined
[11:11] *** [ptc] joined
[11:19] *** rindolf left
[11:30] <itz_> isn't smoke.perl6.org "stuck"?

[11:37] *** Gothmog_ joined
[11:41] *** Bucciarati joined
[11:43] *** rindolf joined
[11:46] *** diana_olhovik left
[12:06] <dalek> perl6.org: ab98067 | paultcochrane++ | source/community/index.html:

[12:06] <dalek> perl6.org: Mention smoke.perl6.org on the community page.

[12:06] <dalek> perl6.org: review: https://github.com/perl6/perl6.org/commit/ab98067ec9

[12:07] <[ptc]> come to think of it, what's the difference between testers.perl6.org and smoke.perl6.org?

[12:07] <masak> the Type Hints PEP is accepted. https://news.ycombinator.com/item?id=9592637

[12:07] <[ptc]> both show the testing status of the modules in the ecosystem, right?

[12:08] <Ven> masak: http://irclog.perlgeek.de/perl6/2015-05-23#i_10647134 :P

[12:10] *** kshannon left
[12:11] *** kshannon joined
[12:12] *** kshannon left
[12:12] <smls> m: say (2, 4, 6, 8).rotor(2, -1).perl

[12:12] <camelia> rakudo-moar 800f70: OUTPUT«((2, 4), (), (4, 6), (), (6, 8), ())␤»

[12:12] <smls> ^^ Where are the empty parcels coming from?

[12:14] *** tinyblak left
[12:14] <lizmat> smls: good question

[12:15] <lizmat> I was just looking at your classification problem  :-)

[12:16] <smls> :)

[12:16] <smls> should I rekudobug the rotor thing?

[12:16] <lizmat> not yet, let's see if I can fix that in the next 20 mins or so

[12:17] <smls> ok

[12:17] *** BenGoldberg joined
[12:17] <lizmat> $ 6 'my %h = (a => 1, a => 2, b=> 3).classify(*.key, :what(*.value)); say %h.perl

[12:18] <lizmat> {:a([1, 2]), :b([3])}<>

[12:18] <lizmat> smls: that's what you were looking for, right ?

[12:18] <smls> yes

[12:18] <lizmat> perhaps :what should be called :as

[12:19] <Ven> m: say (^50).classify(* % 3).perl

[12:19] <camelia> rakudo-moar 800f70: OUTPUT«Cannot call infix:<===>(Any, Mu); none of these signatures match:␤    (Any $?)␤    (Any $a, Any $b)␤    (Int:D \a, Int:D \b)␤    (int $a, int $b)␤    (Num:D \a, Num:D \b)␤    (Num $ where { ... }, Num $ where { ... })␤    (num $a, num $b --> …»

[12:19] *** berekuk joined
[12:19] *** berekuk left
[12:20] *** laouji joined
[12:21] <smls> lizmat: :as is used in .squish for something different

[12:21] <smls> though maybe .squish's :as should be changed to :by, to match .sort

[12:24] <lizmat> keeping :as for now, we can bikeshed it later, when TimToady is around again

[12:24] <lizmat> or scrap altogether if it feels like adding too much functionality

[12:26] <smls> m: say (2, 10, 1).sort :by(~*); say (2, 10, 1).sort(~*)

[12:26] <camelia> rakudo-moar 800f70: OUTPUT«1 2 10␤1 10 2␤»

[12:26] <smls> Hm, I thought the adverb form was allowed there

[12:27] *** spider-mario joined
[12:28] <smls> .classify(by => *.key, as => *.value)  reads quite nicely I think ;)

[12:29] *** colomon joined
[12:30] <dalek> rakudo/nom: 922bcf0 | lizmat++ | src/core/ (2 files):

[12:30] <dalek> rakudo/nom: Introduce :as parameter to classify

[12:30] <dalek> rakudo/nom: 

[12:30] <dalek> rakudo/nom: Use case:

[12:30] <dalek> rakudo/nom: my %h = (a => 1, a => 2, b=> 3).classify(*.key, :what(*.value)); say %h.perl

[12:30] <dalek> rakudo/nom: {:a([1, 2]), :b([3])}<>

[12:30] <dalek> rakudo/nom: 

[12:30] <dalek> rakudo/nom: Inspired by smls++'s comments at:

[12:30] <dalek> rakudo/nom:   http://irclog.perlgeek.de/perl6/2015-05-24#i_10648933

[12:30] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/922bcf06bd

[12:30] <lizmat> if this gets consensus, .categorize will probably need the same treatment

[12:31] <lizmat> but I'm leaving that out in the open, as I'm not writing any tests for it either yet

[12:31] <lizmat> Oops, I left the :what in the commit message

[12:31] <lizmat> anyways, the intent should be clear  :-)

[12:32] <lizmat> smls: I think '.classify(*.key, as => *.value)' also reads nicely

[12:33] <smls> squish could get something similar as well, to let you specify a replacement element for a squished sequence instead of always replacing it with its first element.

[12:33] <Ven> lizmat: why does the commit message mention ":as"?

[12:33] <Ven> sounds like a typo on the first line :)

[12:33] <lizmat> Ven: because that's what I implemented

[12:33] <lizmat> the :what is the typo

[12:33] <Ven> ah, alright, thanks

[12:33] <Ven> lizmat++ # I agree that mapping over a list of Pairs/a hash maybe could be easier

[12:36] <smls> (a => 1, a => 2, b=> 3).squish(*.key, :as => { $(@_) })   # same as the classify example but returning a list with preserved order rather than a hash?

[12:37] *** colomon left
[12:37] *** colomon joined
[12:38] *** koo6 left
[12:38] *** domidumont left
[12:39] <smls> m: say (2, 4, 6, 8).rotor(2 => -1).perl

[12:39] <camelia> rakudo-moar 800f70: OUTPUT«((2, 4), (4, 6), (6, 8))␤»

[12:39] <smls> ah, rotor works after all, i just mistakenly used , instead of => above

[12:40] <lizmat> ah!

[12:40] <lizmat> but in interesting WAT nonetheles

[12:40] <lizmat> *an

[12:40] <mj41> Hi. I just finished roast-data chart. https://github.com/mj41/Perl6-Analytics-results/blob/master/slides/mj41-brnopm-prev2.md#id-tests ... Does any other chart exist?

[12:40] <lizmat> *nonetheless

[12:40] <mj41> coke++ for roast-data repo

[12:41] <smls> lizmat: maybe it should warn when given a negative cycle length?

[12:43] <smls> after all, when you really want the current behavior you could specify it using two cycles instead:

[12:43] <smls> m: say (2, 4, 6, 8).rotor(2, 0 => -1).perl

[12:43] <camelia> rakudo-moar 800f70: OUTPUT«((2, 4), (), (4, 6), (), (6, 8), ())␤»

[12:44] *** tinyblak joined
[12:44] <lizmat> yeah, so it should die with <1  as cycle length

[12:45] <lizmat> unfortunately, we would need to check the cycle in advance for -1

[12:47] <smls> another small WAT about the rotor function is that when called without arguments, it never finishes

[12:47] <smls> maybe it assumes a cycle length of zero?

[12:48] <smls> s/function/method/

[12:50] *** tinyblak_ joined
[12:53] *** tinyblak left
[12:53] *** sue__ left
[12:54] <lizmat> $ 6 'say (2, 4, 6, 8).rotor(2, -1).perl'

[12:54] <lizmat> ===SORRY!===

[12:54] <lizmat> Cannot have elems < 1, did you mean to specify a Pair with => -1?

[12:54] <lizmat> $ 6 'say (2, 4, 6, 8).rotor.perl'

[12:54] <lizmat> Must specify *how* to rotor a List

[12:54] <smls> lizmat++

[12:57] <lizmat> hmmm... feels overdone to create a seperate MMD candidate for that, if rotor(my @) would hang

[13:00] <dalek> rakudo/nom: b9b7f4c | lizmat++ | src/core/List.pm:

[13:00] <dalek> rakudo/nom: Put some sanity testing in List.rotor, smls++

[13:00] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/b9b7f4c9c4

[13:02] *** [ptc]_ joined
[13:02] *** burnersk joined
[13:03] <smls> .oO(  *@slurpy  --->  +@nonempty-slurpy  )

[13:04] *** colomon left
[13:08] <lizmat> hmmm... seems I broke something

[13:10] <masak> hehe. I've trained my brain to genuinely not care about the (alleged) nuanced differences between "weak typing" and "dynamic typing". which means I can skip large parts of the HN thread discussion. :P

[13:11] <masak> anyway, verdict: Python is going the TypeScript route. typing gets done at the tooling layer. color me interested.

[13:11] <masak> well, um, Python 3.x, that is. *cough*

[13:11] *** telex left
[13:12] *** telex joined
[13:13] *** Vlavv joined
[13:15] *** [ptc] left
[13:15] *** [ptc]_ is now known as [ptc]

[13:16] * moritz thinks that having "type hints" instead of type constraints is a mistake

[13:16] *** BenGoldberg left
[13:16] <lizmat> m: ((@) xx *)[0]   # interesting way of hanging yourself

[13:17] *** BenGoldberg joined
[13:17] <camelia> rakudo-moar 922bcf: OUTPUT«(timeout)»

[13:17] *** smls left
[13:17] <lizmat> perhaps xx should check for empty lists

[13:17] <vendethiel> m: say @

[13:17] <camelia> rakudo-moar 922bcf: OUTPUT«␤»

[13:18] <lizmat> m: say state @

[13:18] <camelia> rakudo-moar 922bcf: OUTPUT«␤»

[13:19] <dalek> rakudo/nom: 93e61dc | lizmat++ | src/core/List.pm:

[13:19] <dalek> rakudo/nom: Handle checking for infinite lists

[13:19] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/93e61dcb8b

[13:24] *** Ven left
[13:25] <masak> moritz: it is whenever one writes the type hints without validating/asserting them.

[13:25] <lizmat> m: Hash[Any,Any].new.perl   # golfed vendethiel++ problem with .classify

[13:25] <camelia> rakudo-moar b9b7f4: OUTPUT«Cannot call infix:<===>(Any, Mu); none of these signatures match:␤    (Any $?)␤    (Any $a, Any $b)␤    (Int:D \a, Int:D \b)␤    (int $a, int $b)␤    (Num:D \a, Num:D \b)␤    (Num $ where { ... }, Num $ where { ... })␤    (num $a, num $b --> …»

[13:31] *** bjz left
[13:32] <dalek> rakudo/nom: 0f0e73f | lizmat++ | src/core/Hash.pm:

[13:32] <dalek> rakudo/nom: Fix Hash[Any,Any].new.perl failure, vendethiel++

[13:32] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/0f0e73f65a

[13:32] <vendethiel> lizmat++

[13:35] *** eli-se joined
[13:36] *** burnersk left
[13:36] *** [ptc] left
[13:36] <moritz> masak: well, the "asserting" part should be automatical

[13:37] *** burnersk joined
[13:37] *** [ptc] joined
[13:38] *** burnersk left
[13:38] *** [ptc] left
[13:38] <moritz> masak: IME the possiblity of type annotations is just too tempting, so too many folks will use them even though they don't (or can't, because they don't have the tooling) verify them

[13:39] <masak> moritz: I wonder why that is.

[13:39] <masak> a sense of wanting to be descriptive and tidy, perhaps?

[13:40] *** [ptc] joined
[13:40] *** burnersk joined
[13:41] <Juerd> Heck, there are people who insist on using Perl 5 prototypes on methods, even if they know it's utterly useless.

[13:41] <moritz> masak: yes, and the feeling of providing some sort of extra safety, even if it'll only work in an imagined future where type checking is on by default

[13:42] *** araujo left
[13:43] <lizmat> afk&

[13:43] <masak> hm.

[13:43] <vendethiel> Juerd: don't prototypes change the parsing rules?

[13:44] <vendethiel> oh, they don't for a->b()

[13:44] <moritz> vendethiel: not for methods

[13:44] <vendethiel> alright

[13:44] * vendethiel thought people stopped using prototypes altogether, except for \

[13:44] <masak> so maybe Python should have gone more the TypeScript route, encouraging/forcing people to write in a "TypeThon" superset of the language, whose tools are mandatory or at least hard to turn off.

[13:44] <moritz> masak: we've had that in Perl 6 land; people wrote types on their routine declarations, and when we enforced them, turned out that about a quarter of them were wrong

[13:44] *** burnersk left
[13:45] <masak> *nod*

[13:45] <Juerd> Never have any dead code, even if it's just declarations.

[13:45] <Juerd> At the very best, it will have been correct at one point but gets out of sync.

[13:46] *** [ptc] left
[13:46] <masak> was gonna say. it's tempting fate to write anything that never runs as it's authored.

[13:46] <vendethiel> "comments = dead code" :P

[13:46] <masak> writing things test-first kind of breaks one out of that bad habit a little.

[13:46] <Juerd> I've written Perl 6 code long before there was any implementation to test my code, and I'm quite sure that none of it would even compile... :D)

[13:46] <vendethiel> 0xD34DC0D3

[13:46] <Juerd> s/\)//

[13:47] <vendethiel> Juerd: depends, which perl6? :)

[13:47] <Juerd> vendethiel: Comments aren't code

[13:47] <Juerd> vendethiel: The postapocalyptic one.

[13:48] <Juerd> I don't remember if it was presynoptic.

[13:49] <dalek> doc: 90b5c64 | moritz++ | lib/Pod/Htmlify.pm6:

[13:49] <dalek> doc: htmlify: Always explicitly link to the gh repo in the footer

[13:49] <dalek> doc: 

[13:49] <dalek> doc: Closes #85.

[13:49] <dalek> doc: review: https://github.com/perl6/doc/commit/90b5c640d2

[13:49] <Juerd> moritz++ \o/

[13:49] <moritz> Juerd++ # reporting doc.perl6.org bugs

[13:50] *** tinyblak_ left
[13:50] <moritz> though currently, rebuild of doc is broken anyway :(

[13:51] <moritz> because it has an old-ish rakudo installed, which doesn' understand the 'unit' declarator :(

[13:51] *** [ptc] joined
[13:51] *** burnersk joined
[13:51] *** [ptc] left
[13:51] *** burnersk left
[13:51] * moritz rakudobrews

[13:52] <moritz> last successful build was 2015-05-16

[13:52] *** [ptc] joined
[13:52] *** burnersk joined
[13:54] *** Sqirrel left
[13:55] <moritz> wow, that was quick :-)

[13:56] *** Sqirrel joined
[13:56] *** koo6 joined
[14:06] *** flussenc1 joined
[14:07] *** flussenc1 left
[14:07] *** flussence joined
[14:17] *** BenGoldberg left
[14:17] *** BenGoldberg joined
[14:20] *** [ptc] left
[14:20] *** burnersk left
[14:23] *** [ptc] joined
[14:23] *** [ptc] left
[14:24] *** [ptc] joined
[14:24] *** burnersk joined
[14:26] <Ulti> Stage parse      : 28198.047    the miracles of standby

[14:27] *** flaviusb left
[14:31] <dalek> doc: 8cf8c22 | moritz++ | type-graph.txt:

[14:31] <dalek> doc: X::OS is Exception

[14:31] <dalek> doc: review: https://github.com/perl6/doc/commit/8cf8c227da

[14:40] *** colomon joined
[14:45] *** bbkr joined
[14:48] <mj41> 12 months: lizmat++ > jnthn++ :-) https://github.com/mj41/Perl6-Analytics-results/blob/master/slides/mj41-brnopm-prev2.md#id-top30-12

[14:52] <moritz> mj41: you might want to include perl6/doc in the analysis

[14:52] <moritz> (especially if you want to boost my ranking :-) )

[14:54] <mj41> moritz: ok, np ... see https://github.com/mj41/Perl6-Analytics/tree/master/data

[14:56] <dalek> doc: bb4bd0e | moritz++ | type-graph.txt:

[14:56] <dalek> doc: Type graph: control exceptions

[14:56] <dalek> doc: review: https://github.com/perl6/doc/commit/bb4bd0e183

[14:59] *** fhelmberger joined
[15:00] <moritz> Juerd: the doc.perl6.org has now been rebuilt

[15:04] *** fhelmberger left
[15:10] <mj41> moritz: it's already there https://github.com/mj41/Perl6-Analytics/blob/master/data/projects-final.json#L1006

[15:10] <mj41> 697 commits by you

[15:10] <tadzik> Hmm, someone called?

[15:11] <mj41> moritz: all in grey color are not shown in legend

[15:11] *** eli-se left
[15:17] *** BenGoldberg left
[15:17] *** Ben_Goldberg joined
[15:28] *** skids joined
[15:28] *** grondilu joined
[15:28] *** laouji left
[15:32] *** eli-se joined
[15:45] *** [TuxCM] joined
[15:51] *** [Tux] left
[15:54] *** Khisanth left
[15:54] *** [Tux] joined
[15:56] *** [TuxCM] left
[15:58] <japhb> Anyone know if there's a plan to get coercive types for class attributes?  e.g.  class Foo { has Int() $.v; }

[16:00] *** Khisanth joined
[16:01] *** rindolf left
[16:01] <FROGGS_> hmmmm, that might not even be too hard

[16:04] *** rindolf joined
[16:05] *** colomon left
[16:08] * mst hates class attributes so much

[16:08] <mst> if you make them easy, people use them for global variables all over the place

[16:09] <mst> and then congratulate themselves on not using globals

[16:09] *** diana_olhovik joined
[16:10] <jnthn> confusing, has declared an instance attribute :P

[16:10] <yoleaux> 23 May 2015 15:34Z <Ven> jnthn: typing "s" in the debugger gives me (with --ll-exception) this stack trace: https://gist.github.com/vendethiel/80b612785402162de022 . It also seems, when stepping (via enter) that the "grammar mode" (that shows which part matched already/didn't match yet) is not appearing anymore

[16:10] <jnthn> *declares

[16:10] <timotimo> o/

[16:10] <jnthn> japhb: Yes, eventually

[16:11] *** liztormato joined
[16:11] *** itz2 joined
[16:11] <liztormato> mst: I don't think that is what japhb  means

[16:12] <mst> oh, right

[16:12] <mst> he said 'class attribute' but didn't actually meant 'class attribute'

[16:12] <mst> never mind then

[16:12] <jnthn> "my $.foo" gets you a class attribute, fwiw :)

[16:12] <mst> well, please apply my rage to that syntax then, or something ;)

[16:12] <leedo_> i was just wondering how you'd even get a class attribute, jnthn++

[16:12] <jnthn> People who are bad enough at software design will find a way to re-invent global variables in any language. :)

[16:12] <timotimo> what if it doesn't have a .? just means there's no accessor?

[16:12] <jnthn> timotimo: Then it's just a normal lexical :)

[16:13] <timotimo> right, but its lifetime will remain bound to the class, i.E. it will not be cloned?

[16:14] <jnthn> timotimo: Correct.

[16:14] <jnthn> Whereas if it's in a role you get one per composition of the role

[16:14] *** liztormato_ joined
[16:14] <liztormato_> I find that almost as confusing as "has $a" to mean "has $!a"

[16:14] *** ggoebel joined
[16:15] <jnthn> I think that one is a sop to the twigil-fearers :)

[16:16] <liztormato_> Yeah. And I still feel we should get past that. It is inconsistent I think

[16:16] <timotimo> i don't like "has $a", either

[16:17] *** liztormato left
[16:17] *** liztormato_ is now known as liztormato

[16:18] <jnthn> It doesn't bother me enough to want to be rid of it :)

[16:18] *** Khisanth left
[16:19] <liztormato> Cycling some more&

[16:19] *** liztormato left
[16:19] * nwc10 misread twigil-fearer as twigil-farmer, and was imagining folks in unlit rooms breeding symbols to sell on to time (or typing) poor programmers

[16:19] *** Khisanth joined
[16:19] * jnthn has a hungry

[16:19] <nwc10> make with the noms!

[16:20] <jnthn> I think we'll go out. :)

[16:20] <jnthn> And since I got up at 4:30am today, I'll probably sleep after. I'll have some tuits tomorrow though :)

[16:21] <nwc10> you're doing better than I would. I'd stil have a sleep deficit

[16:21] <jnthn> I still do, but doesn't stop me being hungry :)

[16:21] <jnthn> anyways, bbt :)

[16:21] <nwc10> oh, I meant tomorrow

[16:21] <jnthn> oh :)

[16:21] <nwc10> and yes, enjoy food

[16:21] <jnthn> Well, we'll see :)

[16:21] <jnthn> o/

[16:21] <timotimo> o/

[16:30] <mst> I thought $a was going to reliably be a lexical, i.e. a 'my' variable

[16:30] <mst> and then $!a was an object attr

[16:30] <mst> how do I tell the difference between 'has $a' and 'my $a' where $a is being used otherwise?

[16:36] *** itz2 left
[16:38] *** colomon joined
[16:41] <moritz> mst: you don't; hence it's best practise to use the ! form for attrs

[16:41] *** skids left
[16:48] *** Khisanth left
[16:48] *** Khisanth joined
[16:56] <Ulti> ooc what is the fastest form of loop in Rakudo?

[16:56] <Ulti> assuming I am doing something super tight and numeric rather than iterating a list

[16:59] *** Khisanth left
[16:59] *** Khisanth joined
[17:01] *** colomon left
[17:02] *** colomon joined
[17:03] <mst> moritz: which makes me feel like I dislike it for the same reasons as lizmat

[17:04] <mst> jnthn: if anybody does get annoyed enough to offer a patch to remove it, consider me to've +1'ed the idea, for what little it's worth :)

[17:09] *** Khisanth left
[17:09] *** domidumont joined
[17:10] <masak> `has $a;` is something I would never write in my own code. I don't mind having it in the language, though. maybe someone will absolutely love it.

[17:11] <masak> m: class C { has $a }; say C.^attrs

[17:11] <camelia> rakudo-moar 0f0e73: OUTPUT«Method 'attrs' not found for invocant of class 'Perl6::Metamodel::ClassHOW'␤  in block <unit> at /tmp/8iYOtpMutl:1␤  in any <unit-outer> at /tmp/8iYOtpMutl:1␤␤»

[17:11] <masak> m: class C { has $a }; say C.^attributes

[17:11] <camelia> rakudo-moar 0f0e73: OUTPUT«Mu $!a␤»

[17:12] <masak> ooh, the MOP still calls it '$!a'. I suppose that's good news for people who do .substr(2) to get the post-twigil name. :P

[17:13] *** Khisanth joined
[17:14] *** ggoebel left
[17:14] *** ShimmerFairy joined
[17:16] *** laouji joined
[17:21] *** laouji left
[17:27] *** Khisanth left
[17:28] *** Khisanth joined
[17:30] <moritz> m: class C { has $a; method f { $!a } };

[17:30] <camelia> rakudo-moar 0f0e73: ( no output )

[17:30] <moritz> oh, and $!a is still available

[17:30] <mst> this feature just gets better and better

[17:30] <moritz> :/

[17:31] * moritz would not object to removing it

[17:33] <moritz> there are a few uses in the ecosystem

[17:34] <moritz> Text::Emotion, Net::IRC, bioperl, perl6parsing, hinges, db-orm-quicky

[17:35] <dalek> doc: 39908b7 | moritz++ | lib/Language/functions.pod:

[17:35] <dalek> doc: Avoid unidiomatic use of "has $no-twigil" in unrelated example

[17:35] <dalek> doc: review: https://github.com/perl6/doc/commit/39908b7b69

[17:36] *** xfix joined
[17:36] * grondilu thinks 'has $a' is fine

[17:36] <masak> $!a still being available under `has $a` is by spec.

[17:36] <masak> the other way around doesn't work, though.

[17:36] <Juerd> I'm fond of 'has $a'

[17:36] <masak> I suggest not removing it before conferring with TimToady++, who usually has something deep to say about things like this.

[17:37] <Juerd> The use case I have in mind, is easy switching between class and instance attribute if you change your mind later, which I tend to do.

[17:37] <Juerd> And I find the ! twigil ugly :P

[17:38] * vendethiel always finds the ! twigil *very* confusing, and misreads "!$!x" often

[17:38] *** xinming joined
[17:39] <eli-se> good thing you don't need $! as there's more than one way to do it!

[17:39] * grondilu likes the $! twigil

[17:40] <grondilu> but I think it can be implicit during declaration.

[17:40] *** colomon left
[17:40] *** mj41 left
[17:41] *** Khisanth left
[17:41] <Juerd> vendethiel: Yes, in my mind, ! is still something that negates.

[17:41] <Juerd> $!apple reads almost like $banana

[17:42] *** Khisanth joined
[17:43] <eli-se> have a snapple

[17:46] *** khisanth_ joined
[17:46] *** Khisanth left
[17:51] *** khisanth_ left
[17:52] *** spider-mario left
[17:53] *** Ven joined
[17:59] *** mj41 joined
[18:00] *** khisanth_ joined
[18:07] <ugexe> Can I fire off a Proc::Async from a different directory without changing my script's CWD? Like Proc::Async.new("/home/ugexe","ls")... with `shell` I would do shell("(cd /home/ugexe && ls)")

[18:08] * japhb returns from @family-related distractions

[18:08] <japhb> mst: As a couple people mentioned, I did indeed mean instance attribute, not class attribute, because tired

[18:09] <mst> japhb: aye. no worries.

[18:10] <japhb> As for the 'has $a' debate, while I personally don't favor it, I understand Juerd's point.  The only thing in the above (skimmed) discussion I found worrying is the $!a still being available.

[18:10] <japhb> * Juerd's point*s*

[18:12] *** khisanth_ left
[18:12] *** khisanth_ joined
[18:13] <lizmat> m: class A { has $a; my $.a = 42}; A.new.a.say   # I'm not sure I want to understand this one

[18:13] <camelia> rakudo-moar 0f0e73: OUTPUT«42␤»

[18:14] <masak> m: class A { has $a }; say A.^attributes[0].^methods

[18:14] <camelia> rakudo-moar 0f0e73: OUTPUT«<anon> <anon> <anon> <anon> <anon> <anon> <anon> <anon> <anon> <anon> <anon> <anon> <anon> <anon> <anon> <anon> <anon> <anon> compose apply_handles get_value set_value container has-accessor readonly package inlined WHY set_why Str gist␤»

[18:15] <masak> m: class A { has $a }; say A.^attributes[0].has-accessor

[18:15] <camelia> rakudo-moar 0f0e73: OUTPUT«False␤»

[18:15] <masak> lizmat: looks like a bug to me.

[18:15] <jdv79> [ptc]: i think smoke and testers could be unified

[18:15] <dalek> rakudo/nom: 24aca6a | lizmat++ | src/core/ (2 files):

[18:15] <dalek> rakudo/nom: List|Parcel.eager should only work on instances

[18:15] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/24aca6a89d

[18:15] <jdv79> .seen tony-o

[18:15] <yoleaux> I saw tony-o 12 May 2015 02:55Z in #perl6: <tony-o> i used fluxbox up until trying xfce a couple of months ago

[18:16] *** egrep left
[18:16] <jdv79> .tell tony-o HTML::Parser::XML seems broken and/or super slow

[18:16] <yoleaux> jdv79: I'll pass your message to tony-o.

[18:16] *** egrep joined
[18:17] <lizmat> vendethiel: my last commit still didn't fix "my %h = classify { "foo" }, ()"

[18:17] <lizmat> it looks like it's getting an instantiated Parcel without the $!storage defined  :-(

[18:19] <jdv79> when will all this "churn" be over?  its hard to do anything without running into ruins:(

[18:19] <Ven> lizmat: I wasn't the one using it at first :)

[18:20] <Ven> I just tried to reduce the sample

[18:20] <lizmat> m: my %h = ().classify({"foo"}); say %h.perl   # works fine

[18:20] <camelia> rakudo-moar 0f0e73: OUTPUT«Cannot look up attributes in a type object␤  in block <unit> at /tmp/2JHExcz2eR:1␤  in any <unit-outer> at /tmp/2JHExcz2eR:1␤␤»

[18:21] <lizmat> no?

[18:21] <tony-o_> jdv79: i think it's the deprec warnings that make it extra slow

[18:21] *** laouji joined
[18:21] <jdv79> well, i tried to load up yahoo.com and it took maybe 45s

[18:21] <jdv79> and then i tried to load up a few other sites and it never stopped - i killed after 5 mins

[18:22] <lizmat> jdv79: deprecation warnings generate backtraces for each warning: they're expensive!

[18:22] <lizmat> (although less expensive than they used to be)

[18:22] <jdv79> how do i know if that's what is causing the seemingly never ending processing?

[18:22] <jdv79> strace said just mem (brk)

[18:23] <tony-o_> jdv79: i have an open issue on it that i'm working on right now where it broke bc of the changes to Nil

[18:23] <jdv79> the one on the test i submitted?

[18:23] <lizmat> jdv79: if Deprecation.report -> $deprecations { say $deprecations }

[18:23] <tony-o_> oh you did open that

[18:24] <jdv79> yeah, that got it to install but after that then i ran into molasses at runtime

[18:24] <jdv79> maybe i'll poke at it later

[18:24] <grondilu> std: if Bool.pick -> $x {...}

[18:24] <camelia> std 28329a7: OUTPUT«Potential difficulties:␤  $x is declared but not used at /tmp/OnlbfnZArO line 1:␤------> 3if Bool.pick -> 7⏏5$x {...}␤ok 00:00 139m␤»

[18:24] <jdv79> lizmat: thanks. i'll try it later.

[18:24] <jdv79> gotta run

[18:26] <grondilu> m: while (^10).pick -> $p { say $p }

[18:26] *** laouji left
[18:26] <camelia> rakudo-moar 0f0e73: OUTPUT«6␤4␤6␤»

[18:26] <grondilu> so I guess I can use that syntax for http://rosettacode.org/wiki/Temperature_conversion#Perl_6

[18:28] *** khisanth_ left
[18:28] *** khisanth__ joined
[18:29] <lizmat> grondilu: I'm surprised to see that while loop end

[18:29] *** kaare__ joined
[18:29] <lizmat> I think that's a bug

[18:29] <Ven> m: say (^10).roll(50)

[18:29] <camelia> rakudo-moar 0f0e73: OUTPUT«3 2 4 2 3 7 1 4 1 1 1 5 0 8 5 2 4 0 7 1 8 5 9 2 9 8 4 3 8 9 2 4 8 8 1 3 0 5 7 6 2 7 2 8 7 0 9 9 9 8␤»

[18:29] <Ven> m: say any((^10).roll(50)) == 0 # what's wrong?

[18:29] <camelia> rakudo-moar 0f0e73: OUTPUT«any(False, True, False, False, False, False, False, False, True, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, True, False, False, False, True, False, False, False, Fals…»

[18:30] <lizmat> Ven: either it should run 10 times, or it should run indefinitely

[18:30] <Ven> I don't get why it should do that? .pick should just pick one of the possible value and return it

[18:31] <lizmat> yes, but it will *always* be a true value, so by that reasoning it should run indefinitely

[18:31] <lizmat> or it should run until exhausted

[18:31] <grondilu> doesn't it stop when it returns 0?

[18:31] <Ven> ? ^10 means 0..9

[18:31] <lizmat> ah, duh

[18:31] <lizmat> *sigh*

[18:32] *** smls joined
[18:32] <grondilu> maybe we need a prefix for 1..$n

[18:32] <Ven> good thing it's so easy to add :)

[18:32] *** khisanth__ left
[18:33] <lizmat> ^^10 would be 0^..^10

[18:33] *** kaare_ left
[18:33] * Ven 's grip with "^" is mostly precedence, but that can't be fixed

[18:36] <Ven> m: augment class Int { method cir { ^self } }; say 5.reduce(2* *)

[18:36] <camelia> rakudo-moar 0f0e73: OUTPUT«5===SORRY!5=== Error while compiling /tmp/IBzu7dyGPo␤augment not allowed without 'use MONKEY-TYPING'␤at /tmp/IBzu7dyGPo:1␤------> 3augment class Int7⏏5 { method cir { ^self } }; say 5.reduce(␤    expecting any of:␤        generic role␤»

[18:36] <Ven> m: use MONKEY-TYPING; augment class Int { method cir { ^self } }; say 5.reduce(2* *)

[18:36] <camelia> rakudo-moar 0f0e73: OUTPUT«5␤»

[18:36] *** khisanth__ joined
[18:37] <smls> lizmat: I had submitted a rakudobug about the Hash[Any,Any] .perl bug yesterday, did you see it?

[18:37] <lizmat> not consciously  :-)

[18:38] <tony-o_> .tell jdv79 i have 29s for parsing yahoo.com , it does seem excessive but it's quite possibly because the code was meant to get us by until we had libxml bindings (or if someone needed a PP parser)

[18:38] <yoleaux> tony-o_: I'll pass your message to jdv79.

[18:41] <lizmat> smls: do you have a ticket number handy?

[18:41] <smls> #125242

[18:42] <lizmat> hmmm... seems to not have gotten a mail about that  :-(

[18:43] <Ven> m: use MONKEY-TYPING; augment class Int { method cir { ^self } }; say 5.cir.reduce(2* *)

[18:43] <camelia> rakudo-moar 0f0e73: OUTPUT«Too many positionals passed; expected 1 argument but got 2␤  in block <unit> at /tmp/J5eNn5L_KB:1␤  in any <unit-outer> at /tmp/J5eNn5L_KB:1␤␤»

[18:46] *** spider-mario joined
[18:46] <Ben_Goldberg> m: say 1 R, 2 R, 3 R, 4;

[18:46] <camelia> rakudo-moar 0f0e73: OUTPUT«2 1␤»

[18:48] <masak> huh.

[18:48] <dalek> ecosystem: 08a6f57 | (Sterling Hanenkamp)++ | META.list:

[18:48] <dalek> ecosystem: Add Path::Router to the Perl6 ecosystem

[18:48] <dalek> ecosystem: review: https://github.com/perl6/ecosystem/commit/08a6f57a34

[18:50] *** eli-se left
[18:52] <lizmat> moritz masak: is there a reason why t/02-rakudo is not included in "make test" ?

[18:53] *** andreoss joined
[18:59] <smls> m: say (1..500).classify

[18:59] <camelia> rakudo-moar 24aca6: OUTPUT«Cannot call classify(Int: Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, …»

[18:59] <smls> that's quite the error message ;)

[18:59] <masak> even an Int invocant argument... o.O

[18:59] *** colomon joined
[19:04] *** colomon left
[19:05] <lizmat> wow

[19:10] <dalek> rakudo/nom: bdf5c7d | lizmat++ | t/01-sanity/55-use-trace.t:

[19:10] <dalek> rakudo/nom: Add basic "use trace" sanity test

[19:10] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/bdf5c7dd3d

[19:14] *** khisanth__ left
[19:15] <tony-o_> what should that .classify produce?

[19:15] <moritz> tony-o_: a hash

[19:16] <moritz> lizmat: I'm not aware of any reason

[19:16] <lizmat> no, it should die on lack of a $test

[19:16] <lizmat> m: say (^10).classify({$_})

[19:16] <camelia> rakudo-moar 24aca6: OUTPUT«0 => 0, 1 => 1, 2 => 2, 3 => 3, 4 => 4, 5 => 5, 6 => 6, 7 => 7, 8 => 8, 9 => 9␤»

[19:17] <lizmat> m: say (^10).classify(*)

[19:17] <camelia> rakudo-moar 24aca6: OUTPUT«Cannot look up attributes in a type object␤  in block <unit> at /tmp/Q__YtnwodE:1␤  in any <unit-outer> at /tmp/Q__YtnwodE:1␤␤»

[19:18] <moritz> oh, /me didn't read properly

[19:18] *** domidumont left
[19:22] <lizmat> $ 6 '(1..1).classify'

[19:22] <lizmat> Must specify something to classify with, a Callable, Hash or List

[19:22] <lizmat> $ 6 '(1..1).classify(*)'

[19:22] <lizmat> Doesn't make sense to classify with itself

[19:22] <b2gills> m: say (^10).classify(+*)

[19:22] <camelia> rakudo-moar 24aca6: OUTPUT«0 => 0, 1 => 1, 2 => 2, 3 => 3, 4 => 4, 5 => 5, 6 => 6, 7 => 7, 8 => 8, 9 => 9␤»

[19:23] <tony-o_> m: say (^10).classify({ 0 => $_ });

[19:23] <camelia> rakudo-moar 24aca6: OUTPUT«(0 => 0) => 0, (0 => 1) => 1, (0 => 2) => 2, (0 => 3) => 3, (0 => 4) => 4, (0 => 5) => 5, (0 => 6) => 6, (0 => 7) => 7, (0 => 8) => 8, (0 => 9) => 9␤»

[19:24] <tony-o_> m: say (^10).classify(:key(0), :values(*));

[19:24] <camelia> rakudo-moar 24aca6: OUTPUT«Cannot call classify(Int: Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Whatever); none of these signatures match:␤    (Any: Any $test, Any |c)␤    (Any: Any $test, Any :into($into)!, Any |c)␤  in block <unit> at /tmp/IDFyL6vvGd:1␤  in any <uni…»

[19:24] <masak> m: say (0 => ((0 => 0)).perl

[19:24] <camelia> rakudo-moar 24aca6: OUTPUT«5===SORRY!5=== Error while compiling /tmp/WtDYSD6cfg␤Unable to parse expression in parenthesized expression; couldn't find final ')' ␤at /tmp/WtDYSD6cfg:1␤------> 3say (0 => ((0 => 0)).perl7⏏5<EOL>␤    expecting any of:␤        statemen…»

[19:25] <tony-o_> m: say (^10).classify(:key(0), :values({$_}));

[19:25] <masak> m: say (0 => (0 => 0)).perl

[19:25] <camelia> rakudo-moar 24aca6: OUTPUT«Cannot call classify(Int: Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Block); none of these signatures match:␤    (Any: Any $test, Any |c)␤    (Any: Any $test, Any :into($into)!, Any |c)␤  in block <unit> at /tmp/kqWHTIfNvz:1␤  in any <unit-o…»

[19:25] <camelia> rakudo-moar 24aca6: OUTPUT«0 => 0 => 0␤»

[19:26] <b2gills> m: say (^10).categorize: { ($_ %% 2 ?? 2 !! Empty), ($_ %% 3 ?? 3 !! Empty) }

[19:26] <camelia> rakudo-moar 24aca6: OUTPUT«2 => 0 2 4 6 8, 3 => 0 3 6 9␤»

[19:26] <b2gills> m: say (^10).categorize: { ($_ %% 2 ?? 2 !! ()), ($_ %% 3 ?? 3 !! ()) }

[19:26] <camelia> rakudo-moar 24aca6: OUTPUT«p6listitems may only be used on a concrete List␤  in block <unit> at /tmp/Js02IV9nNg:1␤  in any <unit-outer> at /tmp/Js02IV9nNg:1␤␤»

[19:26] <dalek> rakudo/nom: bfbf833 | lizmat++ | src/core/Any.pm:

[19:26] <dalek> rakudo/nom: Add some sanity to Any.(classify|categorize)

[19:26] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/bfbf8335b6

[19:28] <andreoss> m: sub is-pandigital($n)  { so all $n.comb.one == all 1..9 }; is-pandigital(12365789).say;

[19:28] <camelia> rakudo-moar 24aca6: OUTPUT«False␤»

[19:28] <andreoss> m: sub is-pandigital($n)  { so all $n.comb.one == all 1..9 }; is-pandigital(412365789).say;

[19:28] <camelia> rakudo-moar 24aca6: OUTPUT«True␤»

[19:28] *** cognominal joined
[19:30] <timotimo> m: sub is-pandigital($n)  { bag $n.comb == 9 }; is-pandigital(412365789).say;

[19:30] <camelia> rakudo-moar 24aca6: OUTPUT«bag(True)␤»

[19:30] <timotimo> m: sub is-pandigital($n)  { bag($n.comb) == 9 }; is-pandigital(412365789).say;

[19:30] <camelia> rakudo-moar 24aca6: OUTPUT«True␤»

[19:30] <timotimo> m: sub is-pandigital($n)  { bag($n.comb) == 9 }; is-pandigital(12365789).say;

[19:30] <camelia> rakudo-moar 24aca6: OUTPUT«False␤»

[19:30] <timotimo> m: sub is-pandigital($n)  { bag($n.comb) == 9 }; is-pandigital(111111111).say;

[19:30] <camelia> rakudo-moar 24aca6: OUTPUT«True␤»

[19:30] <timotimo> m: sub is-pandigital($n)  { bag(|$n.comb) == 9 }; is-pandigital(111111111).say;

[19:30] <camelia> rakudo-moar 24aca6: OUTPUT«True␤»

[19:30] <timotimo> uh?

[19:31] *** zakharyas joined
[19:31] <timotimo> m: sub is-pandigital($n)  { set(|$n.comb) == 9 }; is-pandigital(111111111).say;

[19:31] <camelia> rakudo-moar 24aca6: OUTPUT«False␤»

[19:31] <timotimo> that's it

[19:31] <timotimo> m: sub is-pandigital($n)  { set(|$n.comb) == 9 }; is-pandigital(123456789).say;

[19:31] <camelia> rakudo-moar 24aca6: OUTPUT«True␤»

[19:31] <timotimo> m: sub is-pandigital($n)  { set(|$n.comb) == 9 }; is-pandigital(123456780).say;

[19:31] <camelia> rakudo-moar 24aca6: OUTPUT«True␤»

[19:31] <timotimo> this doesn't fit the definition, though, right?

[19:31] <andreoss> not really, zero is excluded

[19:33] <timotimo> right

[19:33] <andreoss> @a.every == @b.every would be a nicer to read

[19:33] <andreoss> then all @a.one == @b.any

[19:33] <masak> to this day, the oppression of poor zero continues...

[19:35] <lizmat> m: say 0 but True  # :-)

[19:35] <camelia> rakudo-moar 24aca6: OUTPUT«0␤»

[19:35] <raydiak> m: sub is-pandigital($n)  { set(|$n.comb) == 9 }; is-pandigital('o/ #perl6').say;

[19:35] <camelia> rakudo-moar 24aca6: OUTPUT«True␤»

[19:38] <timotimo> right

[19:38] <timotimo> fair enough

[19:38] <tony-o_> .tell japhb i have these hilights in irssi doing what you're looking for, they could be improved but they work well enough (and you're right, it cleans up the channel quite a bit): https://gist.github.com/tony-o/968491d6430de41b3ae2 

[19:38] <yoleaux> tony-o_: I'll pass your message to japhb.

[19:39] <timotimo> m: say &[(=)]

[19:39] <camelia> rakudo-moar 24aca6: OUTPUT«5===SORRY!5=== Error while compiling /tmp/zwIl878Q0N␤Missing infix inside []␤at /tmp/zwIl878Q0N:1␤------> 3say &[7⏏5(=)]␤    expecting any of:␤        argument list␤        infix␤        infix noun␤        infix stopper␤        …»

[19:39] <timotimo> what does set equivalence look like? just regular eqv?

[19:39] *** spider-mario left
[19:42] <raydiak> this looks relevant: https://github.com/rakudo/rakudo/blob/nom/src/core/set_operators.pm#L147-153

[19:44] <masak> m: say True but 0

[19:44] <camelia> rakudo-moar 24aca6: OUTPUT«True␤»

[19:45] <lizmat> m: say (True but 0)++   # just curious

[19:45] <camelia> rakudo-moar 24aca6: OUTPUT«Cannot modify an immutable Bool+{<anon>}␤  in block <unit> at /tmp/9uQx2iSVe8:1␤  in any <unit-outer> at /tmp/9uQx2iSVe8:1␤␤»

[19:46] <andreoss> m: say 0 orelse True

[19:46] <camelia> rakudo-moar 24aca6: OUTPUT«0␤»

[19:46] <masak> andreoss: precedence there probably ain't what you think

[19:47] <masak> (say 0) orelse True

[19:47] *** ShimmerFairy left
[19:47] <andreoss> m: say (0 orelse True)

[19:47] <camelia> rakudo-moar 24aca6: OUTPUT«0␤»

[19:47] <masak> oh, and `orelse` probably doesn't mean what you think either :P

[19:47] <masak> m: say (0 or True)

[19:47] <camelia> rakudo-moar 24aca6: OUTPUT«True␤»

[19:47] *** spider-mario joined
[19:48] <masak> m: say (Any orelse True)

[19:48] <camelia> rakudo-moar 24aca6: OUTPUT«True␤»

[19:48] <andreoss> m: say so 0

[19:48] <camelia> rakudo-moar 24aca6: OUTPUT«False␤»

[19:48] <lizmat> for performance reasons, I think we need to create an IDENTITY method for infix:<===>, similar to ACCEPTS for infix:<~~>

[19:49] <lizmat> since most of the time, things are *not* the same, it could safe potentially very expensive/problem prone stringification

[19:49] <lizmat> *save

[19:49] *** yqt joined
[19:51] <masak> sounds good

[19:52] <masak> except I thought that's what .WHICH already does

[19:52] <lizmat> nope: ulti sub infix:<===>($a, $b) {

[19:52] <lizmat>     nqp::p6bool(nqp::iseq_s(nqp::unbox_s($a.WHICH), nqp::unbox_s($b.WHICH)))

[19:52] <lizmat> }

[19:53] <lizmat> mind you, this wouldn't change anything about .WHICH, was we need that still

[19:53] <lizmat> it would only make === a lot cheaper

[19:54] *** kaare__ left
[19:54] <masak> you say "nope" and then paste a sub that uses .WHICH? :P maybe we're talking past each other here...

[19:55] <masak> let me restate, then: I don't yet see how your proposed .IDENTITY is distinct from .WHICH

[19:57] <timotimo> i think if it's meant to be similar to ACCEPTS, it'd implement the whole identity comparison

[19:57] <lizmat> my proposal would be:

[19:57] <lizmat> multi sub infix:<===>(Mu \topic, Mu \matcher) {

[19:57] <lizmat>     matcher.IDENTITY(topic).Bool;

[19:57] <lizmat> }

[19:57] <timotimo> like, method IDENTITY($other) { ... }

[19:58] <lizmat> and then make the default IDENTITY use the .WHICH comparison we have in infix:<===> now

[19:58] <masak> ooh!

[19:58] <masak> sorry I'm so slow

[19:59] <lizmat> so e.g. when List === List, you would first check nr of elems in IDENTITY e.g.

[19:59] <masak> just a minor point from a mathematician's POV: === is symmetric, ~~ ain't

[19:59] <masak> so doing matcher.IDENTITY(topic) feels like it "unfairly" privileges matcher

[19:59] *** ShimmerFairy joined
[20:00] <andreoss> timotimo: i've managed to get full back trace https://paste.debian.net/183070/

[20:00] <lizmat> is that important though?  I mean, if it's symmetric, it doesn't matter in which order you compare them

[20:02] <masak> I don't know. it somehow feels like borrowing a scheme that works very well for ~~ and ACCEPTS, and expecting it to work just as well for ===, but there the conditions are different

[20:02] *** rindolf left
[20:03] <masak> doing it with matcher.IDENTITY introduces the *opportunity* for === not to be symmetric (if someone implements it wrong, for example)

[20:04] <masak> I would be more sold on the scheme if it didn't allow for an implementation of === that could be asymmetric

[20:05] <lizmat> well, isn't that really a case of DIHWIDT ?

[20:06] *** darutoko left
[20:07] <masak> depends which level you're reasoning at. at the architectural level, one has a duty to not introduce DIHWIDTs :P

[20:08] <masak> also, I'm wondering if the way to get rid of the cost of a string comparison is to introduce a method dispatch...

[20:08] <lizmat> well, any size of Set/Bag/Mix makes === *very* expensive on them

[20:09] <lizmat> apart from the issue that there are false positives

[20:09] <masak> *nod*

[20:09] <lizmat> when using string comparison

[20:09] <TimToady> identity strings should probably be interned

[20:10] *** laouji joined
[20:10] <masak> if someone asked me how that happened under the hood, I'd guess something like Git's hash comparison. the cost would then be amortized, too.

[20:10] *** mj41 left
[20:10] <TimToady> identity is about individuals, not pairs of things

[20:11] * TimToady will be a bit distracted here, still helping run a quiz tournament...

[20:11] <lizmat> TimToady: not sure what you mean by "should be interned" ?

[20:13] <TimToady> strings are a convenience for the implementor, really, but identity is more of an opaque value than a string

[20:13] <TimToady> two interned strings can be compared merely by comparing two integers

[20:14] *** laouji left
[20:15] <masak> this is in line with what I feel about hashes and amortized cost.

[20:16] <lizmat> TimToady: but even if they are interned, shouldn't there be some way for any Class to make its interned string ?

[20:16] <Ven> .u dog

[20:16] <yoleaux> U+2EA8 CJK RADICAL DOG [So] (⺨)

[20:16] <yoleaux> U+2F5D KANGXI RADICAL DOG [So] (⽝)

[20:16] <yoleaux> U+1F415 DOG [So] (🐕)

[20:16] <masak> Ven: dogs. so radical.

[20:16] <lizmat> TimToady: and if that's the case, doesn't that run the same risks / costs as .WHICH creation right now for value types ?

[20:17] <Ven> masak: I never knew :o)

[20:17] <lizmat> such as Sets/Bags/Mixes ?

[20:17] <TimToady> we allow classes to define their own WHICH for value types, sure, but just because our current WHICH scheme is expensive doesn't mean it has to be that way

[20:17] * masak wonders if we can get something like Java's .hashCode, without peopl actually having to implement .hashCode

[20:18] <masak> people*

[20:18] <Ven> masak: https://github.com/vendethiel/Serialize-Tiny.pm6/blob/master/lib/Serialize/Tiny.pm :D

[20:18] <lizmat> TimToady: well, making it less expensive is the reason I was exploring this

[20:19] <Ven> auto-hashCode of public properties

[20:20] <lizmat> but apparently I'm a person with a hammer only seeing nails  :-)

[20:20] <TimToady> I'm inclined to agree with masak, in that it feels better to make WHICH faster internally, not try to put second-guessers on the outside

[20:21] <lizmat> TimToady: I'm not worried about the cost if two objects *are* identical

[20:21] <TimToady> we can put cheaters on the outside to optimize, but we'll probably get "caught" sooner, and we can probably speed up the internal paths first, then cheat later

[20:21] <lizmat> I'm worried about the cost when they are not: which would be most of the cases

[20:21] <TimToady> well, strings falsify really fast if they're different at the start :)

[20:22] <FROGGS_> you have to create that string first though

[20:22] <lizmat> that's true, but I'm not talking about the actual string comparison, I'm talking about the effort to create the string

[20:22] <FROGGS_> two of 'em actually

[20:22] <lizmat> yup

[20:22] <TimToady> yes, strings are problematic from all other views :)

[20:22] <TimToady> well, most

[20:22] <lizmat> which, if you're creating 2 Mbyte strings that are different at the first char, is very expensive

[20:25] *** diana_olhovik left
[20:25] <masak> why must the .WHICH of Sets be a full listing of the set's elements? this is what SHA-1s solve so well.

[20:27] *** xfix left
[20:27] <lizmat> well, you would need to walk all values anyway, and nqp::sha1 only works on strings

[20:27] <lizmat> so that would seem like just a lot of extra work, really

[20:28] <TimToady> we really need to move in the direction of everything being able to produce a hash value

[20:28] <masak> I'm talking about the principle -- of amortizing the work of computing a good .WHICH across all additions of elements.

[20:28] <masak> TimToady: well. everything hashable.

[20:28] <TimToady> strings are just a temporary expedient

[20:29] <masak> I'm talking about Merkle trees, I think. https://en.wikipedia.org/wiki/Merkle_tree

[20:29] * TimToady can't really pay close enough attention at the moment, so is just shooting from the hip...

[20:29] <TimToady> duck if any bullets come too close :)

[20:29] <masak> Git makes this cheap, because by the time you're computing the SHA-1 of the commit (say), you've already computed the SHA-1 of all its constituents at earlier moments.

[20:30] <masak> TimToady: enjoy quiz! :)

[20:32] <lizmat> masak: I think you're underestimating the cost of SHA1 calculation and number of objects in a git repo compared with something in a Bag of any size

[20:32] <lizmat> a Bag of any size will quickly be a number of orders of magnitude larger

[20:32] <masak> please forget I said SHA1. that was not my point.

[20:33] <masak> my point was *incremental* computation of the hash value of the container.

[20:33] <lizmat> but that would be *exactly* what my IDENTITY proposal would allow you to do

[20:34] <FROGGS_> I'd think that the .WHICH has to implement that, not the IDENTITY

[20:35] <masak> well, you currently have the advantage in that you have a proposal :) I only have comments so far.

[20:35] <FROGGS_> and you could cache the hash of the nodes, and only rehash some nodes when altering the structure

[20:35] <masak> the hash computation being amortized would mean that the hash-computing concern is kind of spread across the entire class.

[20:36] <TimToady> a set cannot impose a notion of identity outside of the class, that's just a basic violation of encapsulation

[20:37] <lizmat> FROGGS_: please note that atm, you need .WHICH to be a Str for things like typed hashes / Sets / Bags / Mixes

[20:37] <TimToady> that's letting the implementation drive the design, I suspect

[20:38] <masak> I've always thought of .WHICH as more of an integer, for some reason.

[20:38] <lizmat> TimToady: the basic IDENTITY(Mu, Mu) { Mu.WHAT == Mu.WHAT }

[20:38] <lizmat> I should say:  IDENTITY(Mu:U, Mu.U) { Mu.WHAT == Mu.WHAT }

[20:39] <masak> is that numeric comparison?

[20:39] <lizmat> oops, I mean eq

[20:39] <TimToady> I'd say === there, given that WHiCH is always a value type

[20:39] <lizmat> TimToady: that was a .WHAT in the comparison

[20:39] <TimToady> or eqv also works, since value types don't distinguish === from eqv

[20:40] <TimToady> either == or eq is pretty sure to be wrong in the long run

[20:40] <TimToady> okay, that's for :U only then, but still

[20:41] <TimToady> ===/eqv are more fundamental than ==/eq, in my mind

[20:42] <TimToady> we can have types and identities that are neither numbers nor strings

[20:42] <TimToady> nor easily reducable to them, unless you count hashes as funny integers

[20:42] <lizmat> ok, so in order to make Set === Set faster, we would need to add an infix:<===>(Set,Set) candidate

[20:43] <TimToady> no, a set is immutable, should have it's identity calculated some time between set creation and the first time it's asked for

[20:44] <lizmat> well, yes, but I made it lazy, I think

[20:44] <TimToady> $set1.WHICH === $set2.WHICH should only do the identity work once, at most

[20:44] <TimToady> (for each set, and only if not already done)

[20:45] <lizmat> yes, and it does, it just can be *very* expensive atm

[20:45] * TimToady is also not sure the current approach of optimizing for pair production is really the largest use of sets

[20:45] *** Khisanth joined
[20:45] <lizmat> where, if we would e.g. compare the number of elems first, we could already decide that tey cannot be equal *without* creating the identity values

[20:46] <lizmat> Set / Bag / Mixes / Hashes / Typed hashes, all the same issue

[20:46] <lizmat> all value types

[20:46] <TimToady> normal hashes are not a value type

[20:46] <lizmat> true, I meant EnumMaps

[20:48] *** Ven left
[20:53] * masak wonders how Python pulls it off

[20:56] *** beastd joined
[20:56] <timotimo> i think they do the "if you do it wrong, it's your fault" approach?

[20:57] <timotimo> no, wait

[20:57] <timotimo> i think they throw exceptions when unhashable types are put into hash key positions

[20:58] <lizmat> is there a (cheap) signature possible for ($a,$b) where $a and $b are of a different type ?

[20:59] <lizmat> std: sub a(Int $a, !Int $b) {...}

[20:59] <camelia> std 28329a7: OUTPUT«5===SORRY!5===␤Malformed parameter at /tmp/l4LCkqEBIc line 1:␤------> 3sub a(Int $a, 7⏏5!Int $b) {...}␤    expecting any of:␤       name␤   parameter␤      signature␤Parse failed␤FAILED 00:00 137m␤»

[21:00] *** fhelmberger joined
[21:00] <masak> timotimo: that always seemed very reasonable to me. but I agree it might not be Perl's style.

[21:00] <timotimo> sub a(::T $a, ::U $b where U !eqv T) { }; a(10, "hi")

[21:00] <timotimo> m: sub a(::T $a, ::U $b where U !eqv T) { }; a(10, "hi")

[21:00] <camelia> rakudo-moar bfbf83: ( no output )

[21:00] <timotimo> m: sub a(::T $a, ::U $b where U !eqv T) { }; a(10, 11)

[21:00] <camelia> rakudo-moar bfbf83: OUTPUT«Constraint type check failed for parameter '$b'␤  in sub a at /tmp/WTwdOnMsMY:1␤  in block <unit> at /tmp/WTwdOnMsMY:1␤  in any <unit-outer> at /tmp/WTwdOnMsMY:1␤␤»

[21:00] <timotimo> great, isn't it? :P

[21:00] <TimToady> well, we have very few unhashable types, since the identity of a container is just the container itself

[21:01] <lizmat> timotimo: that isn't cheap  :-)

[21:01] <masak> TimToady: in Python, "unhashable" and "mutable" are the same.

[21:01] *** colomon joined
[21:02] <lizmat> so something like: my %h{Any} = { a => 42 } => 666 would not work in Python?

[21:02] <timotimo> i don't think we have anything like that :S

[21:02] <TimToady> sure, which means we give more value, if you happen to want to compare collections of mutable containers for some reason :)

[21:02] *** colomon left
[21:02] <lizmat> m: my %h{Any} = { a => 42 } => 666; say %h.perl

[21:02] <camelia> rakudo-moar bfbf83: OUTPUT«Hash[Any,Any].new({:a(42)} => 666)␤»

[21:03] <timotimo> TimToady: i think we give "more key" rather than "more value"

[21:03] <masak> lizmat: right. you can't use dicts as dict keys in Python.

[21:03] <TimToady> lizmat: that's the value, so no problem

[21:03] <TimToady> it's the key that they want to hash

[21:03] *** colomon joined
[21:03] <TimToady> oh, wait, I misread

[21:04] <TimToady> nm

[21:04] <TimToady> yes, I'd expect that to fail in Python

[21:04] <lizmat> m: my %h = a => 42; my %i{Any} = %h => 666; say %i.perl; %h<b> = 43; say %i.perl   # so is this expected ?

[21:04] <camelia> rakudo-moar bfbf83: OUTPUT«Hash[Any,Any].new({:a(42)} => 666)␤Hash[Any,Any].new({:a(42), :b(43)} => 666)␤»

[21:05] *** fhelmberger left
[21:05] <lizmat> m: my %h = a => 42; my %i{Any} = %h => 666; say %i.perl; %h<b> = 43; say %i.keys[0] === %h

[21:05] <camelia> rakudo-moar bfbf83: OUTPUT«Hash[Any,Any].new({:a(42)} => 666)␤True␤»

[21:05] <TimToady> yes, that's perfectly fine

[21:06] <lizmat> *phew*

[21:06] <TimToady> hashes are always === semantics, not eqv

[21:06] <dalek> rakudo/nom: c56fe3e | lizmat++ | src/core/Mu.pm:

[21:06] <dalek> rakudo/nom: Make @a eqv @b 10% faster if not equal

[21:06] <dalek> rakudo/nom: 

[21:06] <dalek> rakudo/nom: By not enforcing an explicit return in that case

[21:06] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/c56fe3e8ce

[21:07] <TimToady> users have to take their own snapshots if they want them

[21:07] <masak> fails in Python: https://gist.github.com/masak/1afe22b244fcc9255f7a

[21:23] *** zakharyas left
[21:31] <andreoss> timotimo: had you a chance to take a look at my bt? 

[21:32] *** colomon left
[21:36] <timotimo> sorry, i haven't reached a computer at all today until very late in the evening and didn't see your bt

[21:36] <timotimo> can you give me the link again?

[21:36] <andreoss> 	   https://paste.debian.net/183070/

[21:39] <timotimo> do you also have the code available that triggered this?

[21:40] <timotimo> it seems sort of like you're assigning to something that's null somehow

[21:40] <timotimo> is it related to state variables at all?

[21:41] <andreoss> it's in perl6-examples, within Pod::To::HTML callback

[21:41] <andreoss> let me commit it

[21:41] <timotimo> god damn it :S

[21:42] *** ggoebel joined
[21:44] <lizmat> masak: how about a "ValueType"  role:

[21:45] <lizmat> role ValueType { has Str $!sha1; method sha1 { $sha1 //= nqp::sha1(self.Str) }

[21:45] *** laouji joined
[21:46] <lizmat> basically the idea of the Merkle tress, with only value types (such as Int, Str, Set, Bag, Mix) containing the extra $!sha1 attribute

[21:47] <lizmat> and in the case of Set, Bag, Mix they would be a bit more involved...

[21:47] <masak> *nod*

[21:48] <dalek> perl6-examples: b7c6eff | andreoss++ | lib/Pod/Htmlify.pm6:

[21:48] <dalek> perl6-examples: Syntax highlighting. Code in htmlify.pl segfaults with 2015.05

[21:48] <dalek> perl6-examples: review: https://github.com/perl6/perl6-examples/commit/b7c6effd4c

[21:48] <lizmat> the default sha1 of an object would be whatever .WHICH now returns

[21:48] <timotimo> why not commit that in a branch?

[21:48] <andreoss> you should have to, sorry

[21:48] <lizmat> or maybe that is what .WHICH is intended to be ?

[21:48] <timotimo> andreoss: did you also try to "print MVM_dump_backtrace(tc)"?

[21:48] <masak> and please forget I said SHA1. we can do a cheaper hash function. something involving one XOR and a bitshift, perhaps.

[21:50] <lizmat> that feels like opening a can of worms and potential security issues to me

[21:50] <lizmat> did you follow the discussion on hashes on p5p in the past years ?

[21:51] <andreoss> https://paste.debian.net/183106/

[21:51] <andreoss> it crashes with {*} inside BUILD

[21:52] <masak> lizmat: I know the gist of it, I think.

[21:52] <masak> by osmosis.

[21:52] <lizmat> hehe

[21:53] *** grondilu left
[21:53] * mst tries to parse {*} as Tcl

[21:53] * mst resets brain

[21:53] * lizmat wishes we had 160bit native ints

[21:55] <timotimo> we could have 160bit native ints, but we'd have to have a platform that we target that has them :)

[21:55] <lizmat> hehe... and SHA1 all of a sudden is not that safe anymore  :-)

[21:55] <lizmat> still, it would save half of the length if it were a 20 byte buf, instead of a 40 char string

[21:56] <timotimo> i'm not 100% sure the operations you usually run for that kind of thing are really that much better when you have a native register that holds all of it

[21:56] *** Ven joined
[21:57] <lizmat> yeah, I guess the overhead of having an extra attribute with each value type object, would be the real memory hog

[21:57] <lizmat> even though it would be uninitialized most of the time

[22:05] *** laouji left
[22:10] <RabidGravy> is it intentional that if you do "perl6 -Ilib" for instance, the "lib" doesn't appear in the @*INC?

[22:10] <dalek> perl6-examples: 230d296 | andreoss++ | lib/Pod/Htmlify.pm6:

[22:10] <dalek> perl6-examples: Commented out problem code

[22:10] <dalek> perl6-examples: review: https://github.com/perl6/perl6-examples/commit/230d2962d6

[22:10] <lizmat> RabidGravy: you mean it appears as "file#lib" ?

[22:10] <RabidGravy> in the REPL 

[22:10] <lizmat> ah, the REPL...  hmmm...

[22:10] <RabidGravy> no I mean, not at all

[22:11] <lizmat> I don't think that's intentional

[22:11] <RabidGravy> perl6 -Ilib -e 'use Foo' works fine (where Foo is in a lib sub-dir)

[22:12] <RabidGravy> but perl6 -Ilib

[22:12] <RabidGravy> >use Foo;

[22:12] <RabidGravy> doesn't

[22:12] <Ven> I think that's a known bug

[22:12] <RabidGravy> PITA

[22:13] <RabidGravy> oh well not un-work-roundable

[22:16] <lizmat> it appears nqp::atkey(%*COMPILING, '%?OPTIONS'), 'I') is not set when in the REPL

[22:16] <lizmat> and that is why src/core/Inc.pm doesn't add it

[22:18] <lizmat> I'll look at moving that into nqp when I get use cur completely functional

[22:18] <lizmat> which will *not* be tonight

[22:19] <andreoss> http://paste.debian.net/183116/

[22:20] <andreoss> timotimo: i've localized it a bit, seems it segfaults only when the precompiled code is used

[22:21] <[ptc]> RabidGravy: the workaround for that which I use is: PERL6LIB=./lib perl6

[22:21] *** RabidGravy left
[22:22] <[ptc]> maybe that helps..

[22:23] *** smls left
[22:23] <lizmat> yeah, that should help, as it is not having set %*COMPILING when -I is given, is what the problem is

[22:24] * lizmat calls it a night

[22:24] <lizmat> good night, #perl6!

[22:24] <[ptc]> g'night lizmat 

[22:32] *** Ven left
[22:47] *** colomon joined
[22:47] <raydiak> wrt "hashes are always === semantics, not eqv" what does "general value-keyed hashes" refer to at the end of S03:3386 ?

[22:48] <masak> 'night, lizmat

[22:48] <raydiak> hrm, no synbot?

[22:48] <raydiak> http://design.perl6.org/S03.html#line_3386

[22:50] *** laouji joined
[22:51] * raydiak has needed such a thing and so has a shoddy version of hash-keyed hashes w/eqv semantics in Math::Symbolic

[23:00] *** beastd left
[23:00] *** fhelmberger joined
[23:03] *** laouji left
[23:04] *** telex left
[23:05] *** fhelmberger left
[23:06] *** telex joined
[23:07] <raydiak> TimToady: ^^^^^

[23:07] <raydiak> afk

[23:11] *** espadrine left
[23:19] *** xiaomiao left
[23:23] *** xiaomiao joined
[23:25] <timotimo> andreoss: oh, damn. pre-compilation related bugs are hard

[23:25] <timotimo> any golfing you could do to this would be very appreciated

[23:32] *** dayangkun joined
[23:32] <andreoss> can i emulate loading compiled moar byte-code?

[23:32] <andreoss> i've tried INIT for it, seems to be not it

[23:33] *** colomon left
[23:34] *** yqt left
[23:34] *** colomon joined
[23:38] *** BenGoldberg_ joined
[23:41] *** ggoebel left
[23:41] *** Ben_Goldberg left
[23:42] <raydiak> andreoss: not sure how to do that, probably something with CompUnit.precomp() or so, but I often golf them by just doing 'panda-build . && ./test.p6' or so for every attempt

[23:46] <andreoss> timotimo: did so, it segfaults on type checking 

[23:46] <andreoss>     subset File of Str where -> $x { so $x && $x.IO.e };

[23:46] <andreoss>     has File $!in;

[23:46] <andreoss>     method BUILD() { $!in = "whatever" }

[23:46] <andreoss>  

[23:46] <andreoss> segfaults in BUILD

[23:47] <zostay> m: say :16("0xdeadbeef")

[23:47] <camelia> rakudo-moar c56fe3: OUTPUT«3735928559␤»

[23:47] <timotimo> is that piece of code already enough to trigger the bug? 

[23:47] <raydiak> mentioned in #123700

[23:48] <timotimo> how does precompilation factor in? 

[23:48] <raydiak> oh right no bothelp today

[23:48] <raydiak> https://rt.perl.org/Public/Bug/Display.html?id=123700

[23:48] <andreoss> http://paste.debian.net/183140/ and the class it self http://paste.debian.net/183141/

[23:49] <raydiak> particularly anything precompiled with a subset constraint seems to segfault when assigned to (subset Foo; my Foo $foo = 42;)

[23:50] <raydiak> same reason all the subset constraints are commented out in Image::PNG::Portable

[23:50] <andreoss> timotimo: without pre-compiled code it gives type checking error

[23:52] *** bjz joined
[23:56] *** dayangkun left
[23:56] <dalek> rakudo-star-daily: ba0b5a7 | coke++ | log/MoarVM- (5 files):

[23:56] <dalek> rakudo-star-daily: today (automated commit)

[23:56] <dalek> rakudo-star-daily: review: https://github.com/coke/rakudo-star-daily/commit/ba0b5a76e0

[23:56] <dalek> rakudo-star-daily: 59bddc6 | coke++ | log/MoarVM- (5 files):

[23:56] <dalek> rakudo-star-daily: today (automated commit)

[23:57] <dalek> rakudo-star-daily: review: https://github.com/coke/rakudo-star-daily/commit/59bddc6720

[23:57] <dalek> perl6-roast-data: 690c576 | coke++ | / (9 files):

[23:57] <dalek> perl6-roast-data: today (automated commit)

[23:57] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/690c5767e9

[23:57] <dalek> perl6-roast-data: fffa773 | coke++ | / (9 files):

[23:57] <dalek> perl6-roast-data: today (automated commit)

[23:57] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/fffa773b2d

[23:58] *** stimpi joined
