[00:21] *** brrt left
[00:27] *** skids joined
[00:41] *** virtualsue left
[00:42] <masak> 'night, #perl6

[00:43] *** virtualsue joined
[01:01] <japhb> o/

[01:08] *** dj_goku left
[01:13] *** dj_goku joined
[01:13] *** dj_goku left
[01:13] *** dj_goku joined
[01:14] <adu> \o

[01:14] <adu> or is it "o/" I'm not sure anymore

[01:15] <adu> parametric extensions, I have to remember that

[01:16] <adu> IMHO, I would have called 6pe "Perl6 Generics"

[01:23] *** japhb left
[01:24] *** virtualsue left
[01:24] *** japhb joined
[01:24] <japhb> He is in fact extending the 6model API with parameterization, so that name is apropos.

[01:35] <dalek> rakudo-star-daily: 173b35c | coke++ | log/ (9 files):

[01:35] <dalek> rakudo-star-daily: today (automated commit)

[01:35] <dalek> rakudo-star-daily: review: https://github.com/coke/rakudo-star-daily/commit/173b35cfd1

[01:36] * [Coke] is finally done with work and exercise and dinner, and hopes he can get the release out before the day ends locally. :)

[01:46] <skids> ++ to whoever made all three Order enums 4 characters long.  Little touches like that make code fun.

[01:50] *** vendethiel left
[01:52] <b2gills> gtodd: I couldn't help myself, I added a comment to that SO question

[02:00] <[Coke]> m: Order.perl.say

[02:00] <camelia> rakudo-moar 98db03: OUTPUT¬´Order‚ê§¬ª

[02:00] <[Coke]> m: Order.keys.say

[02:00] <camelia> rakudo-moar 98db03: OUTPUT¬´‚ê§¬ª

[02:06] <raydiak> m: Order::.keys.say

[02:06] <camelia> rakudo-moar 98db03: OUTPUT¬´Less Same More‚ê§¬ª

[02:08] <TimToady> skids: yeah, well, it also bothers me that Complex isn't Cpx or some such :)

[02:09] <adu> japhb: parameterized by types? or arbitrary parameterization?

[02:10] <adu> skids: yeah

[02:10] <adu> raydiak: hi

[02:10] <raydiak> hi there adu

[02:10] <adu> raydiak: I got really close to making a new AST

[02:10] <adu> but I forgot to git push

[02:11] <raydiak> heh well it's still somewhere, right?

[02:12] <adu> ok merged

[02:13] <[Coke]> bah. we know there's a leap second this year, but the site we pull from isn't updated yet.

[02:13] <adu> raydiak: all of the unit tests passed, so I think I did good

[02:14] <raydiak> adu: nice, I'll try to check it out later tonight...did you sort out your syntactic vs semantic conundrums?

[02:14] *** vendethiel joined
[02:15] <adu> raydiak: yes, I made something called TypeOp.new() that is generic enough to represent both

[02:15] <adu> TypeOp is kind of a misnomer, since it represents types and declarations

[02:16] <TimToady> b2gills: actually you've got some superstitious parens in there

[02:21] <dalek> rakudo/nom: ad1dc19 | coke++ | docs/ (2 files):

[02:21] <dalek> rakudo/nom: First pass at 2015.01 releasework.

[02:21] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/ad1dc19853

[02:22] <raydiak> adu: I see...awesome, looks like a good solution to me

[02:23] <adu> raydiak: I think I can use the same AST for C++

[02:23] <raydiak> adu: did you know you have tabs on a couple lines in lib/C/AST.pm6 ?  (and those lines miss trailing semicolons too, if you're worried about those)

[02:23] <b2gills> TimToady: It's all of the switching back an forth between Perl 5 and 6 I've been doing

[02:24] <adu> raydiak: I am very pedantic about formatting, but I just don't have the time to worry about that

[02:24] <dalek> nqp: 739d3d7 | coke++ | VERSION:

[02:24] <dalek> nqp: bump VERSION to 2015.01

[02:24] <dalek> nqp: review: https://github.com/perl6/nqp/commit/739d3d7d4f

[02:24] <adu> I also have Rust projects, oh, and my job

[02:25] <[Coke]> I changed the release announcement to have real quotes.

[02:25] <japhb> "real quotes"?

[02:26] <[Coke]> no, ‚Äúreal quotes‚Äù

[02:27] <skids> m: my @s; @s = 0..Inf; for @s { .say; exit if $_ > 4 }

[02:27] <camelia> rakudo-moar 98db03: OUTPUT¬´0‚ê§1‚ê§2‚ê§3‚ê§4‚ê§5‚ê§¬ª

[02:27] <skids> m: my @s; @s <== 0..Inf; for @s { .say; exit if $_ > 4 }

[02:27] <camelia> rakudo-moar 98db03: ( no output )

[02:27] <adu> raydiak: fixed

[02:27] <dalek> rakudo/nom: 48083f5 | coke++ | docs/release_guide.pod:

[02:27] <dalek> rakudo/nom: whoops, fix release name.

[02:27] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/48083f5a43

[02:30] *** regreg left
[02:33] <raydiak> adu: method direct-abstract-declarator in lib/C/Parser/Actions.pm6 is giving me "Could not find symbol '&Var'"

[02:34] <raydiak> afk

[02:36] <adu> I think I did s/Var/Name/

[02:36] <adu> sorry about that

[02:38] <adu> raydiak: fixed, kind of

[02:43] <japhb> [Coke]: I thought someone did a CL way back to convert the quotes the other direction.  Perhaps I am mistaken ...

[02:51] <[Coke]> I will not be offended if someone does it again, but I suspect we'll just be lazy and keep copying them.

[02:53] *** chenryn joined
[02:58] <jercos> m: "whatever".reverse

[02:58] <camelia> rakudo-moar 98db03: ( no output )

[02:58] <jercos> m: say "whatever".reverse

[02:58] <camelia> rakudo-moar 98db03: OUTPUT¬´whatever‚ê§¬ª

[02:58] <jercos> some things never change :p

[02:58] <jercos> (.comb.reverse.join works fine, but lol)

[02:58] *** vendethiel left
[03:00] <[Coke]> tag only pushes not reported by dalek?

[03:06] <japhb> m: say "whatever".flip

[03:06] <camelia> rakudo-moar 98db03: OUTPUT¬´revetahw‚ê§¬ª

[03:07] <japhb> jercos: Is that ^^ what you wanted?

[03:11] <dalek> rakudo/nom: 91aeeb7 | coke++ | tools/build/NQP_REVISION:

[03:11] <dalek> rakudo/nom: [release] bump NQP revision

[03:11] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/91aeeb7e4e

[03:11] <dalek> rakudo/nom: eabaa68 | coke++ | VERSION:

[03:11] <dalek> rakudo/nom: [release] bump VERSION

[03:11] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/eabaa682ec

[03:21] <[Coke]> oh, right, it takes 10 hours to build a release!

[03:25] <[Coke]> moritz++ for providing a build box.

[03:26] *** japhb left
[03:27] *** japhb joined
[03:42] <[Coke]> one or two roast failure, no problema

[03:47] *** vendethiel joined
[03:52] *** noganex joined
[03:56] *** noganex_ left
[04:00] <[Coke]> AAAAAAAAAAAAAAAAGH

[04:00] <[Coke]> lost connection to hack during the LONGEST running step here.

[04:08] *** vendethiel left
[04:14] *** anaeem1 joined
[04:15] *** anaeem1 left
[04:15] *** anaeem1_ joined
[04:19] *** [Tux] left
[04:21] *** kaleem joined
[04:25] <japhb> [Coke]: Not in a screen or tmux session, I take it?

[04:27] *** [Tux] joined
[04:28] <dalek> rakudo/nom: bac0b62 | coke++ | docs/announce/2015.01.md:

[04:28] <dalek> rakudo/nom: Pull in actual items from Changelog

[04:28] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/bac0b6263d

[04:33] <raydiak> adu: now I get "Default constructor for 'Name' only takes named arguments", with the "abstract?!?" being passed in and all :)

[04:35] <adu> damnit

[04:35] <adu> I need to rethink the abstract versions of the direct declarators

[04:37] <raydiak> I see...I assume for now it would do whatever you were trying to just by passing it as :name<abstract?!?> instead?

[04:40] <adu> insert name => and it should work

[04:41] <adu> but I'm not sure if I want to refactor the grammar, or refactor the actions, I would like to combine the direct and abstract versions if possible

[04:41] <adu> but I'm just now sure how yet

[04:49] <raydiak> should I just put some of the failing lines I run into in a gist for you to check out at your leisure?

[04:50] <raydiak> also, did you say __attribute__ should work now, or am I remembering something different?  haven't tried it recently

[04:50] <raydiak> afk dinner

[04:52] <adu> sure

[04:52] <adu> my email is andjrob(AT)gmail.com

[04:55] <skids> m: < foo < 1 >.perl.say # not sure whether this is intended behavior

[04:55] <camelia> rakudo-moar eabaa6: OUTPUT¬´[31m===[0mSORRY![31m===[0m Error while compiling /tmp/XhT4OF25o2‚ê§Unable to parse expression in quote words; couldn't find final '>'‚ê§        ‚ê§at /tmp/XhT4OF25o2:1‚ê§------> [32mt sure whether this is intended behavior[33m‚èè[31m<EOL>[0m‚ê§    ‚Ä¶¬ª

[05:05] <[Coke]> we don't have any releases claimed for the rest of the year.

[05:07] *** vendethiel joined
[05:08] <dalek> rakudo/nom: 53c80a1 | coke++ | docs/release_guide.pod:

[05:08] <dalek> rakudo/nom: Claim another release.

[05:08] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/53c80a163a

[05:10] *** BenGoldberg left
[05:19] *** kaleem left
[05:29] <dalek> rakudo/nom: cd87c47 | coke++ | docs/announce/2015.01.md:

[05:29] <dalek> rakudo/nom: Fix date in announcement.

[05:29] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/cd87c476bb

[05:30] <[Coke]> so: the announcement file in the repo as of the tag has the wrong date in the text of the announcement; Since I've already pushed the tags and this is a minor issue, I'm not going to re-push the tags.

[05:30] <[Coke]> the email will have the correct date.

[05:31] <[Coke]> Release done.

[05:31] <[Coke]> Thanks to everyone who did the actual work of improving perl 6 this month.

[05:31] <jdv79> [Coke]: i forget if i asked already - why the brackets on your nick?

[05:33] <TimToady> [Coke]++

[05:34] *** muraiki_ left
[05:35] <jdv79> yes of course; [Coke]++ # as always

[05:47] <[Coke]> jdv79: because Coke was already taken

[05:47] <[Coke]> at the time I started using freenode, it was the common way to get a slightly different nick.

[05:49] *** telex left
[05:49] *** ggoebel111111119 joined
[05:50] *** vendethiel left
[05:50] *** telex joined
[05:50] *** ggoebel111111118 left
[06:03] *** gtodd1 joined
[06:04] *** gtodd left
[06:06] <b2gills> m: role Val { has Str $.Str }; sub val ($s) { $s.Numeric but Val($s) }; my $a = val('5e0'); say $a; say $a ~~ Num # fake NumStr

[06:06] <camelia> rakudo-moar 53c80a: OUTPUT¬´5e0‚ê§True‚ê§¬ª

[06:18] *** agentzh joined
[06:19] <agentzh> hi, i'm trying out rakudo today and i'm wondering if it supports automatic error message generation when my grammar parrser fails to parse the user input :)

[06:22] <agentzh> i've noticed that Rakudo itself is using "{ $/.CURSOR.panic(...) }" to generate parse fail messages but it does not work with the Perl 6 code input it seems.

[06:22] <agentzh> according to S05, i'm supposed to use "$¬¢" instead but rakudo apparently dislikes it.

[06:26] <agentzh> S05 seems to talk about the automatic error messages generated by the lexer and the :dba() mechanism but I'm not sure how to fetch such error messages. are they going to "$!"?

[06:27] <agentzh> sorry if i've missed anything obvious :)

[06:28] <moritz> yes, they are thrown as exceptions

[06:30] <agentzh> moritz: is it something already implemented in rakudo?

[06:31] <moritz> agentzh: :dba isn't, ~ throwing exceptions is

[06:31] <agentzh> i'm playing bad inputs to interpreters/RPN.pl in perl6-examples and get no error messages.

[06:33] <agentzh> (but the default "This is not an RPN expression")

[06:37] <agentzh> okay, so the automatic exceptions are only generated for the '~' operator?

[06:38] <agentzh> is it possible to do something like this? http://search.cpan.org/~dconway/Regexp-Grammars-1.038/lib/Regexp/Grammars.pm#Handling_errors_when_parsing

[06:40] *** rurban joined
[06:42] *** bjz joined
[06:47] *** bjz left
[06:49] <PerlJam> agentzh: I'm not sure which specific part you mean by "this" but the answer is bound to be "yes"   :)

[06:50] <agentzh> PerlJam: basically i'm wondering how to provide friendly error messages with position details when the user supplies something bad into my parser implemented in Perl 6.

[06:50] <agentzh> ideally rakudo can generate automatic error messages similar to P::RD and P::G's <error> notation.

[06:51] *** kurahaupo1 left
[06:51] <agentzh> PerlJam: failing that, i hope i can use my own subroutines to generate such messages with "$¬¢"

[06:51] <agentzh> or something like that.

[06:51] <agentzh> because i need the current position where the parse fails.

[06:52] <agentzh> position in the input string.

[06:53] <agentzh> but it seems that Rakudo hates "$¬¢".

[06:53] <agentzh> using the latest git master of rakudo from github :)

[06:53] <TimToady> because for a while the parser ran much slower with Unicode, I suspect

[06:53] *** kurahaupo joined
[06:54] <TimToady> we could probably switch to $¬¢ one of these days

[06:54] <TimToady> but $/.CURSOR is still the cursor that contains the positional information

[06:54] <agentzh> TimToady: $/.CURSOR is the NQP only thing?

[06:55] <agentzh> s/the/an/

[06:55] <TimToady> m: grammar Foo { token TOP { ... { say $/.CURSOR.from } } }; Foo.parse("abc")

[06:55] <camelia> rakudo-moar cd87c4: OUTPUT¬´0‚ê§¬ª

[06:55] <TimToady> m: grammar Foo { token TOP { ... { say $/.CURSOR.to } } }; Foo.parse("abc")

[06:55] <camelia> rakudo-moar cd87c4: OUTPUT¬´No such method 'to' for invocant of type 'Foo'‚ê§  in regex TOP at /tmp/_r9lkTS9uQ:1‚ê§  in method parse at src/gen/m-CORE.setting:14583‚ê§  in block <unit> at /tmp/_r9lkTS9uQ:1‚ê§‚ê§¬ª

[06:56] <TimToady> anyway, .CURSOR is available in user code too

[06:56] <TimToady> at least in rakudo, for now

[06:56] <agentzh> interesting

[06:57] <agentzh> thanks for your help :)

[06:57] <TimToady> m: grammar Foo { token TOP { ... { say $/.from } } }; Foo.parse("abc")

[06:57] <camelia> rakudo-moar cd87c4: OUTPUT¬´0‚ê§¬ª

[06:57] <TimToady> m: grammar Foo { token TOP { ... { say $/.to } } }; Foo.parse("abc")

[06:57] <camelia> rakudo-moar cd87c4: OUTPUT¬´3‚ê§¬ª

[06:57] <TimToady> and positional info is in $/ as well

[06:57] <TimToady> m: grammar Foo { token TOP { ... { say $/.orig } } }; Foo.parse("abc")

[06:57] <camelia> rakudo-moar cd87c4: OUTPUT¬´abc‚ê§¬ª

[06:58] <agentzh> cool

[06:58] *** Rounin joined
[07:00] <agentzh> does "..." mean matching anything?

[07:01] <PerlJam> any 3 chars :)

[07:01] <agentzh> oops, silly me :)

[07:02] <agentzh> PerlJam: thanks for the hint :)

[07:02] <agentzh> thought it was some special operator as a whole.

[07:06] <TimToady> in normal code it would indicate a stub

[07:07] <TimToady> m: sub foo { ... }; foo;

[07:07] <camelia> rakudo-moar cd87c4: OUTPUT¬´Unhandled exception: Stub code executed‚ê§   at <unknown>:1  (/home/camelia/rakudo-inst-1/languages/perl6/runtime/CORE.setting.moarvm:throw:4294967295)‚ê§ from src/gen/m-CORE.setting:14148  (/home/camelia/rakudo-inst-1/languages/perl6/runtime/CORE.setting.‚Ä¶¬ª

[07:07] <agentzh> yep, i was aware of the yada yada operator in that context :)

[07:07] <agentzh> that's why it caught my eyeballs :)

[07:07] <TimToady> sorry I was so misleading :)

[07:07] <agentzh> that's completely fine :)

[07:08] <agentzh> it's the fun to ponder various fun operators in perl :)

[07:08] <agentzh> i'm trying to construct some nontrivial compilers in perl 6 or NQP.

[07:08] <agentzh> NQP looks ugly though it seems much faster.

[07:09] <TimToady> the gap should narrow as our optimizers get better

[07:09] <agentzh> great

[07:10] <agentzh> i've been away from the perl 6 world for several years already. need to reread the synopses :)

[07:10] <TimToady> indeed, welcome back

[07:10] <agentzh> thanks :)

[07:11] <TimToady> we're fine with people coming and going as they please :)

[07:11] <agentzh> i've been deep into nginx and luajit in the last few years.

[07:11] <TimToady> well, we're currently using luajit, or at least bits of it

[07:11] <agentzh> but when coming to compiler construction, i really want to use perl and especially perl 6 :)

[07:11] <agentzh> oh really? which bits?

[07:12] <TimToady> uh, you'd have to ask over on #moarvm to get a sensible answer :)

[07:12] <agentzh> okay, got it :)

[07:12] <TimToady> though scanning #moarvm logs for luajit would probably be informative

[07:12] <agentzh> i have had the dream to build a perl 6 compiler using similar approaches in luajit.

[07:12] <agentzh> but maybe just a core subset of it, like NQP.

[07:13] <TimToady> it seems to work okay, though doesn't really produce optimal code yet

[07:13] <TimToady> bit of an impedance mismatch between lua's worldview and Perl's...

[07:13] <agentzh> yeah sure.

[07:13] <agentzh> luajit's vm is specific to lua's semantics.

[07:13] <agentzh> from ground up.

[07:14] <agentzh> my $work requires speed so i had to switch from perl to luajit for online logic.

[07:14] <TimToady> anyway, brrt and jnthn are probably the people who know most about the jit, and timotimo

[07:14] <agentzh> thanks for the info, thanks :)

[07:15] <TimToady> (brrt++ did the jit last year for GSoC)

[07:15] <agentzh> TimToady: I directly listened to your talk at YAPC::NA 2013 for the first time btw :)

[07:15] <TimToady> oh, well, that one was kinda pathetic :)

[07:16] <agentzh> TimToady: i enjoyed it :)

[07:16] <TimToady> oh, wait, 2013

[07:16] <TimToady> I was thinking of 201

[07:16] <TimToady> 2014

[07:16] <agentzh> i missed 2014 :)

[07:16] <TimToady> I probably should've :)

[07:16] <agentzh> but i'll try to find my way to 2015 :)

[07:16] <TimToady> \o/

[07:17] <TimToady> Salt Lake this year

[07:17] <agentzh> yep

[07:17] <agentzh> not far from my place.

[07:17] <TimToady> where are you?

[07:17] <agentzh> i moved to the bay area in 2012 :)

[07:17] <agentzh> with my wife.

[07:17] <TimToady> ah, well, I'm just down in Mountain View

[07:17] <agentzh> got tired of Beijing :)

[07:17] <agentzh> wow, very near.

[07:17] <TimToady> we finally got to Beijing last year

[07:17] <agentzh> i live in Millbrae.

[07:18] <agentzh> oh really?

[07:18] <TimToady> food was wonderful

[07:18] <agentzh> heh

[07:18] <agentzh> yep i miss the food there too :)

[07:19] <agentzh> TimToady: just out of curiosity, are you still coding in C these days? ;)

[07:19] <TimToady> occasionally, but not often

[07:19] <agentzh> i see :)

[07:20] <TimToady> worked on the NFA engine some lately

[07:20] <agentzh> wow

[07:20] <agentzh> i was working on an NFA-based regex engine two years ago: https://github.com/openresty/sregex

[07:21] <agentzh> the goal is to support streaming parsing like in an nginx output filter.

[07:21] <agentzh> but it is sloooow

[07:21] <agentzh> meant to optimize it at some point.

[07:21] <TimToady> yeah, we'd like ours to run faster too...

[07:21] <agentzh> :)

[07:22] <TimToady> though it's really only about 10% of the parser overhead currently

[07:22] <agentzh> for rakudo?

[07:22] <TimToady> nod

[07:22] <agentzh> got it.

[07:22] <agentzh> for my use case, it can be 90% :)

[07:22] <TimToady> 'course we're parsing a fairly complicated languge

[07:22] <agentzh> indeed.

[07:23] <TimToady> the regex are all integrated in p6, so it could well be 90% for some tasks

[07:23] <agentzh> i'm really glad to see rakudo is much faster than a few years ago :)

[07:23] <agentzh> yes, sure.

[07:23] <TimToady> those are the ones it might be worthwhile to do a DFA for

[07:23] <agentzh> yeah

[07:24] <agentzh> do you think it's possible to do submatch capturing with a DFA without going backward in the input stream?

[07:24] <TimToady> for P6 lexing it probably only makes sense to cache the first set of NFA states, since the possibilities drop rapidly after the first char is recognized

[07:24] <TimToady> oh, yes, it's certainly possible

[07:24] <agentzh> wow.

[07:24] <TimToady> but there's a price, of course

[07:25] <agentzh> the re2 author has to reverse the regex and match backward in the input string to get the *beginning* pos of each submatch captures AFAIK.

[07:25] <TimToady> if you look up "tagged dfa" you should find TRE

[07:25] <TimToady> which is a tagged dfa implementation

[07:25] <agentzh> okay, so TRE is the way to go?

[07:25] <TimToady> not exactly

[07:25] <agentzh> cool, i'll have a closer look at it.

[07:26] <agentzh> i was just aware of its existence :)

[07:26] <TimToady> when I tried it in the early days of prototyping STD, I found it allocated 17MB on the stack for every token

[07:26] <agentzh> ouch!

[07:26] <TimToady> which doesn't really work out

[07:26] <TimToady> so it's a bit of a toy in my mind

[07:26] <agentzh> yes, i have some vague impression of that while reading the perl 6 meetup notes.

[07:26] <TimToady> not really suited for very wide alternations

[07:26] <TimToady> and token recognition is nothing if not wide

[07:27] <agentzh> indeed.

[07:28] <TimToady> regex always find some way to reach out and bite you :)

[07:28] <agentzh> for my use case, i just hope to support a good subset of perl 5 regexes and can make the regex engine yield at any point in the input stream and resume later without going back.

[07:29] <agentzh> so that we can filter out data by chunks.

[07:29] <agentzh> one chunk at a time and never buffer anything more than needed.

[07:29] <agentzh> TimToady: yes, i already got the pain while building sregex.

[07:29] <TimToady> well, at least we support p5 regexen already in p6, for the most part

[07:30] <agentzh> TimToady: yep.

[07:30] <agentzh> TimToady: my toy was built for the nginx world :)

[07:30] <TimToady> and we do concurrency now too, so one could run the parser in a different thread and not worry about continuations too much

[07:30] <agentzh> TimToady: the state of art is to use ragel to generate nginx C modules to do the response body processing.

[07:30] <agentzh> TimToady: but ragel is much more painful than perl regexes :)

[07:31] <agentzh> TimToady: is the "thread" OS-like threads or just lightweight threads like coroutines?

[07:31] *** rindolf joined
[07:31] <TimToady> yeah, I keep seeing references to nginx, but haven't had any direct exposure

[07:32] <TimToady> it's more like Go's promises and channels, with green threads over a built-in scheduler that maps to worker threads

[07:32] <TimToady> kinda the best of both worlds

[07:32] <agentzh> i see. so it's collaborative?

[07:33] <TimToady> yes, but fairly transparently

[07:33] <agentzh> cool

[07:33] <agentzh> i built a coroutine scheduler for lua in the nginx event model :)

[07:34] <agentzh> it's still single threaded though.

[07:34] <TimToady> there's also a whole reactive programming system, called 'supplies'

[07:34] <agentzh> never want the pain dealing with multiple threads :)

[07:35] <agentzh> url?

[07:35] <leedo> ls

[07:35] <leedo> whoops

[07:35] <TimToady> http://design.perl6.org/S17.html

[07:36] <agentzh> cool thanks :)

[07:36] <agentzh> having to do all the synopsis recap :)

[07:37] <agentzh> TimToady: nice to talk to you! gotta get some sleep. G'night!

[07:37] <TimToady> night!

[07:38] *** vendethiel joined
[07:42] *** FROGGS joined
[07:42] *** agentzh left
[07:43] *** virtualsue joined
[07:44] *** rindolf left
[07:46] *** bjz joined
[07:46] *** fhelmberger joined
[07:46] *** kaare_ left
[07:47] *** bjz left
[07:49] *** kaare_ joined
[07:54] *** abraxxa joined
[07:55] *** bjz joined
[07:56] *** xfix joined
[07:59] <moritz> [Coke]++ # release

[08:05] *** prime left
[08:10] *** darutoko joined
[08:11] <dalek> perl6-examples: 05669d7 | (Yichun Zhang (agentzh))++ | interpreters/RPN.pl:

[08:11] <dalek> perl6-examples: improvements and fixes in RPN.pl

[08:11] <dalek> perl6-examples: 

[08:11] <dalek> perl6-examples: * use .list to fix "for" iteration over an array reference.

[08:11] <dalek> perl6-examples: * properly handle the case when no input string argument is specified.

[08:11] <dalek> perl6-examples: * suppress the "Useless declaration of a has-scoped method" warnings

[08:11] <dalek> perl6-examples:   from the latest rakudo.

[08:11] <dalek> perl6-examples: review: https://github.com/perl6/perl6-examples/commit/05669d7da6

[08:11] <dalek> perl6-examples: 9cea16f | FROGGS++ | interpreters/RPN.pl:

[08:11] <dalek> perl6-examples: Merge pull request #17 from agentzh/RPN-fixes

[08:11] <dalek> perl6-examples: 

[08:11] <dalek> perl6-examples: improvements and fixes in RPN.pl

[08:11] <dalek> perl6-examples: review: https://github.com/perl6/perl6-examples/commit/9cea16f6c0

[08:12] *** jmark joined
[08:14] *** prime joined
[08:22] *** zakharyas joined
[08:22] *** vendethiel left
[08:33] *** xinming left
[08:34] *** xinming joined
[08:45] *** fhelmberger_ joined
[08:45] *** mr-foobar left
[08:46] *** vendethiel joined
[08:46] *** rurban1 joined
[08:47] *** fhelmberger left
[08:55] *** chenryn left
[09:02] *** kaleem joined
[09:08] *** vendethiel left
[09:13] *** virtualsue_ joined
[09:14] *** virtualsue left
[09:14] *** virtualsue_ is now known as virtualsue

[09:20] *** vendethiel joined
[09:21] *** xfix left
[09:23] *** virtualsue_ joined
[09:23] *** virtualsue left
[09:23] *** virtualsue_ is now known as virtualsue

[09:24] *** Kristien joined
[09:29] *** molaf__ joined
[09:30] *** fhelmberger_ left
[09:30] *** kjs__ joined
[09:30] <jnthn> morning, #perl6

[09:30] <Kristien> hola

[09:30] <jnthn> [Coke]++ # 2015.01 release

[09:31] <nwc10> good *, jnthn

[09:32] *** molaf_ left
[09:34] *** pecastro joined
[09:34] *** Sir_Ragnarok joined
[09:41] <lizmat> [Coke]++  # 2015.01 release and everything else!

[09:42] *** vendethiel left
[09:48] <Kristien> do Perl 6' text I/O APIs always assume UTF-8 by default?

[09:48] *** vendethiel joined
[09:49] <FROGGS> Kristien: aye

[09:50] <moritz> Kristien: the specs say that they should do some limited form of encoding autodetection that detects UTF-{16,32}, and falls back to UTF-8

[09:50] <moritz> Kristien: rakudo doesn't do that, and always assumes UTF-8

[09:50] <Kristien> OK

[09:51] <Kristien> So it doesn't look at the system locale, which is good.

[09:55] *** denis_boyun_ joined
[09:59] <Kristien> m: say (.codes, .chars) given "a\x030A"

[09:59] <camelia> rakudo-moar cd87c4: OUTPUT¬´2 2‚ê§¬ª

[09:59] <Kristien> interesting

[09:59] <Kristien> I expected 2 1, since U+030A is a combining-character.

[10:00] <moritz> grapheme level is not yet implemented

[10:00] <arnsholt> That's graphemes, not characters

[10:01] <Kristien> oh ok

[10:03] *** virtualsue left
[10:03] <FROGGS> arnsholt: well, .chars will be about graphemes one day

[10:03] *** fhelmberger joined
[10:05] <arnsholt> Ah. I thought that was .graphs =)

[10:07] *** fhelmberger left
[10:08] *** fhelmberger joined
[10:10] <Kristien> can arguments default to $_?

[10:11] *** rindolf joined
[10:11] *** vendethiel left
[10:14] <jnthn> Not easily; we don't really do "takes $_ by default" in Perl 6. Those situations tend to be handled by the .foo or .=foo syntax

[10:14] <lizmat> m: sub a($a = CALLER::<$_>) { say $a }; $_ = "foo"; a  # doesn't work  :-(

[10:14] <camelia> rakudo-moar cd87c4: OUTPUT¬´Nil‚ê§¬ª

[10:14] <FROGGS> m: sub foo ($a = OUTER::DYNAMIC::<$_>) { say $a; say OUTER::DYNAMIC::<$_> }; $_ = 42; foo() # wonders why

[10:14] <camelia> rakudo-moar cd87c4: OUTPUT¬´Nil‚ê§42‚ê§¬ª

[10:14] <FROGGS> err

[10:15] <FROGGS> m: sub foo ($a = CALLER::DYNAMIC::<$_>) { say $a; say CALLER::DYNAMIC::<$_> }; $_ = 42; foo()

[10:15] <camelia> rakudo-moar cd87c4: OUTPUT¬´Nil‚ê§42‚ê§¬ª

[10:15] <jnthn> m: given [1..10] { .=grep * %% 2; .=map 'a' x *; .say }

[10:15] <camelia> rakudo-moar cd87c4: OUTPUT¬´[31m===[0mSORRY![31m===[0m Error while compiling /tmp/R_MD_K6055‚ê§Two terms in a row‚ê§at /tmp/R_MD_K6055:1‚ê§------> [32mgiven [1..10] { .=grep * %% [33m‚èè[31m2; .=map 'a' x *; .say }[0m‚ê§    expecting any of:‚ê§        infix stopper‚ê§        ‚Ä¶¬ª

[10:15] <jnthn> m: given [1..10] { .=grep: * %% 2; .=map: 'a' x *; .say }

[10:15] <camelia> rakudo-moar cd87c4: OUTPUT¬´aa aaaa aaaaaa aaaaaaaa aaaaaaaaaa‚ê§¬ª

[10:15] <Kristien> jnthn nic

[10:15] <Kristien> nice*

[10:15] *** rurban1 left
[10:15] * FROGGS .oO( jnicethn? )

[10:16] <jnthn> lizmat: Probably 'cus the thunking of the default gets in the way.

[10:16] <lizmat> ah, more levels you mean ?

[10:16] <jnthn> Yeah

[10:17] <jnthn> And here's a nice bug:

[10:17] <lizmat> m: sub a($a = CALLER::CALLER::<$_>) { say $a }; $_ = "foo"; a   # indeed

[10:17] <camelia> rakudo-moar cd87c4: OUTPUT¬´foo‚ê§¬ª

[10:17] <jnthn> m:  sub foo($a = CALLER::CALLER::<$_>) { say $a }; given 42 { foo(1); foo() }

[10:17] <camelia> rakudo-moar cd87c4: OUTPUT¬´1‚ê§No such method 'dynamic' for invocant of type 'Int'‚ê§  in method at_key at src/gen/m-CORE.setting:11131‚ê§  in sub postcircumfix:<{ }> at src/gen/m-CORE.setting:3090‚ê§  in sub foo at /tmp/MgALuGqWgZ:1‚ê§  in block <unit> at /tmp/MgALuGqWgZ:1‚ê§‚ê§¬ª

[10:18] <lizmat> hehe

[10:18] <lizmat> rakudobuggable ?

[10:18] <jnthn> Yeah

[10:22] <lizmat> done: #123660

[10:22] <synopsebot> Link: https://rt.perl.org/rt3//Public/Bug/Display.html?id=123660

[10:23] <jnthn> Thanks

[10:32] <dalek> rakudo/nom: 2b2de11 | lizmat++ | docs/release_guide.pod:

[10:32] <dalek> rakudo/nom: Claim February's release

[10:32] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/2b2de11284

[10:33] <dalek> rakudo/nom: a05dc90 | lizmat++ | src/core/ (2 files):

[10:33] <dalek> rakudo/nom: Make EnumMap a first class citizen, skids++

[10:33] <dalek> rakudo/nom: 

[10:33] <dalek> rakudo/nom: This reverts commit a8e384cfa1d1d5414d367416a7aca227a5729739.

[10:33] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/a05dc904d6

[10:41] *** virtualsue joined
[10:46] <jnthn> lizmat: If you've chance, you may also try a build/test run on OSX with MoarVM master; I bumped the default optimization level yesterday.

[10:46] <lizmat> will do

[10:46] <jnthn> lizmat: Tested it with gcc and clang, though only on Linux.

[10:46] *** vendethiel joined
[10:46] <jnthn> lizmat: Hopefully clang on OSX is equally fine

[10:46] <jnthn> lizmat: I guess you build with defaults, so this might also get you a time saving on builds/spectests :)

[10:47] <lizmat> yeah, let's see  :-)

[10:47] <jnthn> Measuring the GCC build with callgrind showed 10% less instructions at Rakudo startup, for example.

[10:47] <lizmat> building now

[10:48] *** andreoss joined
[10:49] <andreoss> m: my $n = 2; $n = ( 2 * $n ) % 10_000_000_000 for 1 .. 7830456; say $n;

[10:49] <lizmat> jnthn: definitely not warning free

[10:50] <camelia> rakudo-moar cd87c4: OUTPUT¬´(timeout)¬ª

[10:50] <jnthn> lizmat: Oh?

[10:50] <jnthn> lizmat: What warnings?

[10:50] <andreoss> with native int $n it's even slower

[10:50] <andreoss> why?

[10:50] <lizmat> jnthn: a *lot* in unicode.c

[10:51] <jnthn> wtf

[10:51] <jnthn> It was just two about pthread_yield for me yesterday...

[10:51] <lizmat> src/strings/unicode.c:41600:20: warning: initializing 'unsigned char *' with an

[10:51] <lizmat>       expression of type 'char *' converts between pointers to integer types

[10:51] <lizmat>       with different sign [-Wpointer-sign]

[10:51] <lizmat>     unsigned char *bname = MVM_string_ascii_encode(tc, block, &size);

[10:51] <jnthn> I fixed that? :/

[10:51] <lizmat> is it not a generated file ?

[10:52] <lizmat> the other one:

[10:52] <lizmat> src/6model/serialization.c:327:34: warning: '&' within '|'

[10:52] <lizmat>       [-Wbitwise-op-parentheses]

[10:52] <lizmat>         buffer[offset++] = value & 0x7F | 0x80;

[10:52] <lizmat>                            ~~~~~~^~~~~~ ~

[10:52] <lizmat> src/6model/serialization.c:327:34: note: place parentheses around the '&'

[10:52] <lizmat>       expression to silence this warning

[10:52] <jnthn> lizmat: Yeah, I thought I fixed the thing generating it too

[10:52] <lizmat> I thought I did too, at one time  :-(

[10:52] <jnthn> m: say nqp::isbig_I(10_000_000_000)

[10:52] <camelia> rakudo-moar cd87c4: OUTPUT¬´1‚ê§¬ª

[10:53] <masak> good antenoon, #perl6

[10:53] <jnthn> andreoss: 'cus it considers - maybe wrongly - that literal too big for a native int, so the % is being done with Int math instead, so the native is getting boxed all the time.

[10:54] <andreoss> i guess it fits in int64

[10:54] <jnthn> o/ masak

[10:54] <jnthn> andreoss: Yeah, it would, thus my "maybe wrongly" :)

[10:54] <jnthn> andreoss: Workaround is to assign that value into an int variable, I guess.

[10:56] *** xfix joined
[10:56] <andreoss> jnthn: yep. this way it is faster  

[10:57] <andreoss> still not as fast as p5 (20 times faster)

[10:58] <jnthn> What if you write it with a loop instead of a for?

[11:01] <andreoss> now it's 13 times slower

[11:01] <andreoss> m: loop (my int $x; $x < 10; $x++) {}

[11:01] <camelia> rakudo-moar cd87c4: OUTPUT¬´Cannot assign to an immutable value‚ê§  in sub postfix:<++> at src/gen/m-CORE.setting:5080‚ê§  in block <unit> at /tmp/OXPvF1trKs:1‚ê§‚ê§¬ª

[11:01] <lizmat> andreoss: $x = $x + 1, natives don't handle ++ yet

[11:02] <lizmat> jnthn is working on that right now, afaik  :-)

[11:02] <jnthn> I get 3.03s with it written as a loop, vs 0.82s in Perl 5

[11:02] <xfix> Hm, interesting. Perl 5 just added /n modifier to regexes which makes parentheses not capture. Why not just add Perl 6 regexes?

[11:02] <jnthn> m: say 3.03 / 0.82

[11:02] <camelia> rakudo-moar cd87c4: OUTPUT¬´3.695122‚ê§¬ª

[11:02] <jnthn> So rather closer here.

[11:02] <jnthn> Still surprised we don't do better there, though.

[11:03] <jnthn> Ah, it's allocating somewhere, for some reason...

[11:04] <jnthn> Yeah, I think it's an optimizer bug

[11:05] <jnthn> 'cus if I re-write it as

[11:05] <jnthn> my int $n = 2; my int $lim = 10_000_000_000; loop (my int $i = 0; $i <= 7830456; $i = $i + 1) { $n = 2 * $n; $n = $n % $lim }; say $n;

[11:05] <jnthn> Then I get the answer in 0.51, which is faster than Perl 5.

[11:06] <jnthn> Especially when 0.25s of that is startup.

[11:06] <andreoss> i run this code http://ideone.com/AOapBS

[11:07] *** BenGoldberg joined
[11:07] <andreoss> and it's still faster in perl5 and in perl6 with ints

[11:07] <andreoss> *than in perl6

[11:08] <jnthn> Looks close enough to what I ran.

[11:09] <andreoss> % time perl6 prob097.pl

[11:09] <andreoss> real	0m9.281s

[11:09] <andreoss> user	0m8.959s

[11:09] <andreoss> sys	0m0.311s

[11:09] <andreoss>  

[11:09] <andreoss> % time perl prob097.pl5

[11:09] <jnthn> Yeah but...which perl6?

[11:09] <andreoss> real	0m2.056s

[11:09] <andreoss> user	0m2.052s

[11:09] <andreoss> sys	0m0.003s

[11:09] <andreoss>  

[11:09] <andreoss> rakudo

[11:09] <jnthn> Yes, but which backend?

[11:09] <andreoss> moar

[11:10] <jnthn> OK, and on x64?

[11:10] <andreoss> yes 

[11:10] <jnthn> Hm, then you should have JIT

[11:11] *** BenGoldberg left
[11:11] <andreoss> also without C-style for in perl5 it reduces to 1.35s 

[11:13] <jnthn> Did you run exactly the code I pasted?

[11:16] <andreoss> I see

[11:17] <dalek> Inline-Perl5: 8fc9014 | (Stefan Seifert)++ | lib/Inline/Perl5.pm6:

[11:17] <dalek> Inline-Perl5: Pass on arguments to the P5 constructor

[11:17] <dalek> Inline-Perl5: review: https://github.com/niner/Inline-Perl5/commit/8fc90149ee

[11:17] <jnthn> If so, and it's still slower, I've little idea what's going on, though running with --profile may be informative.

[11:17] <andreoss> jnthn: it's faster, thanks

[11:22] *** andreoss left
[11:26] <lizmat> Files=936, Tests=34394, 177 wallclock secs ( 9.10 usr  3.15 sys + 1050.45 cusr 138.03 csys = 1200.73 CPU)    # jnthn, wow!

[11:27] <lizmat> Files=936, Tests=34394, 229 wallclock secs ( 9.33 usr  2.86 sys + 1228.85 cusr 139.25 csys = 1380.29 CPU)   # before switch to master

[11:28] <jnthn> Damn, that's quite a win. :)

[11:28] <lizmat> startup time for me went from ~ .29 to .23

[11:28] <lizmat> that's about 20% better  :-)

[11:28] <jnthn> And no new test failures?

[11:29] <lizmat> none, so I think a bump is in order

[11:29] <lizmat> panda also bootstraps fine on it

[11:29] <lizmat> shall I bump ?

[11:29] <jnthn> Go for it; will get it wider testing.

[11:29] <lizmat> or wait for you to fix the unicode warnings ?

[11:30] <jnthn> Can wait too

[11:30] <jnthn> We've got a whole month :)

[11:31] <lizmat> ok

[11:33] <dalek> nqp: a05ddba | lizmat++ | tools/build/MOAR_REVISION:

[11:33] <dalek> nqp: Bump Moar revision to get better optimizations

[11:33] <dalek> nqp: review: https://github.com/perl6/nqp/commit/a05ddba5a3

[11:33] <nwc10> sorry to be a bit laggy, but what particular bit of awesome was responsible for that?

[11:34] <lizmat> default opt level of Moar, afaik

[11:34] *** Kristien left
[11:34] <dalek> nqp-js: 41e92e7 | (Pawel Murias)++ | src/vm/js/nqp-runtime/sixmodel.js:

[11:34] <dalek> nqp-js: Set the correct invocant when calling $call on a method during method call.

[11:34] <dalek> nqp-js: review: https://github.com/pmurias/nqp-js/commit/41e92e7eb2

[11:34] <dalek> nqp-js: fcf4d5f | (Pawel Murias)++ | t/nqp/18-associative.t:

[11:34] <dalek> nqp-js: Add a test for nqp::hash(...) to 18-associative.t.

[11:34] <dalek> nqp-js: review: https://github.com/pmurias/nqp-js/commit/fcf4d5f1a1

[11:35] *** pmurias joined
[11:36] <pmurias> people seem to really love benchmarking arithmetic

[11:37] <vendethiel> no idea why :-)

[11:37] <jnthn> nwc10: Bumped default opt level to O2, from O1

[11:37] <jnthn> We used to get into problems with that

[11:38] <jnthn> Maybe the warnings fixes helped nail the issues, maybe it was other improvements (like being stricter about various things when doing the BE stuff)

[11:40] <rurban> Released parrot-7.0.1

[11:40] <lizmat> rurban++

[11:43] <dalek> rakudo/nom: 3e97dc9 | lizmat++ | tools/build/NQP_REVISION:

[11:43] <dalek> rakudo/nom: Bump NQP to get better optimized MoarVM

[11:43] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/3e97dc9fc8

[11:55] <nine> What would be the correct syntax for something like my $handle_tag = sub($tag, $num, *@attrs) { ... }?

[11:59] <jnthn> m: my $handle_tag = sub($tag, $num, *@attrs) { ... }

[11:59] <camelia> rakudo-moar a05dc9: OUTPUT¬´[31m===[0mSORRY![31m===[0m Error while compiling /tmp/yv6tWcNIO9‚ê§Variable '$tag' is not declared‚ê§at /tmp/yv6tWcNIO9:1‚ê§------> [32mmy $handle_tag = sub($tag[33m‚èè[31m, $num, *@attrs) { ... }[0m‚ê§    expecting any of:‚ê§        postfix‚ê§¬ª

[11:59] <jnthn> m: my $handle_tag = sub ($tag, $num, *@attrs) { ... }

[11:59] <camelia> rakudo-moar a05dc9: ( no output )

[11:59] <jnthn> Need the space there; foo(.... is always a function call.

[11:59] <nine> Oh, thanks!

[12:05] *** anaeem1__ joined
[12:07] *** anaeem1_ left
[12:08] *** andreoss joined
[12:12] *** zakharyas left
[12:15] <lizmat> ok, so I just built rakudo on parrot with 7.0.1, and it build and spectested clean

[12:15] <lizmat> so I guess a bump there is in order as well, right rurban?

[12:17] <rurban> yes, please

[12:18] <rurban> there are two improvement branches for nqp and rakudo open, called parrot-rpa

[12:19] <rurban> this is optional if you want better speed on parrot

[12:19] <lizmat> one thing at a time  :-)

[12:19] <moritz> pmichaud didn't see too happy about removing qrpa

[12:21] <dalek> nqp: 4589d81 | lizmat++ | tools/build/PARROT_REVISION:

[12:21] <dalek> nqp: Bump Parrot to 7.0.1

[12:21] <dalek> nqp: review: https://github.com/perl6/nqp/commit/4589d81252

[12:22] <rurban> yes, what can I do.

[12:23] <rurban> I took his qrpa code and improved it

[12:24] *** frew left
[12:26] *** tinyblak joined
[12:28] *** abraxxa left
[12:29] *** Kristien joined
[12:29] *** rurban1 joined
[12:31] <lizmat> hmmm....  that last NQP bump did not work out for parrot: it doesn't build

[12:31] <lizmat> with rakudo now

[12:32] <lizmat> rurban: could you verify that RELEASE_7_0_1 is the correct tag ?

[12:32] * lizmat is a complete parrot noob

[12:36] <moritz> lizmat: yes, that's correct

[12:41] *** yeahnoob joined
[12:46] <lizmat> ok, seems to build now

[12:46] <lizmat> guess I did something wrong

[12:48] *** rindolf left
[12:49] *** rindolf joined
[12:51] <psch> hi #perl6 \o

[12:51] <psch> raiph++ # jvm interop testing

[12:51] <rurban1> lizmat: yes, RELEASE_7_0_1 is good.

[12:51] <psch> apparently the old marshalling (for longnames and not-overloaded methods) is still broken

[12:52] <psch> and it's annoying to fix, because i have to write bytecode that loops and unboxes...

[12:52] <lizmat> rurban1: spectesting now

[12:52] <rurban1> I am working on an 10% faster parrot right now, with an improved StringBuilder. benchmark at https://github.com/parrot/parrot-bench#parrot-bench

[12:53] <psch> .tell raiph i apparently missed fixing marshalling of List-y types for non-overloaded methods.  that's the error you're seeing with "method/update/([B)V"

[12:53] <yoleaux> psch: I'll pass your message to raiph.

[12:57] *** skids left
[12:57] *** anaeem1__ left
[13:00] <lizmat> Files=876, Tests=33426, 451 wallclock secs (10.51 usr  3.55 sys + 2916.91 cusr 410.29 csys = 3341.26 CPU)    # before bump

[13:00] *** Kristien left
[13:00] <lizmat> Files=876, Tests=33426, 474 wallclock secs (10.78 usr  3.76 sys + 3023.09 cusr 424.04 csys = 3461.67 CPU)   # after bump for parrot

[13:00] <lizmat> could be noise, but the tendency seems towards being slower

[13:01] <dalek> rakudo/nom: 912a7fa | lizmat++ | tools/build/NQP_REVISION:

[13:01] <dalek> rakudo/nom: Bump NQP for parrot 7.0.1

[13:01] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/912a7fae52

[13:05] *** tinyblak left
[13:05] *** tinyblak joined
[13:05] *** kaare_ left
[13:09] *** tinyblak_ joined
[13:12] *** tinyblak left
[13:13] *** zakharyas joined
[13:15] *** rindolf left
[13:31] *** H2O1 joined
[13:32] *** H2O1 left
[13:33] <jmark> Hi, all! I'm skimming the official perl6 doc and wondering if "sized low-level types" (will) lead to any optimization comparable to cython?

[13:33] <moritz> jmark: low-level types generally are much faster

[13:34] <moritz> jmark: though there aren't any optimizations for the sized ones in particular, I think

[13:34] <moritz> jmark: so far they are mostly implemented to make it easier to interface with libraries written in C

[13:37] <jmark> I would be satisfied when I do just some number crunching with ints and floats I could get near the speed of light.

[13:38] <moritz> we're working on it :-)

[13:38] <jmark> Without using C::Inline and such.

[13:38] <jmark> nice!

[13:42] <[Coke]> Util++ rurban++ # parrot releases

[13:44] <FROGGS> moritz: I was under the impression that operations with native types are jitted well

[13:44] <jnthn> Within the next month we should have natively typed arrays also, which will make the native types stuff a whole lot more useful.

[13:45] <FROGGS> and we'll have write accessors on native attributes /o/

[13:46] <nwc10> and a pony?

[13:46] <jnthn> Well, if I catch another winter cold I might be a little horse again...

[13:48] <nwc10> if so, be careful, lest you end up in Tesco

[13:49] *** andreoss left
[13:55] <[Coke]> nwc10: the pony's dead, you know that.

[13:55] <nwc10> yes, very true that.

[13:56] * moritz notices that "the pony's dead" is a wonderful text for this tune: http://de.wikipedia.org/wiki/Der_Hahn_ist_tot_%28Kanon%29

[13:57] <FROGGS> *g*

[14:05] <[Coke]> moritz: Den Hunn ass fr√§kt

[14:06] <jmark> Just read something about "PDL support". Is this what you mean by "natively typed arrays"?

[14:07] *** Kristien joined
[14:08] <moritz> jmark: it's a step in that direction

[14:08] <moritz> jmark: when people read "PDL", they expect to be able to multiple matrices, for example

[14:08] *** anaeem1_ joined
[14:08] <moritz> jmark: that's not part of the core language; storing a matrix as compact as PDL does is, though

[14:09] <jmark> moritz: why not implementing some basic LinAlg, too?

[14:10] <jmark> One operator more or less wouldn't hurt perl6, right? ;)

[14:10] <moritz> jmark: why not do it in a library? :-)

[14:11] *** anaeem1_ left
[14:11] <Kristien> jmark: Noo! It would invalidate everyone's Period Table of the Operators posters!

[14:11] <moritz> jmark: doing linear algebra efficiently doens't quite require the same skill set as implementing a compiler

[14:11] <moritz> jmark: so I'd leave it to other folks

[14:11] <moritz> also, scope creep

[14:11] *** anaeem1_ joined
[14:11] <Kristien> there are already fast linear algebra libraries, like Eigen. use them

[14:12] <jmark> Tooo sad: Just checked ... ** is still free yet, isn't it?

[14:12] <jmark> Kristien: But I want to do some LinAlg in perl6. Eigen is big and clumpsy.

[14:13] <jmark> -p

[14:13] <Kristien> I mean an Eigen binding for Perl 6 :P

[14:13] <psch> m: say &infix:<**>.perl

[14:13] <camelia> rakudo-moar 912a7f: OUTPUT¬´sub infix:<**> ($?, $?) { #`(Sub+{<anon>}+{Precedence}|51016560) ... }‚ê§¬ª

[14:13] <masak> I agree. Perl 6 library + custom operators + fast bindings to something exist sounds just right.

[14:13] <Kristien> or BLAS

[14:14] <jmark> Alright, you convinced me.

[14:14] <moritz> uhm, Eigen is quite small in comparison to many other linear algebra libraries

[14:14] *** ptc_p6 joined
[14:14] <Kristien> SciPy uses BLAS IIRC

[14:14] <moritz> it just doesn't compile very fast, because it does template magic

[14:14] *** ptc_p6 left
[14:14] <moritz> (if we're talking about the same library here :-)

[14:15] <Kristien> yeah that one

[14:15] <jmark> moritz: You can bypass that by precompiling specializations.

[14:15] <Kristien> it uses expression templates to simplify expressions at compile-time

[14:15] <moritz> jmark: but then there's not too much point in using the library, no?

[14:15] <Kristien> expression templates is one of its features, not the only one

[14:16] <moritz> TBH I don't remember too much about it; just that it was less of a fuss to use as other libraries, and had an active and friendly community

[14:16] <jmark> jmark: hmm? But what when I just need to do some bigger float matrix multiplications but being still in the compile run cycle of my application.

[14:16] * moritz hasn't done too much linalg lately

[14:19] *** anaeem1_ left
[14:20] *** anaeem1 joined
[14:21] <jmark> Could anyone recommend me an elaborate article/howto about "roles" besides the official doc and chromatics "The Why of Perl Roles"?

[14:22] *** anaeem1 left
[14:22] <masak> jmark: random ddg search: http://blogs.perl.org/users/ovid/2011/01/happy-new-yearroles.html http://blogs.perl.org/users/ovid/2014/12/using-role-as-partial-classes.html http://strangelyconsistent.org/blog/ovid-is-right-roles-are-awesome

[14:22] <masak> I think those might net you a nonzero understanding delta.

[14:22] <masak> er, a positive one, even ;)

[14:23] <moritz> jmark: the academic research calls them "traits", might also help searching in that direction

[14:24] <masak> jmark: that reminds me: https://github.com/perl6/specs/issues/80 will be interesting reading to you, too. it has links to the two relevant papers.

[14:27] *** ptc_p6 joined
[14:28] <Kristien> http://doc.perl6.org/language/modules mentions only GitHub

[14:28] <Kristien> does that mean you can't publish modules without putting them on GitHub?

[14:28] *** skids joined
[14:29] <moritz> Kristien: currently our infrastructure is very github-centric

[14:30] <moritz> Kristien: contributions to diversify that are very welcome

[14:30] <Kristien> OK.

[14:30] *** kaleem left
[14:31] *** Kristien left
[14:32] <jnthn> I guess any Git repo will actually do it?

[14:33] <moritz> jnthn: I'm afraid not

[14:33] <moritz> jnthn: there are some parts (like generating the module list) that check for github URLs

[14:33] <jnthn> Oh

[14:33] <moritz> jnthn: though I'm not entirely sure

[14:42] <skids> Is there a standard way yet to tell panda "use this commit for vX.Y.Z"?

[14:44] *** clkao left
[14:44] *** clkao joined
[14:48] *** rurban left
[14:50] *** Rounin left
[14:55] *** booly-yam-6137__ left
[14:55] <moritz> skids: have you tried to create a tag in git?

[14:56] *** booly-yam-1010 joined
[14:57] <PerlJam> Does panda have a way to checkout a tag/

[14:57] <PerlJam> ?

[14:57] <moritz> dunno

[14:57] * PerlJam doubts

[14:57] <moritz> but skids' question sounded as if it has a way to checkout a commit

[14:58] <moritz> and if it does, it'll probably support tags too

[15:06] *** PZt joined
[15:08] <FROGGS> AFAIK panda does not support installing a certain commit/tag

[15:09] <FROGGS> but, one can `panda look Foo::Bar`, then do a git checkout to the desired comit/tag, and then do `panda install .`

[15:11] *** telex left
[15:12] *** telex joined
[15:13] *** tinyblak_ left
[15:14] *** kurahaupo left
[15:19] *** ptc_p6 left
[15:19] *** ptc_p6 joined
[15:22] *** kaleem joined
[15:22] <PerlJam> Here's a diff (untested) that will support adding  @tag (or other committish things) to the end of the github URLs -- https://gist.github.com/perlpilot/d3001269e80f26915a27

[15:23] *** kaleem left
[15:24] <PerlJam> \w probably needs to change though since that won't match .

[15:27] *** Kristien joined
[15:29] *** kurahaupo joined
[15:30] *** adu left
[15:32] <PerlJam> updated with a better committish matcher

[15:33] *** rurban1 left
[15:41] <hoelzro> I was playing around with type coercion (ex. MyType('')), and I noticed that if I implement postcircumfix:<( )> for MyType, that method receives a Capture as its single argument, rather than the value being coerced.  Is there a reason for this?

[15:41] <moritz> \S+ as a first approximation?

[15:42] <moritz> hoelzro: something bootstrappy, iirc

[15:42] <hoelzro> hmm

[15:42] <hoelzro> moritz: thanks for the input

[15:43] <jnthn> The bootstrappy reason is gone-ish these days, though.

[15:44] <hoelzro> I'm going to try building/spectesting with passing the value itself, rather than a capture

[15:44] <hoelzro> for experimental purposes

[15:44] <jnthn> I'm a bit bothered about coercion stuff overall, fwiw.

[15:45] <jnthn> We have a parsing problem or even ambiguity on coercion type syntax vs. actually performing a coercion.

[15:46] <jnthn> I guess we can say that Int(Str) is a coercion type specification because the inner thing and outer thingy are both types.

[15:47] <jnthn> And Int($foo) is a coercion, not a function call, because we don't see a type on the inside of it.

[15:48] <jnthn> But then we try and overload invocation on the type object to mean coercion, except if that's not defined we fall back to calling a .TypeName method

[15:49] <jnthn> Except if you have a multi that only accepts calls on instances then you get a dispatch error and not falback to the method call

[15:53] *** Kristien left
[15:53] *** adu joined
[16:02] <lizmat> http://www.google.com/safebrowsing/diagnostic?site=perl6.org    # *phew*  :-)

[16:03] <hoelzro> jnthn: I'm not a fan of it either

[16:04] *** booly-yam-1010 left
[16:04] <skids> jnthn: Wasn't Type() (with no args) on the road to deprecation, though?

[16:07] <jnthn> .oO( The road to deprecation is paved with melting features )

[16:07] <jnthn> I thought Type() was kinda short for Type(Mu) or maybe Type(Any)

[16:08] *** booly-yam-9299 joined
[16:09] *** regreg joined
[16:10] <skids> Oh now I think I understand.  So really it is just a matter of when people define their own coercers, ensuring they provide a path to the fallback?

[16:11] *** rindolf joined
[16:14] *** pecastro left
[16:15] <lizmat> m: class A { method Int { say "foo" } }; Int(A)   # just about

[16:15] <camelia> rakudo-moar 912a7f: OUTPUT¬´foo‚ê§¬ª

[16:16] *** gfldex joined
[16:17] <skids> So is this just a case of "This hurts doctor"/"So don't do that" which could be "patched" through enculturation?

[16:17] *** pecastro joined
[16:19] <skids> I guess it would not be possible to warn like "Defining Int coercer without a :D ill advised" because the type named the same as the coercer might not yet exst... and at runtime that would be a long search to track them all down.

[16:21] <hoelzro> ok, doing that experiment broke a few tests

[16:21] <hoelzro> 7, to be exact

[16:21] <hoelzro> so not bad

[16:22] *** kjs__ left
[16:22] <hoelzro> it's not spec'd how to override MyType(Str), is it?

[16:22] <hoelzro> just that MyType(Str) looks like a function call, and it's a coercion?

[16:22] <lizmat> m: class A { method Int { say "foo" } }; A(Int)   # the other way around

[16:22] <camelia> rakudo-moar 912a7f: OUTPUT¬´Cannot find method 'A'‚ê§  in block <unit> at /tmp/iDu7MxkyRo:1‚ê§‚ê§¬ª

[16:23] <lizmat> that goes looking for a method A in Int

[16:23] *** rurban joined
[16:24] <lizmat> m: class A { multi method A(Int:U:) { say "foo" } }; A(Int)   # does this work?

[16:24] <camelia> rakudo-moar 912a7f: OUTPUT¬´Cannot find method 'A'‚ê§  in block <unit> at /tmp/0cn73E9U5z:1‚ê§‚ê§¬ª

[16:24] <hoelzro> lizmat: I tried implementing postcircumfix:<( )> on MyType, that *works*, in that the function is called

[16:25] <hoelzro> but a Capture is passed, rather than the value itself

[16:25] <hoelzro> which is fine, except it's not spec'd (iirc), and I think that would throw a new user of Perl 6

[16:25] <lizmat> yeah, but that approach feels wrong to me

[16:25] <hoelzro> I would honestly just like a multi method coerce($src-type, $dest-type)

[16:25] <skids> m: class A { method Int { say "foo" } }; Int.(A) # that is worse, appearence-wise.

[16:25] <camelia> rakudo-moar 912a7f: OUTPUT¬´foo‚ê§¬ª

[16:26] <PerlJam> hoelzro: maybe spelled COERCE because it's something that Perl will call on your behalf?

[16:26] <hoelzro> so if I want to tell Perl 6 how to coerce Strs into MyTypes, I need only implement multi coerce(Str $value, MyType) { ... }

[16:26] <hoelzro> PerlJam: oh, good call

[16:26] <hoelzro> (no pun intended)

[16:26] <jnthn> hoelzro: Aside from the fact it will have an epic number of candidates, a multi COERCE ain't so bad.

[16:27] <hoelzro> jnthn: epic indeed

[16:28] <hoelzro> we could also have a fallback multi COERCE(Any $value, Any:U $type) { my $name = $type.^name; $value."$name"() }

[16:28] <hoelzro> so that .Str and friends still works

[16:29] <hoelzro> I think it should be easy, when defining a new type, to control how values of other types may be converted into my new type, whether or not I control those other types

[16:29] <hoelzro> (I suppose, given the nature of Perl 6, "control" is a murky term =/)

[16:33] <PerlJam> Most of the "control" seems like it would be the compiler carping about "I don't know how to convert TypeA into TypeB, perhaps you should write a multi COERCE(A,B) routine"

[16:34] <hoelzro> right, in this case, the control would be black magic-free

[16:35] <hoelzro> instead of, for example, having to monkey patch TypeA

[16:36] <skids> Don't I remember reading something about if the source type doesn't have an opinion on the matter, then go see if the destination type does?

[16:37] *** kaleem joined
[16:37] <jnthn> skids: That's the basic idea of the current policy, yes, but having an opinion is currently a bit all-or-nothing

[16:38] <hoelzro> I think it's actually the other way around; I think the destination type is checked first, then the source type is consulted

[16:38] *** denis_boyun_ left
[16:38] <jnthn> Oh?

[16:38] <jnthn> Quite possibly. :)

[16:38] <hoelzro> I *think* so

[16:38] <hoelzro> my Rakudo fu is quite weak =)

[16:38] <skids> Not according to lizmat++s example above.

[16:38] <jnthn> Ah, yeah, destination is the invoke-y one

[16:39] *** panchiniak joined
[16:39] <hoelzro> https://github.com/rakudo/rakudo/blob/nom/src/Perl6/Metamodel/BOOTSTRAP.nqp#L2644

[16:39] *** FROGGS left
[16:39] <hoelzro> if you can invoke the type, try it; otherwise, try $value."$typename"

[16:40] <lizmat> fwiw, a COERCE method feels in line with things like ACCEPTS

[16:41] <hoelzro> jnthn, you mentioned that the dispatch table for such a multi would be huge; how bad are the implications of that?

[16:41] <skids> Is there a way to split a proposed COERCE up to reduce the candidates?

[16:42] <jnthn> hoelzro: With the present way things work, it depends how many of them you hit in the time a program is running.

[16:43] <jnthn> hoelzro: If we totally fill up the multi-dispatch cache then dispatches not in it get slow and spesh can't do much 'cus it looks at the cache.

[16:43] <jnthn> We could of course make the cache growable.

[16:43] <hoelzro> ah ha

[16:44] <jnthn> Or re-focus the caching around the callsite, not the callee

[16:45] <skids> That might be an interesting generic thing to do once a high water mark gets hit.

[16:45] <japhb> jnthn: This reminds me, how will spesh react to a class Foo { has $.bar handles * }, when $.bar changes every so often (say, every 1000 method calls to a Foo instance)?

[16:46] <japhb> Well, not just spesh, but all method-call optimizations, really

[16:46] <jnthn> japhb: Changes *object* or changes type of object?

[16:46] <japhb> Changes the object instance, but $.bar always has the same type.

[16:47] <jnthn> Spesh cares about types

[16:47] <jnthn> So if it does something there it'll likely have a guard on the type $.bar gives back

[16:47] <japhb> So if the type were allowed to vary, then what?

[16:47] <jnthn> Probably if you're stable for a while it'll specialize assuming it'll always be that type

[16:48] <jnthn> And then when it changes, you'll hit the deopt path every time.

[16:48] <japhb> Forever more?  Or will it notice a "new stable" and try again?

[16:48] <jnthn> In the long run, we'll keep stats on deopt rates and retire specializations that work out badly.

[16:49] <jnthn> Forevermore. It's kinda the generational hypothesis for optimization: either things vary in type a lot, or keep the same type, and things in the middle are rarer 

[16:49] * japhb wonders if "punctuated equilibrium" is pessimal for r-m right now

[16:49] <japhb> nodnod

[16:49] <jnthn> Yes, we likely handle that less well at the moment.

[16:49] *** rurban_ joined
[16:49] *** jluis_ joined
[16:50] <jnthn> Though if you have just a couple of places in your program like that, it's not the end of the world.

[16:50] <japhb> How is 'handles *' actually implemented?  Does Foo's method cache just fill up with entries from $.bar over time?

[16:50] <japhb> true

[16:50] <jnthn> No, I doubt it's actually very optimal at all at the moment.

[16:51] <PerlJam> Could there be an op exposed to Rakudo that could trigger a "respecialization"?  (so that you could manually control it for the puntuated equilibrium that japhb mentioned)

[16:51] <jnthn> PerlJam: I think better to let the VM keep stats and learn, tbh.

[16:53] * TimToady wonders how long the world stayed optimized for dinosaurs after the asteroid...

[16:53] <TimToady> or rather, deoptimized for everyone...

[16:54] <japhb> ISTR reading something that the world was already beginning to deopt for existing species before the asteroid hit, and that just put the cap on it.

[16:54] <TimToady> too many megamorphs running around

[16:54] <skids> COERCEASAURUS

[16:55] <japhb> Yeah, here it is: http://arstechnica.com/science/2014/12/massive-volcanic-eruptions-set-the-stage-for-dinosaurs-demise/

[16:56] <skids> That was just the earth breaking into a sweat because it knew it was about to be beaned on the forehead :-)

[16:56] <adu> metamorph?

[16:56] <japhb> heh

[16:56] *** Otterpocket joined
[16:57] *** Otterpocket left
[16:57] <adu> Kyodai Ka?

[16:58] <dalek> perl6-roast-data: 30fa912 | coke++ | / (5 files):

[16:58] <dalek> perl6-roast-data: today (automated commit)

[16:58] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/30fa912ad7

[16:58] <TimToady> Âº∑Â§ß„ÇÇ„ÄÇ

[16:59] *** zakharyas left
[16:59] *** kjs__ joined
[17:01] <adu> ‚ø∞Âºì‚ø±Âè£Ëô´

[17:01] *** rurban left
[17:01] <adu> Â∑®Â§ßÂåñ

[17:02] <adu> Megawandler

[17:03] <pmurias> jnthn: Can setinvokespec be called multiple times on the same type?

[17:05] <jnthn> pmurias: Um...not sure we refuse it, but the behavior isn't very defined. :)

[17:05] <jnthn> In practice, it doesn't happen anywhere I can think of.

[17:05] *** yeahnoob left
[17:05] *** Otterpocket joined
[17:11] *** vendethiel left
[17:13] *** vendethiel joined
[17:16] *** Kristien joined
[17:19] <Kristien> hola

[17:19] *** LLamaRider joined
[17:20] <TimToady> halo

[17:24] <[Coke]> m: sub Int() { say "3" } ; say Int(); say Int(10);

[17:24] <camelia> rakudo-moar 912a7f: OUTPUT¬´0‚ê§10‚ê§¬ª

[17:24] <[Coke]> Should the sub declaration there complain ?

[17:26] <japhb> If type coercion will always win, then yes.

[17:27] *** Otterpocket left
[17:27] <japhb> (There's an argument to be made that an our sub might actually be usable, but at the very least this should be a warning.)

[17:29] *** kaleem left
[17:31] <jnthn> One does start to wonder if we might be hanging things off the wrong peg somehow with coercion...

[17:32] <TimToady> where have I heard that metaphor before... :)

[17:33] * TimToady thinks of type names as new reserved words, basically

[17:33] <[Coke]> m: say Int("three"); say Complex("Sausage")

[17:33] <camelia> rakudo-moar 912a7f: OUTPUT¬´Cannot convert string to number: base-10 number must begin with valid digits or '.' in '‚èèthree' (indicated by ‚èè)‚ê§  in method Int at src/gen/m-CORE.setting:14137‚ê§  in method Int at src/gen/m-CORE.setting:6340‚ê§  in block <unit> at /tmp/Ca0NYzo2Jd:1‚Ä¶¬ª

[17:33] <[Coke]> m:  say Complex("Sausage")

[17:33] <camelia> rakudo-moar 912a7f: OUTPUT¬´Cannot find method 'Complex'‚ê§  in block <unit> at /tmp/ukzPHD4Vbs:1‚ê§‚ê§¬ª

[17:34] <[Coke]> the Int error makes sense. the Complex one does not. (also, should I be testing this on master?)

[17:34] <[Coke]> er, nom?

[17:34] *** vendethiel left
[17:34] <TimToady> were you thinking of that as a coercive type?

[17:35] <TimToady> I don't think 6pe is merged quite yet, though I still have some backlog...

[17:35] *** tgt joined
[17:35] <[Coke]> Yes. I was expecting I could pick arbitrary core classes and try to coerce to them.

[17:36] <[Coke]> ah, ok. I'll wait until post merge before poking more, I guess. or switch to that branch and poke.

[17:37] <jnthn> At the moment, 6pe would give you all the same answers to the things you tried.

[17:37] <jnthn> It only parses a coercion type when typename is hit, which for now is only in explicit calls toit.

[17:37] <TimToady> we need to teach the parser that Int() and Int(SomeType) are coercive types

[17:37] <jnthn> *to it

[17:37] <jnthn> *nod*

[17:37] <TimToady> or is that there already?

[17:38] *** vendethiel joined
[17:38] <jnthn> No, I didn't do that

[17:38] <jnthn> I guess that goes in term:identifier

[17:38] <jnthn> But that now has 3 cases

[17:38] <jnthn> 1) Coercion type

[17:38] <jnthn> 2) Coercion operation

[17:38] <jnthn> 3) Function call

[17:38] <TimToady> basically we stole two syntaxes from ... what you said

[17:38] <jnthn> If we hang it there.

[17:39] <TimToady> doesn't matter so much where a type is already expected

[17:39] <moritz> let's find another use for the colon

[17:39] <TimToady> but as an rvalue...

[17:39] <moritz> Int:(Any) # as coercion type

[17:39] * moritz only 20% serious

[17:39] <jnthn> Yeah, it was no problem in typename, it's the rvalue case... 

[17:39] <TimToady> but I don't think it's semantically ambiguous

[17:39] <TimToady> which is why I picked that in the first place

[17:40] <TimToady> Int(Any) is really a kinda generic for Int($any)

[17:40] <jnthn> I think we can differentiate it without WATs...

[17:40] <TimToady> and the arg has to be literally a type or ()

[17:40] <jnthn> Right.

[17:40] <jnthn> What a coercion operation compiles into is really the one I'm not comfortable with at the moment.

[17:41] <TimToady> you mean Int($foo)?

[17:41] <jnthn> Yeah

[17:42] <jnthn> At the moment it's a call to an internal function that does a bunch of introspection.

[17:42] <jnthn> Which is, uh, LTP.

[17:42] <TimToady> ...parsimonious?

[17:42] <jnthn> Performant is what I had in mind...

[17:42] <TimToady> ...peggy?

[17:43] <TimToady> ...puresmelling

[17:43] *** FROGGS joined
[17:43] *** rmgk_ joined
[17:43] *** rmgk left
[17:43] *** rmgk_ is now known as rmgk

[17:43] <TimToady> it really is sort of an instantiation of the generic coercion type

[17:43] <moritz> ...probabilistic

[17:44] <jnthn> TimToady: That's pretty much how it's been implemented :)

[17:44] *** kjs__ left
[17:46] *** booly-yam-9299 left
[17:46] <jercos> japhb: haha, yes, that was what I was looking for. Thanks :)

[17:47] <jercos> m: say "whatever".WHAT

[17:47] <camelia> rakudo-moar 912a7f: OUTPUT¬´(Str)‚ê§¬ª

[17:47] <jercos> m: say "whatever".methods.grep({$_.gist ~~ /^fl/})

[17:47] <camelia> rakudo-moar 912a7f: OUTPUT¬´No such method 'methods' for invocant of type 'Str'‚ê§  in block <unit> at /tmp/RYnbpgIk9L:1‚ê§‚ê§¬ª

[17:47] <jercos> erm

[17:47] <jercos> m: say "whatever".^methods.grep({$_.gist ~~ /^fl/})

[17:47] <camelia> rakudo-moar 912a7f: OUTPUT¬´‚ê§¬ª

[17:47] *** booly-yam-9299_ joined
[17:48] <jercos> Oh, it's on Cool, haha, got it.

[17:48] <jnthn> .^methods(:all)

[17:49] <moritz> m: say 'whatever'.^methods(:all).grep({.name ~~ /^fl/})

[17:49] <camelia> rakudo-moar 912a7f: OUTPUT¬´floor flip flat flatmap‚ê§¬ª

[17:49] *** denis_boyun joined
[17:50] <jercos> Well yes, that totally works, but doesn't tell me where it's actually from.

[17:50] <jercos> And gives a rather huge list to look through on a Str, if I didn't already know what I was looking for

[17:51] <jnthn> m: say 'whatever'.^methods(:all).grep({.name ~~ /^fl/})>>.package.say

[17:51] <camelia> rakudo-moar 912a7f: OUTPUT¬´(Cool) (Cool) (Any) (Any)‚ê§True‚ê§¬ª

[17:51] <moritz> jercos: http://doc.perl6.org/type/Str nicely tells you where which method comes from

[17:52] <jnthn> m: say 'whatever'.^methods(:all).grep({.name ~~ /^fl/}).map({ "{.name} in {.package.^name}" })

[17:52] <camelia> rakudo-moar 912a7f: OUTPUT¬´floor in Cool flip in Cool flat in Any flatmap in Any‚ê§¬ª

[17:52] *** pmurias left
[17:52] <jnthn> .oO( That's flipin cool! )

[17:52] <jercos> bril :D

[17:53] <jercos> I'm still sorta on the fence about Cool in general though :p

[17:53] <jnthn> So...you're a bit cool about it?

[17:53] <jercos> Most of the methods it bears seem to act like either self.Numeric.something or self.Str.something

[17:53] <jnthn> Yes

[17:54] <TimToady> that's what it's for :)

[17:54] <jnthn> It's a strongly typed implementation of weak typing...

[17:54] <jercos> But without any indication from the method itself which is which

[17:54] <tony-o_> hoelzro: i think i have a fix for the bug you discovered in html-parser-xml

[17:54] <moritz> http://doc.perl6.org/type/Cool has the table of which method coerces to which

[17:55] * moritz feels a small mental reward each time he can point to a point of doc.perl6.org to answer a question that folks actually ask

[17:55] <jercos> Indeed it does. And most of them are pretty obvious.

[17:56] <jercos> I don't think anyone would expect .cos() to be anything but Numeric :p

[17:56] <jnthn> moritz: Yes, doc.perl6.org increasingly seems to have the answers to things :)

[17:56] <moritz> jercos: except when they expect cos play :-)

[17:56] <jercos> And of course the return type is programmatically accessible as well, I suppose.

[17:57] <moritz> http://doc.perl6.org/type/Signature#method_returns

[17:57] <moritz> :-)

[17:58] <moritz> m: say Cool.^find_method('cos').signature.returns.^name

[17:58] <camelia> rakudo-moar 912a7f: OUTPUT¬´Mu‚ê§¬ª

[17:58] <moritz> but it seems to be not declared :(

[17:58] *** virtualsue left
[17:58] <moritz> m: say Cool.^find_method($_).signature.returns.^name for <chop abs floor>

[17:58] <camelia> rakudo-moar 912a7f: OUTPUT¬´Mu‚ê§Mu‚ê§Mu‚ê§¬ª

[17:58] <moritz> :(

[17:59] <TimToady> m: say Num.^find_method('cos').signature.returns.^name

[17:59] <camelia> rakudo-moar 912a7f: OUTPUT¬´Mu‚ê§¬ª

[17:59] <TimToady> that one really oughta say Num anyway

[17:59] <moritz> the methods in Cool don't seem to declare return types right now

[17:59] *** Rounin joined
[18:01] <moritz> TimToady: I think the sentiment so far has been to declare return types where they give a performance boost, which is just for subs so far

[18:01] <moritz> m: say IO::Handle.^find_method('tell').signature.returns.^name

[18:01] <camelia> rakudo-moar 912a7f: OUTPUT¬´Mu‚ê§¬ª

[18:01] <[Coke]> moritz: should they need to if they have a single return point and that item declares a return? (I'm assuming yes because that level of introspection is hard)

[18:02] <moritz> [Coke]: you are correct

[18:02] <TimToady> m: say Cool.^find_method('ord').signature.returns.^name

[18:02] <camelia> rakudo-moar 912a7f: OUTPUT¬´Int‚ê§¬ª

[18:02] <moritz> $ git grep 'method \w.*returns'|wc -l

[18:02] <moritz> 9

[18:03] <TimToady> m: say ord(42)

[18:03] <camelia> rakudo-moar 912a7f: OUTPUT¬´52‚ê§¬ª

[18:03] <moritz> m: say chr 52

[18:03] <camelia> rakudo-moar 912a7f: OUTPUT¬´4‚ê§¬ª

[18:04] *** denis_boyun left
[18:05] <TimToady> some kinds of optimiztions depend on knowing the return type, so I think we should work towards getting return types declared and performant

[18:05] <TimToady> I realize that's more of an AOT concern than a spesh concern

[18:05] <TimToady> but we really don't want to penalize folks for declaring their return types

[18:06] <jnthn> I don't think there's much penalty at all

[18:06] <TimToady> maybe there was at some point in the past?

[18:06] <jnthn> Yes

[18:06] <jnthn> But today should really not be

[18:06] <jnthn> Spesh probably strips a bunch of those checks out when it can prove they're not needed also

[18:06] <TimToady> goodgood

[18:10] <TimToady> I assume spesh can also deal with the optimization of Foo(Any) coercions when we start combining multis that currently are there only to provide Any,Any parameters that map to Foo,Foo?

[18:11] * lizmat recently removed a return type because it could also return a Failure

[18:12] <jnthn> At the moment, Foo(Any) $x is deconstructed in the signature into the same thing that Any $a as Foo has turned into

[18:12] <lizmat> and that broke 

[18:12] <TimToady> lizmat: yes, that's also a concern

[18:12] <jnthn> Which is a nice fast, cachable, nominal type match on Any, and then there's an istype guard against Foo

[18:13] <jnthn> If spesh sees it already is a Foo, then it turns the branch into a goto and the coercion becomes dead code and vanishes.

[18:14] <TimToady> but that's on the callee end, whereas the multies might get duomorphically cached on the caller end?

[18:14] <TimToady> so maybe not equiv

[18:15] <TimToady> I don't imagine we do per-caller speshing like that

[18:15] <TimToady> well, unless you've inlined first...

[18:15] <jnthn> Well, it's done at the callee

[18:15] <jnthn> Uh

[18:15] <jnthn> Specializations are per-callee

[18:15] <jnthn> But the caller might be specialized to call a particular specialization.

[18:16] <jnthn> That's a pre-req for inlining, in fact.

[18:16] <TimToady> so we don't lose that information?

[18:16] <jnthn> Inlining is "just" going one step further when you've decided you know exactly where the call is going.

[18:17] <jnthn> No, if when specializing the caller we find the callee has a specialization that fits, we just emit an invoke op that points directly to the specialization.

[18:17] <TimToady> suppose you have 10 call sites that are monomorphic on the call, but collectively are megamorphic.  do we deopt?

[18:17] *** Hor|zon left
[18:18] * jnthn looks confusedly at the question :)

[18:18] <TimToady> I can well imagine a generic having that behavior when instantiated 10 different ways

[18:19] <jnthn> We only deopt locally if we fail a guard, or globally if we have a mixin or some other such action-at-a-distance change.

[18:19] <TimToady> locally meaning in the caller?

[18:19] <jnthn> So far as 6model parametric stuff and spesh interact so far, each parameterization can have its own specialization.

[18:20] <jnthn> Locally meaning the frame we're in when the guard fails

[18:20] <jnthn> Note that if we are optimizing a call and there's no specialization of the callee that type-matches what we have, then we just leave the slower-path call in place.

[18:21] <jnthn> Though we may cache the code object if it's a lexical that isn't going to change.

[18:21] <jnthn> The thing is structured to specialize on frame *exit*, not entry, so your callees of lesser or similar size will always have been specialized before you.

[18:23] <TimToady> nod

[18:23] *** vendethiel left
[18:24] <TimToady> I love the response 'nod' because it conveys anything from "I hear you" to "I agree completely", and in general conveys greater intelligence than is felt. :)

[18:25] <jnthn> nod

[18:27] *** tgt left
[18:27] <TimToady> :D

[18:32] <[Coke]> returns Int:F # normally an Int, but potentially a Failure.

[18:32] <[Coke]> perhaps?

[18:33] <Kristien> F# :o

[18:33] *** FROGGS_ joined
[18:34] <TimToady> Int() would coerce failure to Int :)

[18:36] *** Sqirrel left
[18:36] *** FROGGS left
[18:38] <ab5tract> jnthn: here's a smaller example which seems to trigger segfaults and unhandled exceptions https://gist.github.com/ab5tract/34408eaa7b5c64dc84a7

[18:39] <ab5tract> i think it is the same behavior i saw previously when playing around with raw thread locking in perl 6

[18:42] *** Hor|zon joined
[18:44] <japhb> [Coke]: Perhaps 'Int?' instead of 'Int:F'?  I don't think we use 'Type?' syntax yet ....

[18:45] <jnthn> ab5tract: Yes, I've got a collection of issues like that to look into...

[18:45] <jnthn> dinner &

[18:45] <ab5tract> enjoy! (the dinner)

[18:48] *** Kristien left
[18:51] *** vendethiel joined
[18:52] <dalek> doc: 9d785d6 | moritz++ | lib/Type/ (2 files):

[18:52] <dalek> doc: Document run, shell, Proc::Status

[18:52] <dalek> doc: review: https://github.com/perl6/doc/commit/9d785d6728

[18:52] <dalek> doc: 5efa369 | moritz++ | lib/Type/Metamodel/MROBasedMethodDispatch.pod:

[18:52] <dalek> doc: Document .^find_method_qualified

[18:52] <dalek> doc: review: https://github.com/perl6/doc/commit/5efa369442

[18:53] <dalek> doc: 64385e5 | (Geoffrey Broadwell)++ | htmlify.p6:

[18:53] <dalek> doc: Improve preamble boilerplate for type graph SVG image

[18:53] <dalek> doc: review: https://github.com/perl6/doc/commit/64385e5a9b

[18:53] <dalek> doc: e87e534 | (Geoffrey Broadwell)++ | lib/Type/ (3 files):

[18:53] <dalek> doc: Merge branch 'master' of https://github.com/perl6/doc

[18:53] <dalek> doc: review: https://github.com/perl6/doc/commit/e87e534e36

[18:56] <[Coke]> japhb: I would expect Int? to mean it could return Nil, I think.

[18:56] <hoelzro> tony-o_: hooray!

[18:57] <[Coke]> m: sub bar() returns Int { Nil }; my Int foo = bar(); say "y"

[18:57] <camelia> rakudo-moar 912a7f: OUTPUT¬´[31m===[0mSORRY![31m===[0m Error while compiling /tmp/FS5VUU6Yx3‚ê§Malformed my (did you mean to declare a sigilless \foo or $foo?)‚ê§at /tmp/FS5VUU6Yx3:1‚ê§------> [32mub bar() returns Int { Nil }; my Int foo[33m‚èè[31m = bar(); say "y"[0m‚ê§¬ª

[18:57] <hoelzro> I was going to start just using the XML module =)

[18:57] <[Coke]> m: sub bar() returns Int { Nil }; my Int $foo = bar(); say "y"

[18:57] <camelia> rakudo-moar 912a7f: OUTPUT¬´Type check failed for return value; expected 'Int' but got 'Any'‚ê§  in any return_error at src/vm/moar/Perl6/Ops.nqp:649‚ê§  in block <unit> at /tmp/4FnwFk8TnL:1‚ê§‚ê§¬ª

[18:57] <TimToady> Int? would be a Maybe type, not an Error type, to put it into Haskellian terms

[18:58] <japhb> Yeah, fair enough.

[18:58] <TimToady> it's also ambiguous currently with optional params

[18:58] <japhb> Oh, for when you don't even specify a sigil?

[18:58] <TimToady> m: sub foo (Int?) { say "here" }; foo()

[18:58] <camelia> rakudo-moar 912a7f: OUTPUT¬´[31m===[0mSORRY![31m===[0m Error while compiling /tmp/qG1V2W0UIq‚ê§Missing block‚ê§at /tmp/qG1V2W0UIq:1‚ê§------> [32msub foo (Int[33m‚èè[31m?) { say "here" }; foo()[0m‚ê§¬ª

[18:58] <TimToady> o_O

[18:59] <japhb> I guess it's not ambigious in Rakudo ...  ;-)

[18:59] <[Coke]> m: sub foo (Int $?) { say "here" }; foo()

[18:59] <camelia> rakudo-moar 912a7f: OUTPUT¬´here‚ê§¬ª

[19:00] *** Sqirrel joined
[19:01] <TimToady> regarding coercion priority, it's neither of the things suggested at http://irclog.perlgeek.de/perl6/2015-01-23#i_9992611

[19:01] <TimToady> see S13:198

[19:01] <synopsebot> Link: http://perlcabal.org/syn/S13.html#line_198

[19:02] *** ashleydev left
[19:02] *** ashleydev joined
[19:02] <TimToady> you just want to avoid the situation where the functional and method forms are both deferring to each other

[19:04] <TimToady> maybe the right way to do that is to have both forms write a multi COERCE that is the fallback, with poisoning if both ends try to define it

[19:08] *** Hor|zon left
[19:08] *** virtualsue joined
[19:09] *** rindolf left
[19:14] *** vendethiel left
[19:14] <dalek> rakudo/nom: 25da7a9 | moritz++ | src/core/Cool.pm:

[19:14] <dalek> rakudo/nom: Declare a few more return types

[19:14] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/25da7a9d53

[19:15] *** LLamaRider left
[19:17] *** fhelmberger left
[19:17] *** Kristien joined
[19:19] <japhb> moritz: How often is doc.perl6.org regenerated?

[19:20] *** vendethiel joined
[19:20] <Kristien> I just noticed the 6 in the wing of Camelia √ñ

[19:21] <moritz> japhb: 17,47   *       *       *       * ./update-and-sync > update.log 2>&1

[19:24] <hobbs> Kristien: how about the P? :)

[19:24] <Kristien> :O

[19:25] <Kristien> Arguably the P is a rotated 6.

[19:25] <japhb> It would have to be reflected as well, since 9 is a rotated 6.

[19:25] <japhb> moritz: thx

[19:26] <Kristien> Rotated on the Y axis. :P

[19:26] <japhb> s/on/about/, but yes, I get your point.  :-)

[19:29] * japhb is happy that the type graph at http://doc.perl6.org/type/Cool is actually quite informative -- though better at 200% zoom on my monitor

[19:32] <Kristien> I found a nice use-case for Perl 6: my compiler I originally intended to write in Haskell. :D

[19:35] <hoelzro> tony-o_: thanks for the fix; I'll try it out later

[19:36] <raydiak> good morning #perl6

[19:36] *** booly-yam-9299_ left
[19:36] <raydiak> m: multi foo (num) { say "num" }; multi foo (Any) { say "Any" }; foo num # ?

[19:36] <camelia> rakudo-moar 912a7f: OUTPUT¬´Any‚ê§¬ª

[19:38] <moritz> japhb: it would be even nicer if a click on the SVG would zoom it to fill the whole page

[19:38] <moritz> \o raydiak 

[19:38] <moritz> raydiak: native type constraint always constrain to instances

[19:39] *** bjz left
[19:39] <raydiak> o/ moritz

[19:39] <raydiak> m: multi foo (num.new(1)) { say "num" }; multi foo (Any) { say "Any" }; foo num.new(1)

[19:39] <camelia> rakudo-moar 912a7f: OUTPUT¬´[31m===[0mSORRY![31m===[0m Error while compiling /tmp/dgjCf1_OCV‚ê§Missing block‚ê§at /tmp/dgjCf1_OCV:1‚ê§------> [32mmulti foo (num[33m‚èè[31m.new(1)) { say "num" }; multi foo (Any) [0m‚ê§¬ª

[19:40] <raydiak> m: multi foo (num $x) { say "num" }; multi foo (Any) { say "Any" }; foo num.new(1)

[19:40] <camelia> rakudo-moar 912a7f: OUTPUT¬´Any‚ê§¬ª

[19:40] <raydiak> moritz: I'm somewhat unclear what that means, but trying to decypher it :)

[19:41] <moritz> m: say num.^name

[19:41] <camelia> rakudo-moar 912a7f: OUTPUT¬´num‚ê§¬ª

[19:42] <raydiak> m: multi foo ($x where num) { say "num" }; multi foo ($x) { say "other" }; foo num.new(1)

[19:42] <camelia> rakudo-moar 912a7f: OUTPUT¬´num‚ê§¬ª

[19:42] <moritz> raydiak: think of sub foo(num $x) { } as a very low-level thing. It doesn't accept the num type object, only "real" doubles (pun intended)

[19:42] <japhb> moritz: as a popover, or a new tab, or replacing the current page?

[19:43] <moritz> japhb: popover or new tab, IMHO. But I'm open to suggestions :-)

[19:43] *** vendethiel left
[19:43] *** jluis_ left
[19:44] <japhb> New tab is probably easiest, popover *might* be better UX, not sure.

[19:44] *** vendethiel joined
[19:44] *** avalenn_ left
[19:44] <raydiak> imo a lightbox would help, but getting those typegraphs to come out at less extreme aspect ratios would be even better

[19:44] <moritz> well, replacing the current tab would just be an ordinary link

[19:45] <moritz> raydiak: the type graphs are pretty well optimized already, as far as dot output goes

[19:45] <japhb> raydiak: Unfortunately, our type heirarchies tend to be wide but shallow.  Most aren't quite as extreme as Cool, but Any and Exception are so bad I had to special case them to rotate 90 degrees.

[19:46] <japhb> I spent a lot of time tuning the layout heuristics (which is why the current method *usually* looks OK, if not always).

[19:46] <raydiak> oh that's why a few look different :)

[19:46] * moritz finds it quite fortunate that our type hierarchies tend to be not too deep :-)

[19:47] <japhb> moritz: Fortunate for programming, unfortunate for pictures.  ;-)

[19:47] <tony-o_> hoelzro: when you get around to trying it out, can you let me know how it goes and i'll close out the github issue

[19:47] <hoelzro> tony-o_: I will let you know!

[19:48] <japhb> raydiak, if you'd like to experiment with a lightbox, be my guest.  I'm supposed to be reviewing design docs at $dayjob anyhow ....

[19:50] <raydiak> japhb: probably not today, but I'll do it some time soon if nobody else does, b/c you're right that some are kinda a nuissance as is

[19:50] *** Hor|zon joined
[19:51] * raydiak is waiting for that oh-so-elusive thing called "inspiration" to strike for the syn redesign

[19:51] <raydiak> yesterday's work was decidedly uninspired and basically just a waste of time :P

[19:52] <japhb> Sometimes it just takes learning lessons from a lot of 

[19:52] <japhb> "uninspired" days to have one truly inspired one.

[19:52] <moritz> start by removing everything that's ugly?

[19:52] <moritz> .oO( color: white; background-color: white )

[19:52] <japhb> .oO( Cut off his head! )

[19:53] <japhb> moritz: Or just convert the entire page to encoded whitespace as per Acme::Bleach ....

[19:54] *** wilx joined
[19:54] * TimToady likes flat org charts...

[19:56] *** Jefffrey joined
[19:56] <Jefffrey> Hello

[19:56] <Kristien> Hello Jefffrey

[19:56] <raydiak> Helllo o/

[19:57] *** spider-mario joined
[19:57] *** lucas joined
[19:58] <Jefffrey> So...

[19:58] <Jefffrey> Let's talk about Perl 5.

[19:58] <hoelzro> when we were talking about COERCE earlier today, there seemed to be a fair amount of support in favor. How does one get such a change into the language?

[19:58] <hoelzro> should I file a PR against perl6/spec?

[19:59] <PerlJam> hoelzro: works for me.

[20:00] <moritz> hoelzro: the strongest case you can make for it is implement it in rakudo, and push your changes to perl6/specs

[20:00] <moritz> (and tests, and docs, if you're really good :-)

[20:00] <hoelzro> =)

[20:00] <PerlJam> yeah, that's even better

[20:00] <lucas> m: my Nil $x; my True $y; my NaN $z; say 'alive'

[20:00] <camelia> rakudo-moar 912a7f: OUTPUT¬´alive‚ê§¬ª

[20:00] <lucas> ^^^ It seems like I can initialize a variable with some odd values. Is this ok? I would expect only typeobjects to be allowed in that position.

[20:00] <hoelzro> ok, I will endeavor to do that!

[20:01] <PerlJam> hoelzro: but even TimToady often just specs stuff with no implementation  ;)

[20:01] <TimToady> hoelzro: so what do you do if both endpoints define contradictory functions?

[20:01] <hoelzro> I was thinking "spec first" so that people could discuss in case the idea was not well recieved widely

[20:01] <hoelzro> TimToady: for example?

[20:01] <moritz> m: my NaN $z; say $Z

[20:01] <camelia> rakudo-moar 912a7f: OUTPUT¬´[31m===[0mSORRY![31m===[0m Error while compiling /tmp/T0JPa1nWb0‚ê§Variable '$Z' is not declared‚ê§at /tmp/T0JPa1nWb0:1‚ê§------> [32mmy NaN $z; say $Z[33m‚èè[31m<EOL>[0m‚ê§    expecting any of:‚ê§        postfix‚ê§¬ª

[20:01] <moritz> m: my NaN $z; say $z

[20:01] <camelia> rakudo-moar 912a7f: OUTPUT¬´NaN‚ê§¬ª

[20:02] <TimToady> well, did you look at S13:198 like I pointed to earlier?

[20:02] <synopsebot> Link: http://perlcabal.org/syn/S13.html#line_198

[20:02] <TimToady> that's current spec on it

[20:02] <hoelzro> I did not!

[20:02] * hoelzro looks

[20:02] <TimToady> and it allows both ends to specify how they think the coercion should go

[20:02] <TimToady> and it allows the user to pick one or the other in the case that they conflict

[20:02] <moritz> lucas: yes, we allow values in some situations that are usually reserved for types

[20:03] <TimToady> I suggested we earlier we might do COERCE as the mutual fallback though

[20:03] <moritz> m: multi f(0) { 1 }; multi f(Int $x) { $x * f($x - 1) }; say f 4 # for lucas++

[20:03] <camelia> rakudo-moar 912a7f: OUTPUT¬´24‚ê§¬ª

[20:03] <TimToady> that would be one way to avoid infinite regress

[20:03] *** denis_boyun joined
[20:04] <Kristien> m: my ($s, $t) = (Supply.new, Supply.new); my ($p, $q) = ($s.Promise, $t.Promise); $t.emit(1); $s.emit($q); say ($p.result, $p.result.result);

[20:04] <camelia> rakudo-moar 912a7f: OUTPUT¬´Promise.new(scheduler => ThreadPoolScheduler.new(initial_threads => 0, max_threads => 16, uncaught_handler => Callable), status => PromiseStatus::Kept) 1‚ê§¬ª

[20:04] <Kristien> No assimilation, good.

[20:04] <TimToady> lunch &

[20:04] <hoelzro> interesting

[20:05] <hoelzro> one thing that bothers me about $value."$typename"() is what about types like X::MyException (/me has no idea if : is legal in method name)

[20:06] *** Jefffrey left
[20:06] <psch> m: class Foo { }; Foo.^add_method("it's a silly::test", method (Foo:U:) { say "dunno?" }); Foo."it's a silly::test"()

[20:06] <camelia> rakudo-moar 912a7f: OUTPUT¬´dunno?‚ê§¬ª

[20:07] <lucas> m: constant Foo = 42; my Foo $x; say $x

[20:07] <camelia> rakudo-moar 912a7f: OUTPUT¬´42‚ê§¬ª

[20:07] <hoelzro> but also, let's say I have two types with the same base name (ex. module Trangressions { class Sin { ... } } module Trig { class Sin { ... } }), and I define .Sin on some other class.  Which one am I coercing to?

[20:08] <lucas> It seems like if I have any bareword, I can use it as a typename

[20:08] <PerlJam> hoelzro: whichever one is in scope

[20:08] <lucas> moritz: Thanks for the example!

[20:08] <moritz> PerlJam: in scope where the coercion method is defined? or where it's called?

[20:08] <hoelzro> PerlJam: what if I import the other class into another module, and call .Sin, having imported neither Transgressions nor Trig?

[20:09] <moritz> jnthn: is there anything holding off the 6pe merge?

[20:10] <PerlJam> moritz: if you're not typing your return values, then either :) 

[20:10] <lizmat> hoelzro: then that Sin will be visible in that scope

[20:10] <lizmat> or the import will fail if there is already a Sin there

[20:11] <skids> m: class A { method y { "yes".say } }; class B is A { }; B.new.A::y() # hoelzro, methods syntactically can have ns colons and such is often used like this.

[20:11] <camelia> rakudo-moar 912a7f: OUTPUT¬´yes‚ê§¬ª

[20:11] <hoelzro> let's say I have class MyType { method Sin { #`( ...magic...) } }

[20:11] <jnthn> moritz: Various things :)

[20:11] <hoelzro> and I import MyType into Foo.pm, and that's all I import.  Then I call MyType.new.Sin.  Which Sin should it try coercing to?

[20:12] <moritz> hoelzro: I'm well aware of the the problem, what's missing is a solution

[20:12] <PerlJam> hoelzro: also, that's one of the things I liked about COERCE, that you have to declare the types of both sides

[20:12] <hoelzro> granted, that's up to the person writing the method in MyType, but then can you create a coercion from MyType to the other Sin class?

[20:12] <jnthn> moritz: For one, it'd bust the Parrot build until I port it there. And there are some spectest regressions, and so on. 

[20:13] <hoelzro> moritz: right, I'm pointing out what bothers me about the current state of affairs

[20:13] <moritz> jnthn: oh

[20:13] <hoelzro> skids: thanks for the demo

[20:13] *** denis_boyun left
[20:13] <moritz> the problem with COERCE(source-type, dest-type) is that it type-checks the wrong

[20:13] <moritz> (co vs. contra variant)

[20:13] <dalek> roast: 8fc7d02 | usev6++ | S32-str/sprintf.t:

[20:13] <dalek> roast: Add test for RT #122907

[20:13] <dalek> roast: review: https://github.com/perl6/roast/commit/8fc7d0289c

[20:13] <synopsebot> Link: https://rt.perl.org/rt3//Public/Bug/Display.html?id=122907

[20:14] <moritz> uhm, no, ignore me

[20:14] * moritz has his head all knotted up

[20:14] *** agentzh joined
[20:15] * japhb wonders what it means for a relatively compact, mostly convex structure to be knotted

[20:15] <hoelzro> I don't mind implementing COERCE for people to try it out, but I don't want to spend time implementing something unless I have a fair amount of confidence that it would eventually be used

[20:16] * hoelzro backlogs to see what TimToady said before hoelzro asked again

[20:16] <PerlJam> hoelzro: such is the implementor's risk.   (How else do we get implementations to vet the ideas of the spec?)

[20:16] <hoelzro> PerlJam: point taken =)

[20:17] * jnthn gets back to work on 6pe stuffs

[20:17] *** lucas left
[20:18] *** darutoko left
[20:22] <hoelzro> I just saw lizmat's comment on removing a returns trait because that routine could return a Failure, which intrigues me

[20:22] <hoelzro> the spec allows for definite return values (ex. sub mysub() returns 3 { ... }), so that mysub always returns 3...

[20:22] <hoelzro> ...expect (iirc) the spec *also* allows mysub to return a Failure!

[20:22] <hoelzro> er, except

[20:22] * hoelzro needs coffee

[20:22] <lizmat> m: sub a(-->Int) { fail }; a

[20:22] <camelia> rakudo-moar 912a7f: OUTPUT¬´Type check failed for return value; expected 'Int' but got 'Failure'‚ê§  in any return_error at src/vm/moar/Perl6/Ops.nqp:649‚ê§  in sub a at /tmp/abIECMht3v:1‚ê§  in block <unit> at /tmp/abIECMht3v:1‚ê§‚ê§¬ª

[20:23] <hoelzro> I find it interesting that the spec allows Failures to sneak past the returns type in the case of definite return specifications, but not definite ones

[20:24] <moritz> hoelzro: does it, still? I thought that was removed

[20:24] <lizmat> m: sub a(-->Int:D) { fail }; a

[20:24] <camelia> rakudo-moar 912a7f: OUTPUT¬´Type check failed for return value; expected 'Int' but got 'Failure'‚ê§  in any return_error at src/vm/moar/Perl6/Ops.nqp:649‚ê§  in sub a at /tmp/95UbbofjMN:1‚ê§  in block <unit> at /tmp/95UbbofjMN:1‚ê§‚ê§¬ª

[20:24] <hoelzro> moritz: the part about definite return specifications?

[20:25] <hoelzro> I see what TimToady was saying now

[20:26] <hoelzro> it's kind of orthogonal to whether or not COERCE exists

[20:26] <moritz> hoelzro: the part about allowing failure to sneak past return type declarations

[20:27] <hoelzro> S06:672

[20:27] <synopsebot> Link: http://perlcabal.org/syn/S06.html#line_672

[20:27] <hoelzro> neat, it worked =)

[20:27] *** vendethiel left
[20:27] <hoelzro> end of the first paragraph

[20:27] <hoelzro> actually, that sentence implies that sneaking should happen for indefinite return specs as well

[20:28] <moritz> and it stil points to perlcabal.org :(

[20:28] <moritz> tadzik: didn't I fix synopsebot? :(

[20:28] <hoelzro> I'm guessing if any routine may return a Failure, that could muck with optimization =/

[20:29] *** bjz joined
[20:29] <hoelzro> unless we check for "fail" while compiling a sub, and annotate the code object with that information

[20:29] <moritz> that's why rakudo doesn't implement it

[20:29] <hoelzro> moritz: sorry, doesn't implement which?

[20:29] <PerlJam> hoelzro: the sneaking

[20:29] <moritz> hoelzro: allowing failures to sneak past

[20:30] <hoelzro> ah

[20:30] <hoelzro> just checking =)

[20:30] *** vendethiel joined
[20:30] <PerlJam> See lizmat's offering to rakudo-m a few minutes ago

[20:31] <hoelzro> yeah, I was just questioning whether or not the spec made sense, and then after I re-read that paragraph, whether or not getting Rakudo to conform with the spec there would impact optimization

[20:33] <lizmat> jnthn has stated the other day, that that would be almost impossible to not have that impact performance significantly

[20:34] <moritz> perl6/doc htmlify.p6 doesn't work with current rakudo + current Pod::To::HTML :(

[20:35] <raydiak> ouch

[20:35] <FROGGS_> hmmm, my code has not suffered...

[20:35] <FROGGS_> moritz: what's wrong?

[20:35] <moritz> http://perlpunks.de/paste/show/54c2b083.700a.2b6

[20:35] <FROGGS_> moritz: hmmm

[20:36] <FROGGS_> https://github.com/perl6/Pod-To-HTML/blob/master/lib/Pod/To/HTML.pm#L161

[20:36] <FROGGS_> looks like a rakudobug if you ask me

[20:37] <FROGGS_> m: my @a; say @a[*-1]

[20:37] <camelia> rakudo-moar 25da7a: OUTPUT¬´Index out of range. Is: -1, should be in 0..Inf‚ê§  in method at_pos at src/gen/m-CORE.setting:9827‚ê§  in sub postcircumfix:<[ ]> at src/gen/m-CORE.setting:2837‚ê§  in sub postcircumfix:<[ ]> at src/gen/m-CORE.setting:2937‚ê§  in block <unit> at /tmp/iskh‚Ä¶¬ª

[20:37] <FROGGS_> star-m: my @a; say @a[*-1]

[20:37] <camelia> star-m 2014.12: OUTPUT¬´Calculated index (-1) is negative, but Array allows only 0-based indexing‚ê§  in method gist at src/gen/m-CORE.setting:13837‚ê§  in sub say at src/gen/m-CORE.setting:16595‚ê§  in block <unit> at /tmp/bgxDUS6alV:1‚ê§‚ê§¬ª

[20:37] <FROGGS_> star-m: my @a = 1; say @a[*-1]

[20:37] <camelia> star-m 2014.12: OUTPUT¬´1‚ê§¬ª

[20:37] <FROGGS_> m: my @a = 1; say @a[*-1]

[20:37] <camelia> rakudo-moar 25da7a: OUTPUT¬´1‚ê§¬ª

[20:37] <FROGGS_> hmmm

[20:37] <FROGGS_> ohh

[20:38] <tony-o_> does p6 build for 32b os/jvm? .. i'm getting  "main" java.lang.NoClassDefFoundError on 32b but it builds fine for 64b same version

[20:38] <moritz> star-mm: my @a; say @a[*-1] // 0

[20:38] <raydiak> maybe like this one: http://irclog.perlgeek.de/perl6/2015-01-10#i_9916445

[20:38] <raydiak> (the infinte array bug, that was for)

[20:38] <moritz> star-m: my @a; say @a[*-1] // 0

[20:38] <camelia> star-m 2014.12: OUTPUT¬´0‚ê§¬ª

[20:38] <FROGGS_> moritz: that's it!

[20:38] <FROGGS_> m: my @a; say @a[*-1] // 42

[20:38] <camelia> rakudo-moar 25da7a: OUTPUT¬´Index out of range. Is: -1, should be in 0..Inf‚ê§  in method at_pos at src/gen/m-CORE.setting:9827‚ê§  in sub postcircumfix:<[ ]> at src/gen/m-CORE.setting:2837‚ê§  in sub postcircumfix:<[ ]> at src/gen/m-CORE.setting:2937‚ê§  in block <unit> at /tmp/ap_2‚Ä¶¬ª

[20:38] <FROGGS_> m: my @a; say @a[*-1].WHAT

[20:38] <camelia> rakudo-moar 25da7a: OUTPUT¬´Index out of range. Is: -1, should be in 0..Inf‚ê§  in method at_pos at src/gen/m-CORE.setting:9827‚ê§  in sub postcircumfix:<[ ]> at src/gen/m-CORE.setting:2837‚ê§  in sub postcircumfix:<[ ]> at src/gen/m-CORE.setting:2937‚ê§  in block <unit> at /tmp/xPuB‚Ä¶¬ª

[20:38] <FROGGS_> star-m: my @a; say @a[*-1].WHAT

[20:38] <camelia> star-m 2014.12: OUTPUT¬´(Failure)‚ê§¬ª

[20:38] <FROGGS_> lizmat: ^^

[20:40] *** denis_boyun_ joined
[20:40] <lizmat> FROGGS_: yes, did that behaviour change?  seems ok to me

[20:40] <lizmat> ah, you mean it throws rather than just fail ?

[20:41] <lizmat> ah, yuck

[20:41] <lizmat> yes

[20:41] <lizmat> argh

[20:41] <FROGGS_> yeah, it explodes too early

[20:42] <lizmat> argh, why doesn't the spectest catch that  :-(

[20:42] <lizmat> this is probably something we need to do a hotfix for, I would say  :-(

[20:42] <FROGGS_> my thought... seems we're missing a test here

[20:42] * lizmat investigates

[20:42] <FROGGS_> I dunno if there is much fallout

[20:43] <FROGGS_> I don't think this is a too common idom

[20:43] <FROGGS_> idiom

[20:44] <tony-o_> does p6 build for 32b os/jvm? .. i'm getting  "main" java.lang.NoClassDefFoundError on 32b but it builds fine for 64b same version

[20:45] <FROGGS_> tony-o_: I have no knowledge that somebody tried it in a 32bit jvm

[20:45] <FROGGS_> on*

[20:45] <jnthn> It's the first time I've heard of a 32-bit issue

[20:45] <bartolin> lizmat: isn't that the same thing as with the test fudged here: https://github.com/perl6/roast/commit/22ef35ba3f

[20:45] <jnthn> I'm sure in the early days I built it on a 32-bit JVM

[20:45] <jnthn> tony-o_: Which OS, ooc?

[20:45] <tony-o_> do you want a gist?

[20:46] <tony-o_> debian 7

[20:46] <jnthn> Hm, nothing unusual

[20:46] <jnthn> And no errors along the way?

[20:46] <lizmat> bartolin: yeah, but that test is weird

[20:46] <jnthn> Yeah, feel free to gist the build output

[20:46] <tony-o_> outside of that, i didn't see any fly by on my screen - it's a fresh copy of rakudo

[20:46] <jnthn> Did the build fail with that, or it just fails to run after building?

[20:47] <tony-o_> the build fails with that

[20:47] <lizmat> FROGGS_: testing a fix

[20:47] <ab5tract> tony-o_: i'm running a build right now

[20:47] *** denis_boyun_ left
[20:48] <jnthn> tony-o_: OK, gist me the last bit of the build output.

[20:48] * ab5tract hadn't realized just how waysided i686 has become in gnu/linux

[20:49] <tony-o_> okay, i'll give you whats in the buffer and full gist when the build finishes

[20:49] <FROGGS_> lizmat++

[20:49] <hoelzro> lizmat: what about the idea about "can fail" annotations on the code objects? would that be good enough

[20:49] <hoelzro> ?

[20:49] <tony-o_> jnthn: not much in my scrollback bufer - https://gist.github.com/tony-o/ca71572bc9fe0e25f28d

[20:50] <hoelzro> oh, wait

[20:50] <lizmat> jnthn: what I understand of the typechecking logic, is that that would not help much

[20:50] <hoelzro> you *could* do return $obj.could-fail() from a routine, and then you don't know

[20:54] <jnthn> It's fine if we have some way to indicate "can't fail" and "can fail" in the returns.

[20:54] <jnthn> It's just that anything marked as "can fail" isn't going to allow the static optimizer to trust what comes back

[20:55] <jnthn> tony-o_: What on earth...

[20:55] * psch suspects badly set up jre

[20:55] *** beastd joined
[20:56] <psch> tony-o_: how are you running the 32bit build? on a seperate 32bit debian?

[20:56] <raydiak> do we allow junctions as return type declarations?  e.g. --> Int|Failure

[20:57] <jnthn> No

[20:57] <raydiak> darn

[20:57] <jnthn> That's a worse kettle of fish :)

[20:58] <tony-o_> psch: yea

[20:58] <moritz> well, at least it'd only make it worth for those routines marked as Int|Failure

[20:58] <moritz> not for all of them

[20:58] <psch> tony-o_: but ¬´java -version¬ª works?

[20:58] <tony-o_> psch: i have a fresh debian 7 (32b) with open jdk installed

[20:59] <tony-o_> and the build fails, i'm comparing it to the same version 64b jdk installed on a different 64b installation of debian

[20:59] <lizmat> is github having problems?

[21:00] <raydiak> well all I was thinking is that I hate it when stuff like failures leak/"sneak" through by default...would rather it gets thrown before/at the return if I specified a return type which doesn't allow it

[21:00] <raydiak> so if not junctions maybe an "is failable" pragma or something?

[21:00] <dalek> rakudo/nom: f120204 | lizmat++ | src/core/ (6 files):

[21:00] <dalek> rakudo/nom: < 0 exceptions should fail rather than throw

[21:00] <dalek> rakudo/nom: 

[21:00] <dalek> rakudo/nom: Spotted by FROGGS++  .  Not sure of the ecosystem fallout of this: could

[21:00] <dalek> rakudo/nom: warrant a hot fix update of the compiler release before R* ?

[21:00] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/f120204aca

[21:01] <lizmat> FROGGS_ ^^^

[21:01] <moritz> lizmat++

[21:02] <hoelzro> raydiak: but the whole point of failures is that you can handle it at the callee, and if you don't, it croaks, right?

[21:03] <moritz> well, if a routine throws an exception, it avoids violating the return type contract

[21:03] * TimToady thinks we should replace the caller/callee terms because they're too confusing

[21:03] <moritz> simply by not returning

[21:04] <dalek> nqp/6pe: a28b48e | jnthn++ | src/vm/parrot/QAST/Operations.nqp:

[21:04] <dalek> nqp/6pe: Map nqp:: ops for 6model parametrics on Parrot.

[21:04] <dalek> nqp/6pe: 

[21:04] <dalek> nqp/6pe: Note they're not implemented yet.

[21:04] <dalek> nqp/6pe: review: https://github.com/perl6/nqp/commit/a28b48e2ec

[21:04] <dalek> nqp/6pe: 70fcb2c | jnthn++ | src/vm/parrot/ops/nqp.ops:

[21:04] <dalek> nqp/6pe: Stub in ops.

[21:04] <dalek> nqp/6pe: 

[21:04] <dalek> nqp/6pe: t/nqp/87-parametric-6model.t now compiles now, though of course fails.

[21:04] <dalek> nqp/6pe: review: https://github.com/perl6/nqp/commit/70fcb2c358

[21:07] * moritz wonders if it's worth parallelizing htmlify

[21:08] <moritz> writing the type documents at least should be quite easy to do

[21:08] <tony-o_> jnthn: here is the full log https://gist.github.com/tony-o/2b5e1f4d71311cc8756b

[21:09] <agentzh> sorry if it's something obvious, but is it possible to precompile perl6 scripts to bytecode (or something like that) to save parsing the source?

[21:09] <tony-o_> stackoverflowerror..think that might be too little memory (it has 1.5G) 

[21:09] <raydiak> hoelzro: if I'm reading things right, there are a number of ways that user code (the caller) might inadvertantly receive such an object and dumbly shove it through the pipeline, no?

[21:09] <moritz> agentzh: no, just modules

[21:09] <agentzh> moritz: thanks for the reply.

[21:09] <jnthn> agentzh: Modules, yes. Scripts, no (well, more "not yet", it's on the wish list)

[21:10] <raydiak> hoelzro: like checking the return value for definedness, or it being received in lazy list context?

[21:10] <agentzh> jnthn: no problem, i'll try to make my boilerplate script minimal :)

[21:10] <jnthn> tony-o_: Well, it tends to mean specifically too little stack memory

[21:11] * raydiak admits he has not much first-hand practice with our Failures and how they work, is just reading as he goes

[21:11] <jnthn> tony-o_: That is configurable, though...

[21:12] <hoelzro> raydiak: yeah, I think you might end up with a little bit of the "nil problem" (I call it that, because Lua uses nils for error conditions)

[21:12] <tony-o_> option on the jvm or in the Configure script?

[21:13] <dalek> doc: 24ea783 | moritz++ | htmlify.p6:

[21:13] <dalek> doc: htmlify: fix traits. Closes #41

[21:13] <dalek> doc: review: https://github.com/perl6/doc/commit/24ea7835a1

[21:13] *** vendethiel left
[21:13] <moritz> tony-o_: you might need to patch tools/build/create-jvm-runner.pl and tools/build/Makefile-JVM.in

[21:14] <moritz> tony-o_: search for -Xss or -Xmx

[21:14] *** booly-yam-4652 joined
[21:15] <tony-o_> for create-jvm-runner.pl i'm only seeing it for the 'install "perl6-eval-server", "java" line - i'll check the makefile

[21:15] <raydiak> hoelzro: yeah precisely...what I'm hoping to avoid is that nasty feeling I get from stuff like javascript where mistakes end up making NaNs that go through and cause weird, totally unrelated errors later on and force you to bisect your pipeline to find it

[21:16] <raydiak> which admittedly is slightly different, but similar enough for my analogy (I think)

[21:16] <hoelzro> do Failures describe where they come from?

[21:16] <hoelzro> that would at least help

[21:16] <moritz> jnthn: that doc commit should fix the routine-trait 404 link on doc.perl6.org you reported yesterday(-ish)

[21:16] <raydiak> yes

[21:16] <moritz> hoelzro: they have a backtrace

[21:16] <raydiak> well, they wrap an exception which does

[21:16] <hoelzro> ok, that's something =)

[21:17] <skids> r: my $f = fail("foo"); $f;

[21:17] <camelia> rakudo-parrot 25da7a: OUTPUT¬´foo‚ê§current instr.: 'throw' pc 501346 (src/gen/p-CORE.setting.pir:206811) (gen/parrot/CORE.setting:12506)‚ê§called from Sub 'sink' pc 544716 (src/gen/p-CORE.setting.pir:222609) (gen/parrot/CORE.setting:14089)‚ê§called from Sub 'MAIN' pc 396 (src/gen/pe‚Ä¶¬ª

[21:17] <camelia> ..rakudo-moar 25da7a: OUTPUT¬´Unhandled exception: foo‚ê§   at <unknown>:1  (/home/camelia/rakudo-inst-1/languages/perl6/runtime/CORE.setting.moarvm:throw:4294967295)‚ê§ from src/gen/m-CORE.setting:14149  (/home/camelia/rakudo-inst-1/languages/perl6/runtime/CORE.setting.moarvm:sink:29)‚Ä¶¬ª

[21:17] <raydiak> so the damage is mitigated, but if I already said "--> Int" somewhere earlier and still ended up with this failure thing getting out, I'd be kinda...unhappy if it was one of my first P6 experiences

[21:17] <moritz> jnthn: erm, nope, it doesn't :(

[21:18] <dalek> doc: 0b7b112 | moritz++ | htmlify.p6:

[21:18] <dalek> doc: Hide link that is a 404 now

[21:18] <dalek> doc: review: https://github.com/perl6/doc/commit/0b7b112620

[21:18] <jnthn> tony-o_: On JVM, and yeah, I think the Makefile is the place to look

[21:21] <tony-o_> jnthn: i changed Xss from 1m to 500m , i didn't touch Xmx because the JVM doesn't get even close to that number

[21:21] <tony-o_> stil the same error

[21:21] <moritz> tony-o_: did you reconfigure?

[21:21] <tony-o_> the box has over a gig of memory left when make pukes

[21:21] *** kaare_ joined
[21:21] <tony-o_> moritz: i do the configure and then change the make file

[21:22] <jnthn> tony-o_: Xss is the one I think, but 500m is crazy...try more like 2m or 5m

[21:22] <hoelzro> raydiak: I can understand that

[21:22] <tony-o_> jnthn: i tried 5m first with same error so i went nuts with it

[21:22] <jnthn> tony-o_: ohh, but now I notice

[21:22] <jnthn> /home/perl6/bash-perl6-burner/wa/p6/../sixes/2014.12/bin/nqp-j

[21:23] <jnthn> It's that shell script that means an -Xss I guess

[21:24] <agentzh> could anyone help with this little NQP program? https://gist.github.com/agentzh/dc53d8f415ac0c6a0260 I keep getting the "cannot stringify this" error.

[21:24] <agentzh> but the equivalent works in rakudo.

[21:25] <agentzh> seems like $match<Expr><Item> is a "null object" somehow.

[21:25] <moritz> agentzh: string do you pass on the command line?

[21:25] <agentzh> i passed.

[21:25] <tony-o_> jnthn: same error still with 1G allocated to the nqp jvm and -Xss set to 5m

[21:26] <moritz> agentzh: token  Expr { [<Item> <ws>]+ }

[21:26] <moritz> agentzh: the + means that the <Item> capture is a list/array

[21:26] <moritz> agentzh: try say($match<Expr><Item>[0])

[21:27] <jnthn> tony-o_: OK, then...I'm confused. :(

[21:27] <tony-o_> :(

[21:27] <moritz> agentzh: in rakudo, lists know how to coerce themselves in string context

[21:27] <moritz> agentzh: nqp isn't that forgiving

[21:27] *** booly-yam-4652 left
[21:27] <agentzh> moritz: i see, thanks!

[21:27] <dalek> nqp/6pe: 98c0b61 | jnthn++ | src/vm/parrot/ (2 files):

[21:27] <dalek> nqp/6pe: Add parametricity bits to STable.

[21:27] <dalek> nqp/6pe: review: https://github.com/perl6/nqp/commit/98c0b61f8b

[21:28] <agentzh> really like NQP's speed :)

[21:29] * moritz too

[21:29] <moritz> though rakudo-m is also not bad

[21:29] <agentzh> yeah, but it still has a startup hit of 200ms on my laptop :)

[21:30] <agentzh> while nqp-m is just 30ms :)

[21:30] <moritz> aye

[21:31] <tony-o_> jnthn: we'll see if it happens on BSD 32b later too

[21:31] <agentzh> will try to port some of my slooow Rarse::RecDescent compilers over to nqp and rakudo.

[21:31] <agentzh> and see how it goes.

[21:31] <moritz> lizmat: re rakudo bugfix release, that might make sense. At least Pod::To::HTML is badly broken with 2015.01.

[21:31] <moritz> TTFN

[21:32] <lizmat> moritz: does my fix just now, solve the problem?

[21:32] <moritz> lizmat: yes

[21:33] <lizmat> then I'm afraid we'll need a hotfix release, right ?

[21:33] <lizmat> what's the procedure for that?

[21:33] *** vendethiel joined
[21:33] <moritz> lizmat: there's not much of a procedure for it

[21:34] <TimToady> minimally, put a new tag, and reference it

[21:34] <moritz> lizmat: I'd start a new branch based on the 2015.01 tag

[21:34] *** kurahaupo left
[21:34] <timotimo> hello everybody

[21:34] <timotimo> what did i miss? :)

[21:34] <TimToady> everything!

[21:34] * lizmat messing up a release

[21:34] <moritz> (git checkout -b hotfix-2015.01 2015.01)

[21:34] <moritz> cherry-pick the commit(s) you want to include

[21:35] <lizmat> only one, fortunately

[21:35] <moritz> do the usual ',ale release'

[21:35] <moritz> with 2015.01.1 as the version

[21:35] <moritz> *'make release'

[21:35] <moritz> and when that one works, upload the tarball, add a tag, push the tag

[21:35] <TimToady> you're not supposed to release ale, you're supposed to consume it

[21:36] * moritz isn't supposed to be typing, he should be sleeping

[21:36] <TimToady> moritz++ for typing anyway

[21:36] *** rurban joined
[21:36] <Kristien> What if it was a bot?

[21:36] <lizmat> will need someone else to do the upload

[21:36] <Kristien> Or speach-to-text?

[21:36] <Kristien> Would we be doomed?

[21:37] <agentzh> how should i check the type of an expression in NQP?

[21:37] <agentzh> there's no WHAT() nor .WHAT in NQP it seems.

[21:37] <tony-o_> that's what you get with your other 170ms :-)

[21:37] <agentzh> hehe

[21:38] <agentzh> so it's "no"?

[21:38] <jnthn> There's a .WHAT, but no .gist/.Str distinction

[21:39] <jnthn> say($foo.HOW.name($foo)) # gets you the typename

[21:39] * agentzh is trying.

[21:39] <jnthn> But if you're try trying to do a type check then smartmatch should work, or nqp::istype($obj, TheType)

[21:40] <agentzh> got it.

[21:40] <agentzh> thanks

[21:40] <jnthn> np

[21:40] *** xfix left
[21:40] <lizmat> moritz: building on parrot and running spectest now

[21:42] <Kristien> I want to become a professional Perl programmer.

[21:42] <Kristien> but I'm stuck with Python and PHP projects 3:

[21:42] <dalek> nqp/6pe: 2c3db63 | jnthn++ | src/vm/parrot/ops/nqp.ops:

[21:42] <dalek> nqp/6pe: Start porting 6pe ops to Parrot; passes 6 tests.

[21:42] <dalek> nqp/6pe: review: https://github.com/perl6/nqp/commit/2c3db63426

[21:43] <jnthn> agentzh: ooc, what Rakudo startup hit would be low enough for it to not be annoying for you?

[21:43] *** PZt left
[21:43] *** Rounin left
[21:44] <PerlJam> Kristien: you have 2 options:  1) find some you can convince to pay to you code in Perl  2)  start a business of your own where you use perl to solve real-world problems and people pay you for that.

[21:44] <PerlJam> :-)

[21:44] <agentzh> jnthn: under 100ms :)

[21:44] <jnthn> agentzh: OK :)

[21:44] <Kristien> :v

[21:46] <Kristien> I couldn't install Parrot because I have no ICU. Does Moar depend on ICU?

[21:46] <TimToady> agentzh: get a machine that's twice as fast? :P

[21:48] <Kristien> I'll try to install Moar so I can implement my monitoring tool.

[21:48] <jnthn> Kristien: No, Moar doesn't depend on that.

[21:49] <jnthn> Kristien: You should also find Moar to be faster :)

[21:49] <Kristien> Parrot doesn't have Proc::Async so I cannot use it anyway :P

[21:50] <lizmat> so tagging should be something like: git tag -a -m"tag release #84" 2015.01.01

[21:50] <lizmat> moritz: ^^ ?

[21:51] <moritz> lizmat: I wouldn't include #84 there

[21:51] <lizmat> just nn?

[21:51] <moritz> lizmat: rather 'tag bugfix release 1 for 2015.01' or so

[21:51] <rurban> parrot ‚Äîwithout-icu

[21:51] <rurban> this is even autodetected

[21:52] <Kristien> it failed installing

[21:52] <Kristien> because ICU was not on my machine

[21:52] <psch> rakudo fails, not parrot

[21:52] <Kristien> the obvious fix is installing ICU, ol

[21:52] <rurban> I thought I had all the necessary workarounds already

[21:52] *** anaeem1_ joined
[21:53] <rurban> but yes, moar has aio already, parrot not

[21:53] <dalek> nqp/6pe: 5feb90a | jnthn++ | src/vm/parrot/ops/nqp.ops:

[21:53] <dalek> nqp/6pe: Port 3 more 6pe ops; 11/14 tests passing.

[21:53] <dalek> nqp/6pe: review: https://github.com/perl6/nqp/commit/5feb90a082

[21:55] <rurban> jnthn++ parrot work

[21:55] *** denis_boyun_ joined
[21:55] *** vendethiel left
[21:56] <dalek> roast: 3a2be84 | raydiak++ | S02-lists/indexing.t:

[21:56] <dalek> roast: Add test for out of range index failures

[21:56] <dalek> roast: 

[21:56] <dalek> roast: Tests pre-hotfix 2015.01 bug fixed by lizmat++ @ f120204aca0276564163c3bc157c0639870d5227

[21:56] <dalek> roast: review: https://github.com/perl6/roast/commit/3a2be8499a

[21:58] <lizmat> moritz: *sigh*  tar building fails because of missing files in t/spec

[21:59] *** skids left
[21:59] <lizmat> moritz: is it supposed to include t/spec in the tar file ?

[22:00] <moritz> lizmat: yes

[22:00] <moritz> lizmat: rm -rf t/spec; make testable

[22:01] <moritz> lizmat: iirc the release process replaces t/spec/ with a non-git directory, or something weird

[22:01] <lizmat> $ make testable

[22:01] <lizmat> make: *** No rule to make target `testable'.  Stop.

[22:01] <lizmat> :-(

[22:02] <moritz> make t/spec

[22:02] <moritz> lizmat: sorry, my bulid-fu is rusty

[22:02] <lizmat> I just reconfigured and am rebuilding

[22:03] <ab5tract> tony-o_: rakudo compiled fine for me on i686 archlinux

[22:05] <dalek> nqp/6pe: 44e9eb2 | jnthn++ | src/vm/parrot/ops/nqp.ops:

[22:05] <dalek> nqp/6pe: Implement interning, to pass 6pe tests.

[22:05] <dalek> nqp/6pe: review: https://github.com/perl6/nqp/commit/44e9eb266a

[22:09] <lizmat> moritz: after make t/spec, make release still fails because of missing files

[22:09] <lizmat> like S32-list/uniq.t

[22:12] *** denis_boyun_ left
[22:14] <jnthn> lizmat: You already nuked your t/spec and got a fresh checkout of it?

[22:14] *** vendethiel joined
[22:14] <lizmat> yes

[22:14] <lizmat> but is also complaining about missing files in src/core

[22:15] <jnthn> o.O

[22:16] *** denis_boyun_ joined
[22:16] *** jmark left
[22:16] <lizmat> a stub file for the newio branch

[22:16] <lizmat> that I removed about 2 weeks ago?

[22:16] <lizmat> src/core/IO/Locally

[22:18] <jnthn> And it's not on disk?

[22:18] <lizmat> nope

[22:19] <lizmat> feels like it is somehow still at 2014.12

[22:19] * jnthn wonders where on earth it gets it from

[22:19] <lizmat> well, the file used to exist at some point in the past

[22:24] <lizmat> ls

[22:25] <lizmat> I touched the missing files and got a tar now

[22:25] *** telex left
[22:25] <lizmat> testing that tar

[22:26] *** telex joined
[22:29] *** mvuets joined
[22:29] <Kristien> m: Duration.new(1).Real

[22:29] <camelia> rakudo-moar f12020: ( no output )

[22:30] <Kristien> m: say Duration.new(1).Real.WHAT

[22:30] <camelia> rakudo-moar f12020: OUTPUT¬´(Duration)‚ê§¬ª

[22:30] <Kristien> Shouldn't that be Real?

[22:30] <lizmat> yes

[22:30] <Kristien> Oh. Duration <: Real

[22:30] <jnthn> m: say Duration ~~ Real

[22:30] <camelia> rakudo-moar f12020: OUTPUT¬´True‚ê§¬ª

[22:31] <Kristien> oops :P

[22:31] <lizmat> jnthn: but the fact that it does the role Real, should make it of that type, no?

[22:32] <lizmat> method Real(Real:D:) { self }   # in Real.pm

[22:32] <masak> ooh, we have literal syntax for object hashes now?

[22:32] <masak> squee!

[22:32] * lizmat notices that masak  does not read the p6w  :-)

[22:32] <lizmat> .oO( or much later :-)

[22:33] <masak> I really should do that.

[22:33] <masak> this was from just catching up on p6l.

[22:34] <lizmat> jnthn: I think Duration needs it's own "method Real(Duration:D:) { self.Num } ?

[22:35] <lizmat> *its

[22:35] <jnthn> lizmat: No, it already *is* a Real

[22:35] <jnthn> lizmat: And .Real on a Real should be identity

[22:36] <lizmat> eh. but it *does* a Real

[22:36] <Kristien> Cool, Promise#then doesn't autocollapse.

[22:36] <Kristien> m: my ($s, $t) = Supply.new, Supply.new; my ($p, $q) = $s.Promise, $t.Promise; my $x = $p.then({ $q; }); $t.emit(3.14); $s.emit(42); say ($x.result.WHAT, $x.result.result.WHAT)

[22:36] <jnthn> m: say 42.Real.WHAT

[22:36] <camelia> rakudo-moar f12020: OUTPUT¬´(Promise) (Rat)‚ê§¬ª

[22:36] <camelia> rakudo-moar f12020: OUTPUT¬´(Int)‚ê§¬ª

[22:37] *** denis_boyun_ left
[22:37] <lizmat> jnthn: ah, ok

[22:37] <Kristien> JS promises typically do, making it impossible to write generic code.

[22:37] <lizmat> I guess there's more cases like that :-)

[22:37] <jnthn> Kristien: That'd be a bit...magical...for my liking :)

[22:37] <lizmat> Kristien: not much of a promise then  :-)

[22:37] <lizmat> jnthn: ok, so Duration.Real -> Duration

[22:38] <jnthn> lizmat: Yes

[22:38] <lizmat> gotcha

[22:38] <jnthn> Dammit. r-p does a SEGV in the 6pe-mop branch :(

[22:39] <dalek> nqp/6pe: 91f6f52 | jnthn++ | src/vm/parrot/6model/serialization.c:

[22:39] <dalek> nqp/6pe: Port basic 6pe serialization to Parrot.

[22:39] <dalek> nqp/6pe: review: https://github.com/perl6/nqp/commit/91f6f525b7

[22:40] <lizmat> ok, tar file built ok, spectested ok (complaned a bit about missing test files, but there you go)

[22:42] *** rurban left
[22:48] * jnthn gets a busted stack in the debugger also. wtf.

[22:49] *** ajr joined
[22:50] *** ajr is now known as Guest18017

[22:50] *** Guest18017 is now known as ajr_

[22:51] <Kristien> RxP6 would be fun to see.

[22:51] <jnthn> Kristien: That's basically what Supply is :)

[22:52] <jnthn> Note the *whole* Rx, but the observer bit and a bunch of the combinators.

[22:52] <FROGGS_> Not*

[22:52] <jnthn> uh, yes

[22:52] <FROGGS_> :o)

[22:52] <Kristien> Yeah.

[22:52] *** adu left
[22:53] <dalek> rakudo/6pe-mop: 432c65a | jnthn++ | tools/build/Makefile-Parrot.in:

[22:53] <dalek> rakudo/6pe-mop: Add CoercionHOW into the r-p Makefile.

[22:53] <dalek> rakudo/6pe-mop: review: https://github.com/rakudo/rakudo/commit/432c65a08f

[22:53] <Kristien> ok let's use Supply instead of Channel for the ping monitor

[22:54] <Kristien> Whooo it works shiny

[22:57] <ab5tract> Kristien: can i see? :D

[22:57] <dalek> rakudo/hotfix-2015.01: f0b3a47 | lizmat++ | src/core/ (6 files):

[22:57] <dalek> rakudo/hotfix-2015.01: < 0 exceptions should fail rather than throw

[22:57] <dalek> rakudo/hotfix-2015.01: 

[22:57] <dalek> rakudo/hotfix-2015.01: Spotted by FROGGS++  .  Not sure of the ecosystem fallout of this: could

[22:57] <dalek> rakudo/hotfix-2015.01: warrant a hot fix update of the compiler release before R* ?

[22:57] <dalek> rakudo/hotfix-2015.01: review: https://github.com/rakudo/rakudo/commit/f0b3a472a0

[22:57] <Kristien> ab5tract: gimme a sec, fixing one more thing

[22:58] <FROGGS_> also spotted by moritz++

[22:58] <lizmat> Hotfix release is now on rakudo.org: http://rakudo.org/downloads/rakudo/

[22:59] <lizmat> FROGGS_++ for helping out

[23:01] *** doobi-sham-25434 joined
[23:01] <dalek> Heuristic branch merge: pushed 16 commits to rakudo/newio by lizmat

[23:01] <lizmat> and on that note, I'm going to call it a night

[23:02] <raydiak> good night lizmat++

[23:03] <FROGGS_> gnight lizmat

[23:05] <FROGGS_> I really love precomp... the libxml tests take 5s precomp'd instead of 28s :o)

[23:07] *** FROGGS_ left
[23:07] *** ptc_p6 left
[23:08] <jnthn> 'night, lizmat 

[23:09] <jnthn> Hm, think I'll consider myself done for the day also :)

[23:10] <japhb> o/

[23:11] *** anaeem1_ left
[23:11] <TimToady> but the night is yet young!

[23:11] <japhb> The night is not yet night!

[23:13] <jnthn> Not in this timezone :P

[23:15] <geekosaur> it's pretty night here...

[23:17] *** japhb left
[23:18] <dalek> Heuristic branch merge: pushed 17 commits to nqp by jnthn

[23:18] * jnthn merged 6pe in nqp

[23:18] <jnthn> All backends pass the new test file there now, so no longer a need to keep it out of master. :)

[23:18] <TimToady> \o/

[23:19] <jnthn> 6pe-mop in Rakudo could be a while longer; we'll see.

[23:19] <TimToady> If it's turtles all the way down, we'll hope it's hares all the way up.

[23:20] <jnthn> :)

[23:21] *** ajr_ left
[23:23] *** spollei joined
[23:24] *** japhb joined
[23:24] *** beastd left
[23:26] <Kristien> Is there a pastebin with Perl 6 syntax highlighting?

[23:26] *** doobi-sham-25434 left
[23:26] <Kristien> Ah, pastebin.com

[23:27] <Kristien> ab5tract: http://pastebin.com/udu7qCiK

[23:27] *** rurban_ left
[23:29] <japhb> What are they using for Perl 6 highlighting?

[23:29] <psch> m: say "1241.12512" ~~ / \d ** 2 % '.'/

[23:29] <camelia> rakudo-moar f12020: OUTPUT¬´ÔΩ¢1.1ÔΩ£‚ê§¬ª

[23:30] <psch> m: say "1241.12512" ~~ / [\d+] ** 2 % '.'/

[23:30] <camelia> rakudo-moar f12020: OUTPUT¬´ÔΩ¢1241.12512ÔΩ£‚ê§¬ª

[23:30] <psch> m: say "1241.12512" ~~ / \d+ ** 2 % '.'/

[23:30] <camelia> rakudo-moar f12020: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Quantifier quantifies nothing‚ê§at /tmp/nojLF2Ee6_:1‚ê§------> [32msay "1241.12512" ~~ / \d+ ** 2[33m‚èè[31m % '.'/[0m‚ê§Missing quantifier on the left argument of %‚ê§at /tmp/nojLF2Ee6_:1‚ê§------> [32msay "1241.12512‚Ä¶¬ª

[23:30] <japhb> m: say "1241.12512" ~~ / \d+**2%'.'/

[23:30] <camelia> rakudo-moar f12020: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Quantifier quantifies nothing‚ê§at /tmp/0a7ESU76WQ:1‚ê§------> [32msay "1241.12512" ~~ / \d+**2[33m‚èè[31m%'.'/[0m‚ê§Missing quantifier on the left argument of %‚ê§at /tmp/0a7ESU76WQ:1‚ê§------> [32msay "1241.12512" ~~‚Ä¶¬ª

[23:31] <TimToady> gotta use brackets there

[23:31] <japhb> OOC, why?

[23:32] <TimToady> the **2 doesn't really know the % is coming :)

[23:32] *** panchiniak left
[23:32] <TimToady> maybe it could be taught

[23:33] <TimToady> but it's not clear that it would be clearer

[23:34] <TimToady> for the rest of regex, one atom and one quantifier is a pretty strong self-clocking feature

[23:34] <japhb> Fair enough

[23:38] <Kristien> m: class A { has Proc::Async $.proc; }; say A.new.proc.WHAT;

[23:38] <camelia> rakudo-moar f12020: OUTPUT¬´Proc::Async is disallowed in restricted setting‚ê§  in sub restricted at src/RESTRICTED.setting:1‚ê§  in method gist at src/RESTRICTED.setting:33‚ê§  in sub say at src/gen/m-CORE.setting:16915‚ê§  in block <unit> at /tmp/iMGvfWdSua:1‚ê§‚ê§¬ª

[23:38] <Kristien> m: class A { has Supply $.proc; }; say A.new.proc.WHAT;

[23:39] <camelia> rakudo-moar f12020: OUTPUT¬´(Supply)‚ê§¬ª

[23:39] <Kristien> Hmm, interesting.

[23:41] <jnthn> TimToady: Not sure the **2 not knowing the % is coming is the issue, it's more than the + was the quantifier, and the **2 then has nothing to quantify.

[23:41] <jnthn> ('cus we're onto the next atom by then)

[23:41] <masak> er.

[23:41] <masak> std: /a+ +/

[23:41] <camelia> std f9b7f55: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Quantifier quantifies nothing at /tmp/kwR60Sa920 line 1:‚ê§------> [32m/a+ +[33m‚èè[31m/[0m‚ê§Check failed‚ê§FAILED 00:00 135m‚ê§¬ª

[23:42] <masak> ok, that seems to be the way it actually works.

[23:42] <masak> fancy that.

[23:42] * jnthn has spent some time in the grammar that parses it :P

[23:42] <masak> :)

[23:42] <masak> I bet I used to know that. I once re-implemented PGE.

[23:42] <jnthn> Well, but PGE didn't use a Perl 6 grammar to parse its regexes, iirc?

[23:43] <masak> no, it used an expression parser with parameterized ops.

[23:48] *** muraiki_ joined
[23:48] *** adu joined
[23:49] *** spider-mario left
[23:52] <jnthn> 'night, #perl6

[23:53] <masak> 'night, jnthn

