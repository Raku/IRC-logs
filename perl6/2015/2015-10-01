[00:03] *** yqt left
[00:05] *** cognominal left
[00:05] *** cognominal joined
[00:17] *** mr_ron left
[00:17] *** mr_ron joined
[00:30] *** leont left
[00:41] *** aborazmeh joined
[00:41] *** aborazmeh left
[00:41] *** aborazmeh joined
[00:44] *** laouji joined
[00:53] *** tokuhiro_ joined
[00:54] *** pmurias left
[00:57] *** tokuhiro_ left
[01:02] *** mr_ron left
[01:09] *** Zoffix is now known as CPAN2

[01:09] *** CPAN2 is now known as Zoffix_

[01:09] *** Zoffix_ is now known as FunBag

[01:09] *** FunBag left
[01:11] <awwaiid> hm. Well I was going to ask a question about some slang thing I was messing with but then I saw that whitespace-before-method-dot (or infix:<.>) is core now. amazing.

[01:11] *** lichtkind joined
[01:12] *** Zoffix joined
[01:13] *** mr_ron joined
[01:20] *** aborazmeh left
[01:20] <Juerd> awwaiid: Before and after, if you like :)

[01:24] * awwaiid hops up and down and mutters about being excited for Christmas

[01:36] *** BenGoldberg joined
[01:40] * Zoffix mumbles something about this still being just September

[01:42] <timotimo> learnxinyminutes probably has some verbiage about "you have to put a \ after $foo and before the newline"

[01:42] * timotimo disappears

[01:51] *** lichtkind_ joined
[01:58] *** vvz left
[02:08] *** makapa joined
[02:08] *** kid51_ joined
[02:10] *** lichtkind_ left
[02:10] *** kid51 left
[02:11] *** kid51_ is now known as kid51

[02:19] *** telex left
[02:20] *** telex joined
[02:21] *** mr_ron left
[02:24] *** kid51 left
[02:25] <dalek> rakudo/nom: e5a266b | TimToady++ | src/Perl6/Actions.nqp:

[02:25] <dalek> rakudo/nom: infix:<o> shouldn't curry WhateverCode

[02:25] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/e5a266b253

[02:33] *** AlexDaniel left
[02:35] <dalek> roast: fc511ea | TimToady++ | S03-operators/composition.t:

[02:35] <dalek> roast: test o against whatevers

[02:35] <dalek> roast: review: https://github.com/perl6/roast/commit/fc511ea6b6

[02:35] *** noganex joined
[02:38] *** noganex_ left
[02:45] *** makapa left
[02:54] *** tokuhiro_ joined
[02:58] *** kaare_ joined
[02:59] *** tokuhiro_ left
[03:12] *** pierrot left
[03:13] *** tokuhiro_ joined
[03:13] *** pierrot joined
[03:21] *** lichtkind left
[03:39] *** makapa joined
[03:44] *** makapa left
[04:15] *** makapa joined
[04:27] *** makapa left
[04:28] *** makapa joined
[04:36] *** skids left
[04:40] *** [Sno] left
[04:43] *** davido_ joined
[05:00] *** BenGoldberg left
[05:22] <dalek> rakudo/nom: 92be579 | TimToady++ | src/core/Range.pm:

[05:22] <dalek> rakudo/nom: Calculate elems of non-num range more directly

[05:22] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/92be579513

[05:32] *** makapa left
[05:36] *** anon joined
[05:37] *** anon is now known as Guest72063

[05:44] *** Guest72063 left
[05:44] *** Guest72063 joined
[05:45] *** araujo left
[05:45] *** Guest72063 is now known as wooden_

[05:45] *** araujo joined
[05:48] *** wooden_ left
[05:56] *** darutoko joined
[05:57] *** emilbarton joined
[05:58] <emilbarton> hello, how can I pass a reference to a class as attribute in another class and not get "Cannot lookup attributes in a Type object" when trying to use a method of the first class within a method in the second one?

[06:02] <emilbarton> I mean a ref to a class instance

[06:05] *** [Sno] joined
[06:09] *** FROGGS joined
[06:20] <emilbarton> hello, how can I pass a reference to a class instance as attribute in another class and not get "Cannot lookup attributes in a Type object" when trying to use a method of the first class within a method in the second one?

[06:27] <FROGGS> .tell jnthn why will shaped arrays in future declared as 'my @a[3,3]' but used as '@a[1;1] = 42'? why not semicolons in the decl too?

[06:27] <yoleaux> FROGGS: I'll pass your message to jnthn.

[06:30] <nine> emilbarton: if you can show us some code, that would help answering your question

[06:33] <FROGGS> .tell Skarsnik You'd declare the CStruct as 'class Foo is repr<CStruct> { has int32 $.bar }' and then 'say nativecast(Foo, $pointer)'

[06:33] <yoleaux> FROGGS: I'll pass your message to Skarsnik.

[06:37] *** Ven joined
[06:37] <TimToady> they're declared as my @a[3;3]

[06:38] * Ven waves

[06:40] *** bjz joined
[06:41] *** bjz left
[06:46] *** davido_ left
[06:49] * moritz particles

[06:51] <emilbarton> hello, how can I pass a reference to a class instance as attribute in another class and not get "Cannot lookup attributes in a Type object" when trying to use a method of the first class within a method in the second one?

[06:55] <nine> emilbarton: if you can show us some code, that would help answering your question

[06:57] <emilbarton> nine: Class1 { method my1 { ... } } ; Class2 { has Class1 $!classref; method my2 { .. $!classref.my2() } }; my Class1 $C1 = new.(); my Class2 $C2 = new.( classref => $C1 ); $C2.my2(); # Cannot lookup attributes in a Type object... 

[06:59] <nine> m: class Class1 { method my1 { } } ; class Class2 { has Class1 $.classref; method my2 { $!classref.my1() } }; my Class1 $C1 = Class1.new(); my Class2 $C2 = Class2.new( classref => $C1 ); $C2.my2();

[06:59] <camelia> rakudo-moar 92be57: ( no output )

[06:59] <nine> emilbarton: a fixed version ^^^

[07:00] <emilbarton> yes I forgot Classx. but that's not the point, it still answers idem

[07:00] <nine> emilbarton: the error is in the has Class1 $!classref; That creates a private attribute which the default constructor does _not_ set. You have to make it public or to add your own BUILD method to initialize it using the parameter of the constructor.

[07:01] *** abraxxa joined
[07:01] <nine> emilbarton: http://doc.perl6.org/language/classtut#Constructors

[07:02] <emilbarton> nine: I thought there was no real public attribute in perl6 ($.classref does n't help)

[07:03] <nine> emilbarton: that's sort of true. The attribute itself is still only accessible through the accessor methods. But those are generated for you by declaring it as has $.classref; and this also tells the constructor to initialize it.

[07:03] <nine> m: class Class1 { has $.foo = "foo"; method my1 { self.foo; } } ; class Class2 { has Class1 $.classref; method my2 { $!classref.my1() } }; my Class1 $C1 = Class1.new(); my Class2 $C2 = Class2.new( classref => $C1 ); $C2.my2();

[07:03] <camelia> rakudo-moar 92be57: ( no output )

[07:05] <nine> emilbarton: also a reference to a class instance is more commonly referred to as "object".

[07:08] <emilbarton> nine: ok, I see where it messed up, I already have a BUILD() in Class2 but forgot to update it when I added classref. Thanks.

[07:10] *** eugu joined
[07:11] *** Ven left
[07:12] *** emilbarton left
[07:13] <tokuhiro_> hi, i got a issue around IO::Socket::Async. my network server written in perl6 stucks around 1000 requests.

[07:13] <tokuhiro_> code is here: https://gist.github.com/tokuhirom/0b6901f3cea1c3bf6170

[07:14] *** bjz joined
[07:16] <FROGGS> TimToady: okay, so just a typo in jnthn++'s blog :o)

[07:20] <tokuhiro_> ah, i forgot to close socket.

[07:21] *** bjz left
[07:21] *** bjz joined
[07:24] *** bjz left
[07:29] *** Ven joined
[07:35] <Ven> I just realized D has a similar features to our phaser, but with a separate keyword (instead of uppercased ones): `scope(success) write("yay"); scope(failure) write(":(");`

[07:36] <Ven> (I just uppercased names are just considered "not explicit enough" in that kind of area)

[07:38] *** bjz joined
[07:40] <moritz> .oO( explicit content )

[07:42] *** g4 joined
[07:52] * timotimo plasmas

[07:52] <masak> good state of matter, timotimo 

[07:53] <timotimo> though i find you can't really write "/me liquids" or "/me gasses" without it sounding ... funny in a bad way :)

[07:53] <moritz> better than a matter of state, for sure

[07:54] * masak .oO( enemy of the states of matter )

[07:54] * lizmat condenses

[07:55] * moritz waits for somebody to (re)sublimate

[07:56] <Ven> m: say(); say()

[07:56] <camelia> rakudo-moar 92be57: OUTPUT«␤␤»

[07:57] <lizmat> m: note(); note()

[07:57] <camelia> rakudo-moar 92be57: OUTPUT«Noted␤Noted␤»

[07:57] <lizmat> m: note; note

[07:57] <camelia> rakudo-moar 92be57: OUTPUT«Noted␤Noted␤»

[07:57] <moritz> duly.

[07:58] * Ven .oO( /dullies )

[08:03] <timotimo> no time for duly dallying

[08:09] <lizmat> m: say (-> --> Int { |(1,2,3) })().WHAT   # eh, shouldn't this fail ?

[08:09] <camelia> rakudo-moar 92be57: OUTPUT«(Slip)␤»

[08:11] *** duncan_dmg joined
[08:11] <masak> lizmat: at compile time, yes.

[08:11] <lizmat> well, ideally, yes

[08:11] <masak> yes

[08:11] <lizmat> but I'll settle for runtime

[08:11] <lizmat> for now

[08:11] * masak .oO( or both ) :P

[08:11] <lizmat> m: say (-> --> Int { fail })().WHAT 

[08:11] <camelia> rakudo-moar 92be57: ( no output )

[08:12] <lizmat> m: say (-> --> Int { die })().WHAT 

[08:12] <camelia> rakudo-moar 92be57: OUTPUT«Died␤  in block <unit> at /tmp/i4Xc5H0FAT:1␤␤»

[08:12] <timotimo> well, fail works with the outer Routine, so at least i understand the first thing

[08:12] *** RabidGravy joined
[08:20] <lizmat> RT #126232 submitted

[08:28] *** eugu left
[08:31] *** Khisanth left
[08:32] *** larion joined
[08:36] *** vvz joined
[08:41] *** dakkar joined
[08:43] *** telex left
[08:51] *** Khisanth joined
[08:54] *** laouji left
[08:58] *** laouji joined
[08:58] *** telex joined
[09:01] *** ][Sno][ joined
[09:01] *** bjz left
[09:02] *** bjz joined
[09:04] *** [Sno] left
[09:04] <timotimo> it seems like i didn't push the manual change to the CALLER::CALLER:: stuff

[09:06] <timotimo> and i also didn't start implementing the optimization in the static optimizer

[09:07] <timotimo> another thing is that my manual optimization didn't factor out the CALLER::CALLER:: into a single lookup yet

[09:08] <timotimo> that could also give a tiny performance boost on top of what's already there

[09:09] <timotimo> though of course the nqp ops that access the lexpad "directly" aren't nearly as expensive as allocating a pseudostash or something like that

[09:31] *** laouji left
[09:34] *** laouji joined
[09:38] *** ChoHag joined
[09:43] <ChoHag> I have (want) a class which has a Foo attribute. A Foo can be created from a string (and a string created from a Foo) so Foo has a method new (Str $newfoo) { ... }. How can I create an attribute so that the class using it will create it from a string without needing to manually create a Foo?

[09:43] <yoleaux> 1 Sep 2015 20:46Z <TimToady> ChoHag: http://irclog.perlgeek.de/perl6/2015-08-30#i_11144152 looks like a bug to me, since .= is sugar for assignment, and assignment is supposed to be eager; please file a bug report, if you haven't already

[09:44] <timotimo> do we still have the COERCE multi sub?

[09:44] <ChoHag> ie. how can I enable the ability to say Bar.new(foo => "Something") rather than being forced to say Bar.new(foo => Foo.new("Something"))?

[09:44] <timotimo> well, with a .new it's very easy

[09:44] <timotimo> if all else fails, the constructor can do the conversion for you

[09:44] <timotimo> and you can have a Proxy for your attribute that does conversion as well

[09:45] <timotimo> so no tricky business needed even in that case

[09:47] <timotimo> does that help, ChoHag?

[09:48] <timotimo> if Str had a method "Foo" on it, you can just set the type of $.foo to be Foo(Str)

[09:48] <timotimo> you can augment Str to have that method, but subclasses of Str won't have it (like IntStr, NumStr, RatStr, Complexstr)

[09:49] <ChoHag> No, I want to be able to use it in locations other than another class' attribute.

[09:50] <ChoHag> ie. my SpecialString $foo = "normal-string-but-fooified".

[09:50] <timotimo> unless you declare $foo to be coercive (like Foo(Str)) that won't work

[09:51] <ChoHag> my SpecialString(Str) $foo?

[09:51] <timotimo> yeah

[09:51] <timotimo> that will call .SpecialString on anything that's Str

[09:51] *** laouji left
[09:53] <ChoHag> So can I have something like ReallySpecialString which stands in for SpecialString(Str)?

[09:53] <timotimo> there used to be something that'd allow you to declare coercions as a multi sub, but that has the problem that unless you export that multi sub into other scopes, the coercion wouldn't work there

[09:53] <timotimo> good question

[09:54] <timotimo> m: constant CToInt = Int(Str); my CToInt $foo = "100"; say $foo.WHAT

[09:54] <camelia> rakudo-moar 92be57: OUTPUT«5===SORRY!5=== Error while compiling /tmp/IwUEdyBXDu␤Coercion Int(Str) is insufficiently type-like to qualify a variable␤at /tmp/IwUEdyBXDu:1␤------> 3nstant CToInt = Int(Str); my CToInt $foo7⏏5 = "100"; say $foo.WHAT␤    expecting any of…»

[09:54] <timotimo> m: my Int(Str) $foo = "100"; say $foo.WHAT

[09:54] <camelia> rakudo-moar 92be57: OUTPUT«5===SORRY!5=== Error while compiling /tmp/WjQi1BQkqO␤Coercion Int(Str) is insufficiently type-like to qualify a variable␤at /tmp/WjQi1BQkqO:1␤------> 3my Int(Str) $foo7⏏5 = "100"; say $foo.WHAT␤    expecting any of:␤        constraint␤»

[09:54] <timotimo> oh, i didn't know that doesn't work

[09:54] <timotimo> that seals it, then

[10:00] <ChoHag> Well basically what I have/want is an object which can search through a bunch of linked items. The search object needs to be passed around/stored in various places, and the original string needs to be obtainable from it.

[10:01] <ChoHag> And basically I want to be able to provide a regular string in all the places the search object is expected and have it magically turn into a search string for me.

[10:01] <ChoHag> Pretty basic.

[10:02] <gfldex> ChoHag: did you consider to subclass Str?

[10:02] <timotimo> doesn't really help to make the code simpler there

[10:03] <timotimo> there's a module that'll let you change how literals are created, but that'll really only enhance your literals

[10:03] <timotimo> and it'll enhance "all" literals

[10:04] <timotimo> what you can do is mix in a role to improve your Str into the SearchStr

[10:04] *** lizmat left
[10:04] *** lizmat joined
[10:04] <ChoHag> role Magic { ... }; class SearchStr is Str does Magic { ... }?

[10:05] <timotimo> not even that

[10:05] <timotimo> role Magic { ... }; my $foo = "foobar" but Magic;

[10:05] <timotimo> also:

[10:05] *** espadrine joined
[10:05] <timotimo> sub searchWithMagic($inputStr is rw) { $inputStr does Magic unless $inputStr ~~ Magic; ... }

[10:10] *** laouji joined
[10:11] <ChoHag> So anywhere I need a magic string but can coerce to one from a regular string I need to do so explicitely?

[10:12] <timotimo> seems so

[10:13] <ChoHag> Sticking to constructors then, how do I enhance this:

[10:13] <ChoHag> m: role Magic { method end { "knob" } }; class Wizard { has Magic $.staff }; my $rincewind = Wizard.new(staff => "wizzard");

[10:13] <camelia> rakudo-moar 92be57: OUTPUT«Type check failed in assignment to $!staff; expected Magic but got Str␤  in block <unit> at /tmp/OyhDQgdKqC:1␤␤»

[10:14] *** rindolf joined
[10:15] <timotimo> m: role Magic { method end { "knob" } }; class Wizard { has Magic $.staff; method new(Str :$staff) { self.bless(staff => $staff ~~ Magic ?? $staff !! $staff but Magic) } }; my $rincewind = Wizard.new(staff => "wizzard"); say $rincewind.staff.perl

[10:15] <camelia> rakudo-moar 92be57: OUTPUT«"wizzard"␤»

[10:15] <timotimo> m: role Magic { method end { "knob" } }; class Wizard { has Magic $.staff; method new(Str :$staff) { self.bless(staff => $staff ~~ Magic ?? $staff !! $staff but Magic) } }; my $rincewind = Wizard.new(staff => "wizzard"); say $rincewind.staff.end

[10:15] <camelia> rakudo-moar 92be57: OUTPUT«knob␤»

[10:17] <ChoHag> Of course. I should have known that.

[10:19] *** laouji_ joined
[10:19] *** laouji left
[10:20] *** Ven left
[10:23] <ChoHag> Is there any advantage to the ternary rather than a multi method which distinguishes between Str :$staff and Magic :$staff?

[10:25] * grondilu suspects using a multi is better a choice

[10:26] <grondilu> because possible compile time optimizations or something

[10:26] <grondilu> but other people surely know better 

[10:26] <gfldex> m: my Int|Str $a;

[10:26] <camelia> rakudo-moar 92be57: OUTPUT«5===SORRY!5===␤Type 'Int' is not declared. Did you mean 'int'?␤at /tmp/kuUWtnhKeF:1␤------> 3my Int7⏏5|Str $a;␤Malformed my␤at /tmp/kuUWtnhKeF:1␤------> 3my Int7⏏5|Str $a;␤␤»

[10:26] <gfldex> i'm pretty sure Int is declared

[10:27] <grondilu> m: my int|Str $

[10:27] <camelia> rakudo-moar 92be57: OUTPUT«5===SORRY!5===␤Type 'int' is not declared. Did you mean 'Int'?␤at /tmp/3S4oURehT5:1␤------> 3my int7⏏5|Str $␤Malformed my␤at /tmp/3S4oURehT5:1␤------> 3my int7⏏5|Str $␤␤»

[10:27] <grondilu> lol

[10:27] <gfldex> and i believed that used to work

[10:27] <gfldex> m: sub foo(Int|Str $a){};

[10:27] <camelia> rakudo-moar 92be57: OUTPUT«===SORRY!===␤No compile-time value for Str␤»

[10:28] *** zakharyas joined
[10:32] *** kid51 joined
[10:33] <moritz> gfldex: you can make an explicit subtype

[10:33] <moritz> subset IntOrStr of Cool where Int|Str

[10:36] *** AlexDaniel joined
[10:38] <grondilu> m: my Str|Int $

[10:38] <camelia> rakudo-moar 92be57: OUTPUT«5===SORRY!5===␤Type 'Str' is not declared. Did you mean 'str'?␤at /tmp/FI7BDfvGlk:1␤------> 3my Str7⏏5|Int $␤Malformed my␤at /tmp/FI7BDfvGlk:1␤------> 3my Str7⏏5|Int $␤␤»

[10:50] <dalek> ecosystem: 66aa639 | (Tokuhiro Matsuno)++ | META.list:

[10:50] <dalek> ecosystem: Retire Raw-Socket

[10:50] <dalek> ecosystem: review: https://github.com/perl6/ecosystem/commit/66aa63911a

[10:58] *** andreoss joined
[11:08] *** abraxxa left
[11:08] *** rindolf left
[11:13] *** vvz left
[11:14] *** Ven joined
[11:14] *** g4 left
[11:19] *** telex left
[11:20] *** telex joined
[11:28] <masak> grondilu: that's definitely a LTA error message.

[11:29] *** cognominal left
[11:30] <masak> so is the one with the `foo(Int|Str $a){}`

[11:30] <Ven> .tell timotimo http://irclog.perlgeek.de/perl6/2015-10-01#i_11301705 something like this, probably

[11:30] <yoleaux> Ven: I'll pass your message to timotimo.

[11:30] <gfldex> i rakudobuged that LTA as #126234

[11:31] <Ven> m: say (*o*)

[11:31] <camelia> rakudo-moar 92be57: OUTPUT«WhateverCode.new␤»

[11:31] <Ven> it's great to have smileys :-)

[11:31] *** rindolf joined
[11:31] <moritz> m: say (*o*)(* * 2, * + 2)(5)

[11:31] <camelia> rakudo-moar 92be57: OUTPUT«14␤»

[11:31] <Ven> m: my \id = -> $a { $a }; (*o*)(id, id)(5).say

[11:31] <camelia> rakudo-moar 92be57: OUTPUT«5␤»

[11:31] * masak .oO( PIG WITH GLITTERING EYES )

[11:32] * moritz still occasionally wants * as a callable to be the identity function

[11:33] <timotimo> don't we have an identity method now, though?

[11:33] <yoleaux> 11:30Z <Ven> timotimo: http://irclog.perlgeek.de/perl6/2015-10-01#i_11301705 something like this, probably

[11:34] *** [ptc] joined
[11:34] *** [ptc] left
[11:34] <lizmat> moritz: it it is just for map, we could e.g. add a candidate for Whatever ?

[11:35] <moritz> lizmat: no, never for map

[11:35] <moritz> usually for experimenting with other higher-order functions

[11:35] <lizmat> where would you use it as a callable then ?

[11:35] <lizmat> I usually use something like *.Str

[11:39] <Ven> timotimo: I want to update the learnx big time for xmas

[11:39] <timotimo> it gets mentioned from time to time on twitter still

[11:40] <timotimo> mostly in the "look at this crazy shit, a hundred pages to learn the basics of perl6"

[11:40] *** ptc joined
[11:40] *** ptc is now known as Guest69182

[11:40] *** Guest69182 left
[11:42] <Ven> timotimo: I'd be interested to see such tweets

[11:44] <Ven> "the author got a bit carried away :)" well, as a learnx contributor, I can say without a single doubt that the perl6 tutorial goes far, far, far beyond what the others provide

[11:45] <timotimo> right

[11:46] <Ulti> .tell tony-o just sent you a little pull request for Slang::SQL for use nqp; there is another issue around the /is rw/ ish changes

[11:46] <yoleaux> Ulti: I'll pass your message to tony-o.

[11:52] *** ptc_ joined
[11:52] *** ptc_ is now known as [ptc]

[11:53] *** FROGGS[tab] left
[11:54] *** [ptc] left
[11:55] *** [ptc] joined
[11:55] *** laouji_ left
[11:57] *** lizmat left
[12:01] *** rindolf left
[12:02] *** FROGGS[tab] joined
[12:03] *** [ptc] left
[12:03] *** [ptc] joined
[12:12] <Ven> timotimo: not sure that's a bad, or good thing, per se

[12:16] *** sufrostico joined
[12:19] <timotimo> it makes a little bit of a bad impression; learnxinyminutes isn't the right place for such a big thing, it seems

[12:19] <timotimo> i'm not saying "you did bad" or "the tutorial isn't good"; it's just the unfortunate view of others :\

[12:20] <Ven> timotimo: that's why I stopped putting stuff in it, fwiw

[12:20] * Ven certainly has tons of ideas on how to make ruby's tutorial 10 times bigger

[12:21] <ShimmerFairy> Just giving it a quick glance, it seems like it needs a serious reduction, if my understanding of xinyminutes as an introduction to get you up and running is correct.

[12:21] *** rindolf joined
[12:23] *** AlexDaniel left
[12:24] *** abraxxa joined
[12:35] *** ZoffixWork left
[12:42] *** zakharyas left
[12:47] *** zakharyas joined
[12:48] <dalek> ecosystem: 9a888ba | (Shoichi Kaji)++ | META.list:

[12:48] <dalek> ecosystem: add HTTP::Tinyish

[12:48] <dalek> ecosystem: review: https://github.com/perl6/ecosystem/commit/9a888ba343

[12:48] <dalek> ecosystem: f16bd64 | (Zoffix Znet)++ | META.list:

[12:48] <dalek> ecosystem: Merge pull request #62 from shoichikaji/http-tinyish

[12:48] <dalek> ecosystem: 

[12:48] <dalek> ecosystem: add HTTP::Tinyish

[12:48] <dalek> ecosystem: review: https://github.com/perl6/ecosystem/commit/f16bd64ff6

[12:56] <masak> maybe the learnx page should link on to pages of the perl6 docs, for example.

[12:56] <masak> "look here to learn more!", like

[12:58] <Ulti> or clone the structure from other languages and fill out the Perl 6 stuff https://doc.rust-lang.org/stable/book/

[12:59] <Ulti> I semi started doing that via a git books site

[12:59] <Ven> I should probably start writing my blog...

[13:03] *** pippo joined
[13:03] <pippo> m: say lines();

[13:03] <camelia> rakudo-moar 92be57: OUTPUT«(Céad slán ag sléibhte maorga Chontae Dhún na nGall Agus dhá chéad slán ag an Eireagal ard ina stua os cionn caor is coll; Nuair a ghluais mise thart le Loch Dhún Lúich’ go ciúin sa ghleann ina luí I mo dhiaidh bhí gleanntáin ghlas’ Ghaoth…»

[13:04] <Ulti> m: lines().elems.say

[13:04] <camelia> rakudo-moar 92be57: OUTPUT«20␤»

[13:04] <pippo> m: say grep {/^C/}, lines();

[13:04] <camelia> rakudo-moar 92be57: OUTPUT«Method 'match' not found for invocant of class 'Any'␤  in block <unit> at /tmp/yY3Dm2vEXU:1␤␤»

[13:04] *** aborazmeh joined
[13:04] *** aborazmeh left
[13:04] *** aborazmeh joined
[13:05] <pippo> ^^ that used to work.

[13:05] <moritz> m: say grep /^C/, lines()

[13:05] <camelia> rakudo-moar 92be57: OUTPUT«(Céad slán ag sléibhte maorga Chontae Dhún na nGall)␤»

[13:05] <Ulti> m: lines().map( *.words.elems ).Bag.perl.say

[13:05] <camelia> rakudo-moar 92be57: OUTPUT«(5=>1,9=>1,12=>1,13=>4,11=>1,8=>1,16=>2,15=>2,14=>3,0=>3,17=>1).Bag␤»

[13:05] <moritz> workaround

[13:05] <pippo> moritz: thank you. Is is a bug?

[13:05] <ShimmerFairy> pippo: I seem to recall jnthn calling that an accident that it ever did work, but I'm not sure.

[13:06] <pippo> ShimmerFairy: Hah. OK then. I'll correct my script.

[13:06] <pippo> Thank you all!

[13:07] <moritz> m: given 'abc' { say !/x/ }

[13:07] <camelia> rakudo-moar 92be57: OUTPUT«Method 'match' not found for invocant of class 'Any'␤  in block <unit> at /tmp/xMRcmv9l9D:1␤␤»

[13:07] <moritz> I'm sure *that's* a bug

[13:07] <moritz> and somehow it smells like the same (or a similar) issue

[13:08] <ShimmerFairy> moritz: perhaps, though to be honest I've never seen someone try to negate a regex (and visually, it just doesn't make sense to me)

[13:08] <ShimmerFairy> at least, not until people started pointing out that bug :)

[13:08] *** duncan_dmg left
[13:08] <moritz> ShimmerFairy: I've seen it quite often

[13:09] <ShimmerFairy> P5 must be weird then :P

[13:09] <moritz> my @sane = grep { !/\s/ }, @list_of_potential_usernames

[13:09] <moritz> ShimmerFairy: it's not negating the regex, it's negating the result of the regex match

[13:09] <ShimmerFairy> moritz: but it reads like negating a regex. I'd argue that you shouldn't expect it to work in the first place.

[13:10] <ShimmerFairy> (and fwiw I still think not using ~~ to match against a regex is kinda weird :P)

[13:10] *** duncan_dmg joined
[13:11] <moritz> ShimmerFairy: but why not?

[13:11] <moritz> ShimmerFairy: /foo/ works in a boolean context

[13:11] <moritz> ShimmerFairy: and a negation provides a boolean context

[13:11] *** Ven left
[13:11] <moritz> programming languages are all about composing bigger pieces from smaller ones, some composability is really key

[13:12] <moritz> if you think something *shouldn't* compose, you need a really good argument to convince me.

[13:12] <ShimmerFairy> moritz: I honestly think it's a mistake that m// and friends magically match against $_ . And I still say it reads like you're negating the actual regex

[13:12] <pippo> my @a = <a b c>; my regex letters = { @a }; say grep /^<letters>/, lines();

[13:12] <pippo> m: my @a = <a b c>; my regex letters = { @a }; say grep /^<letters>/, lines();

[13:12] <camelia> rakudo-moar 92be57: OUTPUT«5===SORRY!5=== Error while compiling /tmp/Zai3tUiH0z␤Malformed regex␤at /tmp/Zai3tUiH0z:1␤------> 3my @a = <a b c>; my regex letters 7⏏5= { @a }; say grep /^<letters>/, lines()␤»

[13:13] <moritz> ShimmerFairy: well, but // does match against $_, even if you don't like it

[13:13] <moritz> ShimmerFairy: and "it reads like" doesn't convince me. To me, it doesn't read like it.

[13:13] <moritz> pippo: just "my regexe letters { ... }"

[13:13] <moritz> m: my @a = <a b c>; my regex letters { @a }; say grep /^<letters>/, lines;

[13:13] <camelia> rakudo-moar 92be57: OUTPUT«()␤»

[13:13] *** rindolf left
[13:13] <moritz> m: my @a = <A B C>; my regex letters { @a }; say grep /^<letters>/, lines;

[13:13] <camelia> rakudo-moar 92be57: OUTPUT«(Céad slán ag sléibhte maorga Chontae Dhún na nGall Agus dhá chéad slán ag an Eireagal ard ina stua os cionn caor is coll; Ag taisteal dom amach trí chnoic Ghleann Domhain ’s an Mucais ar mo chúl Ach trom lámh Gall, le cluain 's le feall, a thi…»

[13:14] <ShimmerFairy> moritz: regardless, it looks to me like you're negating the regex. It'd be like claiming that  !"str"  didn't negate the string, but rather negated the result of doing  $_ eq "str"

[13:14] <moritz> ShimmerFairy: ! simply negates the boolean value of whatever comes after it

[13:14] <moritz> ShimmerFairy: and the boolean value of a regex just happens to be the match against $_

[13:14] <pippo> moritz: TY

[13:14] <pippo> m: my @a = <a b c>; my regex letters  { @a }; say grep /^<letters>/, lines();

[13:14] <camelia> rakudo-moar 92be57: OUTPUT«()␤»

[13:15] <moritz> ShimmerFairy: so, by current rules, it should work. That it does not is a bug

[13:15] <pippo> m: my @a = <a b C>; my regex letters  { @a }; say grep /^<letters>/, lines();

[13:15] <camelia> rakudo-moar 92be57: OUTPUT«(Céad slán ag sléibhte maorga Chontae Dhún na nGall)␤»

[13:15] <eiro> hello #p6 folks 

[13:15] <pippo> eiro: o/

[13:15] <timotimo> yeah, /foobar/ isn't the regex, it's an application of the regex already

[13:15] <timotimo> otherwise you'd write rx/.../ or regex { ... }

[13:15] <ShimmerFairy> moritz: that's far too magical a boolean value for my tastes.

[13:16] <ShimmerFairy> m: $_ = "abc"; say ?rx/def/  # then this shouldn't fail, if rx// is meant to be an unapplied regex, no?

[13:16] <camelia> rakudo-moar 92be57: OUTPUT«Method 'match' not found for invocant of class 'Any'␤  in block <unit> at /tmp/g50UwRos6q:1␤␤»

[13:16] <moritz> ShimmerFairy: I understand that. You mentioned that multilple times. But that doesn't preclude composability

[13:18] <eiro> i remember seeing somthing like the haskell all@(x:xs) in perl6 and currently trying to find the relevant documentation about it 

[13:18] *** skids joined
[13:18] <eiro> any clue ?

[13:18] <ShimmerFairy> moritz: You can't convince me otherwise that  !/.../  looks so, so wrong. I'm totally fine with the current behavior.

[13:19] <moritz> m: sub f(*@all [ $first, *@rest] ) { say @rest }; f <a b c>; # for eiro 

[13:19] <camelia> rakudo-moar 92be57: OUTPUT«[b c]␤»

[13:19] <moritz> subsignatures

[13:19] <moritz> not sure where or if they are documented

[13:21] <eiro> thanks moritz 

[13:22] *** Ven joined
[13:26] <moritz> eiro: http://doc.perl6.org/type/Signature#Destructuring_Parameters

[13:28] <masak> moritz++

[13:34] *** rindolf joined
[13:35] <jdv79> ShimmerFairy: Perl is all about terse magic stuff like that.  

[13:37] <pippo> o/ #perl6 

[13:37] *** pippo left
[13:39] <masak> ShimmerFairy: as another data point, I have no problem with reading !/\s/ in the intended way, as "match $_ against /\s/ and negate the result"

[13:39] <masak> ShimmerFairy: to be more precise, there are many situations in Perl 6 (and Perl 5) where a regex stands in for its match result

[13:40] <masak> ShimmerFairy: I agree that it's one thing we could aggressively wash that out of the language (like we are slowly doing with implicit flattening everywhere). but I just don't see the reason.

[13:41] <eiro> thanks moritz... i realize i have to make those terms appear in my slides 

[13:42] <jdv79> wash out topical?

[13:42] <eiro> since [+] ^5; why not [&say] ^5 ?

[13:44] <masak> jdv79: wash out auto-matching regexes.

[13:44] <Ven> eiro: because &say could be an array value :)

[13:44] <Ven> m: [[&say]] &5; # eiro: hence

[13:44] <camelia> rakudo-moar 92be57: ( no output )

[13:44] <jdv79> but thst basically kills one liners

[13:45] <Ven> m: [[say]] &5; # eiro: hence

[13:45] <camelia> rakudo-moar 92be57: OUTPUT«5===SORRY!5=== Error while compiling /tmp/IkIr9DhIIb␤Unsupported use of bare "say"; in Perl 6 please use .say if you meant $_, or use an explicit invocant or argument, or use &say to refer to the function as a noun␤at /tmp/IkIr9DhIIb:1␤------> 3…»

[13:46] <ShimmerFairy> jdv79: no it doesn't, you can always do $_ ~~ /.../  (I myself have never done without using ~~, as far as I can recall)

[13:46] <eiro> fair enought ... so if [[&say]] ^5, why not [[-> $x , $y { $x + $y }]] ?

[13:47] <jdv79> that alone would push most of minr to a file

[13:48] <jdv79> terseness is serious biz in one liners

[13:49] *** zakharyas left
[13:51] <eiro> Ven, ok ... i just realized what [[&say actually is ... forget the question :) 

[13:51] <Ven> m: [[&say]] ^5; # eiro: hence

[13:51] <camelia> rakudo-moar 92be57: OUTPUT«01␤True2␤True3␤True4␤»

[13:51] <Ven> heh.

[13:52] <eiro> i'm so excited about [] i hopped we could use a function there 

[13:55] <masak> eiro: the parser needs to decide whether the thing it's seeing is a reduce metaop, or an array.

[13:55] <masak> eiro: [42] is an array. so is [[[[1]]]]. so is [&say]

[13:55] <masak> eiro: only if it sees an infix op in there does it go the metaop path.

[13:57] *** TEttinger left
[13:58] <eiro> masak, thanks for those lines

[14:00] <masak> eiro: in general, if you need to reduce on a function, I'd recommend using the .reduce method on lists/arrays.

[14:01] <masak> m: sub foo($l, $r) { 5 * $l + $r }; say [1, 2, 3, 4].reduce(&foo)

[14:01] <camelia> rakudo-moar 92be57: OUTPUT«194␤»

[14:01] <eiro> that's what i'm trying to do right now. 

[14:02] <masak> eiro: the reason what you were trying is kind of hard is that there *should* be a barrier between the op and function namespaces

[14:02] <masak> or rather, between their usage syntax

[14:03] <eiro> i got it ... not the deep way (i need years for that) but a "pragmatic" way. 

[14:04] <eiro> the thing is: whenever there is a operator, i prefer it over the method call 

[14:05] <masak> remember that locally, in your lexical scope, you can always create all the functions and operators that you need

[14:05] <masak> that means you get your wish inside that scope, without screwing up the environment for everyone outside of that scope

[14:05] <masak> more and more I do this, and I really like that Perl 6 supports this in a big way by making a lot of things lexical

[14:08] <eiro> i already love it too :)

[14:09] <PerlJam> It's funny to me how "lexical" plays an important role in the 5 -> 6 transition just like it did in the 4 -> 5 transition.

[14:10] <PerlJam> s/funny/interesting/  (I mean, it doesn't make me laugh or anything  :)

[14:11] *** pmurias joined
[14:12] *** FROGGS[tab]_ joined
[14:13] *** Ven left
[14:13] *** FROGGS[tab] left
[14:16] *** tokuhiro_ left
[14:16] <masak> PerlJam: and it's even the same idea/concept. in Perl 6 we just turn it up even more.

[14:16] *** aborazmeh left
[14:19] <pink_mist> turn it up to eleve^Wsix!

[14:23] *** Ven joined
[14:30] *** vvz joined
[14:36] *** pmurias left
[14:38] *** pmurias joined
[14:38] *** kaare_ left
[14:38] <jdv79> lex all the things

[14:39] <jdv79> lexx wasnt too terrible of a show

[14:39] *** kaare_ joined
[14:39] <jdv79> what else.  lex luther. all i got.

[14:42] <masak> the Lex building, Lex the Iraq war dog, Lex Vehicle Leasing, USS Lexington, and Lex, West Virginia.

[14:43] <PerlJam> .oO( google++ )

[14:44] <masak> there's also the old Roman law by that name.

[14:46] <mspo> elx club

[14:48] *** Ven left
[14:52] *** Ven joined
[14:52] <dalek> specs: 9bf4b95 | (Nova Patch)++ | S32-setting-library/Containers.pod:

[14:52] <dalek> specs: remove loitering space

[14:52] <dalek> specs: review: https://github.com/perl6/specs/commit/9bf4b95e5d

[14:54] <skids> Can't have loiterers conglomerating in the specs.

[14:54] <Ven> .oO( Tune down for loit )

[14:56] * masak .oO( will loit for food )

[14:57] * nebuchadnezzar just read 6guts article

[15:00] <nebuchadnezzar> jnthn: I read the single argument rule in S07, as a non native english (maybe), I needed to think twice to understand the comment in “@a.push: @b, # same, trailing comma doesn't make > 1 argument”

[15:01] <[Tux]> panda still fails on rakudobrew checkout

[15:02] <[Tux]> no time for games or trial-and-error, so no timings today

[15:04] <_itz> [Tux]: I had to "nuke" before it worked

[15:04] <[Tux]> so have a fresh start?

[15:04] <_itz> yes 

[15:04] <[Tux]> $ make again

[15:05] <nebuchadnezzar> in the “for” case, “@a” and “@a,” are different, but in “push”, “@b” and “@b,” are the same

[15:05] <masak> nebuchadnezzar: I believe there's been some very recent (as in yesterday) change there.

[15:05] <masak> nebuchadnezzar: .push has split up into .push and .append, IIUC

[15:06] <nebuchadnezzar> erf, should read in the git repo

[15:06] <masak> nebuchadnezzar: to reduce the number of special cases of the kind you're confused about

[15:06] <nebuchadnezzar> masak: thanks

[15:12] <nebuchadnezzar> I thought I understood but in fact not, I see the consistency between “for (@a,)” and “[@a,]”, but not with the “@a.push: @b,”

[15:12] <nebuchadnezzar> :-D

[15:13] <nebuchadnezzar> hmm, MoarVM september is out, need to package it

[15:14] <skids> nebuchadnezzar: it was decided it was best if pop always got the same things that were pushed, so if you want the consistency, use append.

[15:15] <skids> (or I guess you have to choose between one of two different consistencies. :-)

[15:16] *** tokuhiro_ joined
[15:20] *** Ven left
[15:21] *** tokuhiro_ left
[15:22] *** fling left
[15:26] *** lizmat joined
[15:28] <[Coke]> m: sub postfix:<thousand>($n) { $n*1000 }; say 1 thousand;

[15:28] <camelia> rakudo-moar 92be57: OUTPUT«5===SORRY!5=== Error while compiling /tmp/zpDjL6c4m6␤Two terms in a row␤at /tmp/zpDjL6c4m6:1␤------> 3ostfix:<thousand>($n) { $n*1000 }; say 17⏏5 thousand;␤    expecting any of:␤        infix␤        infix stopper␤        postfix␤…»

[15:29] <[Coke]> m: sub postfix:<thousand>($n) { $n*1000 }; say 1thousand;

[15:29] <camelia> rakudo-moar 92be57: OUTPUT«1000␤»

[15:29] *** FROGGS left
[15:32] <[Coke]> I have a clue on the the profile issue with exit.

[15:33] <[Coke]> I updated MVM_profile_end to unconditionally throw an exception. --profile -e "" says "===SORRY!===\nSURPRISE" . --profile -e "exit" says "SURPRISE\n\nUnhandled exception: SURPRISE\n at..."

[15:38] *** cognominal joined
[15:39] *** Ven joined
[15:40] <cognominal> I forget the syntax to use a function as an operator. Help

[15:40] <[Tux]> Type check failed in assignment to $chunk; expected Str but got Seq

[15:41] <[Tux]> I hoped p6 would have stabalized on that by now

[15:41] <[Tux]>             loop (my int $i = 0; $i < @ch.elems; $i = $i + 1) {

[15:41] <[Tux]>                 my Str $chunk = @ch[$i]; <==== that line

[15:42] <[Tux]> could that be the .push vs .append change?

[15:42] <[Tux]> so        $buffer.defined and @ch.push: chunks ($buffer, $chx);

[15:42] <lizmat> do you have the most recent panda ?

[15:42] <[Tux]> will now do something different?

[15:43] <[Coke]> m: sub b($a,$b) { $a * 2 + $b } ; 3 [&b] 4 #cognomial

[15:43] <camelia> rakudo-moar 92be57: ( no output )

[15:43] <[Coke]> m: sub b($a,$b) { $a * 2 + $b } ; say 3 [&b] 4 #cognomial

[15:43] <camelia> rakudo-moar 92be57: OUTPUT«10␤»

[15:43] <[Tux]> lizmat, was that q to me or to cognominal ?

[15:43] <lizmat> [Tux]: to you

[15:43] <[Tux]> I rebuilt from scratch

[15:43] <[Tux]> rm -rf moar*

[15:43] <lizmat> ok, weird

[15:44] <lizmat> rm -rf install is my usual way of nuking things

[15:44] <cognominal> [Coke] thx. 

[15:44] <[Tux]>         $buffer.defined and @ch.push: |chunks ($buffer, $chx); # note the |

[15:44] <[Tux]> fixes things

[15:44] * [Coke] rants about not having gdb available on os x so that ./perl6-gdb-m fails.

[15:45] <[Tux]> almost

[15:45] *** jasanj`` joined
[15:46] <lizmat> [Tux]: what you're seeing are some skirmishes in the aftermath of the GLR

[15:46] <lizmat> :-(

[15:47] <_itz> there is lldb on mac now

[15:49] *** jasanj` left
[15:49] *** lichtkind joined
[15:50] <lichtkind> will ther be eval in 6.0?

[15:50] <lizmat> m: EVAL "say q/yes'"

[15:50] <camelia> rakudo-moar 92be57: OUTPUT«5===SORRY!5=== Error while compiling EVAL_0␤Couldn't find terminator / (corresponding / was at line 1)␤at EVAL_0:1␤------> 3say q/yes'7⏏5<EOL>␤    expecting any of:␤        /␤»

[15:50] <lizmat> m: EVAL "say q/yes'/"

[15:50] <camelia> rakudo-moar 92be57: OUTPUT«yes'␤»

[15:51] <[Coke]> _itz: aye.

[15:51] <lizmat> eval is spelled EVAL nowadays (well, since july 2014)

[15:52] <[Tux]> https://github.com/Tux/CSV/commit/a7c3fc3f4c5109be86579737332d44b7e985243e

[15:52] <[Tux]> All tests successful.

[15:52] <[Tux]> Files=25, Tests=19732, 70 wallclock secs ( 3.39 usr  0.17 sys + 227.77 cusr  2.61 csys = 233.94 CPU)

[15:52] <[Tux]> Result: PASS

[15:53] <lizmat> yeah:  so nuking install did the trick ?

[15:53] <[Tux]> no, it did the trick for *panda*

[15:53] <lizmat> ah, changes needed for CSV ?

[15:53] <grondilu> m: constant fact = 1, * * ++$ ... *; say fact[4];

[15:53] <[Tux]> see that commit to view what I had to change in CSV

[15:53] <camelia> rakudo-moar 92be57: OUTPUT«24␤»

[15:53] <lizmat> will do

[15:53] <[Tux]> yes :(

[15:54] *** Ven left
[15:55] * grondilu wonders if C<1, * * ++$ ... *;> is better than C<1, |[*] 1 ..*>

[15:56] <lichtkind> lizmat, ah its upper ase now

[15:56] <lichtkind> thanks

[15:56] <[Tux]> NOT happy

[15:56] <lichtkind> but why?

[15:56] <[Tux]> test             50000    38.704    38.580

[15:56] <[Tux]> test-t           50000    41.004    40.880

[15:56] <lizmat> [Tux]: why did you change the first push to append and the third and last one to using a slip ?

[15:57] <lizmat> [Tux]: when was your last timing 

[15:57] <lizmat> ?

[15:57] <[Tux]> yesterday-morning

[15:58] <[Tux]> on the .append I did not know a better notation

[15:58] <[Tux]> feel free to test and time

[15:58] <lizmat> yeah, so I guess 4f7065226c4f28f88 is really to blame for the performance regression

[15:58] <[Tux]> 14% slowdown

[15:59] *** Ven joined
[15:59] <[Tux]> dinner and then meeting. will be late till I return today (if at all)

[15:59] <[Tux]> enjoy

[15:59] <lichtkind> lizmat++

[16:04] <lizmat> lichtkind: because using EVAL means you're doing something potentially naughty, which means it should be more clear from the code

[16:04] <lichtkind> ah thee weird things should look weird doctrine

[16:04] <lizmat> yup

[16:05] <lichtkind> alright and my second question was if i should position my perl 6 tut (code of first two chapter written) should be in or collective p6 group

[16:06] <lichtkind> and if yes could someone please create

[16:06] *** lichtkind_ joined
[16:06] <moritz> lichtkind: if you're willing to adhere to some style guidelines, you could place them in perl6/doc

[16:07] <moritz> lichtkind: if not, you must come up with a repo name; nobody knows the topic better than you

[16:07] <lichtkind> no its a tutorial paralleling my already existing p5 tut written for freies magazin

[16:07] <moritz> is it meant to be a community project?

[16:07] <lichtkind> yes

[16:07] <lichtkind> as long as nobody disagrees with me :9

[16:07] <cognominal> m: my token infix:sym<--\>> { "$^a -> $^b\n" }; [~] 'a' X[-->] <b c>

[16:07] <camelia> rakudo-moar 92be57: OUTPUT«5===SORRY!5=== Error while compiling /tmp/XLcJTzbXjy␤Prefix -- requires an argument, but no valid term found␤at /tmp/XLcJTzbXjy:1␤------> 3m<--\>> { "$^a -> $^b\n" }; [~] 'a' X[--7⏏5>] <b c>␤    expecting any of:␤        prefix␤»

[16:07] <moritz> aka "no" :-)

[16:07] <lichtkind> it was a joke

[16:08] <moritz> here too

[16:08] <lichtkind> from exprience i know most people will submit typos fixes anyway

[16:08] <cognominal> I thought LTM would apply here :(

[16:08] <lichtkind> i think about a title like perl6 for problem solver

[16:09] <cognominal> what do you think?

[16:09] *** pmurias left
[16:09] <cognominal> m:  sub arrow { "$^a -> $^b\n" }; [~] 'a' X[&arrow] <b c>

[16:09] <camelia> rakudo-moar 92be57: ( no output )

[16:09] <cognominal> m:  sub arrow { "$^a -> $^b\n" }; say [~] 'a' X[&arrow] <b c>

[16:09] <camelia> rakudo-moar 92be57: OUTPUT«a -> b␤a -> c␤␤»

[16:10] <lichtkind> moritz: something like problem-solver-tutorial ? so we have still ame spaces for other tuts

[16:10] *** lichtkind_ left
[16:11] <lizmat> m: my token infix:sym«-->» { "$^a -> $^b\n" }; [~] 'a' X[-->] <b c>

[16:11] <camelia> rakudo-moar 92be57: OUTPUT«5===SORRY!5=== Error while compiling /tmp/geTg5LpEb8␤Prefix -- requires an argument, but no valid term found␤at /tmp/geTg5LpEb8:1␤------> 3ym«-->» { "$^a -> $^b\n" }; [~] 'a' X[--7⏏5>] <b c>␤    expecting any of:␤        prefix␤»

[16:12] <lizmat> cognominal: feels like a rakudobuggable thing to me

[16:12] <cognominal> ok

[16:18] *** tokuhiro_ joined
[16:18] *** larion left
[16:18] *** rindolf left
[16:22] <cognominal> bug sumitted

[16:22] *** rindolf joined
[16:22] *** tokuhiro_ left
[16:23] <Ven> .oO( the bug summit )

[16:26] <lizmat> fwiw, re 4f7065226c4f28f88 I wonder why .push couldn't keep the (old) semantics, and have .append do the non-flattening way

[16:26] <tadzik> hey, you may find this an easy way to get a nice tee-shirt :) https://www.digitalocean.com/company/blog/hacktoberfest-is-back/

[16:26] <TimToady> push needs to work well with pop

[16:32] * lizmat is testing a single value variant of .push

[16:32] <lizmat> keeping in mind the comments above that  :-)

[16:32] <TimToady> it also needs to handle slip

[16:32] <lizmat> yeah  :-)

[16:32] <lizmat> taking care of that (I hope)

[16:37] *** Ven left
[16:38] *** MARTIMM joined
[16:41] <TimToady> m: (*o*)(*.self, *.self)(5).say

[16:41] <camelia> rakudo-moar 92be57: OUTPUT«5␤»

[16:41] <TimToady> moritz: ^^

[16:42] <PerlJam> If pop is the inverse of push, what's the inverse of append?

[16:42] <lizmat> prepend

[16:42] <TimToady> splice

[16:43] <lizmat> ?

[16:43] <skids> append is a lossy operation; there is no actual inverse

[16:43] <PerlJam> skids: what do you mean that append is lossy?

[16:43] <skids> You losethe segmentation between lists

[16:44] <skids> (You can recoup it from the .elems and such, but...)

[16:44] <PerlJam> TimToady: Since splice works on both ends and there's a real low demand for "end aware" removal of multiple elements that make sense I guess

[16:45] <PerlJam> skids: oh, I was just thinkind of "add many" and "remove many"

[16:45] <skids> Well, you can push many.

[16:45] <PerlJam> sure, but now it's "natural" to use append for that :)

[16:46] <jnthn> lizmat: If push needs to handle slip as TimToady mentioned, note (if you didn't already :)) that the cheapest way will be a multi candidate for Slip :)

[16:46] <yoleaux> 06:27Z <FROGGS> jnthn: why will shaped arrays in future declared as 'my @a[3,3]' but used as '@a[1;1] = 42'? why not semicolons in the decl too?

[16:46] <lizmat> jnthn: that's exactly the approach I'm taking :-)

[16:47] <jnthn> \o/

[16:47] <jnthn> lizmat++

[16:48] <lizmat> jnthn: https://gist.github.com/lizmat/b4b6d8494bbe295c411a

[16:48] <lizmat> feels there is something wrong with the Slip candidate though...

[16:49] <jnthn> .tell FROGGS because I thunko; fixed :)

[16:49] <yoleaux> jnthn: I'll pass your message to FROGGS.

[16:49] <jnthn> Wait, isn't the push one wrong?

[16:49] <jnthn> Uh, the \value one

[16:50] <jnthn> It shouldn't be checking for iscont or Iterable, just unconditionally treaitng it as an item?

[16:50] <jnthn> I thought that was the point of the change

[16:50] <lizmat> ah...  mmm...

[16:50] <jnthn> The Slip one actually looks correct

[16:50] <jnthn> Well, if append-list does the right thing... :)

[16:51] <lizmat> method !append-list(@values)

[16:53] * lizmat tests again

[16:53] <lizmat> jnthn: https://gist.github.com/lizmat/b4b6d8494bbe295c411a/revisions

[16:54] <jnthn> Seems better, hopefully :)

[16:55] <lizmat> yeah, looks better so far

[16:55] <PerlJam> does append-list return self?

[16:55] <lizmat> if it doesn't, it should  :-)

[16:55] <lizmat> PerlJam: yes it does

[16:57] <jnthn> m: sub infix:sym<--\>> { "$^a -> $^b\n" }; say [~] 'a' X[-->] <b c>

[16:57] <camelia> rakudo-moar 92be57: OUTPUT«5===SORRY!5=== Error while compiling /tmp/Hptg5mkzZU␤Prefix -- requires an argument, but no valid term found␤at /tmp/Hptg5mkzZU:1␤------> 3\>> { "$^a -> $^b\n" }; say [~] 'a' X[--7⏏5>] <b c>␤    expecting any of:␤        prefix␤»

[16:57] <jnthn> m: sub infix:sym<--\>> { "$^a -> $^b\n" }; say 'b' --> 'c'

[16:57] <camelia> rakudo-moar 92be57: OUTPUT«5===SORRY!5=== Error while compiling /tmp/yuia2iO3k_␤Confused␤at /tmp/yuia2iO3k_:1␤------> 3ix:sym<--\>> { "$^a -> $^b\n" }; say 'b'7⏏5 --> 'c'␤    expecting any of:␤        postfix␤        statement end␤        statement modifier…»

[16:57] <jnthn> The problem isn't the meta-op, I htink tht's that \ isn't an escape there :)

[16:57] <jnthn> m: sub infix:sym<< --> >> { "$^a -> $^b\n" }; say 'b' --> 'c'

[16:57] <camelia> rakudo-moar 92be57: OUTPUT«5===SORRY!5=== Error while compiling /tmp/UaKxYtoKSU␤Confused␤at /tmp/UaKxYtoKSU:1␤------> 3sym<< --> >> { "$^a -> $^b\n" }; say 'b'7⏏5 --> 'c'␤    expecting any of:␤        postfix␤        statement end␤        statement modifier…»

[16:58] <lizmat> m: my token infix:sym«-->» { "$^a -> $^b\n" }; [~] 'a' X[-->] <b c>   # jnthn: tried this also

[16:58] <camelia> rakudo-moar 92be57: OUTPUT«5===SORRY!5=== Error while compiling /tmp/3nqdOLWn0S␤Prefix -- requires an argument, but no valid term found␤at /tmp/3nqdOLWn0S:1␤------> 3ym«-->» { "$^a -> $^b\n" }; [~] 'a' X[--7⏏5>] <b c>   # jnthn: tried this also␤    expecting any …»

[16:58] *** espadrine left
[16:58] <jnthn> Uh, token won't do anything useful :)

[16:58] <jnthn> It's just wrong

[16:58] <jnthn> Should be sub :)

[16:58] <jnthn> I wonder if it's 'cus --> is a terminator though

[16:58] <lizmat> m: sub infix:sym«-->» { "$^a -> $^b\n" }; [~] 'a' X[-->] <b c>   # jnthn: tried this also

[16:58] <camelia> rakudo-moar 92be57: OUTPUT«5===SORRY!5=== Error while compiling /tmp/gGzejOlnSq␤Prefix -- requires an argument, but no valid term found␤at /tmp/gGzejOlnSq:1␤------> 3ym«-->» { "$^a -> $^b\n" }; [~] 'a' X[--7⏏5>] <b c>   # jnthn: tried this also␤    expecting any …»

[16:59] <jnthn> It's just wrongm: sub infix:sym«~~>» { "$^a -> $^b\n" }; [~] 'a' X[~~>] <b c>

[16:59] <jnthn> m: sub infix:sym«~~>» { "$^a -> $^b\n" }; [~] 'a' X[~~>] <b c>

[16:59] <camelia> rakudo-moar 92be57: OUTPUT«Type check failed in binding op; expected Any but got Mu␤  in block <unit> at /tmp/2zzZT39x5t:1␤␤»

[16:59] <lizmat> ok, push is spectest clean now, fixing some error reporting fallout

[16:59] <jnthn> m: sub infix:sym«~~>» { "$^a -> $^b\n" }; say X[~~>] <b c>

[16:59] <camelia> rakudo-moar 92be57: OUTPUT«5===SORRY!5=== Error while compiling /tmp/bQGhqWKTdy␤Expected a term, but found either infix ~~ or redundant prefix ~␤  (to suppress this message, please use a space like ~ ~)␤at /tmp/bQGhqWKTdy:1␤------> 3ix:sym«~~>» { "$^a -> $^b\n" }; say…»

[16:59] <jnthn> m: sub infix:sym«~~>» { "$^a -> $^b\n" }; say 'b' ~~> 'c'

[16:59] <camelia> rakudo-moar 92be57: OUTPUT«5===SORRY!5=== Error while compiling /tmp/F5ahM81TG4␤Variable '&infix:<~~>>' is not declared␤at /tmp/F5ahM81TG4:1␤------> 3ix:sym«~~>» { "$^a -> $^b\n" }; say 'b' 7⏏5~~> 'c'␤»

[17:00] <jnthn> wow, there it parses but screw up the symbol installation? 

[17:00] <jnthn> but yeah, I think --> is "special"

[17:00] <jnthn> yeah

[17:00] <jnthn>     token terminator:sym<arrow>  { '-->' }

[17:00] <jnthn> So we never even look for an infix, I guess

[17:02] <TimToady> the push patch looks to me like it will wrongly flatten .push: [1,2,3]

[17:02] <jnthn> TimToady: After the chnages I asked lizmat++ to do?

[17:02] <TimToady> I think I was looking at the last one

[17:02] <lizmat> TimToady: if so, then there is no test for it

[17:03] <jnthn> TimToady: Now it's a straight nqp::push, which is always single item :)

[17:03] <TimToady> okay, I'll wait and see

[17:03] *** duncan_dmg left
[17:03] <jnthn> TimToady: Her first version had the bug you mentioned, so hopefully... :)

[17:03] <TimToady> coulda been looking at the wrong one

[17:03] * TimToady is still backlogging and only paying half a mind

[17:04] <PerlJam> does that infix:sym<< >>  syntax actually work?  I thought it was just infix:<< >>

[17:04] <dalek> rakudo/nom: 692aaec | lizmat++ | src/core/Array.pm:

[17:04] <dalek> rakudo/nom: Add a single value Array.push variant

[17:04] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/692aaec221

[17:04] <jnthn> Oh, that too :)

[17:05] <TimToady> infix:sym is only for parse rule names, not operator names

[17:05] <PerlJam> right

[17:05] <jnthn> m: sub infix:«~~>» { "$^a -> $^b\n" }; say 'b' ~~> 'c'

[17:05] <lizmat> yeah... I'm looking at the self-is-lazy fails messages, making sure that they say "append" when appending, and "pus" when pushing

[17:05] <camelia> rakudo-moar 92be57: OUTPUT«b -> c␤␤»

[17:05] <jnthn> yes, works fine

[17:05] <lizmat> *push

[17:05] <jnthn> m: sub infix:«-->» { "$^a -> $^b\n" }; say 'b' --> 'c'

[17:05] <camelia> rakudo-moar 92be57: OUTPUT«5===SORRY!5=== Error while compiling /tmp/lkpo9zIN_t␤Confused␤at /tmp/lkpo9zIN_t:1␤------> 3 infix:«-->» { "$^a -> $^b\n" }; say 'b'7⏏5 --> 'c'␤    expecting any of:␤        postfix␤        statement end␤        statement modifier…»

[17:05] <jnthn> But that one won't :)

[17:05] <jnthn> m: sub infix:«~~>» { "$^a -> $^b\n" }; say [~~>] <b c>

[17:05] <camelia> rakudo-moar 92be57: OUTPUT«b -> c␤␤»

[17:05] <jnthn> There we go, works fine if you use the right syntax

[17:06] * jnthn volunteers somebody to write that on the RT (and I guess rejecting it for using the wrong syntax) while he goes for dinner

[17:06] <jnthn> bbl &

[17:06] <TimToady>  m: sub infix:«~~>» { "$^a -> $^b\n" }; say &[~~>].name

[17:06] <camelia> rakudo-moar 92be57: OUTPUT«infix:<~~>>␤»

[17:07] <TimToady> we've really gotta fix that to be infix:<~~\>> or some other round-trippable name

[17:11] *** Ven joined
[17:16] *** Ven left
[17:16] <dalek> rakudo/nom: a10ec97 | lizmat++ | src/core/Array.pm:

[17:16] <dalek> rakudo/nom: Make sure we mention correct push/append if lazy

[17:16] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/a10ec979ba

[17:17] *** dakkar left
[17:21] <Juerd> The "Malformed UTF-8" error is surprisingly LTA

[17:22] <Juerd> It would help to know where the malformed UTF-8 was encountered.

[17:23] <TimToady> a lot of low-level errors are still rather LTA

[17:25] <dalek> rakudo/nom: 469d463 | lizmat++ | src/core/Array.pm:

[17:25] <dalek> rakudo/nom: Add single value candidates for Array.unshift

[17:25] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/469d463f57

[17:30] <cognominal> m: my %a; say %a.^roles

[17:30] <camelia> rakudo-moar 692aae: OUTPUT«Method 'iterator' must be implemented by Iterable because it is required by a role␤  in any compose_method_table at gen/moar/m-Metamodel.nqp:2666␤  in any apply at gen/moar/m-Metamodel.nqp:2676␤  in any compose at gen/moar/m-Metamodel.nqp:2812␤  in…»

[17:30] <lizmat> .tell [Tux] hope I've been able to recoup some of the lost performance

[17:30] <yoleaux> lizmat: I'll pass your message to [Tux].

[17:30] <cognominal> Again, the metamodel fails as a tutorial device

[17:30] * lizmat goes off to get some Martian air

[17:33] *** Peter_R joined
[17:38] *** baest left
[17:40] *** perlatex joined
[17:41] *** baest joined
[17:41] <perlatex> hi

[17:42] *** FROGGS joined
[17:44] *** kid51 left
[17:45] *** perlatex left
[17:47] *** AlexDaniel joined
[17:48] <FROGGS> o/

[17:48] <yoleaux> 16:49Z <jnthn> FROGGS: because I thunko; fixed :)

[17:48] <FROGGS> jnthn: for a moment I thought this msg was about my serialization bug :o)

[17:51] <dalek> doc: b5886ca | (Zoffix Znet)++ | lib/Language/grammars.pod:

[17:51] <dalek> doc: Fix typo

[17:51] <dalek> doc: review: https://github.com/perl6/doc/commit/b5886cafc7

[17:52] *** abraxxa left
[17:53] *** Alina-malina left
[17:58] *** Alina-malina joined
[18:00] <tony-o>  

[18:00] <yoleaux> 11:46Z <Ulti> tony-o: just sent you a little pull request for Slang::SQL for use nqp; there is another issue around the /is rw/ ish changes

[18:00] <tony-o> Ulti: merged it in, thanks for the PR

[18:01] *** lichtkind_ joined
[18:06] *** lichtkind_ left
[18:06] *** AlexDaniel left
[18:11] *** xfix joined
[18:16] *** larion joined
[18:18] *** yqt joined
[18:19] *** tokuhiro_ joined
[18:24] *** tokuhiro_ left
[18:39] *** ZoffixWork joined
[18:40] <dalek> rakudo/nom: f52f0db | FROGGS++ | src/Perl6/Grammar.nqp:

[18:40] <dalek> rakudo/nom: call quoting language $~Quote instead of $~Q, RT #126128

[18:40] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/f52f0db3fb

[18:40] *** [ptc] left
[18:40] <ZoffixWork> Is it known where NativeCall loads .dlls from on Windows? I've got AutoItX3.dll I want to load, but regardless of where I tried to put it, this script is telling me it can't find it: http://fpaste.scsys.co.uk/499720

[18:41] *** [ptc] joined
[18:41] <FROGGS> Zoffix: it looks in CWD and PATH

[18:42] <FROGGS> ZoffixWork: ^^

[18:42] <ZoffixWork> Weird. Not finding it. I did try putting it in C:/Windows/System32 and in the same folder as rakudo or my script are at

[18:42] <FROGGS> well, then the error is not about not finding it

[18:42] <ZoffixWork> Ah

[18:43] <FROGGS> is that windows 8?

[18:44] <ZoffixWork> Win7... Actually, I managed to load AutoItX3_x64.dll (or rather, at least I'm not getting any errors). Maybe it's just a 64vs32 issue.

[18:44] * ZoffixWork tries to call something from AutoItX3_x64

[18:45] <FROGGS> yeah, perhaps...

[18:45] *** andreoss left
[18:54] *** leont joined
[19:00] *** kid51 joined
[19:00] <ZoffixWork> Or maybe it's a C++ lib and only C works? I've no idea what Perl6 type to use for LPCWSTR. Str doesn't work

[19:00] * ZoffixWork doesn't know much about C

[19:00] <ZoffixWork> Well, Str works, but produces trash, because LPCWSTR is a wide char string.

[19:02] <moritz> isn't there some way to specify the encoding with nativecall?

[19:03] <moritz> is NativeCallEncoded['UTF-16']

[19:03] <moritz> or something like that

[19:05] *** ][Sno][ left
[19:05] <FROGGS> the docs say: sub message_box(Str is encoded('utf8')) is native('libgui') { * }

[19:06] *** vendethiel joined
[19:07] <ZoffixWork> Oh, I totally missed that bit. Str is encoded('utf16') works. FROGGS++ moritz++

[19:08] <ZoffixWork> And Perl6++, because I can now use AutoIt without having to deal with AutoIt :P

[19:11] <FROGGS> \o/

[19:12] * FROGGS tries to understand S05-capture/array-capture.t and fails

[19:19] <moritz> FROGGS: I don't even have such a test file

[19:19] <moritz> FROGGS: array-alias.t?

[19:21] <FROGGS> moritz: err yes, this one

[19:21] <moritz> ok(%$/.keys == 1, 'No extra captures');

[19:21] <moritz> bogus precedence?

[19:21] <FROGGS> moritz: I am going to push a rewrite

[19:23] *** sufrostico left
[19:29] <ZoffixWork> I'm not following the signatures.... shouldn't   sub send(Str, Int $mode? ) {}  work for send("foo", 42) as well as send("foo")?  I'm being told it'll never work: http://fpaste.scsys.co.uk/499729

[19:30] *** sufrostico joined
[19:30] <jnthn> ...wtf

[19:30] <jnthn> m: sub send(Str, Int $?) { }; send('x', 42)

[19:30] <camelia> rakudo-moar f52f0d: ( no output )

[19:31] <jnthn> m: use NativeCall; sub send(Str, Int $?) is native('libfoo') { }; send('x', 42)

[19:31] <camelia> rakudo-moar f52f0d: OUTPUT«Cannot locate native library 'libfoo.so': libfoo.so: cannot open shared object file: No such file or directory␤  in method setup at lib/NativeCall.pm:225␤  in method CALL-ME at lib/NativeCall.pm:236␤  in block <unit> at /tmp/lZjIi72bdU:1␤␤»

[19:31] <jnthn> m: use NativeCall; sub send(Str is encoded('utf16'), Int $?) is native('libfoo') { }; send('x', 42)

[19:31] <camelia> rakudo-moar f52f0d: OUTPUT«Cannot locate native library 'libfoo.so': libfoo.so: cannot open shared object file: No such file or directory␤  in method setup at lib/NativeCall.pm:225␤  in method CALL-ME at lib/NativeCall.pm:236␤  in block <unit> at /tmp/8DRVKjCltM:1␤␤»

[19:31] <ZoffixWork> Is it because I'm using Windows rakudo that's likely outdated?  rakudo-star-2015.06-x86_64 (JIT).msi

[19:32] <jnthn> Maybe, but it's still a bizzare thing to happen...

[19:32] <FROGGS> star-m: sub send(Str, Int $?) { }; send('x', 42)

[19:32] <camelia> star-m 2015.03: ( no output )

[19:32] <jnthn> Oh wait, it's a runtime error?

[19:32] <jnthn> The "will never work" is usually compile time. That's very confusing.

[19:33] <FROGGS> ummm

[19:34] <jnthn> epic fail

[19:34] <FROGGS> ZoffixWork: you cannot use optional params anyway with native subs atm

[19:34] <jnthn>         if nqp::elems($args) != $r.signature.arity {

[19:34] <ZoffixWork> FROGGS, ah :(

[19:34] <FROGGS> ZoffixWork: create two multies, one with the second param and one without

[19:34] <ZoffixWork> OK. I'll try

[19:35] <jnthn> It's doing that then throwing...

[19:35] <jnthn> Oh, I guess we don't do varargs yet either

[19:35] <jnthn> So we get away with that check...for now

[19:35] * [Tux] builds ...

[19:35] <yoleaux> 17:30Z <lizmat> [Tux]: hope I've been able to recoup some of the lost performance

[19:35] <FROGGS> jnthn: aye, though it would the wrong thing if it got passed that check

[19:35] <FROGGS> would do*

[19:35] <jnthn> *nod*

[19:36] <jnthn> Better would be to detect the optional/named at the point we apply the trait or do the setup

[19:36] <FROGGS> aye

[19:38] *** tokuhiro_ joined
[19:42] <ZoffixWork> Doesn't look like you can do multies with NativeCall either. Getting "cannot invoke object": http://fpaste.scsys.co.uk/499731

[19:43] <FROGGS> it should work though, I already did that

[19:43] <FROGGS> perhaps add a: proto send(|) { }

[19:44] *** tokuhiro_ left
[19:45] <[Tux]> test             50000    38.978    38.856

[19:45] <[Tux]> test-t           50000    38.680    38.558

[19:48] *** loveJesus joined
[19:48] <ZoffixWork> Not exactly sure what that does, but adding it before multies runs the code with no errors, but the DLL call doesn't seem to be made: http://fpaste.scsys.co.uk/499732

[19:48] <ZoffixWork> If I use just one send with just Str sig, then the call does work

[19:48] *** _dolmen_ joined
[19:50] <FROGGS> Zoffix: I think you signature should be: sub send(Str is encoded('utf16'), Int $a = 0 ) ...

[19:50] <FROGGS> without the other candidate and without the proto

[19:51] <ZoffixWork> No, I already tried that earlier. I get "Cannot unbox a type object  in method CALL-ME at lib/NativeCall.pm:248  in block <unit> at nci.p6:13"

[19:52] <ZoffixWork> Same error as with sub send(Str is encoded('utf16'), Int $a? )

[19:52] <FROGGS> strange

[19:53] *** Possum left
[19:53] <FROGGS> m: say "abcxyd" ~~ m/@<foo>=(.)/ # a brainfart of mine

[19:53] <camelia> rakudo-moar f52f0d: OUTPUT«｢abcxyd｣␤ foo => ｢a｣␤ foo => ｢b｣␤ foo => ｢c｣␤ foo => ｢x｣␤ foo => ｢y｣␤ foo => ｢d｣␤»

[19:55] <moritz> FROGGS: you implied a quantifier where there was none?

[19:55] <PerlJam> implied a quantifier? 

[19:56] <FROGGS> I meant to trick it into create an array... but I think I can fix that

[19:57] *** [ptc] left
[19:58] <FROGGS> yeah, easy fix is easy

[19:59] <dalek> roast: 8c5b0dc | usev6++ | S03-metaops/cross.t:

[19:59] <dalek> roast: Fudge test which passed for the wrong reason

[19:59] <dalek> roast: review: https://github.com/perl6/roast/commit/8c5b0dc968

[20:00] <dalek> nqp: 8402ce0 | FROGGS++ | src/QRegex/P6Regex/Actions.nqp:

[20:00] <dalek> nqp: fix fake quantifier for array captures

[20:00] <dalek> nqp: review: https://github.com/perl6/nqp/commit/8402ce0981

[20:04] *** travis-ci joined
[20:04] <travis-ci> NQP build failed. Tobias Leich 'fix fake quantifier for array captures'

[20:04] <travis-ci> https://travis-ci.org/perl6/nqp/builds/83186346 https://github.com/perl6/nqp/compare/eaa6e113a46d...8402ce098192

[20:04] *** travis-ci left
[20:06] *** xfix_ joined
[20:06] <FROGGS> ENOTMYFAULT

[20:07] *** darutoko left
[20:07] <ZoffixWork> :D

[20:08] *** xfix left
[20:23] *** [Sno] joined
[20:28] *** xfix_ left
[20:28] <dalek> rakudo/nom: 11c84a4 | FROGGS++ | tools/build/NQP_REVISION:

[20:28] <dalek> rakudo/nom: bump nqp for array capture fix

[20:28] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/11c84a4e49

[20:28] <dalek> rakudo/nom: 77e58e4 | FROGGS++ | t/spectest.data:

[20:28] <dalek> rakudo/nom: run S05-capture/array-alias.t

[20:28] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/77e58e445b

[20:29] <dalek> roast: eec7994 | FROGGS++ | S05-capture/array-alias.t:

[20:29] <dalek> roast: reqrite S05-capture/array-alias.t

[20:29] <dalek> roast: 

[20:29] <dalek> roast: I hope the changed semantics meet out current expectations.

[20:29] <dalek> roast: Please review carefully.

[20:29] <dalek> roast: review: https://github.com/perl6/roast/commit/eec7994c1f

[20:29] <FROGGS> reqrite

[20:30] * FROGGS sighs

[20:30] <FROGGS> our*

[20:30] <FROGGS> such typo

[20:31] *** sufrostico left
[20:32] *** kid51 left
[20:32] *** _dolmen_ left
[20:33] *** vendethiel left
[20:34] <FROGGS> gnight

[20:34] *** FROGGS left
[20:38] *** sufrostico joined
[20:38] <PerlJam> FROGGS++

[20:41] *** vendethiel joined
[20:42] <lichtkind> jnthn++

[20:42] *** colomon left
[20:46] *** colomon joined
[20:49] *** mtj_ left
[20:51] *** sunnavy joined
[20:53] <lizmat> [Tux]:  :-(

[20:54] <lizmat> jnthn: could it be we lost some optimizations due to addition of append/prepend ?

[20:54] *** kaare_ left
[20:57] *** sunnavy left
[20:58] *** sunnavy joined
[20:58] *** mtj_ joined
[20:59] <lichtkind> jnthn thanks of the fix

[21:01] *** petercommand joined
[21:01] <dalek> roast: 927d805 | usev6++ | S32-hash/delete.t:

[21:01] <dalek> roast: Fudge test that passed for the wrong reason

[21:01] <dalek> roast: review: https://github.com/perl6/roast/commit/927d8052ee

[21:02] <dalek> roast: 3cbb371 | usev6++ | S (7 files):

[21:02] <dalek> roast: Replace remaining eval-dies-ok with throws-like

[21:02] <dalek> roast: review: https://github.com/perl6/roast/commit/3cbb37192d

[21:02] <dalek> roast: 3e1099a | TimToady++ | S07-slip/slip.t:

[21:02] <dalek> roast: slip tests

[21:02] <dalek> roast: review: https://github.com/perl6/roast/commit/3e1099a81f

[21:02] <jnthn> .oO( rewuiem for FROGGS typing skills... )

[21:02] <dalek> rakudo/nom: 8bc8467 | TimToady++ | src/core/Slip.pm:

[21:02] <dalek> rakudo/nom: delete incorrect, duplicate code

[21:02] <dalek> rakudo/nom: 

[21:02] <dalek> rakudo/nom: (If we really need to dup code for performance, it should do one-arg

[21:02] <dalek> rakudo/nom: lazy semantics correctly as the new slip.t tests now test for.)

[21:02] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/8bc846721a

[21:02] <dalek> rakudo/nom: 0f62d9f | TimToady++ | t/spectest.data:

[21:02] <dalek> rakudo/nom: add S07-slip/slip.t

[21:02] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/0f62d9fc05

[21:03] <jnthn> lizmat: Dunno, but TimToady's (useful) semantic cleanup work isn't always very performance-aware ;-)

[21:04] <jnthn> Being fast and wrong isn't very useful though, so souldn't complain too much :)

[21:04] <jnthn> Anyway, no point wasting time guessing what's slowed down. Just --profile it

[21:04] <jnthn> And look at the two side by side

[21:05] * jnthn used the profiler to find many improvements to Rakudo to improve Text::CSV so far :)

[21:07] <lizmat> my @a; @a.push(42) for (^100)   # 65% of time spent in sink-all

[21:07] <TimToady> m: my \c = 0, slip [\+] 1..*; say c[100000]

[21:07] <camelia> rakudo-moar 77e58e: OUTPUT«Nil␤»

[21:07] <TimToady> that should fix itself now

[21:07] <lizmat> I was surprised to learn that for internally maps to map, and that to sequential-map

[21:08] <lizmat> (and then sink-all in there)

[21:08] <leont> Had a weird issue where an array appeared to be empty but true, still figuring it out :-s

[21:08] *** MARTIMM left
[21:08] <lizmat> if we're running a for of which we *know* we want the body just executed for its side effects, why do we need to run it through map with sink-all ?

[21:09] *** telex left
[21:09] <leont> Ah, apparently it contained a [[],]

[21:09] <jnthn> lizmat: I think I made the map iterator special-case sink-all already to not care for the results

[21:10] <lizmat> well, it's doing a repeated $source.pull-one instead of a push-all ?

[21:10] *** telex joined
[21:10] <jnthn> Indeed. https://github.com/rakudo/rakudo/blob/nom/src/core/Any-iterable-methods.pm#L158

[21:10] <jnthn> Uh

[21:10] <jnthn> How could it push-all?

[21:10] *** skids left
[21:10] <jnthn> That makes no sense.

[21:11] <lizmat> I meant sink-all

[21:11] <lizmat> I mean, if it can do a pull-one, it can do a sink-all, no?

[21:11] <jnthn> ?

[21:11] <jnthn> sink means "I don't want the values"

[21:11] <jnthn> in for @foo -> $n { } we certainly want the values :)

[21:12] <jnthn> (to pass for $n)

[21:12] <lizmat> ah, yes: duh  :-)

[21:12] <jnthn> In the particular case of 'for ^100' though, I'm a bit surprised the "re-write to a while loop" opt doesn't kick in.

[21:12] <jnthn> So for that particular range case, something is off

[21:13] <jnthn> Maybe we don't nail it for the statement modifier form somehow

[21:14] <lizmat> for ^100 {  }  gives very similar results

[21:15] <lizmat> looks like it's still doing a map there

[21:16] <lizmat> a manual while loop gives *very* different results

[21:28] *** ZoffixWork left
[21:28] *** espadrine joined
[21:29] * lizmat is looking at the range -> while optimizer

[21:31] <timotimo> jnthn: the "rewrite for to while loop" opt is currently bust

[21:31] <timotimo> because the qast to build for loops has changed quite a bit

[21:31] <timotimo> and i didn't yet bother to come up with an elegant solution to keep the object around that we iterate over

[21:31] <timotimo> because it's now a sibling to the for loop rather than a child :\

[21:32] <lizmat> timotimo: you're saying you know what the problem is but don't know how to fix it ?

[21:32] *** larion left
[21:32] <jnthn> timotimo: ah, ok

[21:33] <jnthn> sleep time....'night, #perl6

[21:33] <timotimo> i know how to fix it, just not how to fix it well

[21:33] <lizmat> gnight, jnthn

[21:33] <timotimo> i can explain easier when we both bring up the qast dump of 'for ^100 { }'

[21:34] *** espadrine left
[21:34] <timotimo> then you'll see there's a bind op with a local called "for-list_1"

[21:34] <timotimo> that's then used in map & sink

[21:34] <timotimo> hey, what kind of operator would we use ſ for?

[21:36] *** dha joined
[21:36] *** dha left
[21:37] *** dha joined
[21:37] <lizmat> timotimo: looking at it

[21:39] *** larion joined
[21:40] <lizmat> timotimo: the first condition that fails, is @($op[0]) == 2

[21:40] <timotimo> i suppose it'd be enough to store a list of the things for-list_* is bound to

[21:40] <timotimo> the thing is, when you notice you're looking at a sink(map(...)), you can't just go to the previous sibling, because there's no reference to the parent

[21:40] <dalek> roast: 33182cf | usev6++ | S02-types/ (2 files):

[21:40] <dalek> roast: Start to replace dies-ok with throws-like (S02-types)

[21:40] <dalek> roast: 

[21:40] <dalek> roast: Thereby unfudge one passing test

[21:40] <dalek> roast: review: https://github.com/perl6/roast/commit/33182cf0f5

[21:41] <timotimo> unless we do something terrible like nqp::ctxlexpad(nqp::callerctx(nqp::ctx))('$node') or whatever

[21:41] *** tokuhiro_ joined
[21:42] <lizmat> timotimo: I'm afraid I lost you already :-(

[21:45] *** tokuhiro_ left
[21:47] <timotimo> i suppose you're looking at the existing code to do the for-to-while optimization, yeah?

[21:47] <lizmat> yeah

[21:48] <lizmat> I assume the "optimize_for_range" method will need adjustment as well, then

[21:51] <timotimo> yes

[21:52] <lizmat> ok, I guess I'm definitely out of my league then

[21:52] <timotimo> i was thinking when we see a bind with a local that matches for-list_(\d+) we take that number as an index into a list that stores the upper and lower bounds we've extracted from the range (if it has a range at all)

[21:54] <lizmat> I wonder if the initial code-gen couldn't more easily leave a marker

[21:54] <lizmat> that would either be removed during optimization, or replace the optimization ?

[22:09] <masak> 'night, #perl6

[22:12] <lizmat> gnight, masak

[22:15] <colomon> \o

[22:17] *** cognominal left
[22:24] *** dha left
[22:26] <lizmat> hmmm.. I just realize we lost 15% in bare startup time as well  :-(

[22:27] <lizmat> around 115 msecs, was below 100  :-(

[22:28] *** larion left
[22:42] <timotimo> nine explained to me why the bind was important in the code-gen, but i forgot

[22:42] <timotimo> perhaps there really is a way to remove the bind if we know we'll be using the .. operator (or its friends) from the core setting

[22:42] *** larion joined
[22:51] <lizmat> FWIW, I'm optimizing the Range iterator itself

[22:51] <timotimo> that's good for every case where we don't have access to the range in question at compile time

[22:52] <timotimo> which is every benchmark that takes the number of runs to do from ARGS, for example

[22:53] <lizmat> a bare start contains at least two Range.push-all 's

[22:54] <timotimo> oh, i didn't realize

[22:54] <timotimo> that's good

[22:54] *** lichtkind left
[22:54] <lizmat> I wonder where they are...

[22:54] * timotimo lifts a rock

[22:54] <timotimo> nope, not here

[22:54] <lizmat> :-)

[22:54] <lizmat> those pesky ^n 's

[22:55] <timotimo> yeah

[23:03] <dalek> rakudo/nom: e7ec205 | lizmat++ | src/core/Range.pm:

[23:03] <dalek> rakudo/nom: Optimize the finite integer Range iterator

[23:03] <dalek> rakudo/nom: 

[23:03] <dalek> rakudo/nom: my @a = ^100000 is now ~ 30% faster, (^100000).map: *.Str about 15%

[23:03] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/e7ec205c01

[23:04] <dalek> roast: 870186b | lizmat++ | S05-metasyntax/angle-brackets.t:

[23:04] <dalek> roast: Remove ) straggler

[23:04] <dalek> roast: review: https://github.com/perl6/roast/commit/870186bf3d

[23:05] *** Peter_R left
[23:05] * lizmat calls it a day

[23:06] *** rindolf left
[23:06] <lizmat> so good night, #perl6!

[23:10] *** lichtkind joined
[23:11] *** TEttinger joined
[23:12] *** bjz left
[23:12] *** BenGoldberg joined
[23:13] <BenGoldberg> m: sub f { $^x + 1 }; sub g { $^x * 2 }; (f o g).say;

[23:13] <camelia> rakudo-moar 0f62d9: OUTPUT«5===SORRY!5=== Error while compiling /tmp/9k2vLglGK_␤Undeclared routine:␤    o used at line 1␤␤»

[23:13] <BenGoldberg> m: sub f { $^x + 1 }; sub g { $^x * 2 }; (&f o &g).say;

[23:13] <camelia> rakudo-moar 0f62d9: OUTPUT«-> |args is raw { #`(Block|73959776) ... }␤»

[23:14] <BenGoldberg> m: sub f { $^x + 1 }; sub g { $^x * 2 }; (&f o &g)(3).say;

[23:14] <camelia> rakudo-moar 0f62d9: OUTPUT«7␤»

[23:15] *** zakharyas joined
[23:25] *** mr_ron joined
[23:30] *** kid51 joined
[23:34] <mr_ron> m: kill($*PID, "INT")

[23:34] <camelia> rakudo-moar e7ec20: OUTPUT«5===SORRY!5=== Error while compiling /tmp/J2YnneE5vV␤Undeclared routine:␤    kill used at line 1␤␤»

[23:35] <mr_ron> anyone know how to signal/kill your own process with Perl 6?

[23:36] *** zakharyas left
[23:36] <timotimo> .tell lizmat i wonder if push-exactly should check for "will we reach the end?" at the beginning and then perhaps use a tiny bit better code?

[23:36] <yoleaux> timotimo: I'll pass your message to lizmat.

[23:37] <mr_ron> It looks like a usable kill function is included in S29 but I didn't notice a test for that kill function int the S29 area of roast ...

[23:42] *** tokuhiro_ joined
[23:45] <TimToady> well, run("kill", $pid) will work on Unix

[23:45] <TimToady> but we should do better

[23:46] <TimToady> run("kill", $*PID) to kill your own process

[23:47] *** tokuhiro_ left
[23:49] <TimToady> m: use NativeCall; sub kill(int $proc, int $sig) is native("libc") {*}; kill($*PID,1); sleep 1

[23:49] <camelia> rakudo-moar e7ec20: OUTPUT«Cannot locate native library 'libc.so': /usr/lib64/libc.so: invalid ELF header␤  in method setup at lib/NativeCall.pm:225␤  in method CALL-ME at lib/NativeCall.pm:236␤  in block <unit> at /tmp/lyzt5zrvBb:1␤␤»

[23:49] <TimToady> hmm

[23:51] <BenGoldberg> m: use NativeCall; sub kill(int $proc, int $sig) is native("") {*}; kill($*PID,1); sleep 1

[23:51] <camelia> rakudo-moar e7ec20: OUTPUT«Cannot locate native library '.so': .so: cannot open shared object file: No such file or directory␤  in method setup at lib/NativeCall.pm:225␤  in method CALL-ME at lib/NativeCall.pm:236␤  in block <unit> at /tmp/BQdHzHUjPV:1␤␤»

[23:51] *** vendethiel left
[23:53] <BenGoldberg> m: use NativeCall; sub kill(int $proc, int $sig) is native(Str) {*}; kill($*PID,1); sleep 1

[23:53] <camelia> rakudo-moar e7ec20: OUTPUT«(signal HUP)»

[23:53] <BenGoldberg> That's not an INT!

[23:53] *** RabidGravy left
[23:54] <mr_ron> It's not that important ... I'll find a way around it.  It looks like only a small part of S29/OS is tested in roast.  It looks obvious enough not to need an RT but if someone likes I'll write one up ...

[23:54] <TimToady> I think it's important to get it on the by-Christmas list

[23:55] <TimToady> m: use NativeCall; sub kill(Int $proc, Int $sig) is native {*}; kill($*PID,2); sleep 1

[23:55] <camelia> rakudo-moar e7ec20: OUTPUT«(signal INT)»

[23:56] <TimToady> I guess just leave off the argument entirely

[23:57] <TimToady> j: use NativeCall; sub kill(Int $proc, Int $sig) is native {*}; kill($*PID,2); sleep 1

[23:57] <camelia> rakudo-jvm e7ec20: ( no output )

