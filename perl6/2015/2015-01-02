[00:09] <psch> raydiak: it's ticketed, RT #111512.  i didn't dig into specs, but the ticket exists might mean it should work but is bugged... :)

[00:09] <synopsebot> Link: https://rt.perl.org/rt3//Public/Bug/Display.html?id=111512

[00:09] <psch> s/exists/existing/

[00:10] <raydiak> cool thanks psch

[00:12] <psch> i'm off to sleep o/

[00:24] *** KCL_ joined
[00:33] *** colomon joined
[00:40] *** yeahnoob joined
[01:05] *** jack_rabbit joined
[01:13] <raydiak> grr modern browsers...close 2 tabs, free up a gig of ram :P

[01:24] *** avuserow joined
[01:24] <raydiak> apparently sandboxing everything is necessary these days so malicious coders can't harm your computer via websites, but running you out of cpu and ram until the whole system slows to an unusable crawl due to 1 ill-tempered script or plugin is still totally acceptable

[01:25] <geekosaur> mm, browsers *try* to detect that these days

[01:25] <geekosaur> chrome seems pretty good at it of late

[01:25] <geekosaur> on os x at least

[01:29] <raydiak> seems like it only offers to kill stuff for me if the process doesn't repond for like...half a minute plus...which by that point everything else is often going just as slow

[01:30] <raydiak> *respond

[01:31] *** anaeem1 left
[01:35] *** Jablonski is now known as pjablons

[01:58] *** petercom1and left
[01:58] *** petercom1and joined
[01:58] *** petercom1and is now known as petercommand

[02:00] <pjablons> this is silly and trivial, but is there a good way to set the default value for a list at declaration? ie initialize to a list of eight 7's?  x seems to just make it one value.

[02:01] <raydiak> pjablons: x is for making strings, xx for lists :)

[02:01] <raydiak> m: say 7 xx 8

[02:01] <camelia> rakudo-moar 80b912: OUTPUT«7 7 7 7 7 7 7 7␤»

[02:01] <pjablons> i don't even want to know what xxx does, then :P

[02:01] <pjablons> thanks

[02:02] <raydiak> heh you're welcome .oO( xxx NYI...well volunteered! :P )

[02:09] * raydiak tracks down his precomp heisenbug, does a momentary happy dance

[02:23] *** rmgk_ joined
[02:23] *** rmgk_ is now known as rmgk

[02:39] *** Ben_Goldberg left
[02:39] *** Ben_Goldberg joined
[02:40] *** Ben_Goldberg left
[02:40] *** Ben_Goldberg joined
[02:47] *** pmurias left
[03:00] *** sirdancealot joined
[03:02] *** yeahnoob left
[03:31] <Ven> wow. c++ got "fold expressions". when are  they even gonna stop :P ?

[03:32] <Ven> it's like our meta-reduce op

[03:41] *** noganex_ joined
[03:52] *** raiph joined
[04:24] *** nwc10 left
[04:26] *** nwc10 joined
[04:30] *** raiph left
[04:39] *** kaare__ joined
[04:59] *** adu joined
[05:04] *** kaleem joined
[05:14] *** Ben_Goldberg left
[05:16] *** adu left
[05:34] *** kaleem left
[05:42] *** kaare__ left
[06:04] *** adu joined
[06:05] *** kaleem joined
[06:08] *** yeahnoob joined
[06:12] *** kaare__ joined
[06:34] <Woodi> morning #perl6 :)

[06:44] <raydiak> good morning Woodi

[06:45] <adu> good morning

[06:45] <raydiak> \o adu

[06:45] <adu> o/

[06:46] <raydiak> adu: hopefully you don't need to worry about it often, but I added the "rakudobrew test" command I mentioned would have been helpful, just fyi

[06:47] <adu> raydiak: :)

[06:47] <raydiak> so instead of tracking down the dir and make spectest you can just 'rakudobrew test'

[06:47] <adu> thanks, I'm sorry I suck at finding Makefiles

[06:47] <Woodi> about current "modern" browsers: I moved back to firefox from chrome and looking for something better again... so many freezes. ~130Mb on start. just switching between 4 very plain pages makes it goes 10Mb more. IMO it's madness...

[06:48] <adu> Woodi: me too, actually

[06:48] <Woodi> and: new R* yay ! \o/

[06:50] <raydiak> yeah browsers kinda irritate me, but then again a lot of modern software does

[06:51] <raydiak> I have a computer that plays netflix but windows 7 solitare brings it to its knees

[06:52] <adu> raydiak: I think the ideal browser would be something that JIT compiled a page to OpenVG would be kind of amazing

[06:53] <raydiak> hmm maybe I'll switch to links...

[06:54] <adu> I read a comparison of TUI browsers

[06:54] <adu> https://kmandla.wordpress.com/2011/01/13/a-comparison-of-text-based-browsers/

[06:55] <adu> it's confusing because there are like 5 browsers that sound like "links"

[06:55] <adu> some of them are forks

[06:59] <Woodi> I remember there was some TUI browser with javascript, links ?

[06:59] <raydiak> yeah I remember as a kid for a while my only access to the internet was the local library bbs that you could use lynx on

[07:00] <Woodi> yea, even gopher was better then ftp :)

[07:02] *** rurban joined
[07:12] <Woodi> mozilla could do that 64bit binary for Windows now, it's 2015 ! ;)  or they are waiting for some commercial compilation-only product, Librefox or something ? 

[07:15] *** jluis joined
[07:16] *** LLamaRider joined
[07:29] *** kaleem left
[07:43] *** darutoko joined
[07:45] *** yeahnoob left
[07:46] *** yeahnoob joined
[07:47] <LLamaRider> r: fork();

[07:47] <camelia> rakudo-{parrot,moar} 80b912: OUTPUT«===SORRY!=== Error while compiling /tmp/tmpfile␤Undeclared routine:␤    fork used at line 1␤␤»

[07:48] <LLamaRider> Hi everyone, I'm looking for a fork :)

[07:52] <tadzik> wy would you want to fork :)

[07:52] <tadzik> but you can get it from NativeCall

[07:52] <tadzik> https://github.com/jnthn/zavolaj/blob/master/examples/unix-fork.p6

[07:53] *** rindolf joined
[07:53] <LLamaRider> tadzik: I can't write a fork bomb if I can't write a fork :D

[07:54] <LLamaRider> I'm also surprised you would hide it down in NativeCall, rather than have it as a low-level primitive in the p6

[07:55] <LLamaRider> but this is handy, thanks :)

[08:01] <Timbus> i think its being avoided because windows cannot do it

[08:02] *** zakharyas joined
[08:06] <LLamaRider> That's a fair point. perl5 just "faked" that somehow

[08:07] <raydiak> emulated fork w/threads iirc

[08:08] *** rurban left
[08:13] <LLamaRider> what I know is that perl5 has one of the briefest cross-platform fork bombs

[08:13] <LLamaRider> "fork while 1"

[08:13] <LLamaRider> so I was just wondering how that would look in p6 :)

[08:15] <raydiak> certainly some of our other concurrency constructs must be able to make entertaining explosions...???...

[08:18] *** virtualsue joined
[08:21] <raydiak> probably not as short, but something with Thread.start should be more portable I'd think

[08:26] <LLamaRider> I'm tinkering with something, but can't figure out how to wait for all start{} blocks to finish at the end of my program?

[08:27] *** leonid joined
[08:27] <LLamaRider> ah, I need to collect all promises and then .finish on each :/

[08:27] <Timbus> await

[08:27] <Timbus> await @promises

[08:29] <LLamaRider> r: sub bomb { start { bomb; bomb; } }; await { bomb; } # fuse is wet, no boom

[08:29] <camelia> rakudo-parrot 80b912: OUTPUT«===SORRY!=== Error while compiling /tmp/tmpfile␤Undeclared routines:␤    await used at line 1␤    start used at line 1. Did you mean 'spurt', 'sqrt', 'sort'?␤␤»

[08:29] <camelia> ..rakudo-moar 80b912: ( no output )

[08:29] <LLamaRider> I am doing this wrong somehow

[08:31] <Timbus> m: await { say 'test' }

[08:31] <camelia> rakudo-moar 80b912: ( no output )

[08:31] <raydiak> you have to pass await a promise, not a block

[08:32] <Timbus> dunno why you think await takes a block

[08:33] <Timbus> also, im pretty sure moarvm uses a threadpool, so its going to be more of a small pop, rather than an explosion

[08:33] <LLamaRider> ah. because start{} takes a block. Wrong intuition

[08:34] <LLamaRider> removing the {} doesn't change anything though 

[08:34] <LLamaRider> r: sub bomb { start { bomb; bomb; } }; await bomb; # fuse is wet, no boom

[08:34] <camelia> rakudo-parrot 80b912: OUTPUT«===SORRY!=== Error while compiling /tmp/tmpfile␤Undeclared routines:␤    await used at line 1␤    start used at line 1. Did you mean 'spurt', 'sqrt', 'sort'?␤␤»

[08:34] <camelia> ..rakudo-moar 80b912: ( no output )

[08:34] <raydiak> yeah you can sleep 1 while $*SCHEDULER.loads, but $*SCHEDULER.max_threads defaults to only 16

[08:35] <raydiak> but if you do Thread.start, I *think* you circumvent the scheduler entirely

[08:37] *** Maddingue left
[08:38] <raydiak> m: sub bomb () {Thread.start: &bomb while 1}; bomb

[08:38] <camelia> rakudo-moar 80b912: OUTPUT«Memory allocation failed; could not allocate 8824 bytes␤Memory allocation failed; could not allocate 8824 bytes»

[08:40] <Timbus> m: Thread.start:{} while 1

[08:40] <camelia> rakudo-moar 80b912: OUTPUT«Type check failed in binding &code; expected 'Callable' but got 'Hash'␤  in method start at src/gen/m-CORE.setting:20402␤  in block <unit> at /tmp/hDmzLQe28r:1␤␤»

[08:40] <Timbus> m: Thread.start:{;} while 1

[08:40] <camelia> rakudo-moar 80b912: OUTPUT«Could not spawn thread: errorcode -1␤»

[08:40] <Timbus> well ok

[08:41] <Timbus> golf sucks anyway

[08:41] * Timbus throws club away

[08:41] *** Maddingue joined
[08:42] <raydiak> yeah I don't think we'll be anywhere near p5's golfability on this one

[08:51] *** jack_rabbit left
[08:52] <raydiak> g'night #perl6 o/

[08:54] <moritz> \o

[08:54] <LLamaRider> \o raydiak 

[08:56] *** zakharyas left
[09:00] *** prime joined
[09:01] *** zakharyas joined
[09:05] *** xfix joined
[09:05] *** [Sno] joined
[09:06] *** kaleem joined
[09:12] *** kjs_ joined
[09:13] *** jack_rabbit joined
[09:22] *** virtualsue left
[09:24] *** jack_rabbit left
[09:24] <nine> .tell pmurias Have never tried that so probably serializing Python objects doesn't work. I also don't like having to initialize Python at BEGIN time, but I create a Python class for every Perl class that inherits from a Python class. And that's a very BEGIN time thing to do.

[09:24] <yoleaux> nine: I'll pass your message to pmurias.

[09:25] *** colomon left
[09:31] *** mvuets joined
[09:40] *** colomon joined
[09:50] *** BigBear joined
[10:05] *** yeahnoob left
[10:08] *** TuxCM joined
[10:12] *** kjs_ left
[10:12] *** Hor|zon joined
[10:24] *** telex left
[10:26] *** telex joined
[10:28] *** Patterner joined
[10:28] *** adu left
[10:31] *** kaleem left
[10:32] *** adu joined
[10:37] *** kjs_ joined
[10:40] *** kaleem joined
[10:53] *** kjs_ left
[10:58] *** virtualsue joined
[11:02] <xfix> r: [1, 2].map({$_, $_}).perl.say

[11:02] <camelia> rakudo-{parrot,moar} 80b912: OUTPUT«((1, 1), (2, 2)).list␤»

[11:02] <xfix> r: [1, 2].for({$_, $_}).perl.say

[11:02] <camelia> rakudo-{parrot,moar} 80b912: OUTPUT«((1, 1), (2, 2)).list␤»

[11:02] <xfix> What is the difference between map and for?

[11:06] <xfix> Oh, map doesn't flatten left side. It's not about right side.

[11:09] *** kjs_ joined
[11:23] *** adu left
[11:30] *** kjs_ left
[11:31] *** Rounin joined
[11:33] <moritz> xfix: currently, they are identical. .map will stop flattening though

[11:33] *** pmurias joined
[11:33] <pmurias> hi

[11:33] <yoleaux> 09:24Z <nine> pmurias: Have never tried that so probably serializing Python objects doesn't work. I also don't like having to initialize Python at BEGIN time, but I create a Python class for every Perl class that inherits from a Python class. And that's a very BEGIN time thing to do.

[11:34] *** jluis left
[11:34] <pmurias> nine: the problem with doing things at BEGIN time is that the python objects will have to get serialized

[11:34] <pmurias> if we precompile

[11:36] *** sirdancealot left
[11:36] <nine> pmurias: I'm currently trying to defer Python class creation to runtime. This may also fix very strange errors Python is giving me in t/inherit.t. Of course, like so often, Python's error message is less than helpful...

[11:40] *** jluis joined
[11:40] <xfix> By the way, what is the equivalent of flat_map from Ruby in Perl 6? .map.flat? In Ruby, [1, 2, 3].flat_map { |item| [item, item] } gives [1, 1, 2, 2, 3, 3]

[11:41] <pmurias> the most significant problem is the we would have to load a python module twice

[11:41] <pmurias> if we are doing precompilation

[11:44] <pmurias> assuming we want to import python modules at runtime

[11:44] <nine> pmurias: precompilation seems to be a difficult topic anyway. AFAIU I'd actually have to serialize the Python interpreter's (or Perl5 in case of Inline::Perl5) whole state to allow for precompiling modules that use Inline::Python and run Python code at compile time.

[11:47] <pmurias> that seems problematic

[11:48] <pmurias> but it would be great to have 'use Foo:from<python>' work at some point

[11:48] <Timbus> m: say [1,2,3].map: { $^a, $^a }

[11:48] <camelia> rakudo-moar 80b912: OUTPUT«1 1 2 2 3 3␤»

[11:48] <nine> Is 'use Foo::from<>' implemented at all in Rakudo?

[11:49] <moritz> nine: I'm pretty usre that's how java interop is done

[11:49] <nine> I would love to play with that mechanism and see how far I come.

[11:50] <pmurias> the precompilation barrier seems hard

[11:50] <pmurias> * a hard problem

[11:53] <pmurias> one possible solution would be to just create the python interpreter twice, at first just look what the python modules contain and create stubs which will then be filled at runtime

[11:54] <dalek> specs: 70fe06b | ugexe++ | S32-setting-library/IO.pod:

[11:54] <dalek> specs: deprecated IO::Spec.splitpath -> $*SPEC.splitpath

[11:54] <dalek> specs: review: https://github.com/perl6/specs/commit/70fe06b2fb

[11:54] <dalek> specs: b1c01d1 | moritz++ | S32-setting-library/IO.pod:

[11:54] <dalek> specs: Merge pull request #78 from ugexe/master

[11:54] <dalek> specs: 

[11:54] <dalek> specs: deprecated IO::Spec.splitpath -> $*SPEC.splitpath

[11:54] <dalek> specs: review: https://github.com/perl6/specs/commit/b1c01d1ab9

[11:54] <nine> Dill also provides the capability to: save and load python interpreter sessions

[11:54] <Timbus> m: my $a = [1]; $a ,= 2;

[11:55] <camelia> rakudo-moar 80b912: ( no output )

[11:55] <Timbus> okay. guess i gotta update

[11:57] <moritz> ok, perl6/doc has a slight problem

[11:57] <moritz> we have types int and Int

[11:58] <moritz> if I check in a file lib/type/int.pod alongside lib/type/Int.pm

[11:58] <pmurias> nine: doing that with perl5 would be more problematic

[11:58] <moritz> people on case-insensitive file systems would be unable to work with it anymore

[11:59] <pmurias> serializing an open socket wouldn't be easy

[12:00] <Timbus> m: my $a = [1]; say $a ,= 2;

[12:00] <camelia> rakudo-moar 80b912: OUTPUT«Memory allocation failed; could not allocate 174080 bytes␤»

[12:00] <Timbus> well okay

[12:04] <nine> pmurias: before starting any work into that direction, we should think about real use cases for this functionality. I guess serializing open sockets is not possible with plain vanilla Perl 6 modules either. Precompilation is just about saving load time after all.

[12:08] <dalek> doc: a6c6eb2 | moritz++ | lib/Type/Int.pod:

[12:08] <dalek> doc: document Int.lsb and .msb

[12:08] <dalek> doc: review: https://github.com/perl6/doc/commit/a6c6eb2452

[12:09] <pmurias> Perl 6 modules are written with precompilation in mind, Perl 5 aren't

[12:09] <nine> Perl 6 modules may be written with precompilation in mind, Perl 5 can't.

[12:11] <pmurias> and the python ones also assume that they are loaded at runtime

[12:11] <nine> Authors with a Perl 5 background like me will not write modules with precompilation in mind until they are first bitten by precomp problems. And maybe not even then (again like me).

[12:12] <pmurias> currently the way modules are loaded in rakudo sucks

[12:13] <pmurias> but things will be precompiled automatically in the future

[12:13] <nine> I cannot even find anything about precompilation in the synopsis.

[12:15] <pmurias> with our current compilation speed we are heavily dependent on precompilation

[12:16] *** FROGGS joined
[12:16] <pmurias> by precompilation I mean compiling things in a different process then the thing that uses them

[12:17] <nine> My current takeaway from this discussion is: avoid running Python/Perl5 code at compile time at any cost.

[12:18] <pmurias> that seems like a sane strategy

[12:18] *** kjs_ joined
[12:18] <nine> Then I already have to thank you for bringing this to my attention when I can still do something about it :)

[12:21] <pmurias> is it common for python modules to have side effects at load time?

[12:22] <nine> I actually don't know. I'm actually not that familiar with the Python ecosystem.

[12:23] <dalek> roast: d3aa62b | usev6++ | S03-metaops/cross.t:

[12:23] <dalek> roast: Add tests for RT #120973

[12:23] <dalek> roast: review: https://github.com/perl6/roast/commit/d3aa62b272

[12:23] <synopsebot> Link: https://rt.perl.org/rt3//Public/Bug/Display.html?id=120973

[12:25] *** KCL joined
[12:27] <moritz> $ panda install Pod::To::HTML

[12:27] <moritz> Segmentation fault (core dumped)

[12:27] *** KCL_ left
[12:27] <moritz> guess I should rebootstrap...

[12:28] <pmurias> nine: we could also load stuff with require

[12:36] <pmurias> with something like: require Term::ANSIColor:from<perl5> <RED RESET>; say RED, "Hi", RESET;

[12:37] *** kjs_ left
[12:39] *** kjs_ joined
[12:42] *** BenGoldberg joined
[12:42] <nine> That may be the best solution, yes.

[12:52] *** kaleem left
[12:52] *** kaleem joined
[12:55] *** BenGoldberg left
[13:06] *** colomon left
[13:06] <FROGGS> is it more like:  require Term::ANSIColor:from<Perl5> <&RED &RESET>; say RED, "Hi", RESET;  ?

[13:07] *** kjs_ left
[13:08] *** colomon joined
[13:09] <nine> FROGGS: I'm not sure about that. I could pass on the <RED RESET> to $p5.use(...) unmodified. I'll have to figure out what the exported symbols are without the help of the importer anyway since I also want to support default exports.

[13:10] <dalek> roast: a3669d5 | usev6++ | S02-types/hash.t:

[13:10] <dalek> roast: Add tests for RT #77504

[13:10] <synopsebot> Link: https://rt.perl.org/rt3//Public/Bug/Display.html?id=77504

[13:10] <dalek> roast: review: https://github.com/perl6/roast/commit/a3669d54c5

[13:11] <FROGGS> nine: seems like S11 also states that the & is not needed

[13:13] *** kjs_ joined
[13:13] *** pecastro joined
[13:14] <dalek> doc: 8500a6c | moritz++ | htmlify.p6:

[13:14] <dalek> doc: htmlify: include methods from roles that were provided by roles

[13:14] <dalek> doc: 

[13:14] <dalek> doc: closes #37

[13:14] <dalek> doc: review: https://github.com/perl6/doc/commit/8500a6c8e4

[13:17] *** colomon left
[13:18] *** pecastro left
[13:23] <dalek> roast: 0e35f65 | lizmat++ | S03-metaops/ (3 files):

[13:23] <dalek> roast: Unfudge now passing tests related to #77114

[13:23] <synopsebot> Link: https://rt.perl.org/rt3//Public/Bug/Display.html?id=77114

[13:23] <dalek> roast: review: https://github.com/perl6/roast/commit/0e35f659ea

[13:27] *** jluis left
[13:43] *** kaare__ left
[13:55] <pmurias> FROGGS: the synopsis doesn't use the &

[13:55] <FROGGS> pmurias: exactly

[13:56] <pmurias> can we export/import classes in Perl6?

[13:56] <FROGGS> yes, using the 'is export' trait for example... IIRC NativeCall does that

[13:58] <dalek> doc: 8983621 | moritz++ | lib/Perl6/TypeGraph/Viz.pm:

[13:58] <dalek> doc: htmlify: Use FreeSans for SVG; Closes #9

[13:58] <dalek> doc: review: https://github.com/perl6/doc/commit/8983621293

[13:58] *** psch joined
[13:59] <pmurias> is that anywhere in the spec?

[13:59] <psch> hi #perl6 \o

[13:59] <pmurias> hi

[14:00] *** colomon joined
[14:01] <psch> S11:Exportation

[14:01] <synopsebot> Link: http://perlcabal.org/syn/S11.html#Exportation

[14:01] <psch> oh, that's not explicitly about classes

[14:01] <lizmat> pmurias: why would you want to export a class ?

[14:02] <moritz> why not?

[14:02] <lizmat> loading a module with a class already exposes it in the scope you do the -use- in

[14:02] <moritz> that S11 link has an example for exporting an enum

[14:02] <moritz> lizmat: unless it's a lexical scope

[14:02] <moritz> there's nothing wrong with keeping classes lexical, and exporting them

[14:03] <pmurias> how can you import them using require?

[14:03] <lizmat> feels like an "our" vs "my" argument here, and I'm not seeing why I would want to use "our" here

[14:03] <pmurias> require Foo <foo> import &foo

[14:03] *** kaleem left
[14:05] <moritz> pmurias: IMHO it would make sense to 'require Foo <&foo>' to import &foo

[14:05] <moritz> pmurias: exactly so that non-sigiled thingies (constants, terms,types) can be imported

[14:17] *** kaleem joined
[14:19] *** gtodd joined
[14:32] *** kjs_ left
[14:35] *** KCL left
[14:37] *** [Sno] left
[14:37] *** kjs_ joined
[14:44] *** xfix is now known as ZoruaTrainer

[14:44] *** ZoruaTrainer left
[14:51] *** kaare__ joined
[14:51] *** kjs_ left
[14:52] *** rurban joined
[14:55] *** kaleem left
[14:59] *** Ven joined
[15:01] *** kjs_ joined
[15:04] <dalek> rakudo/nom: 250c988 | lizmat++ | src/core/CompUnitRepo.pm:

[15:04] <dalek> rakudo/nom: Introduce CREATE-INCLUDE-SPEC helper sub

[15:04] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/250c988078

[15:04] <dalek> rakudo/nom: 83dedd5 | lizmat++ | t/01-sanity/52-parse-include-spec.t:

[15:04] <dalek> rakudo/nom: Make sure we sanity test CREATE-INCLUDE-SPEC

[15:04] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/83dedd5a66

[15:06] *** millican joined
[15:07] *** denis_boyun joined
[15:09] *** kjs_ left
[15:17] *** raiph joined
[15:19] *** kjs_ joined
[15:26] *** kjs_ left
[15:27] *** sirdancealot joined
[15:30] *** kjs_ joined
[15:33] <dalek> specs: ff72f24 | lizmat++ | S22-package-format.pod:

[15:33] <dalek> specs: Some elaboration:

[15:33] <dalek> specs: 

[15:33] <dalek> specs: - CompUnitRepo.parse-spec's functionality is now an implementation detail

[15:33] <dalek> specs: - Spec CompUnit.precomp method

[15:33] <dalek> specs: review: https://github.com/perl6/specs/commit/ff72f24506

[15:37] *** pecastro joined
[15:37] <psch> $ ./perl6  -e'module Foo { enum Bar is export (a => 1) }; import Foo; say a'

[15:37] <psch> a

[15:37] <psch> that's re #111512

[15:37] <synopsebot> Link: https://rt.perl.org/rt3//Public/Bug/Display.html?id=111512

[15:38] <psch> although i think there's probably a better way to do it than i'm doing it, which is "if we have $<trait><trait_mod><longname> eq 'export' call its .ast for the value object and put the key as :SYMBOL"

[15:38] <psch> https://gist.github.com/peschwa/4bfa8a5610b7b7488ef7

[15:39] <psch> i was thinking if enums can somehow know they have to export their keys and values, but i don't think i know how that works :)

[15:39] <psch> s/works/would work/

[15:43] *** virtualsue left
[15:46] *** kjs_ left
[15:47] *** kjs_ joined
[15:50] *** virtualsue joined
[15:51] *** pecastro left
[15:58] *** rurban left
[16:00] *** adu joined
[16:02] *** kjs_ left
[16:04] <dalek> rakudo/nom: 33f7ab3 | lizmat++ | src/core/Inc.pm:

[16:04] <dalek> rakudo/nom: We can't take all params here

[16:04] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/33f7ab3047

[16:07] *** millican left
[16:14] *** virtualsue left
[16:17] *** kjs_ joined
[16:22] *** virtualsue joined
[16:30] *** kaleem joined
[16:36] *** kaleem left
[16:42] <dalek> rakudo/nom: e9a9724 | moritz++ | src/core/Metamodel/Primitives.pm:

[16:42] <dalek> rakudo/nom: Metamodel::Primitives: use P6opaque as default representation

[16:42] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/e9a972437d

[16:48] <psch> where should jvm interop tests go?  i've cleaned up my nqp and rakudo branches to look presentable, but they should definitely have tests before i PR them i'd say...

[16:48] <lizmat> .tell jnthn is it correct that we cannot serialize any Lock objects 

[16:48] <yoleaux> lizmat: I'll pass your message to jnthn.

[16:48] <moritz> psch: imho into t/ somewhere in rakudo

[16:49] <moritz> psch: possibly in a new subdirectory, and the Makefile-JVM.in modified so that 'make test-j' runs them

[16:49] <moritz> or j-test

[16:49] <moritz> or whatever I called it

[16:49] <lizmat> .tell jnthn if not, is that an omission?  or is that something we Just Cannot Do™

[16:49] <yoleaux> lizmat: I'll pass your message to jnthn.

[16:50] <psch> moritz: alright.  i'll add 03-jvm and add a few interop tests

[16:50] <moritz> psch++

[16:54] <dalek> rakudo/nom: 003b358 | lizmat++ | src/core/CompUnit.pm:

[16:54] <dalek> rakudo/nom: Allow specification of @*INC in CompUnit.precomp

[16:54] <dalek> rakudo/nom: 

[16:54] <dalek> rakudo/nom: By default, CompUnit.precomp will now *only* use whatever is in @*INC (by

[16:54] <dalek> rakudo/nom: default) to set up the @*INC in the external process doing the precompilation.

[16:54] <dalek> rakudo/nom: 

[16:54] <dalek> rakudo/nom: This actually breaks a few spectests (and actually passes a todo test), but

[16:54] <dalek> rakudo/nom: does not break panda (mostly because it doesn't use .precomp yet).  Hopefully

[16:54] <dalek> rakudo/nom: this will make it easier to trace some hard to find precomp related bugs and

[16:54] <dalek> rakudo/nom: other oddness.  If not, then please revert this one.

[16:54] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/003b35850d

[16:56] <dalek> doc: cbc03bc | moritz++ | lib/Type/Metamodel/Primitives.pod:

[16:56] <dalek> doc: document Metamodel.::Primitives

[16:56] <dalek> doc: review: https://github.com/perl6/doc/commit/cbc03bc39a

[16:56] <moritz> oops, typo in commit message

[16:57] <lizmat> too bad  :-)

[16:58] *** zakharyas left
[16:58] <moritz> review of these docs would be very welcome; I'm not sure I understand the thiings I documented :-)

[17:04] *** kjs_ left
[17:06] <dalek> doc: c8a6bc0 | lizmat++ | lib/Type/Metamodel/Primitives.pod:

[17:06] <dalek> doc: Fix some typos

[17:06] <dalek> doc: review: https://github.com/perl6/doc/commit/c8a6bc0c56

[17:06] <lizmat> moritz: sorry, can't help more than that :-(

[17:08] <lizmat> dinner&

[17:11] <TimToady> pjablons: we do have Xxx already, at least

[17:11] <TimToady> m: say <a b c> Xxx 1,2,3

[17:11] <camelia> rakudo-moar 80b912: OUTPUT«a a a a a a b b b b b b c c c c c c␤»

[17:11] <TimToady> m: .say for <a b c> Xxx 1,2,3

[17:11] <camelia> rakudo-moar 80b912: OUTPUT«a␤a␤a␤a␤a␤a␤b␤b␤b␤b␤b␤b␤c␤c␤c␤c␤c␤c␤»

[17:11] <TimToady> hmm

[17:12] <TimToady> m: (<a b c> Xxx 1,2,3).perl.say

[17:12] <camelia> rakudo-moar 80b912: OUTPUT«(("a",), ("a", "a"), ("a", "a", "a"), ("b",), ("b", "b"), ("b", "b", "b"), ("c",), ("c", "c"), ("c", "c", "c")).list␤»

[17:12] <TimToady> there we go

[17:14] <moritz> m: (<a b c> Zxx 1,2,3).perl.say

[17:14] <camelia> rakudo-moar 80b912: OUTPUT«(("a",), ("b", "b"), ("c", "c", "c")).list␤»

[17:15] *** kjs_ joined
[17:18] <psch> m: sub infix:<zz>(&lhs, $rhs) { sleep $rhs; lhs }; ({ say "a" }, { say "b" }, { say "c" }) Zzz (1, 2, 3) # scnr

[17:18] <camelia> rakudo-moar 80b912: OUTPUT«a␤b␤c␤»

[17:18] <psch> although i suppose infix:<zZz> looks better

[17:19] <moritz> m: sub infix:<zz>(&lhs, $rhs) { Promise.in($rhs).then({ ; lhs }) }; await ({ say "a" }, { say "b" }, { say "c" }) Zzz (3, 2, 1)

[17:19] <camelia> rakudo-moar 80b912: OUTPUT«c␤b␤a␤»

[17:19] <psch> aah, .then it was

[17:19] <psch> i was trying it with .in().start

[17:20] * moritz is now #perl6[TM] Certified Sleep-Sort Expert[R][TM]

[17:21] * TimToady doubts that, due the absence of Unicode there

[17:21] *** denis_boyun left
[17:21] <TimToady> well, I guess that's Unicode too, technically

[17:22] * masak .oO( 😴 )

[17:22] <moritz> s:g/'[TM]'/™/

[17:23] <moritz> s:g/'[R]'/®/

[17:24] <TimToady> the Texas version of that is Ⓡ

[17:25] <masak> or the IKEA version: R ⃝

[17:26] <TimToady> .oO(falls apart easily?)

[17:32] *** LLamaRider left
[17:39] <moritz> left to your own assembly

[17:41] <hoelzro> good morning, #perl6

[17:42] *** Hor|zon left
[17:49] <moritz> \o hoelzro 

[17:52] <hoelzro> I had a thought (well, a few, actually) over the last few days about earliest { ... }, and I wanted to post them here for some feedback

[17:53] *** pecastro joined
[17:53] <hoelzro> first of all, is there any reason that earliest and friends are limited to operating on Channels? I was thinking something like earliest * { more $socket { ... } ; more $channel { ... } } could be of use, since sockets also have a notion of being done, and receiving more information

[17:53] *** Alina-malina joined
[17:54] <hoelzro> second, I was thinking about the implementation of earliest, and how for multiple channels, it currently uses busy waiting; I was thinking of adding a new NQP op to make things more efficient, and wanted to see if others had thoughts on the matter

[17:54] *** pmurias left
[17:55] <moritz> hoelzro: IMHO earliest could work on Promise/Channel/Supply, and we should have a Socket -> Supply (or Channel) bridge

[17:56] <moritz> (becuase they have a very well-defined notion of "value available", and the Socket -> Supply bridge could define what counts as a value)

[17:56] <moritz> I can't comment on your second thought

[17:57] *** denis_boyun_ joined
[17:57] <hoelzro> moritz: that's true, but my concern with that is that if a thread is reading from a socket to pump values into a channel/supply/etc, another thread might be trying to write to that socket, for example, when a message is received from a channel

[17:57] <hoelzro> and I think thread safety of socket operations is OS dependent

[17:58] <hoelzro> you would definitely have to define what a "next value" of a socket is, though, yes

[18:01] <moritz> hoelzro: well, the solution for thread safety thing is to have an owning thread, and communicate with that thread in some thread-safe manner

[18:02] <hoelzro> right

[18:02] <hoelzro> so let's say I have an owning thread that manages my socket

[18:02] <moritz> hoelzro: and if we don't have the primitives yet for doing that, we need to create them

[18:03] <hoelzro> my thread has two tasks: read bytes from the socket, parse them into protocol-specific packets, and send those along a Supply

[18:03] <moritz> or our high-level socket wrappers must do the locking

[18:03] <hoelzro> the second task is to accept packets from another Channel and send them along the socket

[18:04] *** denis_boyun_ left
[18:04] <hoelzro> so my thread needs to block until data are available on the socket, or on the channel

[18:04] <hoelzro> so my idea for earliest accomplishes that, but there may be a better, "sixier" way

[18:04] *** pecastro left
[18:05] <hoelzro> moritz: I think, at least on MoarVM, the sockets are locked, because I can't write to a socket I'm trying to read from

[18:07] *** isBEKaml joined
[18:10] <moritz> hoelzro: maybe there should be an async-write which queues writes until the lock from reading is available

[18:11] <hoelzro> ah, but the protocol I'm implementing (XMPP) expects a write at the beginning before sending any more data from the server, so that would deadlock, I think

[18:12] *** FROGGS_ joined
[18:15] *** Sqirrel left
[18:15] *** FROGGS left
[18:20] <moritz> then you shouldn't try to read before writing

[18:22] <hoelzro> so right now I have a stanzas method, which returns a lazy list of stanza objects parsed from reads from the server

[18:22] <hoelzro> another thread is reading stanzas from that list, and is determining what stanza to send next to the server

[18:23] <hoelzro> if I wanted to prevent reading until writes are sent, I would have to wait for each stanza to be "handled" by invokers of stanzas

[18:23] <hoelzro> so it seems that perhaps my design is flawed

[18:24] *** LLamaRider joined
[18:25] *** Sqirrel joined
[18:27] *** rindolf left
[18:27] *** jack_rabbit joined
[18:31] *** raiph left
[18:32] *** colomon left
[18:32] *** raiph joined
[18:33] *** colomon joined
[18:34] *** klaas_ joined
[18:37] *** klaas_ left
[18:39] *** Hor|zon joined
[18:44] *** Hor|zon left
[18:46] *** isBEKaml left
[18:52] *** pecastro joined
[18:57] *** colomon left
[19:01] *** colomon joined
[19:03] *** pecastro left
[19:10] <moritz> hoelzro: I think exposing stanzas as a lazy list is dangerous, because it loses the information of which ones are read, and which ones aren't yet

[19:18] *** kjs_ left
[19:25] *** perl007 joined
[19:25] <perl007> qq

[19:31] *** kjs_ joined
[19:31] <perl007> say [or](<asd, asd, asdasd> >>eq>> 'asd');

[19:31] <perl007>  does it short circuit? other/better ways to check the presence?

[19:31] *** colomon left
[19:32] <perl007> more like, when it short circuits

[19:32] <psch> perl007: <[or] @list 

[19:33] *** Hor|zon joined
[19:33] <psch> err

[19:33] <psch> perl007: [or] @list means @list[0] or @list[1] .. @list[*-1] 

[19:33] <psch> as you know 

[19:33] <psch> i don't think it can shortcircuit, as in "not call eq"

[19:34] <psch> m: sub asd { say $++; "asd" }; say asdf { say $++; "asdf" }; say [or] (asd, asd, asdf, asdf >>eq>> "asd")

[19:34] <camelia> rakudo-moar 80b912: OUTPUT«===SORRY!=== Error while compiling /tmp/3POaO0hQ3J␤Preceding context expects a term, but found infix >>eq>> instead␤at /tmp/3POaO0hQ3J:1␤------> }; say [or] (asd, asd, asdf, asdf >>eq>>⏏ "asd")␤»

[19:34] <psch> m: sub asd { say $++; "asd" }; say asdf { say $++; "asdf" }; say [or] ((asd, asd, asdf, asdf) >>eq>> "asd")

[19:34] <camelia> rakudo-moar 80b912: OUTPUT«===SORRY!=== Error while compiling /tmp/0AYIIRrImb␤Undeclared routine:␤    asdf used at line 1. Did you mean 'asd'?␤␤»

[19:34] <psch> m: sub asd { say $++; "asd" }; sub asdf { say $++; "asdf" }; say [or] ((asd, asd, asdf, asdf) >>eq>> "asd")

[19:34] <camelia> rakudo-moar 80b912: OUTPUT«0␤1␤0␤1␤True␤»

[19:35] <psch> m: sub asd { say "asd " ~ $++; "asd" }; sub asdf { say "asdf " ~ $++; "asdf" }; say [or] ((asd, asd, asdf, asdf) >>eq>> "asd") # clearer

[19:35] <camelia> rakudo-moar 80b912: OUTPUT«asd 0␤asd 1␤asdf 0␤asdf 1␤True␤»

[19:36] <avuserow> m: say <asd asd asdasd> ~~ 'asd' # not sure if this shortcircuits

[19:36] <camelia> rakudo-moar 80b912: OUTPUT«False␤»

[19:36] <avuserow> or works apparently.

[19:37] <psch> avuserow: that's List ~~ String

[19:37] *** kjs__ joined
[19:37] *** kjs_ left
[19:37] *** kjs__ is now known as kjs_

[19:38] *** denis_boyun_ joined
[19:39] <psch> m: say so <asd asd asdasd>.Bag<asd>; # checks presence.  applicability depends on context

[19:39] <camelia> rakudo-moar 80b912: OUTPUT«True␤»

[19:40] <psch> actually, disregard the sub example above.  i'm not concentrated enough :)

[19:41] <psch> it increments the state because the lhs has to get a value first before it gets hypered with eq

[19:42] *** colomon joined
[19:42] *** kjs_ left
[19:42] <psch> this could maybe be tested with gather/take, but i'm unsure how .elems on a lazy list works, i.e. if it reifies 

[19:43] *** virtualsue left
[19:45] <colomon> yes, it has to reify in the general case

[19:45] <colomon> (maybe always, I dunno)

[19:47] <Ven> perl007: looks like you're looking for any() :)

[19:48] <Ven> psch: any() is far better here, and should short-circuit

[19:48] *** anaeem1 joined
[19:48] <ugexe> is there a general consensus on naming modules with .pm vs .pm6? I notice rakudos Inc::make-cur only checks for '.pm'

[19:51] <perl007> thanks

[19:55] <psch> Ven: oh, right.  any() actually does what's wanted.  .Bag just has the side effect of checking for presence...

[19:56] <japhb> m: say 'asd' (elem) <asd asd asdasd>;

[19:56] <camelia> rakudo-moar 80b912: OUTPUT«True␤»

[19:56] <japhb> psch: ^^

[19:57] <psch> japhb++ 

[19:57] <psch> setops exist as well

[19:57] <Ven> m: say any(<asd asd asdasd>) eq 'asd' # :P

[19:57] <camelia> rakudo-moar 80b912: OUTPUT«any(True, True, False)␤»

[20:09] *** mvuets left
[20:10] *** telex left
[20:12] *** telex joined
[20:18] *** leonid left
[20:22] *** anaeem1 left
[20:24] *** pizza joined
[20:24] *** anaeem1_ joined
[20:26] *** pizza left
[20:26] *** darutoko left
[20:30] *** denis_boyun_ left
[20:31] *** colomon left
[20:34] *** colomon joined
[20:35] *** flussence joined
[20:40] *** sqirrel_ joined
[20:43] <lizmat> ugexe: regarding checking for .pm: good spot

[20:43] <lizmat> but that's only for loading a non-standard CompUnitRepo module

[20:48] *** rurban joined
[20:49] <dalek> rakudo/nom: 5058ff8 | lizmat++ | t/01-sanity/52-parse-include-spec.t:

[20:49] <dalek> rakudo/nom: Make sure we don't fudge sanity test by accident

[20:49] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/5058ff87d0

[20:53] *** araujo joined
[20:55] *** adu left
[20:56] <ugexe> lizmat++ for latest precomp commit... dont have to work on this pr anymore :)

[20:56] <lizmat> :-)

[20:57] <lizmat> it's still not working like it should, though  :-(

[20:57] <lizmat> at least not on OS X

[20:58] *** Vlavv joined
[21:05] <ugexe> :delete'ing after precomp caught me off guard for doing something like something like: sub pc(*@modules) { CompUnit.new($_.path).precomp for @modules }; { temp %*ENV<RAKUDO_PRECOMP_WITH> = "$*CWD/lib"; pc('A.pm', 'B.pm'); }

[21:06] <ugexe> i.e. $*CWD/lib is not in @INC for B.pm's precomp

[21:07] <lizmat> ugexe: you should be able to pass the INC that you want using the :INC named param

[21:08] <lizmat> and also: there are still dragons there  :-(

[21:08] <lizmat> thanks for also looking at this  :-)

[21:12] <psch> maybe TDD isn't that great of an idea - as soon as i start writing tests i find all kinds of bugs!

[21:12] <psch> more seriously: i'm stuck with True and False specifically

[21:13] *** LLamaRider left
[21:14] <lizmat> you need a http://en.wikipedia.org/wiki/Ternary_computer

[21:14] <psch> trying to differentiate between a type object and True or False on the java side seems not-quite-possible.  Ops.istype doesn't work 'cause it sees the boxed java type, and Ops.istrue and Ops.isfalse evaluate as bool...

[21:15] <psch> lizmat: maybe, yes.  i'm afraid i'd just add another not-working case though :)

[21:15] <psch> maybe i just did something wrong with istype...

[21:16] <dalek> roast: 4247b62 | lizmat++ | S22-package-format/local.t:

[21:16] <dalek> roast: Make tests more robust and fudge failing subtest

[21:16] <dalek> roast: review: https://github.com/perl6/roast/commit/4247b62fb6

[21:18] *** raiph left
[21:38] <lizmat> $ perl6 --ll-exception -It/spec/packages -e 'CompUnit.new("t/spec/packages/Example/A.pm").precomp.say'

[21:38] <lizmat> Missing serialize REPR function for REPR ReentrantMutex

[21:39] <lizmat> finally golfed the problem down to a one liner

[21:40] <lizmat> this is regardless of whether there is a precomped C.pm or not

[21:40] <ugexe> i was getting that ReentrantMutex error earlier

[21:40] <lizmat> the only thing with a ReentrantMutex REPR is Lock.pm

[21:41] *** virtualsue joined
[21:41] <lizmat> on Parrot (which does not have Lock.pm really, it's an empty class there)

[21:42] *** pecastro joined
[21:42] <lizmat> it states: $ perl6-p --ll-exception -It/spec/packages -e 'CompUnit.new("t/spec/packages/Example/A.pm").precomp.say'

[21:42] <lizmat> Could not find Example::C in any of: /Users/liz/Github/rakudo.parrot/install/lib/6.10.0-devel/languages/perl6/lib, /Users/liz/Github/rakudo.parrot/install/lib/6.10.0-devel/languages/perl6

[21:43] <lizmat> which is odd, as apparently the -It/spec/packages is *not* on @*INC there

[21:43] <ugexe> yeah same deal here. its not finding the required modules in @*INC (even though @*INC has the proper path) because it installs some modules but not others

[21:45] <lizmat> however, checking @*INC[0], t/spec/packages *is* there

[21:46] <ugexe> fwiw it happens if i dont use rakudo_precomp_with and use %*ENV<PERL6LIB> directly

[21:46] <ugexe> as well

[22:04] <dalek> roast: 3391c81 | lizmat++ | S22-package-format/local.t:

[22:04] <dalek> roast: Remove deprecations

[22:04] <dalek> roast: review: https://github.com/perl6/roast/commit/3391c81708

[22:07] *** LLamaRider joined
[22:09] <lizmat> ugexe: ok, got a little further: the error occurs when *deserializing* C.pm

[22:10] <lizmat> I found out when I had a .moarvm around from another perl6 build

[22:10] *** pecastro left
[22:10] <lizmat> it failed with missing or wrong dependency then

[22:11] <lizmat> hmmm...?  there is no compiled version for C.pm now, and it still fails with missing REPR ?

[22:13] *** sqirrel_ left
[22:16] <ugexe> from what im seeing it *might* be related to roles. i say this because in a folder with multiple modules the only one it ends up compiling *doesnt* load any roles

[22:17] <ugexe> then again it could just be a 'use' problem i suppose and they just all happen be be roles

[22:17] <lizmat> you mean the usage of roles in the modules being compiled?

[22:17] <lizmat> ah, yes

[22:17] <lizmat> .oO( must read more carefully )

[22:18] <lizmat> ugexe: that one module, does it have any 'use' command in it ?

[22:18] <ugexe> no

[22:19] <ugexe> and in a subfolder of *that* all of the modules get compiled (no 'use' statements) and in another subfolder they all fail (all have a 'use' statement)

[22:19] <lizmat> I think *that* is the deciding factor  :-)

[22:20] <ugexe> yeah, getting ahead of myself heh

[22:22] *** raiph joined
[22:27] <lizmat> .tell jnthn perl6 --ll-exception -e 'CompUnit.new("t/spec/packages/Example/A.pm").precomp' fails with 'Missing serialize REPR function for REPR ReentrantMutex' on Moar

[22:27] <yoleaux> lizmat: I'll pass your message to jnthn.

[22:27] <lizmat> .tell jnthn I would expected it to fail with Could not find Example::C in any of: ....     Any ideas?

[22:27] <yoleaux> lizmat: I'll pass your message to jnthn.

[22:30] <dalek> rakudo/nom: e12b86b | lizmat++ | src/core/CompUnitRepo/Locally.pm:

[22:30] <dalek> rakudo/nom: Make .gist and .perl better

[22:30] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/e12b86b107

[22:30] *** LLamaRider left
[22:34] <lizmat> the plot thickens: on the JVM, if C.pm is not precomped, it correctly fails with:

[22:34] <lizmat> When pre-compiling a module, its dependencies must be pre-compiled first.

[22:34] <lizmat> Please pre-compile /Users/liz/Github/rakudo.jvm/t/spec/packages/Example/C.pm

[22:35] <lizmat> after having precomped C.pm on JVM, trying to precomp A.pm fails with Missing serialize function for REPR ReentrantMutex

[22:37] <lizmat> on parrot it works

[22:38] <lizmat> so I guess we somehow have a live Lock object that is serialized, but cannot be deserialized

[22:38] *** pmqs_ joined
[22:40] * lizmat is tired

[22:40] <lizmat> sleep&

[22:40] <ugexe> i tried manually pushing each sub directory to @*INC and instead of reentrantmutex error it says 'no such short-id for invocant type str'

[22:40] <lizmat> you should 'use lib'

[22:41] <lizmat> pushing strings to @*INC is another of those things that will break (or already break)

[22:41] <lizmat> really sleep&

[22:42] *** Rounin left
[22:44] *** [Sno] joined
[22:44] <ugexe> ah, yea, back to reentrantmutex

[22:51] *** sirdancealot left
[22:53] *** colomon left
[22:55] *** colomon joined
[22:59] *** raiph left
[23:02] *** adu joined
[23:03] *** raiph joined
[23:29] *** ggoebel111111117 joined
[23:36] *** kaare__ left
[23:46] *** rurban left
[23:49] *** virtualsue left
[23:52] *** anaeem1_ left
