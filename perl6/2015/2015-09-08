[00:00] *** BenGoldberg joined
[00:02] *** cognominal left
[00:04] *** leont left
[00:04] <dalek> rakudo-star-daily: 2aa91d2 | coke++ | log/ (8 files):

[00:04] <dalek> rakudo-star-daily: today (automated commit)

[00:04] <dalek> rakudo-star-daily: review: https://github.com/coke/rakudo-star-daily/commit/2aa91d28a9

[00:05] *** aborazmeh joined
[00:05] *** aborazmeh left
[00:05] *** aborazmeh joined
[00:11] *** ShimmerFairy left
[00:12] *** n0tjack joined
[00:22] *** n0tjack left
[00:25] *** ShimmerFairy joined
[00:36] *** Skarsnik left
[00:39] *** laouji left
[00:40] *** laouji joined
[00:41] *** laouji left
[00:41] *** laouji joined
[00:46] *** Zoffix joined
[00:50] *** tokuhiro_ joined
[00:52] <tokuhiro_> how do i pass parameters by reference with nativecall?

[00:53] <tokuhiro_> i want to write code like python's byref https://docs.python.org/2/library/ctypes.html#passing-pointers-or-passing-parameters-by-reference

[00:54] <psch> tokuhiro_: a thing that used to work is passing an Array[CPointer]

[00:55] *** rangerprice left
[00:55] <psch> tokuhiro_: but i wouldn't bet on me being up to date on current practices

[00:57] <ugexe> CArray[OpaquePointer]

[00:57] <psch> .tell FROGGS your patch and the result makes me thing the jvm build is due to some oversight in the Binder, though i haven't found a place to place a BP to gain more insight, just fyi

[00:57] <yoleaux> psch: I'll pass your message to FROGGS.

[00:57] <psch> ugexe++: right, that was probably it, thanks

[00:58] <tokuhiro_> thanks. i'll try it

[01:00] *** lizmat joined
[01:04] *** lizmat left
[01:15] *** n0tjack joined
[01:23] *** n0tjack left
[01:24] *** aborazmeh left
[01:38] <labster> m: my $t1 = now; for ^1000 { <1/65536>.perl }; $t1 = now - $t1;  my $t2 = now; for ^1000 { <1/65537>.perl }; $t2 = now - $t2; say "<1/65537> is {sprintf("%.2f", $t1/$t2)} times faster than <1/65536>";

[01:38] <camelia> rakudo-moar 16d366: OUTPUT«<1/65537> is 16.32 times faster than <1/65536>␤»

[01:43] <timotimo> m: say <1/65536>.perl; say <1/65537>.perl

[01:43] <camelia> rakudo-moar 16d366: OUTPUT«0.000015␤<1/65537>␤»

[01:44] <timotimo> wow, is our algorithm to turn it into a decimal really that bad?

[01:44] <labster> yeah, it's pretty awful.  It's looping on $!denominator %% 2

[01:45] <timotimo> oh

[01:45] <timotimo> so it's basically O(number of 1 bits in denom)?

[01:45] <labster> Yes.  But then after all of that work, Rational.Str doesn't know how to handle it anyway.

[01:46] <timotimo> right, it fails to find something good

[01:46] <timotimo> and finding out it'd not work does the maximum amount of work first

[01:46] <timotimo> perhaps we can count the number of bits set up front and decide based on that that we'd end up bailing out anyway?

[01:46] <labster> no, it finds out it will work incorrectly

[01:48] <labster> I'm tempted to try with base 10 instead of 2 and 5, it might actually work.

[01:48] <timotimo> er, right

[01:49] <labster> Mainly because Rational.Str rounds at min($denominator.chars + 1, 6)

[01:50] <labster> er, max().  Not written like that anyway

[01:51] <timotimo> i'm not familiar with the code, actually, so i was just hoping i could inspire you to build something %)

[01:51] <timotimo> but you already had that in mind

[01:55] <labster> I'm inspired to build, just don't know what to build :P

[01:56] <timotimo> are you "limited" to the rat-to-string thing in this desire/inspiration?

[02:03] *** noganex_ joined
[02:05] *** dayangkun joined
[02:08] *** FROGGS joined
[02:19] *** FROGGS left
[02:22] *** AlexDaniel left
[02:28] *** lea joined
[02:31] *** ab5tract_ joined
[02:32] <labster> timotimo: I think my imagination is less limited after dinner

[02:33] * timotimo is very late for bedtime :|

[02:35] *** yqt left
[02:36] *** ab5tract_ left
[02:41] <dalek> specs: 653f803 | skids++ | S32-setting-library/Containers.pod:

[02:41] <dalek> specs: Adjust some prototypes to post-GLR implementation state.

[02:41] <dalek> specs: 

[02:41] <dalek> specs: Also, write better natural-language descriptions of some methods, since the

[02:41] <dalek> specs: pseudocode had gone stale anyway.

[02:41] <dalek> specs: 

[02:41] <dalek> specs: Remove map(*) as it was removed during GLR.

[02:41] <dalek> specs: 

[02:41] <dalek> specs: Grammar and whitespace cleanups

[02:41] <dalek> specs: 

[02:41] <dalek> specs: Still much work to do on S32, and sub-style slurpies have yet to be changed.

[02:41] <dalek> specs: review: https://github.com/perl6/specs/commit/653f80355f

[02:48] * TimToady --> airport &

[02:58] *** n0tjack joined
[03:03] *** n0tjack left
[03:04] *** kaare_ joined
[03:07] *** dayangkun left
[03:12] *** dayangkun joined
[03:42] *** n0tjack joined
[03:47] *** n0tjack left
[03:50] *** laouji left
[04:29] *** khw left
[04:35] *** FROGGS joined
[04:38] *** laouji joined
[04:44] <moritz> .oO( TimToady returns an airport )

[04:45] <moritz> good morning *

[04:45] *** FROGGS left
[04:51] *** BenGoldberg left
[04:52] *** aborazmeh joined
[04:52] *** aborazmeh left
[04:52] *** aborazmeh joined
[04:52] *** FROGGS joined
[04:53] *** xinming left
[04:54] *** xinming joined
[04:57] <tadzik> g'morning moritz 

[04:57] <yoleaux> 7 Sep 2015 22:18Z <mohij> tadzik: I'm more or less done with putting *env functionality into rakudobrew. Most commands work including local, global and shell switching.

[04:57] <yoleaux> 7 Sep 2015 22:19Z <mohij> tadzik: I have only tested on linux so far. Will do some Windows testing soon. What do you think about merging?

[04:57] <yoleaux> 7 Sep 2015 22:20Z <mohij> tadzik: Tradeoff: Slight startup time decrease because the shims are perl and not bash anymore.

[04:58] *** diana_olhovik_ joined
[04:58] *** laouji left
[04:59] *** laouji joined
[05:01] <tadzik> .tell mohij I'd be delighted :) Can you send me a PR?

[05:01] <yoleaux> tadzik: I'll pass your message to mohij.

[05:01] <tadzik> thanks yolo

[05:03] <FROGGS[mobile]> tadzik: there is also a message by moritz in the clogs

[05:03] *** diana_olhovik___ joined
[05:04] <tadzik> oh

[05:04] *** diana_olhovik_ left
[05:06] <tadzik> FROGGS[mobile]: I don't see it

[05:06] <FROGGS[mobile]> something about rakudobrew

[05:07] <moritz> unlikely

[05:07] <FROGGS> tadzik: ups, wasnt moritz: http://irclog.perlgeek.de/perl6/2015-09-07#i_11181969

[05:07] <yoleaux> 00:57Z <psch> FROGGS: your patch and the result makes me thing the jvm build is due to some oversight in the Binder, though i haven't found a place to place a BP to gain more insight, just fyi

[05:07] <FROGGS> tadzik: and now I also see that mohij did send it again properly

[05:08] <FROGGS> sorry, still being asleep obviously

[05:08] <FROGGS> .tell psch thanks for the hint... now I just need to figure out what that means :o)

[05:08] <yoleaux> FROGGS: I'll pass your message to psch.

[05:11] *** diana_olhovik___ left
[05:13] <moritz> iirc jnthn++ fixed some binder things in JVM

[05:22] <ShimmerFairy> Yeah, I last saw jnthn mention that his JVM hacking should make finding the build issue less scary now for others, or something to that effect :)

[05:29] *** quester joined
[05:29] *** quester left
[05:29] *** quester joined
[05:29] *** [Sno] joined
[05:31] <quester> m: my @a="i i", "j j"; my @b = @a, "k k", "l l", "m m"; say @b.perl

[05:31] <camelia> rakudo-moar 16d366: OUTPUT«[["i i", "j j"], "k k", "l l", "m m"]␤»

[05:31] <quester> m: my @a="i i", "j j"; my @b = | @a, "k k", "l l", "m m"; say @b.perl

[05:31] <camelia> rakudo-moar 16d366: OUTPUT«["i i", "j j", "k k", "l l", "m m"]␤»

[05:35] <quester> I'm fairly impressed... I have about 180 lines of perl6 code written six months ago for $work, and the only thing that the GLR broke was the declaration of a list of keywords.  Kudos to everyone involved, jnthn++ in particular.

[05:36] <quester> Oh, and TimToady++ of course.

[05:40] <tadzik> yay, another production perl 6 :)

[05:42] *** dayangkun left
[05:43] *** dayangkun joined
[05:44] *** dayangkun left
[05:45] *** dayangkun joined
[05:45] *** dayangkun left
[05:47] *** dayangkun joined
[05:49] *** n0tjack joined
[05:51] *** domidumont joined
[05:53] *** laouji left
[05:53] *** n0tjack left
[05:55] *** domidumont left
[05:56] *** domidumont joined
[05:58] *** laouji joined
[05:58] *** laouji left
[05:59] *** laouji joined
[06:14] *** araujo left
[06:15] *** araujo joined
[06:16] *** araujo left
[06:17] *** araujo joined
[06:18] *** CQ joined
[06:24] *** FROGGS left
[06:24] <tadzik> https://gist.github.com/anonymous/c1b0012f2dd4d3e4ca0e

[06:24] <tadzik> ...huh?

[06:24] <tadzik> the :in(True) is the offender

[06:25] <tadzik> for some reason

[06:35] <FROGGS[mobile]> tadzik: what should it do instead? block for input?

[06:46] *** laouji left
[06:46] <tadzik> FROGGS[mobile]: I guess so

[06:46] <tadzik> not bail out would be a good start :)

[06:46] *** laouji joined
[06:47] <tadzik> I mean, it's a minimized test case from a code that launches dmenu, writes to its input and reads from its output

[06:47] <tadzik> this is the simplest I could come up with that reacts the same way

[06:48] *** FROGGS joined
[06:49] *** rurban joined
[06:49] *** Ven joined
[06:50] <FROGGS> tadzik: that script does not fail for me

[06:51] *** FROGGS[mobile] left
[06:56] *** leont joined
[06:59] *** laouji left
[07:00] *** laouji joined
[07:10] *** ab5tract_ joined
[07:12] *** leont left
[07:18] *** rurban left
[07:18] *** Loren joined
[07:19] <masak> morning, #perl6

[07:19] <FROGGS> morning masak 

[07:20] <Loren> morning & afternoon.

[07:20] *** darutoko joined
[07:21] <masak> Loren: afternoon, Loren of .cn

[07:21] <Loren> haha..

[07:24] <Loren> m: class Line { has $!value; method get-value() { return $!value; } } my Line $line; say $line.perl; say $line.get-value();

[07:24] <camelia> rakudo-moar 16d366: OUTPUT«5===SORRY!5=== Error while compiling /tmp/yvjh0B5Asv␤Strange text after block (missing semicolon or comma?)␤at /tmp/yvjh0B5Asv:1␤------> 3method get-value() { return $!value; } }7⏏5 my Line $line; say $line.perl; say $lin␤    expecting an…»

[07:27] <Loren> why '$line' can access $!value ? In my perl6 it print 'Cannot look up attributes in a type object'.

[07:27] <FROGGS> m: class Line { has $!value; method get-value() { return $!value; } }; my Line $line; say $line.perl; say $line.get-value();

[07:27] <camelia> rakudo-moar 16d366: OUTPUT«Line␤Cannot look up attributes in a type object␤  in method get-value at /tmp/IcjD82gF79:1␤  in block <unit> at /tmp/IcjD82gF79:1␤␤»

[07:28] <FROGGS> m: class Line { has $!value; method get-value() { return $!value; } }; my Line $line; say $line.perl; say try $line.get-value(); say try $line.new.get-value();

[07:28] <camelia> rakudo-moar 16d366: OUTPUT«Line␤Nil␤(Any)␤»

[07:28] <FROGGS> Loren: attributes are to be used with class instances, so you need to instantiate first

[07:29] <Loren> so the 'prototype-based OO programming' is not support now ?

[07:30] <moritz> you can have class attributes too

[07:31] <FROGGS> m: class Line { my $value; method get-value() { return $value; } } my Line $line; say $line.perl; say $line.get-value();

[07:31] <camelia> rakudo-moar 16d366: OUTPUT«5===SORRY!5=== Error while compiling /tmp/exnwBEQ45H␤Strange text after block (missing semicolon or comma?)␤at /tmp/exnwBEQ45H:1␤------> 3 method get-value() { return $value; } }7⏏5 my Line $line; say $line.perl; say $lin␤    expecting an…»

[07:31] <FROGGS> m: class Line { my $value; method get-value() { return $value; } }; my Line $line; say $line.perl; say $line.get-value();

[07:31] <camelia> rakudo-moar 16d366: OUTPUT«Line␤(Any)␤»

[07:31] <FROGGS> m: class Line { my $value = 42; method get-value() { return $value; } }; my Line $line; say $line.perl; say $line.get-value();

[07:31] <camelia> rakudo-moar 16d366: OUTPUT«Line␤42␤»

[07:31] <moritz> Loren: there's not much support for prototype-based programming in Perl 6; but the meta object protocol is powerful enough that you could well implement it on your own

[07:31] <Loren> camelia, thks 

[07:32] *** ab5tract_ left
[07:32] <Loren> moritz,  thks, now i know.

[07:33] *** zakharyas joined
[07:35] * moritz hasn't the slightest idea why people would favor prototype-based OO

[07:36] *** Sqirrel left
[07:36] *** Sqirrel_ joined
[07:36] <Loren> It seems like better than 'class-based'.

[07:37] <ShimmerFairy> moritz: I'm looking now, and I'm not sure I get what it even is.

[07:38] <masak> ShimmerFairy: may I recommend Steve Yegge's blog post on the matter?

[07:38] <moritz> Loren: better in what way?

[07:38] <ShimmerFairy> masak: sure :)

[07:38] <masak> moritz: it's not clear to me where protoype-based OO shines. I can use it, but it feels neither better nor worse than class inheritance.

[07:39] <moritz> masak: my impression was that most JS OO patterns revolve around emulating class-based OO

[07:39] <masak> only about half of them.

[07:39] <masak> moritz: nowadays when I write stuff in JavaScript, I tend to favor things like Object.extend when creating objects. kind of leaning towards mixins.

[07:39] <ShimmerFairy> masak: from what I've seen so far, Perl 6 makes the issues supposedly solved by prototype-based OO a non-issue (but to be fair I'm not sure I get it yet)

[07:40] <moritz> ... and about another quarter evolve around the absence of block scoping

[07:40] <Loren> moritz, May be less coding work

[07:40] <moritz> Loren: I haven't seen any evidence (or even examples) that support this claim

[07:41] <masak> ShimmerFairy: http://steve-yegge.blogspot.se/2008/10/universal-design-pattern.html 

[07:42] <masak> moritz: no, I meant that about half of the JS code I see that uses OO, seems to want to first build an insulation layer of class-based OO on top of the prototype system.

[07:42] <masak> moritz: I take it to be mostly an unwillingness to adapt to prototype-based OO, and a belief that class-based OO works better for what they want to do.

[07:43] *** skids left
[07:43] <moritz> masak: I think there's a real lack of educational material on how to design software with prototype-based OO

[07:43] <masak> and while I personally don't have an urge to layer class-based OO on top of what JS already has, I can kind of sympathise with the instinct to put something familiar in place of something unfamiliar.

[07:44] <masak> moritz: yes, that's part of why I like Yegge's post.

[07:44] <masak> it's definitely a different mode of thinking. in many cases, things get slightly easier.

[07:44] <ShimmerFairy> "it's not especially well liked as an academic topic. This is because OO design has no real mathematical foundation to support it"  oh no. the horror. save me. aaah.

[07:45] <masak> but (as @getify points out), the really treacherous thing is that class inheritance is fundamentally based on *copying* whereas prototype OO is fundamentally based on *linking*.

[07:45] <Loren>   it's very convenient in sometimes

[07:45] <masak> ShimmerFairy: I could imagine a world where OO had a solid theoretical foundation. I wouldn't mind that.

[07:46] <ShimmerFairy> masak: I'm just pointing out that I don't care for the mathematical view on programming. Knuth's DLX paper was the best thing I found on DLX, but that's in spite of the mathematical notation, and if I ever write about NFAs I'll stay clear from the utterly useless mathematical definition and jargon :)

[07:46] <masak> ShimmerFairy: I couldn't disagree more.

[07:47] <masak> it's far too easy to bash theory, not knowing or caring what it has done for computing.

[07:48] <masak> on the other hand, the fact that people can use all the fruits of theoretical work and be *oblivious* is also a kind of strength, I guess.

[07:48] <ShimmerFairy> masak: I know the mathy bits are important, but for someone like me, I know programming through programming, not through math; mathematical notation and jargon when describing computer concepts is more than unhelpful to me.

[07:49] <moritz> masak: I agree with your on the importance of mathematics; I also agree with ShimmerFairy that many theory articles could benefit from less jargon/notation

[07:49] <masak> fair enough.

[07:50] <masak> sometimes it seems that some articles introduce jargon/notation for the *authors*, not for the *readers*

[07:50] <masak> it's kind of the same issue as with readable source code

[07:50] <ShimmerFairy> On the subject of NFAs, it's looking at diagrams and reading through walkthroughs of them that helped me get a grip on them, not this "five-tuple" crap :P

[07:51] *** leont joined
[07:51] *** n0tjack joined
[07:53] <moritz> ShimmerFairy: a good theory teaches both

[07:54] <moritz> ShimmerFairy: try writing a sound proof while talking about walking through diagrams...

[07:54] <masak> it's also a matter of what level you're getting in on. a really soft and furry tutorial will help a beginner. the five-tuple crap helps me, because I have a bit of math background already.

[07:54] <ShimmerFairy> moritz: my main problem with mathematically-bent computer articles is that I'm looking up stuff so I know how to code it, and the mathematical view on programming is just about the most unhelpful thing in the world for that goal (for me at least). I need discussion with snippets of code, not with obscure mathematical expressions.

[07:55] <moritz> ShimmerFairy: so you should be looking for cookbooks, not theory articles

[07:55] <masak> I agree with moritz that it's probably about most theory being presented badly.

[07:55] <nine> I think, I'll rather read the book the blog post mentioned. Cannot be that much longer anyway. (Hint: if you have trouble with your blog posts becoming too long, don't repeat yourself endlessly and don't write about how your blog posts become too long...)

[07:55] <masak> this is especially clear when reading academics who can write, such as SPJ or Eric Meier.

[07:55] *** n0tjack left
[07:56] <ShimmerFairy> moritz: when trying to look up NFAs and DFAs for learning regexes, I only found math-based articles. It seemed like no-one can resist the high-level, computer science stuff :/

[07:57] <[Tux]> test             50000    53.736    53.653

[07:57] <[Tux]> test-t           50000    55.116    55.032

[07:58] <moritz> ShimmerFairy: have you read "Mastering Regular Expressions" by Friedl?

[07:59] <ShimmerFairy> If it's a book, then I surely haven't :)

[07:59] *** espadrine joined
[07:59] <moritz> well, it's rather good for learning regexes :-)

[07:59] <masak> ShimmerFairy: it's a bit like saying "when I tried to learn French, people kept bothering me with details about syntax and grammar :/"

[07:59] <moritz> and yes, it's a book

[07:59] <masak> "I don't want to learn grammar, I just want to learn French!"

[08:00] <ShimmerFairy> masak: well, the issue is that I don't know computer science math at all. I want to learn how regexes work, not the entire foundational base of CS math :)

[08:00] <Loren> I don't want to learn En grammar, i just want to learn english.

[08:00] <masak> Loren: :D

[08:01] <Loren> masak, :p

[08:01] <masak> well, I wish you both the best of luck. (meant non-ironically.)

[08:01] <nine> masak: the irony is, that you don't actually have to know Grammar to learn a language. I know practically no rules for English grammar, I just happen to have read enough English to get it right intuitively most of the time.

[08:02] <masak> nine: I know, I know.

[08:02] <nine> Though I somtimes wish, I knew more :)

[08:02] <masak> of course you can learn a language without ever talking about its grammar. and of course many people do that, every day.

[08:02] <masak> kind of a "learning by attrition".

[08:03] <grondilu> yes but language teacher must justify their job.  If people were learning languages as toddlers do, there would be no need for teachers.

[08:03] <masak> "grammar" was never a bad word to me. but at some point I realized that it was a bad word for others, kind of like "math", because they didn't see the point of it and it was just random rules to them.

[08:03] <nine> Well knowing the rules can greatly speed up the process.

[08:04] <masak> the reason we talk so much about grammar is that it's an unparalleled way to structure ideas about language and structures.

[08:04] <masak> just like math is.

[08:04] <ShimmerFairy> masak: I think I'd like it if CS math was written and talked about in terms of programming languages; I can't help but think traditional mathematical notation/jargon is completely inappropriate for programming :)

[08:04] <TEttinger> ShimmerFairy: ... what's hard about five-tuple? are non-native english speakers expected to know every prefix for triplet, quartet, quintet, sextet, septet, etc.?

[08:05] <ShimmerFairy> TEttinger: it's not the word, but the thing itself (which I couldn't be bothered to find back)

[08:05] <TEttinger> tuple?

[08:05] <nine> You can learn a language's grammar by reading hundreds of books and watching TV for thousands of hours, or you can learn it by studying a grammar book. Of course latter is less entertaining, but definitely quicker.

[08:06] <ShimmerFairy> TEttinger: no, the actual 5-tuple that's discussed when it comes to NFA/DFA

[08:06] <TEttinger> oh

[08:06] *** lizmat joined
[08:06] *** ab5tract_ joined
[08:07] <masak> TEttinger: it's kind of a thing with five entries that completely describe an NFA.

[08:07] <ShimmerFairy> "NFAs can be described by this five-tuple"    ok yes but what _is_ an NFA, actually?

[08:07] <TEttinger> ahhhh

[08:07] <masak> ShimmerFairy: yes, it sounds to me that you've been starting at the wrong entry level.

[08:07] <masak> reading Wikipedia, perhaps :)

[08:07] <ShimmerFairy> masak: and every other webpage I could find on the subject, yes :)

[08:08] <masak> at this point, you should stop, take stock, and find a better source text.

[08:08] <TEttinger> but what _is_ a ShimmerFairy? a collection of molecules? a collection of subatomic particles that make up molecules? magic?

[08:08] <nine> Definitely magic

[08:08] <masak> I would second moritz++' book recommendation.

[08:08] <ShimmerFairy> Yeah, too bad it looks like I'd have to buy the book though :/  (to my non-surprise, my county's library system doesn't have it)

[08:08] <masak> TEttinger: it's a 2-tuple of a fairy, and shimmer.

[08:09] <masak> ShimmerFairy: another sure-fire way to understand regexes is to re-implement a grammar engine in Perl 6. worked for me.

[08:09] <TEttinger> at this point I like to recommend people to sit in on philosophy courses at an early college level and just watch as people either completely don't get it or get their minds blown

[08:09] <nine> ShimmerFairy: the irony is that you throw around words like "allomorphic" which I've never heard in > 20 years of programming and sound very mathy to me ;)

[08:10] <masak> heh

[08:10] <ShimmerFairy> nine: to be fair, I didn't come up with the term :P

[08:10] <masak> I'm wary of allomorphic things. not because of the term itself, but what the term *means*.

[08:11] <TEttinger> I'm wary of allosaurs

[08:11] <TEttinger> which I assume are allomorphic

[08:11] <masak> almost certainly.

[08:11] <ShimmerFairy> And I do enjoy math quite a bit (I've looked up some statistics so I can calculate if benchmark timing differences are "statistically significant", for example). Just not the CS math. Never got into it, and I don't see how it could help me with my actual coding

[08:12] <TEttinger> ShimmerFairy, yeah, for the most part I'm the same way

[08:12] <TEttinger> I enjoy "rediscovering" basic math stuff... since I've done it on math tests for some time :)

[08:13] *** dakkar joined
[08:13] <TEttinger> "oh crap what's the formula for x-distance of a point on the unit sphere... uh... pythagoras, I choose you!"

[08:13] <ShimmerFairy> masak: funny thing is, I was looking up this stuff to reason about possibly implementing a P6 grammar engine :P  (because I'd like to implement an emacs major mode for Perl 6, and I'd like to have a Real Parser™ to figure out P6 files)

[08:14] <masak> ShimmerFairy: it may even help you to study the commit history of GGE.

[08:14] <tadzik> FROGGS: huh, very weird

[08:14] <masak> ShimmerFairy: it starts very simply (and test-based) and gets more advanced as it goes.

[08:14] <ShimmerFairy> The main problem with emacs' default facilities, btw, seems to be that there's no (easy?) way to provide context to them.

[08:16] <masak> ShimmerFairy: things like this: https://github.com/masak/gge/commit/8f5369564b9f51897920deb8983461f9b691f007

[08:16] <TEttinger> this is about the extent of technical papers that I can follow, and thankfully it's rather computer-not-science-y in terms of the operations it describes: http://www.pcg-random.org/paper.html

[08:16] <masak> (just an example)

[08:16] <TEttinger> (absolutely great idea for an RNG, btw)

[08:17] <lizmat> commute some further, Basque country, here we come!  &

[08:17] *** lizmat left
[08:17] <ShimmerFairy> masak: I'll be sure to keep the book and GGE in mind whenever I revisit the topic :)

[08:17] <masak> :)

[08:18] <ShimmerFairy> Also, emacs' regexps are absolutely horrible, so there's also incentive to write a parser for the kind of regexes that aren't mind-numbing :P

[08:24] *** laouji left
[08:25] <_itz> magala airport was flooded yesterday with many cancelled flights but we managed to escape

[08:26] <tokuhiro_> how do i call c function has varargs like printf with NativeCall?

[08:27] *** abraxxa joined
[08:28] <FROGGS> tokuhiro_: you don't (yet) :o(

[08:28] <tokuhiro_> :(

[08:28] <FROGGS> tokuhiro_: but you are welcome to help implementing that

[08:29] <FROGGS> tokuhiro_: the backends we use (dyncall / libffi) support that

[08:29] <FROGGS> tokuhiro_: we just don't make use of that currently

[08:29] <tokuhiro_> FROGGS: i see

[08:31] *** laouji joined
[08:32] <ShimmerFairy> masak: also, that Yegge post is quite long, so I'll have to read it in-between doing other stuff :) . But from what I've seen from everything so far, I can't help but wonder if prototype-based OO would be a fit for implementing an MDL compiler (there was a mention of Lisp, I saw, so maybe)

[08:37] *** aborazmeh left
[08:39] *** pmurias joined
[08:42] <BooK> just wondering: is there a Perl6 lib for OAUTH yet?

[08:43] <ShimmerFairy> Haven't heard of one, but I don't keep track of modules that well :) try  modules.perl6.org  and see if something's there

[08:44] <pmurias> do the CREDITS in nqp get updated? the tests seem to use that file

[08:45] <pmurias> not sure how much can I assume about that file when writing tests?

[08:45] <FROGGS> pmurias: well, we would recognize test failures after updating it... and we really do not touch that file often

[08:45] <FROGGS> I mean, it is three years old now

[08:45] <nine> BooK: or use one of the Perl 5 OAUTH modules

[08:46] <mrf> nine++ # Inline all the things

[08:46] <FROGGS> Inline::COBOL /o/

[08:46] <mrf> NO!

[08:47] * mrf would be happy if he never has to see COBOL again.

[08:48] <FROGGS> :D

[08:49] <ShimmerFairy> I wonder if S05 should have an operator precedence table like S03 does  (right now I want to know if [a | b || c] means [ [a | b] || c ])

[08:49] *** leont left
[08:50] *** pmurias left
[08:51] *** Ven left
[08:52] *** Ven joined
[08:53] *** laouji left
[08:56] *** Ven left
[08:58] <FROGGS> tokuhiro_: fwiw, I'd be happy to work on varargs (with you or alone) after I got C++ support merged after the JVM build is healthy again...

[08:59] *** laouji joined
[09:00] <labster> Can someone tell me if this commit is a good idea?  https://github.com/labster/rakudo/commit/c39ea77b7ab235b671e596498dd80634cd25f794  I'm trying to fix Rat.perl doing too much rounding.

[09:00] <labster> m: say <1/128> == <1/128>.perl.EVAL

[09:00] <camelia> rakudo-moar 16d366: OUTPUT«False␤»

[09:02] <tokuhiro_> FROGGS: i want to implement it but i don't have knowledge around it :(

[09:05] <FROGGS> tokuhiro_: well, that's what collab is for :o)

[09:06] *** laouji left
[09:06] <tokuhiro_> :)

[09:06] <FROGGS> we can learn it together

[09:06] *** laouji joined
[09:06] <tokuhiro_> yep

[09:15] *** pmurias joined
[09:17] <dalek> nqp/js: 7844967 | (Pawel Murias)++ | / (4 files):

[09:17] <dalek> nqp/js: Implement nqp::setinputlinesep.

[09:17] <dalek> nqp/js: 

[09:17] <dalek> nqp/js: Test that it works with a input separator consisting of two characters.

[09:17] <dalek> nqp/js: review: https://github.com/perl6/nqp/commit/7844967412

[09:17] <dalek> nqp/js: 77d3834 | (Pawel Murias)++ | src/vm/js/bin/run_tests:

[09:17] <dalek> nqp/js: Add passing test 19 to run_tests.

[09:17] <dalek> nqp/js: review: https://github.com/perl6/nqp/commit/77d3834e18

[09:22] *** abraxxa left
[09:22] *** abraxxa joined
[09:25] *** ab5tract_ left
[09:25] *** ab5tract_ joined
[09:25] <ab5tract_> o/ #perl6

[09:26] *** cognominal joined
[09:28] <ab5tract_> .tell nine I should have clarified further that my "sets are hashes, mmkay" feeling is deeply related to only ever using hashes for sets. This is surely a Perl-ish attitude. Anyway, I totally support efforts to make sets feel more natural to the people who actually have strong opinions about them

[09:28] <yoleaux> ab5tract_: I'll pass your message to nine.

[09:34] <pmurias>  ab5tract_ \o

[09:34] <psch> hi #perl6 o/

[09:34] <yoleaux> 05:08Z <FROGGS> psch: thanks for the hint... now I just need to figure out what that means :o)

[09:37] <psch> FROGGS: well, the dispatch for postcircumfix:<{ }> seems to hit the candidate in src/core/hash_slice.pm:49, whereas it probably should hit the "is parcel" one in line 12 of the same file

[09:38] *** quester left
[09:40] <psch> FROGGS: although maybe $tag is to blame after all, i haven't look in that direction

[09:41] <FROGGS> psch: $tag or rather @tags is to blame

[09:42] <FROGGS> psch: I can potentially explain it in more detail this evening

[09:48] *** TEttinger left
[09:50] *** rmgk left
[09:51] *** rmgk joined
[09:54] *** abraxxa left
[09:59] <ab5tract_> psch: wouldn't the fact that parcel has been removed invalidate the is parcel candidate?

[10:03] *** rindolf joined
[10:03] <psch> ab5tract_: we still have a parcel trait_mod

[10:03] <psch> Parcel has been removed

[10:04] <psch> FROGGS: fair enough, i have a tendency to blame nqp-j in general, because i can't shake the feeling that something in there must be somhow wrong - probably mostly because of its slowness... :)

[10:05] <FROGGS> psch: no, it is not just the slowness...

[10:11] *** laouji left
[10:14] <jnthn> "is parcel" is the name of the trait that maps to \foo in a sig

[10:14] <jnthn> We probably should rename it at some point :)

[10:14] <jnthn> But since you always express it as \foo it's not high priority

[10:15] <FROGGS> jnthn: btw, what's your feeling of that line:

[10:15] <FROGGS>     my int $SIG_ELEM_SLURPY              := ($SIG_ELEM_SLURPY_POS +| SIG_ELEM_SLURPY_NAMED +| $SIG_ELEM_SLURPY_LOL);

[10:15] * FROGGS .oO( We need more dollars, dollars, dollars... )

[10:15] <jnthn> Where is it? :)

[10:15] <FROGGS> BOOTSTRAP.nqp:99

[10:15] <jnthn> Also, I think it's missing a $ :)

[10:16] <FROGGS> aye :o)

[10:16] <jnthn> Curious how little it breaks ;)

[10:16] *** laouji joined
[10:16] <jnthn> Maybe we don't need the SIG_ELEM_SLURPY_NAMED in there at all?

[10:16] <jnthn> If nothing's broken I'd just remote that :)

[10:16] <jnthn> *remove

[10:19] *** rarara joined
[10:19] <FROGGS> lunch &

[10:20] <JimmyZ>   we have method pop(Array:D:) is parcel 

[10:20] <JimmyZ> Does it mean return  \foo?

[10:21] <jnthn> Well, means "return exactly what is returned"

[10:21] <psch> named params also need the trait.  i also agree that renaming might be a good idea, but don't have a suggestion for the new name

[10:21] <jnthn> Aye

[10:21] <jnthn> Me either

[10:21] <jnthn> "is raw" is a bit undescriptive

[10:21] * jnthn won't worry about it much for now :)

[10:25] *** xfix joined
[10:25] <ShimmerFairy> "is noncont[ainerized]" ? :P

[10:25] <JimmyZ> is original :P

[10:26] <jnthn> is not-screwed-with

[10:27] <nine> If I had known that there is such a trait, I'd not have had to fix those Pair creation bugs...

[10:27] <yoleaux> 09:28Z <ab5tract_> nine: I should have clarified further that my "sets are hashes, mmkay" feeling is deeply related to only ever using hashes for sets. This is surely a Perl-ish attitude. Anyway, I totally support efforts to make sets feel more natural to the people who actually have strong opinions about them

[10:27] <nine> It's probably a good thing that I didn't know then ;)

[10:29] *** abraxxa joined
[10:30] <abraxxa> FROGGS: hi! I'm working on DBDish::Oracle again and wonder if there where NativeCall improvements in the last few releases?

[10:30] *** virtualsue joined
[10:36] *** andreoss joined
[10:37] <dalek> rakudo/nom: b6d3180 | jnthn++ | src/core/ (2 files):

[10:37] <dalek> rakudo/nom: A couple of exception types for shaped arrays.

[10:37] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/b6d318069f

[10:37] <dalek> rakudo/nom: 2f06734 | jnthn++ | src/core/Array.pm:

[10:37] <dalek> rakudo/nom: Add default shape method for unshaped Array.

[10:37] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/2f06734a69

[10:37] <dalek> rakudo/nom: 1f3372e | jnthn++ | src/core/Array.pm:

[10:37] <dalek> rakudo/nom: Take (but currently ignore) shape in Array.new.

[10:37] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/1f3372e057

[10:38] <nine> Oh, shaped arrays almost done?

[10:38] *** pat_js joined
[10:39] *** dayangkun left
[10:39] <jnthn> Well, the VM guts are almost done ;)

[10:39] <jnthn> Working on the Perl 6 level now

[10:40] *** pmurias left
[10:40] <nine> Well I usually consider work that's been started as almost done...so jay shaped arrays! And yes, I'm an optimist ;)

[10:41] <jnthn> During GLR when I re-did the [;] slicing stuff I did it in a way that makes shaped arrays easier

[10:41] *** pmurias joined
[10:41] <jnthn> Or paved the way for them

[10:41] <jnthn> So, now to try and write up all the pieces. :)

[10:41] <jnthn> *wire

[10:42] <nine> Yeah, I had a hunch that it's good that you tackled the slicing parts

[10:42] <ab5tract_> much excitement!

[10:44] *** n0tjack joined
[10:44] <baest> jnthn: very nice!

[10:45] *** virtualsue left
[10:50] *** n0tjack left
[10:51] *** telex left
[10:52] *** telex joined
[10:55] <_itz> ok >GLR has is-lazy .. is there a simple way of doing that with pre GLR code?

[10:56] <jnthn> _itz: .infinite may approximate it, though it's different

[10:56] <_itz> ok ty 

[10:56] <jnthn> perl6-m -e "my @a := Array.new(:shape(5)); @a[5] = 42;"

[10:56] <jnthn> Index 5 for dimension 1 out of range (must be 0..4) in block <unit> at -e:1

[10:56] <jnthn> Progress :)

[10:59] *** brrt joined
[11:00] <dalek> nqp: 64a0872 | jnthn++ | src/vm/jvm/runtime/org/perl6/nqp/sixmodel/reprs/MultiDimArrayInstanceBase.java:

[11:00] <dalek> nqp: Fix off-by-one in error reporting.

[11:00] <dalek> nqp: review: https://github.com/perl6/nqp/commit/64a087242b

[11:01] <dalek> rakudo/nom: cbf85b3 | jnthn++ | src/core/Array.pm:

[11:01] <dalek> rakudo/nom: First steps for shaped arrays.

[11:01] <dalek> rakudo/nom: 

[11:01] <dalek> rakudo/nom: No multi-dim indexing support yet, but Array.new(:shape(5)) will now

[11:01] <dalek> rakudo/nom: enforce the fixed size.

[11:01] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/cbf85b3df3

[11:02] <jnthn> Apparently it's time to eat lunch :)

[11:02] <jnthn> bbiab

[11:07] *** laouji left
[11:09] *** Skarsnik joined
[11:10] *** Loren left
[11:11] <psch> m: my $s = (:types, :DEFAULT); my @a = flat "ALL", $s>>.key(); say @a.perl

[11:11] <camelia> rakudo-moar cbf85b: OUTPUT«["ALL", "types", "DEFAULT"]␤»

[11:11] <psch> $ ./perl6-j -e'my $s = (:types, :DEFAULT); my @a = flat "ALL", $s>>.key(); say @a.perl'

[11:11] <psch> ["ALL", ("types", "DEFAULT")]

[11:11] <psch> /o\

[11:14] <TimToady> sitting in Oslo, 4 hour delay... :/

[11:14] <moritz> Oslo is nice. Gardemoen not so much :=)

[11:15] *** Possum joined
[11:18] *** dpk joined
[11:23] *** Sqirrel joined
[11:23] *** Sqirrel_ left
[11:26] <dalek> nqp/js: 52d13fe | (Pawel Murias)++ | / (4 files):

[11:26] <dalek> nqp/js: Preprocess regex tests (as we can't easily compile them at runtime before the bootstrap).

[11:26] <dalek> nqp/js: 

[11:26] <dalek> nqp/js: For now pass rx_basic.

[11:26] <dalek> nqp/js: review: https://github.com/perl6/nqp/commit/52d13fe404

[11:27] *** Loren joined
[11:28] <jnthn> TimToady: Aww :(

[11:28] <jnthn> And Malaga - Oslo can't have been short...

[11:30] <moritz> 4h, maybe?

[11:30] <TimToady> a bit more

[11:30] <TimToady> but we had a headwind

[11:31] <FROGGS> abraxxa: I think there were some improvements... the docs/Changelog will tell

[11:31] <oetiker> jnthn did you find the fondue in olten ?

[11:31] <abraxxa> FROGGS: in which repo? I always fail to find the correct one on github

[11:32] <FROGGS> abraxxa: https://github.com/rakudo/rakudo/blob/nom/docs/ChangeLog

[11:32] <abraxxa> FROGGS: thanks

[11:33] <jnthn> oetiker: Yes, we did! :)

[11:33] <oetiker> \o/

[11:33] <abraxxa> why does rakudobrew not list 2015.08?

[11:34] <jnthn> oetiker: Thanks for the tip...it was a really rather nice one. :-)

[11:34] <jnthn> oetiker: We managed to get a nice table outside also.

[11:34] <nine> abraxxa: we didn't do a release in August

[11:34] <oetiker> beautiful :-)

[11:34] <jnthn> abraxxa: There was no 2015.08.

[11:35] <abraxxa> jnthn: the rakudo ChangeLog has an entry and I saw the tag

[11:35] <abraxxa> so only a rakudo release but no moar release?

[11:35] <jnthn> oetiker: Indeed. :)

[11:36] *** brrt left
[11:36] <jnthn> abraxxa: Don't think there was a Rakudo release actually cut/uploaded anywhere either.

[11:37] <moritz> abraxxa: there's no rakudo 2015.08 tag

[11:37] <moritz> abraxxa: changelog yes, because I started the release process

[11:37] *** dustinm` left
[11:37] <jnthn> abraxxa: http://www.nntp.perl.org/group/perl.perl6.compiler/2015/09/msg11182.html

[11:38] <abraxxa> the MoarVM repo has a 2015.08 tag

[11:38] <abraxxa> i saw it when rakudobrew updated the git repos

[11:38] <jnthn> I think there maybe was a MoarVM release.

[11:38] <jnthn> Though not sure the site got updated yet

[11:39] <abraxxa> no problem, thanks

[11:39] <jnthn> Seems timotimo++ tagged it

[11:39] <jnthn> timotimo: Did you by any chance make a Moar 2015.08 tarball?

[11:40] <[Coke]> TEttinger++

[11:41] *** Urchin joined
[11:45] <[Coke]>  1,038 RTs

[11:46] <[Coke]> (14 GLR tickets still open)

[11:47] *** n0tjack joined
[11:49] *** dustinm` joined
[11:51] *** n0tjack left
[11:54] *** pmurias left
[11:58] <TimToady> m: say 0.91723840987192374893723.perl.EVAL

[11:58] <camelia> rakudo-moar cbf85b: OUTPUT«===SORRY!===␤Cannot find method 'compile_time_value'␤»

[12:00] <[Coke]> jnthn: is updating S07 on your list before the september release?

[12:00] *** domidumont left
[12:00] <[Coke]> Be nice if we had a place to point to details about the GLR from the changelog.

[12:00] *** pmurias joined
[12:02] *** domidumont joined
[12:04] <[Coke]> (no pressure, just thought I saw you mention it this weekend)

[12:06] <andreoss> m: say 0.9999999999999999999999.perl.EVAL

[12:06] <camelia> rakudo-moar cbf85b: OUTPUT«0.1␤»

[12:08] <moritz> that's bad :(

[12:08] <moritz> m: say 0.9999999999999999999999.perl

[12:08] <camelia> rakudo-moar cbf85b: OUTPUT«0.10␤»

[12:08] <moritz> that's very bad :(

[12:09] <moritz> m: say 0.9999999999999999999999

[12:09] <camelia> rakudo-moar cbf85b: OUTPUT«0.10␤»

[12:09] <moritz> m: say 0.9999999999999999999999 - 0.1

[12:09] <camelia> rakudo-moar cbf85b: OUTPUT«0.9␤»

[12:09] <moritz> m: say 0.9999999999999999999999 - 0.9

[12:09] <camelia> rakudo-moar cbf85b: OUTPUT«0.1␤»

[12:09] <moritz> m: say 0.9999999999999999999999 - 0.9999

[12:09] <camelia> rakudo-moar cbf85b: OUTPUT«0.0001␤»

[12:10] <moritz> m: say 0.0999999999999999

[12:10] <camelia> rakudo-moar cbf85b: OUTPUT«0.0999999999999999␤»

[12:10] <moritz> m: say 0.09999999999999999999999

[12:10] <camelia> rakudo-moar cbf85b: OUTPUT«0.1␤»

[12:10] <moritz> so it's only overflow over the decimal point that results in a bad stringification

[12:14] <TimToady> exceeds 66-bit denominator, I expect

[12:15] <[Coke]> r: my Int @a=^3; @a[1]:delete; @a.map:{say .WHAT.perl }; @a[1].WHAT.perl.say

[12:15] <camelia> rakudo-jvm cbf85b: OUTPUT«Can't open perl script "/home/camelia/rakudo-inst/bin/eval-client.pl": No such file or directory␤»

[12:15] <camelia> ..rakudo-moar cbf85b: OUTPUT«Int␤Any␤Int␤Int␤»

[12:15] <moritz> m: say 0.09999999999999999999999.^name

[12:15] <camelia> rakudo-moar cbf85b: OUTPUT«Rat␤»

[12:16] <ShimmerFairy> m: say :16<0.FFFFFFFFFFFFFFF0>; say :16<0.FFFFFFFFFFFFFFF1>

[12:16] <camelia> rakudo-moar cbf85b: OUTPUT«0.99999999999999999913␤0.10␤»

[12:16] <moritz> TimToady: still a rat

[12:16] <moritz> m: say 0.9999999999999999999999.nude

[12:16] <camelia> rakudo-moar cbf85b: OUTPUT«(9999999999999999999999 10000000000000000000000)␤»

[12:16] <moritz> m: say 0.9999999999999999999999.Str

[12:16] <camelia> rakudo-moar cbf85b: OUTPUT«0.10␤»

[12:16] <moritz> it's really a bug in Rat.Str

[12:16] <ShimmerFairy> TimToady: unless I'm mistaken, doesn't Rat still have an Int denominator instead of UInt64 in rakudo's implementation?

[12:16] <TimToady> could be

[12:17] * moritz submits rakudobug

[12:17] <moritz> unless andreoss++ wants the honor, of course

[12:17] <ShimmerFairy> yeah

[12:18] <ShimmerFairy> TimToady: There is a UInt64 in rakudo, but it's defined as a subset, so I'm not sure changing Rat will actually make it any better than a FatRat atm :)

[12:18] <moritz> ShimmerFairy: it does make it better

[12:18] <ShimmerFairy> how is an Int with an extra constraint better than an Int? (Or better than a UInt64 linked to a sized native type?)

[12:19] <moritz> ShimmerFairy: it avoids quadratic runtime behavior on things like newton's algorithm converting on sqrt(2)

[12:19] <moritz> ShimmerFairy: it does overflow to Num eventually

[12:19] <moritz> m: say (1 / 2**65).^name

[12:19] <camelia> rakudo-moar cbf85b: OUTPUT«Num␤»

[12:20] <moritz> which prevents runaway numerator and denominator sizes

[12:20] <dalek> rakudo/nom: b2fea84 | coke++ | docs/ChangeLog:

[12:20] <dalek> rakudo/nom: 2015.08 was skipped.

[12:20] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/b2fea840bb

[12:20] <ShimmerFairy> moritz: true, having a sized denominator would help cap the Rat at a particular point, what I meant was that I'm not sure the current UInt64 would provide the kind of performance improvement over FatRat that's talked about

[12:21] <moritz> ShimmerFairy: it's not UInt64 that provides the performance improvement; it's the fallback to Num that does

[12:21] <hoelzro> o/ #perl6

[12:21] <yoleaux> 7 Sep 2015 11:57Z <pmurias> hoelzro: before merging in js into the master branch remember to run the tests for the jvm/moar backends to make sure our improved test suit doesn't uncover any bugs in those

[12:21] <hoelzro> pmurias: will do

[12:22] <ShimmerFairy> moritz: oh. The way the specs talked about it, it always seemed like it was the sized type itself. Either the specs need to be clarified, or I didn't read the right parts closely enough :/

[12:24] <ShimmerFairy> (that is, of what I've seen nowhere in the specs where it mentioned that FatRat was worse in performance did it mention that it was because Rat has a fallback and FatRat doesn't)

[12:24] *** [Sno] left
[12:25] <moritz> RT #126016 filed for the Rat.Str bug

[12:26] *** brrt joined
[12:26] <moritz> ShimmerFairy: http://perlpunks.de/paste/show/55eed3ed.19dd.15f newton approximation converging on sqrt(2)

[12:26] <moritz> ShimmerFairy: just run it ones as is, and once with a normal Rat as starting value

[12:28] <moritz> maybe with only 12 or 15 iterations instead of 20, if you're impatient :-)

[12:28] <literal> m: %foo<bar><baz><quux>

[12:28] <camelia> rakudo-moar cbf85b: OUTPUT«5===SORRY!5=== Error while compiling /tmp/hUvZaeU4Zo␤Variable '%foo' is not declared␤at /tmp/hUvZaeU4Zo:1␤------> 3<BOL>7⏏5%foo<bar><baz><quux>␤»

[12:28] <literal> is there a way to invoke rakudo-moar in lax mode here?

[12:29] *** [Sno] joined
[12:30] <FROGGS> m: no strict; %foo<bar><baz><quux>

[12:30] <camelia> rakudo-moar cbf85b: OUTPUT«X::Multi::NoMatch exception produced no message␤  in block <unit> at /tmp/IXpit3CwEc:1␤␤»

[12:30] <literal> I see

[12:30] <psch> m: no strict; $x = 5; say $x

[12:30] <camelia> rakudo-moar cbf85b: OUTPUT«5␤»

[12:30] <literal> and why doesn't this run? stricter autovivification?

[12:31] <psch> the failure mode for the hash access looks pretty weird

[12:31] <psch> m: no strict; %h<foo> = "bar"; say %h.perl

[12:31] <camelia> rakudo-moar cbf85b: OUTPUT«{:foo("bar")}␤»

[12:31] <psch> m: no strict; %h<foo><baz><quux> = "bar"; say %h.perl

[12:31] <camelia> rakudo-moar cbf85b: OUTPUT«X::Multi::NoMatch exception produced no message␤  in block <unit> at /tmp/UUeJyp5Tg0:1␤␤»

[12:32] <FROGGS> m: my %h; %h<foo><baz><quux> = "bar"; say %h.perl

[12:32] <camelia> rakudo-moar cbf85b: OUTPUT«{:foo(${:baz(${:quux("bar")})})}␤»

[12:32] <FROGGS> m: my %h<foo><baz><quux> = "bar"; say %h.perl

[12:32] <camelia> rakudo-moar cbf85b: OUTPUT«5===SORRY!5=== Error while compiling /tmp/eS3Q57_kdt␤Shaped variable declarations not yet implemented. Sorry. ␤at /tmp/eS3Q57_kdt:1␤------> 3my %h<foo>7⏏5<baz><quux> = "bar"; say %h.perl␤»

[12:32] <FROGGS> m: our %h<foo><baz><quux> = "bar"; say %h.perl

[12:32] <camelia> rakudo-moar cbf85b: OUTPUT«5===SORRY!5=== Error while compiling /tmp/PlQlie5e31␤Shaped variable declarations not yet implemented. Sorry. ␤at /tmp/PlQlie5e31:1␤------> 3our %h<foo>7⏏5<baz><quux> = "bar"; say %h.perl␤»

[12:33] *** bbkr_ left
[12:34] <abraxxa> http://doc.perl6.org/language/5to6 doesn't mention Perl 6s' undef equivalent

[12:35] <psch> abraxxa: "Since Perl 6 does not allow adding/removing symbols in a lexical scope once it has finished compiling, there is no equivalent to Perl 5's undef &foo;"

[12:36] <moritz> m: our %h; say %h.^name

[12:36] <camelia> rakudo-moar cbf85b: OUTPUT«Hash␤»

[12:36] <literal> psch: that's a different thing though

[12:36] <abraxxa> psch: i guess that would remove the sub foo from the symbol table in Perl 5 although I've never (ab)used it

[12:36] <abraxxa> perl6 -e 'my $foo; say $foo.perl;' returns Any

[12:37] <literal> m: @foo[0]

[12:37] <camelia> rakudo-moar cbf85b: OUTPUT«5===SORRY!5=== Error while compiling /tmp/y05Z8I4YWx␤Variable '@foo' is not declared␤at /tmp/y05Z8I4YWx:1␤------> 3<BOL>7⏏5@foo[0]␤»

[12:37] <andreoss> m: my &foo; say &foo.Perl

[12:37] <camelia> rakudo-moar cbf85b: OUTPUT«Method 'Perl' not found for invocant of class 'Callable'␤  in block <unit> at /tmp/_SG71yxh1x:1␤␤»

[12:37] <literal> m: no strict; @foo[0]

[12:37] <camelia> rakudo-moar cbf85b: ( no output )

[12:37] <andreoss> m: my &foo; say &foo.perl

[12:37] <camelia> rakudo-moar cbf85b: OUTPUT«Callable␤»

[12:37] <literal> m: no strict; @foo[0].perl

[12:37] <camelia> rakudo-moar cbf85b: ( no output )

[12:38] <literal> m: no strict; say @foo[0].perl

[12:38] <camelia> rakudo-moar cbf85b: OUTPUT«Mu␤»

[12:38] <psch> abraxxa: i take that to mean you're wondering about assignment RHS undef?  i think Nil does that in p6, but you're right that it's not mentioned

[12:38] <TimToady> m: &sleep.wrap({ die "I'm undefined" }); sleep 3

[12:38] <camelia> rakudo-moar cbf85b: OUTPUT«I'm undefined␤  in block <unit> at /tmp/AobxTMOX5Q:1␤␤»

[12:39] <abraxxa> psch: i have to compare a list of returned database values and need the Perl 6 equivalent of SQL NULL

[12:39] <literal> so why is an empty array element 'Mu' and an unassigned scalar is 'Any' ? and where would Nil come in? :P

[12:39] <abraxxa> [ Any, Any, 1 ], works

[12:40] <moritz> m: my @a; @a[3] = 1; say @a[0]

[12:40] <camelia> rakudo-moar cbf85b: OUTPUT«(Any)␤»

[12:40] <moritz> seems to be Any, not Mu

[12:40] <psch> m: no strict; @a[3] = 1; say @a[0]

[12:40] <camelia> rakudo-moar b2fea8: OUTPUT«(Mu)␤»

[12:40] <literal> I guess it's only Mu when @foo itself was not declared

[12:40] <literal> oh, or not

[12:41] <abraxxa> but isn't that just wrong when used in tests because it would allow any value instead of just undef?

[12:41] <moritz> I'd say this is a bug in 'no strict'

[12:41] <abraxxa> and isn't Any the root type and not a value?

[12:41] <moritz> abraxxa: it should test !.defined

[12:41] <moritz> abraxxa: types are also values

[12:44] <abraxxa> moritz: https://github.com/abraxxa/DBIish/blob/master/t/99-common.pl6#L159-L161

[12:44] <abraxxa> suggestions how to solve this welcome

[12:48] <moritz> abraxxa: uhm, what's the problem there?

[12:48] *** n0tjack joined
[12:48] <abraxxa> moritz: I have added rows to that table where not all columns have a value

[12:49] <abraxxa> e.g. https://github.com/abraxxa/DBIish/blob/master/t/99-common.pl6#L115

[12:49] <abraxxa> just fixing the now failing tests

[12:50] *** shinobi-cl joined
[12:52] <jdv79> .tell lizmat why doesn't S22 root a dist archive with the dist+ver like a p5 one?

[12:52] <yoleaux> jdv79: I'll pass your message to lizmat.

[12:52] *** n0tjack left
[12:54] <jdv79> FROGGS: do you know if there's a reason for that?

[12:55] <jdv79> most tarballs, p5 and not, usually have a top level dir of the same name as the file itself - at least that i've seen

[13:00] <_itz> is S07-glr-draft.pod still mostly correct?

[13:00] <FROGGS> jdv79: I did not think about that yet tbh...

[13:01] <jdv79> can we just do that then?  normally when i tar -zxvf a file i expect it to politely create one dir with all the stuff it spews

[13:01] <jdv79> is one nice feature

[13:02] <_itz> oh it still talks about Parcels

[13:02] * _itz looks confused

[13:02] <jdv79> plus if it was the same as the p5 way there is less friction/confusion - type of stuff

[13:03] <ShimmerFairy> jdv79: what are you talking about, precisely? Does P6 offer a tar-like thing or something?

[13:03] <jdv79> no

[13:04] <jdv79> perl5 distribution tarballs are of the basename $dist-$ver and they contain one subdir of that same name in which aall else is

[13:05] <jdv79> the perl6 META6.json detection code at pause is looking for '^META6.json'.  this is the problem.

[13:05] * brrt is wondering if anybody made a list of the great-tools-used-in-japan slides

[13:05] <jdv79> i packaged my dist in the p5 way and the indexer failed

[13:06] <jdv79> hence why https://github.com/andk/pause/issues/185

[13:06] <brrt> slideshare has it: http://www.slideshare.net/junichiishida/great-tools-heavily-used-in-japan-you-dont-know

[13:07] <ShimmerFairy> jdv79: is that why your upload failed with that "duplicate package" warning?

[13:07] <jdv79> no, that bug was fixed y'day.

[13:07] <jdv79> so i got past that issue and this is the new one

[13:09] <jdv79> i would like some consensus on the dist layout before m PR is applied as it seems to take a decent amount of time to get things done over there

[13:09] <jdv79> *my

[13:10] <ShimmerFairy> jdv79: cool :)  and yeah, that seems like a bug. Does that regex allow the META6.json anywhere in the package? Because that seems like a bad idea, I think I'd prefer "top-level, considering one top directory in the tarfile as the 'real' top-level", or something to that effect

[13:11] <jdv79> right now it pegs it to the top level of the tarball.  i would like it to peg it to one subdir down.

[13:12] <jdv79> yeah, I just need liz and/or froggs to weigh in.

[13:12] <ShimmerFairy> jdv79: yeah, I personally wouldn't mind enforcing the common-courtesy tarballs are known for (I very rarely see a .tar.* that doesn't unpack as one directory, and such tarballs are very undesirable, imo)

[13:13] <jdv79> yup

[13:14] *** sufrostico joined
[13:17] <ShimmerFairy> btw, I hope the "must specify Perl6/" thing is temporary, since that feels like a bad permanent solution

[13:20] <jdv79> in what way?

[13:21] <jdv79> we could put up a page that does that automatically or hide it behind a tool but cpan using that dir to house p6 content is pretty solid i think

[13:22] <ShimmerFairy> jdv79: not the fact that we're using Perl6, but the fact that I have to manually type it into the "target directory" field

[13:22] *** n0tjack joined
[13:23] <jdv79> yeah, next iteration maybe;)

[13:25] <pmurias> hoelzro: \o

[13:25] <ShimmerFairy> also, does that "can never upload a same-named file, even if deleted" apply to P6 files too?

[13:25] <ShimmerFairy> jdv79: well, next iteration would possibly be a "Yes, this is Perl 6" checkbox :P

[13:25] *** hernanGOA joined
[13:26] *** tokuhiro_ left
[13:26] *** n0tjack left
[13:27] <jdv79> yes and ok

[13:31] <psch> vivifying array elements to Any instead of Mu under "no strict" seems to work with specifying Any as a fallback to $*OFTYPE in the container_type_info in $*W.auto_declare_var

[13:32] <psch> i'm not sure it's really supposed to be that easy, though 

[13:32] <psch> also, RT #124912 has me a bit stumped

[13:33] <psch> as in, i'm unsure if "no strict" propagating into EVAL is really that sensible

[13:33] <psch> OTOH, it's probably less surprising if it did, which is probably reason enough

[13:34] <nine> _itz: that seems to be the closest we've got to GLR documentation: https://gist.github.com/niner/d5f825c07ce1f7a6f7bb

[13:34] <psch> but i think that means teaching HLL::Compiler about "no strict"...

[13:34] *** pmurias left
[13:40] <_itz> nine: thanks

[13:40] *** CQ left
[13:41] <_itz> nine: I was also experimenting with https://gist.github.com/stmuk/de108fc081e45876d1e4 as a learning tool for myself

[13:43] <dalek> roast: 0dc659a | TimToady++ | S03- (3 files):

[13:43] <dalek> roast: test .is-lazy on xx, .., and ...

[13:43] <dalek> roast: review: https://github.com/perl6/roast/commit/0dc659a4e7

[13:43] <dalek> roast: 14d11da | TimToady++ | S32-num/rat.t:

[13:43] <dalek> roast: test (1/128).perl.EVAL trips round

[13:43] <dalek> roast: review: https://github.com/perl6/roast/commit/14d11da571

[13:43] <psch> hm, except the container_type_info fix mentioned above makes autodeclared hashes weird

[13:43] <psch> $ ./perl6 -e'no strict; %a<a> = 0; say %a.perl'

[13:43] <psch> (my Any % = :a(0))

[13:44] <psch> i'm pretty sure that's not right

[13:44] *** CQ joined
[13:46] <dalek> rakudo/nom: 2d6ee41 | TimToady++ | src/core/Rat (2 files):

[13:46] <dalek> rakudo/nom: .base now can take * digits

[13:46] <dalek> rakudo/nom: 

[13:46] <dalek> rakudo/nom: also .base-repeating no longer fails on negatives

[13:46] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/2d6ee41063

[13:47] <ShimmerFairy> psch: I'd like to see some spec confirmation before we consider 124912 a bug. (I personally don't think 'no strict' is worth having in the first place, so I'm not inclined to make this work, but that's just me)

[13:48] <_itz> https://github.com/perl6/doc/issues/116

[13:48] *** brrt left
[13:49] <psch> ShimmerFairy: design is rather thin regarding anything lax mode, unfortunately

[13:50] <ShimmerFairy> psch: because it shouldn't be there in the first place :D . More seriously, I've thought about it a bit today, and I've come to the conclusion that 'no strict' exists in P6 only because P5 had a concept of strictures, so I'm inclined to say "you can't be lazy, there is no lax mode". Perhaps a 6.1 change, if not sooner :)

[13:51] * jnthn back

[13:51] <TimToady> m: say 1/128 == (1/128).perl.EVAL

[13:51] <camelia> rakudo-moar b2fea8: OUTPUT«False␤»

[13:51] <jnthn> [Coke]: Yes, I already re-writing S07

[13:52] <TimToady> that should fix itself with recompile

[13:53] <FROGGS> m: say $*PERL.build-date

[13:53] <camelia> rakudo-moar b2fea8: OUTPUT«Method 'build-date' not found for invocant of class 'Perl'␤  in block <unit> at /tmp/6xD7kGQQ_9:1␤␤»

[13:53] <FROGGS> m: say $*KERNEL.build-date

[13:53] <camelia> rakudo-moar b2fea8: OUTPUT«Method 'build-date' not found for invocant of class 'Kernel'␤  in block <unit> at /tmp/j2mnt2zN1G:1␤␤»

[13:53] <FROGGS> m: say $*COMPILER.build-date

[13:53] <camelia> rakudo-moar b2fea8: OUTPUT«Dynamic variable $*COMPILER not found␤  in block <unit> at /tmp/WlH0s6EESz:1␤␤Actually thrown at:␤  in any  at src/gen/m-Metamodel.nqp:2869␤  in block <unit> at /tmp/WlH0s6EESz:1␤␤»

[13:53] <psch> ShimmerFairy: but laziness is one of the three virtues! ;)

[13:53] <FROGGS> m: say $*PERL.compiler.build-date

[13:53] <camelia> rakudo-moar b2fea8: OUTPUT«2015-09-08T13:09:28Z␤»

[13:56] <psch> ShimmerFairy: in seriousness though, i doubt "no strict" will go away, but the interaction between strictness and EVAL is definitely underspecified

[13:57] <_itz> s: say (Array).^roles

[13:57] <jnthn> s? :)

[13:57] <_itz> star: say (Array).^roles

[13:57] <camelia> star-m 2015.03: OUTPUT«(Positional)␤»

[13:58] <TimToady> boarding &

[13:58] <_itz> m: say (Array).^roles

[13:58] <camelia> rakudo-moar b2fea8: OUTPUT«Method 'iterator' must be implemented by Iterable because it is required by a role␤  in any compose_method_table at src/gen/m-Metamodel.nqp:2666␤  in any apply at src/gen/m-Metamodel.nqp:2676␤  in any compose at src/gen/m-Metamodel.nqp:2812␤  in an…»

[13:58] <jnthn> m: say (Array).^roles.map({.^name})

[13:58] <camelia> rakudo-moar b2fea8: OUTPUT«(Positional Iterable)␤»

[13:58] <_itz> m: say (Array).^roles.WHAT

[13:58] <camelia> rakudo-moar b2fea8: OUTPUT«(List)␤»

[13:59] *** perlawhirl joined
[13:59] <ShimmerFairy> psch: like I said, perhaps only in 6.1, but I definitely don't know what the value of lax mode is, so atm I kinda would like to make it go away. :)

[13:59] <jnthn> m: say Iterator

[13:59] <camelia> rakudo-moar b2fea8: OUTPUT«Method 'pull-one' must be implemented by Iterator because it is required by a role␤  in any compose_method_table at src/gen/m-Metamodel.nqp:2666␤  in any apply at src/gen/m-Metamodel.nqp:2676␤  in any compose at src/gen/m-Metamodel.nqp:2812␤  in an…»

[13:59] <jnthn> ah

[13:59] <jnthn> Maybe .gist needs to go in the no-pun list.

[14:00] <[Coke]> "doctor, it hurts when I no strict."

[14:01] <psch> ShimmerFairy: right, the value is purely traditional.  and considering we have strict -e there's no efficiency argument either...

[14:01] <ShimmerFairy> psch: I just came to this conclusion earlier today, so I'm not too strong on it (yet) :P . I am willing to be shown Perl 6 examples that are *greatly* improved by lax mode, however. :)

[14:02] * grondilu rewrote http://rosettacode.org/wiki/SHA-1#Perl_6 for post-GLR.  Basically had to add a few 'flat' here and there.

[14:02] <ShimmerFairy> Like I said, the only reason I can think of it being there in the first place is because Perl 5 had a concept of strictures. :)

[14:02] *** n0tjack joined
[14:03] * [Coke] trips over a JSON encoder that isn't encoding chr(18) properly. blah.

[14:03] <ab5tract_> ShimmerFairy: I appreciated the lax-ness when it  was in the repl by default

[14:03] <ab5tract_> If there is a strong *technical* reason for removing it, sure. But otherwise, keep it around for dirty one liners

[14:04] <psch> ab5tract_: i read that as an argument for "bring back lax -e", mostly

[14:04] <psch> and i agree with that, i think

[14:04] <ab5tract_> psch: certainly not!

[14:04] <ShimmerFairy> ab5tract_: well, aside from the fact that you have to specify 'no strict' in your one-liner, I'll point out that I never had a problem working under strict mode in one-liners

[14:04] <ab5tract_> perl6 -d or so

[14:04] <pink_mist> I'd say if you really want it, make it a slang

[14:05] <ShimmerFairy> As a P6-only user, I have _never_ thought to myself "gee, if only I didn't have to type two letters and a space to declare a 'my' variable"

[14:05] <ab5tract_> no need to have it in -e, but it would be nice to have a flag that is lax

[14:05] <pink_mist> seems silly to support two different ways of writing perl6

[14:05] <dalek> rakudo/nom: 7102178 | jnthn++ | src/core/Array.pm:

[14:05] <dalek> rakudo/nom: Ban certain operations on shaped arrays.

[14:05] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/71021785f4

[14:05] <ab5tract_> pink_mist: umm... that cat is already out of the bag via TMTOWTDI

[14:06] <psch> and many subs being methods, too

[14:06] <ab5tract_> ShimmerFairy: sure. I see no reason why you're lack of desire should override the desires of others

[14:06] <ab5tract_> If it is particularly costly in terms of technical debt -- sure

[14:06] <pink_mist> ab5tract_: I worded that badly; I didn't mean not to support however many ways to write perl, but rather having two separate bases from which to build code

[14:07] <ab5tract_> pink_mist: I really don't think the split between strict/no strict is that deep though. But I could be wrong

[14:07] <ShimmerFairy> ab5tract_: I'm just saying that as someone who has not used P5, (and as someone who used P6 back when there was no lax mode), I've never desired what P5 offers, so I can't help but think other people liking it are just familiar with it.

[14:07] *** andreoss` joined
[14:07] <ab5tract_> ShimmerFairy: 'use strict;' is not there because Perl 5 had strictures... it's there because it *didn't*

[14:08] <grondilu> oh, first time I see this one: 'Bus Error'

[14:08] <pink_mist> ab5tract_: I'd very much like to see it as a slang though; that way the interpreter wouldn't need to worry about two different ways to parse code

[14:09] <jnthn> pink_mist: The interpreter already doesn't

[14:09] *** andreoss left
[14:09] <ab5tract_> ShimmerFairy: that could easily be turned around to you not realizing the utility due to lack of familiarity

[14:10] <jnthn> The interpreter has no idea at all about parsing anything execpt its own bytecode format. It couldn't care less if that was made from COBOL or Perl 6. :)

[14:10] <ShimmerFairy> ab5tract_: what I meant is that 'Perl 5 having a concept of strictures' meaning that it had a conception of being strict vs. not. Perl 6 doesn't have that same issue, so I see 'no strict' as just a way to keep P5-ers happy

[14:10] <ab5tract_> You are talking about something that only became default *this year*

[14:10] <jnthn> Pushing "no strict" out to a slang would be a good verfication of slangs, once we get far enough along.

[14:11] <ab5tract_> and I really don't understand your readiness to reject things just because they make P5 people happy

[14:11] <ShimmerFairy> jnthn: would you support the idea of kicking out lax mode in 6.1 or 6.x ? I don't think it's quite appropriate to kick it out of 6.0.0

[14:11] *** perlawhirl left
[14:11] <ab5tract_> it's frustrating to say the least

[14:11] <jnthn> ShimmerFairy: Why kick it anywhere?

[14:11] <psch> kick it into a core slang i say!

[14:11] <ShimmerFairy> ab5tract_: what do you mean by "only became default *this year*" ? Are you talking about P5?

[14:11] <jnthn> ShimmerFairy: It can stay implemented as it is for now

[14:12] *** Ven joined
[14:12] <jnthn> ShimmerFairy: Maybe in 6.x when we've got slangs further along we'll kick it out of the core compiler codebase into a module, to decrease code size an iota...but it's a drop in the ocean really.

[14:12] *** Sqirrel left
[14:12] <ShimmerFairy> jnthn: I'm just arguing that lax mode is pretty useless, from my view. I've yet to hear a good reason for it aside from "P5 had a 'strict' pragma".

[14:12] <ShimmerFairy> (which I don't think is a good reason)

[14:13] <jnthn> ShimmerFairy: Then don't use it.

[14:13] <ab5tract_> ShimmerFairy: no, I mean that strict-ness became default for perl6 -e and the repl only this year

[14:13] <jnthn> I thought we already changed -e to be strict recently, leaving about zero places where it's the default.

[14:14] <ShimmerFairy> ab5tract_: before lax mode existed, things were strict everywhere, so that doesn't mean what you're implying it does.

[14:14] <ab5tract_> ..... umm, I'm sorry but I was able to do perl6 -e "@a = rand xx 50" and now I can't

[14:15] <ShimmerFairy> jnthn: we did, and of course I don't use lax mode, I'm just mentioning that I find no reason it exists in P6, much less as a part of CORE :)

[14:15] <ab5tract_> that was just changed recently

[14:15] <Ven> o/, #perl6!

[14:15] <ab5tract_> and the repl was also changed to lax mode

[14:15] <ShimmerFairy> ab5tract_: I recall there being a time where rakudo didn't have "no strict", so of course things wouldn't be lax anywhere :)

[14:15] <ab5tract_> ShimmerFairy: I'm sorry but you are really wrong about that

[14:15] <jnthn> It's true, there was a time where we didn't have lax mode. But we have had it for a while.

[14:15] <jnthn> I suspect multiple years.

[14:16] <psch> 5daa5de7e714908342751decf1d535473d10237e

[14:16] <psch> Date:   Sun Sep 28 13:22:50 2014 +0200

[14:16] <psch> is the commit that implemented lax mode

[14:16] <ab5tract_> NYI is not the same as "not in the language"

[14:16] <dalek> rakudo/nom: 27a3699 | jnthn++ | src/core/Array.pm:

[14:16] <dalek> rakudo/nom: Simpler elems/eager/is-lazy for shaped Array.

[14:16] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/27a3699e5a

[14:16] <psch> ab5tract_: design docs still state -e as lax

[14:16] <jnthn> psch: Wow, more recent than I thought :)

[14:17] <ShimmerFairy> Yeah, I'm just saying that "lax until this year" doesn't mean what you think it does when lax itself didn't exist until last year. Thus implementation-wise the REPL and -e have always been strict, except for that one time it wasn't for a while :P

[14:18] *** laubster joined
[14:19] <ab5tract_> ShimmerFairy: ok, I stand corrected. I also thought it had been around for a lot longer.

[14:19] <ab5tract_> Regardless, I don't think the test of whether something should be in core or not should come down to whether you personally find an argument for it to be satisfying

[14:19] *** skids joined
[14:20] <ab5tract_> Nor do I think it is fair to any of the P5 people who have been patiently waiting / helping to hear their expectations denigrated

[14:20] <jnthn> Indeed, what's in Rakudo core is largely my call. And it's staying. :)

[14:20] <ShimmerFairy> That's why I have to argue my point here instead of just removing it on a whim :)

[14:20] <jnthn> As mentioned, when we have slangs, we can make it one of those (and 'use strict' just pulls in that slang) to decrease core size a bit.

[14:21] <jnthn> Uh, "no strict"

[14:21] <ShimmerFairy> I just think that 'no strict' means nothing useful to P6 on its own. It only exists because Perl 5 had a use/no strict thingy, and I seriously don't think the concept of being lazy with lax mode would exist otherwise.

[14:21] <ShimmerFairy> jnthn: or 'use lax' :)

[14:21] <psch> "use nostrict" :)

[14:21] <jnthn> Nah, "no" will (by default) be a way to load a pragmatic module too, eventually.

[14:22] <jnthn> We just don't have our pragmas story straight enough yet, and probably won't this side of 6.christmas.

[14:22] <_itz> "use strict is gay" (old joke)

[14:22] <ShimmerFairy> jnthn: oh, interesting. Will pragmas eventually work like they did in P5? (As in, a funny module?) Or will they be lightly different than modules here in P6?

[14:22] <jnthn> ShimmerFairy: The pragma/module distinction doesn't especially exist so far as I'm concerned.

[14:23] * PerlJam finds it bizarre that "no strict" has generated so much discussion.

[14:23] <jnthn> ShimmerFairy: Grammar::Tracer has lexical effect in the scope you import it into. Is it a module or a pragma?

[14:23] <ShimmerFairy> jnthn: from my years of P6, I think of pragmas as just compiler flags, so I'm unfortunately used to them being very different. If I were more familiar with P5 I probably wouldn't have that distinction so much :P

[14:24] <TimToady> the very attempt to make the distinction indicates only the module system is not yet powerful enough to implement pragmas :)

[14:24] <TimToady> no, not yet boarded-really

[14:24] <ShimmerFairy> I think the big question is what 'no' means in P6 module loading, since I don't think that's been figured out yet.

[14:24] <jnthn> ShimmerFairy: It hasn't, and that's why they're handled differently in the compiler at the moment.

[14:25] <jnthn> Most such hard-coded things in the compiler with use/no are only that way because it's expedient.

[14:25] <TimToady> m: say 1/128 == (1/128).perl.EVAL

[14:25] <camelia> rakudo-moar 710217: OUTPUT«True␤»

[14:25] <TimToady> there we go

[14:25] <jnthn> And because we know the whole area is related to macros, quasis, etc. and so we can't do what we want with pragmas until we deal with those issues.

[14:26] <ShimmerFairy> Not to mention that the kinds of changes pragmas are known to make are surely the even more difficult changes to undo :)

[14:27] <TimToady> really boarding maybe :) &

[14:27] *** tokuhiro_ joined
[14:27] * moritz hopes for TimToady it's a boring boarding (and flight)

[14:28] <dalek> rakudo/nom: d881420 | jnthn++ | src/core/Array.pm:

[14:28] <dalek> rakudo/nom: Implement multi-dim access to Array.

[14:28] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/d8814206ae

[14:28] <jnthn> TimToady: Good luck!

[14:28] <jnthn> ShimmerFairy: Thankfully, our entire parser arch is designed for forgetting stuff at the exit of a lexical scope

[14:29] <ShimmerFairy> Hm. When pragmas can be implemented as modules, would 'no strict' be some kind of "strict" module that would be able to trickily define itself as adding features upon a "no", or would it be saner for those changes to be brought in by a 'use' statement instead?

[14:29] <ShimmerFairy> jnthn: that's good at least :) . Perhaps some of that can be used in making 'no' work (whatever it'll mean), assuming "exit a lexical scope" doesn't automatically cover that somehow.

[14:30] *** Ven left
[14:31] *** tokuhiro_ left
[14:32] <jnthn> perl6-m -e "my @arr := Array.new(:shape(3, 3)); @arr[1;1] = 42; say @arr[1;1]"

[14:32] <jnthn> 42

[14:32] <jnthn> \o/

[14:32] <jnthn> And yes

[14:32] <jnthn> perl6-m -e "my @arr := Array.new(:shape(3, 3)); @arr[1;1] = 42; say @arr[1;3]"

[14:32] *** zoosha joined
[14:32] <jnthn> Index 3 for dimension 2 out of range (must be 0..2) in block <unit> at -e:1

[14:34] <ShimmerFairy> jnthn++  # \o/ ever closer!

[14:35] <jnthn> I'm getting dangerously close to the point where we have to work out some difficult things.

[14:36] <pink_mist> if lax mode is lexical ... is it really even lax mode at all? I mean in perl5, any variable you used undeclared aside of the globals was package scoped afaik

[14:37] <jnthn> pink_mist: use strict/no strict are lexical in Perl 5 afaik, yes.

[14:37] <pink_mist> hmm, I guess you're right

[14:38] <jnthn> TimToady: If you didn't board yet, can you decide what "my @arr := Array.new(:shape(3, 3)); @arr.map(&say)" does during your flight? ;-)

[14:38] <pink_mist> but the variables in a 'no strict' scope need not be

[14:41] *** zakharyas left
[14:41] <dalek> rakudo/nom: e819dd1 | jnthn++ | src/core/List.pm:

[14:41] <dalek> rakudo/nom: Toss commented out code we likely don't want.

[14:41] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/e819dd12b7

[14:46] *** Ven joined
[14:50] <Tux__> m: my @a; my %h = :A(1), :B(2); @a.push: %h; @a.perl.say

[14:50] <camelia> rakudo-moar d88142: OUTPUT«[:B(2), :A(1)]␤»

[14:50] <Tux__> m: my @a; my %h = :A(1), :B(2); @a.push: { %h }; @a.perl.say

[14:50] <camelia> rakudo-moar d88142: OUTPUT«[:A(1), :B(2)]␤»

[14:51] <jnthn> Has to be $%h or item %h post-GLR

[14:51] <Tux__> what should I push to end up with [{:A(1), :B(2)}] ?

[14:51] <Tux__> jnthn++

[14:52] *** khw joined
[14:56] * Tux__ is trying to get CSV back on line

[14:57] * Tux__ notes that RT#123888 is fixed

[14:57] <dalek> rakudo/nom: 83428be | jnthn++ | src/core/array_slice.pm:

[14:57] <dalek> rakudo/nom: Simple cases of :exists/:delete on multi-dim.

[14:57] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/83428beaac

[14:57] * jnthn needs to look at CSV to see what the perf regression is down to

[14:57] <jnthn> If that's what the numbers you've been posting are about, anyways...

[14:58] <|Tux|> oh sure

[14:58] <|Tux|> the test suite currently still fails

[14:58] <jnthn> OK

[14:58] <jnthn> I'll hold off until it works properly again, so I'm profiling correct code. :)

[14:59] <|Tux|> .tell lizmat will you look at Text::CSV/t/15_flags regarding the disappearing method?

[14:59] <yoleaux> |Tux|: I'll pass your message to lizmat.

[14:59] <|Tux|> I don't know if I can reach "proper" without help

[14:59] <|Tux|> just got rid of 24+ errors

[15:01] *** andreoss` left
[15:01] <Ven> jnthn: why is it postcircumfix:<[; ]> instead of <[ ]> ?

[15:01] <Ven> is that the dispatch that should be hit for @a[3;4]?

[15:02] <jnthn> Ven: Yes, we decided to distinguish the two forms of slicing syntactically and just call a different candidate.

[15:03] <jnthn> Ven: Uh, different set of candidates

[15:03] <Ven> jnthn: so, there'll be a syntactic difference in my code? Then why check if they're not all integers?

[15:03] <Ven> shouldn't this candidate only be called if they're not all multidim?

[15:03] *** domidumont left
[15:03] <jnthn> Ven: @foo[*;0] is perfectly allowable, for example

[15:03] <jnthn> Ven: I plan to re-write various things in the optimizer though

[15:03] <Ven> jnthn: but that's multi-dim, right? not all-ints? I guess I don't really understand it :)

[15:04] <jnthn> Ven: The "all ints" check is "can we just go straight off to do an indexing"

[15:04] <jnthn> Ven: Rather than having to pick apart what we have and do clever stuff

[15:05] <Ven> I don't see how that's the case with [*;0], though? The first one is a whatever.

[15:05] <abraxxa> how can a CArray[uint8] hold codepoints < 0?

[15:05] <jnthn> Ven: It's not the case, thus why we fall back to the rather more involved MD-ARRAY-SLICE

[15:05] <jnthn> abraxxa: Um...I'd hope it can't :)

[15:06] <jnthn> Ven: Rather than just calling AT-POS

[15:06] <|Tux|> jnthn, when you pull T::C, https://gist.github.com/Tux/7e7d54789ec3d5c9234a

[15:06] <abraxxa> http://paste.scsys.co.uk/498338

[15:07] <|Tux|> no need to get a passing test suite to check on performance

[15:07] <abraxxa> that's my code

[15:07] <abraxxa> this works for getting the error text of an Oracle exception but fails for column names

[15:08] *** Ven left
[15:09] <abraxxa> jnthn: ^^ any idea what I'm doing wrong? The warn @col_name_ary; outputs 40-10854

[15:10] <abraxxa> this is the code which works: https://github.com/abraxxa/DBIish/blob/master/lib/DBDish/Oracle.pm6#L282

[15:11] <jnthn> abraxxa: Um, don't immediately see it. Somebody who's worked on/used NativeCall more recently may be able to spot it.

[15:11] *** Ven joined
[15:11] <abraxxa> jnthn: ok, thanks

[15:11] <abraxxa> FROGGS: you maybe?

[15:11] <abraxxa> nine: or you?

[15:11] <Ven> jnthn: aaah, thanks :-).

[15:12] <abraxxa> i thought uint8 should be more precise than int8 but it makes no difference regarding the error

[15:12] <nine> abraxxa: can you try warn @col_name_ary.perl; just to be sure we interpret the output correctly?

[15:12] <abraxxa> nine: [-104, 25, -119]<>  in method fetchrow at /home/abraxxa/perl6/git/DBIish/lib/DBDish/Oracle.pm6:568

[15:14] <nine> That's different than before?

[15:15] <abraxxa> yeah, i guess the order of the columns returned by OCI varies

[15:15] <abraxxa> the length returned is in bytes, the encoding should be utf-8

[15:15] <nine> Just 3 bytes? Do you have an idea which column name this could be?

[15:15] <abraxxa> the query is 'SELECT name, description, quantity, price, quantity*price AS amount FROM nom ORDER BY name'

[15:16] <abraxxa> the length is 4 so it should be name

[15:16] <abraxxa> as the array is 0 based i loop from 0 to 4-1

[15:16] <nine> So it should rather be for ^$col_name_len;

[15:17] *** pmurias joined
[15:17] <nine> ^$col_name_length is already exclusive

[15:17] <|Tux|> is "[ 1, 2, "foo", 3 ].iterator" still the correct syntax for post-glr?

[15:17] <abraxxa> exclusive means what?

[15:17] <pmurias> hoelzro: any hard problems stopping the merge or just tuits?

[15:17] <hoelzro> pmurias: both =/

[15:18] <hoelzro> no tuits for the last 4 or 5 days, but I'm stuck on merging at the point of 18ece1f

[15:18] *** Sqirrel joined
[15:18] <nine> abraxxa: exclusive means it will stop _before_ reaching the limit

[15:18] <nine> m: use NativeCall; my $c = CArray[uint8].new; $c[0] = 180; say $c[0];

[15:18] <camelia> rakudo-moar 83428b: OUTPUT«-76␤»

[15:18] <abraxxa> nine: ok

[15:18] <nine> ^^^ there's your problem

[15:18] <moritz> |Tux|: what do you want to do?

[15:18] <hoelzro> jnthn made a change to NQP that uses an optimization in MoarVM, but I can't seem to figure out how to get nqp-js to compile without reverting that optimization

[15:18] <jnthn> |Tux|: Well, the syntax is fine, but I'm not convinced you'll want to call .iterator post-GLR

[15:18] <nine> uint8 seems to not be unsigned at all

[15:19] <abraxxa> nine: because unsigned are still not implemented correctly and wrap?

[15:19] <nine> yep

[15:19] <abraxxa> i wonder why using int8 in the errortext works

[15:19] <nine> I don't think it should be a problem in your case. Using int8 or uint8 just changes the interpretation of the array's contents, not its values.

[15:20] <nine> But why do you decode('ascii') if it's utf-8?

[15:21] <abraxxa> nine: that was just a try

[15:21] <abraxxa> because 'name' should be the same in both encodings afaik

[15:21] <nine> But you clearly have code points > 127 in there

[15:22] <abraxxa> the length returned seem to be ok: 4, 11, 8, 5, 6

[15:23] <|Tux|> jnthn, https://github.com/Tux/CSV/blob/master/lib/Text/CSV.pm#L296 and https://github.com/Tux/CSV/blob/master/lib/Text/CSV.pm#L384

[15:25] *** coffee` left
[15:25] *** coffee` joined
[15:26] <masak> no release manager for this month...

[15:27] *** xfix left
[15:27] <pmurias> hoelzro: one possible workaround would be to extract that part into a method and override it in the SerializeOnce role we mix in to inject hacks necessary for cross compilation 

[15:27] <abraxxa> nine: the returned bytes are always different

[15:27] <hoelzro> pmurias: I tried that, no dice =(

[15:27] <dalek> rakudo/nom: 90e4dab | coke++ | docs/release_guide.pod:

[15:27] <dalek> rakudo/nom: Claim 2015.09 compiler release

[15:27] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/90e4dab026

[15:28] <hoelzro> [Coke]++

[15:28] *** tokuhiro_ joined
[15:29] <|Tux|> .tell lizmat ignore: I found it «ok (@x[$_], "text") for 1 .. 5, 7, 19;» → «ok (@x[$_], "text") for flat 1 .. 5, 7, 19;»

[15:29] <yoleaux> |Tux|: I'll pass your message to lizmat.

[15:29] <pmurias> hoelzro: I'll try to figure out why things still work after that optimalization and maybe I can figure out a better workaround

[15:29] <hoelzro> pmurias: I have an in-progress merge branch on my machine, I can push it up tonight

[15:30] <hoelzro> after that optimization, I think we just need to provide a dummy NQPReentrantLock REPR

[15:30] <hoelzro> and then fix whatever else remains =)

[15:30] <jnthn> |Tux|: Ho, so you're just implementing a method iterator... Where is that being used? Or is it public API?

[15:31] <jnthn> hoelzro: What was the change?

[15:31] <|Tux|> the iterator in the first url is to enable $object[$index]

[15:31] <Ven> today was a great day. The backlog is full of nice stuff to read & learn :-).

[15:31] <|Tux|> the second is to enable special behaviour for an error class

[15:33] *** tokuhiro_ left
[15:33] *** pmurias left
[15:35] *** muraiki joined
[15:35] <dalek> nqp/js: b015083 | (Pawel Murias)++ | src/vm/js/QAST/Compiler.nqp:

[15:35] <dalek> nqp/js: Bunch of small regex fixes/features.

[15:35] <dalek> nqp/js: 

[15:35] <dalek> nqp/js: Fix emitting of string containing horizontal whitespace.

[15:35] <dalek> nqp/js: Implement enumcharlist.

[15:35] <dalek> nqp/js: Implement eol, bol, lwb, rwb anchors.

[15:35] <dalek> nqp/js: Fix bug in quantifiers.

[15:35] <dalek> nqp/js: review: https://github.com/perl6/nqp/commit/b015083679

[15:35] *** pecastro joined
[15:35] *** pmurias joined
[15:35] <Ven> pmurias++

[15:36] <nine> pmurias++ # still a hero

[15:36] <|Tux|> jnthn, removing the first would result in «Method 'iterator' must be implemented by CSV::Row because it is required by a role»

[15:36] <jnthn> |Tux|: Yes, because the class "does Iterable"

[15:36] <nine> |Tux|: do you have some is Iterable there?

[15:37] <|Tux|> nine, no is Iterable

[15:37] <jnthn> Oh, if it's "is Iterable" it's certainly wanting changing to "does Iterable"

[15:37] <jnthn> Looks like you already changed that.

[15:37] <|Tux|> yes

[15:39] <abraxxa> what's the difference between my @col_name := CArray[int8].new; and my CArray[int8] @col_name;

[15:40] <|Tux|> Method 'error' not found for invocant of class 'X::TypeCheck::Assignment' <= does that ring a bell?

[15:40] <pmurias> is it possible to push half merged branches in git?

[15:40] <nine> abraxxa: in the first case you get an initialized object

[15:40] <nine> pmurias: what do you mean by "half merged"?

[15:41] <abraxxa> nine: and in the later?

[15:41] <nine> You have a variable that can only hold objects of the specified type

[15:41] <abraxxa> and what does 'initialized' mean?

[15:41] <pmurias> nine: after asking that I figured that would be just merging a part of the commits

[15:41] <pmurias> s/part/some/

[15:43] <_itz> https://github.com/jnthn/test-mock/pull/7 # bump

[15:43] <jnthn> _itz: Merged

[15:43] <eiro>  /wg #phear.org 

[15:44] <eiro> oops sorry 

[15:44] <abraxxa> nine: I expected a different output from my @col_name := CArray[int8].new; @col_name[$_] = 0 for ^32; warn @col_name.perl;

[15:44] <_itz> ty

[15:44] <eiro> hello btw

[15:44] *** Ven left
[15:44] <|Tux|> FYI it surprised me that now [[1,2]] != [[1,2],] 

[15:45] *** plicease joined
[15:46] <jnthn> |Tux|: Yes, that's the thing we often call the "single arg rule"

[15:46] <jnthn> |Tux|: Same rule as for the .push case you had earlier, fwiw

[15:47] <jnthn> So [$[1,2]] also does that [[1,2],] does

[15:47] <jnthn> *what

[15:54] <|Tux|> three more flat's fixes 17000 tests :)

[15:55] *** yqt joined
[15:59] <pink_mist> wow, that's some good value per character of code

[16:00] *** CQ left
[16:02] *** Ven joined
[16:02] <ugexe> m: sub foo($a) { once &?ROUTINE($a) }; foo(1)

[16:02] <camelia> rakudo-moar 90e4da: OUTPUT«Too many positionals passed; expected 0 arguments but got 1␤  in sub foo at /tmp/EYb1e48m4u:1␤  in block <unit> at /tmp/EYb1e48m4u:1␤␤»

[16:04] *** dha joined
[16:06] <|Tux|> «take $from .. $r.value;» → Type check failed in assignment to '@!crange'; expected 'Int' but got 'Range'

[16:06] <|Tux|> $r.value can be Inf

[16:06] <timotimo> did i o/ yet?

[16:06] <|Tux|> so I bet flat is out of the question

[16:06] <|Tux|> hi timotimo 

[16:06] <timotimo> o/

[16:06] <timotimo> you may want to take a Slip

[16:07] <timotimo> ISTR take now always just takes a single thing, or something like that, and we've got to rely on iteration encountering a Slip there if we want things to flatten out

[16:07] <Ven> \o timotimo :-)

[16:07] *** rindolf left
[16:07] *** pecastro left
[16:07] <timotimo> to me, flat is like flattening "into", while Slip is like flattening "out of"

[16:08] <|Tux|> so take Slip 1 .. Inf; ?

[16:08] <timotimo> Inf?

[16:08] <abraxxa> how do I define a private attribute that gets lazy populated?

[16:08] <timotimo> could actually work

[16:09] <|Tux|> $r.value can be Inf, as I already said

[16:09] <timotimo> abraxxa: AFAIK lazy population relies on accessors existing to do the "magic"

[16:09] <timotimo> right, it can, that's why "flat" is out of the question, right?

[16:09] <timotimo> but with Slip, it probably can still work

[16:10] <abraxxa> timotimo: so no built-in functionality like Moo's is => 'lazy' sub _build_foo ?

[16:10] <|Tux|> what is the syntax? I keep getting errors

[16:10] <jnthn> m: say (|1..Inf).WHAT

[16:10] <camelia> rakudo-moar 90e4da: OUTPUT«(Range)␤»

[16:10] <jnthn> m: say |(1..Inf).WHAT

[16:10] <camelia> rakudo-moar 90e4da: OUTPUT«(Range)␤»

[16:10] <jnthn> m: say (|(1..Inf)).WHAT

[16:10] <camelia> rakudo-moar 90e4da: OUTPUT«(Slip)␤»

[16:10] <jnthn> heh, third time lucky :P

[16:11] <timotimo> abraxxa: we had that built-in for a few days, but it was deemed "for the ecosystem"

[16:11] <abraxxa> timotimo: i see

[16:11] <timotimo> in fact, you could go back, find the commit that introduced the change, package that up into a module and put it up on the ecosystem right now

[16:11] <timotimo> nobody has done that, as far as i know

[16:12] *** rindolf joined
[16:12] <abraxxa> but that means that you have to access the private attr always through its accessor?

[16:12] <hoelzro> jnthn: something about not using the string heap, and using the compunit's instead

[16:13] <timotimo> abraxxa: direct private attribute access is extremely close "to the metal"

[16:14] <_itz> A suggestion for future stars... that 2015-spw-perl6-course.pdf (or similar) replace UsingPerl6-draft.pdf (unmaintained)?

[16:17] <masak> _itz: I like that suggestion.

[16:17] <Ven> ShimmerFairy: FWIW, my use case for no strict usually stems from -n and -p :)

[16:17] <Ven> ShimmerFairy: being able to go -e '%h{$_}++; END { say %h.perl }' or something is great.

[16:18] *** rvchangue joined
[16:18] <abraxxa> timotimo: i'd add a method that populates the private attribute if undefined (not sure what's the Perl 6 way to check this) and return it's value and always call the method, never the private attribute directly which will be only used for caching. does that sound sane?

[16:18] <timotimo> you can put a state variable into that method

[16:19] <timotimo> that way putting undefined values into that attribute is also a valid thing

[16:19] <timotimo> and checking for defined values is just .defined

[16:19] <dha> Which reminds me, I need to look at documenting C<state>....

[16:19] <abraxxa> timotimo: that sounds safer than the private attr on the class, yes

[16:19] <timotimo> mhm

[16:20] <timotimo> a thing it does is put data that more or less belongs to the instance "far away" from that instance

[16:20] *** Ven left
[16:20] <abraxxa> not much docs on state ;( http://doc.perl6.org/language/variables#The_state_Declarator

[16:21] <timotimo> yeah, that's really not much

[16:21] *** FROGGS left
[16:24] <jnthn> dinner &

[16:26] *** spider-mario joined
[16:26] <dha> Almost nothing, in fact.

[16:26] <dha> And, afaict nothing at all on C<$>.

[16:27] <abraxxa> i want to loop from 1 to .field_count, what is the correct syntax?

[16:27] <abraxxa> for 1.. .field_count -> $field_index { ?

[16:27] <dha> (By "almost nothing", I appear to mean "it's mentioned a couple of times in spec with no actual explanation")

[16:29] <|Tux|> jnthn or timotimo if either of you would clone github.com:Tux/CSV and make t/78_fragment.t pass (CSV.pm line 123) I'd be grateful

[16:29] <abraxxa> timotimo: Natively typed state variables not yet implemented

[16:29] <|Tux|> I give up

[16:29] <|Tux|> I already made 18000 extra tests pass today.

[16:29] *** ab5tract_ left
[16:32] <abraxxa> |Tux|++

[16:40] *** FROGGS joined
[16:41] <ugexe> m: sub foo($a?) { once &?ROUTINE() }; foo(1);

[16:41] <camelia> rakudo-moar 90e4da: OUTPUT«Memory allocation failed; could not allocate 6144 bytes␤»

[16:44] <timotimo> abraxxa: you mean for 1 .. $_.filed_count?

[16:44] <timotimo> field*

[16:45] *** pierrot joined
[16:47] <abraxxa> timotimo: for 1 .. self.field_count {

[16:49] *** Ven joined
[16:49] <timotimo> then you need "self." :)

[16:50] <abraxxa> timotimo: i've overcome the non-implemented state for native vars by using an Int and storing the ub4 to it: https://github.com/abraxxa/DBIish/commit/9f3af5844271cfcf53b434f5f46904936311804c

[16:51] <timotimo> ah, state variables with natives is difficult

[16:51] <timotimo> i think state vars internally rely on setting a c-level null to the variable

[16:51] <timotimo> which for native ints is a valid value (for num i'm not so sure)

[16:54] *** mohij joined
[16:55] <[Coke]> dha: I think $ is just a variable with an empty name.

[16:56] <[Coke]> m: my $ = 3; say $;

[16:56] <camelia> rakudo-moar 90e4da: OUTPUT«(Any)␤»

[16:56] <dha> It's supposedly the anonymous state variable.

[16:57] <dha> m: for 1..5 {say $++}

[16:57] <camelia> rakudo-moar 90e4da: OUTPUT«0␤1␤2␤3␤4␤»

[16:57] <[Coke]> it can be used with state, but I don't think it's exclusive to state.

[16:57] <[Coke]> right. that's not state there.

[16:57] <dha> Hm. That is not what I've been told, but that may not mean anything.

[16:58] <[Coke]> not all info in #perl6 is equal. :)

[16:58] <dha> When I asked "what the heck is C<$>?" TimToady said it was the anonymous state variable.

[16:58] <rindolf> Hi all, sup?

[16:59] <[Coke]> well, timtoady is moar likely to be right about that sort of thing, of course.

[16:59] <dha> Right. Hence my assumption that it was true. :-)

[17:00] <timotimo> [Coke]: $ is an anonymous state variable

[17:00] <timotimo> m: sub test() { $++ }; say test for ^5

[17:00] <camelia> rakudo-moar 90e4da: OUTPUT«0␤1␤2␤3␤4␤»

[17:00] <pink_mist> m: for 1..5 { say $++; say $++; } #it's not quite state ... it's ... weird

[17:00] <camelia> rakudo-moar 90e4da: OUTPUT«0␤0␤1␤1␤2␤2␤3␤3␤4␤4␤»

[17:00] <pink_mist> an anonymous state variable basically

[17:01] <pink_mist> oh, timotimo already said that

[17:01] <pink_mist> timotimo++

[17:01] <dha> ...and this is why we need documentation. scene. :-)

[17:03] * dha goes off to steal the documentation on C<state> from Perl 5...

[17:06] <[Coke]> timotimo: yes, but I'm saying it works without explicitly declaring "state"

[17:07] <[Coke]> Are you saying that referencing $ is the same as "state $" ?

[17:07] *** dbron_ joined
[17:07] <dbron_> .clear

[17:07] <timotimo> yes, that's what i'm saying

[17:07] *** pmurias left
[17:07] <timotimo> $ is short for "(state $)"

[17:08] *** dakkar left
[17:13] <dbron_> At the beginning of the year, Larry intimated we might see a beta 1.0 in Sept .. that still in the cards?

[17:13] *** rangerprice joined
[17:14] <rangerprice> How can i redirect the output of stderr in a variable ?

[17:14] <FROGGS> dbron_: we still try very hard

[17:14] <abraxxa> the C function definition for the pointer to the column name is void *attributep,

[17:14] <ugexe> rangerprice: IO::Capture::Simple

[17:14] <ambs> well, he said something could get out to his birthday in september, yeah

[17:14] <abraxxa> is that NativeCall definition ok? CArray[int8]    $attributep,

[17:14] <ambs> and said that about 5 days ago :D

[17:15] <Ven> rangerprice: change the dynamic variable that represents the output

[17:15] <Ven> ugexe: it's not thread-safe :(

[17:15] <ugexe> right, but he can look at the source and see how

[17:15] <dbron_> FROGGS: from what I've seen, you guys go beyond "try very hard" to "never sleep"

[17:15] <timotimo> abraxxa: why won't a Str do? is this for null-byte-terminated strings?

[17:16] <dbron_> FROGGS: but did you mean to say "we will still try very hard [to get a RC out]"?

[17:16] <abraxxa> timotimo: return by pointer like the whole OCI

[17:16] <abraxxa> using Str results in a segfault because I guess not enough memory is allocated

[17:16] <timotimo> oh

[17:17] <dha> Re: C<state> - https://gist.github.com/dha/02f1f41b5f8937c0271e

[17:17] <abraxxa> you pass it a pointer to a CArray[int8] and a Carray[ub4] which contains the length in bytes

[17:18] <timotimo> you may want just Pointer instead

[17:18] <timotimo> at least for the CArray[ub4]

[17:18] <abraxxa> that's the part that works ;)

[17:18] <timotimo> right

[17:18] <abraxxa> fetching the error message with http://docs.oracle.com/database/121/LNOCI/oci17msc007.htm#LNOCI17287 works

[17:19] <timotimo> the thing about CArray is that it needs to know the size in order to work

[17:19] <abraxxa> fetching the column name with http://docs.oracle.com/database/121/LNOCI/oci16rel002.htm#LNOCI17130 doesn't

[17:19] *** rangerprice left
[17:19] <abraxxa> OraText    *bufp, vs void           *attributep,

[17:19] <timotimo> i ... don't actually know exactly how we do this

[17:19] <timotimo> with shaped array declarations, i expect something like casting to a shaped CArray

[17:19] <abraxxa> shaped?

[17:19] *** pat_js left
[17:20] <timotimo> to be honest, i'd get a Pointer[int8] and increment it length-of-text times and grab each byte individually into another array or directly into a Uni or something string-ish

[17:21] <timotimo> shaped arrays have the size(s) as part of their type

[17:21] <timotimo> jnthn is working on that right now

[17:21] <abraxxa> i see

[17:21] <timotimo> 163056     jnthn │ perl6-m -e "my @arr := Array.new(:shape(3, 3)); @arr[1;1] = 42; say @arr[1;3]"

[17:21] <timotimo> 163102     jnthn │ Index 3 for dimension 2 out of range (must be 0..2) in block <unit> at -e:1

[17:22] <abraxxa> can i allocate a CArray[int8] with n number of elements right now?

[17:22] <abraxxa> 2015.07.2

[17:23] <timotimo> well, you can just .new it and assign to the n-1th element

[17:23] <abraxxa> i do it with my @col_name := CArray[int8].new; @col_name[$_] = 0 for ^512;

[17:23] <timotimo> no need to set to 0 for the initial ones; i *think* we allocate CArray from zero'd memory blocks

[17:23] <timotimo> m: use NativeCall; my $arr = CArray

[17:23] <camelia> rakudo-moar 90e4da: ( no output )

[17:23] <timotimo> loops

[17:23] <abraxxa> so that should suffice? @col_name[511] = 0;

[17:23] <timotimo> m: use NativeCall; my $arr = CArray[int8].new; $arr[10] = 0; say $arr

[17:23] <camelia> rakudo-moar 90e4da: OUTPUT«IntTypedCArray[int8].new␤»

[17:24] <timotimo> huh?

[17:24] <timotimo> m: use NativeCall; my $arr = CArray[int8].new; $arr[0] = 0; say $arr

[17:24] <camelia> rakudo-moar 90e4da: OUTPUT«IntTypedCArray[int8].new␤»

[17:24] <abraxxa> yeah, I also get that output

[17:24] <timotimo> m: use NativeCall; my $arr = CArray[int8].new; $arr[10] = 0; .say for $arr.list

[17:24] <camelia> rakudo-moar 90e4da: OUTPUT«IntTypedCArray[int8].new␤»

[17:24] <abraxxa> wasn't able to output its contents using .perl

[17:24] <timotimo> that's a bug, potentially from GLR

[17:24] <timotimo> star: use NativeCall; my $arr = CArray[int8].new; $arr[10] = 0; .say for $arr.list

[17:24] <camelia> star-m 2015.03: OUTPUT«IntTypedCArray[int8].new()␤»

[17:24] <timotimo> o_O

[17:24] <timotimo> star: use NativeCall; my $arr = CArray[int8].new; $arr[10] = 0; .say for $arr

[17:24] <camelia> star-m 2015.03: OUTPUT«IntTypedCArray[int8].new()␤»

[17:24] <timotimo> star: use NativeCall; my $arr = CArray[int8].new; $arr[10] = 0; $arr[$_].say for ^10;

[17:24] <camelia> star-m 2015.03: OUTPUT«0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤»

[17:24] <timotimo> star: use NativeCall; my $arr = CArray[int8].new; $arr[10] = 0; $arr[$_].say for ^20;

[17:24] <camelia> star-m 2015.03: OUTPUT«0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤»

[17:25] <timotimo> star: use NativeCall; my $arr = CArray[int8].new; $arr[10] = 0; $arr[1000 + $_].say for ^100;

[17:25] <camelia> star-m 2015.03: OUTPUT«0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤…»

[17:25] <timotimo> hehe

[17:25] <timotimo> star: use NativeCall; my $arr = CArray[int8].new; $arr[10] = 0; $arr[1000000 + $_].say for ^100;

[17:25] <camelia> star-m 2015.03: OUTPUT«0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤…»

[17:25] <timotimo> star: use NativeCall; my $arr = CArray[int8].new; $arr[10] = 0; $arr[10000000000 + $_].say for ^100;

[17:25] <abraxxa> note that I use :=

[17:25] <camelia> star-m 2015.03: OUTPUT«0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤…»

[17:25] <timotimo> yes, but i use $ instead of @

[17:25] <timotimo> so this doesn't let us access random memory areas

[17:25] <timotimo> it probably does a bounds check and returns 0 if it's oob

[17:26] <timotimo> anyway, i gotta go AFK, do some grocery shopping and cooking

[17:26] <abraxxa> ok, thanks

[17:26] *** Ven left
[17:26] <abraxxa> although I didn't graps the difference between $ary = and @ary :=

[17:27] <timotimo> for one, @foo = ... is list assignment, so you might end up with a list containing the CArray as its only element; if not, it'll likely try to grab the list inside the CArray and put its values into the array

[17:28] <timotimo> with := you replace the array completely

[17:28] *** pierrot left
[17:28] <timotimo> m: use NativeCall; my @foo = CArray[int8].new(1, 2, 3); say @foo.WHAT; say @foo[0].WHAT;

[17:28] <camelia> rakudo-moar 90e4da: OUTPUT«Default constructor for 'IntTypedCArray[int8]' only takes named arguments␤  in block <unit> at /tmp/Z0Uzrg509X:1␤␤»

[17:28] <timotimo> m: use NativeCall; my @foo = CArray[int8].new(); say @foo.WHAT; say @foo[0].WHAT;

[17:28] <camelia> rakudo-moar 90e4da: OUTPUT«(Array)␤(IntTypedCArray[int8])␤»

[17:28] <timotimo> there we go

[17:28] * timotimo AFK

[17:29] <abraxxa> why not my CArray[int8] @foo;?

[17:29] <abraxxa> m: use NativeCall; my CArray[int8] @foo; say @foo.WHAT;

[17:29] <camelia> rakudo-moar 90e4da: OUTPUT«(Array[IntTypedCArray[int8]])␤»

[17:29] <abraxxa> unexpected!

[17:30] <abraxxa> isn't CArray a subtype of Array?

[17:30] *** tokuhiro_ joined
[17:32] <japhb> m: use NativeCall; my CArray[int8] $foo; say $foo.WHAT;

[17:32] <camelia> rakudo-moar 90e4da: OUTPUT«(IntTypedCArray[int8])␤»

[17:32] <japhb> abraxxa: ^^

[17:33] <abraxxa> ah, typo, thanks!

[17:33] <japhb> abraxxa: You declared an array of CArrays.

[17:33] <abraxxa> so @ instead of $ is nothing else as wrapping the type in Array[]?

[17:34] <japhb> Well, it vivifies to one.  But really the @ twigil is a constraint.

[17:34] *** tokuhiro_ left
[17:34] <[Coke]> m: my ($,$a,$) = 1,2,3; say $a; # timotimo - even here?

[17:34] <camelia> rakudo-moar 90e4da: OUTPUT«2␤»

[17:35] <japhb> abraxxa: And 'my Bar @foo' declares that you want an array-like thing containing Bar elements

[17:35] <japhb> m: my @foo = 1, 2, 3; say @foo.^roles;

[17:35] <camelia> rakudo-moar 90e4da: OUTPUT«Method 'iterator' must be implemented by Iterable because it is required by a role␤  in any compose_method_table at src/gen/m-Metamodel.nqp:2666␤  in any apply at src/gen/m-Metamodel.nqp:2676␤  in any compose at src/gen/m-Metamodel.nqp:2812␤  in an…»

[17:35] <japhb> m: my @foo = 1, 2, 3; say @foo.^roles>>.name;

[17:35] <camelia> rakudo-moar 90e4da: OUTPUT«Method 'name' not found for invocant of class 'Positional'␤  in block <unit> at /tmp/sroFYNmsWB:1␤␤»

[17:36] <japhb> m: my @foo = 1, 2, 3; say @foo.^roles>>.^name;

[17:36] <camelia> rakudo-moar 90e4da: OUTPUT«List␤»

[17:36] <japhb> hmmm

[17:36] <skaji> Hi, I have a question about types.

[17:36] <japhb> Either there is still some fixup to do in the metamodel post-GLR, or my metamodel skills have become very out of date.

[17:37] <skaji> perl6 -e 'sub test(Positional) { say "called" } my $f = gather for ^5 { take }; test($f)'

[17:37] <skaji> prints "called".

[17:37] <skaji> But $f is of type Seq, and Seq ~~ Positional is False. Why does test($f) dispatch test(Positional) subroutine? 

[17:38] *** Ven joined
[17:39] <timotimo> coke, have a look at the --target=ast to find out

[17:39] <skaji> m: sub test(Positional) { say "called" }; my $f = gather for ^5 { take }; test($f);

[17:39] <camelia> rakudo-moar 90e4da: OUTPUT«called␤»

[17:41] <dha> Could someone take a quick look at this and let me know if it's good enough to slot into the docs (documentation for C<for>)?

[17:41] <dha> https://gist.github.com/dha/d8ab9b8cf852d358bfaf

[17:42] <skids> There's something wrong with MMD in that respect I think, I had to work around similar issues when doing slice = sequence code.

[17:42] <skids> And others have noted something funny going on but no golfs or bisects yet.

[17:43] <skids> (wrt test(Positional))

[17:44] <skids> m: sub test(Positional) { say "called" }; my $f = gather for ^5 { take }; $f.WHAT.say; say $f ~~ Positional; test($f);

[17:45] <camelia> rakudo-moar 90e4da: OUTPUT«(Seq)␤False␤called␤»

[17:45] *** yqt left
[17:46] <skids> m: sub test(Positional $a) { $a.WHAT.say; say "called" }; my $f = gather for ^5 { take }; $f.WHAT.say; say $f ~~ Positional; test($f);

[17:46] <camelia> rakudo-moar 90e4da: OUTPUT«(Seq)␤False␤(List)␤called␤»

[17:46] <skids> m: sub test(Positional \a) { a.WHAT.say; say "called" }; my $f = gather for ^5 { take }; $f.WHAT.say; say $f ~~ Positional; test($f);

[17:46] <camelia> rakudo-moar 90e4da: OUTPUT«(Seq)␤False␤(List)␤called␤»

[17:46] <FROGGS> dbron_: I say that we attempt it, but tbh I doubt we will have a RC ready in time...

[17:48] <_itz> japhb: see scrollback from a few hrs back

[17:48] <_itz> re: metamodel

[17:50] * colomon has managed to once again forget how to .grep all strings that DON’T match a regex.

[17:51] <FROGGS> m: say <foo bar baz quux>.grep(* !~ /a/)

[17:51] <camelia> rakudo-moar 90e4da: OUTPUT«5===SORRY!5=== Error while compiling /tmp/cjpruPyvSK␤Unsupported use of !~ to do negated pattern matching; in Perl 6 please use !~~␤at /tmp/cjpruPyvSK:1␤------> 3say <foo bar baz quux>.grep(* !~ 7⏏5/a/)␤»

[17:51] <FROGGS> m: say <foo bar baz quux>.grep(* !~~ /a/)

[17:51] <camelia> rakudo-moar 90e4da: OUTPUT«5===SORRY!5=== Error while compiling /tmp/CwdZxoaqi6␤Variable '&infix:<!~~>' is not declared␤at /tmp/CwdZxoaqi6:1␤------> 3say <foo bar baz quux>.grep(* 7⏏5!~~ /a/)␤»

[17:51] <FROGGS> m: say <foo bar baz quux>.grep({$_ !~~ /a/})

[17:51] <camelia> rakudo-moar 90e4da: OUTPUT«(foo quux)␤»

[17:51] <FROGGS> colomon: ^^

[17:51] <colomon> FROGGS++ 

[17:51] * colomon was just about to try that.  it always seems too long, somehow….

[17:52] <colomon> m: say <foo bar baz quux>.grep(* !~~ /a/)

[17:52] <camelia> rakudo-moar 90e4da: OUTPUT«5===SORRY!5=== Error while compiling /tmp/aE6reeski3␤Variable '&infix:<!~~>' is not declared␤at /tmp/aE6reeski3:1␤------> 3say <foo bar baz quux>.grep(* 7⏏5!~~ /a/)␤»

[17:52] <colomon> ah, FROGGS++ again

[17:53] <skids> (* ~~ /a/).WHAT.say; (* !~~ /a/).WHAT.say

[17:53] <skids> m: (* ~~ /a/).WHAT.say; (* !~~ /a/).WHAT.say

[17:53] <camelia> rakudo-moar 90e4da: OUTPUT«5===SORRY!5=== Error while compiling /tmp/IlsFSTLp3g␤Variable '&infix:<!~~>' is not declared␤at /tmp/IlsFSTLp3g:1␤------> 3(* ~~ /a/).WHAT.say; (* 7⏏5!~~ /a/).WHAT.say␤»

[17:53] <skids> m: (* ~~ /a/).WHAT.say;

[17:53] <camelia> rakudo-moar 90e4da: OUTPUT«(WhateverCode)␤»

[17:54] <abraxxa> is there any difference between Pointer and Pointer[void]?

[17:54] <FROGGS> abraxxa: no

[17:54] <abraxxa> FROGGS: i guessed so, thanks

[17:55] <abraxxa> what's the reason to support the later and even document it?

[17:56] <FROGGS> the reason to support Pointer[void]? it just happened to work so we can disallow using the value of a void pointer directly... and it is more explicit which can be nice

[17:57] <abraxxa> ok

[17:57] <skaji> skids: Thanks. Is Seq actually composed by Positional?

[17:57] <skids> m: my $a = Int; Array[$a].new().perl.say # that would be a reason though it likely won't work for Pointer/natives yet.

[17:57] <camelia> rakudo-moar 90e4da: OUTPUT«Array[Int].new()␤»

[17:57] <abraxxa> OCI seems to fill the memory the pointer points to with something, at least it's 0 before and crap after the call

[17:59] * abraxxa wants proper unsigned native types

[17:59] <dha> Are there currently improper ones?

[17:59] <abraxxa> dha: they are typed ones

[18:00] <skids> skaji: Seq is specifically not Positional IIRC, but it does allow postcircumfix:<[]>, which was not until recently, and before that only Positional did that, so maybe something got a little haywired.

[18:00] <dha> Ah.

[18:00] <abraxxa> say; results in Unhandled exception: Cannot unbox a type object instead of printing a linefeed

[18:02] <abraxxa> an exception occuring inside a for loop prints the line number of the for loop beginning

[18:03] <japhb> _itz: thank you for the Metamodel issues pointer

[18:03] <japhb> .ask jnthn What did you mean by "Maybe .gist needs to go in the no-pun list."?

[18:03] <yoleaux> japhb: I'll pass your message to jnthn.

[18:04] *** Ven left
[18:06] <skids> skaji: I think the problem is that :(Positional) does the same thing that :(@a) does, actually, and manages to turn the Seq into a list, because... MAGIC!

[18:07] <skids> m: sub test(\a where Positional) { a.WHAT.say; say "called" }; my $f = gather for ^5 { take }; $f.WHAT.say; say $f ~~ Positional; test($f);

[18:07] <camelia> rakudo-moar 90e4da: OUTPUT«(Seq)␤False␤Constraint type check failed for parameter 'a'␤  in sub test at /tmp/QDGsWprplx:1␤  in block <unit> at /tmp/QDGsWprplx:1␤␤»

[18:08] <skids> But, I've seen that also fail to work, specifically on invocants.

[18:09] *** leont joined
[18:09] <skaji> Oh, sub test(\a where Positional) failed!

[18:11] *** telex left
[18:11] <FROGGS> the jvm build is fun somehow:

[18:11] <FROGGS> $ ./perl6-j -e 'enum Foo <foo bar baz>'

[18:11] <FROGGS> ===SORRY!===

[18:11] <FROGGS> Method 'role_typecheck_list' not found for invocant of class 'NQPClassHOW'

[18:12] *** sjn_phone_ joined
[18:12] *** espadrine left
[18:12] *** telex joined
[18:13] <abraxxa> i give up, it just doesn't work

[18:13] <FROGGS> :/

[18:16] <abraxxa> i can get the data type, the column name length but just not the column name itself

[18:17] *** tokuhiro_ joined
[18:18] <FROGGS> abraxxa: can you show me the code?

[18:19] <abraxxa> FROGGS: https://github.com/abraxxa/DBIish/blob/master/lib/DBDish/Oracle.pm6#L558

[18:19] <abraxxa> i've pushed what I have so far

[18:19] *** sjn_phone_ left
[18:19] <skaji> skids: I understand Positional type checking is a little weird now. Thanks a lot!

[18:20] <skids> skaji: yes that's a workaround, but it may break if you try it on invocants.  I haven't got a handle on what is going on there yet.

[18:20] <skids> np

[18:22] *** tokuhiro_ left
[18:22] <skids> skaji: do note that 'where constraint' clauses are definition-order-dependent and have a diffent place in the MMD pecking order.

[18:22] *** dbron_ left
[18:24] <FROGGS> abraxxa: why do you pass it a CArray[int8]?

[18:28] <skaji> m: sub test($ where Positional) {}; sub test(Positional) {};

[18:28] <camelia> rakudo-moar 90e4da: OUTPUT«5===SORRY!5=== Error while compiling /tmp/HVpEXUmM3K␤Redeclaration of routine test␤at /tmp/HVpEXUmM3K:1␤------> 3 Positional) {}; sub test(Positional) {}7⏏5;␤    expecting any of:␤        horizontal whitespace␤»

[18:28] * timotimo returns

[18:29] *** ab5tract_ joined
[18:30] <ab5tract_> |Tux|: Impressive :D

[18:30] <timotimo> dha: is "use the arrow" with precedent in the docs? if not, i'd rather have it refered to as "a pointy block"

[18:30] <ab5tract_> But that sounds quite frustrating :)

[18:31] <skids> m: multi sub test($ where Positional) {}; multi sub test(Positional) {};

[18:31] <camelia> rakudo-moar 90e4da: ( no output )

[18:31] <dha> timotimo - I can certainly do that. Although I think pointy blocks remain undocumented.

[18:31] <skaji> skids: oh, sorry.

[18:31] <timotimo> dha: also, it would probably have been better to use the "edit" function rather than write a comment, because it does strange things with C<for> and @foo in comments

[18:32] * ab5tract_ realizes that Convos++ does not currently demarcate between "cached stuff from hours ago" and "right now"

[18:32] <timotimo> and the thing about "lazily by default" sounds strange

[18:32] <dha> Yeah, I didn't notice that at first.

[18:33] <timotimo> so in the comment it now reads "The C Loop"

[18:33] <timotimo> we also have a c-style loop, so that's very confusing at first glance :D

[18:33] <abraxxa> FROGGS: i need to get the bytes for a utf-8 encoded text, the length in bytes is returned in the var after that

[18:33] <dha> FWIW, "lazily by default" comes from existing docs. specifically, 5to6.pod

[18:34] <timotimo> mhm

[18:34] <dha> timotimo - will look to fix that in the gist. thanks.

[18:34] <timotimo> let me have a closer look

[18:34] <timotimo> hm

[18:35] <timotimo> it's kinda weird to write ti like that, because perl5 doesn't really have the same kind of "lazy list" that perl6 does

[18:35] <dha> Well, that's the point, isn't it? That it's *now* lazy, so you would use C<for> instead of C<while>

[18:36] <timotimo> also, while lines() would just run once

[18:36] <FROGGS> abraxxa: hmmm, I'd try passing it a CArray[Pointer[Str]], and then 'say @col_name[0].deref'

[18:36] <timotimo> m: while lines() { say "boing" }

[18:36] <camelia> rakudo-moar 90e4da: OUTPUT«boing␤boing␤boing␤boing␤boing␤boing␤boing␤boing␤boing␤boing␤boing␤boing␤boing␤boing␤boing␤boing␤boing␤boing␤boing␤boing␤»

[18:36] <timotimo> actually, seems like no.

[18:36] <timotimo> m: while lines() -> $_ { say $_.elems }

[18:36] <camelia> rakudo-moar 90e4da: OUTPUT«20␤eof requires an object with REPR MVMOSHandle␤  in block <unit> at /tmp/0Suy4Ariam:1␤␤»

[18:36] *** mprelude joined
[18:36] <timotimo> whoops

[18:36] <FROGGS> :D

[18:36] <timotimo> m: lines(); lines();

[18:36] <camelia> rakudo-moar 90e4da: OUTPUT«eof requires an object with REPR MVMOSHandle␤  in block <unit> at /tmp/RTZmsoJDfC:1␤␤»

[18:36] <FROGGS> timotimo++

[18:36] <timotimo> that's the golf, it seems

[18:37] <timotimo> of course lines() without doing anything to it (like say "boing") won't actually eat any of the lines

[18:37] <abraxxa> FROGGS: trying

[18:37] <timotimo> this may be another place where ARGFILES isn't sufficiently like a regular file handle

[18:38] <FROGGS> abraxxa: note that the param just need to be CArray[Pointer]

[18:38] <dha> Granted, I took the code examples from 5to6.pod, so if they're wrong there, they'll be wrong in my doc. :-/

[18:39] <abraxxa> FROGGS: still my favorite exception: Unhandled exception: Cannot unbox a type object

[18:41] <FROGGS> abraxxa: did you @col_name[0].=new?

[18:41] <abraxxa> FROGGS: @col_name[0] = Pointer[Str];

[18:41] <FROGGS> abraxxa: no

[18:41] <FROGGS> abraxxa: you need an instance, not a type object

[18:42] <abraxxa> my @col_name := CArray[Pointer[Str]].new;

[18:42] <FROGGS> almost

[18:42] <FROGGS> m: use NativeCall; my CArray[Pointer[Str]] @col_name; @col_name[0].=new;

[18:43] <camelia> rakudo-moar 90e4da: ( no output )

[18:43] <FROGGS> m: use NativeCall; my CArray[Pointer[Str]] @col_name; @col_name[0].=new; say @col_name

[18:43] <camelia> rakudo-moar 90e4da: OUTPUT«[TypedCArray[Pointer].new]␤»

[18:43] <FROGGS> m: use NativeCall; my CArray[Pointer[Str]] @col_name; @col_name[0].=new; say @col_name[0]

[18:43] <camelia> rakudo-moar 90e4da: OUTPUT«TypedCArray[Pointer].new␤»

[18:43] <FROGGS> m: use NativeCall; my CArray[Pointer[Str]] @col_name; @col_name[0].=new; say @col_name[0].deref

[18:43] <camelia> rakudo-moar 90e4da: OUTPUT«Method 'deref' not found for invocant of class 'TypedCArray[Pointer]'␤  in block <unit> at /tmp/iSS9MUMGrz:1␤␤»

[18:43] <FROGGS> m: use NativeCall; my CArray[Pointer[Str]] @col_name; @col_name[0] = Pointer[Str].new; say @col_name[0].deref

[18:43] <camelia> rakudo-moar 90e4da: OUTPUT«Type check failed in assignment to '@col_name'; expected 'TypedCArray[Pointer]' but got 'Pointer'␤  in block <unit> at /tmp/TK8AeLoT1Y:1␤␤»

[18:43] <FROGGS> m: use NativeCall; my CArray[Pointer] @col_name; @col_name[0] = Pointer[Str].new; say @col_name[0].deref

[18:43] <camelia> rakudo-moar 90e4da: OUTPUT«Type check failed in assignment to '@col_name'; expected 'TypedCArray[Pointer]' but got 'Pointer'␤  in block <unit> at /tmp/usknrEhTH6:1␤␤»

[18:44] <FROGGS> hmpf

[18:44] *** rurban joined
[18:44] <FROGGS> m: use NativeCall; my CArray[Pointer] $col_name.=new; $col_name[0] = Pointer[Str].new; say $col_name[0].deref

[18:44] <camelia> rakudo-moar 90e4da: OUTPUT«(Str)␤»

[18:45] <FROGGS> abraxxa: I'd do that and get rid of the @-sigils

[18:45] <abraxxa> FROGGS: gladly!

[18:46] <FROGGS> psch: araund?

[18:46] <FROGGS> around*

[18:46] <abraxxa> cannot unbox...

[18:46] <FROGGS> abraxxa: can you push?

[18:46] *** yqt joined
[18:47] *** domidumont joined
[18:47] <masak> wow, this is nice: ttp://okmij.org/ftp/Perl/Scheme-in-Perl.txt

[18:47] * masak wishes mvuets were on this channel so he would pass it on

[18:48] *** vendethiel joined
[18:48] * pink_mist hands masak a missing 'h'

[18:48] <FROGGS> pink_mist: nono, that's French

[18:48] <FROGGS> 'ttp

[18:48] <pink_mist> d'oh lala

[18:49] <masak> ah, 'm sorry

[18:49] <masak> http://okmij.org/ftp/Perl/Scheme-in-Perl.txt

[18:50] *** rurban left
[18:50] <abraxxa> FROGGS: a missing ; lead to the error

[18:50] <FROGGS> ohh

[18:52] <psch> FROGGS: semi-around, yeah

[18:52] <psch> FROGGS: i have some room to pay attention, though :)

[18:52] <abraxxa> FROGGS: after the call say $col_name[0].deref; triggers Internal error: unhandled target type

[18:52] <abraxxa>   in sub nativecast at lib/NativeCall.pm:433

[18:52] <abraxxa>   in method deref at lib/NativeCall.pm:102

[18:52] <FROGGS> psch: what would you do here? $ ./perl6-j -e 'enum Foo <foo bar baz>'

[18:52] <FROGGS> ===SORRY!===

[18:52] <FROGGS> Method 'role_typecheck_list' not found for invocant of class 'NQPClassHOW'

[18:53] <FROGGS> abraxxa: can you push?

[18:54] <psch> FROGGS: uh... probably look who calls that method on a NQPClassHOW and why that should or shouldn't happen... :)

[18:54] <FROGGS> hmpf

[18:54] <FROGGS> :o)

[18:55] <abraxxa> FROGGS: pushed

[18:55] <psch> FROGGS: i'm really confused by 376d7273bb344ec63ec1469846e4ef63fce45f57, fwiw

[18:55] <psch> FROGGS: the check for SIG_ELEM_SLURPY_POS seems logically reversed to the equiv spot in BOOTSTRAP.nqp

[18:55] <psch> FROGGS: but turning it around gives a StackOverflowError...

[18:56] <psch> Metamodel/BOOTSTRAP.nqp:724 is what i'm comparing it to

[18:57] <abraxxa> FROGGS: that's how the pointer is passed in C: (dvoid**) &col_name

[18:57] *** xfix joined
[18:57] *** xfix left
[18:57] *** xfix joined
[18:58] <FROGGS> abraxxa: yes, that would fit... though I cant explain the error you get

[18:58] <FROGGS> psch: hmmmm, interesting

[18:59] <psch> FROGGS: Binder hunches! :P

[18:59] <abraxxa> FROGGS: i guess what is missing is the encoding so it can decode from Buf to Str

[19:00] <FROGGS> abraxxa: no, the error message indicates that it does not know what Str is, which is weird in many ways

[19:01] <abraxxa> comes from sub nativecast in NativeCall.pm

[19:04] <abraxxa> FROGGS: i also tried Str is rw but that results in a segfault, i guess because no memory is reserved

[19:04] <FROGGS> abraxxa: can you just print $col_name[0]?

[19:06] <abraxxa> FROGGS: Pointer<0x8a99178>

[19:07] <abraxxa> why use a CArray[Pointer[Str]] and not Pointer[Pointer[Str]]?

[19:08] <FROGGS> abraxxa: and now print: nativecase(Str, $col_name[0])

[19:08] <FROGGS> abraxxa: dunno... might also "work" (for some definition of work, since it doesnt work yet)

[19:08] <abraxxa> UNBELIEVEABLE!!!

[19:08] <abraxxa> the column names

[19:09] <FROGGS> \o/

[19:09] <abraxxa> how does it know how to decode?

[19:09] <FROGGS> abraxxa: it defaults to utf8

[19:09] <FROGGS> abraxxa: but you can apply a trait called 'is encoded' or so

[19:09] <abraxxa> can it be set explicitly?

[19:10] <abraxxa> ämount works too ;)

[19:10] <FROGGS> and btw, 'Str is rw' won't give you a char** AFAIK, so that's why you get a segfault there

[19:10] <FROGGS> :o)

[19:11] *** zakharyas joined
[19:11] <FROGGS> psch: I turned it around and build it now...

[19:11] <FROGGS> psch: it survived the setting...

[19:11] *** rurban joined
[19:12] <FROGGS> psch: but that would certainly explain the failure modes I see

[19:12] <psch> FROGGS: nom and with your patch both threw StackOverflowError in Pod::To::Text iirc

[19:12] <FROGGS> psch: sadly not... :o(  I can build it, but it fails as usual

[19:13] <abraxxa> FROGGS: i don't get why we need two pointers here, can you explain that please?

[19:13] <psch> huh?

[19:13] <FROGGS> psch: I'm able to build Pod::To::Text fwiw

[19:13] <abraxxa> FROGGS: and why doesn't it require the length that's passed back as well?

[19:14] <psch> FROGGS: and it's still bailing with the same un-flat @tags?

[19:14] <FROGGS> abraxxa: you allocate a piece of mem to let the function store a value there, right? and it will store a char*

[19:14] <FROGGS> abraxxa: so you end up having a char**

[19:14] <abraxxa> char* is an array of chars?

[19:15] <abraxxa> where one char is one byte, not one character?

[19:15] *** rurban left
[19:15] <FROGGS> psch: ohh! that fixes the flat() bug it seems!

[19:16] <FROGGS> abraxxa: aye, given that C does not know what a character is

[19:16] <dha> So, you've flat()tened that bug?

[19:16] * dha hides

[19:17] <FROGGS> :D

[19:18] <psch> FROGGS: curious.  as mentioned, for me it ran into StackOverflowErrors... but i guess your gist from yesterday isn't up-to-date with your current working state

[19:18] <FROGGS> psch: I was able to work around the unflat @tags by changing 'flat a, b' to 'a, |b'

[19:18] <FROGGS> aye

[19:25] *** domidumont left
[19:31] *** thou joined
[19:34] <abraxxa> FROGGS: and what i had before was just a char*?

[19:35] <abraxxa> and the values where memory addresses?

[19:35] <abraxxa> or parts of one memory address

[19:36] <[Tux]> which operation returns a (.....).Seq ?

[19:36] <abraxxa> FROGGS: does that declaration make a difference? CArray[Pointer[Str]] $attributep is encoded('utf8'),

[19:38] <pink_mist> thought utf8 was already the default

[19:38] *** cognominal left
[19:38] <abraxxa> it is but OCI also allows UTF-16 and if that's what I need to use for whatever reason I'd like to find all places where I have to change the encoding

[19:39] <FROGGS> abraxxa: before you got the char* back split across 8 slots of the CArray[int8] most likely

[19:40] <FROGGS> abraxxa: yes, I think that signature is correct

[19:40] <abraxxa> and how does it know the length? null terminated?

[19:40] <FROGGS> psch: do you want to push your gotcha?

[19:40] <FROGGS> psch: it really solved the flat() bug

[19:40] <FROGGS> abraxxa: aye

[19:41] <nine> Seqs dispatching on Positional is intentional

[19:41] <[Tux]> «return [ @in.map (-> @r { $%( @h Z=> @r ) }) ];» used to return [[< a b c>], [1,2,3], ...] but after GLR returns [[<a b c>], ([1,2,3],...).Seq]

[19:41] <nine> Same as assigning Seq to Positional doing the right thing

[19:41] <[Tux]> is that intentional?

[19:43] <nine> m: my @a = <a b c>; my @b = 1, 2, 3; say (@a Z=> @b).perl;

[19:43] <camelia> rakudo-moar 90e4da: OUTPUT«(:a(1), :b(2), :c(3)).Seq␤»

[19:43] <psch> FROGGS: it didn't seem to fix anything when applied to nom HEAD, so feel free to group it with your other fixes

[19:43] <nine> m: my @a = <a b c>; my @b = 1, 2, 3; say ($%(@a Z=> @b)).perl;

[19:43] <camelia> rakudo-moar 90e4da: OUTPUT«{:a(1), :b(2), :c(3)}␤»

[19:44] <jnthn> skaji: We simultaneously wanted to be clear about what are consumable produces of values and also allow a sub foo(@x) { } to be called on something like foo(@a.grep(...)). Seq itself can't be sanely Positional because you only get one shot at the values. 

[19:44] <yoleaux> 18:03Z <japhb> jnthn: What did you mean by "Maybe .gist needs to go in the no-pun list."?

[19:44] <FROGGS> psch: k, will do

[19:44] <jnthn> skaji: So we notice the types didn't match, and then fail over to binding the result of Seq.list; this actually memoizes the list it returns too

[19:45] <jnthn> skaji: We actually have a role (PositionalBindFailover) that marks out Seq and HyperSeq as the types that have this behavior.

[19:46] <jnthn> .tell japhb Normally if you call a method on a role then we pun it into a class and call the method on the pun; there's a small list of exceptions.

[19:46] <yoleaux> jnthn: I'll pass your message to japhb.

[19:47] <jnthn> |Tux|: .map returns a Seq after GLR

[19:47] <[Tux]> just add .list at the end or something like that?

[19:48] <skids> jnthn: down the road are we likely to be able to (/will we want to) discriminate between (Positional $foo) and (@foo) for PositionalBindFailover?

[19:49] <mohij> Is there a dynamic variable telling the exact version of perl6 (the thing perl6 -v reports)?

[19:49] <yoleaux> 05:01Z <tadzik> mohij: I'd be delighted :) Can you send me a PR?

[19:50] <timotimo> m: say $*VM.version

[19:50] <camelia> rakudo-moar 90e4da: OUTPUT«v2015.7.108.g.7.e.9.f.29.e␤»

[19:50] <FROGGS> m: say $*PERL.compiler.version

[19:50] <camelia> rakudo-moar 90e4da: OUTPUT«v2015.7.1.768.g.90.e.4.dab␤»

[19:50] <jnthn> [Tux]: If you actually want a List, yes

[19:50] <FROGGS> mohij: ^^

[19:50] <timotimo> oh, right, VM.version is the moarvm version

[19:50] <jnthn> skids: We don't at the moment; I don't see a strong reason to

[19:50] <[Tux]> .list still leaves in the ()

[19:50] <nine> skids: if you add a candidate that takes a PositionalBindFailover, it will probably bind more strongly than Positional

[19:51] <FROGGS> [Tux]: then you perhaps want .Slip

[19:51] <skids> nine: that was my only reason to want to, so if that works... but isn't it just a role too?

[19:51] <mohij> Thanks!

[19:51] <FROGGS> psch: damn, now I get the StackOverflowError too :o(

[19:52] <skids> nine: OIC, I'll try that sometime.

[19:52] <FROGGS> psch: but rerunning that single line made it pass -.-

[19:52] <jnthn> Generally you just want to take Iterable :)

[19:52] <nine> m: multi sub foo(PositionalBindFailover $a) { say "Seq"; }; multi sub foo(Positional $a) { say "Array"; }; foo((1,2,3).map({$_}));

[19:52] <camelia> rakudo-moar 90e4da: OUTPUT«Ambiguous call to 'foo'; these signatures all match:␤:(PositionalBindFailover $a)␤:(Positional $a)␤  in block <unit> at /tmp/j9f8xBJ2lc:1␤␤»

[19:53] <nine> Funny. Locally this works

[19:54] <[Tux]> This Seq has already been iterated, and its values consumed

[19:54] <nine> Oh, I don't have the dispatcher fix yet

[19:54] <skids> jnthn: not when choosing an implementation that differs based on whether "user expects it to be memoized anyway."

[19:54] <dalek> rakudo/UnbreakJVMBuildFactory: 7315a8a | FROGGS++ | src/core/Variable.pm:

[19:54] <dalek> rakudo/UnbreakJVMBuildFactory: flatten export trait list, like we do for Routines

[19:54] <dalek> rakudo/UnbreakJVMBuildFactory: review: https://github.com/rakudo/rakudo/commit/7315a8aa8c

[19:54] <mohij> .tell tadzik PR is out. Windows testing now...

[19:54] <yoleaux> mohij: I'll pass your message to tadzik.

[19:55] <dalek> rakudo/UnbreakJVMBuildFactory: 1c313d2 | FROGGS++ | src/core/Inc.pm:

[19:55] <dalek> rakudo/UnbreakJVMBuildFactory: box -I string, we'll .split it later

[19:55] <dalek> rakudo/UnbreakJVMBuildFactory: review: https://github.com/rakudo/rakudo/commit/1c313d28cb

[19:56] <mohij> Poll for Windows users: How do you develop and deploy Perl6 on Windows? What would your ideal develop/deploy workflow look like?

[19:56] <dalek> rakudo/UnbreakJVMBuildFactory: 91b7725 | FROGGS++ | src/vm/jvm/runtime/org/perl6/rakudo/Binder.java:

[19:56] <dalek> rakudo/UnbreakJVMBuildFactory: psch++, align JVM's slurp/slurp-flat code to moar's

[19:56] <dalek> rakudo/UnbreakJVMBuildFactory: review: https://github.com/rakudo/rakudo/commit/91b7725815

[19:57] <FROGGS> mohij: I dunno... deploy an msi?

[19:57] <mohij> how would you update? Do you need more than one version installed?

[19:58] <jnthn> skids: Do you have a concrete use case?

[19:58] <mohij> *version of perl6

[19:58] <FROGGS> mohij: more than one version of rakudo? usually not

[19:58] <FROGGS> mohij: upgrade would mean to run a newer msi, hopefully it would not replace my panda state, so I could rebootstrap

[19:58] <jnthn> skids: My gut feeling is trying to deal with something other than Iterable or Positional is kinda odd

[19:59] <jnthn> e.g. you typically want to iterate over the thing *or* index into the thing

[19:59] <psch> FROGGS: hm, the SOE was consistent for me, no matter if called from make or manually via the CLI...

[19:59] <FROGGS> psch: it was the first time I'd seen it

[19:59] <psch> i had played with raising Xss to ridiculous values, but that just kept eating memory...

[20:00] <psch> FROGGS: maybe your other changes push it somewhere less deterministic... :/

[20:00] <FROGGS> psch: yeah, I had quite some more say statements... and the SO appeared after removing them

[20:03] <skids> m:  perl6 -e 'multi sub a (Iterable $a) { 42.say; a($a.list) }; multi sub a (@a) { 43.say }; multi sub a ($scalar) { 44.say }; a((1,2,2,3).grep(2));'

[20:03] <camelia> rakudo-moar 90e4da: OUTPUT«5===SORRY!5=== Error while compiling /tmp/Yy9GNwTZ0x␤Two terms in a row␤at /tmp/Yy9GNwTZ0x:1␤------> 3perl6 -e7⏏5 'multi sub a (Iterable $a) { 42.say; a(␤    expecting any of:␤        infix␤        infix stopper␤        postfix␤  …»

[20:03] <skids> m:  perl6 -e 'multi sub a (PositionalBindFailover $a) { 42.say; a($a.list) }; multi sub a (@a) { 43.say }; multi sub a ($scalar) { 44.say }; a((1,2,2,3).grep(2));'

[20:03] <camelia> rakudo-moar 90e4da: OUTPUT«5===SORRY!5=== Error while compiling /tmp/CgiHw7FzIN␤Two terms in a row␤at /tmp/CgiHw7FzIN:1␤------> 3perl6 -e7⏏5 'multi sub a (PositionalBindFailover $a␤    expecting any of:␤        infix␤        infix stopper␤        postfix␤  …»

[20:03] <skids> oops.

[20:03] <skids> m:  multi sub a (PositionalBindFailover $a) { 42.say; a($a.list) }; multi sub a (@a) { 43.say }; multi sub a ($scalar) { 44.say }; a((1,2,2,3).grep(2)); # this one works

[20:03] <camelia> rakudo-moar 90e4da: OUTPUT«Ambiguous call to 'a'; these signatures all match:␤:(PositionalBindFailover $a)␤:(@a)␤  in block <unit> at /tmp/4Pq2IrL1r2:1␤␤»

[20:04] <skids> m:  multi sub a (Iterable $a) { 42.say; a($a.list) }; multi sub a (@a) { 43.say }; multi sub a ($scalar) { 44.say }; a((1,2,2,3).grep(2)); 

[20:04] <camelia> rakudo-moar 90e4da: OUTPUT«X::Multi::Ambiguous exception produced no message␤  in block <unit> at /tmp/R0LkU1wES6:1␤␤»

[20:04] <skids> So, nine++

[20:04] <FROGGS> psch: I recompiled the setting and there is still no SOE

[20:05] <psch> FROGGS: during Pod::To::Text is where i saw it usually

[20:05] <FROGGS> psch: and it also seems like the next-in-split-hack isnt needed anymore

[20:05] <psch> FROGGS: as in, only there, actually

[20:05] <FROGGS> psch: aye, it compiled P2T and exploded in NativeCall

[20:05] *** dha left
[20:06] <skids> Oh weird, that frst one worked locally.  I must be behind.

[20:06] <abraxxa> is there an int64 or is long or longlong what i need?

[20:07] *** darutoko left
[20:07] <FROGGS> abraxxa: depends... what *do* you need? there are all of them

[20:07] <abraxxa> signed bytes 8

[20:08] <FROGGS> m: use NativeCall; say int64

[20:08] <camelia> rakudo-moar 90e4da: OUTPUT«(int64)␤»

[20:08] <FROGGS> m: say int64

[20:08] <camelia> rakudo-moar 90e4da: OUTPUT«(int64)␤»

[20:08] <FROGGS> abraxxa: long and longlong are variable in size

[20:08] <abraxxa> the oratypes.h file says: ifdef __LP64__ define orasb8 signed long else define orasb8 signed long long

[20:09] *** dha joined
[20:09] <nine> So you want int64

[20:09] <abraxxa> nine: thanks. can you document it please?

[20:09] <labster> m: say (98/99).base(10, 1)

[20:09] <camelia> rakudo-moar 90e4da: OUTPUT«010.0␤»

[20:10] *** rindolf left
[20:11] *** zakharyas left
[20:12] <dalek> doc: da7dc52 | FROGGS++ | lib/Language/nativecall.pod:

[20:12] <dalek> doc: mention int64, abraxxa++

[20:12] <dalek> doc: review: https://github.com/perl6/doc/commit/da7dc52d32

[20:12] <FROGGS> abraxxa / nine: done

[20:13] <abraxxa> dalek++

[20:13] <abraxxa> oh, dalek seems to be a bot

[20:13] <abraxxa> FROGGS++

[20:13] <mohij> .botsnack

[20:13] <yoleaux> :D

[20:14] <FROGGS> aye, dalek reports commits to github

[20:14] <moritz> .humansnack

[20:15] <moritz> those pesky, unreliable and unresponsive humans... :-)

[20:15] <mohij> .oO(send-me-a-beer-license)

[20:15] <nine> :D

[20:16] <FROGGS> :D

[20:16] <[Tux]> t/90_csv.t .. ok

[20:16] <[Tux]> All tests successful

[20:16] <[Tux]> almost there

[20:16] <skids> nine,jnthn: So that PositionalBindFailover trick worked on 16d366a2 and stopped working sometime thereafter.  FWIW.

[20:16] <FROGGS> nice

[20:17] <jnthn> skids: You sure? 9fdaf03b0a4 is the one I'd have expected to change it, when I fixed the multi-dispatcher.

[20:17] * skids checks.

[20:17] <jnthn> Positional and PositionalBindFailover are going to conflict

[20:17] <jnthn> They have no relationship and so are equally narrow

[20:18] *** tokuhiro_ joined
[20:19] <skids> Oh, I never build that merge, so it must have been earler.

[20:19] * jnthn goes to rest &

[20:19] <skids> 13f829c then

[20:20] *** zoosha left
[20:21] *** zoosha joined
[20:22] *** tokuhiro_ left
[20:22] <FROGGS> jnthn: rest well

[20:24] <[Tux]> http://tux.nl/Files/20150908222424.png

[20:24] *** cognominal joined
[20:24] <[Tux]> rest later

[20:27] * skids should maybe try re-multifying the postcircumfix:<[]> stuff post-MMD changes.

[20:28] <ab5tract_> https://github.com/ab5tract/Terminal-Print/commit/5edd10fe95af6e9c305d50b5c761101729f4bd88

[20:29] <[Tux]> test             50000    54.734    54.647

[20:29] <[Tux]> test-t           50000    54.701    54.614

[20:29] <ab5tract_> ^^ This commit reminded me of the days where I would figure out some kind of unexpected, list related solution and then post it here. The response was always "this will hopefully be better after the GLR"

[20:30] *** Loren left
[20:31] <ab5tract_> It's nice that it's a memory, and even nicer that our hopes were well-founded!

[20:32] <nine> Now we just have to get performance to where it should be :)

[20:33] <ab5tract_> nine: Text::CSV is a good canary for that, but give t/basics.t a spin in Terminal::Print and we have another good candidate for "something that could use speeding up"

[20:33] <tadzik> computer, messages

[20:33] <yoleaux> 19:54Z <mohij> tadzik: PR is out. Windows testing now...

[20:33] <tadzik> mohij: how's it going? :)

[20:34] *** popl joined
[20:34] <popl> congrats on the release everyone

[20:34] <ab5tract_> there is a @colors.pick in there that is quite costly, but even without it .. well, it's a visual representation of some gains we can make :)

[20:34] <mohij> Fine. :-) Hacking rakudobrew lifts the mood quite some. It's a nice thing hacking on.

[20:35] <tadzik> I'm glad to hear that :)

[20:36] <smash> .tell TimToady more interesting combinations http://tweag.github.io/HaskellR/

[20:36] <yoleaux> smash: I'll pass your message to TimToady.

[20:37] <timotimo> popl: what, a release?

[20:37] <mohij> Do you know whether rakudo has something like local::lib built in? Can panda install to a (different) local folder?

[20:38] <masak> popl: not quite there yet ;)

[20:38] <popl> Well, in October apparently.

[20:39] <tadzik> mohij: yeah, panda respects DESTDIR iirc

[20:39] <popl> timotimo: http://perl6releasetalk.ticketleap.com/perl-tech-talk/details is what I am referring to.

[20:39] <popl> *to what I am referring

[20:39] <tadzik> mohij: I'm actually curious if anyone ever used that feature though :)

[20:39] <tadzik> except myself for testing

[20:39] <mohij> halfway to a carton on perl6, yay \o/

[20:41] <masak> popl: that talk is in October. the release is still scheduled (?) for Christmas.

[20:41] <masak> ...but feel free to have a peek at Perl 6 before that! :D

[20:41] <popl> okay then, I retract my congratulations

[20:41] <timotimo> ah

[20:41] <popl> better? :P

[20:42] <timotimo> no worse feeling in the world than being wrongly congratulated!!

[20:42] <popl> apparently

[20:43] <leont> Install destinations is something that will need more attention AFAIK (though I haven't looked at it in detail recently)

[20:43] <ugexe> they exist already

[20:43] <timotimo> is there a good reason against giving CArray a "new" candidate that takes values and constructs itself from them?

[20:44] <ugexe> CompUnitRepo::Local::Installation.new($dist-dir)

[20:44] *** espadrine joined
[20:45] *** popl left
[20:46] <timotimo> m: Buf[int64].new(123456).gist.say

[20:46] <camelia> rakudo-moar 90e4da: OUTPUT«Buf[int64]:0x<1e240>␤»

[20:46] <timotimo> ah, nice.

[20:46] <ab5tract_> timotimo: Maybe we've been waiting on shaped arrays for it?

[20:46] <ugexe> i use it to test install/uninstall without touching rakudos default module locations

[20:47] <timotimo> very unlikely

[20:47] <masak> 'night, #perl6

[20:47] <timotimo> m: Buf[num].new(123456).gist.say

[20:47] <camelia> rakudo-moar 90e4da: OUTPUT«MVMArray: bindpos expected num register␤  in any  at src/gen/m-Metamodel.nqp:1679␤  in block <unit> at /tmp/tR_jBDGgeb:1␤␤»

[20:47] <timotimo> m: Buf[num].new(123456e0).gist.say

[20:47] <camelia> rakudo-moar 90e4da: OUTPUT«This type cannot unbox to a native integer␤  in any  at src/gen/m-Metamodel.nqp:1679␤  in block <unit> at /tmp/NbsSm2n0Ag:1␤␤»

[20:47] <timotimo> interesting

[20:47] <timotimo> buf expects to contain only inty things, but doesn't complain early when being created with nums

[20:48] <timotimo> though we have num arrays

[20:48] <timotimo> m: say 15.5e0.fmt("%02x").say

[20:48] <camelia> rakudo-moar 90e4da: OUTPUT«0f␤True␤»

[20:48] <timotimo> m: 15.5e0.fmt("%02x").say

[20:48] <camelia> rakudo-moar 90e4da: OUTPUT«0f␤»

[20:48] <timotimo> m: 15.5e4.fmt("%02x").say

[20:48] <camelia> rakudo-moar 90e4da: OUTPUT«25d78␤»

[20:48] <timotimo> that's not so happy, eh

[20:49] <timotimo> m: 15.5e4.fmt("%f").say

[20:49] <camelia> rakudo-moar 90e4da: OUTPUT«155000.000000␤»

[20:49] * skids wonders if a convenience for "make a GC-safe buf from the CArray and length parameters coming back from this nativecall" would be awesome, or just end up ugly.

[20:49] <timotimo> m: 15.5e4.fmt("%s").say

[20:49] <camelia> rakudo-moar 90e4da: OUTPUT«155000␤»

[20:49] <japhb> timotimo: Buf is notionally serialized data ready for writing to the wire.  Perhaps it doesn't support non-integers because floating point doesn't have a well-standardized wire format?  Or maybe it's just a NYI.

[20:49] <yoleaux> 19:46Z <jnthn> japhb: Normally if you call a method on a role then we pun it into a class and call the method on the pun; there's a small list of exceptions.

[20:50] <japhb> Ah

[20:50] <timotimo> japhb: i agree it's a language design question

[20:52] * japhb still wonders why given all the imperfect standards people *have* been willing to make, that we haven't just standardized on IEEE floating point bit patterns as the default standard for floating point on the wire

[20:52] <timotimo> i didn't know we hadn't, tbh

[20:52] <japhb> Aside from endian concerns (which are there for two's-complement integers anyway), it's basically about as "de facto standard" as you get.

[20:53] <timotimo> oh, yeah, endianness

[20:54] <japhb> timotimo: All sorts of standards assume silly things like taking the IEEE data, unioning it with an appropriate int, and then serializing that.

[20:54] *** Ven joined
[20:54] <japhb> Or going "screw it, we're just going to output scientific notation in ASCII"

[20:55] <timotimo> m)

[20:56] <japhb> (Although oddly, it turns out that scientific notation in ASCII + gzip can compare well with IEEE bit patterns for file size on real-world inputs)

[20:57] <japhb> (The Collada 3D interchange format does this, FWIW.  Arrays of floating point are just space-separated ASCII, and then it's assumed you gzip the file.)

[20:59] <timotimo> oh, interesting

[21:00] *** kaare_ left
[21:00] *** kaare_ joined
[21:03] <timotimo> perl6 -e 'use NativeCall; my $buf = CArray[int8].new; $buf[5] = 10; $buf.gist.say'

[21:04] <timotimo> IntTypedCArray[int8]:0x<00 00 00 00 00 0a>

[21:04] *** skids left
[21:04] <timotimo> (this also makes .elems and .list work)

[21:05] <timotimo> i hope people are OK with these change

[21:05] <timotimo> changes

[21:05] *** [Sno] left
[21:07] *** kaare_ left
[21:07] *** [Sno] joined
[21:08] *** rurban joined
[21:09] <timotimo> and a .new that you can pass values to

[21:09] *** rurban left
[21:10] *** xfix left
[21:12] *** FROGGS left
[21:12] <timotimo> perl6 -e 'use NativeCall; my $buf = CArray[int8].new(1, 2, 3, 4); $buf.perl.say'

[21:12] <timotimo> IntTypedCArray[int8].new(1, 2, 3, 4)

[21:12] <timotimo> ^- just like this

[21:14] *** FROGGS joined
[21:17] <dalek> rakudo/nom: 10dcbad | timotimo++ | / (2 files):

[21:17] <dalek> rakudo/nom: give CArray more methods you'd expect from arrayish things

[21:17] <dalek> rakudo/nom: 

[21:17] <dalek> rakudo/nom: .gist and .perl for int and num, .elems and .list and also

[21:17] <dalek> rakudo/nom: a method new that noms values into the CArray.

[21:17] <dalek> rakudo/nom: 

[21:17] <dalek> rakudo/nom: comes with tests.

[21:17] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/10dcbad60c

[21:17] <timotimo> abraxxa: ^ you may like this

[21:18] <abraxxa> timotimo: looking

[21:18] <abraxxa> (comes with tests)++

[21:18] <timotimo> :)

[21:19] <abraxxa> timotimo: i wonder why you tested 4 out of the 5 array elements ;)

[21:19] <timotimo> that's ... a secret!

[21:19] <abraxxa> my number 1 wish is to improve the 'Unhandled exception: Cannot unbox a type object' error message to point at a line number

[21:19] *** TEttinger joined
[21:20] <timotimo> oh

[21:20] <timotimo> can you give me a golf for that?

[21:20] <psch> .tell FROGGS fwiw, the SOE golfs to 'unit class Foo; sub foo is export {  }'

[21:20] <yoleaux> psch: I'll pass your message to FROGGS.

[21:21] <abraxxa> timotimo: the most boring car ever?

[21:21] <psch> .tell FROGGS and the "unit" isn't even needed

[21:21] <yoleaux> psch: I'll pass your message to FROGGS.

[21:21] <timotimo> is golf that boring?

[21:21] <timotimo> i think golf is a good car

[21:22] <timotimo> i did my driver's license training in a golf, then a passat. both good cars

[21:22] <abraxxa> good !~ boring

[21:23] <timotimo> ah

[21:23] <timotimo> of course

[21:23] <psch> m: sub f { say &?ROUTINE.name }; f

[21:23] <camelia> rakudo-moar 90e4da: OUTPUT«f␤»

[21:23] <psch> m: sub f { say &?ROUTINE }; f

[21:23] <camelia> rakudo-moar 90e4da: OUTPUT«sub f () { #`(Sub|61128792) ... }␤»

[21:23] <abraxxa> not that i think that Golf is a good car...

[21:24] <abraxxa> timotimo: an undeclared variable lead to the  'Unhandled exception: Cannot unbox a type object' error

[21:25] <labster> Golf is the minimum viable car?

[21:25] *** nowan_ is now known as nowan

[21:25] <abraxxa> m: die "undeclared var $var";

[21:25] <camelia> rakudo-moar 90e4da: OUTPUT«5===SORRY!5=== Error while compiling /tmp/Gs9lSmyBJT␤Variable '$var' is not declared␤at /tmp/Gs9lSmyBJT:1␤------> 3die "undeclared var 7⏏5$var";␤»

[21:25] <abraxxa> m: use NativeCall; die "undeclared var $var";

[21:25] <camelia> rakudo-moar 90e4da: OUTPUT«5===SORRY!5=== Error while compiling /tmp/UELAXa3noF␤Variable '$var' is not declared␤at /tmp/UELAXa3noF:1␤------> 3use NativeCall; die "undeclared var 7⏏5$var";␤»

[21:26] *** audy joined
[21:26] *** TEttinger left
[21:26] <labster> m: no strict; die "undeclared var $var";

[21:26] <camelia> rakudo-moar 90e4da: OUTPUT«Use of uninitialized value $var of type Any in string context  in block <unit> at /tmp/jaGnXolcx2:1␤undeclared var ␤  in block <unit> at /tmp/jaGnXolcx2:1␤␤»

[21:27] <shinobi-cl> Hi all

[21:27] <labster> hi shinobi-cl

[21:28] <abraxxa> is there a syntax to say if $var == 'A' or 'B' { ?

[21:28] *** TEttinger joined
[21:28] <shinobi-cl> i have a small module i want to upload, that allows to have an array and reference it by rows and columns. Also allows to use headers for the columns instead of numbers. And it is static. You can search on the columns, and generate an indes (basically, a hash of arrays) . What do you think on naming it "Data::StaticTable" ? Too generic maybe?

[21:29] <colomon> abraxxa: you mean like   if $var == 1 | 2 {  ?

[21:29] <colomon> or possibly    if $var eq ‘A’ | ‘B’ {  ?

[21:29] <abraxxa> colomon: if that works, yes

[21:29] <abraxxa> i tried: elsif $dty == (SQLT_INT, SQLT_NUM)  {

[21:29] <abraxxa> those are constants

[21:30] <abraxxa> seems to work

[21:30] <colomon> m: my $a = 10;  if $a == 9 | 10 | 11 { say “yup”; };

[21:30] <camelia> rakudo-moar 90e4da: OUTPUT«5===SORRY!5=== Error while compiling /tmp/nZAjT0ljdZ␤Bogus statement␤at /tmp/nZAjT0ljdZ:1␤------> 3my $a = 10;7⏏5  if $a == 9 | 10 | 11 { say “yup”; };␤    expecting any of:␤        prefix␤        term␤»

[21:30] *** muraiki left
[21:31] <colomon> Not sure why camelia doesn’t like that, but except for the quotes around yup it is correct.  :)

[21:31] <pink_mist> the ctrl+h character might be the reason

[21:32] <abraxxa> can i define a variable without a type and change the type later?

[21:33] <psch> m: say “yup”;

[21:33] <camelia> rakudo-moar 90e4da: OUTPUT«yup␤»

[21:33] <pink_mist> colomon: that is, you embedded a literal backspace character in your line

[21:33] *** Ven left
[21:36] <leont> Fun fact: until very recently dollar control-character was a valid variable in perl 5. Not a feature to steal ;-)

[21:37] * vendethiel remembers leont talking to people about this at APW14, and our eyes getting bigger and bigger *g*

[21:37] <TEttinger> the unicode byte order marker, aka zero-width space, is a valid identifier part in java and a valid identifier in clojure and scala

[21:38] <TEttinger> I strongly suspect it would need to be valid in JVM perl at least

[21:39] <psch> TEttinger: why?

[21:39] <TEttinger> because there would be JVM names you couldn't call otherwise in perl6

[21:40] <TEttinger> is there a way to eval on the jvm perl6 instead of moarvm with camelia?

[21:40] <psch> TEttinger: i'd say you'd just have to call them with the quoted method name syntax

[21:40] <psch> TEttinger: jvm is broken currently, didn't quite survive the glr merge i think

[21:41] <TEttinger> ah

[21:41] <psch> TEttinger: it also depends on whether java introspection (and indy) properly reproduce the zero-width space

[21:41] <TEttinger> m: say "y\ufeffay"

[21:41] <camelia> rakudo-moar 10dcba: OUTPUT«5===SORRY!5=== Error while compiling /tmp/fICSnk6Vdy␤Unrecognized backslash sequence: '\u'␤at /tmp/fICSnk6Vdy:1␤------> 3say "y\7⏏5ufeffay"␤    expecting any of:␤        argument list␤        double quotes␤        term␤»

[21:41] <psch> TEttinger: if they don't we don't get it while building the name, if they do... i'm not actually sure what happens then :)

[21:42] <TEttinger> what... is the unicode 4-hex-digit escape in perl6?

[21:42] <psch> m: say "y\x[feff]ay"

[21:42] <camelia> rakudo-moar 10dcba: OUTPUT«y﻿ay␤»

[21:43] <TEttinger> m: my $y﻿ay = 10; say $y﻿ay;

[21:43] <camelia> rakudo-moar 10dcba: OUTPUT«5===SORRY!5=== Error while compiling /tmp/suoI05cxzn␤Bogus postfix␤at /tmp/suoI05cxzn:1␤------> 3my $y7⏏5﻿ay = 10; say $y﻿ay;␤    expecting any of:␤        constraint␤        infix␤        infix stopper␤        postfix␤     …»

[21:43] <psch> m: say "y\c[ZERO WIDTH SPACE]ay"

[21:43] <camelia> rakudo-moar 10dcba: OUTPUT«y​ay␤»

[21:43] <TEttinger> it appears to be invalid in moarvm

[21:43] <psch> TEttinger: i don't think the BOM is the zero width space, though

[21:44] <TEttinger> unfortunately, it is a whole mess of unicode history

[21:44] <psch> m: say chr "\c[ZERO WIDTH SPACE]"

[21:44] <camelia> rakudo-moar 10dcba: OUTPUT«Cannot convert string to number: base-10 number must begin with valid digits or '.' in '⏏​' (indicated by ⏏)␤  in block <unit> at /tmp/Ycyy_f6mxZ:1␤␤Actually thrown at:␤  in block <unit> at /tmp/Ycyy_f6mxZ:1␤␤»

[21:44] <psch> ehh, how was that

[21:44] <psch> m: say unival "\c[ZERO WIDTH SPACE]"

[21:44] <camelia> rakudo-moar 10dcba: OUTPUT«NaN␤»

[21:44] <psch> m: say ord "\c[ZERO WIDTH SPACE]"

[21:44] <camelia> rakudo-moar 10dcba: OUTPUT«8203␤»

[21:44] <psch> m: say (ord "\c[ZERO WIDTH SPACE]").base(16)

[21:44] <camelia> rakudo-moar 10dcba: OUTPUT«200B␤»

[21:46] <TEttinger> http://www.fileformat.info/info/unicode/char/feff/index.htm

[21:47] <TEttinger> m: say ord "\c[ZERO WIDTH NO-BREAK SPACE]"

[21:47] <camelia> rakudo-moar 10dcba: OUTPUT«65279␤»

[21:47] <psch> ah, no-break

[21:48] *** n0tjack left
[21:48] <TEttinger> and it's in an arabic presentation forms block, of all things

[21:48] <timotimo> abraxxa: can you give me a test case that leads to that error?

[21:49] <timotimo> m: my int $foo = Int

[21:49] <camelia> rakudo-moar 10dcba: OUTPUT«Cannot unbox a type object␤  in block <unit> at /tmp/srIZT25vKA:1␤␤»

[21:49] <timotimo> like that? that has a line number to go with it

[21:50] *** rangerprice joined
[21:51] <rangerprice> How can i redirect the stderr stream to stdout ?

[21:51] <timotimo> you can my $*ERR = $*OUT

[21:51] <moritz> $*ERR = $*OUT

[21:54] <colomon> pink_mist: I assure you it was not intentional; indeed, I wouldn’t know how to do it if I wanted to.

[21:54] *** rurban joined
[21:55] <pink_mist> colomon: I'm not surprised; the only reason I went into so much detail is because a lot of irc clients won't even show you it happened; take a look at the irclog linked in the topic for example; you can't see that it's there at all in that ... but it's right before the 'if'

[21:55] <pink_mist> colomon: which is also where camelia reported the error

[21:57] <abraxxa> timotimo: didn't find out what causes it, but if you edit DBIish you can force it easiliy

[22:00] <abraxxa> i've pushed all i've done today to my repo

[22:00] <abraxxa> timotimo: it happens for example if you remove the ; in line 688 in lib/DBDish/Oracle.pm6

[22:02] <timotimo> abraxxa: something i just remembered, you could also have a native int "is rw" parameter for the size that the call fills in for you

[22:02] <abraxxa> i'm done for today, bye!

[22:03] <timotimo> gnite abraxxa!

[22:03] *** Possum left
[22:03] <rangerprice> And if i want to redirect the stderr to a variable, how i can do ?

[22:03] <abraxxa> timotimo: yeah, that should work too!

[22:04] *** rurban1 joined
[22:04] <abraxxa> timotimo: also good night and thanks!

[22:04] *** abraxxa left
[22:05] *** rurban left
[22:05] *** rurban1 left
[22:06] *** rurban joined
[22:06] <japhb> rangerprice: ISTR there is an IO::String module available via panda (or zef, I suppose)

[22:09] *** cognominal left
[22:11] *** dha left
[22:12] *** laubster left
[22:13] <psch> .tell FROGGS the mentioned golf calls sink from EXPORT_SYMBOL, goes through a bunch of pull-, push-, and reify- methods and then ends in a new, new, bless, BUILDALL loop...

[22:13] <yoleaux> psch: I'll pass your message to FROGGS.

[22:14] *** dha joined
[22:16] *** FROGGS left
[22:16] *** hernanGOA left
[22:20] *** tokuhiro_ joined
[22:20] *** FROGGS joined
[22:22] *** nightfrog joined
[22:24] *** tokuhiro_ left
[22:25] *** lolisa joined
[22:33] *** espadrine left
[22:40] *** rurban left
[22:40] *** mohij left
[22:50] <thou> is 'use v6' deprecated now?

[22:50] <thou> Trying to understand why i got a pull request removing that from files

[22:50] <gfldex> r: use v6;

[22:50] <camelia> rakudo-moar 10dcba: ( no output )

[22:50] <camelia> ..rakudo-jvm 10dcba: OUTPUT«Can't open perl script "/home/camelia/rakudo-inst/bin/eval-client.pl": No such file or directory␤»

[22:54] <ShimmerFairy> thou: it's not deprecated or discouraged; I'd like to see this PR, sounds interesting

[22:54] <thou> https://github.com/softmoth/p6-Template-Mustache/pull/11

[22:55] <ugexe> rakudobrew doesn't seem to work on OSX anymore

[22:55] <thou> mj41 is Michal Jurosz

[22:56] <ShimmerFairy> thou: I'd change those C<v6;> lines to C<use v6;> (just my preference, and it's also a use statement vs. Version object in sink context), but aside from that I'd reject the PR, esp. without a rationale given.

[22:58] <labster> didn't 'v6;' previously mean "no strict;"  and does it still?

[23:00] *** leont left
[23:00] <thou> labster, I think you're right. I can't seem to find that in the synopses though.

[23:01] *** vendethiel left
[23:01] <ugexe> v6 used to turn strict on (when it was not default for -e for example)

[23:01] <timotimo> i think it still means that

[23:01] <timotimo> m: v6; $x = 10

[23:01] <camelia> rakudo-moar 10dcba: OUTPUT«5===SORRY!5=== Error while compiling /tmp/EhZz3isSlG␤Variable '$x' is not declared␤at /tmp/EhZz3isSlG:1␤------> 3v6; 7⏏5$x = 10␤»

[23:01] <timotimo> apparently it doesn't any more

[23:02] <ugexe> maybe it was `use v6` only then

[23:02] <ugexe> probably remembering -Mv6

[23:03] <ShimmerFairy> thou: I definitely recall something about v6 being in sink context but not getting warned about that, or something :)

[23:05] *** bbkr_ joined
[23:06] <thou> Yeah. I can't find any reference to bald 'v6;' on design.perl6.org now; I'll reject that pull request but update all to 'use v6;'

[23:06] <ShimmerFairy> I'm surprised to not see the bare 'v6' mentioned anymore, but it does make sense that we wouldn't want that to be magical :)

[23:06] <rangerprice> Do you know a generic approach to see what shell execute the command inside the backstick (``) ?

[23:07] *** skids joined
[23:07] *** bbkr left
[23:07] <thou> rangerprice: Does 'set -x' do what you want?

[23:08] <thou> maybe I misunderstood your question...

[23:09] <rangerprice> I would like to know what shell execute the `command`

[23:10] <pink_mist> presumably the shell in your /etc/passwd file if on *nix

[23:10] <pink_mist> maybe?

[23:11] <geekosaur> you can test that easily enough with something like perl6 -e '`ps -fp$$`.say', Id' think

[23:11] <geekosaur> I'd also think /bin/sh but...

[23:11] <geekosaur> hm, might need to escape the $s

[23:12] * geekosaur should update rakudo on this machine at some point >.>

[23:12] <ShimmerFairy> I don't think we even have backticks

[23:12] <ShimmerFairy> nope, you'd have to do qx`...` if you really wanted to use backticks in P6 :)

[23:13] <rangerprice> Is backstick more efficient than exec() or system() ?

[23:13] <ugexe> m: say %*ENV<SHELL>

[23:13] <camelia> rakudo-moar 10dcba: OUTPUT«/bin/bash␤»

[23:13] * japhb built all just before the glr merge, and is afraid to rebuild his main perl6 tree until the ecosystem fallout dies down, lest he break it and be sad

[23:13] <geekosaur> less, I'd expect, since it connects to a pipe and captures output

[23:13] <japhb> rangerprice: backtick is for capturing stdout.

[23:14] <rangerprice> i didn't yet learn perl 6, actually i'm on perl 5 !

[23:14] <geekosaur> using `` as a shorthand for "system" is an old perl5ish code smell

[23:14] <japhb> rangerprice: I answered for Perl 5, because I guessed as much.  :-)

[23:14] <ShimmerFairy> japhb: interesting, I'm in pre-glr because the allomorphs branch I've been working on started before the merge. It's not by choice that I don't have GLR yet :P

[23:14] <pink_mist> rangerprice: you might want #perl then, not #perl6 ...

[23:15] <japhb> ShimmerFairy: Yeah, understood.  Looking forward to getting the allomorphs in the main tree, that'll be one of my really old wishes come to fruition.

[23:16] <rangerprice> pink_mist: oh thank ! but i will also stay here, after all, i'm a great lambda camel

[23:16] <japhb> rangerprice: Pugs devotee?

[23:16] <ShimmerFairy> japhb: I "just" need to change how I do val() at compile-time (last time I tried I got too annoyed with one problem that cropped up), and then I'd definitely merge it in. I could merge it in now, in fact, it's just not handling compile-time val() in a DRY way

[23:17] <japhb> nod, saw something about using World lookup to get the setting version of val() in the backlog

[23:17] <ShimmerFairy> japhb: if you didn't catch the recent commits (I pushed the branch a while back), I did put back in your original code, which did improve things by a couple seconds :)

[23:17] <rangerprice> japhb:  yes

[23:18] *** rangerprice left
[23:18] <ShimmerFairy> (And doing that showed me that val()'s implementation wasn't the issue with the slowdown anymore, just the sheer number of calls to val() that happen)

[23:19] *** rangerprice joined
[23:23] *** ab5tract_ left
[23:23] <ShimmerFairy> Also something that's come up is whether certain <>/«» lists, like %hash<subscripts>, should have :v done on them like everything else, or if :v should only be done in places where you as the user could coerce resulting values

[23:25] <ShimmerFairy> (if the latter, then you'd need %hash{<subscripts>} to get val processing on a <>/«» list, because there you could do stuff like %hash{<subscripts 42>».Numeric})

[23:28] <ShimmerFairy> Certainly something I'd like TimToady's opinion on, I think it might be a nicer way than the mostly-implied "<>/«» does :v everywhere all the time"  :)

[23:28] <japhb> ShimmerFairy: Thank you for putting my code back, I appreciate that.  I wonder how much my original tuning has rotted over the years.

[23:29] <ShimmerFairy> japhb: keep in mind that my original code ran my one sorting benchmark to 90s on average, so the "couple seconds less" is after I did a bunch of optimizing changes to my version :)

[23:29] <japhb> ShimmerFairy: I do think it's sane to say that hash subscripting (and perhaps all places that <> is pretty clearly just syntactic sugar) does not deserve :v without a couple extra characters of effort.

[23:30] <ShimmerFairy> japhb: and when I put it in, I only changed your code enough to work in val() (of course), and made \i required on NaN\i and Inf\i :)

[23:31] <ShimmerFairy> japhb: there are some tests that fail because your code is more permissive on "slash rationals", but I haven't done anything about that (fixing neither tests nor code) pending some sort of decision on that

[23:31] <japhb> A decent change.  I hadn't bothered, mostly based on "until someone cares one way or the other, don't force the decision"

[23:31] <ShimmerFairy> The \i required was just to fix some tests I had un-TODOd back when my version was still in place, and I figured making \i required was better than re-TODOing (and it was a simple enough change, so no big deal) :P

[23:32] <japhb> The slash rational code was intentionally permissive (I happen to like that, because I like .Numeric and constant folding to produce the same value if possible), but it's more preference than requirement

[23:32] <japhb> It just seems easier to explain that way.

[23:33] * japhb attempted to think ahead to not causing jnthn, masak, et al. pain in their classes.  :-)

[23:33] <ShimmerFairy> japhb: I personally wouldn't mind if the only limit was "only one slash in a slash rational", like we only allow one point in a point rational :)

[23:36] <ShimmerFairy> And if for some reason we wanted val() to handle "<1/2>", then we'd want that to be as restrictive as actual <1/2> in code, so that's where the more restrictive view could go :P

[23:37] <japhb> nodnod

[23:39] *** Urchin left
[23:41] *** lolisa left
[23:43] *** spider-mario left
[23:46] <ShimmerFairy> japhb: in terms of tuning, I wonder how much unboxing might contribute to that; you have a lot of literal numbers in your version, which are mostly likely read as Ints by the parser at first, which then have to be unboxed for the nqp::ops. If that is contributing greatly to it, I'm not sure how that could be fixed, though :(

[23:52] <japhb> Hmmm.  Back in The Old Days(tm) ISTR it used to be that literal numbers directly used as nqp::op arguments where just handled directly, no box/unbox.  But it may be that that was only an optimization which we may not do anymore.  :-/

[23:52] <japhb> Might be worth looking at the --target=optimize on that.

[23:53] *** mprelude left
[23:54] <japhb> And as for how to work around that, we could create some scoped native constants and use them that way, I suppose.  Seems like we ought to fix the optimizer though, if indeed it broke.

[23:54] <ShimmerFairy> japhb: wouldn't know, that's just my naive guess based on what I know of parsing, which isn't everything :) . It may very well still be optimized for nqp:: calls (and perhaps any parameter marked as a native type, who knows?)

[23:55] <japhb> rangerprice: Ah, missed your response amongst the val() discussion.  Glad to see there are still Pugs herders about, I still have a soft spot for it.  :-)

[23:56] * geekosaur still wants to poke at it for real someday

[23:56] * geekosaur still keeps getting butt kicked by it >.>

[23:56] <ShimmerFairy> japhb: just checked    perl6 -Mnqp --target=optimize -e 'say nqp::add_i(42, 0)'   , and I see Int WVals just like in --target=ast  :(

[23:56] * japhb imagines that a brain dump from au++ might result in melting the surrounding brains

[23:56] <japhb> ShimmerFairy: Aww, dang

[23:57] <japhb> That would certainly explain less than awesome performance.

[23:57] <japhb> (well, at least contribute to it)

[23:57] <ShimmerFairy> japhb: more precisely, Wants with a WVal(Int) and a IVal(42)

[23:58] <ShimmerFairy> japhb: my naive "implict unboxing will be happening" guess is why I didn't bother switching to less-readable codepoint numbers in my version. I figured implied unbox_s couldn't be much worse than implied unbox_i :P

[23:59] *** rmgk left
