[00:01] <dalek> roast: ffc5993 | coke++ | S06-multi/subsignature.t:

[00:01] <dalek> roast: loosen some fudge

[00:01] <dalek> roast: review: https://github.com/perl6/roast/commit/ffc5993e42

[00:01] <dalek> rakudo/nom: e9c5679 | coke++ | t/spectest.data:

[00:01] <dalek> rakudo/nom: add passing test

[00:01] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/e9c56799d8

[00:03] <[Coke]> m: class Foo { method bar() { 42 } method bar_ref() { &bar } }; Foo.new.bar_ref.say

[00:03] <camelia> rakudo-moar 2f7ab3: OUTPUT«5===SORRY!5=== Error while compiling /tmp/Opp4YlUqtX␤Strange text after block (missing semicolon or comma?)␤at /tmp/Opp4YlUqtX:1␤------> 3class Foo { method bar() { 42 }7⏏5 method bar_ref() { &bar } }; Foo.new.ba␤    expecting any of:␤ …»

[00:04] <[Coke]> ^^ that's a test from t/spec/S13-syntax/aliasing.t

[00:04] <[Coke]> that dates from 2008 or so. Seems dubious.

[00:11] *** BenGoldberg joined
[00:11] <[Coke]> r: say ((* < 5 and * > 5)(4,6))

[00:11] <camelia> rakudo-jvm 2f7ab3: ( no output )

[00:11] <camelia> ..rakudo-moar 2f7ab3: OUTPUT«Too many positionals passed; expected 1 argument but got 2␤  in block <unit> at /tmp/tmpfile:1␤␤»

[00:11] <[Coke]> r: say ((* < 5 and * > 5)(4))

[00:11] <camelia> rakudo-{moar,jvm} 2f7ab3: OUTPUT«False␤»

[00:11] <[Coke]> r: my $divisor = 2; say(* != $divisor && * %% $divisor);

[00:11] <camelia> rakudo-{moar,jvm} 2f7ab3: OUTPUT«WhateverCode.new␤»

[00:12] <[Coke]> r: my $divisor = 2; say(* != $divisor && * %% $divisor)(3);

[00:12] <camelia> rakudo-jvm 2f7ab3: OUTPUT«WhateverCode.new␤Method 'postcircumfix:<( )>' not found for invocant of class 'Bool'␤  in block <unit> at /tmp/tmpfile:1␤␤»

[00:12] <camelia> ..rakudo-moar 2f7ab3: OUTPUT«WhateverCode.new␤Cannot find method 'postcircumfix:<( )>'␤  in block <unit> at /tmp/tmpfile:1␤␤»

[00:12] *** Zoffix left
[00:12] <[Coke]> r: my $divisor = 2; say (* != $divisor && * %% $divisor)(3);

[00:12] <camelia> rakudo-{moar,jvm} 2f7ab3: OUTPUT«False␤»

[00:12] *** Zoffix joined
[00:14] *** yqt left
[00:15] *** virtualsue left
[00:21] <[Coke]> can I get a ll exception in a REPL?

[00:22] <TimToady> do you mean something other than starting the program with --ll-exception in the first place?

[00:22] <ShimmerFairy> I assume you've tried --ll-exception with the REPL?

[00:22] <[Coke]> TimToady: that doesn't seem to work, no.

[00:22] <[Coke]> (using perl6-j)

[00:23] <TimToady> well, but Java is a high-level language :P

[00:24] <[Coke]> r: &&::{}[];;

[00:25] <camelia> rakudo-moar e9c567: OUTPUT«===SORRY!===␤MVMArray: Index out of bounds␤»

[00:25] <camelia> ..rakudo-jvm e9c567: OUTPUT«===SORRY!===␤VMArray: Index out of bounds␤»

[00:30] <Sgeo> m: my %foo; say %foo<hi>;

[00:30] <camelia> rakudo-moar e9c567: OUTPUT«(Any)␤»

[00:30] <Sgeo> m: my %foo; say %foo<hi>; %foo<hi> ~= 'there'; say %foo<hi>;

[00:30] <camelia> rakudo-moar e9c567: OUTPUT«(Any)␤there␤»

[00:31] <Sgeo> Hmm where can I learn a bit about autovivification?

[00:32] <Sgeo> Also Perl6 keeps reminding me of Haskell lenses. A lot.

[00:32] <ShimmerFairy> Sgeo: S09 and S12 appear to have sections on autovivification

[00:32] <Sgeo> ty

[00:33] <Sgeo> I'm not sure if that's good or bad. IMO it's good if Perl6 is in fact similarly expressive, but I feel like without mathematical backing it might... miss use cases or something

[00:37] <ShimmerFairy> I'm sure the lack of a mathematical backing can likely trip us up in places, but I like to think we're generally better at stuff than lower-level, less expressive languages :)

[00:48] *** laouji joined
[00:54] <Sgeo> Suppose I want to make a Proxy that backs a Promise. I can implement STORE to replace what it will return with, but I can't really implement FETCH (unless I either die, or freeze, or something). But, it would still make sense for me to do something like += 1 on it, but I can't do that if I can only define STORE/FETCH. So maybe MODITY/FETCH makes more sense, and storing is just a special case of MODIFYing

[00:59] <skids> What would * += 1 do on something that cannot be FETCHed?

[01:02] <japhb> I'm getting an error trying to bootstrap panda on a fresh r-j: "Could not find symbol '&Async'", which I vaguely remember being a known issue.  Anyone happen to remember the last time panda and r-j got along?

[01:03] <Sgeo> skids, map { * + 1 } on it, if it has a meaningful map operation

[01:03] <skids> I bootstrapped panda fine just a little while ago and the only thing that is way out of date for me is rakudobrew.

[01:04] <japhb> skids: what's your `perl6-j -v` ?

[01:05] <skids> I nuked it since.

[01:05] <japhb> Huh, the erroring line refers to Proc::Async.  When did that get implemented on r-j?  ISTR it was r-m only ....

[01:07] *** gfldex left
[01:11] <japhb> Confirmed, no src/core/Proc/Async.pm in tools/build/Makefile-JVM.in

[01:12] <japhb> Thus, I need to figure out how old a panda I need to successfully bootstrap (meaning, to go back far enough to *not* require Proc::Async)

[01:15] *** kaare_ joined
[01:19] <skids> Yeah seeing that too now.

[01:19] <skids> (recompiled it

[01:19] <skids> )

[01:20] <skids> But its File::Find maybe complaining?

[01:21] <skids> No it's in panda.

[01:21] <japhb> It's panda commit afd281a

[01:22] <japhb> .tell hoelzro Panda commit afd281a breaks panda on r-j, because it requires Proc::Async.  Either panda should handle lack of Proc::Async, or r-j needs to learn how to Proc::Async.  :-)

[01:22] <yoleaux> japhb: I'll pass your message to hoelzro.

[01:24] *** rmgk left
[01:24] *** rmgk joined
[01:31] *** mtj_- joined
[01:41] *** StavroMueller left
[01:45] *** ilbot3 left
[01:45] <ugexe> there is already an issue open on it

[01:46] <ugexe> zef works on jvm

[01:47] *** ilbot3 joined
[01:48] *** mtj_- left
[01:49] *** mtj_- joined
[01:56] *** mtj_- left
[01:57] *** mtj_- joined
[01:57] *** yeahnoob joined
[02:00] <japhb> ugexe: Oh, is zef a panda replacement?  For some reason I got the feeling it was for something else ....

[02:00] *** mtj_- left
[02:00] *** dmitri joined
[02:00] *** mtj_- joined
[02:07] <ugexe> the client itself is. working on a Build.pm file converter so it can install everything. the server parts are not done, but the client uses the p6 community ecosystem as default for now

[02:09] *** dayangkun joined
[02:10] *** [Sno] left
[02:10] <japhb> ugexe: Ah, understood.  Make sure zef gets advertised in the p6weekly when it can fully replace panda.  :-)

[02:11] *** [Sno] joined
[02:11] <japhb> Dang it, the last merge commit before afd281a still doesn't work on r-j, for a totally different reason (but at least it gets a lot farther).

[02:11] *** mtj_- left
[02:12] * japhb wonders if modern r-m is thread-stable enough to handle my crazy code that requires r-j

[02:13] <ugexe> i've implemented a generic replacement for Build.pm thats not dependent on a package manager at all, so hopefully we can just hammer our the details of hooks/ and get people using those instead

[02:13] <Sgeo> Is there a way to make custom containers other than Proxy?

[02:28] <skids> Sgeo: Containers go down to the VM level so while ISTR Moarvm allows dynamic extensions it will be an adventure.

[02:31] *** khw joined
[02:36] <skids> Yeah rakudo/src/vm does seem to build and load some Perl6 containers, so ther are examples outside the MoarVM source tree.

[02:37] *** mtj__ joined
[02:44] *** noganex joined
[02:46] <Sgeo> I wonder if FETCH/STORE could be cheated with gather/take to get behavior like I described

[02:47] *** noganex_ left
[02:58] *** BenGoldberg left
[03:05] *** mtj_ joined
[03:07] *** skids left
[03:07] *** mtj__ left
[03:07] *** mtj_ left
[03:08] *** mtj_ joined
[03:11] *** grondilu left
[03:13] *** grondilu joined
[03:23] *** dmitri left
[03:24] *** dsm left
[03:26] *** dsm joined
[03:31] *** khw left
[03:39] *** dj_goku joined
[03:49] <Sgeo> What's slice context? @@

[03:55] <TimToady> where'd you dig up that fossil?

[03:56] <ShimmerFairy> I don't think that's been really dealt with so far; there are only three occurrences of 'slice context' in the specs, and pretty much none of the code given does anything.

[03:56] <ShimmerFairy> oh, it's an old thing?

[03:57] <ShimmerFairy> TimToady: you can find one mention each in S04, S09, and S32::Str

[03:57] <TimToady> it's probably what mutated into ** lol context

[03:59] <TimToady> but I don't think it's been @@ for more than 5 years

[03:59] <ShimmerFairy> Well, ||@a in an array subscript doesn't work, and neither does **

[03:59] <TimToady> ** works in binding

[04:03] *** nys left
[04:05] <ShimmerFairy> I saw that sub foo(**@a) { } works, I'm just not clear on how to see how it differs from *@a (I thought I'd see a change in behavior by passing something with ||, but as mentioned it's NYI)

[04:12] <Sgeo> TimToady, http://www.ozonehouse.com/mark/periodic/

[04:13] <[Coke]> m: say 3 p5=> 4;

[04:13] <camelia> rakudo-moar e9c567: OUTPUT«5===SORRY!5=== Error while compiling /tmp/ExCP9DPlD1␤Two terms in a row␤at /tmp/ExCP9DPlD1:1␤------> 3say 37⏏5 p5=> 4;␤    expecting any of:␤        infix␤        infix stopper␤        postfix␤        statement end␤        state…»

[04:20] <ShimmerFairy> S06:346 mentions p5=> . I'm not surprised it's not implemented :)

[04:20] <synbot6> Link: http://design.perl6.org/S06.html#line_346

[04:21] <TimToady> we decided to remove it, actually, since it can always be defined by a p5-to-p6 translator at need

[04:22] <TimToady> afk for a bit &

[04:24] <Sgeo> Is there a reverse application operator?

[04:24] <Sgeo> Or a thing to turn functions into operators for the purpose of using a metaoperator?

[04:25] <Sgeo> In Haskell if foo is a normal function then `foo` is an operator

[04:26] <dalek> specs: 4c0e9cd | ShimmerFairy++ | S06-routines.pod:

[04:26] <dalek> specs: Remove p5=> fossil.

[04:26] <dalek> specs: review: https://github.com/perl6/specs/commit/4c0e9cd692

[04:27] <ShimmerFairy> Sgeo: you can define a sub with name  infix:<op>  to create an operator that can then be used as  $a op $b  . I don't believe there's any syntax that lets you use an arbitrary sub as an infix.

[04:42] <b2gills> m: 4 [&say] 5

[04:42] <camelia> rakudo-moar e9c567: OUTPUT«45␤»

[04:43] <b2gills> m: ^4 X[&say] 5

[04:43] <camelia> rakudo-moar e9c567: OUTPUT«05␤15␤25␤35␤»

[04:43] <b2gills> Sgeo: Like that ^

[04:44] <b2gills> m: [[&say]] ^5

[04:44] <camelia> rakudo-moar e9c567: OUTPUT«01␤True2␤True3␤True4␤»

[04:44] <Sgeo> neat ty

[04:45] <Sgeo> m: 2, 3 X[* * *] 2, 3, 4 # Needless stuff time

[04:45] <camelia> rakudo-moar e9c567: OUTPUT«5===SORRY!5=== Error while compiling /tmp/NNSbo15bYm␤Unable to parse expression in bracketed infix; couldn't find final ']' ␤at /tmp/NNSbo15bYm:1␤------> 032, 3 X[*7⏏5 * *] 2, 3, 4 # Needless stuff time␤»

[04:46] <Sgeo> I mean, there's no reason not to use X* there, but should it have worked?

[04:50] *** baest_ is now known as baest

[04:53] <b2gills> m: 2, 3 X[&(* * *)] 2, 3, 4

[04:53] <camelia> rakudo-moar e9c567: ( no output )

[04:53] <b2gills> m: say 2, 3 X[&(* * *)] 2, 3, 4

[04:53] <camelia> rakudo-moar e9c567: OUTPUT«4 6 8 6 9 12␤»

[04:54] *** ChoHag joined
[04:54] <ChoHag> m: my %h = a => 1; say %h.push: a => 1;

[04:54] <camelia> rakudo-moar e9c567: OUTPUT«a => 1␤»

[04:54] <b2gills> Sgeo: the opening bracket must be followed immediately by an ampersand

[04:55] <Sgeo> Hmm, ok

[04:55] <ChoHag> Either hash push has broken or changed. Either way the example in doc.perl6.org/type/Hash#method_push doesn't work.

[04:55] <Sgeo> That seems tricky to remember

[04:55] <Sgeo> m: my $say = &say; say [[$say]] 1,2

[04:55] <camelia> rakudo-moar e9c567: OUTPUT«5===SORRY!5=== Error while compiling /tmp/ipPMTWPgbm␤Two terms in a row␤at /tmp/ipPMTWPgbm:1␤------> 3my $say = &say; say [[$say]]7⏏5 1,2␤    expecting any of:␤        infix␤        infix stopper␤        postfix␤        statement …»

[04:56] <Sgeo> m: my $say = &say; say [[&$say]] 1,2

[04:56] <camelia> rakudo-moar e9c567: OUTPUT«5===SORRY!5=== Error while compiling /tmp/XfuNa96Qhj␤Unable to parse expression in bracketed infix; couldn't find final ']' ␤at /tmp/XfuNa96Qhj:1␤------> 3my $say = &say; say [[&7⏏5$say]] 1,2␤»

[04:56] <b2gills> m: my $say = &say; say [[&$say]] 1,2

[04:56] <camelia> rakudo-moar e9c567: OUTPUT«5===SORRY!5=== Error while compiling /tmp/GkERC0n2x2␤Unable to parse expression in bracketed infix; couldn't find final ']' ␤at /tmp/GkERC0n2x2:1␤------> 3my $say = &say; say [[&7⏏5$say]] 1,2␤»

[04:56] <Sgeo> m: my $say = &say; say [[&($say)]] 1,2

[04:56] <camelia> rakudo-moar e9c567: OUTPUT«12␤True␤»

[04:56] <Sgeo> Uh. Not quite the right result?

[05:02] <b2gills> That is exactly what I would have expected, the return value of say is usually True

[05:03] <ShimmerFairy> ChoHag: it's never been broken, nor has it changed. Named parameters always get silently eaten by implicit *%_ on methods.

[05:04] <ChoHag> Then the documentation is wrong.

[05:06] <Sgeo> m: say 1,2

[05:06] <camelia> rakudo-moar e9c567: OUTPUT«12␤»

[05:06] <ChoHag> According to the documentation's example to which I only added a 'say', %h<a> should have been [1,1].

[05:07] <Sgeo> Why did say get 1,2 as an argument instead of... ..

[05:07] * Sgeo is a bit confused

[05:07] <ChoHag> Also:

[05:07] <ChoHag> m: my %h = a => 1; %h.push: b => 2; say %h

[05:07] <camelia> rakudo-moar e9c567: OUTPUT«a => 1␤»

[05:07] <ChoHag> Where did b and 2 go?

[05:08] <b2gills> m: my %h = a => 1; %h.push: (a => 2); say %h.push: 'a' => 3;

[05:08] <camelia> rakudo-moar e9c567: OUTPUT«a => 1 2 3␤»

[05:08] <b2gills> You have to force it to be a positional argument instead of a named argument

[05:09] <ChoHag> Then the documentation will be easy to fix.

[05:10] *** ssqq joined
[05:10] <dalek> doc: 0344de8 | ShimmerFairy++ | lib/Type/Hash.pod:

[05:10] <dalek> doc: Fix hash push example, ChoHag++

[05:10] <dalek> doc: 

[05:10] <dalek> doc: The given example forgot to account for methods' implicit *%_ and the

[05:10] <dalek> doc: interpretation of certain Pairs as named parameters in argument lists.

[05:10] <dalek> doc: review: https://github.com/perl6/doc/commit/0344de8354

[05:13] *** ssqq left
[05:13] *** ssqq joined
[05:18] <Sgeo> Wonder how often similar mistakes will be made in real code

[05:19] <ChoHag> All the time.

[05:20] <ChoHag> The set of "list-like things in perl 6" is the very definition of weird.

[05:20] <ShimmerFairy> Sgeo: quite. I'm a big fan of getting rid of implicit *%_ and disambiguating the syntax for nameds and Pairs. More realistically, I should think an Associative class' methods should handle *%_ because that's a particularly likely source of problems.

[05:20] <ChoHag> This is not necessarily a bad thing, mind.

[05:22] <ShimmerFairy> m: my %hash; %hash.push("IsAPair" => 42, NotAPairThough => 21); say %hash.perl   # such fun, much wow

[05:22] <camelia> rakudo-moar e9c567: OUTPUT«{:IsAPair(42)}<>␤»

[05:23] <ChoHag> I'd be happy with Associative.push dealing with *%_ specially. I can't think of any way in which not doing so makes more sense than doing so.

[05:26] <ShimmerFairy> Yeah. I imagine some of the arguments for keeping *%_ would make assuming *%_ to contain Pairs for the Associative-doing class problematic, but I don't think it outweighs the unintuitive ignoring of certain unlucky Pairs.

[05:46] *** ssqq left
[05:47] *** ssqq joined
[05:47] *** laouji left
[05:50] *** laouji joined
[05:56] *** ssqq left
[06:03] *** mr-foobar left
[06:19] *** FROGGS joined
[06:34] *** rurban_ joined
[06:36] *** rurban joined
[06:49] *** woolfy joined
[06:54] *** woolfy left
[07:09] *** mr-foobar joined
[07:09] *** [ptc]_ joined
[07:15] *** virtualsue joined
[07:15] <Sgeo> my %base36 = ( 0..9, 'A'..'Z' ) Z ( ^36 );

[07:15] <Sgeo> How does that work, isn't Z by itself a comma, not a pair maker?

[07:16] <Sgeo> m: my %base36 = ( 0..9, 'A'..'Z' ) Z ( ^36 ); say %base36;

[07:16] <camelia> rakudo-moar e9c567: OUTPUT«0 => 0, 1 => 1, 2 => 2, 3 => 3, 4 => 4, 5 => 5, 6 => 6, 7 => 7, 8 => 8, 9 => 9, A => 10, B => 11, C => 12, D => 13, E => 14, F => 15, G => 16, H => 17, I => 18, J => 19, K => 20, L => 21, M => 22, N => 23, O => 24, P => 25, Q => 26, R => 27, S => 28, T => …»

[07:16] <ChoHag> It's a zip.

[07:17] <ChoHag> Neither a comma nor a pair maker, as I understand it, but its own thing.

[07:20] <ChoHag> If an attribute's has-accessor returns true does that imply that the accessor might be named after the attribute sans sigil+twigil, or does it mean exactly that?

[07:21] <lizmat> .tell jnthn regarding supply { }, how will the runtime know which supply to emit()/done() to?   $*SUPPLY ?

[07:21] <yoleaux> lizmat: I'll pass your message to jnthn.

[07:21] <Sgeo> circumfix:«( )»('a', 'b', 'c') 

[07:21] <Sgeo> Why the double << >> instead of < >?

[07:21] <ChoHag> Are there any circumstances whene has-accessor can be True but the accessor is _not_ attribute.name.substr(2..*)?

[07:21] *** RabidGravy joined
[07:23] <ChoHag> Apparently my substr syntax is wrong, but ignore that.

[07:24] <Sgeo> m: my @a = 0, 1; say @a[*-1, *-2];

[07:24] <camelia> rakudo-moar e9c567: OUTPUT«1 0␤»

[07:25] *** darutoko joined
[07:25] *** [ptc]_ left
[07:26] <lizmat> m: say "foobar".substr(2..4)

[07:26] <camelia> rakudo-moar e9c567: OUTPUT«oba␤»

[07:26] <lizmat> m: say "foobar".substr(2..*)

[07:26] <camelia> rakudo-moar e9c567: OUTPUT«Type check failed in assignment to '$chars'; expected 'Int' but got 'Num'␤  in block <unit> at /tmp/kI_POeAt7C:1␤␤»

[07:26] <lizmat> hmmm...

[07:26] <lizmat> that should work

[07:26] <ChoHag> I seem to hit all the bugs...

[07:28] *** cibs joined
[07:28] <ChoHag> Serves me right for using the documentation I suppose. There is no 'trusts Documemtation' in 'class Sysadmin'.

[07:30] <Sgeo> m: say rand xx 3

[07:30] <camelia> rakudo-moar e9c567: OUTPUT«0.775496218272425 0.294049764640139 0.906301652066614␤»

[07:30] <Sgeo> How does xx work, that the lhs is reevaluated?

[07:32] *** pdcawley joined
[07:32] <ChoHag> xx's signature is probably a block and an int.

[07:32] <moritz> Sgeo: it's special-cased in the compiler

[07:32] <ChoHag> Or that.

[07:32] <Sgeo> :/

[07:32] <ChoHag> Boo.

[07:34] <moritz> note that macros can do that too

[07:34] <Sgeo> Oh ok

[07:34] <ChoHag> So [how] can I reliably get an attribute from its sigil-less name, and a sigil-less name from an attribute?

[07:35] <Sgeo> m: sub foo(Int $a:) { $a + 1); say 5.foo;

[07:35] <camelia> rakudo-moar e9c567: OUTPUT«5===SORRY!5=== Error while compiling /tmp/nkmTqu67tY␤Missing block␤at /tmp/nkmTqu67tY:1␤------> 3sub foo(Int $a:) { $a + 17⏏5); say 5.foo;␤    expecting any of:␤        statement end␤        statement modifier␤        statement modi…»

[07:35] <Sgeo> m: sub foo(Int $a: $b) { $a + 1); say 5.foo 6;

[07:35] <camelia> rakudo-moar e9c567: OUTPUT«5===SORRY!5=== Error while compiling /tmp/yZdBjM32Jk␤Missing block␤at /tmp/yZdBjM32Jk:1␤------> 3sub foo(Int $a: $b) { $a + 17⏏5); say 5.foo 6;␤    expecting any of:␤        statement end␤        statement modifier␤        statement…»

[07:35] <Sgeo> m: sub foo(Int $a:) { $a + 1}; say 5.foo;

[07:35] <camelia> rakudo-moar e9c567: OUTPUT«Method 'foo' not found for invocant of class 'Int'␤  in block <unit> at /tmp/v9E1oU9y66:1␤␤»

[07:36] <Sgeo> m: sub foo(Int $a:) { $a + 1}; say 5.&foo;

[07:36] <camelia> rakudo-moar e9c567: OUTPUT«Cannot bind to non-existing object lexical 'self'␤  in sub foo at /tmp/56Cw2W1Rfr:1␤  in block <unit> at /tmp/56Cw2W1Rfr:1␤␤»

[07:36] <Sgeo> It.. seemed to try to work?

[07:36] <moritz> ChoHag: you cannot; a class can have both $!foo and @!foo, though only one can have an accessor

[07:36] <ChoHag> And assuming .has-accessor is true for one of them?

[07:38] <ChoHag> Is the accessor _always_ named after the attribute sans sigil+twigil? What about twigil-les attributes?

[07:38] <moritz> m: class A { has $.a; has @.b }; say A.^attributes.grep({ .has-accessor && .name =~ /a/ })

[07:38] <camelia> rakudo-moar e9c567: OUTPUT«5===SORRY!5=== Error while compiling /tmp/YBzr9_RsuL␤Unsupported use of =~ to do pattern matching; in Perl 6 please use ~~␤at /tmp/YBzr9_RsuL:1␤------> 3ributes.grep({ .has-accessor && .name =~7⏏5 /a/ })␤»

[07:38] <moritz> m: class A { has $.a; has @.b }; say A.^attributes.grep({ .has-accessor && .name ~~ /a/ })

[07:38] <camelia> rakudo-moar e9c567: OUTPUT«Mu $!a␤»

[07:39] <moritz> m: class A { has $.a; has @.b }; say A.^attributes.grep({ .has-accessor && .name.substr(2) eq 'a' })

[07:39] <camelia> rakudo-moar e9c567: OUTPUT«Mu $!a␤»

[07:39] <moritz> ChoHag: auto-generated accessors are always named that way, yes

[07:39] <ChoHag> Actually a twigil-less attribute won't have an accessor will it?

[07:39] <moritz> ChoHag: and sigilless attributes ... correct

[07:40] <moritz> and twigilless attributes are just an alias for the one with twigil

[07:40] <moritz> m: class A { has $a }; say A.^attributes[0]

[07:40] <camelia> rakudo-moar e9c567: OUTPUT«Mu $!a␤»

[07:40] <moritz> still stored as $!a

[07:41] <ChoHag> Right.

[07:43] <Sgeo> if 'properly' ~~ m/ perl / 

[07:43] <Sgeo> How does that work, I thought m meant do it immediately

[07:43] <Sgeo> Oh does 'properly' become $_ for the m/ ?

[07:43] <Sgeo> THat's.. a bit strange to rely on that there instead of using without m which should work, right?

[07:44] <Sgeo> (Saw this at http://doc.perl6.org/language/regexes#Literals )

[07:44] *** g5 is now known as g4

[07:45] *** g4 left
[07:45] *** g4 joined
[07:46] <moritz> yes, ~~ sets $_ on the RHS

[07:46] <Sgeo> Which gets wiped out if you use $_ in a block, but that block would receive the LHS anyway, so there's no apparent difference

[07:47] *** mr-foobar left
[07:50] *** rindolf joined
[07:50] *** mr-foobar joined
[07:53] <dalek> rakudo/nom: 0dcbba7 | lizmat++ | src/core/Str.pm:

[07:53] <dalek> rakudo/nom: Make "foobar".substr(2..*) work

[07:54] <dalek> rakudo/nom: 

[07:54] <dalek> rakudo/nom: Spotted by ChoHag++

[07:54] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/0dcbba70a6

[07:56] <Sgeo> Wouldn't that then be a ~~ vs a Matches (or Matcher or whatever the result of a regex is)?

[07:59] <dalek> roast: b536f89 | lizmat++ | S32-str/substr.t:

[07:59] <dalek> roast: Tweak substr(Range) tests

[07:59] <dalek> roast: review: https://github.com/perl6/roast/commit/b536f89cbf

[07:59] <ChoHag> Tut tut tut.

[07:59] <ChoHag> Is somebody writing their code before their tests?

[08:04] <moritz> all our tests are perfect in the first iteration, of course.

[08:08] <lizmat> ChoHag: some people might have thanked me for not having to submit a bug report

[08:10] <Sgeo> Can a grammar be defined for matching on binary data? e.g. a network protocol

[08:10] <Sgeo> Or regex or other similar parsing mechanism

[08:14] <RabidGravy> you can't ~~ or match against a Buf as it stands

[08:16] *** cschwenz left
[08:17] *** mr-foobar left
[08:19] *** [Tux] joined
[08:21] *** telex left
[08:22] *** telex joined
[08:22] *** [Sno] left
[08:26] *** [Sno] joined
[08:28] <ShimmerFairy> Sgeo: there isn't currently a way to write grammars for binary data (unless of course you're veeeery careful about pretending it's text :P)

[08:28] *** RabidGravy left
[08:30] *** zakharyas joined
[08:32] *** RabidGravy joined
[08:33] <RabidGravy> boo!

[08:35] *** pierrot left
[08:41] <jnthn> morning, #perl6

[08:41] <yoleaux> 07:21Z <lizmat> jnthn: regarding supply { }, how will the runtime know which supply to emit()/done() to?   $*SUPPLY ?

[08:42] <jnthn> lizmat: Probably something like that, though control exceptions are another option

[08:42] <lizmat> jnthn RabidGravy  o/

[08:42] <jnthn> lizmat: await in the thread pool will certainly be a control exception

[08:42] <jnthn> *by

[08:43] <lizmat> if emit / done work on $*SUPPLY, I think I can implement that

[08:43] <RabidGravy> rarr!

[08:44] <lizmat> jnthn: if that would help

[08:46] <jnthn> lizmat: Ah, done will need something exceptional...

[08:47] <jnthn> lizmat: Though that doesn't mean you can't issue it through $*SUPPLY

[08:47] <lizmat> why?  wouldn't it just be sub done(|c) { $*SUPPLY.done(|c) } ?

[08:48] <lizmat> (with a check on validity of $*SUPPLY of course)

[08:48] <lizmat> ok, so you agree  :-)

[08:48] *** pierrot joined
[08:49] <jnthn> supply { whenever $input -> $value { state $i = 0; done if $i++ == 5; emit $value; } }

[08:49] <jnthn> That emit must not get to run after the done.

[08:49] *** pierrot is now known as Guest76133

[08:49] <jnthn> So sure, it can desugar to a method call

[08:49] <jnthn> But that just moves the place the exceptional stuff is needed.

[08:49] <jnthn> Oh, one more note

[08:49] <jnthn> $*SUPPLY is maybe a misleading name since it's not actually a Supply

[08:50] <jnthn> It'll need to be something a bit smarter than that

[08:50] <jnthn> That pumps stuff into an actual supply, but handles e.g. the control flow nature of done, and potentially the hyper-whenever/emit semantics eventually

[08:51] <jnthn> Not saying you have to do all of those of course :)

[08:51] <jnthn> The other thing is that a "whenever" attaches itself in some way to the thing in $*SUPPLY so we know to close the tap there when done, or when the output supply is closed

[08:51] <moritz> [Coke], colomon: you both run your smoke tests on hack around 14:00 UTC; might I suggest that one of you moves the job a few hours around, so that they don't run at the same time? thanks

[08:52] <jnthn> So it's really some coordinating object that goes in there.

[08:53] <jnthn> (That will also have responsibility for the actor semantics on the inside of the supply block)

[08:54] *** [Tux] left
[08:57] <jnthn> lizmat: I think if you start out just getting supply { emit "hi"; done; } working, though, then you'll have helped no matter how exactly you do it by getting the basic wiring in place.

[08:57] *** g4 left
[08:58] *** g4 joined
[09:00] *** Guest76133 left
[09:01] <jnthn> lizmat: I'd probably compile supply into a call to some Supply.from-block(pass the block), and whenever $s -> { xxx } into $*SUPPLY.whenever($s, -> { xxx })

[09:03] *** laouji left
[09:03] *** laouji joined
[09:04] *** FROGGS left
[09:04] <lizmat> jnthn: ok, will do when back from some cycling (now the temperature is still bearable)

[09:04] <lizmat> so afk until later&

[09:05] <jnthn> Enjoy :)

[09:06] *** [Tux] joined
[09:06] *** espadrine joined
[09:12] *** rarara_ joined
[09:18] *** pierrot_ joined
[09:23] *** [TuxCM] left
[09:35] *** [TuxCM] joined
[09:56] *** mr-foobar joined
[10:02] <sergot> hiho \o

[10:05] <timotimo> oh hi sergot!

[10:08] <RabidGravy> marnin!

[10:11] *** smls joined
[10:23] *** yeahnoob left
[10:27] *** yqt joined
[10:29] <dalek> doc: ed062b0 | (Steve Mynott)++ | lib/ (2 files):

[10:29] <dalek> doc: fix minor typos

[10:29] <dalek> doc: review: https://github.com/perl6/doc/commit/ed062b0565

[10:35] *** pdcawley_ joined
[10:35] *** pdcawley left
[10:35] *** rindolf left
[10:44] *** rurban left
[10:45] *** pmurias joined
[10:45] <pmurias> hi

[10:46] *** Woodi joined
[10:46] <moritz> \o

[10:51] *** yqt left
[10:51] <RabidGravy> erp

[10:52] <DrForr> derrp.

[10:54] <itz> DrForr: I get " Error:  Can't locate Perl/ToPerl6/Transformer/Operators/AddWhitespace.pm" trying to run Perl-Mogrify tests

[10:55] <DrForr> Uh.. hi.

[10:55] <DrForr> Oh, I removed that because it more clearly belonged in the operator changeover.

[10:56] <DrForr> Removed it in git, the tests that I was concerned about passed, must have missed that one.

[10:56] <DrForr> I'm going to do a release tonight, I'll remember to keep an eye out for that.

[11:01] <itz> ty

[11:01] <DrForr> I've already got a failing test that I need to clear up, that output is probably what blinded me to the problem.

[11:03] *** yqt joined
[11:06] <ChoHag> Is there any particular reason why Attribute lacks a is-required method?

[11:06] <ChoHag> One can be succesfully monkey-typed in with simply 'method is-required { ?$!required }'

[11:09] <RabidGravy> it has a private $!required

[11:09] <RabidGravy> oh you noticed that

[11:09] <ChoHag> I knows grep, me!

[11:09] *** mr-foobar left
[11:16] *** Psyche^_ joined
[11:17] *** rurban_ left
[11:20] *** Psyche^ left
[11:21] *** skids joined
[11:27] <smls> m: my @a = 'a'..'z'; dd @a[2]; dd @a[2,];

[11:27] <camelia> rakudo-moar 0dcbba: OUTPUT«@a = "c"␤("c",)␤»

[11:28] *** TEttinger left
[11:28] <smls> ^^ based on what type contraints is it decided whether a list is returned there?

[11:28] <smls> If the subscript ~~ Positional?  or if the subscript ~~ Iterable?

[11:33] *** rurban joined
[11:37] <ChoHag> What's the correct syntax for: for something-which-produces-a-list-of-pairs() -> ($a, $b) { ... }

[11:38] <ChoHag> To change from: for something-which-produces-a-list() -> $a { my $b = derive-b-from($a); ... } to for s-w-p-a-l().map(* => derive-b-from(*)) -> ($a, $b) { ... }

[11:38] <smls> not sure there is one

[11:39] <smls> you can use    for ... {  .key ... .value }   thouch

[11:39] <ChoHag> I'm sure I've seen a few examples of more than one variable between the -> and the {.

[11:39] <smls> yes, but I don't know if there's a way to unpack a pair in a signature.

[11:40] <ChoHag> Well maybe not a Pair then. I can do whatever I feel like in the map.

[11:40] <ChoHag> map(* => derive-from(*)) was just my first guess.

[11:41] *** gfldex joined
[11:41] <smls> m: for (1, 10), (2, 20), (3, 30) -> [$a, $b] { say "$a : $b" }

[11:41] <camelia> rakudo-moar 0dcbba: OUTPUT«1 : 10␤2 : 20␤3 : 30␤»

[11:41] <smls> [] unpacks a Positional object in a signature

[11:48] <smls> Hm, looking the multi candidates in src/core/array_slice.pm, it appears that .[Positional] is what causes a slice, not .[Iterable]

[11:49] <smls> Is that intentional? A Positional-but-non-Iterable type like CArray will blow up here, won't it?

[11:52] <smls> m: use NativeCall; my @a := CArray[int].new; @a[0] = 2; @a[1] = 4; dd @a ~~ Positional; dd (0, 1, 2, 3, 4, 5)[@a]

[11:53] <camelia> rakudo-moar 0dcbba: OUTPUT«(timeout)Bool::True␤»

[11:53] <smls> right, timeout.

[12:03] <[Coke]> I have a job at 13:55 - after it runs today, I'll set it to run at 6:55 going forward.

[12:03] <[Coke]> ^^ colomon, moritz

[12:03] <[Coke]> so, one more day of too much at once.

[12:04] <[Coke]> actually, bumping it up to as close to now as possible.

[12:04] <colomon> [Coke]: errrr, too much at once on hack?  (I’m missing context here)

[12:05] <[Coke]> colomon: from backlog. Yes, we both ahve jobs running at 1400ish. I'm moving mine

[12:05] <colomon> [Coke]++

[12:07] <[Coke]> ok, it's running now 1206ish. moritz, is that OK or shoudl I move it again tomorrow?

[12:09] <moritz> [Coke]: how long does it take?

[12:09] <moritz> colomon: I'm not sure yet it's too much; I just know it's better if they don't coincide

[12:11] *** yqt left
[12:11] <smls> huh?:  "Method 'contents' not found for invocant of class 'Any' in sub find-definitions at ./htmlify.p6:327"

[12:11] <smls> with today's rakudo via "rakudobrew triple nom master master"

[12:13] <moritz> smls: worth investigating

[12:13] <moritz> might be a list-y or a pod-y change

[12:13] <moritz> http://doc.perl6.org/build-log/build-2015-08-05T10:30+0000.log last build was successful

[12:14] *** RabidGravy left
[12:14] <moritz> though that runs on a rakudo 2015.05

[12:15] *** RabidGravy joined
[12:15] <smls> Hm, it seems a change to a .pod  file I made locally, triggered it.

[12:18] *** mr-foobar joined
[12:22] <smls> moritz: Ah, problem solved. I accidentally left a bare "=head1" line (without an actual heading following it) in the .pod; that's what caused the error.

[12:23] *** zacts left
[12:23] <moritz> smls: if you could improve the error message, that would be great

[12:24] <smls> I wonder if Rakudo's POD parser itself should fail/warn there?

[12:28] <jnthn> smls: On the postcircumfix:<[ ]> question, I suspect it has to be Iterable post-GLR, otherwise @a[1, 2, 4 ... 16] won't work for example

[12:29] <smls> m: say (1, 2, 4 ... 16).WHAT

[12:29] <camelia> rakudo-moar 0dcbba: OUTPUT«(List)␤»

[12:29] <smls> I was wondering about that case anyway: How does it know to that .[2, 4, ... *] should be a truncating slice, but .[2, 4, 6, 8] shouldn't?

[12:29] <moritz> smls: I don't know the pod syntax well enough to be able to comment on that

[12:30] <smls> Seeing how both are List objects?

[12:30] <jnthn> For one, 1, 2, 4 ... 16 won't be a list after GLR

[12:30] <jnthn> It'll be a Seq

[12:30] *** dayangkun left
[12:31] <jnthn> Either could be known infinite though

[12:31] <jnthn> I suspect asking "is this known infinite" will be the answer

[12:31] <smls> but 0..10 will also be truncating, even though it is not infinite

[12:32] <smls> "However, it is legal for a range or sequence iterator to extend beyond the end of an array"  -- what S09 has to say on the matter

[12:32] <smls> Whatever a "sequence iterator" is... :P

[12:32] <jnthn> We could change that, to fix the @a[0, 1, 2] being different from @a[^2] thing I guess

[12:32] <smls> Maybe it was written at a time when  ...  was thought to return a special object?

[12:33] <jnthn> Maybe. There's been so many models...

[12:33] <jnthn> By this point I'd rather get what we like down in code and then go make the design docs reflect it afterwards.

[12:33] <jnthn> Maybe you have to write an infinite range if you actually want the auto-truncating behavior.

[12:33] <jnthn> That'd make things far more uniform.

[12:33] * [Tux] was somehow hoping that .flat would do that recursively, so [[1,2],[2,3]].flat would return [1,2,2,3]

[12:35] <jnthn> [Tux]: You'll have to work a bit harder to flatten recursively

[12:35] * [Tux] nods

[12:35] <jnthn> [Tux]: If there's an Array there, anyways.

[12:35] <[Tux]> hence the "hope" :)

[12:36] <smls> m: dd [[1,2],[2,3]].duckmap(*.flat)

[12:36] <camelia> rakudo-moar 0dcbba: OUTPUT«([1, 2]<>, [2, 3]<>)␤»

[12:36] <smls> m: dd [[1,2],[2,3]].duckmap(*.flat).flat

[12:36] <camelia> rakudo-moar 0dcbba: OUTPUT«(1, 2, 2, 3)␤»

[12:36] <smls> m: dd [[1,2],[2,3]]».flat.flat

[12:36] <camelia> rakudo-moar 0dcbba: OUTPUT«([1, 2], [2, 3])␤»

[12:37] <smls> ^^hm, why does that one not work?

[12:37] <jnthn> No idea

[12:37] <[Tux]> what is the diff between map and duckmap?

[12:37] <jnthn> I'm not going debugging a bunch of code I'm in the process of replacing though :)

[12:37] <moritz> because >> descends into the array elements

[12:38] <jnthn> Ah

[12:38] <jnthn> Arguably .flat should be nodal though

[12:38] <moritz> m: say [["a", "b"], "c"]>>.uc.perl

[12:38] <camelia> rakudo-moar 0dcbba: OUTPUT«(["A", "B"], "C")␤»

[12:38] <smls> oh, » does a deepmap then?

[12:39] <smls> [Tux]: I should have just used .map there, .duckmap does't really help here.

[12:39] *** AlexDaniel joined
[12:39] <[Tux]> m: dd [[1,2],[2,3]].map(*.flat)

[12:39] <camelia> rakudo-moar 0dcbba: OUTPUT«(1, 2, 2, 3)␤»

[12:39] <[Tux]> that'll do

[12:39] *** yqt joined
[12:42] <moritz> m: dd [[1,2],[2,3]].map(&flat)

[12:42] <camelia> rakudo-moar 0dcbba: OUTPUT«([1, 2], [2, 3])␤»

[12:43] <smls> jnthn: Re restricting auto-truncating to infinite things, when I suggested it before, skids disagreed: http://irclog.perlgeek.de/perl6/2015-07-07#i_10863136

[12:43] <smls> Would be good to know TimToady's original intentions behind it, and what skids (and others) find it useful for.

[12:44] *** rindolf joined
[12:45] <smls> Maybe the post-GLR rule wants to be "Seq and Range subscripts truncate; List and others don't"

[12:46] *** espadrine left
[12:46] <jnthn> Doesn't feel very general

[12:46] *** rarara_ left
[12:47] <smls> true

[12:48] <jnthn> Whatever we pick, we're not going to make everyone happy all of the time, and a lot of the weight of previous list implementations came from trying to please too many competing use-cases simultaneously with too much magic.

[12:48] <smls> restricting it to *just* Range would make it a proper "special exception", but also cause neat things like this to not work:    .[2, 4 ... *]  # select all even indices

[12:48] *** mr-foobar left
[12:49] <smls> with "known infinity" that would work.

[12:49] <jnthn> Right

[12:50] <jnthn> Though I'm at this point thinking "lazy" actually marks something as "known infinite" (and perhaps hides any batching)

[12:50] <jnthn> So .[lazy 1..10] would get you back your auto-truncating

[12:50] <smls> Interesting.

[12:51] <jnthn> Though "mark" sounds mutating whereas that isn't actually what happens at all, you just get an iterator that delegates to another one and enforces one-at-a-time

[12:52] <colomon> ooooo, I like the sound of that lazy

[12:53] *** laouji left
[12:53] <skids> I could live with that.  As long as their is a way that does not involve breking out the ternaries and minus signs.

[12:57] <smls> I guess I'll have to make peace with the whole "known infinite" thing then, if various things rely on it... :P

[12:57] <smls> Please do make sure to unambiguously define when it is the case, though.

[12:58] * jnthn adds documenting those to his todo list

[12:59] <[Coke]> moritz: sorry, don't know how long it normally takes.

[12:59] <moritz> [Coke]: just make sure it's finished by 1400; in case of doubt, be defensive and run it at 0200 or so

[13:00] <dalek> perl6-roast-data: 1564ca0 | raiph++ | README.md:

[13:00] <dalek> perl6-roast-data: Try to fix the link to the latest run

[13:00] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/1564ca05c1

[13:00] <dalek> perl6-roast-data: b4ff632 | (Will Coleda)++ | README.md:

[13:00] <dalek> perl6-roast-data: Merge pull request #5 from raiph/patch-1

[13:00] <dalek> perl6-roast-data: 

[13:00] <dalek> perl6-roast-data: Try to fix the link to the latest run

[13:00] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/b4ff63265c

[13:00] *** [Tux] left
[13:00] <jnthn> Oh come on, just one diacritic per letter? :P

[13:02] <dalek> perl6-roast-data: 5140895 | moritz++ | bin/doit:

[13:02] <dalek> perl6-roast-data: Apply a memory limit to the non-JVM processes

[13:02] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/514089538c

[13:02] <dalek> perl6-roast-data: 3183852 | (Will Coleda)++ | bin/doit:

[13:02] <dalek> perl6-roast-data: Merge pull request #8 from moritz/ulimit

[13:02] <dalek> perl6-roast-data: 

[13:02] <dalek> perl6-roast-data: Apply a memory limit to the non-JVM processes

[13:02] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/31838523a8

[13:06] <hoelzro> goooood morning #perl6!

[13:06] <yoleaux> 01:22Z <japhb> hoelzro: Panda commit afd281a breaks panda on r-j, because it requires Proc::Async.  Either panda should handle lack of Proc::Async, or r-j needs to learn how to Proc::Async.  :-)

[13:08] *** spider-mario joined
[13:10] *** davido__ left
[13:10] <hoelzro> what's the proper equivalent to Perl 5's hex() function? redefining sub hex(Str $s) returns Int { (":16<" ~ $s ~ ">").Numeric } in oneliners is a bit tedious, and it may be a good opportunity for "hex() is gone, use X in Perl 6"

[13:11] *** davido__ joined
[13:12] *** espadrine_ joined
[13:12] *** espadrine_ is now known as espadrine

[13:13] <DrForr> Heh. P::RD continues to pay off in new and creative ways to break P6 string interpolation.

[13:14] <DrForr> I'm gonna owe Damian a few beers next time I see him :)

[13:15] *** cognominal joined
[13:15] <PerlJam> hoelzro: why can't you just use :16<1234>  directly?

[13:16] <hoelzro> PerlJam: ...because I'm dumb and didn't take to try :16($s)

[13:16] * hoelzro facepalms

[13:17] <PerlJam> :)

[13:17] <nine> m: $i = 1234; say :16($i) # there's also this nice hint

[13:17] <camelia> rakudo-moar 0dcbba: OUTPUT«5===SORRY!5=== Error while compiling /tmp/YLiO6K_v0J␤Variable '$i' is not declared␤at /tmp/YLiO6K_v0J:1␤------> 3<BOL>7⏏5$i = 1234; say :16($i) # there's also th␤»

[13:17] <nine> m: my $i = 1234; say :16($i) # there's also this nice hint

[13:17] <camelia> rakudo-moar 0dcbba: OUTPUT«This call only converts base-16 strings to numbers; value 1234 is of type Int, so cannot be converted!␤(If you really wanted to convert 1234 to a base-16 string, use 1234.base(16) instead.)␤  in block <unit> at /tmp/zTqbfHZY_A:1␤␤»

[13:18] <PerlJam> nine: unfortunately(?), .base(16) doesn't work on strings

[13:20] <Woodi> [5~[6~[6~[6~

[13:21] *** cognominal left
[13:24] *** AlexDani` joined
[13:26] <nine> PerlJam: fortunately, this is Perl :)

[13:26] <nine> m: my $i = "1234"; $i.Int.base(16).say

[13:26] <camelia> rakudo-moar 0dcbba: OUTPUT«4D2␤»

[13:26] *** AlexDaniel left
[13:30] <PerlJam> m: my $i = "12ab"; $i.Int.base(16).say  # oops :)

[13:30] <camelia> rakudo-moar 0dcbba: OUTPUT«Cannot convert string to number: trailing characters after number in '12⏏ab' (indicated by ⏏)␤  in block <unit> at /tmp/9eEseCmji2:1␤␤Actually thrown at:␤  in block <unit> at /tmp/9eEseCmji2:1␤␤»

[13:35] <jnthn> King James GLR: http://kingjamesprogramming.tumblr.com/post/125927093164/1929-do-not-prostitute-thy-daughter-to-cause-her

[13:36] *** ChoHag left
[13:38] <moritz> lol

[13:38] <nine> poor daughter

[13:39] <timotimo> well, if the parents heed that advice, that's good for the daughter, no?

[13:39] <nine> Well, if the parents _need_ that advice, that cannot be good for the daughter, no? :)

[13:39] <daxim> lizmat, can you use /etc/os-release instead of lsb_release, or check /etc/os-release first, lsb_release second?

[13:39] <timotimo> true

[13:40] <dalek> nqp/js: 71fe204 | (Pawel Murias)++ | src/vm/js/ (2 files):

[13:40] <dalek> nqp/js: Make array access happen through 12275bindpos/12275atpos instead of using [] directly

[13:40] <dalek> nqp/js: review: https://github.com/perl6/nqp/commit/71fe20448d

[13:41] <lizmat> daxim: that's how it's coded already....  lsb_release is only called if /etc/os-release does not exist

[13:42] *** khw joined
[13:42] <hoelzro> japhb: got it, I'll try to fix it

[13:42] <daxim> cool, I didn't see that

[13:42] <smls> I like this one: http://kingjamesprogramming.tumblr.com/post/121918434069/154-and-i-will-send-serpents-cockatrices-among

[13:48] <moritz> smls: yes, that's nice

[13:48] *** rindolf left
[13:49] <hoelzro> is it possible to unpack hash values via assignment (something like my { :$value } = { :value<17> } )?

[13:50] <smls> m: my %a = a => 1, b => 2; my (:$a, :$b) := %a; dd $a, $b

[13:50] <camelia> rakudo-moar 0dcbba: OUTPUT«1␤2␤»

[13:50] <smls> if the variables are named differently, use  :key($var)  as you would in any signature.

[13:51] <hoelzro> huh, I tried that...

[13:51] <smls> did you use binding?

[13:51] <hoelzro> ooooh

[13:51] <hoelzro> thanks smls 

[13:52] <hoelzro> smls++

[13:55] *** jkva joined
[13:57] *** laouji joined
[14:04] <hoelzro> has anyone here tried Linenoise on Windows? I'd like to hear if it works

[14:05] <jnthn> hoelzro: No, need to use binding for unpacks

[14:05] <jnthn> oh, smls++ beat me

[14:08] <jnthn> GLR gist updated with gather/take support, including take slip(...); handling: https://gist.github.com/jnthn/aa370f8b32ef98e4e7c9

[14:09] <dalek> doc: 8da95e9 | smls++ | lib/Language/subscripts.pod:

[14:09] <dalek> doc: subscripts: Fill in the "Slices" section

[14:09] <dalek> doc: review: https://github.com/perl6/doc/commit/8da95e9fd3

[14:10] <smls> ^^ documented the current Rakudo/spec design for now, but added POD comments so we won't forget to update things post-GLR

[14:10] <jnthn> For anyone not also on #moarvm (where most of the serious performance analysis discussion goes on), here's some numbers so far:

[14:10] <jnthn> gather/take assigned into an array ==> was 0.525030056635539s, now 0.224679549535116s

[14:10] <jnthn> for loop over gather/take ==> was 3.6518755753835s, now 0.570699373881022s

[14:10] <jnthn> That's the bottom two benchmarks

[14:10] <tony-o> jnthn++

[14:11] <tony-o> damn that's a nice improvement

[14:12] <timotimo> "bottom two" doesn't mean "the ones where we win the least"

[14:12] <hoelzro> does :ignorecase apply to character ranges like <[a..f]>?

[14:12] <timotimo> yes

[14:12] <jnthn> timotimo: No, I mean textually in the gist

[14:12] <timotimo> it's supposed to. if it doesn't work, that'd be a bug

[14:13] <jnthn> Oh, those numbers are before I have a MoarVM with timotimo++'s inline threshold tuning

[14:13] * jnthn builds to see if it gives any boost

[14:14] <hoelzro> m: '"%E3%81%82" ~~ m:ignorecase/["%" (<[a..f0..9]> ** 2)]+/ && say $/[0]'

[14:14] <camelia> rakudo-moar 0dcbba: OUTPUT«WARNINGS:␤Useless use of constant string "\"%E3%81%82\" ~~ m:ignorecase/[\"%\" (<[a..f0..9]> ** 2)]+/ && say $/[0]" in sink context (line 1)␤»

[14:14] <hoelzro> grr, shell quoting

[14:14] <hoelzro> m: "%E3%81%82" ~~ m:ignorecase/["%" (<[a..f0..9]> ** 2)]+/ && say $/[0]

[14:14] <camelia> rakudo-moar 0dcbba: OUTPUT«｢81｣ ｢82｣␤»

[14:14] <hoelzro> should I rakudobug that?

[14:15] <jnthn> Sadly, nothing much

[14:16] <timotimo> jnthn: i feared as much :\

[14:18] *** jkva left
[14:21] <PerlJam> m: "%E3%81%82" ~~ m:ignorecase/ "%" <[a..f0..9]> / && say $/;

[14:21] <camelia> rakudo-moar 0dcbba: OUTPUT«｢%8｣␤»

[14:22] <PerlJam> "%E3%81%82" ~~ m:ignorecase/ "%" <[a..f]> / && say $/;

[14:22] <PerlJam> m: "%E3%81%82" ~~ m:ignorecase/ "%" <[a..f]> / && say $/;

[14:22] <camelia> rakudo-moar 0dcbba: OUTPUT«｢%E｣␤»

[14:22] <hoelzro> interesting find PerlJam 

[14:23] <hoelzro> PerlJam: could you put your findings on https://rt.perl.org/Ticket/Display.html?id=125753 ?

[14:23] * jnthn ponders what next for the GLR work

[14:25] <dalek> nqp/js: eb81a56 | (Pawel Murias)++ | src/vm/js/nqp-runtime/ (3 files):

[14:25] <dalek> nqp/js: Implement positional_delegate

[14:25] <dalek> nqp/js: review: https://github.com/perl6/nqp/commit/eb81a565b0

[14:25] <dalek> nqp/js: 22a103c | (Pawel Murias)++ | src/vm/js/ (2 files):

[14:25] <dalek> nqp/js: Binding and accessing a hash is done through $$bindkey/$$atpos.

[14:25] <dalek> nqp/js: review: https://github.com/perl6/nqp/commit/22a103c1d9

[14:25] <dalek> nqp/js: fa6709e | (Pawel Murias)++ | src/vm/js/ (3 files):

[14:25] <dalek> nqp/js: Pass test 73.

[14:25] <dalek> nqp/js: 

[14:25] <dalek> nqp/js: Implement associative_delegate.

[14:25] <dalek> nqp/js: review: https://github.com/perl6/nqp/commit/fa6709ea60

[14:26] <PerlJam> hoelzro: updated

[14:26] <hoelzro> PerlJam: thanks!

[14:26] <jnthn> I guess lazy loops (lazy while/until/loop and so on) come next

[14:26] <jnthn> Then maybe I should try hyper/race

[14:27] <timotimo> you could try recruiting people to build some fast-path versions of push-all (or pull-all?)

[14:30] <jnthn> *nod*

[14:30] <jnthn> Well, I'd start by writing benchmarks to make sure such things pull their weight

[14:31] <PerlJam> hoelzro: check this out ...

[14:31] <jnthn> For example, writing one for 0 xx * is kinda pointless because inlining basically writes it for you.

[14:31] <PerlJam> m: '%E3%81%82' ~~ m:ignorecase/['%' (<[abcdef0123456789]> ** 2)]+/ && say $/[0];

[14:31] <camelia> rakudo-moar 0dcbba: OUTPUT«｢E3｣ ｢81｣ ｢82｣␤»

[14:31] <PerlJam> hoelzro: I guess something is broken with character class ranges?

[14:33] <jnthn> PerlJam: Other fun question is if you can rely on chr(start)..chr(end) being contiguous implying chr(uc(start))..chr(uc(end)) being

[14:33] <jnthn> PerlJam: And the answer is surely no because that'd make life way too easy :)

[14:33] <jnthn> PerlJam: So it'll need a bit of care to fix, but shouldn't be too bad :)

[14:34] <jnthn> Trouble is though that then you lose the nice charrange optimization

[14:34] <jnthn> Or at least, if you want to keep it you've got some analysis to do

[14:34] <jnthn> Anyway, long story short I can see why it didn't get done yet. I agree it probably should be. :)

[14:35] * PerlJam adds to the ticket for now.

[14:36] <jnthn> *nod*

[14:38] *** cognominal joined
[14:40] <dalek> perl6-roast-data: 1c78d6e | coke++ | / (8 files):

[14:40] <dalek> perl6-roast-data: today (automated commit)

[14:40] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/1c78d6e22d

[14:43] <tony-o> jamming through these http::server::async tests, the rewrite + the work you guys did on the core io::socket::async is looking good so far

[14:43] *** kyclark joined
[14:44] *** isBEKaml joined
[14:48] <hoelzro> PerlJam: interesting...thanks for digging into that further!

[15:02] *** isBEKaml left
[15:04] *** hobbified joined
[15:04] *** FatalNIX left
[15:04] *** pnu left
[15:04] *** AlexDani` is now known as AlexDaniel

[15:05] *** pnu joined
[15:05] <moritz> http://perlpunks.de/paste/show/55c2262e.6617.290 # current r-m spectest failures

[15:05] *** FatalNIX joined
[15:10] <[Coke]> 

[15:12] <smls> m: my %a = a=>1, b=>2, c=>3; say %a

[15:12] <camelia> rakudo-moar 0dcbba: OUTPUT«a => 1, b => 2, c => 3␤»

[15:12] <smls> ^^ Is this new? (The comma separation in .gist output)

[15:13] <[Coke]> star: my %a = a=>1, b=>2, c=>3; say %a

[15:13] <camelia> star-m 2015.03: OUTPUT«a => 1, b => 2, c => 3␤»

[15:14] *** kyclark left
[15:18] <moritz> https://github.com/perl6/roast/blob/master/S17-supply/start.t why is [1, 1] in line 34?

[15:18] *** kyclark joined
[15:19] <moritz> $master.emit(2); # shall not be seen

[15:19] <moritz> why not?

[15:20] <TimToady> shh!

[15:21] <moritz> is Supply.start limited to keeping just one Promise?

[15:22] <tony-o> HTTP::Server::Async has breaking changes and now conforms to HTTP::Server 

[15:22] <tony-o> it's also a lot more stable

[15:22] <timotimo> good! :) 

[15:23] <moritz> skimming http://design.perl6.org/S17.html#Supplies I see no evidence for that

[15:24] <moritz> oh, it's probably related to the sleep $_; thing

[15:25] <moritz> and hoping that the sleep 2 isn't run at the time the is() is run

[15:25] <jnthn> tony-o: yay, my days of concurrency debugging did something :)

[15:25] <moritz> erm, is-deeply

[15:25] <tony-o> jnthn: they did a lot, not sure if you saw my `siege` gist a few days ago :-)

[15:25] <jnthn> tony-o: Now just need to get throughput better ;)

[15:25] <jnthn> tony-o: Yes, I saw it survived

[15:26] <tony-o> https://gist.github.com/tony-o/2b5840bd5bec4be6cbab

[15:26] <tony-o> well, it survived and had 10 concurrent requests - it used to puke on >1 request 

[15:26] <jnthn> :)

[15:26] <jnthn> No idea how bad 71 trans/sec is though :)

[15:27] <jnthn> yay, plumbing for lazy loop { ... } with next/redo/last support is working

[15:28] <jnthn> Now need the variant with a condition and post-action

[15:28] <tony-o> 71 trans/sec seems decent enough 

[15:28] *** rindolf joined
[15:29] <jnthn> tony-o: OK, nice :)

[15:34] <flussence> that's within the same ballpark I got last time I ran siege on some php stuff

[15:34] <flussence> I guess the days of p6 being "too slow" are over then :)

[15:35] <tony-o> looking at other siegers' articles and they're around 50 trans/sec so it'll probably slow down with actual practice

[15:35] <tony-o> flussence++

[15:36] <flussence> (porting/rewriting some old php stuff has been on my todo list for... quite a while)

[15:38] *** erdic joined
[15:39] *** preyalone joined
[15:39] <dalek> ecosystem: f29d4a0 | tony-o++ | META.list:

[15:39] <dalek> ecosystem: removing pandapack from ecosystem

[15:39] <dalek> ecosystem: review: https://github.com/perl6/ecosystem/commit/f29d4a00da

[15:39] <dalek> roast: a4c2a2c | moritz++ | S17-supply/start.t:

[15:39] <dalek> roast: sleep less in S17-supply/start.t

[15:39] <dalek> roast: 

[15:39] <dalek> roast: also make it a bit more robust; now it should not error out if the machine is

[15:39] <dalek> roast: too slow

[15:39] <dalek> roast: review: https://github.com/perl6/roast/commit/a4c2a2c3b2

[15:40] *** preyalone left
[15:40] *** pnu left
[15:40] *** FatalNIX left
[15:40] *** pnu joined
[15:40] <japhb> ++hoelzro  # Making r-j and panda play nice together again

[15:40] *** preyalone joined
[15:40] *** pnu left
[15:40] *** pnu joined
[15:41] <japhb> tony-o: I had missed that siege gist the first time around, very cool!  Where is the code?

[15:41] *** FatalNIX joined
[15:43] <tony-o> japhb: https://github.com/tony-o/perl6-http-server-async

[15:45] *** captain-adequate joined
[15:46] <jnthn> back later &

[15:49] <dalek> doc: f80d844 | smls++ | lib/Type/Positional.pod:

[15:49] <dalek> doc: Remove postcircumfix:<[ ]> documentation from /type/Positional

[15:49] <dalek> doc: 

[15:49] <dalek> doc: It's covered by /language/subscripts now.

[15:49] <dalek> doc: review: https://github.com/perl6/doc/commit/f80d844ef5

[15:49] <dalek> doc: d0e295b | smls++ | lib/Language/operators.pod:

[15:49] <dalek> doc: solidify documentation of subscripts at /language/operators

[15:49] <dalek> doc: 

[15:49] <dalek> doc: The corresponding secions now provide a short overview / usage

[15:49] <dalek> doc: demonstration, and link to /language/subscripts for further

[15:49] <dalek> doc: details.

[15:49] *** smls left
[15:49] <dalek> doc: Also moved up the .[ ] section so that all subscript operator

[15:49] <dalek> doc: sections are grouped together.

[15:49] <dalek> doc: review: https://github.com/perl6/doc/commit/d0e295be0b

[15:49] <japhb> tony-o: Thank you, but I actually meant the code for "siege" itself.

[15:49] <japhb> Where does that come from?

[15:49] <timotimo> it's a tool

[15:49] *** smls joined
[15:49] <timotimo> apt-get'll have it

[15:51] <japhb> Ah, fair enough.  I can see the value in using a bulletproof client to test a server that is still being reinforced.

[15:51] <timotimo> sure

[15:52] <smls> "If you want your objects to respond to the call operator, you need to implement a method postcircumfix:<( )> ."  -- from /language/operators

[15:52] <smls> that's wrong now, isn't it?

[15:52] <timotimo> right, we have CALL-ME now

[15:52] <smls> right

[15:53] <dalek> roast: aa3f208 | moritz++ | S17-supply/start.t:

[15:53] <dalek> roast: Speed up S17-supply/start.t a bit more

[15:53] <dalek> roast: 

[15:53] <dalek> roast: sadly I was not able to get rid of sleep() entirely

[15:53] <dalek> roast: review: https://github.com/perl6/roast/commit/aa3f208a23

[15:53] <dalek> roast: 7a53036 | moritz++ | S17-supply/start.t:

[15:53] <dalek> roast: Get rid of another sleep in S17-supply/start.t

[15:53] <dalek> roast: 

[15:53] <dalek> roast: only one remaining

[15:53] <dalek> roast: review: https://github.com/perl6/roast/commit/7a53036db5

[15:53] <smls> timotimo: And if one *were* to override the actual postfix, one would have to export a multi sub rather than implement it as a method, right?

[15:54] <timotimo> not sure

[15:54] *** EINVAL joined
[15:55] *** kyclark left
[15:55] *** virtualsue left
[15:56] *** kyclark joined
[15:57] *** yqt left
[15:59] <dalek> doc: 7a15fea | smls++ | lib/Language/operators.pod:

[15:59] <dalek> doc: recommend CALL-ME instead of overloading postcircumfix:<( )>

[15:59] <dalek> doc: review: https://github.com/perl6/doc/commit/7a15fea89e

[16:03] *** ChoHag joined
[16:03] <dalek> roast: 84b7f16 | moritz++ | S17-procasync/kill.t:

[16:03] <dalek> roast: Avoid IPC to sleeping

[16:03] <dalek> roast: review: https://github.com/perl6/roast/commit/84b7f169aa

[16:05] <dalek> roast: 5314d06 | moritz++ | S17-scheduler/times.t:

[16:05] <dalek> roast: Don't need no sleep with CurrentThreadScheduler

[16:05] <dalek> roast: review: https://github.com/perl6/roast/commit/5314d06756

[16:09] *** EINVAL left
[16:11] <dalek> doc: f497cd4 | smls++ | lib/Language/operators.pod:

[16:11] <dalek> doc: fix typo

[16:11] <dalek> doc: review: https://github.com/perl6/doc/commit/f497cd44a5

[16:15] *** mr-foobar joined
[16:17] *** [Sno] left
[16:18] *** Begi joined
[16:20] <b2gills> ChoHag: Is this what you are looking for `for pairs -> ( :key($a), :value($b) ) { say $a, $b }` or `for pairs -> ( :$key, :$value ) { say $key, $value }`

[16:22] <smls> m: for (a=>10), (b=>20), (c=>30) -> ( :$key, :$value ) { say "$key:$value" }

[16:22] <camelia> rakudo-moar 0dcbba: OUTPUT«a:10␤b:20␤c:30␤»

[16:23] <smls> Huh. How does that work?

[16:23] <timotimo> it calls the "key" and "value" method, iirc

[16:23] <timotimo> m: for "hi", "how", "are", "you" -> ( :$uc, :$tc ) { say $uc; say $tc }

[16:23] <camelia> rakudo-moar 0dcbba: OUTPUT«(Mu)␤(Mu)␤(Mu)␤(Mu)␤(Mu)␤(Mu)␤(Mu)␤(Mu)␤»

[16:23] <timotimo> oops

[16:23] <smls> so how does a :foo parameter know whether it should unpack .<foo> or .foo() ?

[16:24] <timotimo> it'll never unpack .<foo> i think

[16:24] <timotimo> oh, hold on

[16:24] <timotimo> that's about Associative vs not, i suppose?

[16:24] <smls> smells fishy

[16:25] <smls> Associative object have methods too... :P

[16:25] <smls> Wouldn't it be better to have a separate syntax for method-based unpacking?

[16:29] <ChoHag> It seems to be, but curiously despite apparently looping over the same items in the same way, the overall effect of the function is different.

[16:29] *** brisby joined
[16:31] <jdv79> why doesn't this work as i expect?:  https://gist.github.com/anonymous/2dd40701854756dc47a4

[16:32] <jdv79> i just want a custom array type for the slot typing - otherwise an array

[16:32] *** [Sno] joined
[16:33] *** yqt joined
[16:33] *** kyclark left
[16:33] *** FROGGS joined
[16:37] *** nys joined
[16:37] <timotimo> m: https://gist.github.com/anonymous/2dd40701854756dc47a4

[16:37] <camelia> rakudo-moar 0dcbba: OUTPUT«1␤A<139755513461576>␤A.new␤»

[16:38] *** telex left
[16:38] *** kyclark joined
[16:39] *** Begi left
[16:39] *** zakharyas left
[16:40] *** telex joined
[16:40] *** kyclark left
[16:42] <jdv79> oh, i forgot to apply the subset but the intent is there.  that part works anyway.

[16:42] <timotimo> mhm, i was wondering about that

[16:42] <timotimo> i don't know what's wrong about that

[16:43] *** kyclark joined
[16:43] <timotimo> the submethod BUILD seems superfluous

[16:43] <jdv79> but Str, join, elems should all work as an array, right?

[16:43] <jdv79> i was told its necessary to set a private attr via a constructor

[16:43] <jdv79> and that part works 

[16:44] <timotimo> no good results for "handles" in the design docs google search

[16:45] <jdv79> http://design.perl6.org/S12.html#Delegation

[16:45] <timotimo> Wildcard matches are evaluated only after it has been determined that there's no exact match to the method name anywhere in this object or in any of its parents.

[16:45] <timotimo> since Any gives you Str, join and elems ... yeah

[16:46] <jdv79> oh...

[16:46] <timotimo> so you may want "handles Positional"?

[16:47] <jdv79> that doesn't work

[16:47] <timotimo> If instead you want to delegate completely and utterly, including a search of the delegate for its own fallback methods, with abject failure if the delegate can't handle it, then use the "HyperWhatever" instead:

[16:47] <jdv79> inherriting from Mu does

[16:47] <jdv79> wonder if that's bad in any way

[16:47] <timotimo> yeah, it is

[16:47] <timotimo> the great majority of parameters and variables and such are constrained to at least Any

[16:47] *** pmurias left
[16:48] *** diana_olhovik joined
[16:48] <lizmat> moritz: are we sure it is wise to test some async features with other async features, such as Channel?

[16:48] <jdv79> that doesn't work either

[16:48] <jdv79> :(

[16:48] <TimToady> handles Positional makes a lot of sense, someone should make it work

[16:49] <jdv79> bug that?

[16:49] * timotimo bbml

[16:50] <TimToady> especially since the methods supplied by a role are known at compile time, so it's no longer in wildcard status (and performance)

[16:51] <moritz> lizmat: better than testing with sleep, IMHO

[16:51] <TimToady> basically, if an entry in the list is a role instead of a string, we should slip in the methods of the role there

[16:51] <moritz> lizmat: and we use promises anyway

[16:52] <lizmat> feels wrongish to me, but if it makes you happy  :-)

[16:54] <moritz> well, the problem with sleep is that it carries at lot of assumptions

[16:54] <jdv79> is there a workaround for now?  as in, is there a way to get a list of all methods of self and parents recursively?

[16:54] <moritz> for one, sleep($n) is always "sleep at least $n seconds"

[16:55] <jdv79> easily i mean.

[16:55] <moritz> so if you have two sleep($n), you have no guarantuee that they sleep roughly the same time

[16:55] *** Begi joined
[16:56] <jdv79> like moose's $metaclass->get_all_methods

[16:57] <lizmat> moritz: hmmm...

[16:57] <moritz> jdv79: for $obj.^mro -> $class { say $class.^methods(:local) }

[16:57] <moritz> lizmat: also, it's sort of slow with sleep

[16:58] <lizmat> yeah, *that* I agree with  :-)

[17:00] *** kyclark left
[17:02] *** bronco_creek joined
[17:08] <bronco_creek> .tell jnthn It looks to me like there is a mis-matched ")" at the end of line 72 in https://gist.github.com/jnthn/aa370f8b32ef98e4e7c9

[17:08] <yoleaux> bronco_creek: I'll pass your message to jnthn.

[17:12] *** domidumont joined
[17:14] <Begi> Oh, a new page on the doc ? http://doc.perl6.org/language/subscripts Thanks ! :)

[17:16] *** domidumont left
[17:16] *** kaare_ left
[17:17] *** domidumont joined
[17:19] *** domidumont left
[17:26] <jnthn> From backlog: I think the supply tests should be done in terms of a test scheduler with virtualized time, like we do with Rx tests, which removes the slowness and fragility. We just don't have a test scheduler like that implemented yet.

[17:26] <yoleaux> 17:08Z <bronco_creek> jnthn: It looks to me like there is a mis-matched ")" at the end of line 72 in https://gist.github.com/jnthn/aa370f8b32ef98e4e7c9

[17:27] *** kaare_ joined
[17:28] <jnthn> bronco_creek: So there is :)

[17:28] <jnthn> bronco_creek: Fixed, thanks.

[17:29] <jnthn> Also about how the unpacking works: it calls .Capture on the incoming argument

[17:29] <jnthn> A Hash fills the Capture's named part with its things

[17:29] <jnthn> An object looks through it's attributes taht have accessors and uses that to populate named slots

[17:30] <dalek> doc: bdd43d9 | smls++ | lib/Language/subscripts.pod:

[17:30] <dalek> doc: subscripts#Slices: improve clarity; document Zen & Whatever slices

[17:30] <dalek> doc: review: https://github.com/perl6/doc/commit/bdd43d9e90

[17:31] *** rindolf left
[17:33] *** kaare_ left
[17:34] <TimToady> jnthn: hate to say it, but a 2000 line file is not a "gist" anymore, and makes it hard to follow diffs, unless there's some mechanism I don't know about...

[17:34] *** espadrine left
[17:34] *** kaare_ joined
[17:35] *** lucasb joined
[17:36] <jnthn> TimToady: You're aware of the Revisions tab?

[17:36] <jnthn> On the right?

[17:37] *** brisby left
[17:38] <jnthn> https://gist.github.com/jnthn/aa370f8b32ef98e4e7c9/revisions if you don't find the link

[17:41] <lucasb> If the GLR is going to ship in August, then why not merge it now, or at least put it in a branch. The details can be fixed after this :D

[17:42] <lucasb> jnthn++, I'm just eager to have the new semantics :)

[17:44] <leedo> TimToady: jnthn iirc you can actually clone a gist with git

[17:44] *** kyclark joined
[17:45] <jnthn> leedo: Yes, I knew that, but good to mention...TimToady++ may prefer to read diffs that way.

[17:46] <jnthn> lucasb: There's nothing in a mergeable state yet

[17:46] *** rindolf joined
[17:46] <jnthn> lucasb: As to "why not in a bracnh", because the moment this code goes into CORE.setting my development velocity on it will be slower due to build times.

[17:47] <jnthn> lucasb: It's not quite a the point where the cost/benefit supports moving development to a Rakudo branch yet.

[17:47] <jnthn> Expect we'll be at that point around the weekend.

[17:47] <lucasb> jnthn: ok, thanks to explain and thanks for the GLR, jnthn++

[17:48] <nwc10> jnthn: so, in the context of the GLR - Is it Friday?

[17:51] *** yqt left
[17:51] <jnthn> Well, just 'cus the branch may well exist on Friday doesn't mean it'll survive the build... :)

[17:51] <jnthn> dinner's ready &

[17:55] <RabidGravy> of course it's Friday

[17:56] <ugexe> seem to have hit a strange bug on osx where i get `await $promise; say $promise.perl` showing $promise as planned (its not waiting). if i do `$promise.result; await $promise; say $promise.perl` it shows the promise as Kept after properly awaiting. 

[17:56] *** [Sno] left
[17:56] *** [Sno] joined
[17:59] <TimToady> okay, didn't see the revisions tab because I blow up the text on the left to fill my screen, because the blamed contrast is so low with light gray letters on white

[17:59] <TimToady> will definitely clone it :)

[17:59] *** araujo left
[18:01] <mst> TimToady: the only thing that isn't versioned in github is issues and PRs

[18:02] *** kyclark left
[18:06] <TimToady> well, chalk it up to youthful ignorance :)

[18:06] <dalek> roast: d2d4f7a | usev6++ | S32-exceptions/misc.t:

[18:06] <dalek> roast: Add test for RT #125754

[18:06] <dalek> roast: review: https://github.com/perl6/roast/commit/d2d4f7a99b

[18:06] <synbot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=125754

[18:08] *** Begi left
[18:09] <jnthn> ugexe: That sounds horribly like a condvar spurious wake-up...and I *think* Promise uses condvars...

[18:11] <jnthn> ugexe: Please RT it

[18:11] *** spider-mario left
[18:16] <mst> TimToady: the hilarious thing then being that if somebody mis-edits an issue text the old version is permanently lost

[18:16] <mst> TimToady: the irony ... is palpable

[18:18] <lucasb> Is there something like 'sub f(&c is thunked)', where in 'f(EXPR)', EXPR will not be evaluated at function call time, just when I call it inside my sub?

[18:19] <jnthn> That's what a macro is for

[18:19] <lucasb> I know I could explicit pass a block as argument. This is just for syntax sugar.

[18:22] *** yqt joined
[18:25] *** domidumont joined
[18:25] *** jkva joined
[18:26] <lucasb> I try playing with macros for a bit...

[18:27] <jnthn> lucasb: Yeah...I'm afraid they're a bit fragile so far, though :(

[18:30] *** TEttinger joined
[18:32] <ChoHag> What's the canonical mechanism to create a coderef? my $foo = sub { ... } as before, or doing something fancy with one of the new classes?

[18:33] <ChoHag> And on a related note, can multi subs be associated with a single coderef?

[18:35] <hoelzro> ChoHag: you can also do -> { .. } (ex. my $foo = -> { ... })

[18:35] *** domidumont left
[18:35] <hoelzro> the arrow is optional if you want to allow implicit params like $_ and $^param

[18:35] * hoelzro .oO( I wonder why → isn't allowed as a block-introducing arrow? )

[18:35] <ChoHag> Too many arrows in unicode?

[18:36] <hoelzro> ChoHag: and what exactly do you mean by associating a single coderef with multi subs?

[18:36] <hoelzro> could you provide an example

[18:36] <hoelzro> ?

[18:36] <gfldex> m: my $a = multi sub { 2 }; say $a();

[18:36] <camelia> rakudo-moar 0dcbba: OUTPUT«5===SORRY!5=== Error while compiling /tmp/oluhhU4wvD␤An anonymous routine may not take a multi declarator␤at /tmp/oluhhU4wvD:1␤------> 3my $a = multi sub { 2 }7⏏5; say $a();␤    expecting any of:␤        horizontal whitespace␤        …»

[18:36] <gfldex> std: my $a = multi sub { 2 }; say $a();

[18:36] <camelia> std 28329a7: OUTPUT«ok 00:00 139m␤»

[18:36] <hoelzro> ah, now I see

[18:36] <ChoHag> Something like $s = multi sub (Str $a) { ... } | multi sub (Int $a) { ... };

[18:37] <jnthn> No, though you can exploit do and lexical scoping to get pretty close I guess

[18:37] <jnthn> $s = do { multi x (Str $a) { ... }; ...other multis...; &x }

[18:38] <ChoHag> Should probably be made possible in perl 6.something.

[18:38] <gfldex> m: my &a = sub { 2 }; say &a(); my Callable $b = sub { 3 }; say $b();

[18:38] <camelia> rakudo-moar 0dcbba: OUTPUT«2␤3␤»

[18:38] <gfldex> two ways to be explicit

[18:39] <ChoHag> jnthn: Will the symbol x be confined to the do block?

[18:39] <jnthn> ChoHag: Yes

[18:46] <ugexe> filed an RT. not able to reproduce an example outside of the entire program, but included a (hopefully) relative snippet

[18:53] *** captain-adequate left
[18:53] <ChoHag> How (in apply_handles in an attribute trait role) can I add a private method?

[18:54] <moritz> ChoHag: http://doc.perl6.org/type/Metamodel::PrivateMethodContainer#method_add_private_method

[18:54] <ChoHag> The naïve answer is wrong: $pkg.^add_method("!foo", sub { ... });

[18:54] <ChoHag> Ah there it is.

[18:55] <ChoHag> Might not be a terrible idea to warn that method names passed to add_method with an initial ! don't do what you think.

[18:56] <moritz> ChoHag: doc patches very welcome!

[18:58] <moritz> (the methods themselves shouldn't warn; it's the MOP, not end-user facing)

[19:02] <ChoHag> I've added a simple (for now) private method but obviously shouldn't be using the mop to get an attribute's value as it's obstinately read-only (Cannot modify an immutable Int): $pkg.^add_private_method("foo", sub ($instance:) { my \r = $att.get_value($instance); say "something"; return-rw r; });

[19:02] <ChoHag> How should I correctly get the value?

[19:03] <moritz> I think you need to declare the routine itself as rw too

[19:03] <moritz> sub ($instance) is rw { ... }

[19:03] <ChoHag> I tried that.

[19:04] <moritz> maybe look at how rakudo auto-generatres RW accessors?

[19:05] <ChoHag> And again just now, because it's late and I'm forgetting what I did.

[19:05] <moritz> should be in BOOTSTRAP.nqp (not sure though)

[19:05] <jnthn> In Attribute class, iirc

[19:05] <ChoHag> It does something big and ugly with nqp in core/Attribute.pm

[19:05] <jnthn> I think "is rw" and return-rw must be paired though

[19:05] <jnthn> Or just use the "fall off the end" return appraoch inside an is rw

[19:06] <ChoHag> ... remains immutable.

[19:06] <moritz> ah, it uses nqp::getattr

[19:06] <moritz> it's probably get_value that decontainerizes

[19:06] *** diana_olhovik left
[19:06] <ChoHag> I think copying from Attribute.pm may be the way to go :/

[19:06] *** rindolf left
[19:06] <jnthn> If get_value does it wants fixing...

[19:07] <jnthn> grr, it does as well

[19:07] <ChoHag> Yay! Stumbled into another bug!

[19:07] <moritz> well, it says get_*value*, not get_container

[19:07] <jnthn> True

[19:07] <moritz> maybe a separate get_container method would work

[19:07] <jnthn> I still thing it's probably more useful if it's rw though

[19:07] <jnthn> Hm, or that

[19:07] <jnthn> Though there's only one set_value

[19:08] <ChoHag> Both would be logical.

[19:08] <ChoHag> It's the mop after all.

[19:09] <ChoHag> Does a set_container make sense?

[19:12] *** mohij joined
[19:12] *** estrabd left
[19:12] *** spider-mario joined
[19:13] <moritz> not really, set_value already binds

[19:14] <moritz> (yes, it's mis-named)

[19:14] *** jkva left
[19:14] <bronco_creek> jnthn: You're welcome.  Thanks for the excellent notes on the GLR.

[19:19] *** skids left
[19:24] *** bronco_creek left
[19:25] *** nowan joined
[19:28] *** jjido joined
[19:28] *** nowan_ left
[19:29] *** domidumont joined
[19:30] <jnthn> The GLR gist is now updated with code/tests for lazy loop/while/repeat stuff

[19:30] <jnthn> (modulo labels and phaser calls, but hey, we didn't have lazy loops at all so far, so there's no big hurry on them)

[19:31] <jnthn> Didn't do the "receives the conditon" form of them yet either, but again, can come later

[19:34] <smls> "we didn't have lazy loops at all so far" - we didn't?

[19:34] <ChoHag> Then how about set() and get()/get():container (or get()/get():value)

[19:34] <DrForr> Oi. What's the accepted way to remove a key from a hash? There's no obvious assignment and 'delete' and 'remove' don't show up in the online help.

[19:34] <ChoHag> Anyway I'm both too new to perl 6 to have an informed opinion and going to bed.

[19:35] <ChoHag> %hash<key>:delete

[19:36] <DrForr> Ah, an adverb. Right. Maybe we should add those to online help somehow?... Also, thanks :)

[19:36] *** ChoHag left
[19:36] <smls> m: say (lazy for ^5 { say "for"; $_ }).map({ say "map"; $_ })

[19:36] <camelia> rakudo-moar 0dcbba: OUTPUT«for␤for␤for␤for␤for␤map␤map␤map␤map␤map␤0 1 2 3 4␤»

[19:36] <smls> ok then :P

[19:36] <tony-o> but finally, right click in cmd pastes..only took 30 years

[19:37] <[Coke]> DrForr: docs.perl6.org -> language -> search "delete" -> subscript adverb :delete

[19:37] <smls> DrForr: I documented it at http://doc.perl6.org/language/subscripts#:delete just this week :P

[19:37] <smls> theoretically, they should show up in the search

[19:37] <DrForr> The search is broken under Opera. Hrm.

[19:37] <jnthn> smls: I quite clearly was meaning that in the context of loop/while/repeat

[19:38] <smls> DrForr: It's broken for be in Firefox too

[19:39] <DrForr> (could no longer stand FF taking up 90% RAM just for a second.)

[19:39] <smls> the live version, that is. In my local checkout on http://127.0.0.1:3000, it works...

[19:40] <tony-o> i was under the impression that opera dev had stopped

[19:40] <[Coke]> please open issues for borked browsers, we'll see what we can do.

[19:40] <[Coke]> firefox at least.

[19:41] <tony-o> works on chrome

[19:41] <[Coke]> tony-o: opera had a release -yesterday- :)

[19:41] <smls> DrForr: Here's what I get locally when I enter "delete" in the search box: http://i.imgur.com/vrhv9Li.png

[19:42] *** khw left
[19:43] <DrForr> Nod. Adverbs themselves don't appear to be documented directly, there's another issue..

[19:43] *** khw joined
[19:44] <smls> They are documented as subsections on language pages, and marked with POD syntax so that they show up in the search.

[19:44] <jnthn> TimToady: I'm figuring the return types of hyper/race are Seq, and the moment you pull-one it kicks off the parallel work, assuming it can work ahead and produce everything into a buffer that future pull-one calls eat from (and if we get clever later, push-exactly and friends can do smarter stealing from the buffer)

[19:44] <DrForr> I didn't see them in the Hash documentation online.

[19:45] <smls> DrForr: Also, sub/method/operator entries tend to list their supported adverbs, in this case: http://doc.perl6.org/language/operators#postcircumfix_{_}

[19:45] <jnthn> TimToady: I'm also wondering, in connection with my "does lazy just set the infinite flag", if we'd be better off dropping the whole "known infinite" thing and instead talk about "forced lazy"

[19:45] <jnthn> TimToady: Which fits very nicely with things like array assignment evaluating up to the first "forced lazy" thing

[19:45] *** jkva joined
[19:45] *** khw left
[19:45] <smls> DrForr: That's because it's npot provided by hash, it's provided by postcircumfix { } which is a generic interface (i.e. Hash is just one of the things that use it.)

[19:46] <jnthn> TimToady: It'd actually work the same as I have it now, it's just a conceptual rename that feels clearer in semantic intent to me

[19:47] <smls> DrForr: Which is not to say that the documentation for Hash couldn't mention it and demonstrate it with an example.

[19:47] <tony-o> i don't even get a search bar on FF..a jquery issue

[19:48] <jnthn> TimToady: eager would also then give a Seq that evaluates/buffers the lot on first pull-one, makes push-until-infinite mean push-all, and if you are doing push-all anyway then it skips the whole buffering thing (and it counts as a useless use of eager)

[19:48] <jnthn> (though we don't have to whine)

[19:48] <jnthn> I think this is the first time I've understood how to implement eager/lazy in a sane way :)

[19:49] <[Coke]> tony-o: please open a ticket with a stack trace if possible.

[19:49] <DrForr> Well, at the least a pointer to the {} circumfix operator and an explanation that this is where *other* things that can be done to hashes are would be a great help.

[19:49] *** jkva left
[19:49] <jnthn> TimToady: The things that default to known infinite today then can be said to default to born lazy.

[19:50] <tony-o> looks like it's a problem with the way FF is loading jquery ..

[19:50] <jnthn> As another data point, I don't have a single place yet where I care for "known finite".

[19:52] <[Coke]> we need to remove the "async", I bet.

[19:53] <[Coke]> if the search.js returns first, it's run, even if jquery isn't done loading yet.

[19:53] <[Coke]> without something like require.js, we actually need it sync to insure it's loaded in the right order.

[19:55] *** jkva joined
[19:55] <japhb> Async loading of that search bar is probably a premature optimization anyway.

[19:56] <japhb> jnthn: Yes, forced/born-lazy smells much less than known-infinite to me.

[19:57] <[Coke]> er, search on ff does work for me consistently on the Language page, but not on the main page.

[19:57] <[Coke]> so it might be something else. Iunno.

[20:00] <jnthn> japhb: Thanks :)

[20:00] <jnthn> Hm, now that I ponder hyper/race on map (the obvious place to start)

[20:00] <jnthn> Seems that "next" is about impossible to define

[20:01] <jnthn> And "last" is do-able but you need to pick your semantics (should we take care to continue processing everything up to the "last", or call off the whole show)

[20:01] * japhb is tickled pink to discover that the way to fix his 6-month old bitrotted Perl 6 code is to *remove workarounds for old Rakudo bugs*

[20:02] <RabidGravy> :)

[20:02] <jnthn> Oh, actually, the "last" thing probably is a hyper/race distinction perhaps.

[20:03] <jnthn> Yes, that works quite naturally.

[20:04] <jnthn> So I guess we just need to decide what "next" with hyper/race is going to mean

[20:04] <jnthn> Oh, and maybe it's not even a problem

[20:04] <jnthn> 'cus it really just means "I'm not producing a value this thing"

[20:05] <jnthn> So it doesn't matter if the actual "next" item has already been handled on another thread.

[20:05] <jnthn> Given I'm barely clever enough to think about this stuff at the moment, I should probably defer implementing it :P

[20:06] *** shinobi-cl left
[20:06] * TimToady was born lazy...

[20:06] <jnthn> Anyway, there's a brain dump of things to ponder until Friday's GLR hacking :)

[20:07] <jnthn> (Tomorrow is the one day of the week I'll spend some time caring about a $dayjob thing)

[20:09] *** mohij_ joined
[20:10] *** meisl joined
[20:10] *** mohij left
[20:12] *** domidumont left
[20:12] <japhb> .oO( I exemplified all three great programming virtues *before I even started programming*! )

[20:13] <japhb> jnthn++  # Seriously, you've been kicking ass even compared to your usual output

[20:14] <jdv79> is there a way to negate a rule?

[20:14] <moritz> jdv79: yes, <!foo>

[20:14] <moritz> though note that it doesn't consume any characters

[20:14] <jdv79> i tried <!FooBar::token> and no luck

[20:14] <jdv79> so that's no good

[20:15] <moritz> well, <!foo> .*

[20:15] <jnthn> What kind of "no luck"? :)

[20:15] <jnthn> Bad interaction between ! and FooBar::token maybe?

[20:15] <jdv79> i can't find the error atm

[20:16] <moritz> jdv79: the problem is, what's the opposite of "match a number here". Is it "match anything that's not a number"? or "don't match if there's a number"?

[20:16] <jdv79> something like that

[20:16] <jnthn> jdv79: Well, if you write token foo { <FooBar::token> } and the <!foo> and it works, you've found the culprit...

[20:17] <jnthn> (I've no idea if there could be a bug there...it doesn't feel immediately likely from what I remember of how it's implemented...)

[20:17] <jdv79> all i really want to so is .subst all chars not matching a rule

[20:17] <jnthn> How many chars does the rule match?

[20:17] <moritz> s:g/<!foo>.//

[20:18] <TimToady> I can see race in terms of push, but seems like hyper needs to know what offset in the target to install its values

[20:18] <jnthn> <-foo> may do it

[20:18] <jdv79> ok

[20:19] <jnthn> TimToady: I've thought of hyper rather more in terms of an ordering on what chunks you can push

[20:19] <jnthn> TimToady: As in, "can't push things in chunk 2 until chunk 1's been done and pushed"

[20:19] <TimToady> so you're copying each target

[20:20] <TimToady> each chunk has its own initial target?

[20:20] *** colomon left
[20:20] *** jkva left
[20:20] <TimToady> I guess that works out better, unless you have a lock-free target that everyone can write to at the right location

[20:21] <jnthn> Well, for map we fill a fixed-size buffer with input values, workers grab one and process it inot an output buffer, and hands it back

[20:21] <jnthn> Even if you have lock-free you're still needing to care for cache coherency.

[20:21] <TimToady> makes one kinda want list ropes

[20:22] <TimToady> well, seq ropes

[20:22] <TimToady> well, whatever you call it

[20:22] <jnthn> The way I've generally seen this stuff implemented elsewhere is chunking the work, though.

[20:23] <jnthn> Which means for the period a thread is working on a chunk its not contending.

[20:24] <TimToady> make sense from a caching perspective, yes

[20:24] <jnthn> I suspect the bit of overhead of copying the result chunks to their final destination will be a lower cost than the contention we might get otherwise.

[20:24] <TimToady> seems likely

[20:24] <TimToady> I'm fine with the forced lazy rethink, btw

[20:25] <jnthn> OK, nice. :)

[20:25] <jnthn> That means I know how to do lazy :)

[20:25] <jnthn> (the prefix)

[20:25] <TimToady> well, it would be nice if you could stall a pipeline when it runs into something else it knows will be ready later, but isn't yet

[20:25] *** jjido left
[20:26] *** mohij joined
[20:26] <TimToady> espcially if that's what is currently being calculated as the next value in a recursive sequence

[20:26] *** jjido joined
[20:27] <TimToady> well, maybe it's not really stalling, but forcing the pipeline lazy at that point

[20:27] *** jjido is now known as Guest82660

[20:27] *** mohij_ left
[20:27] <TimToady> would like to have self-referential sequences, like Hamming, is all

[20:28] <TimToady> or maybe an explicit lazy will help there

[20:28] <jnthn> Do you have a golfed example of a self-referential sequence?

[20:28] <jnthn> Maybe I should get lazy in place, though, and then you can try to write it :)

[20:30] <TimToady> m: constant @foo = 1, @foo; say @foo

[20:30] <camelia> rakudo-moar 0dcbba: OUTPUT«5===SORRY!5=== Error while compiling /tmp/x4gb5fT7DP␤Variable '@foo' is not declared␤at /tmp/x4gb5fT7DP:1␤------> 3constant @foo = 1, 7⏏5@foo; say @foo␤»

[20:30] <TimToady> m: my @foo := 1, @foo; say @foo

[20:30] <camelia> rakudo-moar 0dcbba: OUTPUT«1 (Mu)␤»

[20:31] <TimToady> something like that, though of course that's a terrible way to produce 1 xx *  :)

[20:31] <jnthn> Hmm

[20:31] <TimToady> it may have more to do with when we create the name

[20:31] <jnthn> That'd certainly need a "lazy"

[20:31] <TimToady> and when we bind

[20:32] <TimToady> the lazy bits really oughta work out, so I think it's that we lack a "definitional" =

[20:33] <TimToady> anyway, sounds like what your doing should be close to what we need anyway

[20:33] <jnthn> Oh, if it's going to work the way I'm imagining it maybe could it'd be my @foo = 1, @foo; so you actually are referencing yourself

[20:33] <jnthn> uh, my @foo = 1, lazy @foo

[20:33] *** mohij_ joined
[20:33] *** mohij_ left
[20:33] <TimToady> well, don't sweat it for now

[20:34] <jnthn> That *may* mean lazy is also obligated to delay obtaining the iterator

[20:34] <jnthn> *nod*

[20:34] <jnthn> But it'd be cool if it worked :P

[20:34] <TimToady> I'd always thought the negotiation should be outside the "get" bits

[20:35] <TimToady> maybe that's a good argument for it

[20:35] *** mohij left
[20:36] *** Guest82660 left
[20:37] *** colomon joined
[20:38] * TimToady is currently working on with/without

[20:38] *** virtualsue joined
[20:40] <TimToady> adding the syntax is trivial, but the compilation of conditionals is somewhat opaque 'cuz it dives down to very low-level stuff in various spots

[20:43] *** darutoko left
[20:43] <jnthn> if/unless are pretty primitive.

[20:43] * colomon imagined that as “when / whennot” for a second there…. (as in, working with given)

[20:44] <jnthn> I don't immediately have a good idea of a shortcut way to implement it; defor (used for //) is also fairly low level

[20:45] <TimToady> the statement modifier is just andthen backwards

[20:46] <lucasb> m: say 'andthen'.flip

[20:46] <camelia> rakudo-moar 0dcbba: OUTPUT«nehtdna␤»

[20:46] <TimToady> the control is basically if with an extra .defined stuck in there before testing the boolean value, but then binding the original object in to the block

[20:47] <TimToady> a design question, though, should we allow intermixing of when-based and if-based xblocks?

[20:47] <TimToady> er, s/when/with/

[20:49] <jnthn> TimToady: Yeah...tbh I'd probably just go and deal with it at the code-gen level (copy/paste QAST op if/unless compilation and hack it to do definedness checking too

[20:49] <TimToady> that's what I have now, but that doesn't allow intermixing

[20:49] <jnthn> Ah

[20:50] <jnthn> Wait, how not?

[20:50] <TimToady> with $x {...} elsif $y {...}

[20:50] <TimToady> I'd have to do it the first way I tried, and $<sym>=[if|with]

[20:50] <jnthn> elsif chains just become nestings

[20:51] <TimToady> copy/paste of the grammar rule only lets you have all with or all if

[20:51] *** Mhoram left
[20:51] <jnthn> Is that not going to become a QAST::Op.new( :op('with'), $x, {...}, QAST::Op.new( :op('if'), $y, {...}, Nil )) (to handwave)

[20:52] <jnthn> I didn't mean copy-paste the grammar rule :)

[20:52] <jnthn> I meant copy-paste the stuff in the QAST -> VM level compiler

[20:52] *** Mhoram joined
[20:52] <jnthn> I don't think there's an elegant way to do it without introducing a new nqp::op

[20:52] <TimToady> yes, once you get down to a consistent structure, it's not so much of a problem

[20:52] *** skids joined
[20:52] <TimToady> I was coming to that conclusion

[20:53] <TimToady> No registered operation handler for 'without'

[20:53] <jnthn> Right, that's the code-gen piece that'll need doing

[20:53] <jnthn> The if/unless compilation lives in src/vm/moar/QAST/QASTOperationsMAST.nqp 

[20:54] <TimToady> but I don't think I can copy-paste the 'unless' code because it's very low level

[20:54] <TimToady> well, I guess I copy the low-level stuff then

[20:54] <jnthn> *nod*

[20:55] <jnthn> If you don't want to re-compile NQP each time then you can paste/hack it in src/vm/moar/Perl6/Ops.nqp in the Rakudo repo

[20:56] <TimToady> okay, I think that gives me enough to work with while you waste^Wspend your time on $dayjob :)

[20:57] <jnthn> ;)

[20:58] <TimToady> are you still only funded through Aug, or has more come in?

[20:58] <jnthn> If I didn't have to waste my time on nobody implementing Schengen the way it was designed, I'd have had a decent few hours more this week too :/

[20:59] <jnthn> TimToady: There's more, details to be announced soon, but we're safe for a while :)

[20:59] <TimToady> we definitely want to keep you going, one way or another

[20:59] <jnthn> *nod*

[21:01] * TimToady is very, very, very happy to see the progress on GLR

[21:01] <jnthn> I'm very positively surprised how less of a hornet's nest it's been so far compared to what I feared, tbh.

[21:01] *** MueThoS joined
[21:01] *** kaare_ left
[21:02] <smls> TimToady: S26 lists Damian Conway as the author of the POD6 spec, but you invented the original POD format right? Could you maybe comment on https://github.com/perl6/doc/issues/111 ?

[21:02] *** FROGGS left
[21:02] <ShimmerFairy> TimToady: at first I thought that with/orwith should be separate from if/elsif, but now I think it'd be more useful to mix defined-ness checks with boolean checks. (I can see an 'orwith' after a bunch of if/elsifs that says "do I have _anything_ to work with!?", for example)

[21:02] <smls> jnthn++ # GLR work. I'm eager to try it (and update p6doc) once it has landed... :P

[21:03] <lucasb> This new 'with' has 'if' semantics? What if I want 'while' to also work like that? Does a statement prefix like 'with if ...', 'with while ...' makes sense?

[21:03] *** telex left
[21:04] *** espadrine joined
[21:04] *** telex joined
[21:04] <lucasb> Also, reiterating yesterday's question, should the Index type be removed now, before aug release?

[21:04] *** jjidoTEMP joined
[21:05] <TimToady> yes, it should be removed, whatever kind of ifdef we end up with

[21:06] <TimToady> 'with' has ifdef semantics, but topicalizes on the original object pre .defined

[21:06] <ShimmerFairy> smls: I imagine an X<> tag could be used as an anchor for links, or Pod::To::HTML could always provide its own helpful module for the M<> formatting code.

[21:06] *** laouji left
[21:07] <smls> ShimmerFairy: Could you add a comment to the issue to elaborate?

[21:07] <ShimmerFairy> sure

[21:08] <smls> thanks :)

[21:08] *** MueThoS left
[21:13] *** jjidoTEMP is now known as jjido

[21:13] *** colomon left
[21:15] *** rurban left
[21:18] <smls> ShimmerFairy++

[21:24] <ab5tract_> jnthn: the timings on `glr.p6 benchmark` are impressive, to say the least!

[21:24] <ab5tract_> I had to hot onto IRC to show my appreciation :)

[21:24] <ab5tract_> *hop

[21:30] <jjido> hey, where did you see these benchmark results?

[21:32] *** virtualsue left
[21:33] <jnthn> ab5tract_: Yes, they're quite promising :)

[21:34] <ab5tract_> jjido: just wget the gist and run `perl6 glr.p6 benchmark` :)

[21:35] <jjido> ab5tract_: reading...

[21:35] <jnthn> perl6 --optimize=3 glr.p6 benchmark # fairer

[21:35] <ab5tract_> jnthn: will there still be a deepflat or such that dives into $[]

[21:36] <jnthn> (Because you're comparing it against code compiled agaisnt --optimize=3, 'cus CORE.setting is)

[21:36] <jnthn> ab5tract_: I'm...not sure there's a deepflat today? :)

[21:36] <jnthn> ab5tract_: It would be really easy to implement one though.

[21:36] <ab5tract_> Well, I had some sense that it existed as a conceptual catregory

[21:37] <jnthn> ab5tract_: Just depends if we want to actually have a deepflat or if we want to get people to write it in terms of some other more general operation

[21:37] <timotimo> oh, i forgot to --optimize=3 all this time

[21:37] <jnthn> I even wrote a comment about the MAIN benchmark sub suggesting it ;)

[21:37] <jjido> jnthn: haha, maybe you want to rename "slip" (French for undies)

[21:37] <jnthn> *lol*

[21:37] <jnthn> That pretty much makes certain it stays :P

[21:37] *** daxim_ joined
[21:38] *** jkva joined
[21:39] *** colomon joined
[21:39] *** g4 left
[21:39] *** daxim left
[21:39] <jjido> https://www.google.fr/search?q=slip

[21:40] <jjido> I didn't put the Pictures parameter

[21:40] <jnthn> damn damn damn why did I click images..

[21:40] <ab5tract_> jnthn: makes sense re: deepflat

[21:40] *** g4 joined
[21:40] *** g4 left
[21:40] *** g4 joined
[21:40] <tony-o> glad i clicked that at work

[21:41] <jnthn> ab5tract_: I don't feel strongly on it to be honest

[21:41] <jnthn> ab5tract_: I'm fine with implement a deepflat if it's going to be common enough

[21:41] * jnthn punts it to the language designer :)

[21:42] <ab5tract_> The thing is that this case comes up pretty often, and has often elicited hopeful mentions of the GLR: https://github.com/ab5tract/p6-playground/blob/master/Temp-Fix/lol-prefix.p6

[21:42] *** jkva left
[21:46] *** smls_ joined
[21:46] *** smls left
[21:47] *** lucasb left
[21:49] *** smls_ is now known as smls

[22:03] <tony-o> connection timeout working in http::server::async, working on pipelining and serializing output

[22:03] <RabidGravy> yay!

[22:03] <smls> I think "deepflat" is misleading, because the normal "flat" is already recursive.

[22:04] <smls> What you seem to want, is a "flat that ignores containerization"

[22:04] <ShimmerFairy> Not for GLR Arrays, since they enforce itemization

[22:04] <tony-o> it's usable without pipelining currently, just use connection:close header

[22:04] <smls> ShimmerFairy: I thought the opposite?

[22:05] <ShimmerFairy> smls: [] is an Array that has Scalar containers for each element, () is a List that doesn't. In a post-GLR world, that is.

[22:05] <jnthn> The grant report for last week's work: https://6guts.wordpress.com/2015/08/05/this-week-fixing-lots-of-rts-digging-into-the-glr/

[22:06] <smls> ShimmerFairy:  that's also true now (except s/List/Parcel/)

[22:06] *** meisl left
[22:06] <smls> but [] will no longer itemize *itself* post-glr

[22:06] <tony-o> is there a way to see what failed during build phase on the smoke.perl6.org site?

[22:07] <jnthn> smls: We may want a better name, though I think the semantics of the operation desired are quite clear.

[22:07] <smls> so  (([2, 4], 6), ([3, 5], 7)).flat  would have 6 elements.

[22:07] <smls> jnthn: Yes.

[22:07] <jnthn> smls: That one has 4 elements.

[22:07] <smls> why?

[22:07] <jnthn> Oh, wait...it has 6

[22:07] <jnthn> :)

[22:08] <jnthn> Sorry, confused some parens for square brackets

[22:08] <smls> .flat(:all)  maybe?

[22:08] <jnthn> ([[2, 4], 6], [[3, 5], 7]).flat woulda had 4

[22:08] <smls> yeah

[22:08] <jnthn> :all isn't really any clearer than deepmap...

[22:08] <jnthn> uh, deepflat

[22:09] <smls> it's recursive, it just respects things that say "don't flatten me".

[22:09] <TimToady> I foresee some variants to flatten subsets or supersets of .flat

[22:09] <jnthn> .flat(:items) or .itemsflat or .flatitems or so...

[22:09] <smls> so we shouldnh't give the impre4ssion that it's not recursive

[22:09] <jnthn> *nod*

[22:09] <tony-o> where is smoke.perl6.org getting it's info? 

[22:09] <ShimmerFairy> .oO( @array.reallyflat )

[22:09] <jnthn> .steam-roller

[22:10] <ShimmerFairy> .paper-thin

[22:10] <hoelzro> tony-o: I believe it runs the tests by itself

[22:10] <hoelzro> every so often

[22:10] <smls> .flattt

[22:10] * hoelzro just noticed his warnings patch worked o/

[22:10] <tony-o> what OS, do you know?  i have a bunch of modules failing that are passing locally

[22:11] <jnthn> Anyway, I should get me some rest...only managed 4ish hours of decent sleep last night...

[22:11] <jnthn> 'night, all o/

[22:11] <tony-o> most of them with 'B' problems ..

[22:11] <hoelzro> tony-o: not sure, but I'm guessing a Linux of some sort

[22:11] <tony-o> they all build fine with zef

[22:11] <hoelzro> tony-o: I can try one out on my box if you'd like

[22:11] <tony-o> if you don't mind, https://github.com/tony-o/perl6-data-dump

[22:11] <smls> .flat(:items)  does not seem so bad actually

[22:11] <ShimmerFairy> ♞ jnthn o/

[22:11] <tony-o> that one is failing for tests 

[22:12] <tony-o> .each ?

[22:12] <ShimmerFairy> smls: my only concern with .flatitems or however you'd spell it is that it could imply _just_ items, instead of 'flat + items'. I'm not sure how much of a real concern that is, however :)

[22:13] <timotimo> hmm, will we have something like car, cdr, cddr, cdddr?

[22:13] <timotimo> flat, flatt, flattt, flaat, flaatt, flaattt, ...?

[22:14] <tony-o> super-flat

[22:14] <tony-o> would be enjoyable to write

[22:15] <hoelzro> tony-o: Works on My Machine™

[22:15] <tony-o> thanks hoelzro 

[22:15] <TimToady> $list.recurse(any(Seq,List,Array,Scalar), *.slip)

[22:15] <hoelzro> np

[22:15] <tony-o> .slip.fr.google.images

[22:16] <timotimo> .slip.haha-get-it

[22:16] <tony-o> isn't there another smoke site for p6 modules?

[22:16] <tony-o> one with logs

[22:16] <ShimmerFairy> TimToady: hmm, I wonder if we couldn't have some kind of .derotor method.

[22:17] <ugexe> testers.perl6.org

[22:17] <tony-o> ty

[22:17] <ugexe> not accepting new reports though. that seems to be down

[22:17] <timotimo> ShimmerFairy: hm, what if you generate indices via rotor and index into the rotored thing via that?

[22:18] <ShimmerFairy> timotimo: Not sure. I just thought that .derotor would be a good name for "flatten this list" in the way that .rotor un-flattens lists :)

[22:19] <timotimo> oh

[22:19] <timotimo> i thought you meant primarily the "move back and forth" thing

[22:19] <ab5tract_> I 

[22:20] <ab5tract_> c

[22:20] <ab5tract_> ad

[22:20] <ab5tract_> oops :(

[22:21] <ab5tract_> fwiw, the idea of .flat having some adverbs sounds like the cleanest way

[22:22] <ab5tract_> .flat :recurse

[22:23] <ShimmerFairy> My thought was perhaps something like  method derotor(Int $levels, Positional *@types-to-derotor)  as a first idea. (Though if it existed its args should probably be more similar to rotor's)

[22:23] <ShimmerFairy> I'll certainly have to figure out what .derotor would look like, because now I'm interested :)

[22:25] <ab5tract_> tony-o: ++super-flat; # love the art style of the same name :)

[22:26] <timotimo> hmm

[22:26] <timotimo> a propellor is kind of a rotor ... and an impellor is the opposite of a propellor ...

[22:27] <Sgeo> How does .list cause list context?

[22:27] <timotimo> sneakily

[22:28] <Sgeo> m: sub foo(*@args) { .say for @args; }; my $f = (1,2,3); foo $f; foo $f.list;

[22:28] <camelia> rakudo-moar 0dcbba: OUTPUT«1 2 3␤1␤2␤3␤»

[22:29] <Sgeo> How is $f different from $f.list ?

[22:29] <dalek> rakudo-star-daily: 1689e8d | coke++ | log/ (9 files):

[22:29] <dalek> rakudo-star-daily: today (automated commit)

[22:29] <dalek> rakudo-star-daily: review: https://github.com/coke/rakudo-star-daily/commit/1689e8d5ee

[22:29] *** pochi left
[22:30] *** pochi joined
[22:30] <timotimo> in $f there's still the scalar container that gets inspected by "for"

[22:31] *** smls_ joined
[22:31] <RabidGravy> Hmmm

[22:31] *** smls left
[22:32] *** pippo joined
[22:32] <pippo> o/ #perl6

[22:32] <RabidGravy> anyhow I think that's enough of today

[22:32] <RabidGravy> toodlepip

[22:33] *** yqt left
[22:33] *** yqt joined
[22:33] <pippo> m: my @a = [1,2,3;1,2,3;1,2,3]; say @a»[0,2];

[22:33] <camelia> rakudo-moar 0dcbba: OUTPUT«2␤»

[22:33] <pippo> m: my @a = [1,2,3;1,2,3;1,2,3]; say @a[*]»[0,2];

[22:33] <camelia> rakudo-moar 0dcbba: OUTPUT«2␤»

[22:33] <pippo> m: my @a = [1,2,3;1,2,3;1,2,3]; say @a[*]»[0];

[22:33] <camelia> rakudo-moar 0dcbba: OUTPUT«1 2 3␤»

[22:34] <pippo> m: my @a = [1,2,3;1,2,3;1,2,3]; say @a[*]»[2];

[22:34] <camelia> rakudo-moar 0dcbba: OUTPUT«1 2 3␤»

[22:34] <pippo> m: my @a = [1,2,3;1,2,3;1,2,3]; say @a[*]»[0;2];

[22:34] <camelia> rakudo-moar 0dcbba: OUTPUT«2␤»

[22:34] <pippo> m: my @a = [1,2,3;1,2,3;1,2,3]; say @a[*]»[*-1];

[22:34] <camelia> rakudo-moar 0dcbba: OUTPUT«1 2 3␤»

[22:35] <ShimmerFairy> timotimo: I think the best choice for name would simply be to reverse the name 'rotor'  (...wait.)

[22:35] <pippo> Anybody knows how can I get the first and last column at same time? »[0,2] does not work.

[22:35] *** pdcawley_ left
[22:35] <timotimo> :D

[22:36] *** g4 left
[22:36] <ShimmerFairy> m: my @a = (1,2,3;4,5,6;7,8,9); say @a[0,2]

[22:36] <camelia> rakudo-moar 0dcbba: OUTPUT«1 2 3 7 8 9␤»

[22:36] *** g4 joined
[22:36] <ShimmerFairy> m: my @a = (1,2,3;4,5,6;7,8,9); say @a[0,2;*] # more explicit

[22:36] <camelia> rakudo-moar 0dcbba: OUTPUT«1 2 3 7 8 9␤»

[22:37] <pippo> ShimmerFairy: Thank you very much.

[22:38] <ShimmerFairy> pippo: it's helpful to remember not to wrap literals arrays like that with [] when assigning to a @var . With your example, you would've needed @a[0][0,2] to make it work.

[22:39] <ShimmerFairy> (It also trips you up when assigning a piece of a multi-dim array, so  @b = @a[0]  would've cause @b[0] to hold @a[0], which is likely not what you intend there)

[22:39] <pippo> ShimmerFairy: OK. Thank you.

[22:39] <ShimmerFairy> um, nvm, I think that @b = @a[0] trip-up only happens with certain kinds of @a :)

[22:40] <ShimmerFairy> m: my @a = [1,2,3],[1,2,3],[1,2,3]; my @b = @a[0]; say @b.perl;  # this kind of @a :)

[22:40] <camelia> rakudo-moar 0dcbba: OUTPUT«[[1, 2, 3]]<>␤»

[22:45] *** mr-foobar left
[22:47] <pippo> ShimmerFairy: Sorry but I got a little confused. I need to get 1,4,7 and 3,6,9 from your example. I.e. I need the columns and not the rows.

[22:47] <ShimmerFairy> ah, lemme see

[22:48] <pippo> m: @a = (1,2,3;4,5,6;6,7,8); @a[*]»[0];

[22:48] <camelia> rakudo-moar 0dcbba: OUTPUT«5===SORRY!5=== Error while compiling /tmp/fdYNQHanX9␤Variable '@a' is not declared␤at /tmp/fdYNQHanX9:1␤------> 3<BOL>7⏏5@a = (1,2,3;4,5,6;6,7,8); @a[*]»[0];␤»

[22:48] <pippo> m: my @a = (1,2,3;4,5,6;6,7,8); @a[*]»[0];

[22:48] <camelia> rakudo-moar 0dcbba: ( no output )

[22:48] <pippo> m: my @a = (1,2,3;4,5,6;6,7,8); say @a[*]»[0];

[22:48] <camelia> rakudo-moar 0dcbba: OUTPUT«1 4 6␤»

[22:48] <pippo> ^^ this is the first column.

[22:49] <pippo> m: my @a = (1,2,3;4,5,6;6,7,8); say @a[*]»[0,2];

[22:49] <camelia> rakudo-moar 0dcbba: OUTPUT«Cannot modify an immutable Int␤  in block <unit> at /tmp/WXYV9Tfwrv:1␤␤»

[22:49] <ShimmerFairy> m: my @a = (1,2,3;4,5,6;7,8,9); say @a[*;0].perl; @a[*;2].perl;

[22:49] <camelia> rakudo-moar 0dcbba: OUTPUT«(1, 4, 7)␤»

[22:49] <ShimmerFairy> m: my @a = (1,2,3;4,5,6;7,8,9); say @a[*;0].perl; say @a[*;2].perl;

[22:49] <camelia> rakudo-moar 0dcbba: OUTPUT«(1, 4, 7)␤(3, 6, 9)␤»

[22:50] <pippo> m: my @a = (1,2,3;4,5,6;6,7,8); say @a[*]»[0;2];

[22:50] <camelia> rakudo-moar 0dcbba: OUTPUT«Cannot modify an immutable Int␤  in block <unit> at /tmp/482M7HNaBj:1␤␤»

[22:50] <ShimmerFairy> I don't think we're magical enough to get the columns when you try [*;0,2] though :(  (and I don't know if it's supposed to be that magical)

[22:50] <ShimmerFairy> m: my @a = (1,2,3;4,5,6;7,8,9); say @a[*;0,2].perl;

[22:50] <camelia> rakudo-moar 0dcbba: OUTPUT«((1, 3), (4, 6), (7, 9))␤»

[22:51] <pippo> ^^ that is wonderful!!

[22:51] *** mr-foobar joined
[22:51] <ShimmerFairy> pippo: oh, you wanted the columns separated per row? ok then! :)

[22:52] <pippo> Yes yes !!! :-))

[22:52] <pippo> Thank you.

[22:52] <ShimmerFairy> (if you want the columns as a list of its own, then you'd need to do it one at a time like I showed before)

[22:52] <ShimmerFairy> you're welcome :)

[22:52] <pippo> though I do not understand what the '*' means in @a[*;0,2]

[22:53] <pippo> No I think I got it now.

[22:53] <pippo> :-))

[22:54] <ShimmerFairy> It's the same ol' Whatever that shows up in lots of places. In this context it means "all the things in this dimension" :)

[22:56] <pippo> ShimmerFairy: Thank you again and have a good night. :-)

[22:56] <pippo> o/

[22:56] *** pippo left
[22:57] *** pecastro left
[22:59] *** Khisanth left
[23:07] *** Khisanth joined
[23:26] <timotimo> i ought to get some sleep, too. tomorrow'll be a car day

[23:37] *** smls_ left
[23:39] *** jkva joined
[23:43] *** jkva left
[23:58] *** RabidGravy left
