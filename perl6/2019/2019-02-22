[00:00] <Xliff> guifa: Is this method in a subclass?

[00:00] <lizmat> Xliff: just switching on my machine after coming back from Köln

[00:00] * lizmat goes to bed

[00:01] <guifa> Ha, I’ll throw it all up very shortly (this is probably the last thing to squash and I think I’ve got a big new release for BCP47 with langtag filtering available

[00:01] <Xliff> :)

[00:01] *** woolfy joined
[00:02] <guifa> Aha!  Nicely golfs

[00:02] <guifa> https://tio.run/##K0gtyjH7/z85J7G4WMFRoZqLM7c0pyRTIS@1XEHDSiVRR8FKJUkTJM5ZnFipoJJozcVZy1XLxQXiOeoBlWlYGYJUGSVp/v8PAA

[00:03] <guifa> errrr wait

[00:03] <guifa> I didn’t bless the object in the golfed code one sec

[00:07] <timotimo> guifa: you actually declared a multi sub inside class A

[00:07] <timotimo> you can't call that with A.new syntax

[00:08] <guifa> That’s bad golfing on my part

[00:08] <guifa> I’m definitely using “multi method new ( … )” 

[00:08] <Xliff> Is there a way to check if a Routine is hidden from backtrace?

[00:08] <Xliff> m: Routine.^methods.say

[00:08] <camelia> rakudo-moar d6563816e: OUTPUT: «(The 'ForeignCode' class is a Rakudo-specific␤implementation detail and has no serviceable parts inside The 'ForeignCode' class is a Rakudo-specific␤implementation detail and has no serviceable parts inside The 'ForeignCode' class is a Rakudo-spec…»

[00:09] <timotimo> if you omit the "multi", the existing candidates from parent classes no longer exist

[00:09] <Xliff> m: .say for Routine.^methods

[00:09] <camelia> rakudo-moar d6563816e: OUTPUT: «The 'ForeignCode' class is a Rakudo-specific␤implementation detail and has no serviceable parts inside␤The 'ForeignCode' class is a Rakudo-specific␤implementation detail and has no serviceable parts inside␤The 'ForeignCode' class is a Rakudo-s…»

[00:09] <Xliff> WTF?

[00:09] <timotimo> ha

[00:09] <timotimo> m: .name.say for Routine.^methods

[00:09] <camelia> rakudo-moar d6563816e: OUTPUT: «<anon>␤<anon>␤<anon>␤<anon>␤<anon>␤<anon>␤<anon>␤<anon>␤<anon>␤<anon>␤<anon>␤<anon>␤<anon>␤<anon>␤<anon>␤<anon>␤onlystar␤candidates␤cando␤multi␤soft␤wrap␤unwrap␤yada␤package␤leave␤gist␤perl␤BUILD…»

[00:10] <timotimo> but the "is it hidden from backtrace?" thing is mixed in via a role

[00:10] <Xliff> HA!

[00:10] <timotimo> m: sub foo() is hidden-from-backtrace { }; say foo.^methods

[00:10] <camelia> rakudo-moar d6563816e: OUTPUT: «(new Numeric Str sink AT-POS AT-KEY BIND-POS BIND-KEY ASSIGN-POS ASSIGN-KEY STORE push append unshift prepend FALLBACK ords chrs chop chomp iterator Set SetHash Bag BagHash Mix MixHash gist)␤»

[00:10] <timotimo> hm

[00:10] <timotimo> ah

[00:10] <timotimo> m: sub foo() is hidden-from-backtrace { }; say &foo.^methods

[00:10] <camelia> rakudo-moar d6563816e: OUTPUT: «(is-hidden-from-backtrace The 'ForeignCode' class is a Rakudo-specific␤implementation detail and has no serviceable parts inside yada The 'ForeignCode' class is a Rakudo-specific␤implementation detail and has no serviceable parts inside The 'Forei…»

[00:10] <timotimo> there it is

[00:11] <Xliff> m: sub foo() is hidden-from-backtrace {}; say foo.^roles.name.say

[00:11] <camelia> rakudo-moar d6563816e: OUTPUT: «No such method 'name' for invocant of type 'List'. Did you mean any of these?␤    none␤    note␤    race␤    take␤␤  in block <unit> at <tmp> line 1␤␤»

[00:11] <timotimo> btw the warning message about ForeignCode is because it's trying to call .gist or something on the methods that are on Routine

[00:11] <Xliff> m: sub foo() is hidden-from-backtrace {}; say foo.^roles».name

[00:11] <camelia> rakudo-moar d6563816e: OUTPUT: «()␤»

[00:11] <Xliff> m: sub foo() is hidden-from-backtrace {}; say foo.^roles

[00:11] <camelia> rakudo-moar d6563816e: OUTPUT: «()␤»

[00:11] <Xliff> m: sub foo() is hidden-from-backtrace {}; say &foo.^roles

[00:11] <camelia> rakudo-moar d6563816e: OUTPUT: «((is-hidden-from-backtrace) (Callable))␤»

[00:12] <Xliff> m: sub foo() is hidden-from-backtrace {}; say &foo.^roles.contains('is-hidden-from-backtrace') 

[00:12] <camelia> rakudo-moar d6563816e: OUTPUT: «Use of uninitialized value of type is-hidden-from-backtrace in string context.␤Methods .^name, .perl, .gist, or .say can be used to stringify it to something meaningful.␤False␤  in block <unit> at <tmp> line 1␤Use of uninitialized value of typ…»

[00:12] <Xliff> m: sub foo() is hidden-from-backtrace {}; say &foo.^roles.contains(is-hidden-from-backtrace) 

[00:12] <camelia> rakudo-moar d6563816e: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Undeclared routine:␤    is-hidden-from-backtrace used at line 1␤␤»

[00:12] <Xliff> m: sub foo() is hidden-from-backtrace {}; say &foo.^roles».^name

[00:12] <camelia> rakudo-moar d6563816e: OUTPUT: «List␤»

[00:12] <Xliff> m: sub foo() is hidden-from-backtrace {}; say &foo.^roles».name

[00:12] <camelia> rakudo-moar d6563816e: OUTPUT: «No such method 'name' for invocant of type 'is-hidden-from-backtrace'␤  in block <unit> at <tmp> line 1␤␤»

[00:13] <Xliff> m: sub foo() is hidden-from-backtrace {}; say &foo.^roles.map( *.name )

[00:13] <camelia> rakudo-moar d6563816e: OUTPUT: «No such method 'name' for invocant of type 'is-hidden-from-backtrace'␤  in block <unit> at <tmp> line 1␤␤»

[00:13] <Xliff> m: sub foo() is hidden-from-backtrace {}; say &foo.^roles.map( *.^name )

[00:13] <camelia> rakudo-moar d6563816e: OUTPUT: «(is-hidden-from-backtrace Callable)␤»

[00:13] *** zacts joined
[00:13] <Xliff> m: sub foo() is hidden-from-backtrace {}; say &foo.^roles.map( *.^name ).contains( 'is-hidden-from-backtrace' )

[00:13] <camelia> rakudo-moar d6563816e: OUTPUT: «True␤»

[00:13] <Xliff> \o/

[00:13] <timotimo> bad idea

[00:13] <Xliff> :(

[00:13] <timotimo> let me show you :)

[00:13] <Xliff> Explain, pls

[00:14] <timotimo> m: role is-hidden-from-backtrace-haha-just-kidding { }; sub foo() {}; &foo does is-hidden-from-backtrace-haha-just-kidding; say &foo.^roles.map( *.^name ).contains(

[00:14] <camelia> rakudo-moar d6563816e: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Unable to parse expression in argument list; couldn't find final ')' (corresponding starter was at line 1)␤at <tmp>:1␤------> 3say &foo.^roles.map( *.^name ).contains(7⏏5<EOL>␤    expecting …»

[00:14] <Xliff> m: List.STORE.^roles.map( *.^name ).say

[00:14] <camelia> rakudo-moar d6563816e: OUTPUT: «Invocant of method 'STORE' must be an object instance of type 'List', not a type object of type 'List'.  Did you forget a '.new'?␤  in block <unit> at <tmp> line 1␤␤»

[00:14] <timotimo> oops

[00:14] <Xliff> m: List.STORE.code.^roles.map( *.^name ).say

[00:14] <camelia> rakudo-moar d6563816e: OUTPUT: «Invocant of method 'STORE' must be an object instance of type 'List', not a type object of type 'List'.  Did you forget a '.new'?␤  in block <unit> at <tmp> line 1␤␤»

[00:14] <timotimo> m: role is-hidden-from-backtrace-haha-just-kidding { }; sub foo() {}; &foo does is-hidden-from-backtrace-haha-just-kidding; say &foo.^roles.map( *.^name ).contains( 'is-hidden-from-backtrace' )

[00:14] <camelia> rakudo-moar d6563816e: OUTPUT: «True␤»

[00:15] <timotimo> contains will first stringify the list and then search for the substring in the result

[00:15] <Xliff> Oh. HAHA.

[00:15] <guifa> Okay so packaging up all the code is going to be really awkward, but basically here’s what’s the issue

[00:15] <guifa> https://imgur.com/a/j4siKVF

[00:16] <Xliff> m: sub foo() is hidden-from-backtrace {}; say 'is-hidden-from-backtrace'∈ &foo.^roles.map( *.^name ) 

[00:16] <camelia> rakudo-moar d6563816e: OUTPUT: «True␤»

[00:16] *** rindolf left
[00:16] <Xliff> :P

[00:16] <guifa> When I added the Str version of new, the named-only one started acting as if it didn’t exist

[00:16] <Xliff> m: role is-hidden-from-backtrace-haha-just-kidding { }; sub foo() {}; &foo does is-hidden-from-backtrace-haha-just-kidding; say 'is-hidden-from-backtrace' ∈ &foo.^roles.map( *.^name )

[00:16] <camelia> rakudo-moar d6563816e: OUTPUT: «False␤»

[00:16] <guifa> And it’ll output the “Found base of “ line no problem, but then never outputs “Called without a string”

[00:17] <guifa> (there are no other multi candidates)

[00:18] <Xliff> m: GLOBAL.samewith.^roles.map( *.^name ).say

[00:18] <camelia> rakudo-moar d6563816e: OUTPUT: «No such method 'samewith' for invocant of type 'GLOBAL'␤  in block <unit> at <tmp> line 1␤␤»

[00:19] <Xliff> BOLLOCKS! I've been fighting that thing in my backtraces all afternoon!

[00:20] <Xliff> guifa: First off, all of your arrays in the second multi will need "is copy" at the end.

[00:21] <Xliff> Otherwise it will complain about modifying the immutable

[00:21] <Xliff> secondly, how are you invoking if you want to trigger the second?

[00:21] <guifa> Triggering the second using only named arguments and no Str

[00:22] <timotimo> you'll want "proto method new(|) {*}" in your class

[00:22] <guifa> Per the docs, named arguments take precedence over positional

[00:22] <timotimo> methods will always take any amount of named arguments, though

[00:24] <timotimo> Xliff: are you sure push will not succeed there?

[00:25] <guifa> Push definitely works there :-) 

[00:25] <Xliff> https://gist.github.com/Xliff/74a448e07fed4014c8326d8bd14a41d8

[00:25] <Xliff> Oh. Nevermind.

[00:25] <Xliff> ^^ See the bane of my existence.

[00:26] <Xliff> Cannot call method from outside of a GTK:: object (Any::IterateOneWithoutPhasers.pull-one)

[00:26] <Xliff> WTF?!?

[00:26] <Xliff> Why is that appearing in my backtrace!?

[00:27] <timotimo> btw the internals try for is-hidden-from-backtrace using if $foo.^can("is-hidden-from-backtrace") && $foo.is-hidden-from-backtrace, iirc

[00:27] <Xliff> So gisted code returns Any::IterateOneWithoutPhasers.pull-one, and I don't want that.

[00:28] <timotimo> what do you want to do with the calling method once you have it?

[00:29] <guifa> So I did a $foo = LanguageTagFilter and I think I found the issue

[00:29] <Xliff> timotimo: Insure that it doesn't come from user code that doesn't start with "GTK::"

[00:30] <guifa> Can’t resolve caller because I think it wants me to supply all of those to match since they don’t have default values? 

[00:31] <timotimo> m: package A { our sub call-into($other-thing) { $other-thing() } }; package B { our sub call-into($other-thing) { $other-thing } }; sub tell-me-caller { say CLIENT::.^keys }; A::call-into({ B::call-into({ tell-me-caller }) });

[00:31] <camelia> rakudo-moar d6563816e: ( no output )

[00:31] <timotimo> m: package A { our sub call-into($other-thing) { $other-thing() } }; package B { our sub call-into($other-thing) { $other-thing() } }; sub tell-me-caller { say CLIENT::.^keys }; A::call-into({ B::call-into({ tell-me-caller }) });

[00:31] <camelia> rakudo-moar d6563816e: OUTPUT: «Cannot invoke this object (REPR: Null; VMNull)␤  in sub tell-me-caller at <tmp> line 1␤  in block  at <tmp> line 1␤  in sub call-into at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[00:31] <timotimo> m: package A { our sub call-into($other-thing) { $other-thing() } }; package B { our sub call-into($other-thing) { $other-thing() } }; sub tell-me-caller { say CLIENT::.WHAT }; A::call-into({ B::call-into({ tell-me-caller }) });

[00:31] <camelia> rakudo-moar d6563816e: OUTPUT: «Cannot invoke this object (REPR: Null; VMNull)␤  in sub tell-me-caller at <tmp> line 1␤  in block  at <tmp> line 1␤  in sub call-into at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[00:31] <timotimo> m: package A { our sub call-into($other-thing) { $other-thing() } }; package B { our sub call-into($other-thing) { $other-thing() } }; sub tell-me-caller { say CLIENT::&ROUTINE }; A::call-into({ B::call-into({ tell-me-caller }) });

[00:31] <camelia> rakudo-moar d6563816e: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Malformed lookup of ::&ROUTINE; please use ::('&ROUTINE'), ::{'&ROUTINE'}, or ::<&ROUTINE>␤at <tmp>:1␤------> 3g() } }; sub tell-me-caller { say CLIENT7⏏5::&ROUTINE }; A::call-into({ B::call-in…»

[00:31] <timotimo> m: package A { our sub call-into($other-thing) { $other-thing() } }; package B { our sub call-into($other-thing) { $other-thing() } }; sub tell-me-caller { say CLIENT::('&ROUTINE') }; A::call-into({ B::call-into({ tell-me-caller }) });

[00:31] <camelia> rakudo-moar d6563816e: OUTPUT: «Cannot invoke this object (REPR: Null; VMNull)␤  in sub tell-me-caller at <tmp> line 1␤  in block  at <tmp> line 1␤  in sub call-into at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[00:32] <timotimo> hm. i wonder.

[00:33] <guifa> Okay no, giving everything default values didn’t work.

[00:34] *** hc1^ left
[00:34] <timotimo> did you try the "proto method new" one?

[00:34] <guifa> I did

[00:35] <guifa> Cannot resolve caller new(Intl::BCP47::LanguageTagFilter: :variants(Array), :language(Language), :region(Region), :script(WildcardScript)); none of these signatures match:

[00:35] <timotimo> named arguments are always optional, so their default value is just their corresponding type object

[00:35] <guifa>     (Intl::BCP47::LanguageTagFilter $: Language :$language = { ... }, Language :@languages = { ... }, Region :$region = { ... }, Region :@regions = { ... }, Script :$script = { ... }, Script :@scripts = { ... }, Variant :$variant = { ... }, Variant :@variants = { ... }, PrivateUse :@privateuses = { ... }, *%_)

[00:35] <timotimo> i think i'd need to see more code for that

[00:36] <guifa> OMG

[00:36] *** kurahaupo left
[00:36] * guifa *hates* the typing system sometimes 

[00:36] <guifa> Finally found it

[00:36] <guifa> I was passing an array of Variants

[00:37] <timotimo> oh

[00:37] <guifa> but not an Array[Variant] 

[00:37] *** kurahaupo joined
[00:37] <timotimo> well, that doesn't match Variant :$variant

[00:37] *** aborazmeh joined
[00:37] *** aborazmeh left
[00:37] *** aborazmeh joined
[00:37] <timotimo> oh, Variants

[00:37] <timotimo> er, variants

[00:37] <timotimo> yeah, nominal typing system

[00:38] <guifa> I wish there were a way to capture that and allow that through

[00:38] <timotimo> with a constraint that says "all elements of this need to be Variant"?

[00:38] <guifa> I mean I can do that with a where 

[00:39] <guifa> But I’ve hit this a few times before

[00:39] <timotimo> if there's no other side effects until then, you can also explode later when one of the entries isn't a Variant

[00:39] <guifa> Maybe an autocasting of some sort where Variant() @foo is copy; will attempt to create a Positional[Variant] 

[00:40] <timotimo> i could kind of see that

[00:40] <guifa> I’m not sure what the best syntax would be, but it would definitely help with the DWIT concept

[00:40] <guifa> DWIM*

[00:41] <guifa> I’ll do a where restrain for now

[00:41] *** zacts left
[00:43] <timotimo> Xliff: i wonder if putting a dynamic variable into the GTK:: packages would make it accessible through CALLERS:: or just the variable itself

[00:44] *** dominix__ is now known as dominix

[00:46] *** zachk left
[00:47] <Xliff> timotimo: How would it work with a dynvar?

[00:48] <Xliff> I mean, how would the failure case look?

[00:48] <timotimo> m: say $*FOO ~~ Failure

[00:48] <camelia> rakudo-moar d6563816e: OUTPUT: «True␤»

[00:48] <Xliff> Oh.

[00:48] <Xliff> LOL!

[00:51] <Xliff> timotimo: How would that work inside of a class?

[00:51] <Xliff> m: class A { my $*A; }

[00:51] <camelia> rakudo-moar d6563816e: ( no output )

[00:52] <dominix> m: say ((A, B, C,D) X=>1);

[00:52] <camelia> rakudo-moar d6563816e: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Undeclared names:␤    A used at line 1␤    B used at line 1␤    C used at line 1␤    D used at line 1␤␤»

[00:52] <guifa> finally!

[00:52] <Xliff> m: class A { my $*A; submethod BUILD { $*A = True; };  method a { $*A.say }; }; A.new

[00:52] <camelia> rakudo-moar d6563816e: OUTPUT: «Dynamic variable $*A not found␤  in submethod BUILD at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[00:52] * guifa does a little dance

[00:52] <dominix> m: say <(A, B, C,D) X=>1>;

[00:52] <camelia> rakudo-moar d6563816e: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Two terms in a row␤at <tmp>:1␤------> 3say <(A, B, C,D) X=>7⏏051>;␤    expecting any of:␤        infix␤        infix stopper␤        postfix␤        statement end␤        statement…»

[00:52] <Xliff> guifa++

[00:52] <Xliff> m: class A { my $*A = True;  method a { $*A.say }; }; A.new

[00:52] <camelia> rakudo-moar d6563816e: ( no output )

[00:52] <dominix> m: say (<A, B, C,D> X=>1);

[00:52] <camelia> rakudo-moar d6563816e: OUTPUT: «(A, => 1 B, => 1 C,D => 1)␤»

[00:53] <Xliff> m: class A { my $*A = True;  method a { $*A.say }; }; A.new.a

[00:53] <camelia> rakudo-moar d6563816e: OUTPUT: «Dynamic variable $*A not found␤  in method a at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[00:53] <dominix> m: say (<A, B, C, D> X=>1);

[00:53] <camelia> rakudo-moar d6563816e: OUTPUT: «(A, => 1 B, => 1 C, => 1 D => 1)␤»

[00:53] *** kurahaupo_ joined
[00:53] <Xliff> m: class A { my $*A = True;  method a { $*A = 1; $*A.say }; }; A.new.a

[00:53] <camelia> rakudo-moar d6563816e: OUTPUT: «Dynamic variable $*A not found␤  in method a at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[00:53] <dominix> can someone explain me this weird X=> thing in this exemple

[00:53] <Xliff> dominix: which example?

[00:53] <dominix> m: say (<A, B, C, D> X=>1);

[00:53] <camelia> rakudo-moar d6563816e: OUTPUT: «(A, => 1 B, => 1 C, => 1 D => 1)␤»

[00:54] <Xliff> X is cross operator.

[00:54] <Xliff> m: say (<A B C D> X (1, 2, 3))

[00:54] <camelia> rakudo-moar d6563816e: OUTPUT: «((A 1) (A 2) (A 3) (B 1) (B 2) (B 3) (C 1) (C 2) (C 3) (D 1) (D 2) (D 3))␤»

[00:55] <dominix> ha ok, at least I got the name of this thing

[00:55] <dominix> m: say (<A, B, C, D> X(1));

[00:55] <camelia> rakudo-moar d6563816e: OUTPUT: «((A, 1) (B, 1) (C, 1) (D 1))␤»

[00:55] <Xliff> m: say (<A B C D> X=>1);

[00:55] <camelia> rakudo-moar d6563816e: OUTPUT: «(A => 1 B => 1 C => 1 D => 1)␤»

[00:56] <lookatme_q> m: say (<A B C D> X=> 1);

[00:56] <camelia> rakudo-moar d6563816e: OUTPUT: «(A => 1 B => 1 C => 1 D => 1)␤»

[00:56] *** kurahaupo left
[00:56] <Xliff> dominix: If using <>, you do NOT need commas.

[00:56] <Xliff> m: <Todd Tim Timmah!>.say

[00:56] <camelia> rakudo-moar d6563816e: OUTPUT: «(Todd Tim Timmah!)␤»

[00:57] <dominix> Xliff, OK

[00:57] <Xliff> m: (<A B C D> X 1).say

[00:57] <camelia> rakudo-moar d6563816e: OUTPUT: «((A 1) (B 1) (C 1) (D 1))␤»

[00:58] <dominix> m: say (<A B C D> X=>1, <E F G H> X=>2, <I J K> X=>3);

[00:58] <camelia> rakudo-moar d6563816e: OUTPUT: «(A => 1 => 2 => 3 A => 1 => (I J K) => 3 A => (E F G H) => 2 => 3 A => (E F G H) => (I J K) => 3 B => 1 => 2 => 3 B => 1 => (I J K) => 3 B => (E F G H) => 2 => 3 B => (E F G H) => (I J K) => 3 C => 1 => 2 => 3 C => 1 => (I J K) => 3 C => (E F G H) => …»

[00:58] <Geth> ¦ doc: 897388637f | cfa++ | doc/Type/IO/Path.pod6

[00:58] <Geth> ¦ doc: Formatting.

[00:58] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/897388637f

[00:58] <synopsebot> Link: https://doc.perl6.org/type/IO::Path

[01:00] <Xliff> dominix: Now you are trying to cross with a list, which is why that came out so weird.

[01:00] <Xliff> W say ( (<A B C D> X=>1), (<E F G H> X=>2), (<I J K> X=>3));

[01:00] <Xliff> m: say ( (<A B C D> X=>1), (<E F G H> X=>2), (<I J K> X=>3));

[01:00] <camelia> rakudo-moar d6563816e: OUTPUT: «((A => 1 B => 1 C => 1 D => 1) (E => 2 F => 2 G => 2 H => 2) (I => 3 J => 3 K => 3))␤»

[01:00] <dominix> m: say (<A B C D> X=>1),(<E F G H> X=>2), (<I J K> X=>3);

[01:00] <camelia> rakudo-moar d6563816e: OUTPUT: «(A => 1 B => 1 C => 1 D => 1)(E => 2 F => 2 G => 2 H => 2)(I => 3 J => 3 K => 3)␤»

[01:00] <Xliff> m: say ( |(<A B C D> X=>1), |(<E F G H> X=>2), |(<I J K> X=>3));

[01:00] <camelia> rakudo-moar d6563816e: OUTPUT: «(A => 1 B => 1 C => 1 D => 1 E => 2 F => 2 G => 2 H => 2 I => 3 J => 3 K => 3)␤»

[01:01] <Xliff> ^ Flattened.

[01:01] <dominix> m: say ((<A B C D> X=>1),(<E F G H> X=>2), (<I J K> X=>3)).flat;

[01:01] <camelia> rakudo-moar d6563816e: OUTPUT: «(A => 1 B => 1 C => 1 D => 1 E => 2 F => 2 G => 2 H => 2 I => 3 J => 3 K => 3)␤»

[01:01] <dominix> haaa OK

[01:01] <Xliff> m: say |( (<A B C D> X=>1), (<E F G H> X=>2), (<I J K> X=>3)); # Also flattened

[01:01] <camelia> rakudo-moar d6563816e: OUTPUT: «(A => 1 B => 1 C => 1 D => 1)(E => 2 F => 2 G => 2 H => 2)(I => 3 J => 3 K => 3)␤»

[01:01] <Xliff> Or now.

[01:01] <Xliff> not

[01:01] <Xliff> Yeah. My mistake. That makes 3 lists, not one

[01:02] <dominix> m: say ( |(<A B C D> X=>1), |(<E F G H> X=>2), |(<I J K> X=>3));

[01:02] <camelia> rakudo-moar d6563816e: OUTPUT: «(A => 1 B => 1 C => 1 D => 1 E => 2 F => 2 G => 2 H => 2 I => 3 J => 3 K => 3)␤»

[01:03] <dominix> m: say ((<A B C D> X=>1),(<E F G H> X=>2), (<I J K> X=>3)).flat;

[01:03] <camelia> rakudo-moar d6563816e: OUTPUT: «(A => 1 B => 1 C => 1 D => 1 E => 2 F => 2 G => 2 H => 2 I => 3 J => 3 K => 3)␤»

[01:03] <dominix> the .flat operator has more meaning to me than this (|()) thing

[01:06] <Xliff> Is there a way to detect if the routine is in a role?

[01:07] <dominix> the doc on X "cross metaoperator" is very light 

[01:07] <Xliff> m: class A { method a { ?&ROUTINE.HOW.^name.say }; }; A.new.a

[01:07] <camelia> rakudo-moar d6563816e: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Undeclared name:␤    ROUTINE used at line 1. Did you mean 'Routine'?␤␤»

[01:07] <Xliff> m: class A { method a { &?ROUTINE.HOW.^name.say }; }; A.new.a

[01:07] <camelia> rakudo-moar d6563816e: OUTPUT: «Perl6::Metamodel::ClassHOW␤»

[01:08] <Xliff> m: role B { method b { &?ROUTINE.HOW.^name.say }; }; { class A does B { method a { &?ROUTINE.HOW.^name.say }; }; A.new.a; A.new.b

[01:08] <camelia> rakudo-moar d6563816e: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Missing block␤at <tmp>:1␤------> 3INE.HOW.^name.say }; }; A.new.a; A.new.b7⏏5<EOL>␤    expecting any of:␤        statement end␤        statement modifier␤        statement modifier loo…»

[01:08] <Xliff> m: role B { method b { &?ROUTINE.HOW.^name.say }; }; class A does B { method a { &?ROUTINE.HOW.^name.say }; }; A.new.a; A.new.b

[01:08] <camelia> rakudo-moar d6563816e: OUTPUT: «Perl6::Metamodel::ClassHOW␤Perl6::Metamodel::ClassHOW␤»

[01:08] <Geth> ¦ doc: 7350b35230 | cfa++ | 2 files

[01:08] <Geth> ¦ doc: Spelling.

[01:08] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/7350b35230

[01:08] <Xliff> m: role B { method b { &?ROUTINE.name.say }; }; class A does B { method a { &?ROUTINE.HOW.^name.say }; }; A.new.a; A.new.b

[01:08] <camelia> rakudo-moar d6563816e: OUTPUT: «Perl6::Metamodel::ClassHOW␤b␤»

[01:24] *** manwar joined
[01:24] <guifa> How do you test for die in the testing module?

[01:25] <guifa> (nok [something that dies] kills the testing ha)

[01:25] <timotimo> dies-ok

[01:25] <timotimo> or lives-ok

[01:26] <manwar> Just installed rakudo-star-2018.10.tar.gz using the instruction on https://perl6.org/downloads/

[01:27] <timotimo> hi mohammad :)

[01:27] <manwar> Hi TimoTimo :-)

[01:27] <manwar> However when I do manwar@ubuntu:~/rakudo-star-2018.10$ perl6 -v This is Rakudo version 2016.04 built on MoarVM version 2016.04 implementing Perl 6.c.

[01:28] <manwar> why does it say 2016.04

[01:28] <timotimo> sounds like you may have installed a rakudo via your package manager

[01:28] <manwar> most likely...how can I clean up?

[01:29] <timotimo> not exactly sure what the package would be called on ubuntu, maybe it's "apt-get uninstall rakudo"?

[01:29] <manwar> good guess...let me try

[01:29] <timotimo> other things to try, "perl6" or "rakudo-star"

[01:30] <timotimo> also, maybe it's apt-get purge rather than uninstall? i haven't been on a debian-like system in ages

[01:33] *** choiboi joined
[01:42] *** aborazmeh left
[01:48] <manwar> It can't find any package called rakudo

[01:48] <manwar> manwar@ubuntu:~/rakudo-star-2018.10$ sudo apt-get remove rakudo Reading package lists... Done Building dependency tree        Reading state information... Done Package 'rakudo' is not installed, so not removed 0 upgraded, 0 newly installed, 0 to remove and 257 not upgraded.

[01:49] *** ryn1x left
[01:52] <timotimo> have you tried "perl6" or "rakudo-star"?

[01:52] <timotimo> if there's a separate package "moarvm", it should also remove anything that uses that along with it

[01:53] <Xliff> manwar: "dpkg -l rakudo\*"

[01:53] <Xliff> Also

[01:53] <Xliff> manwar: "dpkg -l perl6\*"

[01:54] *** Kaiepi joined
[01:55] <manwar> dpkg-query: no packages found matching rakudo*

[01:56] <manwar> dpkg-query: no packages found matching perl6*

[01:57] <Xliff> manwar: "cd ~; which perl6"

[01:57] <timotimo> OK, maybe try "which perl6"

[01:57] <timotimo> yes

[01:58] <Xliff> Or maybe "~/rakudo-star-2018.10/site/install/bin/perl6 -v"

[01:58] <Xliff> I think that's the path.

[01:59] * Xliff dinner &

[02:00] <manwar> I am rebuilding fresh...having dropped the folder containing 2016.10

[02:00] *** Kaiepi left
[02:09] *** cfa left
[02:11] *** Praise left
[02:12] *** Praise joined
[02:12] *** Praise left
[02:12] *** Praise joined
[02:13] *** mowcat joined
[02:25] *** choiboi left
[02:26] *** AlexDani` joined
[02:28] *** AlexDaniel left
[02:29] <Geth> ¦ doc: f82ad1eecc | cfa++ | doc/Type/IO/Path.pod6

[02:29] <Geth> ¦ doc: Sort file test list.

[02:29] <Geth> ¦ doc: 

[02:29] <Geth> ¦ doc: Method order should probably follow suit.

[02:29] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/f82ad1eecc

[02:29] <synopsebot> Link: https://doc.perl6.org/type/IO::Path

[02:33] *** manwar left
[02:46] *** zacts joined
[03:13] *** MasterDuke joined
[03:13] *** MasterDuke left
[03:13] *** MasterDuke joined
[03:16] *** lgtaube left
[03:28] *** netrino_ left
[03:36] *** mowcat left
[03:36] *** lgtaube joined
[03:44] *** lgtaube left
[03:46] *** zacts left
[03:57] *** Kaiepi joined
[03:59] *** lgtaube joined
[04:04] <Geth> ¦ doc: 7c43c864a6 | cfa++ | doc/Type/IO/Path.pod6

[04:04] <synopsebot> Link: https://doc.perl6.org/type/IO::Path

[04:04] <Geth> ¦ doc: Expand file test list.

[04:04] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/7c43c864a6

[04:14] *** Cabanossi left
[04:22] <guifa> Okay I thought I tried resubmitting the PR to add BCP47 I think I messed up

[04:25] <guifa> (not in the file names just not seeing it as a pending PR)

[04:26] *** Cabanossi joined
[04:37] *** zacts joined
[04:44] *** reach_satori left
[04:47] *** kurahaupo_ left
[04:48] *** kurahaupo joined
[04:51] *** llfourn_ joined
[04:52] *** llfourn left
[04:54] *** molaf joined
[05:04] *** w17t joined
[05:14] *** ferreira1 left
[05:18] <Xliff> m: $*PERL.compiler.version.say

[05:18] <camelia> rakudo-moar d6563816e: OUTPUT: «v2018.12.311.gd.6563816.e␤»

[05:35] *** zacts left
[05:37] *** reach_satori joined
[05:57] *** curan joined
[06:04] *** dominix_ joined
[06:04] <dominix_> is there in perl6 something like perl5 B::Deparse ? 

[06:06] *** jmerelo joined
[06:06] <dominix_> trying to understand obscure code like : { given .comb(/<[A..Z0..9]>+/) { %map{.[0..*-2]} = .[*-1] xx (.elems - 1) } } for @B;

[06:07] <dominix_> @B contains text lines, like "A, E, I, O, U, L, N, R, S, T       1","B, C, M, P                         3"

[06:07] <dominix_> %map is an empty hash, my %map

[06:08] <jmerelo> releasable6: status

[06:08] <releasable6> jmerelo, Next release will happen when it's ready. 4 blockers. 175 out of 311 commits logged (⚠ 1 warnings)

[06:08] <releasable6> jmerelo, Details: https://gist.github.com/13fdfeb64080dafcbbc6c83c2a0ccdf1

[06:08] <dominix_> my @B=("Letter                           Value","A, E, I, O, U, L, N, R, S, T       1","D, G                               2","B, C, M, P                         3","F, H, V, W, Y                      4","K                                  5","J, X                               8","Q, Z                               10",);

[06:10] *** w_richard_w left
[06:17] <guifa> dominix_: I’m working up a little thing to show you

[06:17] *** zacts joined
[06:18] <Xliff> { .say } for <A B C>

[06:18] <evalable6> Xliff, rakudo-moar d6563816e: OUTPUT: «A␤B␤C␤»

[06:18] <Xliff> Well shit.

[06:18] <Xliff> m: -> $a, $b { .say } for <A B C> X <D E F>

[06:18] <camelia> rakudo-moar d6563816e: OUTPUT: «(Any)␤Too few positionals passed; expected 2 arguments but got 1␤  in block <unit> at <tmp> line 1␤␤(Any)␤(Any)␤(Any)␤»

[06:18] <Xliff> m: { .say } for <A B C> X <D E F>

[06:18] <camelia> rakudo-moar d6563816e: OUTPUT: «(A D)␤(A E)␤(A F)␤(B D)␤(B E)␤(B F)␤(C D)␤(C E)␤(C F)␤»

[06:20] <Xliff> dominix:  { given .comb(/<[A..Z0..9]>+/) { %map{.[0..*-2]} = .[*-1] xx (.elems - 1) } } for @B; is better written as

[06:22] <Xliff> for @B { my @a = $_.comb(/<[A..Z0..9+/); %map { $_.[0 .. *-2] = $_.[*-1] xx (@a.elems - 1) }

[06:23] <Xliff> m: @a = <A B C>; (%map { .[0..*-2] } = @a[*-1] xx 3).say

[06:23] <camelia> rakudo-moar d6563816e: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Variable '@a' is not declared␤at <tmp>:1␤------> 3<BOL>7⏏5@a = <A B C>; (%map { .[0..*-2] } = @a[*␤»

[06:23] <Xliff> m: my @a = <A B C>; (%map { .[0..*-2] } = @a[*-1] xx 3).say

[06:23] <camelia> rakudo-moar d6563816e: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Variable '%map' is not declared. Did you mean any of these?␤    &map␤    Map␤␤at <tmp>:1␤------> 3my @a = <A B C>; (7⏏5%map { .[0..*-2] } = @a[*-1] xx 3).say␤»

[06:23] <Xliff> m: my @a = <A B C>; (map { .[0..*-2] } = @a[*-1] xx 3).say

[06:23] <camelia> rakudo-moar d6563816e: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Missing comma after block argument to map␤at <tmp>:1␤------> 3 B C>; (map { .[0..*-2] } = @a[*-1] xx 37⏏5).say␤»

[06:23] <Xliff> m: my @a = <A B C>; (map { .[0..*-2] }, @a[*-1] xx 3).say

[06:23] <camelia> rakudo-moar d6563816e: OUTPUT: «(() () ())␤»

[06:24] <Xliff> m: my @a = <A B C>; {% map { .[0..*-2] } =  @a[*-1] xx 3)

[06:24] <camelia> rakudo-moar d6563816e: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Two terms in a row␤at <tmp>:1␤------> 3my @a = <A B C>; {%7⏏5 map { .[0..*-2] } =  @a[*-1] xx 3)␤    expecting any of:␤        infix␤        infix stopper␤        statement end␤     …»

[06:24] <Xliff> m: my @a = <A B C>; {map { .[0..*-2] } =  @a[*-1] xx 3)

[06:24] <camelia> rakudo-moar d6563816e: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Missing comma after block argument to map␤at <tmp>:1␤------> 3B C>; {map { .[0..*-2] } =  @a[*-1] xx 37⏏5)␤»

[06:24] <Xliff> m: my @a = <A B C>; {map { .[0..*-2] } =  @a[*-1] xx 3;

[06:24] <camelia> rakudo-moar d6563816e: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Missing comma after block argument to map␤at <tmp>:1␤------> 3B C>; {map { .[0..*-2] } =  @a[*-1] xx 37⏏5;␤»

[06:25] <Xliff> Yeah. That's a sign it's time for bed.

[06:25] <Xliff> That %map is doing me in.

[06:26] <Xliff> m: "Now is the time for all good men to come to the aid of their country"..comb(/<[A..Z0..9]>+/)

[06:26] <camelia> rakudo-moar d6563816e: OUTPUT: «WARNINGS for <tmp>:␤Useless use of ".." in expression "\"Now is the time for all good men to come to the aid of their country\"..comb(/<[A..Z0..9]>+/)" in sink context (line 1)␤Too few positionals passed; expected 2 or 3 arguments but got 1␤  in…»

[06:26] <Xliff> m: "Now is the time for all good men to come to the aid of their country".comb(/<[A..Z0..9]>+/)

[06:26] <camelia> rakudo-moar d6563816e: ( no output )

[06:26] <Xliff> m: "Now is the time for all good men to come to the aid of their country".comb(/<[A..Z0..9]>+/).say

[06:26] <camelia> rakudo-moar d6563816e: OUTPUT: «(N)␤»

[06:26] <Xliff> m: "Now is the Time for all Good men to come to the aid of their country".comb(/<[A..Z0..9]>+/).say

[06:26] <camelia> rakudo-moar d6563816e: OUTPUT: «(N T G)␤»

[06:27] <Xliff> So....

[06:27] <Xliff> m: .comb(/<[A..Z0..9]>+/).say == Search invocant for all capital letters and numbers and put them in an array in the order they were found.

[06:27] <camelia> rakudo-moar d6563816e: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Two terms in a row␤at <tmp>:1␤------> 3ers and numbers and put them in an array7⏏5 in the order they were found.␤    expecting any of:␤        infix␤        infix stopper␤        postf…»

[06:27] <guifa> https://tio.run/##hVTZUhsxEHxef8UUkMIQecHkqKQcKI7cIXdCEigqpV0PtkB7ZKU1dlz@dqc1xuEldvTg0mpaM909I5dc2YfTaTaiO5kuaZeaG50GvvYPd5uNaOWYveeKFq4TbWteUUAeKHqm6JWi94q@KjpW9E7RJ0WfFX2ZYduCe6roBS1dO4I7VHSk6K2iD4tw9wT3XNFLRSeKvin68W/gfQG@of@uBwJ8rej7ctwjwX1UdLoc194GEH42VqOLooKnNKZolWxRlI58vyrqXp9Yp32EGnNIa4/WkhnwminVOTn2QDMNgtnkixDHb6avmIxHAmfQI5xcFNYW16Fc1DMDzgGM0yJLmltPzg7i@HQ7jh@f793d2qAxsvu@AQskcZK9YldbT8XF/BbpvIuspUm1Nb@BQq1mJnjs9EAbqxMLWkbT2k9BJ7

[06:27] <guifa> czfLmNRhSFURpirBYx6YCIyZ1n3VXQu24tXdbOi2ZUgSgN3ZWRSsjUFGYV@7pKHGKOf9WcpxxqyVqlIyAUJSNRda1HinxlgkgYZEBS5yNIz3uIaw8Xfdq/sUBXvTrjHNXrsrSGu7dJXaHAZz2UtMaJTdK4ef1wkOrSeG3JyqNx4kjX9CBDyR4b08sLGE084OqGBVvHt3WEExJBH2AadgRi84ygbwamW@N8NMsZonmdJRiA9jYFc0wuvMMQROFNj@MzuL3Z2jmfoA/x2WarfU5DOBmz5cxRi9piHjq1Fk6g3wG4P7yNd@Zxj57LZIe4ZOoE0thQxjp3lPNQmiaktQs95CzcluEezpnIkF/xiMaiXGiG78BwVgQE/7KR8pMgaNKIJnhOTs/@rjrT6R8

[06:28] <guifa> Eek, didn’t realize that URL was going to be so big 

[06:28] <guifa> sorry

[06:28] <Xliff> :)

[06:28] <Xliff> You can always pastebin the URL! :D

[06:29] <Xliff> Still can't get that link to work.

[06:29] <guifa> https://pastebin.com/XNPVCNnC

[06:30] <guifa> Although for some reason I am not QUITE getting the same result

[06:30] <Xliff> guifa++

[06:31] <guifa> err duh I see it

[06:32] <dominix_> amazing

[06:32] * Xliff slaps forhead.

[06:32] <Xliff> %map is a freaking hash

[06:32] <dominix_> thanks guys for the explaination

[06:32] <Xliff> np

[06:35] <guifa> https://pastebin.com/zA3ymSQZ

[06:35] <guifa> That’s a better one

[06:35] <guifa> And gets the correct result 

[06:35] *** reach_satori left
[06:35] <guifa> Xliff: I was trying to figure that one out too for a second lol

[06:35] <Xliff> :)

[06:36] <dominix_> %map should look like this {A => 1, B => 3, C => 3, D => 2, E => 1, F => 4, G => 2, H => 4, I => 1, J => 8, K => 5, L => 1, M => 3, N => 1, O => 1, P => 3, Q => 10, R => 1, S => 1, T => 1, U => 1, V => 4, W => 4, X => 8, Y => 4, Z => 10}

[06:36] <guifa> dominix if you look at the last link you sent you should get that result 

[06:37] <dominix_> it put weight to some letter (it is use to score words at scrabble)

[06:39] *** Cabanossi left
[06:39] <dominix_> I guess the use of %map has confused me with map{} 

[06:40] *** reach_satori joined
[06:41] <guifa> So I tried to make my language tag module automagically use the latest and greatest language subtag registry direct from IANA.  They provide a super easy to process text file that I could have used a phaser to compile-time download and parse

[06:42] <guifa> Make a raw HTTP request and everything to keep dependencies down

[06:42] <guifa> And what do I end up downloading?  A file telling me that the file has moved and is now at an HTTPS page =\

[06:44] <Geth> ¦ doc: 07a56a2457 | (JJ Merelo)++ | doc/Type/Any.pod6

[06:44] <Geth> ¦ doc: Adds tail refs |1494

[06:44] <synopsebot> Link: https://doc.perl6.org/type/Any

[06:44] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/07a56a2457

[06:44] <Geth> ¦ doc: 39140e37f4 | (JJ Merelo)++ | doc/Type/Any.pod6

[06:44] <Geth> ¦ doc: Adds iterator refs #1494

[06:44] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/39140e37f4

[06:45] <SmokeMachine> m: sub bla is hidden-from-backtrace {}; say &bla ~~ is-hidden-from-backtrace

[06:45] <camelia> rakudo-moar d6563816e: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Undeclared routine:␤    is-hidden-from-backtrace used at line 1␤␤»

[06:45] *** cgfbee left
[06:46] <dominix_> thanks guifa:

[06:48] *** Cabanossi joined
[06:50] *** kurahaupo left
[06:50] *** kurahaupo_ joined
[06:50] *** kurahaupo_ left
[06:51] *** kurahaupo joined
[06:52] <guifa> SmokeMachine: I’m about to upload Fluent if you want to play around with it although the big feature (the number selection) isn’t available

[06:53] <ufobat_> cfa tadzik wondering if this line needs a 'is rw'  https://github.com/Bailador/Bailador/blob/dev/lib/Bailador/Context.pm#L7

[06:53] <SmokeMachine> guifa: sure! I’ll take a look when I go back from work! :)

[06:54] *** molaf left
[06:55] <Xliff> ufobat_: No, it's this line that needs the "is rw" https://github.com/Bailador/Bailador/blob/dev/lib/Bailador/Context.pm#L12

[06:56] <ufobat_> ah 

[06:56] <Xliff> And definitely want a "FETCH => ->" here https://github.com/Bailador/Bailador/blob/dev/lib/Bailador/Context.pm#L12

[06:56] <ufobat_> those lines are still your code, tadzik :p

[06:57] <ufobat_> thanks Xliff 

[06:57] <Xliff> :)

[06:58] <ufobat_> i cant fix it in the next 3 days i am afraid

[07:00] <Xliff> m: class A { has $!a; method a is rw { Proxy.new: FETCH => { $!a }, STORE => -> $, $v { $!a = $v }; }; }; my $a = A.new; $a.a = 4; $a.a.say; $a.a = 2; $a.a.say

[07:00] <camelia> rakudo-moar d6563816e: OUTPUT: «4␤2␤»

[07:01] <Xliff> OK, So the FETCH is fine.

[07:01] <Xliff> But the method definitely needs the "is rw"

[07:01] <Xliff> m: class A { has $!a; method a { Proxy.new: FETCH => { $!a }, STORE => -> $, $v { $!a = $v }; }; }; my $a = A.new; $a.a = 4; $a.a.say; $a.a = 2; $a.a.say

[07:01] <camelia> rakudo-moar d6563816e: OUTPUT: «Cannot modify an immutable 'Any' type object␤  in block <unit> at <tmp> line 1␤␤»

[07:02] <Xliff> m: class A { has $!a = 2; method a { Proxy.new: FETCH => { $!a }, STORE => -> $, $v { $!a = $v }; }; }; my $a = A.new; $a.a = 4; $a.a.say; $a.a = 2; $a.a.say

[07:02] <camelia> rakudo-moar d6563816e: OUTPUT: «Cannot modify an immutable Int (2)␤  in block <unit> at <tmp> line 1␤␤»

[07:02] <Xliff> m: class A { has $!a = 2; method a { Proxy.new: FETCH => { $!a }, STORE => -> $, $v { $!a = $v }; }; }; my $a = A.new; $a.a.say; $a.a = 2; $a.a.say

[07:02] <camelia> rakudo-moar d6563816e: OUTPUT: «2␤Cannot modify an immutable Int (2)␤  in block <unit> at <tmp> line 1␤␤»

[07:02] * Xliff bed &

[07:07] *** kurahaupo left
[07:07] *** kurahaupo_ joined
[07:07] *** kurahaupo_ left
[07:07] *** kurahaupo joined
[07:08] *** ayerhart left
[07:09] *** sauvin joined
[07:09] *** dominix_ left
[07:15] *** kurahaupo left
[07:15] *** kurahaupo joined
[07:17] *** ayerhart joined
[07:28] <guifa> SmokeMachine: what’s your username on GH?

[07:36] <SmokeMachine> guifa: FCO

[07:38] *** jmerelo left
[07:45] *** Xliff left
[07:52] <ufobat_> bisectable6_, help

[07:52] <bisectable6_> ufobat_, Like this: bisectable6_: old=2015.12 new=HEAD exit 1 if (^∞).grep({ last })[5] // 0 == 4 # See wiki for more examples: https://github.com/perl6/whateverable/wiki/Bisectable

[07:53] <ufobat_> m: class A { has $!a; method a { Proxy.new: FETCH => { $!a }, STORE => -> $, $v { $!a = $v }; }; }; my $a = A.new; $a.a = 4

[07:53] <camelia> rakudo-moar d6563816e: OUTPUT: «Cannot modify an immutable 'Any' type object␤  in block <unit> at <tmp> line 1␤␤»

[07:54] <ufobat_> bisectable6_: old=2017.01 new=HEAD class A { has $!a; method a { Proxy.new: FETCH => { $!a }, STORE => -> $, $v { $!a = $v }; }; }; my $a = A.new; $a.a = 4

[07:54] <bisectable6_> ufobat_, Bisecting by exit code (old=2017.01 new=d656381). Old exit code: 0

[07:54] <bisectable6_> ufobat_, bisect log: https://gist.github.com/6514fab899ffc19f160d3c5f991933c3

[07:54] <bisectable6_> ufobat_, (2018-11-19) https://github.com/rakudo/rakudo/commit/7d37f9aaf0ef0290709679568dac0b6110c43506

[08:18] *** rindolf joined
[08:38] *** Grauwolf left
[08:38] *** Grauwolf joined
[08:38] *** Grauwolf left
[08:38] *** Grauwolf joined
[08:42] *** Xliff joined
[08:43] <Xliff> m: my %a = (a => 1, b => 2, c => 3); my %b = ( d => 4, e => 5, f => 6) %a.append(%b);  %a.gist.say

[08:43] <camelia> rakudo-moar d6563816e: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Cannot use variable %b in declaration to initialize itself␤at <tmp>:1␤------> 3 = ( d => 4, e => 5, f => 6) %a.append(%7⏏5b);  %a.gist.say␤    expecting any of:␤        argument list␤   …»

[08:43] <Xliff> m: my %a = (a => 1, b => 2, c => 3); my %b = ( d => 4, e => 5, f => 6); %a.append(%b);  %a.gist.say

[08:43] <camelia> rakudo-moar d6563816e: OUTPUT: «{a => 1, b => 2, c => 3, d => 4, e => 5, f => 6}␤»

[08:43] <Xliff> m: my %a = (a => 1, b => 2, c => 3); my %b = ( c => 4, e => 5, f => 6); %a.append(%b);  %a.gist.say

[08:43] <camelia> rakudo-moar d6563816e: OUTPUT: «{a => 1, b => 2, c => [3 4], e => 5, f => 6}␤»

[08:47] *** zacts left
[08:47] <Xliff> m: my @a = ('A', 'B', 0, "C"); @a.grep( Int ).say

[08:47] <camelia> rakudo-moar d6563816e: OUTPUT: «(0)␤»

[08:47] <Xliff> m: my @a = ('A', 'B', 42, "C"); @a.grep( Int ).say

[08:47] <camelia> rakudo-moar d6563816e: OUTPUT: «(42)␤»

[08:47] <Xliff> m: my @a = ('A', 'B', 42, "C"); @a.grep( Str ).say

[08:47] <camelia> rakudo-moar d6563816e: OUTPUT: «(A B C)␤»

[08:57] <masak> Xliff: did you know you can also privmsg with camelia?

[08:57] <Xliff> Yes

[08:58] *** woolfy left
[09:02] *** w17t left
[09:04] *** w17t joined
[09:06] *** woolfy joined
[09:13] *** zacts joined
[09:27] *** avar joined
[09:27] *** avar left
[09:27] *** avar joined
[10:00] *** sena_kun joined
[10:15] *** dustinm` left
[10:22] *** dustinm` joined
[10:27] *** dominix_ joined
[10:30] *** dominix left
[10:51] *** kurahaupo left
[10:51] *** kurahaupo joined
[10:52] *** kurahaupo left
[10:52] *** pecastro joined
[10:52] *** kurahaupo joined
[11:15] *** kurahaupo left
[11:15] *** kurahaupo joined
[11:15] *** kurahaupo left
[11:16] *** kurahaupo joined
[11:25] *** mowcat joined
[11:36] *** Kaiepi left
[12:08] *** curan left
[12:18] *** gregf_ left
[12:25] *** lucasb joined
[12:35] *** dogbert2_ left
[12:37] *** gregf_ joined
[12:40] *** curan joined
[12:44] *** curan left
[12:45] *** curan joined
[12:56] *** kurahaupo left
[12:56] *** kurahaupo joined
[12:59] <tbrowder> has anyone seen notice of my version 2 of Date::Names uploaded to cpan? loaded it near mid day (UTC-5) yesterday.

[12:59] <jkramer> m: sub foo { 'lol' }; (foo() xx 3).join.say

[12:59] <camelia> rakudo-moar d6563816e: OUTPUT: «lollollol␤»

[12:59] <jkramer> Shouldn't this work without the ()?

[12:59] <jkramer> m: sub foo { 'lol' }; (foo xx 3).join.say

[12:59] <camelia> rakudo-moar d6563816e: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Undeclared routine:␤    xx used at line 1␤␤»

[12:59] <timotimo> jkramer: after a sub, a term is expected, not an infix  :)

[12:59] <timotimo> however

[13:00] <timotimo> m: sub term:<foo> { 'lol' }; (foo xx 3).join.say

[13:00] <camelia> rakudo-moar d6563816e: OUTPUT: «lollollol␤»

[13:00] <jkramer> Ah right, that's kinda :D

[13:00] <timotimo> ^- in SDL2::Raw i made SDL_GetTicks a term, not only because it's a no-arguments sub, but also because it tends to be used as a term all over in maths calculations

[13:00] <jkramer> *obvious

[13:02] <lizmat> https://twitter.com/perl6_cpan_new/status/1098636403989143552   # tbrowder

[13:03] <tbrowder> lizmat: thnx. i'm used to seeing msg here but i never saw one.

[13:04] <lizmat> the tweet is done by a different bot

[13:04] <lizmat> so it could well be that you didn't see it here

[13:05] <tbrowder> lizmat: ref holapi, i found my pr is not merged, pinged josh, hopefully he is ok and will answer.

[13:05] * lizmat hopes so as well

[13:21] *** mowcat left
[13:32] *** Kaiepi joined
[13:36] *** w17t left
[13:40] *** dogbert2_ joined
[13:41] <masak> https://en.wikipedia.org/wiki/Safe_navigation_operator#Perl_6 -- it's odd to see `.?` being mentioned in an article which is otherwise about `?.`

[13:41] <masak> it almost feels like a mistake that Perl 6's operator is mentioned there at all

[13:42] <jnthn> Huh, it's just a spelling difference, no?

[13:43] <masak> (to be painfully clear: the article is about a syntax `$obj?.meth` which returns null (instead of dying) when $obj is null. Perl 6's `$obj.?meth` is about not dying when `.meth` is absent.)

[13:43] <jnthn> Oh

[13:43] <masak> jnthn: so, no :)

[13:43] <timotimo> the ? is on the side that is allowed to be missing, clearly

[13:43] <masak> I know moritz++ is aware of this difference. he's explained it to me more than once ;)

[13:43] <masak> (and I keep forgetting)

[13:44] <masak> timotimo: just as clearly, `?.?` would be for the case when *both* the object and the method are allowed to be missing :P

[13:44] <timotimo> :)

[13:45] <timotimo> more operators that look like emoji

[13:50] *** vike left
[13:53] *** Kaiepi left
[13:54] <jkramer> m: my regex lol { 'lol' }; say lol.WHAT

[13:54] <camelia> rakudo-moar d6563816e: OUTPUT: «Too few positionals passed; expected 1 argument but got 0␤  in regex lol at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[13:54] *** vike joined
[13:54] <jkramer> m: my regex lol { 'lol' };

[13:54] <camelia> rakudo-moar d6563816e: ( no output )

[13:55] <jkramer> m: my regex lol { 'lol' }; say lol.^name

[13:55] <camelia> rakudo-moar d6563816e: OUTPUT: «Too few positionals passed; expected 1 argument but got 0␤  in regex lol at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[13:55] <jkramer> What? :D

[13:55] <jnthn> It's a routine, so you're calling it

[13:55] <jkramer> Oh

[13:55] <jnthn> &lol

[13:55] <jkramer> Well locally I'm getting this: Cannot find method 'match': no method cache and no .^find_method

[13:56] <jnthn> m: my regex lol { 'lol' }; say &lol.^name

[13:56] <camelia> rakudo-moar d6563816e: OUTPUT: «Regex␤»

[14:00] *** abraxxa left
[14:00] <jkramer> m: my regex lol { 'lol' }; say lol('lol')

[14:00] <camelia> rakudo-moar d6563816e: OUTPUT: «No such method '!cursor_start' for invocant of type 'Str'␤  in regex lol at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[14:00] <jkramer> m: my regex lol { 'lol' }; say 'lol' ~~ lol

[14:00] <camelia> rakudo-moar d6563816e: OUTPUT: «Too few positionals passed; expected 1 argument but got 0␤  in regex lol at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[14:00] <jkramer> m: my regex lol { 'lol' }; say 'lol'.match(lol)

[14:00] <camelia> rakudo-moar d6563816e: OUTPUT: «Too few positionals passed; expected 1 argument but got 0␤  in regex lol at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[14:01] <jkramer> m: my regex lol { 'lol' }; say 'lol' ~~ /<lol>/

[14:01] <camelia> rakudo-moar d6563816e: OUTPUT: «｢lol｣␤ lol => ｢lol｣␤»

[14:01] <jkramer> Is this the only way I can use it?

[14:02] <sena_kun> ACCEPTS?

[14:02] <sena_kun> m:  my regex lol { 'lol' }; say 'lol'.ACCEPTS(lol);

[14:02] <camelia> rakudo-moar d6563816e: OUTPUT: «Too few positionals passed; expected 1 argument but got 0␤  in regex lol at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[14:02] <sena_kun> m:  my regex lol { 'lol' }; say lol.ACCEPTS('lol');

[14:02] <camelia> rakudo-moar d6563816e: OUTPUT: «Too few positionals passed; expected 1 argument but got 0␤  in regex lol at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[14:02] <sena_kun> hmm

[14:03] <jkramer> Ah wait, it's the same mistake as before :)

[14:03] <lucasb> m: my regex lol { 'lol' }; say 'lol' ~~ &lol

[14:03] <camelia> rakudo-moar d6563816e: OUTPUT: «｢lol｣␤»

[14:03] <jkramer> m: my regex lol { 'lol' }; say 'lol'.match(&lol)

[14:03] <camelia> rakudo-moar d6563816e: OUTPUT: «｢lol｣␤»

[14:03] <jkramer> m: my regex lol { 'lol' }; say 'lol' ~~ &lol

[14:03] <camelia> rakudo-moar d6563816e: OUTPUT: «｢lol｣␤»

[14:03] <sena_kun> yup, and ACCEPTS wants `&` too.

[14:05] <jkramer> m: my regex lol { 'lol' }; say &lol.signature

[14:05] <camelia> rakudo-moar d6563816e: OUTPUT: «(Mu: *%_)␤»

[14:24] *** kylese joined
[14:26] *** mack[m] joined
[14:29] <mack[m]> /join #freenode_#smartos:matrix.org

[14:31] *** molaf joined
[14:50] *** w17t joined
[14:51] *** AlexDani` is now known as AlexDaniel

[14:53] *** ambs left
[14:54] <woolfy> We have hundreds of t-shirts, jackets and hoodies, Perl- and otherwise related.  See this album on Flickr: https://www.flickr.com/photos/wendyga/albums/72157707043555354  and my blog about it: https://wendyga.wordpress.com/2019/02/22/t-shirts-lots-of-t-shirts/

[14:59] <El_Che> so many tshirts

[15:01] <Geth> ¦ doc: fba25f87d7 | cfa++ | doc/Type/IO/Path.pod6

[15:01] <Geth> ¦ doc: IO::Path: restructure the file test operator section.

[15:01] <synopsebot> Link: https://doc.perl6.org/type/IO::Path

[15:01] <Geth> ¦ doc: 

[15:01] <Geth> ¦ doc: Update examples, reference .path.

[15:01] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/fba25f87d7

[15:04] *** choiboi joined
[15:16] *** ambs joined
[15:27] *** curan left
[15:28] <woolfy> Claudio Ramirez: sometimes they make me crazy.  Crazy shirt.

[15:32] *** Actualeyes joined
[15:36] <choiboi> I just implemented all the heart emoji in xikuuky/Avolution-Emoji

[15:36] <choiboi> ^_^

[15:41] *** cfa joined
[15:42] <lizmat> choiboi++   # any place we can see progress / try things out ?

[15:43] *** xinming_ left
[15:45] <SmokeMachine> now Im on Europe, Im sure it will be easier... how can I buy a Camelia?

[15:46] <lizmat> SmokeMachine: visiting any Perl event / PM meeting anytime soon ?

[15:47] <lizmat> like GPW / Amsterdam.pm meeting / Niederrhein.pm meeting ?

[15:47] <SmokeMachine> lizmat: Im going to the next London tech meeting...

[15:47] <lizmat> when is that ?

[15:47] <SmokeMachine> next week, I think...

[15:48] <lizmat> sorry, won't be able to give someone a Camelia for you before that :-(

[15:48] <SmokeMachine> yes, next week: https://www.meetup.com/London-Perl-Mongers/events/258358558/

[15:49] <SmokeMachine> lizmat: no problem... Ill find a way... :) when will be that meetings you sad?

[15:49] <choiboi> lizmat: the repos is https://github.com/XiKuuKy/Avolution-Emoji , if people want to try it out, I'll start up the bot again

[15:50] <lizmat> SmokeMachine: GPW http://act.yapc.eu/gpw2019/

[15:50] <lizmat> Amsterdam.pm every first Tue of the month, except next month due to GPW

[15:50] <lizmat> (second Tue)

[15:50] <lizmat> Niederrhein.pm every 3rd Thursday of the month (in Cologne)

[15:52] *** Kaiepi joined
[15:53] <SmokeMachine> lizmat: I think Ill have to wait to rent a property before getting it... :( but thank you!

[15:53] <choiboi> How long does it take zef/p6 to notice a package has upgraded? (I just released a new version so I could update, but it is still only finding version 0.1.0)

[15:54] <lizmat> choiboi: up to 4 hours I seem to recall

[15:54] <choiboi> lizmat: alright, I'll try to install from the local repo so that I can speed this up (for the emojibot)

[15:55] <lizmat> :-)

[15:57] <choiboi> lizmat: If you want to try the emojibot, go to #perl6bottest or /msg emojibot , I recommend before using that you read the docs so you know what codes don't work

[15:57] *** ambs left
[15:57] *** zacts left
[16:13] *** jmerelo joined
[16:13] <Geth> ¦ doc: a0048653aa | cfa++ | doc/Language/numerics.pod6

[16:13] <Geth> ¦ doc: Rat degradation example.

[16:13] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/a0048653aa

[16:13] <synopsebot> Link: https://doc.perl6.org/language/numerics

[16:19] <choiboi> is there anyway to find all lines with a comment on them and print them without writing a regex pattern?

[16:24] *** ravenousmoose left
[16:24] <moritz> depends on which language you are parsing, and how precise you want to do that

[16:24] <moritz> $string.contains('#') might be enough, or it might not

[16:26] <lizmat> my $a = "#"

[16:26] <lizmat> ^^ not a comment

[16:28] <choiboi> thanks

[16:35] *** zacts joined
[16:43] *** mowcat joined
[16:46] <moritz> in general, you need to parse all quote-like constructs to reliably determine comments

[16:50] *** bobby left
[16:54] *** kurahaupo left
[16:54] *** kurahaupo joined
[16:55] *** kurahaupo left
[16:55] *** kurahaupo joined
[16:55] <choiboi> moritz: yeah, I'm writing a program to find comments in my code right now.

[17:04] *** reach_satori left
[17:19] <lucasb> m: dd ((1,2),(3,4)).Set

[17:19] <camelia> rakudo-moar d6563816e: OUTPUT: «Set.new(4,1,3,2)␤»

[17:19] <lucasb> m: dd [(1,2),(3,4)].Set

[17:19] <camelia> rakudo-moar d6563816e: OUTPUT: «Set.new((1, 2),(3, 4))␤»

[17:20] <lucasb> can't get why the different behavior

[17:20] <lucasb> with regard lists vs. arrays

[17:23] <jmerelo> lucasb: main difference is that Arrays are not immutable. Every element of the array is an item. But I don't think that's got anything to do with it. It's probably just using different constructors.

[17:23] <jnthn> m: dd ((1,2),$(3,4)).Set

[17:23] <camelia> rakudo-moar d6563816e: OUTPUT: «Set.new(1,2,(3, 4))␤»

[17:23] <jnthn> m: dd ($(1,2),$(3,4)).Set

[17:23] <camelia> rakudo-moar d6563816e: OUTPUT: «Set.new((1, 2),(3, 4))␤»

[17:24] <jmerelo> jnthn: so I got this right. It's the item thing. 

[17:24] * jmerelo hi-fives himself.

[17:24] <jnthn> Yes

[17:26] <lucasb> ok, I think I get: array elements are implicty itemized while list elements aren't. right? :) thanks

[17:26] <lucasb> *implicit(ly)

[17:26] <jnthn> Yes

[17:34] *** Aceeri__ joined
[17:36] *** ferreira joined
[17:54] *** Kaiepi left
[17:56] *** ravenousmoose joined
[17:57] *** mowcat left
[17:57] *** ravenousmoose left
[18:11] *** reach_satori joined
[18:14] *** natrys joined
[18:20] *** patrickb joined
[18:23] *** zacts left
[18:25] *** aindilis left
[18:34] *** aindilis joined
[18:36] *** autark joined
[18:46] *** netrino joined
[18:47] <Xliff> \o

[18:54] *** molaf left
[18:59] *** ufobat__ joined
[19:02] *** ufobat_ left
[19:03] <Geth> ¦ doc: 1fda10edd7 | cfa++ | doc/Language/numerics.pod6

[19:03] <synopsebot> Link: https://doc.perl6.org/language/numerics

[19:03] <Geth> ¦ doc: Extend Rat degradation example.

[19:03] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/1fda10edd7

[19:05] *** manwar joined
[19:12] <manwar> I found this in office perl6 doc, has $.destination = self.origin eq 'Orlando' ?? 'Kampala' !! 'Orlando';, can I force it die if condition is false?

[19:14] <jmerelo> hi, manwar

[19:14] <El_Che> manwar: make it 'is required'

[19:14] <manwar> Hi

[19:15] <El_Che> https://docs.perl6.org/type/Attribute.html#Trait_is_required

[19:15] <manwar> But I want to add constraint if self.origin is not 'Orlando' then die

[19:15] <jmerelo> manwar: you can simply use || die "Need this thing"

[19:15] <jmerelo> manwar: it's better to catch that at the signature level

[19:15] <sena_kun> m: class A { has $.a; has $.destination = $.a eq 'Orlando' ?? 'Kampala' !! die 'Too bad'; } say A.new(a => 'Orlando'); say A.new(a => 'Orlandoe');

[19:15] <camelia> rakudo-moar d6563816e: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Virtual method call $.a may not be used on partially constructed object (maybe you mean $!a for direct attribute access here?)␤at <tmp>:1␤------> 3ass A { has $.a; has $.destination = $.a7⏏5 eq…»

[19:16] <sena_kun> m: class A { has $.a; has $.destination = $!a eq 'Orlando' ?? 'Kampala' !! die 'Too bad'; } say A.new(a => 'Orlando'); say A.new(a => 'Orlandoe');

[19:16] <camelia> rakudo-moar d6563816e: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Strange text after block (missing semicolon or comma?)␤at <tmp>:1␤------> 3rlando' ?? 'Kampala' !! die 'Too bad'; }7⏏5 say A.new(a => 'Orlando'); say A.new(a ␤    expecting any of:␤       …»

[19:16] <sena_kun> m: class A { has $.a; has $.destination = $!a eq 'Orlando' ?? 'Kampala' !! die 'Too bad'; }; say A.new(a => 'Orlando'); say A.new(a => 'Orlandoe');

[19:16] <camelia> rakudo-moar d6563816e: OUTPUT: «A.new(a => "Orlando", destination => "Kampala")␤Too bad␤  in method  at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[19:16] <sena_kun> manwar, ^?

[19:17] <manwar> Thanks sena_hun, let me try that

[19:17] <jmerelo> m: class A { has $.a; has $.destination where * eq "Orlando" }; my $a = A.new(destination => "Orlando); say $a

[19:17] <camelia> rakudo-moar d6563816e: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Cannot use variable $a in declaration to initialize itself␤at <tmp>:1␤------> 3 = A.new(destination => "Orlando); say $7⏏5a␤    expecting any of:␤        double quotes␤        term␤»

[19:18] <jmerelo> m: class A { has $.destination where * eq "Orlando"; }; my $a = A.new(destination => "Orlando); say $a

[19:18] <camelia> rakudo-moar d6563816e: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Cannot use variable $a in declaration to initialize itself␤at <tmp>:1␤------> 3 = A.new(destination => "Orlando); say $7⏏5a␤    expecting any of:␤        double quotes␤        term␤»

[19:18] <jmerelo> m: class A { has $.destination where * eq "Orlando"; }; my $a = A.new(destination => "Orlando"); say $a

[19:18] <camelia> rakudo-moar d6563816e: OUTPUT: «A.new(destination => "Orlando")␤»

[19:18] <jmerelo> m: class A { has $.destination where * eq "Orlando"; }; my $a = A.new(destination => "Someplace else"); say $a

[19:18] <camelia> rakudo-moar d6563816e: OUTPUT: «Type check failed in assignment to $!destination; expected <anon> but got Str ("Someplace else")␤  in block <unit> at <tmp> line 1␤␤»

[19:19] <jmerelo> manwar: ^^^that's another way

[19:19] <jmerelo> manwar: you can use "where" to qualify attributes, and also arguments in functions.

[19:19] <manwar> Excellent, jmerelo.

[19:20] <manwar> Can I also say "is required" with the constraint?

[19:20] <sena_kun> jmerelo, I don't think it is.

[19:20] <sena_kun> manwar, sure.

[19:20] <sena_kun> jmerelo, see:

[19:21] <sena_kun> m: class A { has $.destination where "Orlando" }; say A.new;

[19:21] <camelia> rakudo-moar d6563816e: OUTPUT: «A.new(destination => <anon>)␤»

[19:21] <sena_kun> so destination has type of a lambda, but it doesn't work as a guard.

[19:22] <jmerelo> manwar: "is required" will say that you need to assign a value; since that balue needs to be "Orlando", that should be taken care of.

[19:22] *** grumble is now known as `-_-`grumble

[19:22] <manwar> Perfect, sena_kun.

[19:22] <jmerelo> m: class A { has $.destination where * eq "Orlando" is required; }; my $a = A.new(destination => "Someplace else"); say $a

[19:22] <camelia> rakudo-moar d6563816e: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Two terms in a row␤at <tmp>:1␤------> 3{ has $.destination where * eq "Orlando"7⏏5 is required; }; my $a = A.new(destinati␤    expecting any of:␤        constraint␤        infix␤      …»

[19:22] *** zacts joined
[19:23] <jmerelo> m: class A { has $.destination is required where * eq "Orlando"; }; my $a = A.new(destination => "Someplace else"); say $a

[19:23] <camelia> rakudo-moar d6563816e: OUTPUT: «Type check failed in assignment to $!destination; expected <anon> but got Str ("Someplace else")␤  in block <unit> at <tmp> line 1␤␤»

[19:23] <jmerelo> m: class A { has $.destination is required where * eq "Orlando"; }; my $a = A.new; say $a

[19:23] <camelia> rakudo-moar d6563816e: OUTPUT: «The attribute '$!destination' is required, but you did not provide a value for it.␤  in block <unit> at <tmp> line 1␤␤»

[19:23] <sena_kun> m: class A { has $.destination where * eq "Orlando"; }; my $a = A.new(destination => "Orlando"); say $a

[19:23] <camelia> rakudo-moar d6563816e: OUTPUT: «A.new(destination => "Orlando")␤»

[19:23] <jmerelo> sena_kun: ^^^ now?

[19:23] <sena_kun> oops, nevermind me, I am too dumb, sorry. :|

[19:24] *** sauvin left
[19:24] <jmerelo> m: class A { has $.destination is required where * eq "Orlando"; }; my $a = A.new( destination => "Orlando" ); say $a

[19:24] <camelia> rakudo-moar d6563816e: OUTPUT: «A.new(destination => "Orlando")␤»

[19:25] <jmerelo> m: class A { has $.destination  where * eq "Orlando" = ''; }; my $a = A.new( destination => "Orlando" ); say $a

[19:25] <camelia> rakudo-moar d6563816e: OUTPUT: «A.new(destination => "Orlando")␤»

[19:25] <jmerelo> m: class A { has $.destination  where * eq "Orlando" = ''; }; my $a = A.new; say $a

[19:25] <camelia> rakudo-moar d6563816e: OUTPUT: «Type check failed in assignment to $!destination; expected <anon> but got Str ("")␤  in block <unit> at <tmp> line 1␤␤»

[19:25] <cfa> r

[19:25] <cfa> er, or*

[19:25] <cfa> m: subset OnlyOrlando of Str where * eq "Orlando"; class A { has OnlyOrlando $.destination }; say A.new(destination => "Orlando")

[19:25] <camelia> rakudo-moar d6563816e: OUTPUT: «A.new(destination => "Orlando")␤»

[19:25] <cfa> vs.

[19:25] <jmerelo> m: class A { has $.destination  where * eq "Orlando" = ''; }; my $a = A.new( destination => "Someplaceelse" ); say $a

[19:25] <camelia> rakudo-moar d6563816e: OUTPUT: «Type check failed in assignment to $!destination; expected <anon> but got Str ("Someplaceelse")␤  in block <unit> at <tmp> line 1␤␤»

[19:25] <cfa> m: subset OnlyOrlando of Str where * eq "Orlando"; class A { has OnlyOrlando $.destination }; say A.new(destination => "Miami")

[19:25] <camelia> rakudo-moar d6563816e: OUTPUT: «Type check failed in assignment to $!destination; expected OnlyOrlando but got Str ("Miami")␤  in block <unit> at <tmp> line 1␤␤»

[19:25] <cfa> which might be more descriptive

[19:25] <cfa> er, add is required as before if necessary

[19:26] <jmerelo> TMWTDI

[19:26] *** rindolf left
[19:27] <cfa> m: subset OnlyOrlando of Str where * eq "Orlando"; { .say } given class { has OnlyOrlando $.destination }.new: destination => "Orlando"  # for jmerelo 

[19:27] <camelia> rakudo-moar d6563816e: OUTPUT: «<anon|1>.new(destination => "Orlando")␤»

[19:27] *** rindolf joined
[19:27] <cfa> er, .say needn't be braced there

[19:28] <rindolf> Hi all

[19:28] <rindolf> manwar: hi

[19:28] *** MasterDuke left
[19:29] <manwar> hi rindolf

[19:29] <Harzilein> gnu time hat ein merkwuerdiges default-ausgabeformat

[19:29] <jmerelo> cfa: great!

[19:29] <Harzilein> ewin

[19:29] <rindolf> manwar: what's new?

[19:29] *** irced joined
[19:30] <rindolf> what?

[19:30] <jmerelo> rindolf: manwar has made a pull request to every single CPAN module and now needs another language ;-)

[19:30] <rindolf> jmerelo: heh

[19:31] <manwar> rindolf, I am simply fighting at the moment

[19:31] <rindolf> manwar: ah, fighting what?

[19:31] <manwar> may be one day, I will know enough Perl6 to contribute

[19:33] <manwar> I am trying to create a class with 2 attrbutes, where I want add constraint the second attribute should always be smaller than the first attribute

[19:33] <manwar> and both attributes are required

[19:34] *** w17t left
[19:35] <manwar> I am new to IRC. I find it hard to share codes here

[19:36] <irced> i don't know perl6 from adam but that sounds a lot like a constructor definition 

[19:36] *** `-_-`grumble is now known as grumble

[19:36] <discord6> <Rogue> manwar: you can send pastebin/github gist links if it's a long segment of code

[19:36] <hahainternet> i recommend gists, as they can be edited and commented upon

[19:37] <manwar> github gist would do, good idea

[19:37] <irced> maybe sub f($n1 $n2 where $n2 < $n1) { } as a constructor function

[19:37] <discord6> <Rogue> alternatively, I run a Discord guild if you'd like to join. Discord supports multi-line messages

[19:37] <discord6> <Rogue> Though remember to be courteous, because the channel is bridged and it will come out as one big blob on the IRC side

[19:38] <hahainternet> also then you have to support a closed source product

[19:38] <manwar> irced, I am not familiar with that syntax

[19:38] <irced> hmm

[19:38] <hahainternet> that is attempting to obsolete open source communication platforms

[19:38] <hahainternet> (don't use Slack either ;p)

[19:38] <sena_kun> m: class A { has $.a; has $.b; method TWEAK(:$!a!, :$!b!) { die "Too bad" unless $!a.chars > $!b.chars } }; say A.new(a => "abc", b => "ab");

[19:38] <camelia> rakudo-moar d6563816e: OUTPUT: «A.new(a => "abc", b => "ab")␤»

[19:39] <discord6> <Rogue> I greatly dislike Discord, but it's part of my initiative to get some new blood involved

[19:39] <sena_kun> m: class A { has $.a; has $.b; method TWEAK(:$!a!, :$!b!) { die "Too bad" unless $!a.chars > $!b.chars } }; say A.new(a => "abc", b => "abab");

[19:39] <camelia> rakudo-moar d6563816e: OUTPUT: «Too bad␤  in method TWEAK at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[19:39] <discord6> <Rogue> Ideally I would be running a Matrix server

[19:39] * irced scratches his chin, his skins peels exposing patches of red subepithelial tissue.

[19:39] <hahainternet> irced needs some steroids

[19:39] <manwar> sena_kun, you are too fast for me ;-)

[19:39] <hahainternet> and Rogue: we need mandatory federation for chat services :(

[19:39] <irced> i would settle for a bandaid

[19:39] <sena_kun> manwar, well, I was just thinking out loud. :)

[19:40] <hahainternet> irced: i've got one in my car :)

[19:40] <irced> m: sub f ($n1 $2 where $n2 < $n1) { put $n2 $n1 }

[19:40] <camelia> rakudo-moar d6563816e: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Malformed parameter␤at <tmp>:1␤------> 3sub f ($n17⏏5 $2 where $n2 < $n1) { put $n2 $n1 }␤    expecting any of:␤        constraint␤»

[19:40] <discord6> <Rogue> I've been considering making my own chat platform with p6

[19:40] <irced> m: sub f ($n1, $2 where $n2 < $n1) { put $n2 $n1 }

[19:40] <camelia> rakudo-moar d6563816e: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Cannot declare a numeric parameter␤at <tmp>:1␤------> 3sub f ($n1, $27⏏5 where $n2 < $n1) { put $n2 $n1 }␤»

[19:40] <irced> m: sub f ($n1, $n2 where $n2 < $n1) { put $n2 $n1 }

[19:40] <camelia> rakudo-moar d6563816e: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Two terms in a row␤at <tmp>:1␤------> 3b f ($n1, $n2 where $n2 < $n1) { put $n27⏏5 $n1 }␤    expecting any of:␤        infix␤        infix stopper␤        postfix␤        statement e…»

[19:41] <hahainternet> irced: you'll need to wrap the where block in a {}

[19:41] <hahainternet> i think it's normally done using a whatever, right?

[19:41] <hahainternet> Rogue: would be a good project, i'm most interested in what sort of standard would be needed

[19:41] <discord6> <Rogue> you need a comma between $n1 and $n2

[19:41] * irced draws his garrote from his coat pockets, tightens it between two fists, and eyes camelia with unusual interest.

[19:41] *** w17t joined
[19:41] * irced nods to hahainternet.

[19:42] * irced puts the wire back in his coat pocket.

[19:42] <irced> maybe sub f($n1, $n2 where $n2 < $n1) { } as a constructor function

[19:43] <irced> oops

[19:43] <discord6> <Rogue> hahainternet: it would be akin to IRC in the sense that you host your own server rather than relying on a centralized service, but I would want to support some of the attractive features Discord has as well

[19:43] * irced checks the wiring in his speech chip.

[19:43] * irced proclaims he is not an andy, and swears on a bible.

[19:43] <manwar> sena_kun, how about if the attributes are Int?

[19:43] * irced proceeds to open his skull.

[19:43] <hahainternet> Rogue: yeah, a federated service, the problem comes in that there's so many different variations, but none interoperate

[19:44] <hahainternet> i'd like to force them to interoperate by law :)

[19:44] <discord6> <Rogue> I'm not a GUI guy whatsoever, so I would only make the infrastructure

[19:44] <irced> m: sub f($n1 where $n1 >=0) { put $n1 }

[19:44] <camelia> rakudo-moar d6563816e: ( no output )

[19:44] <sena_kun> manwar, you need other method then. `.chars` is for getting a string length in chars. I think, for Int it'll be just your old `>` operator, no?

[19:44] <irced> m: sub f($n1 where $n1 >=0) { put $n1 }; f(-1); f(1);

[19:44] <camelia> rakudo-moar d6563816e: OUTPUT: «Constraint type check failed in binding to parameter '$n1'; expected anonymous constraint to be met but got Int (-1)␤  in sub f at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[19:44] <irced> m: sub f($n1 where $n1 >=0) { put $n1 }; f(1);

[19:44] <camelia> rakudo-moar d6563816e: OUTPUT: «1␤»

[19:45] <irced> m: sub f($n1, $n2 where $n2 >=0) { put $n1 $n2 }; f(1);

[19:45] <camelia> rakudo-moar d6563816e: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Two terms in a row␤at <tmp>:1␤------> 3sub f($n1, $n2 where $n2 >=0) { put $n17⏏5 $n2 }; f(1);␤    expecting any of:␤        infix␤        infix stopper␤        postfix␤        state…»

[19:45] <sena_kun> class A { has Int $.a; has Int $.b; method TWEAK(Int :$!a!, Int :$!b!) { die "Too bad" unless $!a > $!b } }; say A.new(a => 5, b => 10);

[19:45] <sena_kun> m: class A { has Int $.a; has Int $.b; method TWEAK(Int :$!a!, Int :$!b!) { die "Too bad" unless $!a > $!b } }; say A.new(a => 5, b => 10);

[19:45] <camelia> rakudo-moar d6563816e: OUTPUT: «Too bad␤  in method TWEAK at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[19:45] <sena_kun> m: class A { has Int $.a; has Int $.b; method TWEAK(Int :$!a!, Int :$!b!) { die "Too bad" unless $!a > $!b } }; say A.new(a => 5, b => 3);

[19:45] <camelia> rakudo-moar d6563816e: OUTPUT: «A.new(a => 5, b => 3)␤»

[19:46] * irced ignores sena_kun's solution and continues to work.

[19:46] <manwar> sena_kun, thanks TWEAK did the job

[19:46] <discord6> <kawaii> Are we not reinventing the wheel for the eighth time? XMPP is all of the things you want. (OSS, federated...)

[19:47] <discord6> <Rogue> I have a particular dislike for XML, personally

[19:47] <discord6> <Rogue> Plus it's just something I want to do from the ground up, because that's how I am

[19:48] *** ferreira left
[19:48] <hahainternet> XMPP is... substantial

[19:48] <hahainternet> there are improvements that can be made, but few users will be willing to adopt

[19:49] <irced> m: sub f($n1, $n2 where $n2 >=0) { put $n1 }; f(1);

[19:49] <camelia> rakudo-moar d6563816e: OUTPUT: «Too few positionals passed; expected 2 arguments but got 1␤  in sub f at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[19:49] <irced> m: sub f($n1, $n2 where $n2 >=0) { put $n1 }; f(1, 2);

[19:49] <camelia> rakudo-moar d6563816e: OUTPUT: «1␤»

[19:49] <hahainternet> there needs to be an encryption safe way to ephemerally map phone numbers to an ident too

[19:49] <irced> m: sub f($n1, $n2 where $n2 >=$n1) { put $n1 }; f(1, 2);

[19:49] <camelia> rakudo-moar d6563816e: OUTPUT: «1␤»

[19:49] <irced> m: sub f($n1, $n2 where $n2 >=$n1) { put $n1 }; f(1, 0);

[19:49] <camelia> rakudo-moar d6563816e: OUTPUT: «Constraint type check failed in binding to parameter '$n2'; expected anonymous constraint to be met but got Int (0)␤  in sub f at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[19:49] * irced exclaims, Eureka!

[19:49] <irced> manwar you see that?

[19:50] *** Kaiepi joined
[19:50] * irced 's arm recedes into his back.

[19:50] <irced> did you all see that?

[19:51] *** natrys left
[19:51] * hahainternet didn't see anything

[19:51] <hahainternet> you must be hallucinating

[19:51] <irced> what's that you say? quiet, i'm trying to listen to hahainternet.

[19:51] <manwar> irced, I am confused, is "f" class?

[19:52] <irced> no, and I'm not a PERL6 programmer! but if you could just manage to make sub f a constructor function you'll be golden

[19:52] <irced> any1?

[19:52] <manwar> Unfortunately I don't know how to

[19:52] <irced> help

[19:52] <irced> bots!

[19:53] <discord6> <Rogue> Chill

[19:53] * irced pays particular notice to discord6.

[19:54] * irced fumbles with something in his pocket.

[19:55] * irced looks around for affirmation.

[19:55] <sena_kun> m: class A { has $.a is required; has $.b is required; method new($n1, $n2 where $n2 >=$n1) { self.bless(a => $n1, b => $n2); } }; say A.new(1, 5); A.new(1, 0);

[19:55] <camelia> rakudo-moar d6563816e: OUTPUT: «A.new(a => 1, b => 5)␤Constraint type check failed in binding to parameter '$n2'; expected anonymous constraint to be met but got Int (0)␤  in method new at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[19:55] * irced ignores sena_kun's brilliant solution.

[19:56] <manwar> irced, I can follow your code now, thanks. Let me try.

[19:57] * irced grins evilly as sena_kun's work is dismissed by manwar.

[19:59] <irced> m: class B { method new($n1, $n2 where $n2 >= $n1) { A.new(1,5) };

[19:59] <camelia> rakudo-moar d6563816e: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Missing block␤at <tmp>:1␤------> 031, $n2 where $n2 >= $n1) { A.new(1,5) };7⏏5<EOL>␤»

[19:59] <irced> m: class B { method new($n1, $n2 where $n2 >= $n1) { A.new(1,5) }};

[19:59] <camelia> rakudo-moar d6563816e: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Undeclared name:␤    A used at line 1␤␤»

[19:59] <irced> m: class B { method new($n1, $n2 where $n2 >= $n1) { B.new(1,5) }};

[19:59] <camelia> rakudo-moar d6563816e: ( no output )

[20:00] <irced> m: class B { method new($n1, $n2 where $n2 >= $n1) { say 'good to go' } }; B.new(1,5);

[20:00] <camelia> rakudo-moar d6563816e: OUTPUT: «good to go␤»

[20:00] <irced> m: class B { method new($n1, $n2 where $n2 >= $n1) { say 'good to go' } }; B.new(5,1);

[20:00] <camelia> rakudo-moar d6563816e: OUTPUT: «Constraint type check failed in binding to parameter '$n2'; expected anonymous constraint to be met but got Int (1)␤  in method new at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[20:00] <irced> manwar, you catch that?

[20:01] * irced fishes out his pet man-o-war from his aquarium to throw on sena_kun's head.

[20:02] <irced> did you all see that?

[20:03] <manwar> irced: Too few positionals passed; expected 3 arguments but got 1

[20:03] <irced> m: class B { method new($n1, $n2 where $n2 >= $n1) { say 'good to go' } }; B.new(5,1);

[20:03] <camelia> rakudo-moar d6563816e: OUTPUT: «Constraint type check failed in binding to parameter '$n2'; expected anonymous constraint to be met but got Int (1)␤  in method new at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[20:03] <irced> m: class B { method new($n1, $n2 where $n2 >= $n1) { say 'good to go' } }; B.new(1,5);

[20:03] <camelia> rakudo-moar d6563816e: OUTPUT: «good to go␤»

[20:04] <irced> are you challenging camelia?

[20:04] <irced> that's good, she's a strumpet anyway

[20:04] * irced leers at camelia.

[20:05] <manwar> I dare not

[20:05] <irced> i dunno, i thought i made a class and a constructor there.. but you say no. maybe sena_kun can help.

[20:05] <irced> sena_kun, can you give us something like a page long this time

[20:06] *** kylese left
[20:07] <irced> i think he's working on it

[20:07] <irced> s/he's

[20:07] <sena_kun> you likely want to read https://docs.perl6.org/language/classtut

[20:07] * irced feels schooled.

[20:07] <irced> right

[20:07] *** jmerelo left
[20:08] <manwar> I am exactly reading the same page

[20:19] <irced> m: class dumbCamelia { has $n1; has $n2; method new($n1, $n2 where $n2 > $n1) { return self.bless(:$n1, :$n2); } submethod BUILD(:$n1, :$n2) {} }

[20:19] <camelia> rakudo-moar d6563816e: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Strange text after block (missing semicolon or comma?)␤at <tmp>:1␤------> 3 $n1) { return self.bless(:$n1, :$n2); }7⏏5 submethod BUILD(:$n1, :$n2) {} }␤    expecting any of:␤        infix…»

[20:21] <irced> m: class dumbCamelia { has $n1; has $n2; method new($n1, $n2 where $n2 >= $n1) { return self.bless(:$n1, :$n2); }; submethod BUILD(:$n1, :$n2) {} }

[20:21] <camelia> rakudo-moar d6563816e: ( no output )

[20:22] <irced> m: class dumbCamelia { has $n1; has $n2; method new($n1, $n2 where $n2 >= $n1) { return self.bless(:$n1, :$n2); }; submethod BUILD(:$n1, :$n2) {} }; my cammie = dumbCamelia.new(1,5);

[20:22] <camelia> rakudo-moar d6563816e: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Malformed my (did you mean to declare a sigilless \cammie or $cammie?)␤at <tmp>:1␤------> 3method BUILD(:$n1, :$n2) {} }; my cammie7⏏5 = dumbCamelia.new(1,5);␤»

[20:22] <irced> m: class dumbCamelia { has $n1; has $n2; method new($n1, $n2 where $n2 >= $n1) { return self.bless(:$n1, :$n2); }; submethod BUILD(:$n1, :$n2) {} }; my $cammie = dumbCamelia.new(1,5);

[20:22] <camelia> rakudo-moar d6563816e: ( no output )

[20:22] *** dant joined
[20:22] <irced> m: class dumbCamelia { has $n1; has $n2; method new($n1, $n2 where $n2 >= $n1) { return self.bless(:$n1, :$n2); }; submethod BUILD(:$n1, :$n2) {} }; my $cammie = dumbCamelia.new(5,1);

[20:22] <camelia> rakudo-moar d6563816e: OUTPUT: «Constraint type check failed in binding to parameter '$n2'; expected anonymous constraint to be met but got Int (1)␤  in method new at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[20:22] * irced does his own special hero dance and manages to keep his pants up.

[20:22] <irced> manwar, you see that?

[20:23] <irced> did you all see that?

[20:24] * irced explains to camelia that andy's don't have rights.

[20:24] <vrurg> irced: are your attributes lack dot in the declaration on purpose?

[20:24] <irced> camelia: what do I look like, the Abe Lincoln for andys????? tell it on the mountain.

[20:25] <irced> yeah, what's the dot for anyway?

[20:25] <vrurg> irced: basically, it has to be 'has $.n1'

[20:25] <discord6> <Rogue> the dot twigil generates a method to access that field

[20:26] <discord6> <Rogue> if you want it to be private, you'd use an !

[20:26] <irced> m: class dumbCamelia { has $n1; has $n2; method new($n1, $n2 where $n2 >= $n1) { return self.bless(:$n1, :$n2); }; submethod BUILD(:$n1, :$n2) {} }; my $cammie = dumbCamelia.new(1,5); put "$cammie.n1"

[20:26] <camelia> rakudo-moar d6563816e: OUTPUT: «dumbCamelia<78828560>.n1␤»

[20:27] <irced> m: class dumbCamelia { has $n1; has $n2; method new($n1, $n2 where $n2 >= $n1) { return self.bless(:$.n1, :$.n2); }; submethod BUILD(:$.n1, :$.n2) {} }; my $cammie = dumbCamelia.new(1,5); put "$cammie.n1"

[20:27] <camelia> rakudo-moar d6563816e: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Virtual method call $.n1 may not be used on partially constructed object (maybe you mean $!n1 for direct attribute access here?)␤at <tmp>:1␤------> 3(:$.n1, :$.n2); }; submethod BUILD(:$.n17⏏5,…»

[20:27] <irced> m: class dumbCamelia { has Int $n1; has Int $n2; method new($n1, $n2 where $n2 >= $n1) { return self.bless(:$.n1, :$.n2); }; submethod BUILD(:$.n1, :$.n2) {} }; my $cammie = dumbCamelia.new(1,5); put "$cammie.n1"

[20:27] <camelia> rakudo-moar d6563816e: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Virtual method call $.n1 may not be used on partially constructed object (maybe you mean $!n1 for direct attribute access here?)␤at <tmp>:1␤------> 3(:$.n1, :$.n2); }; submethod BUILD(:$.n17⏏5,…»

[20:28] <irced> m: class dumbCamelia { has $n1; has $n2; method new($n1, $n2 where $n2 >= $n1) { return self.bless(:$.n1, :$.n2); }; submethod BUILD(:$.n1, :$.n2) {} }; my $cammie = dumbCamelia.new(1,5);

[20:28] <camelia> rakudo-moar d6563816e: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Virtual method call $.n1 may not be used on partially constructed object (maybe you mean $!n1 for direct attribute access here?)␤at <tmp>:1␤------> 3(:$.n1, :$.n2); }; submethod BUILD(:$.n17⏏5,…»

[20:28] <vrurg> irced: because accessors are not yet available to construction submethods. use direct attribute access with $!

[20:28] <irced> m: class dumbCamelia { has $.n1; has $.n2; method new($n1, $n2 where $n2 >= $n1) { return self.bless(:$.n1, :$.n2); }; submethod BUILD(:$.n1, :$.n2) {} }; my $cammie = dumbCamelia.new(1,5);

[20:28] <camelia> rakudo-moar d6563816e: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Virtual method call $.n1 may not be used on partially constructed object (maybe you mean $!n1 for direct attribute access here?)␤at <tmp>:1␤------> 3(:$.n1, :$.n2); }; submethod BUILD(:$.n17⏏5,…»

[20:29] <lucasb> almost there :)

[20:29] <irced> m: class dumbCamelia { has $.n1; has $.n2; method new($.n1, $.n2 where $.n2 >= $.n1) { return self.bless(:$.n1, :$.n2); }; submethod BUILD(:$.n1, :$.n2) {} }; my $cammie = dumbCamelia.new(1,5);

[20:29] <camelia> rakudo-moar d6563816e: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Virtual method call $.n1 may not be used on partially constructed object (maybe you mean $!n1 for direct attribute access here?)␤at <tmp>:1␤------> 3(:$.n1, :$.n2); }; submethod BUILD(:$.n17⏏5,…»

[20:29] <irced> m: class dumbCamelia { has $.n1; has $.n2; method new($.n1, $.n2 where $.n2 >= $.n1) { return self.bless(:$.n1, :$.n2); }; submethod BUILD(:$!.n1, :$!.n2) {} }; my $cammie = dumbCamelia.new(1,5);

[20:29] <camelia> rakudo-moar d6563816e: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Malformed parameter␤at <tmp>:1␤------> 3ss(:$.n1, :$.n2); }; submethod BUILD(:$!7⏏5.n1, :$!.n2) {} }; my $cammie = dumbCame␤    expecting any of:␤        constraint␤»

[20:30] <lucasb> P6 doesn't has thrigils

[20:31] <irced> m: class dumbCamelia { has $.n1; has $.n2; method new($n1, $n2 where $n2 >= $n1) { return self.bless(:$.n1, :$.n2); }; submethod BUILD(:$!.n1, :$!.n2) {} }; my $cammie = dumbCamelia.new(1,5);

[20:31] <camelia> rakudo-moar d6563816e: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Malformed parameter␤at <tmp>:1␤------> 3ss(:$.n1, :$.n2); }; submethod BUILD(:$!7⏏5.n1, :$!.n2) {} }; my $cammie = dumbCame␤    expecting any of:␤        constraint␤»

[20:31] <irced> m: class dumbCamelia { has $.n1; has $.n2; method new($n1, $n2 where $n2 >= $n1) { return self.bless(:$n1, :$n2); }; submethod BUILD(:$!.n1, :$!.n2) {} }; my $cammie = dumbCamelia.new(1,5);

[20:31] <camelia> rakudo-moar d6563816e: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Malformed parameter␤at <tmp>:1␤------> 3less(:$n1, :$n2); }; submethod BUILD(:$!7⏏5.n1, :$!.n2) {} }; my $cammie = dumbCame␤    expecting any of:␤        constraint␤»

[20:32] <irced> m: class dumbCamelia { has $.n1; has $.n2; method new($n1, $n2 where $n2 >= $n1) { return self.bless(:$.n1, :$.n2); }; submethod BUILD(:$!n1, :$!n2) {} }; my $cammie = dumbCamelia.new(1,5);

[20:32] <camelia> rakudo-moar d6563816e: OUTPUT: «Cannot look up attributes in a dumbCamelia type object␤  in method n1 at <tmp> line 1␤  in method new at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[20:33] <irced> m: class dumbCamelia { has $.n1; has $.n2; method new($n1, $n2 where $n2 >= $n1) { return self.bless(:$!n1, :$!n2); }; submethod BUILD(:$!n1, :$!n2) {} }; my $cammie = dumbCamelia.new(1,5);

[20:33] <camelia> rakudo-moar d6563816e: OUTPUT: «Cannot look up attributes in a dumbCamelia type object␤  in method new at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[20:33] <irced> m: class dumbCamelia { has $.n1; has $.n2; method new($n1, $n2 where $n2 >= $n1) { return self.bless(:$!n1, :$!n2); }; submethod BUILD(:$.n1, :$.n2) {} }; my $cammie = dumbCamelia.new(1,5);

[20:33] <camelia> rakudo-moar d6563816e: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Virtual method call $.n1 may not be used on partially constructed object (maybe you mean $!n1 for direct attribute access here?)␤at <tmp>:1␤------> 3(:$!n1, :$!n2); }; submethod BUILD(:$.n17⏏5,…»

[20:34] <irced> m: class dumbCamelia { has $.n1; has $.n2; method new($n1, $n2 where $n2 >= $n1) { return self.bless(:$!n1, :$!n2); }; submethod BUILD(:$!n1, :$!n2) {} }; my $cammie = dumbCamelia.new(1,5);

[20:34] <camelia> rakudo-moar d6563816e: OUTPUT: «Cannot look up attributes in a dumbCamelia type object␤  in method new at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[20:34] <irced> m: class dumbCamelia { has $.n1; has $.n2; method new($.n1, $.n2 where $.n2 >= $.n1) { return self.bless(:$!n1, :$!n2); }; submethod BUILD(:$!n1, :$!n2) {} }; my $cammie = dumbCamelia.new(1,5);

[20:34] <camelia> rakudo-moar d6563816e: OUTPUT: «Cannot look up attributes in a dumbCamelia type object␤  in method n1 at <tmp> line 1␤  in method new at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[20:35] <irced> m: class dumbCamelia { has $.n1; has $.n2; method new($!n1, $!n2 where $!n2 >= $!n1) { return self.bless(:$!n1, :$!n2); }; submethod BUILD(:$!n1, :$!n2) {} }; my $cammie = dumbCamelia.new(1,5);

[20:35] <camelia> rakudo-moar d6563816e: OUTPUT: «Cannot look up attributes in a dumbCamelia type object␤  in method new at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[20:35] <irced> m: class dumbCamelia { has $n1; has $n2; method new($n1, $n2 where $n2 >= $n1) { return self.bless(:$n1, :$n2); }; submethod BUILD(:$n1, :$n2) {} }; my $cammie = dumbCamelia.new(1,5);

[20:35] <camelia> rakudo-moar d6563816e: ( no output )

[20:35] * irced scratches his head.

[20:35] * irced has decided dot notation is a bug.

[20:36] * irced puts his hand in his coat from which a fly swatter emerges.

[20:37] <dant> '"a \"b\" \"c\""' ~~ regex { ^ \" (.*) <!before \\> \" $ }

[20:37] <dant> p6: '"a \"b\" \"c\""' ~~ regex { ^ \" (.*) <!before \\> \" $ }

[20:37] <camelia> rakudo-moar d6563816e: ( no output )

[20:37] <dant> p6: say 3;

[20:37] <camelia> rakudo-moar d6563816e: OUTPUT: «3␤»

[20:39] * irced begins swatting camelia repeatedly.

[20:40] *** manwar left
[20:41] * irced unremittingly swats camelia, despite her plaintive protests.

[20:41] <irced> you've got bugs! i'm trying to help you! stay still!

[20:43] <dant> Is there a canonical regex for matching quoted strings with escapes? The best I can come up with is   rx { \" (.*) <!before \\> \" } .

[20:46] *** zacts left
[20:49] *** guifa left
[20:51] *** kst` joined
[20:52] *** kst left
[20:54] *** zachk joined
[20:56] *** zachk left
[20:56] *** zachk joined
[21:04] *** Aceeri__ left
[21:17] *** molaf joined
[21:23] *** cfa left
[21:27] <sena_kun> dant, I don't think there is a "canonical" one.

[21:28] <sena_kun> but you can look at https://modules.perl6.org/dist/JSON::Tiny:cpan:MORITZ/lib/JSON/Tiny/Grammar.pm#L25

[21:29] <dant> sena_kun: thanks for the suggestion ... very helpful

[21:30] <irced> p6: '"a \"b\" \"c\""' ~~ regex { ^ <quoted> (.*) <!before \\> <quoted> $ }

[21:30] <camelia> rakudo-moar d6563816e: OUTPUT: «No such method 'quoted' for invocant of type 'Match'␤  in regex  at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[21:31] <irced> p6: '"a \"b\" \"c\""' ~~ regex { ^ <"(.*) <!before \\>"> $ }

[21:31] <camelia> rakudo-moar d6563816e: OUTPUT: «5===SORRY!5===␤Unrecognized regex metacharacter < (must be quoted to match literally)␤at <tmp>:1␤------> 3'"a \"b\" \"c\""' ~~ regex { ^ <7⏏5"(.*) <!before \\>"> $ }␤Malformed regex␤at <tmp>:1␤------> 3'"a \"b\" \"c\""' ~~ regex…»

[21:32] <irced> p6: '"a \"b\" \"c\""' ~~ regex { <^ "(.*) <!before \\>"> $ }

[21:32] <camelia> rakudo-moar d6563816e: OUTPUT: «5===SORRY!5===␤Unrecognized regex metacharacter < (must be quoted to match literally)␤at <tmp>:1␤------> 3'"a \"b\" \"c\""' ~~ regex { <7⏏5^ "(.*) <!before \\>"> $ }␤Unrecognized regex metacharacter ^ (must be quoted to match literal…»

[21:35] *** autark left
[21:51] *** sena_kun left
[21:58] *** choiboi left
[22:00] *** ferreira joined
[22:09] <moritz> dant: the common approach is to parse the insides of a quote string as ``neither \ nor "`` or either \\ or \"

[22:10] <moritz> in code, \" ~ \" [[ <-["\\]>+ | \\ <["\\]> ]*]

[22:10] <moritz> (untested)

[22:11] *** rindolf left
[22:27] *** dominix__ joined
[22:31] *** dominix_ left
[22:39] *** kkielak joined
[22:54] *** lucasb left
[23:00] *** kkielak left
[23:04] *** john_parr_ joined
[23:05] *** john_parr left
[23:05] *** john_parr_ is now known as john_parr

[23:07] *** Kaiepi left
[23:19] *** kurahaupo left
[23:19] *** kurahaupo joined
[23:31] <dant> moritz: The "~" feature is perfect. Very clever, but required RTFM. Thanks 

[23:32] *** kurahaupo left
[23:32] *** kurahaupo joined
[23:32] *** kurahaupo left
[23:33] *** kurahaupo joined
[23:39] *** manchicken joined
[23:40] *** zacts joined
[23:41] *** Gothmog_ left
[23:48] *** manchicken left
[23:51] *** kurahaupo left
[23:52] *** kurahaupo joined
[23:52] *** manchicken joined
[23:59] *** manchicken left
