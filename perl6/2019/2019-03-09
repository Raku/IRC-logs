[00:01] *** vike left
[00:05] *** cpan-p6 left
[00:05] *** cpan-p6 joined
[00:12] *** SergiusUA left
[00:14] *** vike joined
[00:16] *** drclaw joined
[00:22] *** vike left
[00:25] *** pecastro left
[00:28] *** cpan-p6 left
[00:28] *** irced joined
[00:29] *** cpan-p6 joined
[00:31] <irced> sooo like any self-respecting *nixer, I am learning BASH scripting. but, what opinions do you all have of BASH vs perl6? what thoughts do you all have on perl6 replacing BASH and variants? I know, that pesky jvm! but still.

[00:32] <irced> in the context of treating perl6 as a "glue" language and doing things the unix way. (process piping)

[00:33] <timotimo> i'm not sure what you mean by "that pesky jvm"?

[00:33] * irced turns red in the face.

[00:34] * irced starts chewing on his foot.

[00:34] * irced muffles something incomprehensible.

[00:36] <timotimo> i mean, perl6 is pretty good for putting stuff together from different processes, and it has a bunch of stuff built-in that can do what many unix tools do easily, as well

[00:36] * irced mumbles more and finally removes his foot from his mouth.

[00:36] *** zacts left
[00:37] *** zacts joined
[00:38] <irced> good points, timotimo, thanks.

[00:41] *** zacts left
[00:47] <irced> well, looking at native call and IO::Handle, I'm beginning to think different-ly

[00:48] <irced> render things unto BASH that are BASH, and things that are perl6 unto perl6 and who needs BASH anyway :-p

[00:48] <irced> provided you're a c/unix programmer

[00:49] *** |oLa| left
[00:49] * irced waits for his epiphany to be appreciated.

[00:50] * irced climbs a tree.

[00:50] * irced strings a hammock.

[00:52] *** cpan-p6 left
[00:52] *** cpan-p6 joined
[00:55] *** w_richard_w joined
[00:56] *** vike joined
[00:56] <timotimo> sorry, a bit distracted by the C code in front of me

[00:59] <timotimo> at least i remember now what i was doing before i got sidetracked by a bug that wasn't actually there any more

[01:07] *** cpan-p6 left
[01:08] *** cpan-p6 joined
[01:08] * irced climbs down.

[01:09] *** rindolf left
[01:09] <irced> hablo C. any questions?

[01:09] * irced looks around for the perl6 police.

[01:17] *** zachk left
[01:19] *** epony joined
[01:22] *** cpan-p6 left
[01:23] *** cpan-p6 joined
[01:45] <irced> that is, what have you got that you might like some input/feedback on?

[01:46] *** cpan-p6 left
[01:46] <Seance[m]> Been tooling around with Comma Community

[01:47] <Seance[m]> Beats the hell out of atom + p6 packages

[01:47] <Seance[m]> (:

[01:47] *** cpan-p6 joined
[01:48] <irced> I'm holding out for semicolon

[01:49] <irced> Semicolon is slated for release next after the CE

[01:53] <timotimo> irced: no worries, i had been installing my modified moar to a different folder from the one i was running, so my changes weren't being hit and it made no sense to me at all

[01:55] <irced> timotimo: stupid computers!

[01:56] <timotimo> no, stupid timo

[01:56] *** w_richard_w left
[01:56] <timotimo> i didn't look at what i was getting from my commandline history

[01:56] <irced> I stand by my statement!

[02:06] *** molaf left
[02:09] *** cpan-p6 left
[02:10] *** cpan-p6 joined
[02:15] <Seance[m]> <freenode_irc "I'm holding out for semicolon"> What's got you holding out?

[02:19] *** molaf joined
[02:20] *** drclaw left
[02:23] *** SCHAPiE left
[02:28] *** cpan-p6 left
[02:37] *** SCHAPiE joined
[02:41] *** zacts joined
[02:53] *** drclaw joined
[02:54] *** vike left
[02:58] *** vike joined
[03:03] *** mowcat joined
[03:05] *** cpan-p6 joined
[03:18] <Xliff> m: my @a = ^100; for @a.rotor(5) -> $a { $a.hyper.map( .say ) }

[03:18] <camelia> rakudo-moar 70d61b214: OUTPUT: «(Any)␤Cannot resolve caller map(Rakudo::Internals::HyperRaceSharedImpl:U: HyperSeq:D, Rakudo::Internals::HyperIteratorBatcher:D, Bool:D, Hash:D); none of these signatures match:␤    ($: Hash \h, *%_)␤    (\SELF: &block;; :$label, :$item, *%_)␤…»

[03:19] <Xliff> m: my @a = ^100; for @a.rotor(5) -> $a { $a.hyper( degree => 4 ).map( .say ) }

[03:19] <camelia> rakudo-moar 70d61b214: OUTPUT: «(Any)␤Cannot resolve caller map(Rakudo::Internals::HyperRaceSharedImpl:U: HyperSeq:D, Rakudo::Internals::HyperIteratorBatcher:D, Bool:D, Hash:D); none of these signatures match:␤    ($: Hash \h, *%_)␤    (\SELF: &block;; :$label, :$item, *%_)␤…»

[03:19] <Xliff> m: my @a = ^100; for @a.rotor(5) -> $a { $a.hyper( degree => 4 ).map( *.say ) }

[03:19] <camelia> rakudo-moar 70d61b214: OUTPUT: «0␤1␤2␤3␤4␤5␤6␤7␤8␤9␤10␤11␤12␤13␤14␤15␤16␤17␤18␤19␤20␤21␤22␤23␤24␤25␤26␤27␤28␤29␤30␤31␤32␤33␤34␤35␤36␤37␤38␤39␤40␤41␤42␤43␤44␤45␤46␤47␤48␤49␤50␤51␤5…»

[03:19] *** cpan-p6 left
[03:19] <Xliff> m: my @a = ^100; for @a.rotor(5) -> $a { $a.hyper( degree => 4 ).map({ .say }) }

[03:19] <camelia> rakudo-moar 70d61b214: OUTPUT: «0␤1␤2␤3␤4␤5␤6␤7␤8␤9␤10␤11␤12␤13␤14␤15␤16␤17␤18␤19␤20␤21␤22␤23␤24␤25␤26␤27␤28␤29␤30␤31␤32␤33␤34␤35␤36␤37␤38␤39␤40␤41␤42␤43␤44␤45␤46␤47␤48␤49␤50␤51␤5…»

[03:19] *** cpan-p6 joined
[03:21] <Xliff> m: constant BATCH = 4; my @a = ^100; for @a.rotor(5) -> $a { $a.hyper( degree => BATCH ).map({ .say }) }

[03:21] <camelia> rakudo-moar 70d61b214: OUTPUT: «0␤1␤2␤3␤4␤5␤6␤7␤8␤9␤10␤11␤12␤13␤14␤15␤16␤17␤18␤19␤20␤21␤22␤23␤24␤25␤26␤27␤28␤29␤30␤31␤32␤33␤34␤35␤36␤37␤38␤39␤40␤41␤42␤43␤44␤45␤46␤47␤48␤49␤50␤51␤5…»

[03:27] *** drclaw left
[03:29] <irced> Seance[m], I dunno, I was super optimistic about exclamation point but all it and myself spewed were expletives.

[03:39] <Geth> ¦ doc: 33238e3ce7 | cfa++ | 4 files

[03:39] <Geth> ¦ doc: Remove .html from internal doc links.

[03:39] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/33238e3ce7

[03:43] *** cpan-p6 left
[03:43] *** cpan-p6 joined
[04:07] *** cpan-p6 left
[04:07] *** cpan-p6 joined
[04:11] *** netrino left
[04:13] *** zacts left
[04:27] *** cpan-p6 left
[04:29] *** zacts joined
[04:41] *** zacts left
[04:48] <Kaiepi> i have a binary that has a multi sub MAIN() and a multi sub main(Str $host!, Int $port!, Str $serverid!). why doesn't it include the usage of the binary without any arguments in the help message it shows if you use it wrong?

[04:49] <Kaiepi> s/multi sub main/multi sub MAIN/

[04:55] *** Cabanoss- joined
[04:57] *** Cabanossi left
[05:04] *** zacts joined
[05:11] *** cpan-p6 joined
[05:14] *** mowcat left
[05:14] <Xliff> Kaiepi: I don't know if USAGE generation is supported for multi MAINS

[05:15] <Xliff> s/MAINS/MAINs

[05:15] <Xliff> You get what I mean.

[05:15] <Kaiepi> oh

[05:15] <Xliff> Keyphrase there being "I don't know"

[05:16] <Xliff> But it's FRY-day. I have no life. And I am sitting here doing what most people do on FRY-day nights.

[05:18] <Xliff> Has anyone thought about adding module dependency generation into CURI so precompiling can go faster?

[05:20] <irced> I wish it was a FRY day, sigh, but I can dream. In fact, that's what I'll do.

[05:20] * irced zzzZZzzzZZzzz

[05:21] *** irced left
[05:23] *** drclaw joined
[05:28] *** [particle]1 joined
[05:31] *** [particle] left
[05:35] *** cpan-p6 left
[05:36] *** cpan-p6 joined
[05:44] *** zacts left
[05:48] <Kaiepi> i helped get perl6 to 1k questions on stack overflow https://stackoverflow.com/questions/55072228/creating-a-maybe-type-in-perl-6

[05:48] <Kaiepi> just 6 more to go!

[05:56] *** zacts joined
[05:57] <cpan-p6> New module released to CPAN! Random-Choice (0.0.3) by 03TITSUKI

[05:59] *** cpan-p6 left
[06:00] *** cpan-p6 joined
[06:04] *** Sgeo_ joined
[06:05] <Xliff> Kaiepi: Just off of the cuff, you might want to override STORE and just die unless the assigned value is (T, Failure).any

[06:06] <Xliff> m: role Maybe[::T] { sub STORE(\v) { self = v unless (T, Failure).any }; sub foo(--> Int) { rand < 0.5 ?? 1 !! fail 'oops' }; my Maybe[Int] $foo = foo;

[06:06] <camelia> rakudo-moar 70d61b214: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤'self' used where no object is available␤at <tmp>:1␤------> 3role Maybe[::T] { sub STORE(\v) {7⏏5 self = v unless (T, Failure).any }; sub␤    expecting any of:␤        term␤»

[06:06] <Xliff> m: role Maybe[::T] { method STORE(\v) { self = v unless (T, Failure).any }; sub foo(--> Int) { rand < 0.5 ?? 1 !! fail 'oops' }; my Maybe[Int] $foo = foo;

[06:06] <camelia> rakudo-moar 70d61b214: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Missing block␤at <tmp>:1␤------> 3fail 'oops' }; my Maybe[Int] $foo = foo;7⏏5<EOL>␤»

[06:06] <Xliff> m: role Maybe[::T] { method STORE(\v) { self = v unless (T, Failure).any }; sub foo(--> Int) { rand < 0.5 ?? 1 !! fail 'oops' }; my Maybe[Int] $foo = foo();

[06:06] <camelia> rakudo-moar 70d61b214: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Missing block␤at <tmp>:1␤------> 3il 'oops' }; my Maybe[Int] $foo = foo();7⏏5<EOL>␤»

[06:06] *** MidCheck joined
[06:06] <Xliff> m: role Maybe[::T] { method STORE(\v) { self = v unless (::T, Failure).any }; sub foo(--> Int) { rand < 0.5 ?? 1 !! fail 'oops' }; my Maybe[Int] $foo = foo();

[06:06] <camelia> rakudo-moar 70d61b214: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Missing block␤at <tmp>:1␤------> 3il 'oops' }; my Maybe[Int] $foo = foo();7⏏5<EOL>␤»

[06:07] <Xliff> Something like that. I am missing something, too.

[06:07] <Xliff> m: role Maybe[::T] { method STORE(\v) { self = v unless (::T, Failure).any }; }; sub foo(--> Int) { rand < 0.5 ?? 1 !! fail 'oops' }; my Maybe[Int] $foo = foo();

[06:07] <camelia> rakudo-moar 70d61b214: OUTPUT: «Type check failed in assignment to $foo; expected Maybe[Int] but got Int (1)␤  in block <unit> at <tmp> line 1␤␤»

[06:07] <Xliff> m: role Maybe[::T] { method STORE(\v) { self = v unless (T, Failure).any }; }; sub foo(--> Int) { rand < 0.5 ?? 1 !! fail 'oops' }; my Maybe[Int] $foo = foo();

[06:07] <camelia> rakudo-moar 70d61b214: OUTPUT: «Earlier failure:␤ (HANDLED) oops␤  in sub foo at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤Final error:␤ Type check failed in assignment to $foo; expected Maybe[Int] but got Failure (&CORE::infix:<orelse>...)␤  in block <unit> at <…»

[06:07] *** Sgeo left
[06:08] <Xliff> m: role Maybe[::T] { method STORE(\v) { self = v unless v ~~ (T, Failure).any }; }; sub foo(--> Int) { rand < 0.5 ?? 1 !! fail 'oops' }; my Maybe[Int] $foo = foo();

[06:08] <camelia> rakudo-moar 70d61b214: OUTPUT: «Earlier failure:␤ (HANDLED) oops␤  in sub foo at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤Final error:␤ Type check failed in assignment to $foo; expected Maybe[Int] but got Failure (&CORE::infix:<orelse>...)␤  in block <unit> at <…»

[06:08] <Xliff> m: role Maybe[::T] { method STORE(\v) { self = v unless v ~~ (T, Failure).any }; }; sub foo(--> Int) { rand < 0.5 ?? 1 !! fail 'oops' }; my Maybe[Int] $foo = foo();

[06:08] <camelia> rakudo-moar 70d61b214: OUTPUT: «Earlier failure:␤ (HANDLED) oops␤  in sub foo at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤Final error:␤ Type check failed in assignment to $foo; expected Maybe[Int] but got Failure (&CORE::infix:<orelse>...)␤  in block <unit> at <…»

[06:08] <Xliff> m: role Maybe[::T] { method STORE(\v) { self = v unless v ~~ (T, Failure).any }; }; sub foo(--> Int) { rand < 0.5 ?? 1 !! fail 'oops' }; my Maybe[Int] $foo = foo();

[06:08] <camelia> rakudo-moar 70d61b214: OUTPUT: «Earlier failure:␤ (HANDLED) oops␤  in sub foo at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤Final error:␤ Type check failed in assignment to $foo; expected Maybe[Int] but got Failure (&CORE::infix:<orelse>...)␤  in block <unit> at <…»

[06:08] <Xliff> m: role Maybe[::T] { method STORE(\v) { self = v unless v ~~ (T, Failure).any }; }; sub foo(--> Int) { 1 }; my Maybe[Int] $foo = foo();

[06:08] <camelia> rakudo-moar 70d61b214: OUTPUT: «Type check failed in assignment to $foo; expected Maybe[Int] but got Int (1)␤  in block <unit> at <tmp> line 1␤␤»

[06:08] <Xliff> Hmmm...

[06:10] <Kaiepi> m: role Maybe[::T] { method STORE(\v) is raw { state $subset = my subset Maybe of Mu where T | Failure; return-rw Proxy.new: FETCH => -> { $subset }, STORE => -> $ { die }; } }; my Maybe[Int] $foo = 1

[06:10] <camelia> rakudo-moar 70d61b214: OUTPUT: «Type check failed in assignment to $foo; expected Maybe[Int] but got Int (1)␤  in block <unit> at <tmp> line 1␤␤»

[06:11] *** ayerhart left
[06:12] <Kaiepi> oh wait that's not even what STORE does

[06:12] <cpan-p6> New module released to CPAN! Random-Choice (0.0.4) by 03TITSUKI

[06:13] <Kaiepi> m: role Maybe[::T] { method ACCEPTS(::?ROLE:D: Mu \v) { v ~~ T | Failure } }; my Maybe[Int] $foo = 1

[06:13] <camelia> rakudo-moar 70d61b214: OUTPUT: «Type check failed in assignment to $foo; expected Maybe[Int] but got Int (1)␤  in block <unit> at <tmp> line 1␤␤»

[06:13] <Kaiepi> m: role Maybe[::T] { method ACCEPTS(::?ROLE:D: Mu \v) { v ~~ T | Failure } }; 1 ~~ Maybe[Int]

[06:13] <camelia> rakudo-moar 70d61b214: ( no output )

[06:13] <Kaiepi> m: role Maybe[::T] { method ACCEPTS(::?ROLE:D: Mu \v) { v ~~ T | Failure } }; say 1 ~~ Maybe[Int]

[06:13] <camelia> rakudo-moar 70d61b214: OUTPUT: «False␤»

[06:15] *** telex left
[06:16] *** telex joined
[06:22] <Xliff> Aand... I think we killed camelia.

[06:22] <Xliff> m: 1.say

[06:22] <camelia> rakudo-moar 70d61b214: OUTPUT: «1␤»

[06:22] <Xliff> Oh. NVM

[06:22] *** cpan-p6 left
[06:23] *** cpan-p6 joined
[06:24] <Xliff> ¯\_(ツ)_/¯

[06:34] *** reach_satori joined
[06:37] *** cpan-p6 left
[06:38] *** cpan-p6 joined
[06:47] *** daxim left
[06:53] *** daxim joined
[06:58] <Xliff> Does .hyper work with Lists?

[07:01] *** cpan-p6 left
[07:01] *** cpan-p6 joined
[07:01] <cpan-p6> New module released to CPAN! Random-Choice (0.0.5) by 03TITSUKI

[07:03] <Xliff> m: my $b = ^6; $b».map( *.say )

[07:03] <camelia> rakudo-moar 70d61b214: ( no output )

[07:03] *** drclaw left
[07:04] <Xliff> m: my $b = ^6; $b.»map( *.say )

[07:04] <camelia> rakudo-moar 70d61b214: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Missing dot on method call␤at <tmp>:1␤------> 3my $b = ^6; $b.»7⏏5map( *.say )␤    expecting any of:␤        postfix␤»

[07:04] <Xliff> m: my $b = ^6; say $b.gist; $b.map( *.say )

[07:04] <camelia> rakudo-moar 70d61b214: OUTPUT: «^6␤0␤1␤2␤3␤4␤5␤»

[07:04] <Xliff> m: my $b = ^6.list; $b.map( *.say )

[07:04] <camelia> rakudo-moar 70d61b214: OUTPUT: «Potential difficulties:␤    Precedence of ^ is looser than method call; please parenthesize␤    at <tmp>:1␤    ------> 3my $b = ^67⏏5.list; $b.map( *.say )␤0␤»

[07:04] <Xliff> m: my $b = (^6).list; $b.map( *.say )

[07:04] <camelia> rakudo-moar 70d61b214: OUTPUT: «0␤1␤2␤3␤4␤5␤»

[07:04] <Xliff> m: my $b = (^6).list; $b».map( *.say )

[07:04] <camelia> rakudo-moar 70d61b214: ( no output )

[07:05] <Xliff> ^^ WTF?

[07:05] <Xliff> m: my $b = (^6).list; $b».map({ .say })

[07:05] <camelia> rakudo-moar 70d61b214: ( no output )

[07:05] <Xliff> m: my $b = (^6).list; $b.hyper.map({ .say })

[07:05] <camelia> rakudo-moar 70d61b214: OUTPUT: «0␤1␤2␤3␤4␤5␤»

[07:06] <Xliff> m: my $b = (^6).list; ($b)».map({ .say })

[07:06] <camelia> rakudo-moar 70d61b214: ( no output )

[07:06] <Xliff> m: my $b = (^6).list; ($b»).map({ .say })

[07:06] <camelia> rakudo-moar 70d61b214: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Malformed postfix␤at <tmp>:1␤------> 3my $b = (^6).list; ($b»7⏏5).map({ .say })␤    expecting any of:␤        postfix␤»

[07:06] <Xliff> m: my $b = (^6).list; $b.gist.say; $b».map({ .say })

[07:06] <camelia> rakudo-moar 70d61b214: OUTPUT: «(0 1 2 3 4 5)␤»

[07:06] <Xliff> m: my $b = (^6).list; $b.gist.say; $b».map({ say "S: $_" })

[07:06] <camelia> rakudo-moar 70d61b214: OUTPUT: «(0 1 2 3 4 5)␤»

[07:07] <Xliff> m: my $b = (^6).list; $b».map({ say "S: $_" })

[07:07] <camelia> rakudo-moar 70d61b214: ( no output )

[07:07] <Xliff> m: my $b = (^6).list; $b.map({ say "S: $_" })

[07:07] <camelia> rakudo-moar 70d61b214: OUTPUT: «S: 0␤S: 1␤S: 2␤S: 3␤S: 4␤S: 5␤»

[07:07] <Xliff> m: my $b = (^6).list; $b.Array.map({ say "S: $_" })

[07:07] <camelia> rakudo-moar 70d61b214: OUTPUT: «S: 0␤S: 1␤S: 2␤S: 3␤S: 4␤S: 5␤»

[07:07] <Xliff> m: my $b = (^6).list; $b.Array».map({ say "S: $_" })

[07:07] <camelia> rakudo-moar 70d61b214: ( no output )

[07:25] *** cpan-p6 left
[07:25] *** cpan-p6 joined
[07:28] *** sena_kun joined
[07:30] *** SergiusUA joined
[07:32] *** SergiusUA left
[07:33] *** SergiusUA joined
[07:37] *** zacts left
[07:39] *** SergiusUA left
[07:49] *** cpan-p6 left
[07:50] *** cpan-p6 joined
[07:50] *** SergiusUA joined
[07:52] *** jmerelo joined
[08:02] <Xliff> m: my @list = ^100; sub dothis(@a) { sleep rand; say @a }; @list.rotor(5).hyper(:1batch).map: &dothis

[08:02] <camelia> rakudo-moar 70d61b214: OUTPUT: «(10 11 12 13 14)␤(15 16 17 18 19)␤(0 1 2 3 4)␤(5 6 7 8 9)␤(35 36 37 38 39)␤(20 21 22 23 24)␤(45 46 47 48 49)␤(25 26 27 28 29)␤(30 31 32 33 34)␤(40 41 42 43 44)␤(55 56 57 58 59)␤(70 71 72 73 74)␤(50 51 52 53 54)␤(80 81 82 83 8…»

[08:03] <Xliff> m: my @list = ^100; sub dothis($a) { sleep rand; say $a }; @list.rotor(5).hyper(:1batch).map: &dothis

[08:03] <camelia> rakudo-moar 70d61b214: OUTPUT: «(15 16 17 18 19)␤(10 11 12 13 14)␤(5 6 7 8 9)␤(0 1 2 3 4)␤(30 31 32 33 34)␤(20 21 22 23 24)␤(25 26 27 28 29)␤(50 51 52 53 54)␤(40 41 42 43 44)␤(35 36 37 38 39)␤(45 46 47 48 49)␤(65 66 67 68 69)␤(55 56 57 58 59)␤(75 76 77 78 7…»

[08:03] *** sauvin joined
[08:04] <Xliff> m: my @list = ^100; sub dothis($a) { sleep rand; say $a }; @list.rotor(5) -> $b { $b.map: &dothis }

[08:04] <camelia> rakudo-moar 70d61b214: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Unexpected block in infix position (missing statement control word before the expression?)␤at <tmp>:1␤------> 3) { sleep rand; say $a }; @list.rotor(5)7⏏5 -> $b { $b.map: &dothis }␤    expec…»

[08:04] <Xliff> m: my @list = ^100; sub dothis($a) { sleep rand; say $a }; for @list.rotor(5) -> $b { $b.map: &dothis }

[08:04] <camelia> rakudo-moar 70d61b214: OUTPUT: «(timeout)0␤»

[08:04] <Xliff> m: my @list = ^20; sub dothis($a) { sleep rand; say $a }; for @list.rotor(5) -> $b { $b.map: &dothis }

[08:05] <camelia> rakudo-moar 70d61b214: OUTPUT: «0␤1␤2␤3␤4␤5␤6␤7␤8␤9␤10␤11␤12␤13␤14␤15␤16␤17␤18␤19␤»

[08:05] <Xliff> m: my @list = ^20; sub dothis($a) { sleep rand; say $a }; for @list.rotor(5) -> $b { $b.hyper(:1batch).map: &dothis }

[08:05] <camelia> rakudo-moar 70d61b214: OUTPUT: «3␤2␤4␤0␤1␤8␤5␤6␤7␤9␤13␤14␤12␤10␤11␤15␤18␤16␤19␤17␤»

[08:05] <Xliff> m: my @list = ^20; sub dothis($a) { sleep rand; say $a }; for @list.rotor(5) -> $b { $b.hyper(:3batch).map: &dothis }

[08:05] <camelia> rakudo-moar 70d61b214: OUTPUT: «0␤3␤4␤1␤2␤8␤5␤6␤9␤7␤13␤14␤10␤11␤12␤15␤18␤19␤16␤17␤»

[08:05] <Xliff> m: my @list = ^20; sub dothis($a) { say $a }; for @list.rotor(5) -> $b { $b.hyper(:3batch).map: &dothis }

[08:05] <camelia> rakudo-moar 70d61b214: OUTPUT: «0␤1␤2␤3␤4␤5␤6␤7␤8␤9␤10␤11␤12␤13␤14␤15␤16␤17␤18␤19␤»

[08:14] *** cpan-p6 left
[08:14] *** cpan-p6 joined
[08:15] <Kaiepi> m: $*SCHEDULER.cue({ say 1 }, at => -Inf)

[08:15] <camelia> rakudo-moar 70d61b214: OUTPUT: «This type cannot unbox to a native integer: P6opaque, Failure␤  in block <unit> at <tmp> line 1␤␤»

[08:16] *** MidCheck left
[08:17] *** rindolf joined
[08:18] <Kaiepi> m: -Inf - now

[08:18] <camelia> rakudo-moar 70d61b214: OUTPUT: «WARNINGS for <tmp>:␤Useless use of "-" in expression "-Inf - now" in sink context (line 1)␤»

[08:18] <Kaiepi> m: say -Inf - now

[08:18] <camelia> rakudo-moar 70d61b214: OUTPUT: «-Inf␤»

[08:18] <Kaiepi> m: use nqp; (1000 * -Inf).Int

[08:18] <camelia> rakudo-moar 70d61b214: OUTPUT: «Cannot convert -Inf to Int: ␤  in block <unit> at <tmp> line 1␤␤»

[08:22] <Kaiepi> m: Inf.Int

[08:22] <camelia> rakudo-moar 70d61b214: OUTPUT: «Cannot convert Inf to Int: ␤  in block <unit> at <tmp> line 1␤␤»

[08:22] <hahainternet> Inf isn't really a number is it :p

[08:22] <Kaiepi> nope

[08:23] <Kaiepi> m: use nqp; say nqp::iseq(Inf, nqp::inf)

[08:23] <camelia> rakudo-moar 70d61b214: OUTPUT: «===SORRY!===␤No registered operation handler for 'iseq'␤»

[08:23] <jmerelo> Just created commaide tag in StackOverflow https://stackoverflow.com/questions/tagged/commaide

[08:23] <yoleaux> 8 Mar 2019 08:38Z <AlexDaniel> jmerelo: cool. But keep in mind that we've been testing the ecosystem since the 2017.04 disaster, after which Zoffix created Toaster

[08:23] <yoleaux> 8 Mar 2019 08:49Z <AlexDaniel> jmerelo: Blin is simply a bit more efficient, and it automatically bisects affected modules (so that the release manager doesn't have to do it manually)

[08:24] <Kaiepi> m: use nqp; say nqp::iseq_n(Inf, nqp::inf)

[08:24] <camelia> rakudo-moar 70d61b214: OUTPUT: «1␤»

[08:24] <jmerelo> Maybe someone with the knowledge (and the time) can fill it up a little bit 

[08:24] <jmerelo> .tell AlexDaniel OK, good point. What happened during the 2017.04?

[08:24] <yoleaux> jmerelo: I'll pass your message to AlexDaniel.

[08:25] <jmerelo> Also, first question using that tag: https://stackoverflow.com/questions/55075395/sdk-is-not-set-in-comma-ide

[08:25] *** zacts joined
[08:33] *** sno left
[08:36] *** ravenousmoose joined
[08:37] <Kaiepi> ok the fix for setting :at to Inf/-Inf/NaN is pretty simple

[08:37] *** w17t joined
[08:38] *** cpan-p6 left
[08:39] *** cpan-p6 joined
[08:52] <Kaiepi> m: say 1000 * NaN

[08:52] <camelia> rakudo-moar 70d61b214: OUTPUT: «NaN␤»

[08:53] *** cpan-p6 left
[08:54] *** cpan-p6 joined
[09:07] *** cpan-p6 left
[09:08] *** cpan-p6 joined
[09:09] <Kaiepi> bastille% perl6 -e '$*SCHEDULER.cue({ say 1 }, at => Inf)'

[09:09] <Kaiepi> 1

[09:09] <Kaiepi> :)

[09:22] *** cpan-p6 left
[09:22] *** cpan-p6 joined
[09:25] <jmerelo> Kaiepi: what?

[09:26] <Kaiepi> m: $*SCHEDULER.cue({ say 1 }, at => Inf)

[09:26] <camelia> rakudo-moar 70d61b214: OUTPUT: «This type cannot unbox to a native integer: P6opaque, Failure␤  in block <unit> at <tmp> line 1␤␤»

[09:26] <Kaiepi> i wrote a fix for this jmerelo 

[09:28] <Kaiepi> in js using Infinity/-Infinity/NaN with setTimeout immediately calls the callback so i did the same here

[09:31] *** ravenousmoose left
[09:32] <jmerelo> Kaiepi: nice!

[09:36] *** cpan-p6 left
[09:36] *** cpan-p6 joined
[09:58] *** cpan-p6 left
[09:59] *** cpan-p6 joined
[10:07] *** SergiusUA left
[10:09] *** w17t left
[10:13] <Geth> ¦ doc: f70f13f69b | (JJ Merelo)++ | doc/Type/IO/Handle.pod6

[10:13] <synopsebot> Link: https://doc.perl6.org/type/IO::Handle

[10:13] <Geth> ¦ doc: Provides example for WRITE refs #2653

[10:13] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/f70f13f69b

[10:13] <jmerelo> Kaiepi: any luck with the Maybe type?

[10:14] <Kaiepi> no

[10:16] <jmerelo> Kaiepi: the problem is that everything is a subclass of Mu unless you use the MOP

[10:16] <Kaiepi> the MOP?

[10:17] <jmerelo> Kaiepi: maybe you can create a new class with the features you want through the meta-object-protocol

[10:17] <jmerelo> Kaiepi: yep, classHOW and all that.

[10:17] <Kaiepi> ah

[10:17] <jmerelo> Kaiepi: https://docs.perl6.org/type/Metamodel::ClassHOW

[10:18] <jmerelo> Kaiepi: it's hard, but you have all the building blocks to create a class that behaves just the way you want (and without subclassing Mu)

[10:21] *** cpan-p6 left
[10:22] *** cpan-p6 joined
[10:26] *** netrino joined
[10:27] *** haukex joined
[10:33] *** w17t joined
[10:48] *** cpan-p6 left
[10:48] *** cpan-p6 joined
[10:57] *** drclaw joined
[11:12] *** drclaw left
[11:12] *** lizmat joined
[11:12] *** cpan-p6 left
[11:13] *** cpan-p6 joined
[11:13] *** drclaw joined
[11:24] *** jmerelo left
[11:33] *** drclaw1 joined
[11:35] *** cpan-p6 left
[11:35] *** woolfy joined
[11:35] *** cpan-p6 joined
[11:36] *** drclaw left
[11:36] *** drclaw2 joined
[11:39] *** drclaw1 left
[11:46] *** mowcat joined
[11:49] *** MasterDuke left
[11:53] *** pecastro joined
[11:59] *** cpan-p6 left
[12:00] *** cpan-p6 joined
[12:04] *** lizmat left
[12:09] *** woolfy left
[12:22] *** cpan-p6 left
[12:22] *** cpan-p6 joined
[12:31] *** pmurias joined
[12:31] *** dhyan_nataraj joined
[12:31] *** SergiusUA joined
[12:34] *** drclaw2 left
[12:37] *** cpan-p6 left
[12:37] *** cpan-p6 joined
[12:52] *** cpan-p6 left
[12:52] *** cpan-p6 joined
[12:54] *** lucasb joined
[12:55] *** ravenousmoose joined
[13:11] *** ravenousmoose left
[13:11] *** cpan-p6 left
[13:18] *** ravenousmoose joined
[13:18] <Geth> ¦ doc: fea4772bca | (Ben Davies)++ | doc/Language/js-nutshell.pod6

[13:18] <synopsebot> Link: https://doc.perl6.org/language/js-nutshell

[13:18] <Geth> ¦ doc: Correct statement about typeof/constructor/^name in JS nutshell

[13:18] <Geth> ¦ doc: 

[13:18] <Geth> ¦ doc: typeof has no equivalent in Perl 6. The constructor property has an

[13:18] <Geth> ¦ doc: equivalent, but it's not the ^name meta-attribute, it's the WHAT

[13:18] <Geth> ¦ doc: attribute.

[13:18] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/fea4772bca

[13:19] <Geth> ¦ doc: c980c202f5 | (Ben Davies)++ | doc/Language/js-nutshell.pod6

[13:19] <Geth> ¦ doc: Change Node to Node.js in the title of the JS nutshell

[13:19] <Geth> ¦ doc: 

[13:19] <Geth> ¦ doc: Calling it Node does not follow Node.js' style guide

[13:19] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/c980c202f5

[13:22] <AlexDaniel> .

[13:22] <yoleaux> 08:24Z <jmerelo> AlexDaniel: OK, good point. What happened during the 2017.04?

[13:22] *** haukex left
[13:22] <AlexDaniel> .tell https://rakudo.party/post/The-Failure-Point-of-a-Release

[13:22] <yoleaux> AlexDaniel: I don't know what you want me to say to https://rakudo.party/post/The-Failure-Point-of-a-Release.

[13:22] <AlexDaniel> oops

[13:23] <AlexDaniel> .tell jmerelo https://rakudo.party/post/The-Failure-Point-of-a-Release

[13:23] <yoleaux> AlexDaniel: I'll pass your message to jmerelo.

[13:27] *** netrino left
[13:55] <El_Che> wasn't zoffix planning on letting the rakudo.party domain expire?

[14:09] <Kaiepi> m: say [Nil, Nil, Nil].map({ 1 })

[14:09] <camelia> rakudo-moar 70d61b214: OUTPUT: «(1 1 1)␤»

[14:09] <Kaiepi> is there a better way to generate an array using a function?

[14:10] <Kaiepi> wait that was worded badly

[14:10] *** cpan-p6 joined
[14:10] <timotimo> yeah, use the xx operator. it thunks its LHS

[14:10] <timotimo> m: say ($++ xx 20)

[14:10] <camelia> rakudo-moar 70d61b214: OUTPUT: «(0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19)␤»

[14:11] <Kaiepi> m: my @ranks = [2, 3, 4, 5, 6, 7, 8, 9, 'J', 'Q', 'K', 'A']; say @ranks.pick xx 3

[14:11] <camelia> rakudo-moar 70d61b214: OUTPUT: «(3 7 J)␤»

[14:11] <timotimo> rather than .pick xx 3 you can also .roll(3)

[14:12] <timotimo> and also:

[14:12] <timotimo> if you actually have a deck of cards, you'll really want to .pick, which will not grab the same element twice

[14:12] <timotimo> m: my @ranks = <1 2 3 4 4 4 4 4 4>; say @ranks.pick(5); say @ranks.pick(5); say @ranks.pick(5)

[14:12] <camelia> rakudo-moar 70d61b214: OUTPUT: «(4 4 4 2 4)␤(4 4 4 4 4)␤(4 2 4 4 1)␤»

[14:13] <timotimo> m: my @ranks = <1 2 3 4 5 6>; say @ranks.pick(5); say @ranks.pick(5); say @ranks.pick(5)

[14:13] <camelia> rakudo-moar 70d61b214: OUTPUT: «(5 4 3 2 1)␤(3 2 4 1 5)␤(3 4 5 1 2)␤»

[14:13] <timotimo> .pick(*) will give you as many elements as are in the source, .roll(*) will give you an infinite lazy sequence

[14:13] <Kaiepi> ah

[14:15] <Kaiepi> what about if i want to generate each element in an array with a nondeterministic function?

[14:16] <sena_kun> foo xx 50?

[14:16] <sena_kun> m: sub foo { rand }; say foo() xx 50;

[14:16] <camelia> rakudo-moar 70d61b214: OUTPUT: «(0.48982788749651385 0.4173129736778004 0.8122867503349468 0.4006933500550446 0.33840279263919715 0.06235815537018208 0.009366707936189766 0.9424356648221496 0.44825783385146745 0.9564038172628159 0.7097463593071354 0.4829340447387036 0.90074128035879…»

[14:18] <Kaiepi> oh, i thought it'd call the function once and repeat the output 50 times

[14:19] <lucasb> thunkiness is tricky. I'm not entirely sure it was the best idea to make xx thunked by default :)

[14:19] <yoleaux> 8 Mar 2019 18:11Z <AlexDaniel> lucasb: thank you! :)

[14:20] <lucasb> m: say (state $x = 42) xx 3

[14:20] <camelia> rakudo-moar 70d61b214: OUTPUT: «((Any) (Any) (Any))␤»

[14:20] <lucasb> ^^ is this right?

[14:25] <timotimo> lucasb: ask python programmers about the x operator being used on arrays

[14:25] <timotimo> er, the * operator

[14:25] <timotimo> m: my @inner-array = 0 xx 10; my @outer = @inner-array xx 10; @outer[0][0] = 1; say @outer;

[14:25] <camelia> rakudo-moar 70d61b214: OUTPUT: «[[1 0 0 0 0 0 0 0 0 0] [1 0 0 0 0 0 0 0 0 0] [1 0 0 0 0 0 0 0 0 0] [1 0 0 0 0 0 0 0 0 0] [1 0 0 0 0 0 0 0 0 0] [1 0 0 0 0 0 0 0 0 0] [1 0 0 0 0 0 0 0 0 0] [1 0 0 0 0 0 0 0 0 0] [1 0 0 0 0 0 0 0 0 0] [1 0 0 0 0 0 0 0 0 0]]␤»

[14:26] <timotimo> m: my @outer = [0 xx 10] xx 10; @outer[0][0] = 1; say @outer;

[14:26] <camelia> rakudo-moar 70d61b214: OUTPUT: «[[1 0 0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0 0 0]]␤»

[14:26] <Kaiepi> m: 1 xx Inf

[14:26] <camelia> rakudo-moar 70d61b214: ( no output )

[14:26] <timotimo> which do you prefer? :)

[14:26] <Kaiepi> m: say 1 xx Inf

[14:26] <camelia> rakudo-moar 70d61b214: OUTPUT: «(...)␤»

[14:26] <Kaiepi> the latter's a bit easier to read imo

[14:27] *** cpan-p6 left
[14:28] <tobs> Kaiepi: the outputs are different

[14:28] <lucasb> sure, the behavior is convenient when you really needs it :)

[14:29] <Kaiepi> oh

[14:29] <Kaiepi> didn't notice

[14:30] <timotimo> the first one is what you get from python's * operator

[14:30] <Kaiepi> right, the former has 10 references to @inner-array, while the latter has 10 separate arrays

[14:31] <timotimo> yup

[14:31] <tobs> btw, was your grant proposal about sockets accepted, Kaiepi?

[14:31] <Kaiepi> yep!

[14:31] <timotimo> i believe it was

[14:31] <lucasb> but I think thunkiness is a "big deal", so it could be more prominently that you are using it. "A xx B" looks just like a regular operator, but it's not 

[14:31] <Kaiepi> just waiting to hear from a mentor

[14:31] <timotimo> m: sub foobar(@bloop = []) { @bloop.push(1); say @bloop; }; foobar(); foobar(); foobar();

[14:31] <camelia> rakudo-moar 70d61b214: OUTPUT: «[1]␤[1]␤[1]␤»

[14:31] <tobs> Nice, I'm looking forward especially to UNIX sockets! (Heard about it some time ago, and then forgot about it.)

[14:31] <timotimo> m: my $bloop = []; sub foobar($ibloop = $bloop) { $ibloop.push(1); say $ibloop; }; foobar(); foobar(); foobar();

[14:31] <camelia> rakudo-moar 70d61b214: OUTPUT: «[1]␤[1 1]␤[1 1 1]␤»

[14:32] <Kaiepi> that'll be what i work on a couple months from now if all goes to schedule

[14:32] <timotimo> ^- the second one is how python does what the first code does in perl6

[14:32] <timotimo> similar issue

[14:32] <Kaiepi> rn i have getsockopt/setsockopt support finished, i'm just waiting on a code review

[14:45] *** Black_Ribbon left
[14:53] *** cpan-p6 joined
[14:55] *** ravenousmoose left
[15:02] *** pmurias left
[15:09] <Kaiepi> jesus explaining control flow for the js nutshell page is rough

[15:09] <Kaiepi> i'm at 169 lines and i've only explained if/else, switch, and for loops

[15:09] *** cpan-p6 left
[15:10] *** cpan-p6 joined
[15:20] <lucasb> m: sub f($x = my $y = 42) { $y }; say f()

[15:20] <camelia> rakudo-moar 70d61b214: OUTPUT: «42␤»

[15:20] <lucasb> lexical $y is really supposed to leak inside the sub?

[15:22] *** MilkmanDan left
[15:22] *** MilkmanDan joined
[15:23] <timotimo> m: sub f($x = my $y = 42) { $x }; say f(); say $y

[15:23] <camelia> rakudo-moar 70d61b214: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Variable '$y' is not declared␤at <tmp>:1␤------> 3f($x = my $y = 42) { $x }; say f(); say 7⏏5$y␤»

[15:23] <timotimo> it's actually even only inside the sub

[15:26] *** kurahaupo left
[15:27] *** kurahaupo joined
[15:28] *** molaf left
[15:33] *** pmurias joined
[15:34] *** cpan-p6 left
[15:34] *** cpan-p6 joined
[15:38] *** andrewshitov joined
[15:42] *** andrewshitov left
[15:47] <Geth> ¦ doc: 5fdddcc8fd | cfa++ | doc/Type/IO/Handle.pod6

[15:47] <synopsebot> Link: https://doc.perl6.org/type/IO::Handle

[15:47] <Geth> ¦ doc: Fix typo.

[15:47] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/5fdddcc8fd

[15:49] *** cpan-p6 left
[15:49] *** cpan-p6 joined
[15:50] <AlexDaniel> El_Che: yes, and we should make a backup somewhere

[15:51] <AlexDaniel> and in fact maybe set up a perm redirect before it expires

[15:51] <AlexDaniel> that needs tuits, time and a volunteer :)

[15:55] <Kaiepi> m: my %primes is SetHash; my Int $i = 2; OUTER: loop { next OUTER if $i %% $_ for %primes.keys; %primes{$i}++; last if ++$i >= 20 }

[15:55] <camelia> rakudo-moar 70d61b214: OUTPUT: «Cannot resolve caller next(OUTER:U); none of these signatures match:␤    ( --> Nil)␤    (Label:D \x --> Nil)␤  in block  at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[15:56] <Kaiepi> m: my %primes is SetHash; my Int $i = 2; OUTER: loop { for %primes.keys { next OUTER if $i %% $_ }; %primes{$i}++; last if ++$i >= 20 }

[15:56] <camelia> rakudo-moar 70d61b214: OUTPUT: «Cannot resolve caller next(OUTER:U); none of these signatures match:␤    ( --> Nil)␤    (Label:D \x --> Nil)␤  in block  at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[16:00] <Kaiepi> is there something i'm doing wrong?

[16:00] <Kaiepi> bisectable6, my %primes is SetHash; my Int $i = 2; OUTER: loop { next OUTER if $i %% $_ for %primes.keys; %primes{$i}++; last OUTER if ++$i >= 20 }

[16:00] <bisectable6> Kaiepi, Bisecting by output (old=2015.12 new=70d61b2) because on both starting points the exit code is 1

[16:00] <sena_kun> you mean the approach itself or the absence of `is-prime` method? :)

[16:00] <Kaiepi> the approach

[16:01] <bisectable6> Kaiepi, bisect log: https://gist.github.com/b9a7021c7dc06ad4e1085c9e66f92ee3

[16:01] <bisectable6> Kaiepi, (2016-06-09) https://github.com/rakudo/rakudo/commit/b6902e5192929a733a37079d5dc414430078bc7d

[16:01] <Kaiepi> i know about is-prime, i'm just using this as an example of using loops with next/last and labels

[16:01] <tobs> m: OUTER.perl.say

[16:01] <camelia> rakudo-moar 70d61b214: OUTPUT: «OUTER␤»

[16:02] <tobs> I think it's complaining about the name of your label. OUTER is already a thing.

[16:02] <Kaiepi> m: my %primes is SetHash; my Int $i = 2; OUTSIDE: loop { for %primes.keys { next OUTSIDE if $i %% $_ }; %primes{$i}++; last OUTSIDE if ++$i >= 20 }

[16:03] <camelia> rakudo-moar 70d61b214: OUTPUT: «(timeout)»

[16:03] *** cpan-p6 left
[16:03] <tobs> m: my $x = 10; { my $x = 12; say $x; say $OUTER::x } # as in

[16:03] <camelia> rakudo-moar 70d61b214: OUTPUT: «12␤10␤»

[16:03] *** reach_satori left
[16:03] *** cpan-p6 joined
[16:03] <Kaiepi> m: my %primes is SetHash; .say for %primes.keys

[16:03] <camelia> rakudo-moar 70d61b214: ( no output )

[16:04] <Kaiepi> oh i know why it's timing out

[16:04] <Kaiepi> m: my %primes is SetHash; my Int $i = 1; OUTSIDE: loop { ++$i; for %primes.keys { next OUTSIDE if $i %% $_ }; %primes{$i}++; last OUTSIDE if $i >= 20 }

[16:04] <camelia> rakudo-moar 70d61b214: ( no output )

[16:04] <Kaiepi> m: my %primes is SetHash; my Int $i = 1; OUTSIDE: loop { ++$i; for %primes.keys { next OUTSIDE if $i %% $_ }; %primes{$i}++; last OUTSIDE if $i >= 20 }; say %primes

[16:04] <camelia> rakudo-moar 70d61b214: OUTPUT: «SetHash(11 13 17 19 2 23 3 5 7)␤»

[16:05] <Kaiepi> m: my %primes is SetHash; my Int $i = 1; OUTSIDE: loop { ++$i; for %primes.keys { redo OUTSIDE if $i %% $_ }; %primes{$i}++; last OUTSIDE if $i >= 20 }; say %primes

[16:05] <camelia> rakudo-moar 70d61b214: OUTPUT: «SetHash(11 13 17 19 2 23 3 5 7)␤»

[16:06] <Kaiepi> m: my %primes is SetHash; my Int $i = 1; OUTSIDE: loop { ++$i; last OUTSIDE if $i >= 20; redo OUTSIDE if $i %% $_ for %primes.keys; %primes{$i}++; }; say %primes

[16:06] <camelia> rakudo-moar 70d61b214: OUTPUT: «SetHash(11 13 17 19 2 3 5 7)␤»

[16:06] <Kaiepi> there we go

[16:08] <tobs> m: my %primes is SetHash; while (my $i = 2) < 20 { next if $i %% any(%primes.keys); %primes{$i}++; NEXT $i++ }

[16:08] <tobs> hmmm

[16:08] <camelia> rakudo-moar 70d61b214: OUTPUT: «(timeout)»

[16:08] <tobs> all I wanted to say is: a NEXT phaser might also look nice.

[16:09] <tobs> ah, I see

[16:09] <tobs> m: my %primes is SetHash; my $i = 2; while $i < 20 { next if $i %% any(%primes.keys); %primes{$i}++; NEXT $i++ }

[16:09] <camelia> rakudo-moar 70d61b214: ( no output )

[16:09] <tobs> m: my %primes is SetHash; my $i = 2; while $i < 20 { next if $i %% any(%primes.keys); %primes{$i}++; NEXT $i++ }; say %primes

[16:09] <camelia> rakudo-moar 70d61b214: OUTPUT: «SetHash(11 13 17 19 2 3 5 7)␤»

[16:21] <Kaiepi> i'd use any but i haven't gotten to explaining junctions yet in the docs i'm writing

[16:26] *** cpan-p6 left
[16:27] *** cpan-p6 joined
[16:28] *** netrino joined
[16:28] *** lizmat joined
[16:30] *** reach_satori joined
[16:38] *** woolfy joined
[16:50] *** cpan-p6 left
[16:50] *** cpan-p6 joined
[16:52] *** ufobat joined
[17:04] *** cpan-p6 left
[17:04] *** cpan-p6 joined
[17:08] *** MilkmanDan left
[17:09] *** dhyan_nataraj left
[17:12] *** MilkmanDan joined
[17:20] *** cpan-p6 left
[17:20] *** cpan-p6 joined
[17:38] *** zacts left
[17:44] *** cpan-p6 left
[17:44] *** dhyan_nataraj joined
[17:44] *** cpan-p6 joined
[17:50] <discord6> <kawaii> Got an error stating Undeclared routine: unpack used at line 47, the docs say all I need is use experimental :pack; (which I already have due to using pack, are the docs wrong?

[17:50] *** zacts joined
[17:51] <discord6> <kawaii> (yes I already checked if use experimental :unpack; was a thing, it's not 😉 )

[17:51] <sena_kun> well, it is a routine

[17:51] <sena_kun> which is undeclared, but you need a method.

[17:51] <sena_kun> m: use experimental :pack; say Blob.new(1..10).unpack("C*");

[17:51] <camelia> rakudo-moar 70d61b214: OUTPUT: «(1 2 3 4 5 6 7 8 9 10)␤»

[17:51] <sena_kun> see example from https://docs.perl6.org/routine/unpack

[17:52] <discord6> <kawaii> I was trying to use it like unpack("VVVa*", $response);

[17:52] <sena_kun> so it is not a `unpack $blob, $pattern`, but `$block.unpack($pattern)`.

[17:52] <discord6> <kawaii> ah, hm

[17:52] <sena_kun> try `$response.unpack("VVVa*")`

[17:53] <sena_kun> you can write a wrapper if you want, it'd be just `sub unpack($p, $buf) { $buf.unpack($p) }`

[17:53] *** zacts left
[17:53] *** zacts joined
[17:53] <discord6> <kawaii> ah, that seems to work, new error about strings or something, but progress, thank you! 😃

[17:53] <sena_kun> but if you are porting a thing from P5, I suspect, it's better to use more nativish approach, imho.

[17:53] <discord6> <kawaii> https://fastapi.metacpan.org/source/CHANDWER/Net-RCON-1.0/lib/Net/RCON.pm

[17:54] <discord6> <kawaii> sena_kun: this is what I'm porting

[17:54] <discord6> <kawaii> figured it was simple enough to handle as my first module

[17:54] <sena_kun> looks like a good choice to me. :)

[18:08] *** cpan-p6 left
[18:08] *** cpan-p6 joined
[18:10] <Geth> ¦ doc: Kaiepi++ created pull request #2654: Document control flow in the JS nutshell

[18:10] <Geth> ¦ doc: review: https://github.com/perl6/doc/pull/2654

[18:13] <cpan-p6> New module released to CPAN! Smack (0.2.0) by 03HANENKAMP

[18:14] <tobs> @kawaii, if you don't want to do it more nativish, try P5pack

[18:14] <tobs> eco: P5pack

[18:15] <tobs> (does that bot not exist anymore?)

[18:17] *** molaf joined
[18:20] <discord6> <kawaii> tobs: I'm happy to refactor bits to be more native, can you point me in the right direction? 😃

[18:22] *** cpan-p6 left
[18:22] *** cpan-p6 joined
[18:27] *** kyzn left
[18:42] <Geth> ¦ doc: 88232c9940 | (Ben Davies)++ | util/perl-nbsp.p6

[18:42] <Geth> ¦ doc: Fix up and refactor util/perl-nbsp.p6

[18:42] <Geth> ¦ doc: 

[18:42] <Geth> ¦ doc: Sometimes the script would replace the "6" in "Perl 6" with nothing for

[18:42] <Geth> ¦ doc: whatever reason. That no longer happens. A filename can now be passed to

[18:42] <Geth> ¦ doc: the script so it'll only check that file for any instances of "Perl 6"

[18:42] <Geth> ¦ doc: using regular spaces.

[18:42] *** cpan-p6 left
[18:42] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/88232c9940

[18:43] *** cpan-p6 joined
[18:44] <cpan-p6> New module released to CPAN! Concurrent-Stack (1.1) by 03JNTHN

[18:44] *** Khisanth left
[18:48] *** MasterDuke joined
[18:48] *** MasterDuke left
[18:48] *** MasterDuke joined
[18:54] *** MilkmanDan left
[18:56] *** MilkmanDan joined
[18:58] *** Khisanth joined
[19:06] *** zachk joined
[19:07] *** zachk left
[19:08] *** cpan-p6 left
[19:08] *** zachk joined
[19:08] *** zachk left
[19:08] *** zachk joined
[19:08] *** cpan-p6 joined
[19:09] *** zacts left
[19:14] <cpan-p6> New module released to CPAN! gtk-v3 (0.8.3) by 03MARTIMM

[19:15] *** hankache joined
[19:18] *** reach_satori left
[19:24] *** ravenousmoose joined
[19:24] <Geth> ¦ doc: 828a8411f5 | (Ben Davies)++ | doc/Language/js-nutshell.pod6

[19:24] <Geth> ¦ doc: Document control flow in the JS nutshell

[19:24] <synopsebot> Link: https://doc.perl6.org/language/js-nutshell

[19:24] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/828a8411f5

[19:24] <Geth> ¦ doc: 564eb6a81d | (Juan Julián Merelo Guervós)++ (committed using GitHub Web editor) | doc/Language/js-nutshell.pod6

[19:24] <Geth> ¦ doc: Merge pull request #2654 from Kaiepi/nodejs

[19:24] <Geth> ¦ doc: 

[19:24] <Geth> ¦ doc: Document control flow in the JS nutshell

[19:24] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/564eb6a81d

[19:32] *** zachk left
[19:32] *** dhyan_nataraj left
[19:32] *** dhyan_nataraj joined
[19:33] *** cpan-p6 left
[19:33] *** cpan-p6 joined
[19:48] *** cpan-p6 left
[19:48] *** hcshcshcshcshcs left
[19:48] *** cpan-p6 joined
[19:52] *** jmerelo joined
[20:01] <discord6> <kawaii> my ($response-size, $response-id, $packet-type, $response-body) = $response.unpack("VVVa*"); No such method 'unpack' for invocant of type 'Str' I assume this means that one of the values in $response is not a blob and is actually already a string?

[20:02] *** cpan-p6 left
[20:02] <discord6> <kawaii> I assumed that the socket would be sending me a 'packet' in the form of a blob, and that I could use unpack like this to extract values out into those variables according to the template provided

[20:02] <timotimo> yeah, that'd already be a string

[20:02] *** cpan-p6 joined
[20:02] <timotimo> you can use stuff that reads strings from sockets, too

[20:02] <timotimo> depends on what methods you are using

[20:03] <discord6> <kawaii> the perl5 code I'm porting does the same thing though :[ my ( $size, $response_id, $response_type, $response_body ) = unpack( "VVVa*", $response );

[20:03] *** ferreira left
[20:04] <jmerelo> kawaii you did "use experimental :pack", right?

[20:04] <yoleaux> 13:23Z <AlexDaniel> jmerelo: https://rakudo.party/post/The-Failure-Point-of-a-Release

[20:04] <jmerelo> tell AlexDaniel thanks!

[20:04] <discord6> <kawaii> jmerelo: yep! i'm already using pack elsewhere too :]

[20:04] <discord6> <kawaii> https://github.com/shuppet/p6-net-rcon/blob/master/lib/Net/RCON.pm6#L47

[20:06] <jmerelo> kawaii perl5 works on strings, not Blobs... It wouldn't make a lot of sense to convert stuff back into a Blob, I guess.

[20:08] <discord6> <kawaii> from my understanding, the original p5 module packs strings into blobs, before sending them, and unpacks blobs we get back from the socket into strings to populate variables with

[20:08] <timotimo> maybe you can also use .read-int64 (or .read-uint64) and friends, too

[20:08] <timotimo> we don't have a "read string" equivalent, so you'd .subbuf.decode('utf-8') or whatever

[20:09] *** smash_ left
[20:10] *** Util left
[20:11] *** Util joined
[20:12] *** charsbar left
[20:12] *** charsbar joined
[20:12] *** jmerelo left
[20:13] <discord6> <kawaii> timotimo: I was missing :bin on my recv call, so the socket was returning me strings all along :]

[20:14] <timotimo> ah, easy :)

[20:14] *** integral left
[20:15] *** integral joined
[20:16] *** smash joined
[20:17] *** a3r0 left
[20:17] *** a3r0 joined
[20:25] *** cpan-p6 left
[20:25] *** cpan-p6 joined
[20:27] *** smash left
[20:27] *** smash joined
[20:40] *** cpan-p6 left
[20:40] *** cpan-p6 joined
[20:42] <AlexDaniel> kawaii: btw, recommended reading: https://rakudo.party/post/The-Failure-Point-of-a-Release

[20:43] <AlexDaniel> greppable: Test::Output

[20:43] <greppable6> AlexDaniel, 52 lines, 14 modules: https://gist.github.com/bcb89321e1bad458d47c35c320a1439a

[20:44] <AlexDaniel> greppable: use Test::Output;

[20:44] <greppable6> AlexDaniel, 27 lines, 12 modules: https://gist.github.com/b87e9d4dc5eb60e1e86f1e0479b518e6

[20:46] <discord6> <kawaii> AlexDaniel: thanks! I'll add it to my reading list, going to spend the next week getting comfortable with everything detailed in the rakudo release document you linked too, not sure if I'll be much use for the next release, but hopefully if I can at least help out with the next one it's progress.

[20:54] <AlexDaniel> kawaii: OK, will talk to you next week then!

[20:54] *** molaf left
[20:58] *** ferreira joined
[21:01] *** Black_Ribbon joined
[21:04] *** cpan-p6 left
[21:04] *** cpan-p6 joined
[21:05] *** integral left
[21:05] *** integral joined
[21:14] *** Kaiepi left
[21:15] *** Kaiepi joined
[21:18] *** ravenousmoose left
[21:25] *** Kaiepi left
[21:26] *** Kaiepi joined
[21:27] *** cpan-p6 left
[21:27] *** cpan-p6 joined
[21:38] *** sno joined
[21:41] *** pmurias left
[21:52] *** cpan-p6 left
[21:52] *** cpan-p6 joined
[21:54] *** dhyan_nataraj left
[21:58] *** pmurias joined
[22:05] *** sena_kun left
[22:06] *** kurahaupo left
[22:06] *** kurahaupo joined
[22:15] <Kaiepi> m: class Maybe { method ^parameterize(Mu \M, Mu \T) { my $refinee = (T === Junction) ?? Mu !! Any; Metamodel::SubsetHOW.new_type: :name("Maybe[{T.^name}]"), :$refinee, :refinement(T | Failure) } }; my Maybe[Int] ($a, $b) = (1, Failure.new); say $a; say $b

[22:15] <camelia> rakudo-moar 4cfe5ec10: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤An exception occurred while parameterizing Maybe␤at <tmp>:1␤Exception details:␤  Type check failed in binding to parameter '<anon>'; expected Any but got Junction (Junction)␤    in method parame…»

[22:15] *** cpan-p6 left
[22:15] *** cpan-p6 joined
[22:16] <Kaiepi> m: use nqp; class Maybe { method ^parameterize(Mu \M, Mu \T) { Metamodel::SubsetHOW.new_type: :name("Maybe[{T.^name}]"), :refinee(nqp::if(nqp::istype(T, Junction), Mu, Any)), :refinement(T | Failure) } }; my Maybe[Int] ($a, $b) = (1, Failure.new); say $a; say $b

[22:16] <camelia> rakudo-moar 4cfe5ec10: OUTPUT: «1␤Failed␤␤Actually thrown at:␤  in block <unit> at <tmp> line 1␤␤»

[22:16] <Kaiepi> FINALLY

[22:16] <Kaiepi> m: use nqp; class Maybe { method ^parameterize(Mu \M, Mu \T) { Metamodel::SubsetHOW.new_type: :name("Maybe[{T.^name}]"), :refinee(nqp::if(nqp::istype(T, Junction), Mu, Any)), :refinement(T | Failure) } }; my Maybe[Int] $a = 'a'

[22:16] <camelia> rakudo-moar 4cfe5ec10: OUTPUT: «Type check failed in assignment to $a; expected Maybe[Int] but got Str ("a")␤  in block <unit> at <tmp> line 1␤␤»

[22:20] *** SergiusUA left
[22:26] <lizmat> m: my Int $a = Failure.new

[22:26] <camelia> rakudo-moar 4cfe5ec10: OUTPUT: «Earlier failure:␤ (HANDLED) Failed␤␤Final error:␤ Type check failed in assignment to $a; expected Int but got Failure (&CORE::infix:<orelse>...)␤  in block <unit> at <tmp> line 1␤␤»

[22:26] <lizmat> hmmm

[22:27] *** rindolf left
[22:27] <lizmat> Kaiepi++  # perseverance

[22:28] * lizmat wonders whether Maybe should be core

[22:29] *** cpan-p6 left
[22:29] *** cpan-p6 joined
[22:42] *** drclaw2 joined
[22:44] *** cpan-p6 left
[22:44] *** cpan-p6 joined
[23:04] *** kurahaupo left
[23:05] *** kurahaupo joined
[23:09] *** cpan-p6 left
[23:10] *** cpan-p6 joined
[23:35] *** cpan-p6 left
[23:35] *** cpan-p6 joined
[23:50] *** cpan-p6 left
[23:50] *** cpan-p6 joined
