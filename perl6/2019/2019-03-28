[00:15] *** patrickz joined
[00:17] *** huf left
[00:18] *** patrickb left
[00:23] *** netrino left
[00:53] *** w_richard_w joined
[01:14] *** zachk left
[01:22] *** patrickz left
[02:19] *** leont left
[02:20] *** MidCheck left
[02:27] *** sftp left
[02:29] *** sftp joined
[02:44] *** kini left
[02:51] *** kini joined
[02:52] *** huf joined
[03:18] *** mowcat left
[03:21] *** ufobat_ joined
[03:24] *** aborazmeh joined
[03:24] *** aborazmeh left
[03:24] *** aborazmeh joined
[03:25] *** ufobat__ left
[03:26] *** jeek_ left
[03:44] <Xliff> "Unexpected named argument 'binding' passed

[03:44] <Xliff> "

[03:44] <Xliff> What causes that?!

[03:48] *** aindilis joined
[03:49] *** jeek joined
[03:59] *** Xliff left
[04:02] <MasterDuke> m: sub f(:$a) { say $a }; f(:2b)

[04:02] <camelia> rakudo-moar b5843b0e3: OUTPUT: «Unexpected named argument 'b' passed␤  in sub f at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[04:43] *** aborazmeh left
[05:32] *** sauvin joined
[05:56] *** andrzejku joined
[05:58] *** curan joined
[06:08] *** xtreak joined
[06:14] *** xtreak left
[06:19] *** robertle left
[06:26] *** xtreak joined
[06:44] *** molaf joined
[06:44] *** MidCheck joined
[06:57] *** nebuchadnezzar joined
[07:09] <tyil> tfw cpan-p6_' memory usage has not increased during my sleep

[07:10] <tyil> this is a good sign (but it also has not seen any new modules come by)

[07:11] *** molaf left
[07:12] *** domidumont joined
[07:28] *** simcop2387 left
[07:29] *** TeamBlast left
[07:29] *** TeamBlast joined
[07:29] *** simcop2387 joined
[07:35] *** rindolf joined
[07:38] *** domidumont1 joined
[07:41] *** domidumont left
[07:47] *** patrickb joined
[07:55] *** ekexium joined
[07:55] *** andrzejku left
[07:59] *** dmaestro left
[08:03] *** zakharyas joined
[08:04] *** robertle joined
[08:08] *** sno left
[08:30] *** dakkar joined
[08:32] *** kensanata joined
[08:33] *** cpan-p6 joined
[08:33] *** cpan-p6 left
[08:33] *** cpan-p6 joined
[08:33] *** cpan-p6_ left
[08:36] *** molaf joined
[08:37] *** xtreak left
[08:45] *** domidumont1 left
[08:46] *** cpan-p6_ joined
[08:46] *** cpan-p6_ left
[08:46] *** cpan-p6_ joined
[08:46] *** mowcat joined
[08:46] *** cpan-p6 left
[08:46] *** mowcat left
[08:47] *** mowcat joined
[08:47] *** yqt joined
[08:47] *** cpan-p6_ left
[08:47] *** cpan-p6 joined
[08:47] *** cpan-p6 left
[08:47] *** cpan-p6 joined
[08:53] <tyil> .bots

[08:53] <cpan-p6> 03cpan-p6 reporting for duty! [Perl 6] 02https://git.tyil.nl/perl6/app-cpan-uploadannouncer-irc

[08:54] <tyil> :D

[08:56] <Geth> ¦ doc: a198ad46f6 | (JJ Merelo)++ | doc/Language/packages.pod6

[08:56] <Geth> ¦ doc: Eliminating erroneous examples

[08:56] <Geth> ¦ doc: 

[08:56] <Geth> ¦ doc: This closes #2700. Also eliminates a few paragraphs below that did not work either.

[08:56] <synopsebot> Link: https://doc.perl6.org/language/packages

[08:56] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/a198ad46f6

[08:58] *** ravenousmoose_ joined
[08:58] <lizmat> weekly: https://medium.com/@jcoterhals/perl-6-small-stuff-15-long-story-about-short-answers-to-perl-weekly-challenge-no-1-85e741bf8716

[08:58] <notable6> lizmat, Noted!

[09:00] *** ravenousmoose left
[09:05] *** sena_kun joined
[09:05] *** xtreak joined
[09:05] *** antoniogamiz joined
[09:07] <kawaii> AlexDaniel: any idea what's going on here? using the sakefile recursively (localhost) on a larger server and coming back with sake not found... https://www.irccloud.com/pastebin/vC0BiJih/

[09:17] *** ravenousmoose_ left
[09:17] *** ravenousmoose_ joined
[09:18] <moritz> sake not found? no booze for you? :D

[09:18] <kawaii> sadly :(

[09:19] *** reach_satori_ left
[09:21] *** ravenousmoose_ left
[09:22] *** ravenousmoose joined
[09:28] *** antoniogamiz left
[09:29] *** antoniogamiz joined
[09:35] *** w_richard_w left
[10:00] *** zacts joined
[10:01] *** zacts left
[10:02] *** zacts joined
[10:02] *** zacts left
[10:09] *** reach_satori joined
[10:14] *** domidumont joined
[10:30] <Altreus> kawaii: presumably the ssh is complicit

[10:30] <Altreus> kawaii: I bet if you do something like ssh localhost sh -c sake

[10:30] <Altreus> this won't work because your zshrc doesn't set your $PATH because sh doesn't run it

[10:30] <Altreus> from that we could hypothesise that whatever's doing that ssh is doing it that way

[10:31] *** ravenousmoose left
[10:33] *** reach_satori left
[10:36] *** yqt left
[10:40] *** xtreak left
[10:40] *** ravenousmoose joined
[10:41] *** xtreak joined
[10:46] *** reach_satori joined
[10:46] *** ravenousmoose left
[10:52] <kawaii> Altreus: yeah you're right, `sake` invokes `perl6` so I then get `/usr/bin/env: ‘perl6’: No such file or directory`

[10:52] <kawaii> this is all just bash on this server

[10:53] *** domidumont1 joined
[10:55] *** leont joined
[10:56] *** domidumont left
[10:57] <patrickb> tyil: Question about the license you chose for the dockerfiles of yours: Why did you choose AGPL?

[10:58] <tyil> because it's my preferred license

[10:58] <patrickb> If I understand the AGPL correctly it has little effect on Dockerfiles.

[10:58] <Altreus> kawaii: set up /etc/bashrc or whatever

[10:59] <Altreus> might be a bit heavy-handed but you get the idea

[10:59] <Altreus> some file that Makes It Work

[10:59] <tyil> all it means is that you're free to use any code in the repo for whatever purpose you see fit, so long as you make the stuff you're using it free (as in freedom)

[10:59] <patrickb> Because one usually doesn't distribute them to users of the software nor uses them implicitly on webservers.

[10:59] <Altreus> Speaking of freedom, looks like Mel Gibson is playing another Scot

[11:00] <tyil> patrickb: correct, but the license is for the entire repo, and is my default go-to license

[11:00] <tyil> I don't have any reasons for that license to be there other than having no reasons *not* to have it :>

[11:02] <patrickb> tyil: I'm ok with the license. In fact I do plan to release my adaption of it as well. It's just that the license confuses me a bit when applied to dockerfiles since I think in most normal use cases the license doesn't enforce anything.

[11:03] <tyil> fair enough

[11:03] <tyil> I'm not aware of any license to slap on Dockerfiles in particular that could do a better job for the intended purposes (make it available for free as in freedom, to anyone who wants to make something free as in freedom)

[11:04] <tyil> I don't think the Dockerfiles matter that much to most people anyway, licensed or not, as they'd use the images themselves

[11:07] <patrickb> I suspect there is none. All free licences I'm aware of build on the concept of being activated when the piece in question is distributed or serviced (AGPL). This usually doesn't happen with dockerfiles.

[11:07] <patrickb> True that it doesn't matter much for dockerfiles though.

[11:08] <patrickb> Except for people being unfamiliar with licenses and avoiding the docker files because they think it'd taint the software they build using the resulting docker images...

[11:14] <tyil> I'm not sure what I can do to resolve such simple misunderstandings, though

[11:17] *** reach_satori left
[11:21] *** bobby left
[11:23] *** bobby joined
[11:27] *** andrzejku joined
[11:33] *** ekexium left
[11:33] *** Bob- joined
[11:34] *** llfourn left
[11:34] *** bobby left
[11:34] *** llfourn joined
[11:35] *** ekexium joined
[11:39] *** llfourn left
[11:45] *** Sgeo left
[11:46] <lizmat> weekly: http://www.khanate.co.uk/blog/tag/weekly-challenge-1/

[11:46] <notable6> lizmat, Noted!

[11:46] *** Sgeo joined
[11:47] *** molaf left
[11:48] *** lucasb left
[11:51] <cpan-p6> New module released to CPAN! Acme::Cow (0.0.1) by 03ELIZABETH

[11:51] *** Black_Ribbon left
[11:51] <tadzik> :o

[11:52] <tadzik> this is great :D

[11:54] *** reach_satori joined
[11:57] <lizmat> tadzik: you mean the cow ?

[12:02] <tyil> lizmat: ty, your module confirmed cpan-p6 to be still working as intended :D

[12:03] <tyil> now I can also start on making it say updated when there's an earlier version of it available in my db :3

[12:03] <tyil> and hopefully a command to make a paste containing all new and updated modules of the past 7 days 

[12:06] <tadzik> lizmat: yes :)

[12:07] <cpan-p6> New module released to CPAN! Acme::Cow (0.0.2) by 03ELIZABETH

[12:07] *** xtreak left
[12:11] *** reach_satori left
[12:11] *** xtreak joined
[12:15] *** zakharyas left
[12:15] *** llfourn joined
[12:18] *** ravenousmoose joined
[12:24] *** llfourn left
[12:25] *** llfourn joined
[12:31] *** SergiusUA joined
[12:33] <kawaii> does anyone have any idea why this results in an output of `Level 5 1234 is now tied to`? :) https://www.irccloud.com/pastebin/vw5rKJFD/

[12:33] *** llfourn left
[12:33] <kawaii> how does one unpack a regex match into multiple scalars?

[12:34] <sena_kun> m: my ($foo, $bar) = ('ab' ~~ /('a') ('b')/).List; say $foo; say $bar;

[12:34] <camelia> rakudo-moar b5843b0e3: OUTPUT: «｢a｣␤｢b｣␤»

[12:34] *** llfourn joined
[12:34] <sena_kun> kawaii, something like ^?

[12:34] <kawaii> looks to be what I'm looking for :)

[12:35] <moritz> through at +<< in front if you want to convert to integers

[12:35] <moritz> *a

[12:35] <moritz> m: my $in = '12 34'; my ($a, $b) = +«($in ~~ /(\d+) \s+ (\d+)/).List

[12:36] <camelia> rakudo-moar b5843b0e3: ( no output )

[12:36] <moritz> m: my $in = '12 34'; my ($a, $b) = +«($in ~~ /(\d+) \s+ (\d+)/).List; say :$a.perl, :$b.perl

[12:36] <camelia> rakudo-moar b5843b0e3: OUTPUT: «:a(12):b(34)␤»

[12:36] <kawaii> the role-ids are used as strings by the target API, so no need :)

[12:37] <sena_kun> m: my ($foo, $bar) = ~<<('ab' ~~ /('a') ('b')/).List; say $foo; say $bar;

[12:37] <camelia> rakudo-moar b5843b0e3: OUTPUT: «a␤b␤»

[12:37] <lizmat> m: my ($foo, $bar) = ~<<('ab' ~~ /('a') ('b')/); say $foo; say $bar;   # don't need the List

[12:37] <camelia> rakudo-moar b5843b0e3: OUTPUT: «a␤b␤»

[12:38] <lizmat> afk&

[12:38] <Altreus> ~<< seems more subtle than .List

[12:38] <ugexe> m: my ($foo, $bar) = ("ab" ~~ /("a") ("b")/)>>.Str; say $foo; say $bar;

[12:38] <kawaii> lizmat++ :)

[12:38] <camelia> rakudo-moar b5843b0e3: OUTPUT: «a␤b␤»

[12:38] <kawaii> works perfectly

[12:38] <kawaii> `Level 7 is now tied to 1234567`

[12:38] <ugexe> just let >> turn it into a list

[12:38] <ugexe> oh thats what lizmat did :)

[12:39] <Altreus> What if one needs .Int and the other .Str?

[12:39] <timotimo> try >>.&var :)

[12:39] <timotimo> you'll get IntStr or just Str

[12:39] <ugexe> type them as Str() and Int()

[12:39] <timotimo> or RatStr, ComplexStr, NumStr

[12:40] <ugexe> well that doesn't work either

[12:40] <Altreus> m: my (Int $foo, Str $bar) = ("1 01020" ~~ /(\d+) \s+ (\d+)/)>>.&var; say $foo.WHAT; say $bar.WHAT;

[12:40] <camelia> rakudo-moar b5843b0e3: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Undeclared routine:␤    var used at line 1. Did you mean 'VAR', 'val'?␤␤»

[12:40] <ugexe> m: my (Str() $foo, Int() $bar) = ("ab" ~~ /("a") ("1")/)>>.Str; say $foo.WHAT; say $bar.WHAT;

[12:40] <camelia> rakudo-moar b5843b0e3: OUTPUT: «Use of Nil in string context␤(Str)␤(Any)␤  in block <unit> at <tmp> line 1␤»

[12:40] <ugexe> m: my (Str() $foo, Int() $bar) = ("ab" ~~ /("a") ("a")/)>>.Str; say $foo.WHAT; say $bar.WHAT;

[12:40] <camelia> rakudo-moar b5843b0e3: OUTPUT: «Use of Nil in string context␤(Str)␤(Any)␤  in block <unit> at <tmp> line 1␤»

[12:40] <Altreus> oh heck

[12:41] <Altreus> timotimo: is that what you meant by >>.&var ?

[12:41] <ugexe> wait what?

[12:41] <timotimo> yeah

[12:41] <ugexe> m: my (Str() $foo, Int() $bar) = ("ab" ~~ /("a") ("a")/)>>.Str; say $foo.WHAT; say $bar.WHAT;

[12:41] <camelia> rakudo-moar b5843b0e3: OUTPUT: «Use of Nil in string context␤(Str)␤(Any)␤  in block <unit> at <tmp> line 1␤»

[12:41] <Altreus> ugexe: you used "a" twice

[12:41] <ugexe> m: my (Str() $foo, Int() $bar) = ("ab" ~~ /("a") ("b")/)>>.Str; say $foo.WHAT; say $bar.WHAT;

[12:41] <camelia> rakudo-moar b5843b0e3: OUTPUT: «(Str)␤(Str)␤»

[12:41] <Altreus> there we are xD

[12:41] <Altreus> timotimo: I'm not sure it worked

[12:41] <timotimo> yeah, must match, else it'll be empty

[12:41] <ugexe> the only differenc ein those two is one has "a", "a", and the other "a", "b"

[12:41] <ugexe> but their output is quite different

[12:42] <ugexe> oh god nevermind

[12:42] <ugexe> too early :/

[12:44] *** llfourn left
[12:44] *** antoniogamiz left
[12:45] *** llfourn joined
[12:45] <Altreus> m: my (Int $foo, Str $bar) = ("1 01020" ~~ /(\d+) \s+ (\d+)/)>>.&val; say $foo.WHAT; say $bar.WHAT;

[12:45] <camelia> rakudo-moar b5843b0e3: OUTPUT: «Value of type Match uselessly passed to val()␤  in block <unit> at <tmp> line 1␤Value of type Match uselessly passed to val()␤  in block <unit> at <tmp> line 1␤Type check failed in assignment to $foo; expected Int but got Match (Match.new(from…»

[12:45] *** xtreak_ joined
[12:46] <Altreus> ¯\(._.)/¯

[12:46] <timotimo> oh, oops

[12:46] *** AlexDaniel joined
[12:48] *** xtreak left
[12:49] *** llfourn left
[12:50] *** yoleaux joined
[12:50] *** ChanServ sets mode: +v yoleaux

[12:50] *** llfourn joined
[12:50] *** epony left
[12:55] <Altreus> ugexe: can't help but notice that your example put 'b' into an Int() and then said it was a Str

[12:55] <Altreus> Feels like perl6's type system might have some gaps

[12:56] <Altreus> where a gap is a thing that violates POLA

[12:57] <timotimo> principle of least astonishment?

[12:58] <Altreus> just so

[12:58] <timotimo> m: my Int() $foo = "a"

[12:58] <camelia> rakudo-moar b5843b0e3: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Coercion Int(Any) is insufficiently type-like to qualify a variable␤at <tmp>:1␤------> 3my Int() $foo7⏏5 = "a"␤    expecting any of:␤        constraint␤»

[12:58] *** domidumont1 left
[12:58] <timotimo> it perhaps shouldn't have allowed that code to compile at all?

[12:58] *** llfourn left
[12:59] <Altreus> yes either DWIM or die trying

[12:59] *** llfourn joined
[12:59] *** Sigyn left
[13:00] *** Sigyn joined
[13:04] *** epony joined
[13:04] *** llfourn left
[13:05] *** llfourn joined
[13:06] *** xtreak_ left
[13:09] *** molaf joined
[13:09] *** llfourn left
[13:10] *** llfourn joined
[13:12] *** domidumont joined
[13:15] *** llfourn left
[13:15] *** llfourn joined
[13:16] *** molaf left
[13:19] *** xtreak joined
[13:20] *** llfourn left
[13:20] *** llfourn joined
[13:25] *** llfourn left
[13:25] *** llfourn joined
[13:27] *** zakharyas joined
[13:29] *** AlexDaniel left
[13:31] *** llfourn left
[13:31] *** llfourn joined
[13:36] *** llfourn left
[13:36] *** llfourn joined
[13:37] *** pistacchio joined
[13:38] <pistacchio> hi, a couple of question. Is it possible, while instantiating an object, to reference a just-assigned property?

[13:39] <pistacchio> for instance Object.new(property1 => 42, property2 => property1 * 2) or something like that?

[13:39] <sena_kun> no, as they are passed as named arguments(i.e. pairs) and don't have values yet. However, you can make such a link in the class body itself.

[13:40] <sena_kun> m: class A { has $.a; has $.b = $!a * 3 }; A.new(a => 10).say

[13:40] <camelia> rakudo-moar b5843b0e3: OUTPUT: «A.new(a => 10, b => 30)␤»

[13:40] <sena_kun> m: class A { has $.a; has $.b = $!a * 3 }; A.new(a => 10, b => 15).say

[13:40] <camelia> rakudo-moar b5843b0e3: OUTPUT: «A.new(a => 10, b => 15)␤»

[13:40] <sena_kun> pistacchio, what about ^?

[13:41] *** llfourn left
[13:41] *** cpan-p6 left
[13:41] *** llfourn joined
[13:41] *** cpan-p6 joined
[13:41] *** cpan-p6 left
[13:41] *** cpan-p6 joined
[13:41] <pistacchio> an unrelated question. is there any place in the community where one can get its code reviewed for best practices / check if the code is perl6-y?

[13:42] <pistacchio> @sena_kun thank you. so $.b is actually a getter for $.a, right? does that mean that at every access $.b is re-calculated?

[13:43] <sena_kun> asking here, I'd say. Though it works only for small gists/scripts and such, of course.

[13:44] <sena_kun> pistacchio, it depends on its placing. When you are defining an attribute with `has $.foo`, it is, in fact, a private attribute `$!foo` and a getter is created for you. But no, it is not re-calculated. When you are doing assignment in an attribute declaration, you are defining a "default value" which will be used at object creation time.

[13:45] <sena_kun> so it is calculated only once - at object creation. and if you will give `b` a value, it will be used instead of the default one.

[13:45] <sena_kun> If you want to have a stronger linking between your attributes, I'd go some another way. But you have asked about object instantiation time.

[13:46] *** llfourn left
[13:46] *** llfourn joined
[13:49] <sena_kun> if you are working with a class attribute from the inside, I'd always just use `$!foo` instead of `$.foo`.

[13:49] <sena_kun> you can read more at https://docs.perl6.org/language/classtut#State <- this section.

[13:50] <pistacchio> @sena_kun yes, of course. i'm converting a simple python script that analyses some csv to perl6, but the language is huge and i don't know how to check if i'm doing more work because there are more idiomatic ways of doing what i'm doing

[13:50] <pistacchio> and thanks for the link!

[13:51] *** llfourn left
[13:51] <sena_kun> pistacchio, for such cases you can ask here and it is very likely to get someone's help here with a review, a help with debugging, profiling and so on.

[13:52] *** llfourn joined
[13:53] <pistacchio> great, thank @sena_kun

[13:58] *** robertle left
[14:01] *** robertle joined
[14:04] *** llfourn left
[14:04] *** llfourn joined
[14:06] *** traxex joined
[14:07] *** llfourn left
[14:07] *** llfourn joined
[14:11] *** CepriN joined
[14:11] *** xtreak left
[14:13] *** SergiusUA left
[14:18] *** llfourn left
[14:30] <pistacchio> how do i dynamically access an object's property having the property name as a string in variable?

[14:31] <ugexe> m: class Foo { has $.a; has $.b; submethod BUILD(:$!a, :$!b = $!a * 2) { }; }; say Foo.new(a => 2);

[14:31] <camelia> rakudo-moar b5843b0e3: OUTPUT: «Foo.new(a => 2, b => 4)␤»

[14:31] <pistacchio> @ugexe thanks!

[14:32] <ugexe> m: class Foo { has $.a; has $.b; submethod BUILD(:$!a, :$!b = $!a * 2) { }; }; my $property = "a"; say Foo.new(a => 2)."$a"();

[14:32] <camelia> rakudo-moar b5843b0e3: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Variable '$a' is not declared␤at <tmp>:1␤------> 3y $property = "a"; say Foo.new(a => 2)."7⏏5$a"();␤»

[14:32] <ugexe> m: class Foo { has $.a; has $.b; submethod BUILD(:$!a, :$!b = $!a * 2) { }; }; my $property = "a"; say Foo.new(a => 2)."$property"();

[14:32] <camelia> rakudo-moar b5843b0e3: OUTPUT: «2␤»

[14:33] <pistacchio> @ugexe thanks!

[14:33] *** llfourn joined
[14:36] *** cpan-p6_ joined
[14:36] *** cpan-p6_ left
[14:36] *** cpan-p6_ joined
[14:37] *** cpan-p6 left
[14:38] *** llfourn left
[14:39] *** molaf joined
[14:41] *** cpan-p6 joined
[14:41] *** cpan-p6 left
[14:41] *** cpan-p6 joined
[14:41] *** cpan-p6_ left
[14:43] *** cpan-p6 left
[14:43] *** cpan-p6 joined
[14:43] *** cpan-p6 left
[14:43] *** cpan-p6 joined
[14:48] <patrickb> tyil: https://github.com/patzim/perl6-dockerfiles <- I implemented building release versions. In case you like to pull stuff.

[14:48] <tyil> nice

[14:49] <tyil> I'll take a look once I figure out a nice way to have cpan-p6 report it's build date on .bots

[14:50] <vrurg> patrickb: you're a windows guy, as I remember. Are you?

[14:53] <tyil> patrickb: ah, build utils and git. For some zef actions one would need unzip and curl, though

[14:53] *** Shashi joined
[14:54] <tyil> I left them out of my builds because those packages make the image huge, and for running a Perl 6 applications they're not needed (but also easily installed for the install/build phase)

[14:54] <tyil> I'm wondering if I should provide two seperate variants, though

[14:54] <tyil> one as minimal as possible, just for running, and one for installing/building/testing

[14:54] *** Shashi left
[14:56] <tyil> can you explain what RELEASE does?

[14:56] <patrickb> vrurg: Not really. I'm on Linux when I can. I do have a Windows installation sitting somewhere and thus can do stuff there if necessary.

[14:57] <patrickb> tyil: internal flag to determine what the build scripts should do

[14:57] <tyil> ah, I see it now in the last file on that commit

[14:57] <patrickb> see the makefile

[14:59] <patrickb> tyil: What I'm doing now is basing another image with my application in it on the perl6 one and stripping that. This way I get to use full zef in my Dockerfile and still have a small image in the end.

[14:59] *** EWDurbin18 joined
[14:59] <EWDurbin18> Bored? Call the official freenode IRC partyline at +4521137886

[14:59] *** EWDurbin18 left
[15:01] <patrickb> tyil: btw. I added another commit to not use a temporary zef URL in build.sh. Please do not take the one with 'github.com/patzim/' in it.

[15:02] *** JayC3 joined
[15:02] <JayC3> Bored? Call the official freenode IRC partyline at +4521137886

[15:02] *** JayC3 left
[15:03] *** lucasb joined
[15:03] *** zedomega joined
[15:03] <zedomega> Bored? Call the official freenode IRC partyline at +4521137886

[15:03] *** zedomega left
[15:04] *** MoaMoaK27 joined
[15:04] <MoaMoaK27> Bored? Call the official freenode IRC partyline at +4521137886

[15:04] *** debdog12 joined
[15:04] *** MoaMoaK27 left
[15:04] *** debdog12 left
[15:05] <tyil> patrickb: I'd rather not have build-essential and other stuff in the main Docker image (I want those to be small, after all), but I do see use in a -dev image containing all those tools

[15:05] *** Sgeo_ joined
[15:05] <tyil> then one can use that -dev image to get all the deps sorted, then use a new stage based on the regular variant and copy in the resolved deps

[15:05] <tyil> and run their application

[15:06] <patrickb> tyil: Makes sense. Then it might also make sense to leave zef out.

[15:06] <tyil> this would make zef perfectly usable when it's needed, and still have a small image for running the actual application

[15:06] <tyil> yes, indeed

[15:07] *** llfourn joined
[15:08] *** Sgeo left
[15:12] *** bigfondue joined
[15:12] *** bigfondue left
[15:13] *** scimon joined
[15:13] *** S0rin6 joined
[15:14] *** S0rin6 left
[15:14] <scimon> Afternoon

[15:14] *** Sgeo__ joined
[15:16] *** cpan-p6 left
[15:16] *** llfourn left
[15:17] *** pistacchio left
[15:17] *** llfourn joined
[15:17] *** cpan-p6 joined
[15:17] *** cpan-p6 left
[15:17] *** cpan-p6 joined
[15:17] *** Sgeo_ left
[15:20] *** pistacch_ joined
[15:21] *** cpan-p6 left
[15:21] *** llfourn left
[15:22] *** cpan-p6 joined
[15:22] *** cpan-p6 left
[15:22] *** cpan-p6 joined
[15:22] *** llfourn joined
[15:24] *** cpan-p6_ joined
[15:24] *** cpan-p6_ left
[15:24] *** cpan-p6_ joined
[15:24] *** cpan-p6 left
[15:24] <tyil> .bots

[15:24] <cpan-p6_> 03cpan-p6_:121.0.1 (2019-03-28T15:22:52Z) reporting for duty! [Perl 6] 02https://git.tyil.nl/perl6/app-cpan-uploadannouncer-irc

[15:24] <tyil> \o/

[15:27] *** llfourn left
[15:28] *** llfourn joined
[15:30] *** traxex left
[15:32] *** Wahnberger joined
[15:33] <Wahnberger> hi! someone know how the status of this project? https://github.com/jnthn/cro-webapp

[15:33] *** llfourn left
[15:33] <Wahnberger> *is

[15:33] *** llfourn joined
[15:33] <sena_kun> Wahnberger, not yet publically released. Likely to be released with Cro 0.9. When it will be exactly - when it will be ready.

[15:34] <sena_kun> Wahnberger, though the API is more or less stable and it can be used for small projects, just have to install it manually, as it isn't added to the ecosystem yet.

[15:34] <Wahnberger> so it Ill become a part of cro (when its ready)

[15:34] <Wahnberger> very nice

[15:35] <sena_kun> according to jnthn - yes. :)

[15:35] <timotimo> for whatever that's worthington

[15:36] <Wahnberger> i asked some days ago for samples of websites with perl6..now ive found https://github.com/lancew/MyJudo (with Mustache) and then Jonathans Project

[15:42] <sena_kun> MyJudo looks pretty good to get inspiration from

[15:43] <Altreus> timotimo: :|

[15:43] *** llfourn left
[15:44] *** llfourn joined
[15:44] <Altreus> I appreciate a good pun but nevertheless cannot bring myself to use a happier face than that in recognition of one

[15:45] *** CepriN left
[15:45] <timotimo> it's kind of a bittersweet thing

[15:45] <Wahnberger> sena_kun: yep, escpecially how to handle routes togehter with a template system

[15:45] *** CepriN joined
[15:48] *** CepriN left
[15:48] *** pistacch_ left
[15:49] *** llfourn left
[15:49] *** pistacchio joined
[15:49] *** SergiusUA joined
[15:51] *** patrickb left
[16:02] *** jmerelo joined
[16:09] *** cpan-p6 joined
[16:09] *** cpan-p6 left
[16:09] *** cpan-p6 joined
[16:09] *** cpan-p6_ left
[16:09] *** andrzejku_ joined
[16:12] *** andrzejku left
[16:12] *** andrzejku_ is now known as andrzejku

[16:13] *** reach_satori joined
[16:15] *** cpan-p6 left
[16:16] *** cpan-p6 joined
[16:16] *** cpan-p6 left
[16:16] *** cpan-p6 joined
[16:18] *** cpan-p6_ joined
[16:18] *** cpan-p6_ left
[16:18] *** cpan-p6_ joined
[16:18] *** cpan-p6 left
[16:19] *** pistacch_ joined
[16:20] *** andrzejku left
[16:21] *** cpan-p6_ left
[16:21] *** andrzejku joined
[16:21] *** cpan-p6 joined
[16:21] *** cpan-p6 left
[16:21] *** cpan-p6 joined
[16:21] *** curan left
[16:22] *** pistacchio left
[16:23] *** domidumont left
[16:23] <xinming> m: role T { method meth () { "role meth".say; }; method test () { "get-code-object for meth in the class which have role applied".say; "test".say; }; }; class C { method meth () { "C meth".say; } };  (my C $t .= new) does T; $t.test;

[16:23] <camelia> rakudo-moar b5843b0e3: OUTPUT: «get-code-object for meth in the class which have role applied␤test␤»

[16:24] *** pistacch_ left
[16:24] <xinming> Anyone here tells me, How can I get the code object from the class C?

[16:24] <xinming> I just got an idea. bbl

[16:26] *** cpan-p6_ joined
[16:26] *** cpan-p6_ left
[16:26] *** cpan-p6_ joined
[16:26] *** cpan-p6 left
[16:29] <Geth> ¦ doc: a9b2310075 | (JJ Merelo)++ | doc/Language/py-nutshell.pod6

[16:29] <Geth> ¦ doc: Adds some more examples

[16:29] <Geth> ¦ doc: 

[16:29] <Geth> ¦ doc: Actually sigilless variables are all over the document, apparently

[16:29] <Geth> ¦ doc: with the intent indicated before: to make it look like Python. I have

[16:29] <synopsebot> Link: https://doc.perl6.org/language/py-nutshell

[16:29] <Geth> ¦ doc: added a note, and also more examples that work the same, which I guess

[16:29] <Geth> ¦ doc: illustrates also the More than One Way To Do It (theoretically

[16:29] <Geth> ¦ doc: opposite the philosophy of Python). Closes #2699

[16:29] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/a9b2310075

[16:30] *** pistacchio joined
[16:32] <tyil> it seems IRC::Client strips off the name of the bot if that is the first word in a message

[16:32] <tyil> does anyone know if this can be turned off?

[16:34] <xinming> When we apply a role to a class, the WHAT returns the class name with role names. How can I get only the class name?

[16:34] <tyil> .^name?

[16:34] <sena_kun> xinming, ^name?

[16:35] *** andrzejku_ joined
[16:35] <xinming> sena_kun: Nope, Name still returns the T+{R}

[16:35] <tyil> .^name.split("+").head? :D

[16:35] <xinming> I want the T part. But don't like to do regex myself. 

[16:35] <xinming> :-)

[16:35] <sena_kun> m: role A {}; class B does A {}; B.^name.say

[16:35] <camelia> rakudo-moar b5843b0e3: OUTPUT: «B␤»

[16:36] <xinming> m: role A {}; (my $x = 5) does A; $x.^name.say;

[16:36] <camelia> rakudo-moar b5843b0e3: OUTPUT: «Int+{A}␤»

[16:36] <sena_kun> xinming, are you doing `but` magic or something?

[16:36] <xinming> yes, with does

[16:37] <SmokeMachine> Hi! is there any thing that I can add to my tests and it would test the code inside my pod?

[16:38] <sena_kun> xinming, I don't think there is a way besides regexing.

[16:38] <jmerelo> SmokeMachine: not for the time being. It's something I wanted to do, and even created a few lines of code, but there's no straightforward way to do it.

[16:38] <xinming> sena_kun: Ok, Thanks, Then, Do we need to add helper for this? :-)

[16:38] <ugexe> look at .^mro maybe

[16:38] <jmerelo> SmokeMachine: You can use Pod::Load to load the Pods, and then some pod-filtering to extract code. 

[16:38] *** andrzejku left
[16:38] *** andrzejku_ is now known as andrzejku

[16:39] <xinming> ((C+{T}) (C) (Any) (Mu))

[16:39] <sena_kun> xinming, not sure, sounds as a pretty rare case for me. Do you need a name for debug purposes?

[16:39] <xinming> mro returns something like this.

[16:39] <xinming> sena_kun: Nope, I need to get the class name within role. need to call the "class" method within role first.

[16:39] *** drags1 joined
[16:39] <SmokeMachine> jmerelo: yes... I think Ill have to do that... :(

[16:39] <xinming> I'll later give the same.

[16:39] <tyil> m: role A {}; (my $x = 5) does A; $x.^name.split("+").first.say

[16:39] <camelia> rakudo-moar b5843b0e3: OUTPUT: «Int␤»

[16:40] * tyil shrugs

[16:40] *** drags1 left
[16:40] <sena_kun> xinming, have you tried $?CLASS(or how it is written)?

[16:42] <tyil> xinming: does my .split solution not work?

[16:42] <sena_kun> hmm, no, class gives Int+{A}, so forget it.

[16:42] *** robertle left
[16:43] *** kensanata left
[16:47] <xinming> m: class C { method meth () { "C meth".say } }; role T { method meth () { "role meth".say }; method test () { my $class = ::?CLASS.^name.split("+")[0]; ::("::$class").^lookup("meth")(self); "test".say; self.meth; }; }; (my C $t .= new) does T; $t.test;

[16:47] <camelia> rakudo-moar b5843b0e3: OUTPUT: «C meth␤test␤role meth␤»

[16:47] <xinming> sena_kun: I tried. This is what I'm trying to do.

[16:47] <tyil> xinming: role A {}; (my $x = 5) does A; $x.^name.split("+").first.say worked both on my machine and in this channel

[16:47] <xinming> m: class C { method meth () { "C meth".say } }; role T { method meth () { "role meth".say }; method test () { my $class = ::?CLASS.^name.split("+")[0]; ::($class).^lookup("meth")(self); "test".say; self.meth; }; }; (my C $t .= new) does T; $t.test;

[16:47] <camelia> rakudo-moar b5843b0e3: OUTPUT: «C meth␤test␤role meth␤»

[16:48] *** yht__ joined
[16:48] <xinming> tyil: it works, doesn't mean it's the best. I just try to find the right way to do things in perl6.

[16:48] *** yht_ left
[16:49] <xinming> sena_kun: Can I have a better version for    ::($class).^lookup("meth")(self)     ?

[16:49] <sena_kun> xinming, does "::($class)."meth"()" work?

[16:49] <xinming> can we do something like   self.::("{$class}::meth")()

[16:49] <xinming> let me try

[16:49] <sena_kun> works for me

[16:49] <ugexe> m: role A {}; (my $x = 5) does A; $x does role :: { }; say $x.^mro.first(!*.^name.contains("+"));

[16:49] <camelia> rakudo-moar b5843b0e3: OUTPUT: «(Int)␤»

[16:50] <ugexe> that gives you the class object itself

[16:50] <xinming> m: class C { method meth () { "C meth".say } }; role T { method meth () { "role meth".say }; method test () { my $class = ::?CLASS.^name.split("+")[0]; self.::($class)."meth"(); "test".say; self.meth; }; }; (my C $t .= new) does T; $t.test;

[16:50] <camelia> rakudo-moar b5843b0e3: OUTPUT: «===SORRY!===␤cannot stringify this␤»

[16:50] <sena_kun> m: class C { method meth () { "C meth".say } }; role T { method meth () { "role meth".say }; method test () { my $class = self.^name.split("+")[0]; ::("::$class")."meth"(); "test".say; self.meth; }; }; (my C $t .= new) does T; $t.test;

[16:50] <camelia> rakudo-moar b5843b0e3: OUTPUT: «C meth␤test␤role meth␤»

[16:51] <xinming> I need the "self" for the "meth"() part

[16:51] <xinming> maybe my $meth = ::("::$class")."meth"; self."$meth"();

[16:51] <sena_kun> self is passed automatically when you call it this way.

[16:53] <ugexe> i think they are trying to use fully qualified name

[16:53] <xinming> So, so,  my $c = "Class";   ::("::$c")."meth"();  will auto pass the current self as the "self" for the method call?

[16:53] <xinming> I'll try it, bbl

[16:53] <sena_kun> I think so.

[16:55] <xinming> sena_kun: it not.

[16:55] <xinming> It doesn't*

[16:55] <sena_kun> sorry, then I'm wrong.

[16:55] <xinming> m: class C { has $.a; method meth () { self.a.say; "C meth".say } }; role T { method meth () { "role meth".say }; method test () { my $class = ::?CLASS.^name.split("+")[0]; ::($class)."meth"(); "test".say; self.meth; }; }; (my C $t .= new(:a<5>)) does T; $t.test;

[16:55] <camelia> rakudo-moar b5843b0e3: OUTPUT: «Cannot look up attributes in a C type object␤  in method a at <tmp> line 1␤  in method meth at <tmp> line 1␤  in method test at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[16:55] <sena_kun> then explicit passing with lookup is probably what you want.

[16:56] <xinming> the self will be the first arg for Method object, right?

[16:56] <sena_kun> ah, of course it's not, it is called on C type object, not instance. :|

[16:56] <xinming> so,  MethodObject(self, @other-arg-is-here)

[16:57] <sena_kun> I guess that's the solution.

[16:57] <xinming> if I don't want the Method to be called for self, I can do something like  MethodObject(Nil, @other-arg-is-here)

[16:57] <xinming> hmm, Just to clarify some confusion. :-)

[16:57] <xinming> Am I right?

[16:58] <sena_kun> as with `lookup` you are getting a Method object, I am not sure "Nil" will be appropriate, but you can just pass a type object.

[16:59] <ugexe> there is always EVAL

[16:59] <ugexe> m: use MONKEY-SEE-NO-EVAL; role Foo { method bar { 42 } }; class Bar does Foo { method bar { 1 }; method go { my $class = "Foo"; EVAL("self.{$class}::bar") } }; say Bar.new.go

[16:59] <camelia> rakudo-moar b5843b0e3: OUTPUT: «42␤»

[16:59] *** llfourn joined
[17:01] <xinming> sena_kun: You are right, I just now tried, It requires a type object to be passed as first arg.

[17:01] <xinming> ugexe: I don't like EVAL. :-)

[17:01] <xinming> Thanks all for your ideas.

[17:02] <xinming> best sollution solved. :-)

[17:02] <xinming> best sollution got.

[17:03] *** maxim_d33_26 joined
[17:03] *** maxim_d33_26 left
[17:04] *** irietux19 joined
[17:04] *** Wahnberger left
[17:04] *** irietux19 left
[17:04] *** llfourn left
[17:05] <timotimo> you can also reach the dispatch that it normally does with a package name inside the method name part

[17:07] <timotimo> m: IntStr.new(1, "1").perl.say; IntStr.new(1, "1").Str::perl.say

[17:07] <camelia> rakudo-moar b5843b0e3: OUTPUT: «IntStr.new(1, "1")␤"1"␤»

[17:07] <timotimo> m: IntStr.new(1, "1").perl.say; IntStr.new(1, "1").Str::perl.say; IntStr.new(1, "1").dispatch:<::>("perl", Str); IntStr.new(1, "1").dispatch:<::>("perl", Int); 

[17:07] <camelia> rakudo-moar b5843b0e3: OUTPUT: «IntStr.new(1, "1")␤"1"␤»

[17:07] <timotimo> m: IntStr.new(1, "1").perl.say; IntStr.new(1, "1").Str::perl.say; IntStr.new(1, "1").dispatch:<::>("perl", Str).say; IntStr.new(1, "1").dispatch:<::>("perl", Int).say; 

[17:07] <camelia> rakudo-moar b5843b0e3: OUTPUT: «IntStr.new(1, "1")␤"1"␤"1"␤1␤»

[17:08] <timotimo> xinming, sena_kun, ugexe: ^

[17:08] <sena_kun> haha

[17:08] <ugexe> i knew the answer would be obvious

[17:08] <timotimo> "obvious" :)

[17:09] <timotimo> i got it by looking at the --target=ast of using .foo::bar

[17:11] <xinming> m: class C { has $.a; method meth () { self.a.say; "C meth".say } }; role T { method meth () { "role meth".say }; method test () { my $class = ::?CLASS.^name.split("+")[0]; self.::($class)::test(); "test".say; self.meth; }; }; (my C $t .= new(:a<5>)) does T; $t.test;

[17:11] <camelia> rakudo-moar b5843b0e3: OUTPUT: «===SORRY!===␤cannot stringify this␤»

[17:11] <xinming> m: class C { has $.a; method meth () { self.a.say; "C meth".say } }; role T { method meth () { "role meth".say }; method test () { my $class = ::?CLASS.^name.split("+")[0]; self.dispatch:<::>("test"); "test".say; self.meth; }; }; (my C $t .= new(:a<5>)) does T; $t.test;

[17:11] <camelia> rakudo-moar b5843b0e3: OUTPUT: «===SORRY!===␤MVMArray: Can't shift from an empty array␤»

[17:12] <xinming> m: class C { has $.a; method meth () { self.a.say; "C meth".say } }; role T { method meth () { "role meth".say }; method test () { my $class = ::?CLASS.^name.split("+")[0]; self.dispatch:<::>("C::test"); "test".say; self.meth; }; }; (my C $t .= new(:a<5>)) does T; $t.test;

[17:12] <camelia> rakudo-moar b5843b0e3: OUTPUT: «===SORRY!===␤MVMArray: Can't shift from an empty array␤»

[17:12] <timotimo> that's not how that works :)

[17:12] <timotimo> you pass the class type object as well as the method name

[17:12] <xinming> m: class C { has $.a; method meth () { self.a.say; "C meth".say } }; role T { method meth () { "role meth".say }; method test () { self.dispatch:<::>("test", C); "test".say; self.meth; }; }; (my C $t .= new(:a<5>)) does T; $t.test;

[17:12] <camelia> rakudo-moar b5843b0e3: OUTPUT: «Cannot find method 'test' on object of type C␤  in method test at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[17:13] <xinming> m: class C { has $.a; method meth () { self.a.say; "C meth".say } }; role T { method meth () { "role meth".say }; method test () { self.dispatch:<::>("C::test", C); "test".say; self.meth; }; }; (my C $t .= new(:a<5>)) does T; $t.test;

[17:13] <camelia> rakudo-moar b5843b0e3: OUTPUT: «Cannot find method 'C::test' on object of type C␤  in method test at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[17:13] <xinming> I did that.

[17:14] *** ravenousmoose left
[17:18] <kawaii> I have some functions that add/remove to a jsonb value in a postgresql database, when all the values are removed I'm left with `{}` in that col, so my 'list' command returns `{}` thinking it's 'something' and not null/empty, is there a way I can validate the result I pull from the database to return an alternative message?

[17:18] <xinming> m: class C { has $.a; method meth () { self.a.say; "C meth".say } }; role T { method meth () { "role meth".say }; method test () { self.dispatch:<::>("meth", C); "test".say; self.meth; }; }; (my C $t .= new(:a<5>)) does T; $t.test;

[17:18] <camelia> rakudo-moar b5843b0e3: OUTPUT: «5␤C meth␤test␤role meth␤»

[17:18] <xinming> finally, got it work.

[17:19] <xinming> timotimo: Is there a syntax sugar for     self.dispatch:<::>("meth", C);    ?

[17:19] <ugexe> self.C::method :P

[17:20] <timotimo> if it's okay that the result will have .item called on it, it should be possible to $.dispatch:<::>("meth", C)

[17:20] <timotimo> but i wouldn't expect $.C::foo to work. try it, though!

[17:20] <xinming> ugexe: what if C is a string?

[17:20] <ugexe> m: use MONKEY-SEE-NO-EVAL; role Foo { method bar { 42 } }; class Bar does Foo { method bar { 1 }; method go { my $class = "Foo"; EVAL("self.{$class}::bar") } }; say Bar.new.go

[17:20] <camelia> rakudo-moar b5843b0e3: OUTPUT: «42␤»

[17:20] <timotimo> then you'll need to call the long name of the dispatch thing

[17:21] <xinming> no eval. :-)

[17:22] <xinming> class C { has $.a; method meth () { self.a.say; "C meth".say } }; role T { method meth () { "role meth".say }; method test () { self.dispatch:<::>("meth", C); "test".say; self.meth; }; }; (my C $t .= new(:a<5>)) does T; $t.test;

[17:22] <evalable6> xinming, rakudo-moar b5843b0e3: OUTPUT: «5␤C meth␤test␤role meth␤»

[17:23] <xinming> We'll have to use the .dispatch:<::>,   the    self.::C::meth()  will work. other than that, nothing works

[17:23] *** scimon left
[17:23] <xinming> We'll get error which is can't stringify this.

[17:24] <timotimo> can you give the code for that exact error? or nopaste the output of --ll-exception somewhere?

[17:24] <ugexe> m: class Foo { method foo::bar { 42 } }; say Foo.new."foo::bar"()

[17:24] <camelia> rakudo-moar b5843b0e3: OUTPUT: «42␤»

[17:25] <lucasb> m: 1.::(1)

[17:25] <camelia> rakudo-moar b5843b0e3: OUTPUT: «===SORRY!===␤cannot stringify this␤»

[17:25] <timotimo> yeah, quotes are also the way to call methods with silly names

[17:25] <timotimo> that doesn't even have a method name! :D

[17:25] <timotimo>    at gen/moar/Perl6-Actions.nqp:6022  (/home/timo/perl6/install/share/nqp/lib/Perl6/Actions.moarvm:methodop)

[17:25] <timotimo> who wants to fix it

[17:26] <xinming> timotimo: Is this consider a missing feature?

[17:26] <xinming> for the question I asked.

[17:26] *** ekexium left
[17:26] <timotimo> which exactly?

[17:27] *** Riddick joined
[17:27] <xinming> m: class C { has $.a; method meth () { self.a.say; "C meth".say } }; role T { method^Ceth () { "role meth".say }; method test () { self.::("C::meth")::meth; "test".say; self.

[17:27] <camelia> rakudo-moar b5843b0e3: OUTPUT: «===SORRY!===␤cannot stringify this␤»

[17:27] <xinming> methny; }; }; (my C $t .= new(:a<5>)) does T; $t.test;

[17:28] *** Riddick left
[17:28] <xinming> m: class C { has $.a; method meth () { self.a.say; "C meth".say } }; role T { method meth () { "role meth".say }; method test () { self.::(::("C"))::meth; "test".say; self.meth; }; }; (my C $t .= new(:a<5>)) does T; $t.test;

[17:28] <camelia> rakudo-moar b5843b0e3: OUTPUT: «===SORRY!===␤cannot stringify this␤»

[17:28] <xinming> self.::(::("C"))::meth;   <--- This part.

[17:28] <timotimo> not sure. the error should surely be better

[17:28] <ugexe> m: role Bar { method bar { 69 } }; class Foo does Bar { method Bar::bar { 42 } }; say Foo.new.Bar::bar()

[17:28] <camelia> rakudo-moar b5843b0e3: OUTPUT: «69␤»

[17:29] <ugexe> m: role Bar { method bar { 69 } }; class Foo does Bar { method Bar::bar { 42 } }; say Foo.new."Bar::bar"()

[17:29] <camelia> rakudo-moar b5843b0e3: OUTPUT: «42␤»

[17:29] <ugexe> i assume this is why it cannot do what you ask

[17:30] <xinming> m: class C { has $.a; method meth () { self.a.say; "C meth".say } }; role T { method meth () { "role meth".say }; method test () { self."C::test"(); "test".say; self.meth; }; }; (my C $t .= new(:a<5>)) does T; $t.test;

[17:30] <camelia> rakudo-moar b5843b0e3: OUTPUT: «No such method 'C::test' for invocant of type 'C+{T}'␤  in method test at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[17:30] <xinming> m: class C { has $.a; method meth () { self.a.say; "C meth".say } }; role T { method meth () { "role meth".say }; method test () { self."C::meth"(); "test".say; self.meth; }; }; (my C $t .= new(:a<5>)) does T; $t.test;

[17:30] <camelia> rakudo-moar b5843b0e3: OUTPUT: «No such method 'C::meth' for invocant of type 'C+{T}'␤  in method test at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[17:30] <xinming> ugexe: With 'does', that doesn't work. I'll try something else

[17:31] <timotimo> like ugexe says, that's already syntax for something else

[17:31] *** robertle joined
[17:31] *** absentia17 joined
[17:32] *** absentia17 left
[17:32] <xinming> m: class C { has $.a; method meth () { self.a.say; "C meth".say } }; role T { method meth () { "role meth".say }; method test () { my $class = self.^name.split("+").first; $class.say; self."{$class}::meth"(); "test".say; self.meth; }; }; (my C $t .= new(:a<5>)) does T; $t.test;

[17:32] <camelia> rakudo-moar b5843b0e3: OUTPUT: «C␤No such method 'C::meth' for invocant of type 'C+{T}'␤  in method test at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[17:34] <xinming> I think I understand why we need the dispatch version

[17:35] *** dakkar left
[17:39] *** llfourn joined
[17:43] <jmerelo> .seen chsanch

[17:43] <yoleaux> I saw chsanch 13 Nov 2018 12:57Z in #perl6: <chsanch> I've learn the hardway to never do push to master directly, mostly when working with more people, or at least limit the access to push commits to master to just the admins. But is just one of the other ways to manage the work flow

[17:43] *** llfourn left
[17:44] *** pistacchio left
[17:44] *** pistacchio joined
[17:49] *** pistacchio left
[17:53] *** SergiusUA left
[18:03] *** cpan-p6 joined
[18:03] *** cpan-p6 left
[18:03] *** cpan-p6 joined
[18:03] *** cpan-p6_ left
[18:18] *** iqubic joined
[18:18] *** iqubic left
[18:20] *** kylese joined
[18:21] *** skids joined
[18:21] *** llfourn joined
[18:25] *** sauvin left
[18:26] *** llfourn left
[18:26] *** pistacchio joined
[18:32] *** rnd_gen joined
[18:32] *** rnd_gen left
[18:34] *** [Sno] joined
[18:44] *** MidCheck left
[18:46] *** irdr left
[18:46] *** Black_Ribbon joined
[18:47] *** irdr joined
[18:47] *** zakharyas left
[18:54] *** llfourn joined
[18:57] *** domidumont joined
[18:57] <xinming> m: {}.perl.say;

[18:57] <camelia> rakudo-moar b5843b0e3: OUTPUT: «{}␤»

[18:58] *** klaxa3 joined
[18:58] <xinming> m: ({ +1; }).perl.say;  (-> { }).perl.say;

[18:58] <camelia> rakudo-moar b5843b0e3: OUTPUT: «-> ;; $_? is raw { #`(Block|77600280) ... }␤->  { #`(Block|77606832) ... }␤»

[18:58] *** klaxa3 left
[18:58] <xinming> So, { }  as block is different from -> { }       am I right?

[18:58] *** llfourn left
[19:02] <vrurg> xinming: No, it's same Block.

[19:03] <vrurg> Pointy has a non-empty signature, that's all.

[19:05] *** Guest67700 joined
[19:05] *** Guest67700 left
[19:10] *** dosaboy6 joined
[19:10] *** dosaboy6 left
[19:14] <timotimo> { } has an optional $_ positional parameter, which -> { } does not have

[19:20] *** shinobi_cl joined
[19:20] <shinobi_cl> Hi all

[19:20] *** molaf left
[19:23] <timotimo> yo

[19:28] <sena_kun> o/

[19:28] <xinming> m: my $f = start { sleep 1 }; my @arr = ^4; my @t = @arr.map: { my $t = $_; $f.then(-> { sleep $t; $t.say; }) }; await Promise.allof(@t).then({ "doen".say; });

[19:28] <camelia> rakudo-moar b5843b0e3: OUTPUT: «doen␤»

[19:28] <xinming> m: my $f = start { sleep 1 }; my @arr = ^4; my @t = @arr.map: { my $t = $_; $f.then({ sleep $t; $t.say; }) }; await Promise.allof(@t).then({ "doen".say; });

[19:29] <camelia> rakudo-moar b5843b0e3: OUTPUT: «0␤1␤2␤3␤doen␤»

[19:29] <xinming> :-)

[19:29] <xinming> timotimo: Can you tell me why the poiny doesn't work, while the bare block work in then?

[19:29] <xinming> It takes me quite a while to find the differences

[19:30] <sena_kun> m: my $f = start { sleep 1 }; my @arr = ^4; my @t = @arr.map: { my $t = $_; $f.then(-> $_ { sleep $t; $t.say; }) }; await Promise.allof(@t).then({ "doen".say; });

[19:31] <camelia> rakudo-moar b5843b0e3: OUTPUT: «0␤1␤2␤3␤doen␤»

[19:32] <xinming> Then,   -> { }       { }      -> $_ { }     are different?

[19:33] <sena_kun> well, first one explicitly takes 0 arguments, second one takes implicitly 1 argument($_), third one takes explicitly 1 argument($_).

[19:34] <sena_kun> I am not an expert though. :| But my guess is that `then` passes result of the Promise as `$_` into the block, and when body of `then` callback rejects it, it somehow isn't executed.

[19:34] <sena_kun> thus `{}` and `-> $_ {}` with a promise result argument(implicit and explicit) are executed, while block that ignores the result is not.

[19:34] <xinming> I think so, that's why someone here can help me clarify this, or maybe we can add warnings to tell user the use of   -> {  }   is wrong

[19:36] <sena_kun> m: my $a = Promise.new; $a.then(-> { 1.say }); $a.keep; sleep 0.5;

[19:36] <camelia> rakudo-moar b5843b0e3: ( no output )

[19:36] <sena_kun> m: my $a = Promise.new; $a.then({ 1.say }); $a.keep; sleep 0.5;

[19:36] <camelia> rakudo-moar b5843b0e3: OUTPUT: «1␤»

[19:37] <sena_kun> I wonder if it seems like a bug.

[19:39] *** aindilis left
[19:41] <xinming> sena_kun: I'd say it's a bug. :-)

[19:42] <xinming> But need someone who can clarify this

[19:42] <sena_kun> https://github.com/rakudo/rakudo/blob/master/src/core/Promise.pm6#L179 <- the best thing I can do is to find the implementation code piece. :)

[19:45] <sena_kun> though I wonder how a Block is coerced into Promise there.

[19:45] <xinming> I know it's perl6, But I can't read the source. :-)

[19:46] *** llfourn joined
[19:47] *** d-fence_23 joined
[19:47] *** netrino joined
[19:47] *** d-fence_23 left
[19:49] *** domidumont left
[19:52] *** pistacchio left
[19:52] *** pistacchio joined
[19:56] *** llfourn left
[20:02] *** pistacchio left
[20:03] *** pistacchio joined
[20:06] *** blueness29 joined
[20:06] *** blueness29 left
[20:09] *** llfourn joined
[20:10] <timotimo> it's not a bug

[20:10] <timotimo> the resulting promise is surely set to Broken

[20:11] <timotimo> m: my $trigger = Promise.new; my $result = $trigger.then(-> { say "blah" }); $trigger.keep; say $result.status; say await $result

[20:11] <camelia> rakudo-moar b5843b0e3: OUTPUT: «Planned␤An operation first awaited:␤  in block <unit> at <tmp> line 1␤␤Died with the exception:␤    Too many positionals passed; expected 0 arguments but got 1␤      in block  at <tmp> line 1␤␤»

[20:11] <timotimo> m: my $trigger = Promise.new; my $result = $trigger.then(-> { say "blah" }); $trigger.keep; sleep 0.1; say $result.status; say await $result

[20:11] <camelia> rakudo-moar b5843b0e3: OUTPUT: «Broken␤An operation first awaited:␤  in block <unit> at <tmp> line 1␤␤Died with the exception:␤    Too many positionals passed; expected 0 arguments but got 1␤      in block  at <tmp> line 1␤␤»

[20:11] <timotimo> Promise.allof will just give you a promise that is kept when all promises have changed away from "Planned"

[20:11] <timotimo> whether or not all of them are Kept or one, more, or all of them are Broken doesn't matter to that one

[20:12] <timotimo> you'll instead just want to "await @t

[20:12] <timotimo> "

[20:12] *** SCHAPiE left
[20:17] *** SCHAPiE joined
[20:19] *** llfourn left
[20:26] *** zachk joined
[20:28] *** zachk left
[20:28] *** zachk joined
[20:30] *** Guest21615 joined
[20:30] *** Guest21615 left
[20:32] *** MidCheck joined
[20:32] <xinming> timotimo: Thanks for the explanation.

[20:52] *** antoniogamiz joined
[20:52] <antoniogamiz> \o/

[20:54] *** netrino_ joined
[20:54] *** netrino left
[21:04] *** molaf joined
[21:05] *** RaycatWhoDat joined
[21:07] <antoniogamiz> mmmm what's the standard?

[21:07] <El_Che> weekly: https://twitter.com/omengue/status/1111373440794058752

[21:07] <notable6> El_Che, Noted!

[21:07] <antoniogamiz> I'm getting this failed test from Test::META

[21:07] <antoniogamiz>     # license ‘GPL-v3.0’ is not one of the standardized SPDX license identifiers.

[21:08] <El_Che> .tell pmurias: https://twitter.com/omengue/status/1111373440794058752

[21:08] <yoleaux> El_Che: What kind of a name is "pmurias:"?!

[21:08] *** Xliff joined
[21:08] <El_Che> .tell pmurias https://twitter.com/omengue/status/1111373440794058752

[21:08] <yoleaux> El_Che: I'll pass your message to pmurias.

[21:08] <Xliff> \o

[21:09] <Xliff> Has anyone worked on a way to create a "array" of CStructs?

[21:09] <Xliff> Not pointers to CStructs, just (CStruct *)

[21:12] *** skids left
[21:15] *** wraithm1 joined
[21:15] *** wraithm1 left
[21:16] <RaycatWhoDat> This might be a faux pas but what compiled languages do you guys like using?

[21:17] <RaycatWhoDat> I'm finding myself at a bit of an impassé. I have to learn one but I don't like how inflexible/unexpressive they tend to be.

[21:18] *** glenfe19 joined
[21:18] <sena_kun> antoniogamiz, https://spdx.org/licenses/ <- maybe you can find appropriate code here?

[21:18] *** glenfe19 left
[21:19] *** mdeslaur23 joined
[21:19] *** mdeslaur23 left
[21:19] <sena_kun> RaycatWhoDat, I've used Haskell in the past and it was pretty nice, though it's probably not the answer you want. :)

[21:19] <ugexe> C++ is the opposite of inflexible and unexpressive

[21:21] <RaycatWhoDat> Maybe I did something wrong. ugexe, what's your experience with it?

[21:21] <tyil> antoniogamiz: you're looking for "GPL-3.0" I think

[21:21] <sena_kun> antoniogamiz, I am having https://github.com/Altai-man/Slang-Kazu/blob/master/META6.json#L12 <- and it works...

[21:22] <RaycatWhoDat> sena_kun: What's your experience with Haskell and how does it compare with your Perl experiences?

[21:22] <RaycatWhoDat> ugexe: The latter question goes to you, too.

[21:22] *** beasty_3 joined
[21:22] *** beasty_3 left
[21:22] <tadzik> RaycatWhoDat: I found Rust nice

[21:22] <tyil> antoniogamiz: for future reference, this is the list of SPDX identifiers: https://spdx.org/licenses/

[21:23] <tadzik> the experience is completely different from Perl's though

[21:23] *** TheAvatar22 joined
[21:23] *** llfourn joined
[21:23] <tyil> it's a standardized list, thus making it easier for other applications to parse and get conclusions from, without having to guess whether it parsed something correctly

[21:23] <tadzik> it takes more effort to write the thing you want, but then it takes substancially less to test it properly and identify/fix the bugs

[21:23] <antoniogamiz> tyil: thanks, I've found the correct one1 :)

[21:23] *** TheAvatar22 left
[21:24] <tyil> huh, it looks like everyone's favourite AGPL-3.0 is actually deprecated

[21:24] <RaycatWhoDat> tadzik: Maybe I've been too jaded towards Rust. I looked at it, tried writing a file lister program, and struggled for two hours to even get basic functionality.

[21:24] <tyil> guess I should update my repos

[21:24] <RaycatWhoDat> I should give it another go.

[21:25] <tadzik> RaycatWhoDat: it's kinda like that, yes

[21:25] <tyil> I dont think feeding Go to your Rust compiler is going to help

[21:25] <tadzik> it shatters a lot of assumptions you normally have as to how the code works

[21:26] <tadzik> normally a language usually assumes that you know what you're doing

[21:26] <tadzik> rust assumes, and sometimes knows, that you don't

[21:26] <tadzik> and it can be frustrating because very often it nags you about things that really don't matter in this particular case

[21:27] *** desuwa9 joined
[21:27] *** desuwa9 left
[21:28] <antoniogamiz> sena_kun: ty

[21:28] <jnthn> jmerelo: At last found the mentor email and did the signup :)

[21:29] <RaycatWhoDat> tadzik: Interesting. I'll assume it feels less constraining as long as you play by its rules?

[21:29] <sena_kun> RaycatWhoDat, well, from small things like 99 problems to writing an imageboard engine with Yesod underneath. Haskell does a lot of things very differently compared to a lot of languages, imperative ones, but what I really appreciate is how it makes you thik in terms of data transformation processes and chaining those processes in abstract ways.

[21:31] <RaycatWhoDat> Ah. I like that. :)

[21:31] <sena_kun> though it gets annoying when you have to work with real world things. when you work with e.g. a database using a library with generic type families with exestential types and I don't even know what I am talking about and suddenly it goes "Boom, type mismatch" with the error described in like 40-50 lines of type descriptions, that is sometimes irritating. :)

[21:31] <RaycatWhoDat> Ah. That sucks, though.

[21:33] <sena_kun> but as for now, I am super-satisfied with Perl 6. I am not really an enthusiast hacker that can just write code all the day including weekends, but I find myself having "Oh, so I have an hour this morning, let's patch some things up quickly" situation to be not so rare.

[21:33] *** llfourn left
[21:34] *** kylese left
[21:34] <sena_kun> even considering that, if you want to have some interesting (possibly mind-bending) journey, I'd recommend Haskell. If you want to write code in this language at $dayjob, well, Haskell is still not the best choice.

[21:36] <RaycatWhoDat> I'm torn, honestly. I'm a JavaScript dev by trade and as much as I enjoy JS, I'm growing tired of the ecosystem. I want to learn a new language that's fun to program in and expressive but I don't want to have another hobby language.

[21:38] <RaycatWhoDat> But then again, I could just be complaining about absolutely nothing.

[21:38] *** learningprogged joined
[21:39] *** meowray11 joined
[21:40] *** meowray11 left
[21:40] *** netameta joined
[21:40] *** netameta left
[21:41] <tadzik> RaycatWhoDat: it is, but the rules are really really unfamiliar

[21:42] <RaycatWhoDat> :(

[21:42] <tadzik> no other language I know "thinks" in terms of what function does a variable belong to, and I don't think that way either P

[21:42] <tadzik> so it's quite hard to adapt

[21:42] <tadzik> because I think I understand programming, and I write code that I'm sure will work safely: in that specific context, scope etc

[21:43] <tadzik> but Rust will think in broader terms and say "well, it's *potentially* unsafe this way"

[21:43] <tadzik> and it is ultimately right

[21:44] <tadzik> because one day I may call these few functions in different order and hurt myself

[21:45] <tadzik> so it's fundamentally different from other languages I normally use, which are very results-oriented and often force me to compensate for my lack of foresight in different ways :)

[21:46] *** grepper4 joined
[21:46] *** grepper4 left
[21:47] <tony-o> weekly: https://deathbyperl6.com/zef-plugins-a-very-alpha-glimpse/

[21:47] <notable6> tony-o, Noted!

[21:47] <tony-o> jmerelo: ^

[21:55] <antoniogamiz> mmm how do you avoid adding use lib "lib" when you are developing a module?

[21:55] <antoniogamiz> I have to add that line to each file where I want to use the module :/

[21:56] *** RaycatWhoDat left
[22:00] <jnthn> antoniogamiz: One option is to invoke `perl6 -Ilib` instead (I have my IDE do it for me, so don't even have to remember). You can also set PERL6LIB=lib in the environment. 

[22:00] *** Khisanth left
[22:00] <antoniogamiz> jnthn: :oooooooooooooooooooo thanks a lot!!!!! :DDD

[22:03] *** ctilmes joined
[22:04] <ctilmes> Xliff: re: array of CStructs, I tried but had trouble.  See my workaround here: https://github.com/CurtTilmes/perl6-dbmysql/blob/master/lib/DB/MySQL/Native.pm6#L142

[22:05] <vrurg> "If builders built houses the way programmers built programs, the first woodpecker to come along would destroy civilization." –  current Configure.pl reminds me about this quote...

[22:05] <Xliff> ctilmes++ # Thanks! Love that comment, btw! =)

[22:07] <tony-o> antoniogamiz: perl6 -Ilib 

[22:08] <Xliff> m: role A does Positional { method AT-POS(Int $f) { self + 3 }; }; my $a = 1 but A; say $a[5];

[22:08] <camelia> rakudo-moar b5bf7cd4f: OUTPUT: «4␤»

[22:08] <Xliff> m: role A does Positional { method AT-POS(Int $f) { self + 3 + $f }; }; my $a = 1 but A; say $a[5];

[22:08] <camelia> rakudo-moar b5bf7cd4f: OUTPUT: «9␤»

[22:10] <tony-o> vrurg: lol

[22:11] <tony-o> jnthn: what IDE do you use?

[22:11] <sena_kun> tony-o, well, he wrote "my IDE", so... (Comma)

[22:12] <jnthn> Hah...I didn't mean it in *that* sense, but yeah, I guess it is that too :)

[22:12] *** Khisanth joined
[22:13] <tony-o> looks p cool

[22:13] <sena_kun> I wouldn't consider that a pun, but a tiny double meaning joke - certainly. ;)

[22:13] <tony-o> i'll count it as a pun

[22:15] <antoniogamiz> tony-o: thanks :D

[22:15] <antoniogamiz> I'm using atom 

[22:17] * vrurg is unlucky with IDEs. None works properly for me. :(

[22:18] *** geordi18 joined
[22:18] <jnthn> antoniogamiz: I think there's a way to get atom to run your script, and presumably to sneak the -Ilib in there too

[22:18] *** geordi18 left
[22:20] <vrurg> Regarding Configure.pl: anybody knows if there is reason in gen_nqp() to iterate over backends in the order of jvm first, then moar and js?

[22:24] <ugexe> probably just how it came out. it was probably parrot first

[22:25] <antoniogamiz> jnthn: mm I will take a look then :D

[22:26] <ugexe> yeah, moar wasnt in the Configure.pl when the jvm conditional was added https://github.com/rakudo/rakudo/commit/499325e0fc33a151f664973a40a02c23462ba093

[22:26] <tony-o> vrurg: i use vim

[22:26] *** rindolf left
[22:27] <vrurg> tony-o: vim is hellishly slow with perl6 syntax highlight. Especially in a terminal. Basically, I currently mix atom and MacVIM. 

[22:28] <vrurg> ugexe: Probably you're right. After all, the loop ends up storing results in a hash.

[22:28] <tony-o> i don't seem to have much lagginess with the syntax, it was awfully slow when it firt came out but has gotten a lot better since

[22:29] <Xliff> ctilmes: Is there a converse operation? Say I want to create a traditional C array of structs in Perl6. Have you figured out a workaround for that?

[22:30] <Xliff> I was thinking I could do something like that with memset and a pre-allocated buffer...

[22:31] <vrurg> tony-o: I'm that lucky or I demand more. BTW, I'm using perl6 plugin because the original support is incomplete.

[22:32] <vrurg> Anyway, atom is really fast. My biggest complain with this one is that perl6 package conflicts with perl5 and the latter gets disabled.

[22:41] *** MidCheck left
[22:44] <Xliff> Has there been any thought as to providing function pointer types in NativeCall?

[22:45] <Xliff> Currently if I have &handler (Type1, Type2, Type3), I have to specify that out fully for each callback.

[22:45] <Xliff> I'm wondering if I can define the sig in a Signature object and use that with NativeCall... or a similar mechanism.

[22:46] *** shinobi_cl left
[22:53] <ctilmes> Xliff: I just call calloc with nativesizeof(my CStruct) to make an array of structs 

[22:54] <Xliff> How do you assign to a specific POS? memset?

[22:54] <Xliff> or memcpy?

[22:54] *** domme joined
[22:54] *** domme left
[22:54] <ctilmes> define AT-POS as nativecast(foo, Pointer.new(nativecast(Pointer, blah) + $count*nativesizeof(my struct)))

[22:55] <Xliff> Oh! I thought that was only for RO!

[22:55] <ctilmes> could wrap all that up into a parameterized "array-of-cstruct[my CStruct]" or some such module util real array of CStruct works

[22:55] <ctilmes> ^until

[22:55] <Xliff> So that works for assignment, too!

[22:55] <Xliff> ?

[22:56] *** FireBreath_ joined
[22:56] <ctilmes> once you nativecast() the Pointer into a CStruct repr thing, you can access its parts just like it was a single CStruct

[22:56] *** FireBreath_ left
[22:57] <ctilmes> You have to be careful with assignment to CStruct parts, some things you need to take special care with

[22:57] <Xliff> Like what?

[22:58] <ctilmes> Pointers to pointers, arrays of stuff, etc.

[22:59] <antoniogamiz> more than 5 minutes to pass simple tests

[23:00] <antoniogamiz> build-zef is quite time consuming, any solution?

[23:01] <Xliff> ctilmes: OK, thanks. I take it some of that has been dealt with in perl6-dbmysql?

[23:01] <Xliff> If so, I'll take a deeper look. 

[23:03] <ctilmes> Xliff: https://github.com/CurtTilmes/perl6-dbmysql/blob/master/lib/DB/MySQL/Native.pm6#L90

[23:07] <Xliff> Ah. SMH. right. ;)

[23:12] *** lucasb left
[23:13] <ctilmes> Xliff: https://gist.github.com/CurtTilmes/bd3b515a6995c473990635e73a4b34a5

[23:14] <ctilmes> Xliff if you need to pass it to a C function, pass $array.base in as a Pointer.

[23:14] <Xliff> So: Pointer.new($array.base) ??

[23:15] *** sena_kun left
[23:15] <ctilmes> $array.base *is* a Pointer, just use it.

[23:15] <ctilmes> sub c_function(Pointer --> int32) is native() {}, just call c_function($array.base);

[23:16] <Xliff> Ah. OK! Thanks.

[23:16] <ctilmes> if you are supposed to pass in a struct foo[], just define the Perlish native sub as 'Pointer'

[23:18] <ctilmes> If you're feeling ambitious, package up that gist, write some basic docs and push it to the ecosystem as a reusable module ;-)

[23:27] *** antoniogamiz left
[23:28] *** helldorado15 joined
[23:28] *** helldorado15 left
[23:29] *** llfourn joined
[23:34] *** llfourn left
[23:34] *** llfourn joined
[23:39] *** llfourn left
[23:40] *** gist_ joined
[23:40] *** gist_ left
[23:40] *** llfourn joined
[23:54] *** llfourn left
[23:55] *** llfourn joined
[23:57] *** aindilis joined
[23:59] *** jungleboyj8 joined
[23:59] *** jungleboyj8 left
