[00:00] *** w_richard_w joined
[00:00] *** melezhik left
[00:00] *** p6bannerbot sets mode: +v w_richard_w

[00:31] *** rindolf left
[00:39] *** leont joined
[00:39] *** p6bannerbot sets mode: +v leont

[00:39] *** sena_kun left
[00:50] *** jast left
[00:50] *** kurahaupo joined
[00:51] *** p6bannerbot sets mode: +v kurahaupo

[01:06] <Xliff> m: (^6)[* - 1].say

[01:06] <camelia> rakudo-moar 3d3578b60: OUTPUT: «5␤»

[01:08] <Xliff> m: my %a = (a => 1, b => 2, c => 3); my $e = %a<a>:delete; $e.say; %a.gist.say

[01:08] <camelia> rakudo-moar 3d3578b60: OUTPUT: «1␤{b => 2, c => 3}␤»

[01:09] <lookatme_q> m: my %a = (a => 88, b => 2, c => 3); my $e = %a<a>:delete; $e.say; %a.gist.say

[01:09] <camelia> rakudo-moar 3d3578b60: OUTPUT: «88␤{b => 2, c => 3}␤»

[01:30] *** leont left
[01:53] *** jme` joined
[01:54] *** p6bannerbot sets mode: +v jme`

[01:57] *** Cabanossi left
[01:58] *** Cabanossi joined
[01:59] *** p6bannerbot sets mode: +v Cabanossi

[02:03] *** w_richard_w left
[03:03] *** evalable6 left
[03:03] *** gregf_ left
[03:05] *** evalable6 joined
[03:05] *** p6bannerbot sets mode: +v evalable6

[03:35] *** w17t left
[03:55] *** daotoad joined
[03:56] *** p6bannerbot sets mode: +v daotoad

[04:00] <vrurg> Can't find how to create a link to another module in a pod...

[04:16] *** ferreira left
[04:30] *** Cabanossi left
[04:31] *** Cabanossi joined
[04:31] *** p6bannerbot sets mode: +v Cabanossi

[04:33] *** guifa left
[04:38] *** daotoad left
[04:38] <Kaiepi> i bought Compilers: Principles, Techniques, and Tools (2nd Edition)

[04:39] <Kaiepi> hopefully it'll help me understand perl 6 core dev better

[04:45] *** daotoad joined
[04:46] *** p6bannerbot sets mode: +v daotoad

[04:46] *** daotoad left
[05:00] *** RavBell joined
[05:00] *** p6bannerbot sets mode: +v RavBell

[05:03] <RavBell> Test message. Sending first time.

[05:07] <pony> True

[05:21] <lookatme_q> RavBell, True

[05:22] *** daotoad1 joined
[05:22] *** p6bannerbot sets mode: +v daotoad1

[05:25] *** MasterDuke left
[05:36] *** dncefan left
[05:37] *** mowcat left
[05:38] *** molaf joined
[05:39] *** p6bannerbot sets mode: +v molaf

[05:40] *** ferreira joined
[05:41] *** p6bannerbot sets mode: +v ferreira

[05:42] *** dncefan joined
[05:42] *** p6bannerbot sets mode: +v dncefan

[05:46] *** molaf left
[05:47] *** daotoad1 left
[05:58] *** curan joined
[05:58] *** p6bannerbot sets mode: +v curan

[06:14] *** kurahaupo left
[06:16] *** daemon left
[06:22] <RavBell> p6: say 'Hello!;'

[06:22] <camelia> rakudo-moar 3d3578b60: OUTPUT: «Hello!;␤»

[06:22] <RavBell> p6: say "test\ner"~~/test<?before \n'er'>/

[06:22] <camelia> rakudo-moar 3d3578b60: OUTPUT: «｢test｣␤»

[06:23] <RavBell> p6: say "test\ner"~~/test<?before ^^'er'>/

[06:23] <camelia> rakudo-moar 3d3578b60: OUTPUT: «Nil␤»

[06:23] <RavBell> Can someone  tell me why the output is different for the last two statements?

[06:24] <RavBell> If I understood it right, ^^ should match the start of a logical new line. Which is what the second of the two statements seems to be doing but the answer is Nil.

[06:25] *** jmerelo joined
[06:25] <RavBell> Am I missing something in my understanding?

[06:25] *** p6bannerbot sets mode: +v jmerelo

[06:26] <lookatme_q> RavBell, I think you missed the \n

[06:27] <lookatme_q> p6: say "test\ner"~~/test\s<?before ^^'er'>/

[06:27] <camelia> rakudo-moar 3d3578b60: OUTPUT: «｢test␤｣␤»

[06:29] <RavBell> But I isn't ^^ inside <> the same as matching after \n?

[06:29] <lookatme_q> RavBell, \n is belong to first line

[06:30] <RavBell> May be I am not understanding the difference beween ^^ and \n?

[06:31] <lookatme_q> ^^ is an anchor, not a char

[06:31] <RavBell> I thought \n is ^^ or somthing like that.

[06:31] <lookatme_q> no

[06:31] <RavBell> That means it does not match it per se?

[06:31] <lookatme_q> it's like <?before ..>, match the pos

[06:32] <lookatme_q> p6: say "test\ner"~~/<?before ^^'er'>/

[06:32] <camelia> rakudo-moar 3d3578b60: OUTPUT: «｢｣␤»

[06:32] <RavBell> It is what they call the zero-width assertions?

[06:32] <lookatme_q> you see, it's nothing

[06:32] <lookatme_q> yes

[06:32] <RavBell> ok. Thanks for clearing that up!

[06:33] <lookatme_q> p6: say "test\ner"~~/^^/

[06:33] <camelia> rakudo-moar 3d3578b60: OUTPUT: «｢｣␤»

[06:33] <lookatme_q> similar things

[06:33] <RavBell> Got you!

[06:33] <RavBell> Thanks lookatme_q!

[06:34] <lookatme_q> you welcome

[06:35] *** domidumont joined
[06:36] *** p6bannerbot sets mode: +v domidumont

[06:44] *** ferreira left
[06:45] *** ferreira joined
[06:46] *** p6bannerbot sets mode: +v ferreira

[06:48] <Geth> ¦ doc: 800a5b9704 | (JJ Merelo)++ | doc/Language/variables.pod6

[06:48] <Geth> ¦ doc: Minor corrections and reflow

[06:48] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/800a5b9704

[06:48] <Geth> ¦ doc: 4830298860 | (JJ Merelo)++ | doc/Language/contexts.pod6

[06:48] <Geth> ¦ doc: Fixes errors

[06:48] <synopsebot> Link: https://doc.perl6.org/language/variables

[06:48] <synopsebot> Link: https://doc.perl6.org/language/contexts

[06:48] <Geth> ¦ doc: 

[06:48] <Geth> ¦ doc: Basically changes say to put, which always calls Str (while say calls

[06:48] <Geth> ¦ doc: .gist). Closes #2546

[06:48] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/4830298860

[06:50] *** dncefan left
[06:51] *** domidumont left
[06:54] *** dncefan joined
[06:55] *** p6bannerbot sets mode: +v dncefan

[07:07] *** domidumont joined
[07:08] *** dct joined
[07:08] *** p6bannerbot sets mode: +v dct

[07:08] *** p6bannerbot sets mode: +v domidumont

[07:15] *** dct left
[07:26] *** dct joined
[07:26] *** p6bannerbot sets mode: +v dct

[07:27] *** reach_satori left
[07:32] *** dct left
[07:38] *** jmerelo left
[07:53] *** dct joined
[07:53] *** p6bannerbot sets mode: +v dct

[07:58] *** zacts joined
[07:58] *** p6bannerbot sets mode: +v zacts

[08:01] <Kaiepi> m: say "A͜͡".subst(rx:i/ <-[a..z]> /, '', :g)

[08:01] <camelia> rakudo-moar 3d3578b60: OUTPUT: «␤»

[08:01] <Kaiepi> how do i get this to return a?

[08:01] <Kaiepi> s/a\?/A?/

[08:01] *** reach_satori joined
[08:02] *** p6bannerbot sets mode: +v reach_satori

[08:05] <moritz> .uni A͜͡

[08:05] * moritz too old to remember bot usage

[08:05] *** reach_satori_ joined
[08:06] <moritz> m: say lc samemark ' ', 'A͜͡'

[08:06] <camelia> rakudo-moar 3d3578b60: OUTPUT: « ͜͡␤»

[08:06] <moritz> m: say lc samemark 'A͜͡', ' '

[08:06] <camelia> rakudo-moar 3d3578b60: OUTPUT: «a␤»

[08:06] <moritz> Kaiepi: ^^ like this?

[08:06] *** p6bannerbot sets mode: +v reach_satori_

[08:07] <moritz> there are also regex and substitution modifies for ignoring marks

[08:07] <Kaiepi> i need the regex modifiers

[08:08] <Kaiepi> m: say "A͜͡".subst(rx:i:ignoremark/ <-[a..z]> /, '', :g)

[08:08] *** reach_satori left
[08:08] <camelia> rakudo-moar 3d3578b60: OUTPUT: «A͜͡␤»

[08:08] <Kaiepi> hm

[08:10] <Kaiepi> m: say "A͜͡".subst(rx:i:samemark/ <-[a..z]> /, '', :g)

[08:10] <camelia> rakudo-moar 3d3578b60: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Adverb samemark not allowed on rx␤at <tmp>:1␤------> 3say "A͜͡".subst(rx:i:samemark/ <-[a..z]> /7⏏5, '', :g)␤»

[08:12] <Kaiepi> m: say "A͜͡" ~~ S:i:samemark:g/ <-[a..z]> //

[08:12] <camelia> rakudo-moar 3d3578b60: OUTPUT: «Potential difficulties:␤    Smartmatch with S/// is not useful. You can use given instead: S/// given $foo␤    at <tmp>:1␤    ------> 3say "A͜͡" ~~ 7⏏5S:i:samemark:g/ <-[a..z]> //␤True␤»

[08:12] <Kaiepi> m: say "A͜͡" ~~ s:i:samemark:g/ <-[a..z]> //

[08:12] <camelia> rakudo-moar 3d3578b60: OUTPUT: «()␤»

[08:12] <Kaiepi> m: say "A͜͡" ~~ s:i:ignoremark:g/ <-[a..z]> //

[08:12] <camelia> rakudo-moar 3d3578b60: OUTPUT: «()␤»

[08:15] <Kaiepi> m: say "A͜͡".samemark(' ').subst(rx:i:samemark/ <-[a..z]> /, '', :g)

[08:15] <camelia> rakudo-moar 3d3578b60: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Adverb samemark not allowed on rx␤at <tmp>:1␤------> 3rk(' ').subst(rx:i:samemark/ <-[a..z]> /7⏏5, '', :g)␤»

[08:15] <Kaiepi> m: say "A͜͡".samemark(' ').subst(rx:i/ <-[a..z]> /, '', :g)

[08:15] <camelia> rakudo-moar 3d3578b60: OUTPUT: «A␤»

[08:15] <Kaiepi> there we go

[08:15] <Kaiepi> thanks

[08:25] *** pmurias joined
[08:25] *** p6bannerbot sets mode: +v pmurias

[08:30] *** lizmat left
[08:32] <pmurias> masak: example of a real life assembly generation library, it seems like it would be a good thought experiment to consider how it would look like in a macroish world

[08:38] *** andrzejku joined
[08:39] *** p6bannerbot sets mode: +v andrzejku

[08:57] *** Sgeo_ joined
[08:58] *** p6bannerbot sets mode: +v Sgeo_

[09:00] *** Sgeo left
[09:01] <masak> pmurias: go on :)

[09:17] *** robertle_ joined
[09:18] *** p6bannerbot sets mode: +v robertle_

[09:21] *** zakharyas joined
[09:21] *** zacts left
[09:22] *** p6bannerbot sets mode: +v zakharyas

[09:25] *** kiwi_92 joined
[09:25] *** p6bannerbot sets mode: +v kiwi_92

[09:27] <kiwi_92> m: class C { method ^test () { "Hi" } }; dd C.new.test

[09:27] <camelia> rakudo-moar 3d3578b60: OUTPUT: «No such method 'test' for invocant of type 'C'. Did you mean any of these?␤    List␤    Set␤    gist␤    list␤␤  in block <unit> at <tmp> line 1␤␤»

[09:30] *** jast joined
[09:31] *** p6bannerbot sets mode: +v jast

[09:55] *** rindolf joined
[09:55] <gfldex> lolibloggedalittle: https://gfldex.wordpress.com/2019/01/11/iterating-past-the-finish/

[09:55] *** p6bannerbot sets mode: +v rindolf

[09:58] *** Sgeo joined
[09:58] *** p6bannerbot sets mode: +v Sgeo

[10:00] *** Sgeo_ left
[10:02] *** gregf_ joined
[10:02] *** p6bannerbot sets mode: +v gregf_

[10:09] <pmurias> masak: I don't have an authoritative answer how a Perl 6y or macroish version would look like

[10:10] <pmurias> masak: it seems to be a regular case of generating a different language, with the big difference that because assembly doesn't have structured control flow it's mostly linear

[10:13] <pmurias> masak: one possible observations is that any time we are generating an AST for an language a imperative style dsl is a different interface that could be generated automatically

[10:14] *** Sgeo_ joined
[10:15] *** p6bannerbot sets mode: +v Sgeo_

[10:18] *** Sgeo left
[10:25] *** kiwi_92 left
[10:29] <pmurias> masak: example of a Qtree from the 007 faq being turned into imperative Ruby DSL style: https://gist.github.com/pmurias/292b3ac5b672d9e690d823aca1ecc767

[10:30] *** llfourn left
[10:31] <pmurias> masak: if we take it to a logical extreme would such a tranform make sense with actuall extending of the syntax? 

[10:33] *** patrickb joined
[10:34] *** p6bannerbot sets mode: +v patrickb

[10:35] <RavBell> m: https://gist.github.com/ravbell/d94b37f1a346a1f73b5a827d9eaf7c92

[10:35] <camelia> rakudo-moar 3d3578b60: OUTPUT: «===SORRY!===␤Could not find Grammar::Tracer at line 2 in:␤    /home/camelia/.perl6␤    /home/camelia/rakudo-m-inst-2/share/perl6/site␤    /home/camelia/rakudo-m-inst-2/share/perl6/vendor␤    /home/camelia/rakudo-m-inst-2/share/perl6␤    Co…»

[10:36] *** llfourn joined
[10:36] *** p6bannerbot sets mode: +v llfourn

[10:36] <RavBell> m: https://gist.github.com/ravbell/d94b37f1a346a1f73b5a827d9eaf7c92

[10:36] <camelia> rakudo-moar 3d3578b60: OUTPUT: «Invoice Summary␤asd fasdf␤asdfasdf␤asd 123-fasdf $1234.00␤qwe {rq} [we-r_q] we␤Start Invoice Details ␤␤␤Nil␤»

[10:37] <RavBell> Not sure this is giving a Nil. I have been scratching my head whole day!

[10:38] <RavBell> Any one please help!

[10:39] *** dncefan left
[10:41] *** dncefan joined
[10:42] *** p6bannerbot sets mode: +v dncefan

[10:42] <moritz> RavBell: .parse expects to match the whole string

[10:43] <RavBell> moritz: .subparse did not work either ...

[10:45] *** dncefan left
[10:46] <timotimo> could have to do with "token" and "rule" being "no backtracking"?

[10:46] <RavBell> timotimo: Does not appear like that.

[10:47] *** dncefan joined
[10:47] <RavBell> I ran the code using Grammer::Tracer.

[10:47] <RavBell> It seems to go all the way doing the right thing, almost.

[10:47] *** p6bannerbot sets mode: +v dncefan

[10:48] <moritz> RavBell: ok, I've figured out the problem

[10:48] <moritz> RavBell:  <invoice-prelude-end>

[10:48] <moritz> wants to parse a <line>

[10:48] <moritz> but at that point in time, the <line> has already been parsed

[10:48] <timotimo> but the line part of invoice-prelude is frugal?

[10:51] <RavBell> moritz: <line>*? is used. Does that not work then?

[10:52] <RavBell> moritz: What other better way could this rule be written then?

[10:53] *** gregf_ left
[10:53] <moritz> RavBell: sorry, I'm a bit distracted right now

[10:55] <RavBell> moritz: No problem! I am just grateful that you are trying to help even in the middle of your busy schedule I guess!

[10:57] <moritz> RavBell: I think you could simplify super-word to \S+

[11:00] <RavBell> moritz: that makes sense

[11:03] *** domidumont left
[11:12] *** lizmat joined
[11:12] *** p6bannerbot sets mode: +v lizmat

[11:18] *** domidumont joined
[11:18] *** p6bannerbot sets mode: +v domidumont

[11:29] *** lucasb joined
[11:29] *** p6bannerbot sets mode: +v lucasb

[11:30] *** dncefan left
[11:32] *** sena_kun joined
[11:33] *** p6bannerbot sets mode: +v sena_kun

[11:39] *** molaf joined
[11:40] *** p6bannerbot sets mode: +v molaf

[11:41] *** dncefan joined
[11:42] *** p6bannerbot sets mode: +v dncefan

[11:57] *** pmurias left
[12:01] *** satori__ joined
[12:02] *** p6bannerbot sets mode: +v satori__

[12:03] *** reach_satori_ left
[12:17] <Xliff> ===SORRY!===

[12:17] <Xliff> Missing serialize REPR function for REPR CStruct (GTK::Compat::RGBA)

[12:17] <Xliff> ^^ What does that mean?

[12:17] <Xliff> I take it that effectively means that CStructs can't be constants?

[12:18] <lizmat> yeah, there's no way to store them in a precomp file is what that means

[12:22] <AlexDaniel> moritz: you can address bots by their name :)

[12:22] <AlexDaniel> unicodable6: A͜͡

[12:22] <unicodable6> AlexDaniel, U+0041 LATIN CAPITAL LETTER A [Lu] (A)

[12:22] <unicodable6> AlexDaniel, U+035C COMBINING DOUBLE BREVE BELOW [Mn] ( ͜)

[12:22] <unicodable6> AlexDaniel, U+0361 COMBINING DOUBLE INVERTED BREVE [Mn] ( ͡)

[12:24] *** ZzZombo joined
[12:24] *** p6bannerbot sets mode: +v ZzZombo

[12:24] *** ZzZombo left
[12:25] *** dncefan left
[12:26] *** molaf left
[12:26] *** dncefan joined
[12:26] *** pmurias joined
[12:26] *** p6bannerbot sets mode: +v pmurias

[12:26] *** p6bannerbot sets mode: +v dncefan

[12:29] *** satori__ left
[12:29] <pmurias> lizmat: re $*FULL-PRECISION dynamic variable isn't the variable being applicable to external libraries also a *serious drawback*? either all libraries that use Rats will have to work with it set (either by accident or design) or if you call an external library with it set you will have to check stuff still works

[12:30] <lizmat> pmurias: it's by design for me

[12:30] <AlexDaniel> lizmat: also, is there a way to make $*FULL-PRECISION experimental? In case we want to change it later and people start using it in their modules or in their code

[12:32] <lizmat> I guess we could put it under 6.e.PREVIEW

[12:33] <pmurias> lizmat: by the "by design" I mean if you are writing a module and using some Rats (even if you don't use it) you will have to consider that someone might call your module with $*FULL-PRECISION set

[12:33] <lizmat> why would you need to consider that ?

[12:33] <lizmat> the only thing it will do, is give you *more* precision 

[12:34] <lizmat> if a library always expects to see Rats, it's already in trouble

[12:39] *** zakharyas left
[12:40] <pmurias> lizmat: because FatRats can grow arbitrarily large

[12:41] *** domidumont left
[12:42] <pmurias> lizmat: FatRats being passed unexpectedly is fair game, if the library creates it's own Rat now it has to expect them being either Rats or FatRats

[12:44] <lizmat> but their use is completely transparent?

[12:44] <lizmat> downgrading to float isn't

[12:55] *** domidumont joined
[12:55] *** p6bannerbot sets mode: +v domidumont

[12:56] *** dncefan left
[12:57] *** dncefan joined
[12:57] *** p6bannerbot sets mode: +v dncefan

[13:00] <robertle_> perhaps we need an explicit slimrat? so that a library can deliberately choose low-precision but fast and small, no matter what the user selected for rat behavior?

[13:01] <lizmat> robertle_: but precision stays at Rat if it doesn't go out of range

[13:01] <robertle_> right, but about everything goes out of range after a few divisions

[13:01] <lizmat> and what should a slimrat do when it goes out of range?  die ?

[13:02] <robertle_> loose precision

[13:02] <lizmat> that's what a Rat is

[13:02] <lizmat> it loses precision by converting to a Num

[13:02] <El_Che> Don't call me a rat!

[13:03] <lizmat> .oO( Elizabeth Rattijsen :-)

[13:06] <El_Che> lizmat: I haven't heard that one before :)

[13:08] <robertle_> right, but isn't your proposal to selectively change that so that all rats instead convert to fatrat on overflow?

[13:08] <robertle_> perhaps I got that wrong

[13:09] <robertle_> but the slimrat idea is rubbish anyway, because you typically do not construct a rat explicitely but by saying "1 / 7"

[13:11] <robertle_> I am just saying that I would very much like a rat to convert to fatrat rather than num by default, simply because it is safer. but it is much slower as well, and in many cases you do not need the precision. so some way to say "even if the wider program wants precision, this part of the code is fine with degradation to num"  

[13:11] <robertle_> would be fab

[13:11] <timotimo> actually i don't think there's a good reason not to implement a serialize/deserialize function for CStruct

[13:28] *** satori__ joined
[13:29] *** p6bannerbot sets mode: +v satori__

[13:32] *** kurahaupo joined
[13:33] *** p6bannerbot sets mode: +v kurahaupo

[13:33] *** molaf joined
[13:34] *** p6bannerbot sets mode: +v molaf

[13:36] *** molaf left
[13:41] <lizmat> robertle_: that would imply a pragma, if you want lexical 

[13:42] <lizmat> which is problematic

[13:53] *** kurahaupo_ joined
[13:54] *** p6bannerbot sets mode: +v kurahaupo_

[13:56] *** kurahaupo left
[14:00] *** abraxxa left
[14:17] *** zakharyas joined
[14:18] *** p6bannerbot sets mode: +v zakharyas

[14:28] *** curan left
[14:38] *** AlexDani` joined
[14:39] *** p6bannerbot sets mode: +v AlexDani`

[14:42] *** AlexDaniel left
[14:44] *** AlexDani` is now known as AlexDaniel

[14:48] <Xliff> Won't the IO::Handle version of spurt and slurp close automatically?

[14:51] *** molaf joined
[14:51] *** p6bannerbot sets mode: +v molaf

[15:03] <jnthn> Don't think so

[15:04] <Xliff> s/IO::Handle/IO::Path/

[15:06] <jnthn> hah

[15:06] <jnthn> I think the IO::Path ones will :)

[15:07] <jnthn> Since you never see the handle there.

[15:07] <Xliff> OK. Docs don't make that clear, so I think I will add that wording.

[15:07] <Xliff> https://docs.perl6.org/routine/slurp <-- see bottom

[15:09] <jnthn> Yeah, worth clarifying

[15:09] <Xliff> Oh, and thanks for the reset link! ;)

[15:10] <jnthn> :)

[15:12] *** molaf left
[15:14] <Xliff> What's the best way to pass quoted strings to run?

[15:14] <Xliff> m: run 'ls', '-l'

[15:14] <camelia> rakudo-moar 86557cfd2: OUTPUT: «total 136␤drwxr-xr-x 1 camelia users   274 Jul 20  2017 Inline-Perl5␤drwxrwxr-x 1 camelia users   494 Dec 28 16:05 Perlito␤drwxr-xr-x 1 camelia users    30 Jul 16  2016 bin␤-rw-r--r-- 1 camelia users   810 Dec 31  2015 dalek-queue␤drwxrwxr-x…»

[15:15] <Xliff> m: run 'touch', '"my file"'

[15:15] <camelia> rakudo-moar 86557cfd2: ( no output )

[15:15] <Xliff> m: run 'ls', '-l'

[15:15] <camelia> rakudo-moar 86557cfd2: OUTPUT: «total 136␤-rw-r--r-- 1 camelia users     0 Jan 11 16:15 "my file"␤drwxr-xr-x 1 camelia users   274 Jul 20  2017 Inline-Perl5␤drwxrwxr-x 1 camelia users   494 Dec 28 16:05 Perlito␤drwxr-xr-x 1 camelia users    30 Jul 16  2016 bin␤-rw-r--r-- 1…»

[15:15] <Xliff> :S

[15:15] <Xliff> m: run 'cat', '"my file"'

[15:15] <camelia> rakudo-moar 86557cfd2: ( no output )

[15:15] <Xliff> m: (run 'cat', '"my file", :out).out.say'

[15:15] <camelia> rakudo-moar 86557cfd2: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Unable to parse expression in parenthesized expression; couldn't find final ')' (corresponding starter was at line 1)␤at <tmp>:1␤------> 3(run 'cat', '"my file", :out).out.say'7⏏5<EOL>␤    e…»

[15:15] <Xliff> m: (run 'cat', '"my file"', :out).out.say

[15:15] <camelia> rakudo-moar 86557cfd2: OUTPUT: «This pipe was opened for reading, not writing␤  in block <unit> at <tmp> line 1␤␤»

[15:16] <Xliff> m: (run 'cat', '"my file"', :out).out.say

[15:16] <camelia> rakudo-moar 86557cfd2: OUTPUT: «This pipe was opened for reading, not writing␤  in block <unit> at <tmp> line 1␤␤»

[15:16] <Xliff> OK. Trying this locally.

[15:17] <jnthn> I think run will already quote them for you?

[15:17] <jnthn> As in, it passes each thing as an individual argument to the program

[15:17] <Xliff> OK, but I want "quoted string" to be passed as one string.

[15:17] <Xliff> More like '"quoted string"'

[15:18] <Xliff> Think embedded-spaces

[15:20] <Xliff> OK, I get that error no matter what. Weird/.

[15:20] <jnthn> $ perl6 -e 'run "perl6", "-e", "say 42"'

[15:20] <jnthn> 42

[15:20] <tobs> Xliff: spaces only become a problem when you involve a shell. run doesn't start the program through a shell, so you should be fine without any quoting

[15:20] <jnthn> If it was splitting that on spaces there, then you'd get an error, 'cus the 42 would be taken as a program argument, not as an argument to say

[15:21] <jnthn> tobs explains it better :)

[15:21] <Xliff> Yep! I think I have it. Thanks.

[15:34] *** mowcat joined
[15:35] <Xliff> m: my @a = <aaa bbb ccc>; for @a { if / .{3..3} / { s/{ $/.Str }/ZzZ/ }; }; @a.say

[15:35] <camelia> rakudo-moar 86557cfd2: OUTPUT: «[ZzZaaa ZzZbbb ZzZccc]␤»

[15:35] <Xliff> Why is that an append instead of a replace?

[15:35] *** p6bannerbot sets mode: +v mowcat

[15:35] <Xliff> m: my @a = <aaa bbb ccc>; for @a { if / .{3..3} / { s:x/{ $/.Str }/ZzZ/ }; }; @a.say

[15:35] <camelia> rakudo-moar 86557cfd2: OUTPUT: «[ZzZaaa ZzZbbb ZzZccc]␤»

[15:36] <Xliff> m: my @a = <aaa bbb ccc>; for @a { if / .{3..3} / { $/.Str.say; s:x/{ $/.Str }/ZzZ/ }; }; @a.say

[15:36] <camelia> rakudo-moar 86557cfd2: OUTPUT: «a␤b␤c␤[ZzZaaa ZzZbbb ZzZccc]␤»

[15:36] <Xliff> m: my @a = <aaa bbb ccc>; for @a { if / ... / { $/.Str.say; s:x/{ $/.Str }/ZzZ/ }; }; @a.say

[15:36] <camelia> rakudo-moar 86557cfd2: OUTPUT: «aaa␤bbb␤ccc␤[ZzZaaa ZzZbbb ZzZccc]␤»

[15:36] <Xliff> m: my @a = <aaa bbb ccc>; for @a { if / ... / { $/.Str.say; s/{ $/.Str }/ZzZ/ }; }; @a.say

[15:36] <camelia> rakudo-moar 86557cfd2: OUTPUT: «aaa␤bbb␤ccc␤[ZzZaaa ZzZbbb ZzZccc]␤»

[15:37] <Xliff> m: my @a = <aaa bbb ccc>; for @a { if / (...) / { $/.Str.say; s/{ $/[0].Str }/ZzZ/ }; }; @a.say

[15:37] <camelia> rakudo-moar 86557cfd2: OUTPUT: «aaa␤Use of Nil in string context␤bbb␤ccc␤[ZzZaaa ZzZbbb ZzZccc]␤  in block  at <tmp> line 1␤Use of Nil in string context␤  in block  at <tmp> line 1␤Use of Nil in string context␤  in block  at <tmp> line 1␤»

[15:37] <Xliff> m: my @a = <aaa bbb ccc>; for @a { if / (...) / { $/[0].Str.say; s/{ $/[0].Str }/ZzZ/ }; }; @a.say

[15:37] <camelia> rakudo-moar 86557cfd2: OUTPUT: «aaa␤Use of Nil in string context␤bbb␤ccc␤[ZzZaaa ZzZbbb ZzZccc]␤  in block  at <tmp> line 1␤Use of Nil in string context␤  in block  at <tmp> line 1␤Use of Nil in string context␤  in block  at <tmp> line 1␤»

[15:38] <Xliff> m: my @a = <aaa bbb ccc>; for @a { if / (...) / { s/{ $/[0].Str }/ZzZ/ }; }; @a.say

[15:38] <camelia> rakudo-moar 86557cfd2: OUTPUT: «Use of Nil in string context␤[ZzZaaa ZzZbbb ZzZccc]␤  in block  at <tmp> line 1␤Use of Nil in string context␤  in block  at <tmp> line 1␤Use of Nil in string context␤  in block  at <tmp> line 1␤»

[15:38] *** MasterDuke joined
[15:38] *** p6bannerbot sets mode: +v MasterDuke

[15:38] <Xliff> m: my @a = <aaa bbb ccc>; for @a { if / (...) / { s/{ $/.Str }/ZzZ/ }; }; @a.say

[15:38] <camelia> rakudo-moar 86557cfd2: OUTPUT: «[ZzZaaa ZzZbbb ZzZccc]␤»

[15:39] <Xliff> m: my @a = <aaa bbb ccc>; for @a { / (...) /; s/{ $/.Str }/ZzZ/; }; @a.say

[15:39] <camelia> rakudo-moar 86557cfd2: OUTPUT: «[ZzZaaa ZzZbbb ZzZccc]␤»

[15:45] *** jme` left
[16:04] *** haha joined
[16:04] *** p6bannerbot sets mode: +v haha

[16:04] <haha> JOIN

[16:05] <haha> p6: say 3;

[16:05] <camelia> rakudo-moar 86557cfd2: OUTPUT: «3␤»

[16:06] *** haha left
[16:12] *** pmurias left
[16:16] *** jmerelo joined
[16:17] *** p6bannerbot sets mode: +v jmerelo

[16:28] *** domidumont left
[16:50] *** sjoshi joined
[16:50] *** p6bannerbot sets mode: +v sjoshi

[16:51] *** RavBell left
[16:58] *** sjoshi left
[17:06] *** zakharyas left
[17:09] <Xliff> m: my $a = { :check, 'do' => -> { 1 } }; $a.gist.say

[17:09] <camelia> rakudo-moar 86557cfd2: OUTPUT: «{check => True, do => ->  { #`(Block|81896440) ... }}␤»

[17:11] <tobs> :/

[17:13] <tobs> oh, I misread that. I thought it created a Block, but it did create a hash

[17:13] <tobs> s:/:):

[17:20] *** domidumont joined
[17:21] *** p6bannerbot sets mode: +v domidumont

[17:28] <Geth> ¦ doc: 98301ace31 | (Elizabeth Mattijsen)++ | doc/Type/Signature.pod6

[17:28] <Geth> ¦ doc: Add documentation for Signature.new

[17:28] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/98301ace31

[17:28] <synopsebot> Link: https://doc.perl6.org/type/Signature

[17:36] *** sjoshi joined
[17:36] *** p6bannerbot sets mode: +v sjoshi

[17:41] *** cfa joined
[17:41] *** p6bannerbot sets mode: +v cfa

[17:43] *** reportable6 left
[17:43] *** shareable6 left
[17:43] *** squashable6 left
[17:43] *** committable6 left
[17:44] *** releasable6 left
[17:44] *** bisectable6 left
[17:44] *** squashable6 joined
[17:45] *** reportable6 joined
[17:45] *** p6bannerbot sets mode: +v squashable6

[17:46] *** p6bannerbot sets mode: +v reportable6

[17:46] *** shareable6 joined
[17:46] *** ChanServ sets mode: +v shareable6

[17:47] *** p6bannerbot sets mode: +v shareable6

[17:47] *** releasable6 joined
[17:47] *** ChanServ sets mode: +v releasable6

[17:47] *** bisectable6 joined
[17:47] *** ufobat joined
[17:48] *** p6bannerbot sets mode: +v releasable6

[17:48] *** p6bannerbot sets mode: +v bisectable6

[17:48] *** p6bannerbot sets mode: +v ufobat

[17:49] *** committable6 joined
[17:49] *** i1nfusion joined
[17:49] *** p6bannerbot sets mode: +v committable6

[17:50] *** p6bannerbot sets mode: +v i1nfusion

[17:50] <cfa> 👋🏽

[17:50] <jmerelo> cfa: hi!

[17:51] <cfa> hey hey

[18:10] *** guifa joined
[18:10] *** p6bannerbot sets mode: +v guifa

[18:11] *** xi- left
[18:15] *** xi- joined
[18:15] *** p6bannerbot sets mode: +v xi-

[18:16] <guifa> Is there a way to get the invocant/self as rw without needing to tack on a parameter?  Only way I could figure out was to say method ($invocant is rw: $dummy?) { ... } 

[18:16] <yoleaux> 10 Jan 2019 12:35Z <SmokeMachine> guifa: thanks!

[18:16] <yoleaux> 10 Jan 2019 12:52Z <AlexDaniel> guifa: “There were two that are Inline::Perl5 for instance” – it's the same module

[18:17] *** robertle_ left
[18:18] *** leont joined
[18:19] *** p6bannerbot sets mode: +v leont

[18:19] <guifa> (I'm trying to do a "freeze" method for Regex that locks in place variables' values. Regex doesn't like self = rx/blah/, but it sure doesn't mind $invocant = rx/blah/ with the given method signature, but the parameter is superfluous but I couldn't get the invocant any other way other than self which keeps it not rw)

[18:25] *** sauvin left
[18:27] <lizmat> guifa: "self" is *always* the decontainerized object

[18:27] *** remi_ness joined
[18:27] <lizmat> what you did with $invocant is rw:

[18:28] <lizmat> is indeed the way to do it

[18:28] <guifa> I guess I just don't like the :$dummy? bit in the signature, that's all :-)

[18:28] *** p6bannerbot sets mode: +v remi_ness

[18:30] <tobs> m: class A { method freeze ($invocant is rw:) { $invocant = 42 } }; A.new.freeze.say

[18:30] <camelia> rakudo-moar d6b1bd2ae: OUTPUT: «Parameter '$invocant' expected a writable container, but got A value␤  in method freeze at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[18:31] <tobs> m: class A { method freeze ($invocant is rw:) { $invocant = 42 } }; ($ = A.new).freeze.say

[18:31] <camelia> rakudo-moar d6b1bd2ae: OUTPUT: «42␤»

[18:31] <tobs> guifa: you can stop with the signature after the colon

[18:32] <guifa> tobs: ah perfect!

[18:36] *** sjoshi left
[18:37] <jmerelo> lizmat: will your Signature.new provide an answer to this? https://stackoverflow.com/questions/41531393/can-i-use-a-standalone-signature-as-a-signature-in-perl-6

[18:39] <lizmat> if you're willing to also programatically create the MAIN sub, it might

[18:39] <lizmat> but generally, I think moritz' answer still applies

[18:41] *** xinming_ is now known as xinimng

[18:51] *** w17t joined
[18:51] *** p6bannerbot sets mode: +v w17t

[18:52] *** w17t left
[18:53] <jmerelo> lizmat++

[18:58] <guifa> Hrm, everything almost works.  It seems the Attribute.new() doesn't automagically create the get_value and set_value.  Probably going to be easiest to write a lightweight custom class 

[18:59] <b2gills> .tell RavBell You weren't dealing with a trailing space. I left some comments at https://gist.github.com/ravbell/d94b37f1a346a1f73b5a827d9eaf7c92

[18:59] <yoleaux> b2gills: I'll pass your message to RavBell.

[19:06] <guifa> Actually, no wait.  Something else is going weird

[19:18] *** dct left
[19:19] *** dct joined
[19:19] *** p6bannerbot sets mode: +v dct

[19:25] *** guifa left
[19:29] *** leont left
[19:31] <Geth> ¦ doc: 764b1c2ee8 | (JJ Merelo)++ | doc/Language/glossary.pod6

[19:31] <Geth> ¦ doc: Adds link and minor fixes

[19:31] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/764b1c2ee8

[19:31] <Geth> ¦ doc: 18b3e102d2 | (JJ Merelo)++ | 2 files

[19:31] <Geth> ¦ doc: Minor reflow and rewriting

[19:31] <synopsebot> Link: https://doc.perl6.org/language/glossary

[19:31] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/18b3e102d2

[19:33] *** i1nfusion left
[19:35] *** i1nfusion joined
[19:35] *** p6bannerbot sets mode: +v i1nfusion

[19:39] <Xliff> m: %a = ( toggled => -> { 1 } ); %a.gist.say

[19:39] <camelia> rakudo-moar d6b1bd2ae: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Variable '%a' is not declared␤at <tmp>:1␤------> 3<BOL>7⏏5%a = ( toggled => -> { 1 } ); %a.gist.sa␤»

[19:39] <Xliff> m: my %a = ( toggled => -> { 1 } ); %a.gist.say

[19:39] <camelia> rakudo-moar d6b1bd2ae: OUTPUT: «{toggled => ->  { #`(Block|85021944) ... }}␤»

[19:40] <Xliff> m: my $a = { toggled => -> { 1 } }; $a.gist.say

[19:40] <camelia> rakudo-moar d6b1bd2ae: OUTPUT: «{toggled => ->  { #`(Block|83038656) ... }}␤»

[19:54] *** w17t joined
[19:54] *** p6bannerbot sets mode: +v w17t

[20:05] *** lizmat left
[20:08] *** koto joined
[20:09] *** p6bannerbot sets mode: +v koto

[20:10] *** sena_kun left
[20:12] *** jmerelo left
[20:16] *** koto is now known as sena_kun

[20:18] *** lizmat joined
[20:18] *** p6bannerbot sets mode: +v lizmat

[20:24] *** dct left
[20:25] *** ufobat left
[20:25] *** ufobat joined
[20:26] *** p6bannerbot sets mode: +v ufobat

[20:28] *** i1nfusion left
[20:30] *** i1nfusion joined
[20:31] *** p6bannerbot sets mode: +v i1nfusion

[20:36] *** domidumont left
[20:38] *** lucasb left
[20:43] *** remi_ness left
[20:53] <Xliff> What's the best way to eliminate the first frame when using Backtrace.new?

[20:55] <Xliff> m: sub c { Backtrace.new[1..*].Str.say }; sub b { c(); } sub a { b() }]; a()

[20:55] <camelia> rakudo-moar d6b1bd2ae: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Strange text after block (missing semicolon or comma?)␤at <tmp>:1␤------> 3race.new[1..*].Str.say }; sub b { c(); }7⏏5 sub a { b() }]; a()␤    expecting any of:␤        infix␤        inf…»

[20:55] <Xliff> m: sub c { Backtrace.new[1..*].Str.say }; sub b { c() }; sub a { b() }; a()

[20:55] <camelia> rakudo-moar d6b1bd2ae: OUTPUT: «␤»

[20:55] <pony> m: say 001 => 1

[20:55] <camelia> rakudo-moar d6b1bd2ae: OUTPUT: «Potential difficulties:␤    Leading 0 has no meaning. If you meant to create an octal number, use '0o' prefix; like, '0o01'. If you meant to create a string, please add quotation marks.␤    at <tmp>:1␤    ------> 3say 0017⏏5 => 1␤1 => 1␤»

[20:56] <Xliff> m: sub c { Backtrace.new.Str.say }; sub b { c() }; sub a { b() }; a()

[20:56] <camelia> rakudo-moar d6b1bd2ae: OUTPUT: «  in sub c at <tmp> line 1␤  in sub b at <tmp> line 1␤  in sub a at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[20:56] <Xliff> m: sub c { Backtrace.new.[1..*].Str.say }; sub b { c() }; sub a { b() }; a()

[20:56] <camelia> rakudo-moar d6b1bd2ae: OUTPUT: «␤»

[20:56] <Xliff> m: sub c { Backtrace.new[1..*].Str.say }; sub b { c() }; sub a { b() }; a()

[20:56] <camelia> rakudo-moar d6b1bd2ae: OUTPUT: «␤»

[20:56] <Xliff> m: sub c { Backtrace.new.list[1..*].Str.say }; sub b { c() }; sub a { b() }; a()

[20:56] <camelia> rakudo-moar d6b1bd2ae: OUTPUT: «  in method new at SETTING::src/core/Backtrace.pm6 line 85␤   in sub c at <tmp> line 1␤   in sub b at <tmp> line 1␤   in sub a at <tmp> line 1␤   in block <unit> at <tmp> line 1␤␤»

[20:57] <Xliff> m: sub c { Backtrace.new.list[2..*].Str.say }; sub b { c() }; sub a { b() }; a()

[20:57] <camelia> rakudo-moar d6b1bd2ae: OUTPUT: «  in sub c at <tmp> line 1␤   in sub b at <tmp> line 1␤   in sub a at <tmp> line 1␤   in block <unit> at <tmp> line 1␤␤»

[20:57] <Xliff> m: sub c { Backtrace.new.list[3..*].Str.say }; sub b { c() }; sub a { b() }; a()

[20:57] <camelia> rakudo-moar d6b1bd2ae: OUTPUT: «  in sub b at <tmp> line 1␤   in sub a at <tmp> line 1␤   in block <unit> at <tmp> line 1␤␤»

[21:23] *** jme` joined
[21:24] *** p6bannerbot sets mode: +v jme`

[21:24] *** celeritas joined
[21:25] *** p6bannerbot sets mode: +v celeritas

[21:27] *** celeritas left
[21:28] *** robertle left
[21:39] *** Sgeo__ joined
[21:40] *** zachk joined
[21:40] *** p6bannerbot sets mode: +v Sgeo__

[21:41] *** p6bannerbot sets mode: +v zachk

[21:42] *** Sgeo_ left
[21:44] <Xliff> m: Array.^can('keys').say

[21:44] <camelia> rakudo-moar d6b1bd2ae: OUTPUT: «(Method+{is-nodal}.new Method+{is-nodal}.new)␤»

[21:45] *** zachk left
[21:45] *** zachk joined
[21:45] *** asimov.freenode.net sets mode: +v zachk

[21:45] <ufobat> what is the difference between a X::NYI.new.throw vs ... in method? i know it is something else, but semantically

[21:45] *** p6bannerbot sets mode: +v zachk

[21:45] <ufobat> isnt ... ment to be implement but it is not yet there?

[21:45] <timotimo> "stub code executed", yeah

[21:45] <timotimo> is that actually the NYI ex type?

[21:45] <timotimo> m: sub stubbed { ... }; try stubbed; say $!.perl

[21:45] <camelia> rakudo-moar d6b1bd2ae: OUTPUT: «X::StubCode.new(message => "Stub code executed")␤»

[21:45] <timotimo> ah, it's not

[21:46] <timotimo> i don't think there'd be a difference between ...-ing and doing the .throw, except there'd be the extra stack frame from the ... sub

[21:46] <ufobat> okay :)

[21:47] <Xliff> m: my regex ab { <a> \v* }; my token b { 'b'+ }; my token a { 'a'+<b>* }; my $a = 'aaaabbaba'; my $m = $a ~~ /<ab>/; $m.gist.say

[21:47] <camelia> rakudo-moar d6b1bd2ae: OUTPUT: «No such method 'a' for invocant of type 'Match'. Did you mean 'at'?␤  in regex ab at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[21:47] <Xliff> m: my regex a { ... }; my regex ab { <a> \v* }; my token b { 'b'+ }; my token a { 'a'+<b>* }; my $a = 'aaaabbaba'; my $m = $a ~~ /<ab>/; $m.gist.say

[21:47] <camelia> rakudo-moar d6b1bd2ae: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Redeclaration of method 'a'␤at <tmp>:1␤------> 3oken b { 'b'+ }; my token a { 'a'+<b>* }7⏏5; my $a = 'aaaabbaba'; my $m = $a ~~ /<a␤»

[21:48] <Xliff> m: my token a { ... }; my regex ab { <a> \v* }; my token b { 'b'+ }; my token a { 'a'+<b>* }; my $a = 'aaaabbaba'; my $m = $a ~~ /<ab>/; $m.gist.say

[21:48] <camelia> rakudo-moar d6b1bd2ae: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Redeclaration of method 'a'␤at <tmp>:1␤------> 3oken b { 'b'+ }; my token a { 'a'+<b>* }7⏏5; my $a = 'aaaabbaba'; my $m = $a ~~ /<a␤»

[21:48] <timotimo> you can't stub a token like that because ... is already valid regex syntax :D

[21:48] <Xliff> m: my token b { 'b'+ }; my token a { 'a'+<b>* }; my regex ab { <a> \v* };  my $a = 'aaaabbaba'; my $m = $a ~~ /<ab>/; $m.gist.say

[21:48] <camelia> rakudo-moar d6b1bd2ae: OUTPUT: «｢aaaabb｣␤ ab => ｢aaaabb｣␤  a => ｢aaaabb｣␤   b => ｢bb｣␤»

[21:49] <Xliff> m: my token b { 'b'+ }; my token a { 'a'+<b>* }; my regex ab { <a> \v* };  my $a = 'aaaabbaba'; my $m = $a ~~ /<ab>+/; $m.gist.say

[21:49] <camelia> rakudo-moar d6b1bd2ae: OUTPUT: «｢aaaabbaba｣␤ ab => ｢aaaabb｣␤  a => ｢aaaabb｣␤   b => ｢bb｣␤ ab => ｢ab｣␤  a => ｢ab｣␤   b => ｢b｣␤ ab => ｢a｣␤  a => ｢a｣␤»

[21:49] <Xliff> m: my token b { 'b'+ }; my token a { 'a'+<b>* }; my regex ab { <a> \v* };  my $a = 'aaaabbaba'; my $m = $a ~~ /<ab>+/; $m<ab>.^name.say

[21:49] <camelia> rakudo-moar d6b1bd2ae: OUTPUT: «Array␤»

[21:50] <timotimo> i mean sub lookup is already deferred so that you can have subs post-declared

[21:50] <Xliff> m: my token b { 'b'+ }; my token a { 'a'+<b>* }; my regex ab { <a> \v* };  my $a = 'aaaabbaba'; my $m = $a ~~ /<ab>+/; $m<ab><A>.^name.say

[21:50] <camelia> rakudo-moar d6b1bd2ae: OUTPUT: «Failure␤»

[21:50] <timotimo> so you don't need to stub subs

[21:50] <Xliff> m: my token b { 'b'+ }; my token a { 'a'+<b>* }; my regex ab { <a> \v* };  my $a = 'aaaabbaba'; my $m = $a ~~ /<ab>+/; $m<ab><a>.^name.say

[21:50] <camelia> rakudo-moar d6b1bd2ae: OUTPUT: «Failure␤»

[21:50] <timotimo> and "my regex" is sub-like enough

[21:50] <Xliff> m: my token b { 'b'+ }; my token a { 'a'+<b>* }; my regex ab { <a> \v* };  my $a = 'aaaabbaba'; my $m = $a ~~ /<ab>+/; $m<ab>[0]<a>.^name.say

[21:50] <camelia> rakudo-moar d6b1bd2ae: OUTPUT: «Match␤»

[21:51] <Xliff> m: my token b { 'b'+ }; my token a { 'a'+<b>* }; my regex ab { <a> \v* };  my $a = 'aaaabbaba'; my $m = $a ~~ /<ab>+/; $m<ab>[0]<a>.keys.say

[21:51] <camelia> rakudo-moar d6b1bd2ae: OUTPUT: «(b)␤»

[22:00] <Xliff> m: my token b { 'b'+ }; my token a { 'a'+<b>* }; my regex ab { <a> \v* };  my $a = 'aaaabbaba'; my $m = $a ~~ /<ab>+/; .^name.say for $m<ab>

[22:00] <camelia> rakudo-moar d6b1bd2ae: OUTPUT: «Match␤Match␤Match␤»

[22:02] <Xliff> timotimo: :-O

[22:02] <Xliff> D'oh!

[22:14] *** abaiste left
[22:16] *** abaiste joined
[22:16] *** abaiste left
[22:23] *** i1nfusion left
[22:27] *** i1nfusion joined
[22:28] *** p6bannerbot sets mode: +v i1nfusion

[22:31] <Kaiepi> i asked a question on stackoverflow that requires in-depth knowledge on how modules are compiled https://stackoverflow.com/questions/54154735/can-modules-be-hotpatched

[22:31] <Kaiepi> if anyone can help that'd be great

[22:32] *** rindolf left
[22:32] *** abaiste joined
[22:32] *** abaiste left
[22:33] <Xliff> Kaiepi: The only way I can think of is to create a closure that module runs in. If you need to hotpatch, you clear the closure and create a new one.

[22:34] <Xliff> I can't quite give you examples on how that is done, but I am doing something similar with grammars where it wouldn't work unless I ran the grammar in its own scope and dropped it later, for reloading.

[22:34] *** rindolf joined
[22:35] *** p6bannerbot sets mode: +v rindolf

[22:35] <Kaiepi> can you give an example of what you mean?

[22:38] <Xliff> Unfortunately, not.

[22:38] <Xliff> I can't think of how you'd make a reusable closure that you could run code in.

[22:39] *** random_yanek left
[22:39] <Xliff> m: my $a = { try require ::('Color') }; say ::('Color')

[22:39] <camelia> rakudo-moar d6b1bd2ae: OUTPUT: «No such symbol 'Color'␤  in block <unit> at <tmp> line 1␤␤»

[22:40] <Xliff> m: my $a = { try require ::('Color'); say ::('Color') };

[22:40] <camelia> rakudo-moar d6b1bd2ae: ( no output )

[22:40] <Xliff> m: my $a = -> { try require ::('Color'); say ::('Color') };

[22:40] <camelia> rakudo-moar d6b1bd2ae: ( no output )

[22:40] <Xliff> m: my $a = -> { try require ::('Color'); say ::('Color') }; $a()

[22:40] <camelia> rakudo-moar d6b1bd2ae: OUTPUT: «No such symbol 'Color'␤  in block <unit> at <tmp> line 1␤␤»

[22:40] <Xliff> m: my $a = -> { try require ::('NativeCall'); say ::('NativeCall') }; $a()

[22:40] <camelia> rakudo-moar d6b1bd2ae: OUTPUT: «(NativeCall)␤»

[22:40] *** patrickb left
[22:41] *** random_yanek joined
[22:41] *** p6bannerbot sets mode: +v random_yanek

[22:42] <ufobat> this means you need to encapsulate all the code that uses a module in a closure

[22:42] <Xliff> m: my $b; my $a = -> { try require ::('NativeCall'); $b = -> { say ::('NativeCall'); }; }; $b()

[22:42] <camelia> rakudo-moar d6b1bd2ae: OUTPUT: «Cannot find method 'Any' on object of type List␤  in block <unit> at <tmp> line 1␤␤»

[22:43] <Xliff> m: my $b; my $a = -> { try require ::('NativeCall'); $b = -> { say ::('NativeCall'); }; }; $a(); $b()

[22:43] <camelia> rakudo-moar d6b1bd2ae: OUTPUT: «(NativeCall)␤»

[22:43] <ufobat> use ( and i thikn requires as well ) is lexically scoped, isnt it?

[22:43] <Xliff> m: my $b; my $a = -> { try require ::('NativeCall'); $b = -> { say ::('NativeCall'); }; }; $a(); $b(); $a = ''; $b()

[22:43] <camelia> rakudo-moar d6b1bd2ae: OUTPUT: «(NativeCall)␤(NativeCall)␤»

[22:43] <Xliff> m: my $b; my $a = -> { try require ::('NativeCall'); $b = -> { say ::('NativeCall'); }; }; $a(); $b(); $a = $b = 0; $b

[22:43] <camelia> rakudo-moar d6b1bd2ae: OUTPUT: «WARNINGS for <tmp>:␤(NativeCall)␤Useless use of $b in sink context (line 1)␤»

[22:44] <Xliff> So now that closure is dropped.

[22:44] <Xliff> To reload, you'd have to recreate both $a and $a recreates $b.

[22:44] <Xliff> Something like that.

[22:46] *** i1nfusion left
[22:47] *** i1nfusion joined
[22:48] <tobs> "reusable closure that you could run code in" -- isn't that what a class is?

[22:48] *** p6bannerbot sets mode: +v i1nfusion

[22:49] * tobs sounded smart there for a moment and is going to sleep now o/

[22:51] <Xliff> LOL

[23:14] *** molaf joined
[23:15] *** p6bannerbot sets mode: +v molaf

[23:28] *** leont joined
[23:29] *** p6bannerbot sets mode: +v leont

[23:30] *** molaf left
[23:35] <timotimo> benchable6: compare HEAD my Int @foo = 1..10000; for ^1000 { say @foo.join(",").chars } ||| my int @foo = 1..10000; for ^1000 { say @foo.join(",").chars }

[23:35] <benchable6> timotimo, starting to benchmark the 1 given commit

[23:36] <benchable6> timotimo, https://gist.github.com/7792664d1b22d3589c9b13823c5655f7

[23:36] <timotimo> ha, d'oh

[23:37] <timotimo> benchable6: compare HEAD my Int @foo = 1..10000; my $result = 0; for ^200 { $result += @foo.join(",").chars }; say $result; ||| my int @foo = 1..10000; my $result = 0; for ^200 { $result += @foo.join(",").chars }; say $result

[23:37] <benchable6> timotimo, starting to benchmark the 1 given commit

[23:37] <benchable6> timotimo, https://gist.github.com/f9950c6779b9aade8740a666d0c4829b

[23:38] <timotimo> benchable6: compare HEAD my Int @foo = 1..10000; for ^1000 { } ||| my int @foo = 1..10000; for ^1000 { }

[23:38] <benchable6> timotimo, starting to benchmark the 1 given commit

[23:38] <benchable6> timotimo, https://gist.github.com/2a0c5aad699683454af78be9fa415725

[23:46] <Xliff> timotimo: \o

[23:46] <Xliff> Working on a Grammar inspector. :D

[23:47] <timotimo> oh, sweet

[23:49] <Xliff> https://github.com/Xliff/p6-VisualGrammar

[23:49] <Xliff> It's still very rough around the edges.

[23:50] <Xliff> Write the grammar in the top left window, the test to test against in the right pane, and then select Grammar -> Refresh from the menu

[23:51] *** DarthGandalf left
[23:51] *** jme` left
[23:53] *** ufobat left
[23:54] <timotimo> btw i recently had someone tell me about "smem"

[23:54] <timotimo> which is able to tell you what processes are responsible for memory usage in swap

[23:58] <TreyHarris> Under what conditions does .WHAT correctly ne .^name?

[23:59] <TreyHarris> sorry, ne "({.^name})" I should have said

