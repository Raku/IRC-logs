[00:02] *** |oLa| joined
[00:05] *** leont left
[00:10] <ugexe> https://github.com/ugexe/Perl6-App--OpenAPI--META6Validator someone should do all the rest of the work and host the service on p6c

[00:13] <ugexe> https://petstore.swagger.io/?url=https://raw.githubusercontent.com/ugexe/Perl6-App--OpenAPI--META6Validator/master/resources/openapi.json

[00:16] *** Sgeo_ joined
[00:19] *** Sgeo__ left
[00:30] *** farcas82 joined
[00:36] *** |oLa| left
[00:38] *** khisanth_ left
[00:58] *** khisanth_ joined
[00:59] *** Xliff left
[01:00] *** tyil left
[01:04] <MasterDuke> .seen donaldh

[01:04] <yoleaux> I saw donaldh 4 Dec 2018 23:38Z in #perl6: <donaldh> oh

[01:33] *** |oLa| joined
[01:34] *** mtg joined
[01:52] *** tyilanmenyn joined
[02:02] *** Kaiepi left
[02:06] *** |oLa| left
[02:10] *** farcas82 is now known as farcas82regreg

[02:16] *** tyilanmenyn is now known as tyil

[02:18] *** mtg left
[02:39] *** squashable6 left
[02:42] *** squashable6 joined
[02:55] <cpan-p6> New module released to CPAN! FindBin::libs (0.1.0) by 03LEMBARK

[03:03] *** |oLa| joined
[03:09] *** epony joined
[03:10] *** epony left
[03:11] *** epony joined
[03:20] *** Kaiepi joined
[03:37] *** |oLa| left
[04:03] *** Cabanossi left
[04:07] *** Cabanossi joined
[04:11] <cpan-p6> New module released to CPAN! FindBin::libs (0.1.1) by 03LEMBARK

[04:14] *** Sgeo_ left
[04:14] *** Sgeo_ joined
[04:30] *** aindilis joined
[04:33] *** aborazmeh left
[04:34] *** |oLa| joined
[04:37] *** reach_satori left
[04:37] *** reach_satori joined
[05:08] *** giraffe left
[05:08] *** |oLa| left
[05:09] *** giraffe joined
[05:41] *** squashable6 left
[05:47] *** squashable6 joined
[05:47] *** ChanServ sets mode: +v squashable6

[05:51] *** nadim_ joined
[05:51] *** squashable6 left
[05:55] *** squashable6 joined
[06:04] *** |oLa| joined
[06:18] *** zakharyas joined
[06:37] *** zakharyas left
[06:38] *** |oLa| left
[06:39] *** jmerelo joined
[06:44] <jmerelo> squashable6: status

[06:44] <yoleaux> 8 Jun 2019 09:58Z <Kaiepi> jmerelo: since i made a bunch of issues on undocumented supply and lock::async methods i could look into what they actually do and see if i can write up some docs for them

[06:44] <squashable6> jmerelo, Next SQUASHathon in 25 days and ≈21 hours (2019-07-06 UTC-14⌁UTC+20). See https://github.com/rakudo/rakudo/wiki/Monthly-Bug-Squash-Day

[06:45] <jmerelo> .tell Kaiepi please do

[06:45] <yoleaux> jmerelo: I'll pass your message to Kaiepi.

[06:46] <jmerelo> releasable6: status

[06:46] <releasable6> jmerelo, Next release in ≈11 days and ≈12 hours. 1 blocker. 140 out of 582 commits logged (⚠ 2 warnings)

[06:46] <releasable6> jmerelo, Details: https://gist.github.com/af9a99bc116d10b77cd65b553f237b05

[06:59] <cpan-p6> New module released to CPAN! Archive::Libarchive (0.0.11) by 03FRITH

[06:59] *** adu left
[07:35] *** |oLa| joined
[08:14] *** ravenousmoose joined
[08:29] *** rindolf joined
[08:40] *** domidumont joined
[08:43] *** Deep_Thought joined
[08:53] *** domidumont left
[08:58] *** Deep_Thought left
[08:58] *** Deep_Thought joined
[08:59] *** Deep_Thought left
[08:59] *** Deep_Thought joined
[09:01] *** leah2 left
[09:09] *** Deep_Thought left
[09:09] *** Deep_Thought joined
[09:10] *** ravenousmoose left
[09:12] *** Deep_Thought left
[09:12] *** Deep_Thought joined
[09:12] *** Deep_Thought left
[09:16] *** leah2 joined
[09:22] <lizmat> hmmm... wrt to "from-json": is there a reason why we are currently returning mutable arrays and hashes instead of immutable lists and maps ?

[09:25] <timotimo> not to my knowledge

[09:26] <jmerelo> lizmat: good point.

[09:26] <lizmat> it breaks JSON::Fast tests  :-(

[09:27] <jmerelo> lizmat: because they will be expecting mutable data structures.

[09:27] <lizmat> so I wonder how wide spread this assumption is

[09:27] <timotimo> well, they'll be is-eqv a Hash or Array probably

[09:28] <lizmat> the first I found was doing my @a := from-json, easily fixed by s/:=/=/

[09:28] *** Xliff joined
[09:29] <jmerelo> I'd like to talk for a bit, if you will, about the next squashathon

[09:29] <timotimo> how performant is assigning a List into an Array?

[09:29] <Xliff> m: my (@a, @b) = do gather for <a b c> Z <d e f> -> ($x, $y) { take $x; take $y }; @a.say; @b.say

[09:29] <camelia> rakudo-moar a643b8be1: OUTPUT: «Cannot invoke this object (REPR: Uninstantiable; Callable)␤  in block <unit> at <tmp> line 1␤␤»

[09:29] <lizmat> timotimo: I think we squeezed as much out of that as we can

[09:30] <timotimo> OK

[09:30] <Xliff> m: my (@a, @b) = do gather for <a b c> Z <d e f> -> ($x, $y) { take $x; }; @a.say; @b.say

[09:30] <camelia> rakudo-moar a643b8be1: OUTPUT: «Cannot invoke this object (REPR: Uninstantiable; Callable)␤  in block <unit> at <tmp> line 1␤␤»

[09:30] <lizmat> I mean, I can easily fix my from-json code to make hashes and arrays

[09:30] <lizmat> but it feels wrong  :-)

[09:32] <cpan-p6> New module released to CPAN! Gnome::GObject (0.13.6) by 03MARTIMM

[09:45] *** leont joined
[09:46] <jmerelo> Re: next squashathon. It does not have a topic yet. 

[09:47] <jmerelo> And https://github.com/perl6/modules.perl6.org has 29 issues. They have been mostly ignored

[09:47] <jmerelo> It's not received much love lately. 

[09:48] *** rindolf left
[09:48] <jmerelo> And it's an essential part of the infrastructure.

[09:49] <lizmat> jmerelo: sounds like a plan for the next squashathon

[09:50] <jmerelo> lizmat: OK. If no one else suggests an alternate plan, I'll just set it to that.

[09:51] <lizmat> jmerelo: also keep in mind https://github.com/perl6/problem-solving/issues/26

[09:53] <jmerelo> lizmat: I'll try to see what can be done about that. If I got it correctly, we need to generate some kind of index that it's compatible with MetaCPAN?

[09:54] <lizmat> perhaps... that is one of the questions

[09:55] <jmerelo> lizmat: I'll bear it in mind. If what you mean is to eventually merge modules.perl6.org into MetaCPAN, I'd be all for it. But for the time being, it's got to be maintained.

[09:55] *** ravenousmoose joined
[09:56] <lizmat> it indeed needs to be maintained... and whether a merge with MetaCPAN is an option, is still to be seen

[09:57] <jmerelo> lizmat: OK. It will not hurt to kind of keep that in the back of the mind, to make migration easier.

[09:57] <lizmat> right

[09:58] <jmerelo> lizmat: in general, the problem with that repo, and with most repos under the perl6/ and perl6-community-modules/ orga is that unless someone feels keenly about them, they are abandoned.

[09:58] <lizmat> indeed.. so very true  :-(

[09:59] <jmerelo> lizmat: I don't know if that should go to the problem solving repo or wherever, but devoting a squashathon from time to time feels like crapshooting

[09:59] <lizmat> maybe a toolchain summit would be more appropriate  :-)

[10:00] <jmerelo> lizmat: I'm all for that...

[10:00] * timotimo is reminded to rebuild modules.perl6.org's database

[10:05] <jmerelo> timotimo: I already did that today. I have set up a cron job for doing it daily.

[10:08] <timotimo> oh, cool

[10:08] <timotimo> well, it's running now so i probably shouldn't kill it

[10:26] <jmerelo> .tell AlexDaniel congrats on your Master's defense :-)

[10:26] <yoleaux> jmerelo: I'll pass your message to AlexDaniel.

[10:30] <nadim_> intresting! an instanciated Grammar is a Match. I am wondering what you use to dump grammars. the obvious answer would be a text editor and look at the source but I wonder how the Grammar is kept internally. 

[10:30] <nadim_> Yes, I came tothe pointwhere I want to dump grammars, and more specifically filter them, how do you do that?

[10:32] <jmerelo> nadim_: would there be anything shorter than the grammar itself? 

[10:32] <nadim_> jmerelo: that's what I meant with openingit in a text editor

[10:33] <nadim_> but I'd like to manipulate it as an object

[10:33] <timotimo> nadim_: how do you dump a class?

[10:33] <timotimo> that's the same thing :)

[10:33] <timotimo> like, the regexes, rules, and tokens of a grammar are methods

[10:34] <timotimo> m: say Grammar.^lookup("ws");

[10:34] <camelia> rakudo-moar a643b8be1: OUTPUT: «ws␤»

[10:34] <timotimo> m: say Grammar.^lookup("ws").perl

[10:34] <camelia> rakudo-moar a643b8be1: OUTPUT: «Died with X::Method::NotFound␤  in block <unit> at <tmp> line 1␤␤»

[10:34] <timotimo> m: say Grammar.^lookup("ws").WHAT

[10:34] <camelia> rakudo-moar a643b8be1: OUTPUT: «Cannot look up attributes in a NQPRoutine type object␤  in any name at gen/moar/stage2/NQPCORE.setting line 386␤  in any gist at gen/moar/stage2/NQPCORE.setting line 392␤  in block <unit> at <tmp> line 1␤␤»

[10:34] <timotimo> that's fair i guess

[10:35] <timotimo> m: grammar T { regex test { <[abc]>+ } }; say T.^lookup("test")

[10:35] <camelia> rakudo-moar a643b8be1: OUTPUT: «regex test { <[abc]>+ }␤»

[10:36] <nadim_> Cannot find method 'name': no method cache and no .^find_method

[10:37] <nadim_> so I can't dump it as a class

[10:37] <timotimo> that could be the extremely-low-level methods in there

[10:37] <timotimo> custom matching stuff implemented directly in nqp code

[10:40] <nadim_> I need to readmore about Grammars in P6 I think, and maybe play a bit with them first

[10:40] <nadim_> but it would be could to be able to dump them nicely

[10:42] <timotimo> every match object is also an instance of the grammar class it belongs to

[10:42] <timotimo> so it'll be difficult to figure out if somebody wants to dump a result or an "instance of the grammar"

[10:43] <timotimo> so the user would have to give that hint i guess

[10:45] <nadim_> hmm, so far instances are dumped as Match, what I want to dump is a Grammar:U

[10:46] <Kaiepi> m: my Lock::Async $l .= new; await $l.protect-or-queue-on-recursion({ sleep 5; await $l.protect-or-queue-on-recursion({ say 1 }); })

[10:46] <yoleaux> 06:45Z <jmerelo> Kaiepi: please do

[10:47] <Kaiepi> working on it now jmerelo 

[10:47] <nadim_> a related question, sayI have my regx a=/<another_regexp_calling_other_regexps>/;  I can't use "a" directly, ddt a; I don't even get an object to dump, P6 fails before tehcall to ddt

[10:47] <Kaiepi> m: my Lock::Async $l .= new; await $l.protect-or-queue-on-recursion({ await $l.protect-or-queue-on-recursion({ sleep 5; say 1 }); })

[10:48] <Kaiepi> m: my Lock::Async $l .= new; $l.protect-or-queue-on-recursion({ await $l.protect-or-queue-on-recursion({ sleep 5; say 1 }); })

[10:48] <Kaiepi> m: my Lock::Async $l .= new; $l.protect-or-queue-on-recursion({ await $l.protect-or-queue-on-recursion({ say 1 }); })

[10:49] <Kaiepi> m: my Lock::Async $l .= new; $l.protect-or-queue-on-recursion({ sleep 5; say 1; }); await $l.protect-or-queue-on-recursion({ say 2; });

[10:49] <Kaiepi> this is used... somehow.

[10:50] *** camelia left
[10:50] <Kaiepi> m: my Lock::Async $l .= new; $l.protect-or-queue-on-recursion({ sleep 5; say 1; }); $l.protect-or-queue-on-recursion({ say 2; });

[10:50] <evalable6> Kaiepi, rakudo-moar c0c99e77c: OUTPUT: «1␤2␤»

[10:51] <Kaiepi> there we go

[10:51] <Kaiepi> m: my Lock::Async $l .= new; $l.protect({ sleep 5; say 1; }); $l.protect({ say 2; });

[10:51] <evalable6> Kaiepi, rakudo-moar c0c99e77c: OUTPUT: «1␤2␤»

[10:51] <Kaiepi> m: my Lock::Async $l .= new; $l.protect({ sleep 5; $l.protect({ say 1; }); });

[10:52] <evalable6> Kaiepi, rakudo-moar c0c99e77c: OUTPUT: «(signal SIGHUP) «timed out after 10 seconds»»

[10:52] <Kaiepi> m: my Lock::Async $l .= new; $l.protect-or-queue-on-recursion({ sleep 5; $l.protect-or-queue-on-recursion({ say 1; }); })

[10:52] <evalable6> Kaiepi, rakudo-moar c0c99e77c: OUTPUT: «»

[10:52] <Kaiepi> m: my Lock::Async $l .= new; $l.protect-or-queue-on-recursion({ await $l.protect-or-queue-on-recursion({ say 1; }); })

[10:53] <evalable6> Kaiepi, rakudo-moar c0c99e77c: OUTPUT: «(signal SIGHUP) «timed out after 10 seconds»»

[10:53] <Kaiepi> m: my Lock::Async $l .= new; $l.protect-or-queue-on-recursion({ $l.protect-or-queue-on-recursion({ say 1; }); })

[10:53] <evalable6> Kaiepi, rakudo-moar c0c99e77c: OUTPUT: «»

[10:53] <timotimo> nadim_: regexes are subs, you have to call it &a

[10:53] <Kaiepi> m: my Lock::Async $l .= new; await $l.protect-or-queue-on-recursion({ $l.protect-or-queue-on-recursion({ say 1; }); })

[10:53] <evalable6> Kaiepi, rakudo-moar c0c99e77c: OUTPUT: «(exit code 1) 1␤Must specify a defined Awaitable to await (got an undefined Nil)␤  in block <unit> at /tmp/lXpzFK6jCy line 1␤␤»

[10:54] <timotimo> Kaiepi: protect does an await for you, i'd expect protect-or-queue-on-recursion would also await for you

[10:55] <Kaiepi> protect-or-queue-on-recursion has a case where it may return a Promise

[10:55] <Kaiepi> the comments aren't quite clear on when that's supposed to happen though

[10:56] <Kaiepi> for when the lock is locked and it wants to return Promise: # Lock is already held on the stack, so we're recursing. Queue

[10:57] <Kaiepi> for when the lock is locked and it doesn't: # Lock is held but by something else. Await it's availability.

[10:57] <Kaiepi> what is "something else"?

[10:57] <timotimo> a different piece of code?

[10:57] <timotimo> like, the thing that holds the lock isn't on the same call stack

[10:57] <nadim_> timotimo: it works better with &regex but I see that I do a .perl in ddt (yes I am lazy), it will be interesting to see how .perl does the dump

[10:57] <Kaiepi> oh

[10:58] <timotimo> which i guess corresponds to tasks as they are queued on the threadpoolscheduler and such

[10:58] <timotimo> nadim_: i'm not sure what the exact question is

[10:59] <timotimo> https://github.com/rakudo/rakudo/blob/master/src/core/Regex.pm6#L119

[10:59] <nadim_> timotimo: given a regexp that calls regexps that call regexps, I'd like to dump a structure of that. Not sure it is possible if they are represented as subs

[11:00] <timotimo> there is something that can take you a quarter of the way there, which is to inspect the NFAs, but that's only for the "declarative prefix" parts of alternations, not for anything else

[11:00] <Kaiepi> timotimo, looks like it's based on the caller chain

[11:01] <timotimo> Kaiepi: that makes sense; it'd probably look for the continuation root point to identify what the actual task is

[11:01] <nadim_> hmm, writting a grammar to parse the source of regexps to find which sub elements a regexp uses sound tedious, any other way?

[11:01] <nadim_> timotimo: lol, you answer my questions before I ask them.

[11:01] <timotimo> it's a "halting problem" issue :P

[11:03] <nadim_> Any good intro to Perl 6 grammars somewhere, not a reference manual but something to have fun reading?

[11:03] <timotimo> moritz' book is good

[11:04] <nadim_> I'll order it  then

[11:05] <nadim_> something short in the meantime, you named andrew's  video a few week ago I believe

[11:05] <nadim_> no, that was in your blog entry

[11:16] <timotimo> well, that's a very specific grammar usage example

[11:16] <timotimo> and i guess it doesn't go much into grammar's inner workings

[11:19] <Kaiepi> m: my Int $i = 0; my Lock::Async $lock .= new; await $lock.protect-or-queue-on-recursion({ cas $int, { .succ }; $lock.protect-or-queue-on-recursion({ cas $int, { .succ } }); }); say $i

[11:19] <evalable6> Kaiepi, rakudo-moar c0c99e77c: OUTPUT: «(exit code 1) 04===SORRY!04=== Error while compiling /tmp/LaFBIvuMD9␤Variabl…»

[11:19] <evalable6> Kaiepi, Full output: https://gist.github.com/41ddfb218090efa042e872d6633c65be

[11:19] <Kaiepi> m: my Int $i = 0; my Lock::Async $lock .= new; await $lock.protect-or-queue-on-recursion({ cas $i, { .succ }; $lock.protect-or-queue-on-recursion({ cas $i, { .succ } }); }); say $i

[11:19] <evalable6> Kaiepi, rakudo-moar c0c99e77c: OUTPUT: «(exit code 1) Must specify a defined Awaitable to await (got an undefined Nil)␤  in block <unit> at /tmp/DjapNvmCfT line 1␤␤»

[11:19] <Kaiepi> m: my Int $i = 0; my Lock::Async $lock .= new; $lock.protect-or-queue-on-recursion({ cas $i, { .succ }; $lock.protect-or-queue-on-recursion({ cas $i, { .succ } }); }); say $i

[11:20] <evalable6> Kaiepi, rakudo-moar c0c99e77c: OUTPUT: «1␤»

[11:20] <Kaiepi> m: my Int $i = 0; my Lock::Async $lock .= new; $lock.protect-or-queue-on-recursion({ cas $i, { .succ }; await $lock.protect-or-queue-on-recursion({ cas $i, { .succ } }); }); say $i

[11:20] <evalable6> Kaiepi, rakudo-moar c0c99e77c: OUTPUT: «(signal SIGHUP) «timed out after 10 seconds»»

[11:20] <timotimo> seems like an odd api to only sometimes return a promise and otherwise nil

[11:21] <timotimo> but the method is also not even documented, i wonder if it's spectested?

[11:21] <Kaiepi> m: my Int $i = 0; my Lock::Async $lock .= new; $lock.protect-or-queue-on-recursion({ cas $i, { .succ }; LEAVE await $lock.protect-or-queue-on-recursion({ cas $i, { .succ } }); }); say $i

[11:21] <evalable6> Kaiepi, rakudo-moar c0c99e77c: OUTPUT: «(signal SIGHUP) «timed out after 10 seconds»»

[11:21] <timotimo> it's not mentioned anywhere in t/spec/

[11:21] <timotimo> so you're officially on your own :P

[11:21] <Kaiepi> nope

[11:21] <Kaiepi> fun

[11:22] <Kaiepi> m: my Int $i = 0; my Lock::Async $lock .= new; $lock.protect-or-queue-on-recursion({ cas $i, { .succ }; $*AWAITER.await: $lock.protect-or-queue-on-recursion({ cas $i, { .succ } }); }); say $i

[11:22] <timotimo> it's probably not something you actually need?

[11:22] <evalable6> Kaiepi, rakudo-moar c0c99e77c: OUTPUT: «(signal SIGHUP) «timed out after 10 seconds»»

[11:22] <Kaiepi> i would've used it in my telnet library if i knew it existed because of a deadlock related to calling protect twice in the same caller chain

[11:23] *** sena_kun joined
[11:23] <Kaiepi> but it turned out i didn't need the locks in the first place

[11:23] <timotimo> i thought Lock::Async is what you want if you don't want recursion to immediately go through a protect call

[11:24] <timotimo> so using Lock instead of Lock::Async might be the right thing there?

[11:24] <Kaiepi> i honestly don't remember what the code looked like at all so idk

[11:25] <Kaiepi> i *think* i tried Lock and had the same issue but i'm not positive

[11:41] *** jmerelo left
[11:46] *** SCHAPiE left
[11:46] <ugexe> Lock.protect is reentrant 

[11:47] <Kaiepi> m: my Lock::Async $lock .= new; my Int $i = 0; $lock.protect-or-queue-on-recursion({ cas $i, { .succ }; $lock.with-lock-hidden-from-recursion-check({ cas $i, { .succ } }); }); say $i

[11:47] <evalable6> Kaiepi, rakudo-moar c0c99e77c: OUTPUT: «2␤»

[11:47] <Kaiepi> ok i think i understand how these undocumented methods work now

[11:48] *** SCHAPiE joined
[11:49] <ugexe> ...why use cas inside a critical section?

[11:50] <ugexe> that’s already locked 

[11:50] <ugexe> Would you not just assign directly to $i ?

[11:52] <Kaiepi> shrug

[11:53] <Kaiepi> m: my Lock::Async $lock .= new; my Int $i = 0; $lock.protect-or-queue-on-recursion({ cas $i, { .succ }; $lock.protect-or-queue-on-recursion({ cas $i, { .succ } }); }); say $i

[11:53] <evalable6> Kaiepi, rakudo-moar c0c99e77c: OUTPUT: «1␤»

[11:54] *** dyske left
[11:55] <nadim_> Is there any *existing* command line too that given a grammar (in the tools language of choice) and a text would generate a json of the grammar match and set the exit code in case of failure?

[11:55] *** dyske joined
[11:59] *** oodani left
[11:59] *** oodani joined
[12:02] *** Xliff_ joined
[12:03] *** _Xliff_ joined
[12:06] *** Xliff left
[12:06] *** Xliff_ left
[12:08] *** MilkmanDan left
[12:08] *** MilkmanDan joined
[12:27] *** aborazmeh joined
[12:27] *** aborazmeh left
[12:27] *** aborazmeh joined
[12:34] <Kaiepi> ok after documenting wtf Lock::Async.protect-or-queue-on-recursion and Lock::Async.with-lock-hidden-from-recursion-check do i understand a lot better how supplies manage to work at all

[12:35] <Kaiepi> mainly because supplies are the only thing that use them

[12:36] *** _Xliff_ left
[12:48] *** adu joined
[12:51] *** rindolf joined
[12:55] *** ChoppedBacon_ joined
[12:56] *** ChoppedBacon left
[12:56] *** ChoppedBacon_ is now known as ChoppedBacon

[12:56] <Geth> ¦ doc: Kaiepi++ created pull request #2842: Document missing Lock::Async methods

[12:56] <Geth> ¦ doc: review: https://github.com/perl6/doc/pull/2842

[12:58] *** dmaestro joined
[12:59] *** squashable6 left
[13:00] <dmaestro> design.perl6.com is not serving any pages - have the spec documents been moved anywhere temporarily (or otherwise), and can someone point me to them?

[13:02] <ugexe> you can still view them in their repository: https://github.com/perl6/specs

[13:05] *** squashable6 joined
[13:09] *** veesh left
[13:09] *** kaare__ left
[13:11] *** veesh joined
[13:12] <Kaiepi> is anyone willing to document Lock::ConditionVariable? i know nothing about how condition variables work

[13:24] *** aborazmeh left
[13:48] *** veesh left
[13:54] *** veesh joined
[13:55] *** andry joined
[13:56] *** andry left
[13:57] *** Kaiepi left
[13:57] *** dyske left
[13:57] *** dyske joined
[14:07] *** Kaiepi joined
[14:47] *** adu left
[14:47] <lizmat> weekly: https://perl6.eu/fc-matrix.html

[14:47] <notable6> lizmat, Noted!

[14:54] *** cpan-p6 left
[15:00] *** cpan-p6 joined
[15:00] *** cpan-p6 left
[15:00] *** cpan-p6 joined
[15:14] *** Xliff joined
[15:14] <Xliff> \o

[15:15] <Xliff> How can I force the generated USAGE to show up?

[15:17] <ugexe> say $*USAGE

[15:19] <Xliff> ugexe++

[15:22] <Xliff> Is there a way to emit a carriage return in comments starting with '#='?

[15:32] <Xliff> m: my @a = 'a'..'g'; sub sayLetter { $^a.say }; @a.batch(4)»&sayLetter

[15:32] <evalable6> Xliff, rakudo-moar c0c99e77c: OUTPUT: «(exit code 1) 04===SORRY!04=== Error while compiling /tmp/ssdD7yZEtw␤Malform…»

[15:32] <evalable6> Xliff, Full output: https://gist.github.com/88c798fdf31a6dbba8b1b7b5a0680e11

[15:32] <Xliff> ^^ What am I doing wrong, there?

[15:33] <Xliff> m: my @a = 'a'..'g'; sub sayLetter { $^a.say }; @a.batch(4)».sayLetter()

[15:33] <evalable6> Xliff, rakudo-moar c0c99e77c: OUTPUT: «(exit code 1) No such method 'sayLetter' for invocant of type 'Str'␤  in block <unit> at /tmp/jxKa9by_9p line 1␤␤»

[15:33] <Xliff> m: my @a = 'a'..'g'; sub sayLetter { $^a.say }; @a.batch(4)».&sayLetter()

[15:33] <evalable6> Xliff, rakudo-moar c0c99e77c: OUTPUT: «a␤b␤c␤d␤e␤f␤g␤»

[15:33] <Xliff> m: my @a = 'a'..'g'; sub sayLetter { $^a.say }; @a.batch(2)».&sayLetter()

[15:33] <evalable6> Xliff, rakudo-moar c0c99e77c: OUTPUT: «a␤b␤c␤d␤e␤f␤g␤»

[15:33] <Xliff> Nevermind! ;)

[15:37] *** adu joined
[15:43] <Xliff> m: my @a = 'a'..'g'; sub sayLetter ($a) { $a.say }; @a.batch(2)».&sayLetter()

[15:43] <evalable6> Xliff, rakudo-moar c0c99e77c: OUTPUT: «a␤b␤c␤d␤e␤f␤g␤»

[16:28] *** domidumont joined
[16:30] *** Maylay left
[16:31] *** silug_ left
[16:34] <Geth> ¦ doc: c557b5f1d2 | (Ben Davies)++ | doc/Type/Lock/Async.pod6

[16:34] <Geth> ¦ doc: Document missing Lock::Async methods

[16:34] <Geth> ¦ doc: 

[16:34] <Geth> ¦ doc: This documents Lock::Async.protect-or-queue-on-recursion and

[16:34] <Geth> ¦ doc: Lock::Async.with-lock-hidden-from-recursion-check.

[16:34] <Geth> ¦ doc: 

[16:34] <synopsebot> Link: https://doc.perl6.org/type/Lock::Async

[16:34] <Geth> ¦ doc: Fixes #2785

[16:34] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/c557b5f1d2

[16:34] <Geth> ¦ doc: d17da25331 | (Juan Julián Merelo Guervós)++ (committed using GitHub Web editor) | doc/Type/Lock/Async.pod6

[16:34] <Geth> ¦ doc: Merge pull request #2842 from Kaiepi/lock-async

[16:34] <Geth> ¦ doc: 

[16:34] <Geth> ¦ doc: Document missing Lock::Async methods

[16:34] <Geth> ¦ doc: Thanks!

[16:34] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/d17da25331

[16:35] *** Maylay joined
[16:36] <sena_kun> Kaiepi++

[16:36] *** silug joined
[16:38] <Xliff> '»' does guarantee starting on a new processor, does it?

[16:38] *** veesh left
[16:38] <Xliff> Is there any way I can force the issue?

[16:39] *** jmerelo joined
[16:40] *** veesh joined
[17:05] *** goon_ joined
[17:06] <ugexe> no it doesn't guarentee that at all

[17:08] *** veesh left
[17:09] <mst> what's an idiomatic way to do 'optional whitespace' in a grammar?

[17:09] <mst> say to be able to parse (<expr>, <expr> , <expr>)

[17:11] <jmerelo> mst: <ws>* or more likely <.ws>* without capturing

[17:13] <mst> given something like token list { '(' <expr> + % ',' ')' }

[17:13] <mst> can I (<expr><.ws>?) + % ',' ?

[17:13] <MasterDuke> mst: i think someone asked a similar question a couple days ago and jnthn or moritz had a good example

[17:13] <mst> sorry. I'm not really sure where to read up on this

[17:13] *** ravenousmoose left
[17:13] *** veesh joined
[17:13] <jmerelo> Something like this? https://stackoverflow.com/questions/56507066/whats-the-best-way-to-be-lax-on-whitespace-in-a-perl6-grammar

[17:14] <ugexe> token Trailer { [[<.OWS> <field-name>]*] *%% ',' }

[17:14] <ugexe> OWS = optional white space

[17:15] <Geth> ¦ doc: Kaiepi++ created pull request #2843: Document Kernel.free-memory and Kernel.total-memory

[17:15] <Geth> ¦ doc: review: https://github.com/perl6/doc/pull/2843

[17:15] <mst> ugexe: ooooh

[17:16] <ugexe> OWS is whatever the http equiv of <ws> is though, not some built-in token

[17:16] <mst> so .. '(' [<expr><.ws>?]+ % ',' ')' ?

[17:16] <mst> also, uh, *%% ? where do I read about that

[17:17] <mst> sorry. re-read half of moritz' book and now having a good flail

[17:17] <ugexe> its been awhile since i wrote that, but i believe it allows trailing commas, which http spec allows

[17:18] <ugexe> where % only allows the thing between items, and %% allows the after each item

[17:18] <mst> ah, presumably %% is its own op there and the * is actually part of the preceding pattern?

[17:18] <ugexe> yeah, its a quantifier on the preceding pattern

[17:18] <mst> so it's morally ([[<.OWS> <field-name>]*] *) %% ','

[17:19] <ugexe> possibly redundant. hell if i know anymore :)

[17:19] <mst> heh

[17:19] <leont> jmerelo: AFAIK <ws> also zero-matches, so <ws>* would not DWIM

[17:19] <Geth> ¦ doc: 278a1800bb | (JJ Merelo)++ | doc/Type/Backtrace.pod6

[17:19] <Geth> ¦ doc: Adds nice to Backtrace refs #2809

[17:19] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/278a1800bb

[17:19] <Geth> ¦ doc: 307a1863c7 | (JJ Merelo)++ | doc/Type/Backtrace.pod6

[17:19] <Geth> ¦ doc: Moves example to right place, refs #2809

[17:19] <synopsebot> Link: https://doc.perl6.org/type/Backtrace

[17:19] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/307a1863c7

[17:19] <Geth> ¦ doc: 560bfa0e2a | (JJ Merelo)++ | doc/Type/Backtrace.pod6

[17:19] <Geth> ¦ doc: Adds last method, closes #2809

[17:19] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/560bfa0e2a

[17:19] <jmerelo> leont: does it? 

[17:19] <Xliff> ugexe: This reads better as -- token Trailer { [[<.OWS> <field-name>]*]* %% ',' }

[17:19] <Xliff> <token><quantifier> %% <delimeter>

[17:20] <Xliff> MUST have a quantifier

[17:20] <tobs> m: say "42,    23 , 10" ~~ /(\d+)* % [ <.ws> ',' <.ws> ]/ # jmerelo

[17:20] <evalable6> tobs, rakudo-moar c0c99e77c: OUTPUT: «｢42,    23 , 10｣␤ 0 => ｢42｣␤ 0 => ｢23｣␤ 0 => ｢10｣␤»

[17:20] <tobs> m: say "42,    23 , 10" ~~ /(\d+)* % [ <.ws> ',' <.ws>* ]/ # jmerelo

[17:20] <evalable6> tobs, rakudo-moar c0c99e77c: OUTPUT: «(signal SIGHUP) «timed out after 10 seconds»»

[17:20] <jmerelo> leont, tobs: right, zero or more whitespace characters. Thanks!

[17:20] <mst> I'm now confused where you get required ws and where you get optional

[17:22] <ugexe> token OWS { [<.SP> || <.HTAB>]* }

[17:22] <ugexe> token RWS { [<.SP> || <.HTAB>]+ }

[17:22] <mst> that part I get, it's ... 'rule' makes a space implicitly <.rws> ?

[17:22] <ugexe> https://github.com/ugexe/Perl6-Grammar--HTTP/blob/master/lib/Grammar/HTTP/RFC7230.pm6 is where im pulling this from

[17:22] <ugexe> ah 

[17:23] <ugexe> im not sure i've ever used rule

[17:23] <mst> it appears to be 'token, but with :sigspace on'

[17:24] <mst> I'll keep playing

[17:33] <Geth> ¦ doc: 755b28b730 | (Ben Davies)++ | doc/Type/Kernel.pod6

[17:33] <Geth> ¦ doc: Document Kernel.free-memory and Kernel.total-memory

[17:33] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/755b28b730

[17:33] <Geth> ¦ doc: 61af23c728 | (Juan Julián Merelo Guervós)++ (committed using GitHub Web editor) | doc/Type/Kernel.pod6

[17:33] <Geth> ¦ doc: Merge pull request #2843 from Kaiepi/kernel

[17:33] <synopsebot> Link: https://doc.perl6.org/type/Kernel

[17:33] <Geth> ¦ doc: 

[17:33] <Geth> ¦ doc: Document Kernel.free-memory and Kernel.total-memory

[17:33] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/61af23c728

[17:34] <Xliff> ugexe: How do you force a task to run on a different proc?

[17:34] <MasterDuke> start

[17:34] <jmerelo> Xliff: different from what?

[17:34] <Xliff> Because when I use '»' I use batch. No matter what I set the batch size to, the code is still runs at the same speed.

[17:34] <Xliff> jmerelo: I want to parallelize some code.

[17:34] <MasterDuke> well, i'm not sure it's possible to force a difference physical processor, but start puts it on a new thread

[17:35] <MasterDuke> Xliff: >> is allowed by the spec to parallelize if/when it wants, but rakudo currently doesn't ever do it

[17:36] <jmerelo> MasterDuke: right. If there are threads available, of course. If there are no physical threads left, it might just run wherever it can

[17:36] <jmerelo> Xliff: you might try and use hyper/race. You'll notice some speedup only with big sizes, though.

[17:36] <ugexe> start doesnt always start a new thread

[17:37] <Xliff> So should I use .batch or not?

[17:37] <ugexe> .batch?

[17:37] <Xliff> @hrefs.batch($batch)».&processClass();

[17:37] <jmerelo> Xliff: you mean hyper/race? You might give it a try, and see what it buys you. 

[17:38] <Xliff> Where $batch is the number of jobs I want to run in parallel.

[17:38] <Xliff> Or should I just do....

[17:38] <Xliff> @hrefs».&processClass();

[17:38] <ugexe> you might want to look at the docs for hyper/race

[17:38] <jmerelo> Xliff: again, give it a try. As MasterDuke said above, autothreading is not implemented yet

[17:39] <ugexe> autothreading is not automatically starting threads

[17:39] <jmerelo> Xliff: hyper/race use 4 threads by default. You might use different batch/processor size, but again you'll need to experiment to get it right.

[17:39] <Xliff> OK. Will give it a try.

[17:39] <Xliff> So would that convert to...

[17:40] <Xliff> @hrefs.race(degree => $threads).&processClass();

[17:40] <ugexe> it sounds like you want batch => 1, degree => $threads

[17:40] <Xliff> OK. Trying.

[17:40] <jmerelo> Xliff: you need to use map or grep in the middle, and processClass within it

[17:41] <Xliff> Oh.... fiddlestix. jmerelo++

[17:43] <Xliff> SEGV'd

[17:44] <Xliff> I think Inline::Perl5 is giving race() some indigestion.

[17:44] <Xliff> Setting threads to anything but 1 will SEGV

[17:45] <ugexe> sounds like your code isn't thread safe

[17:45] <Xliff> Probably not, but my guess is it might have something to do with Inline::Perl5

[17:45] <Xliff> Backtrace incoming...

[17:46] <Xliff> https://paste.fedoraproject.org/paste/IR4JBrpoGiUJmw-N3jfPpw

[17:46] <Xliff> I use Inline::Perl5 for Mojo::DOM

[17:46] <Xliff> Nothing I am doing should be thread unsafe.

[17:47] <ugexe> you are sure Mojo::DOM is thread safe?

[17:47] <Xliff> No. I am not. ;)

[17:47] <ugexe> i sure as hell dont think or care about thread safety when writing perl 5

[17:48] <ugexe> so you can't say Nothing you are doing is thread unsafe

[17:48] <Xliff> Nothing on google.

[17:48] <mst> I would imagine you'd need a perl5 VM per thread for that to work?

[17:48] <Xliff> ugexe: OK, fine. Split hairs. :)

[17:48] <Xliff> Fair enough. One thread it is.

[17:51] *** clarkema joined
[17:52] <clarkema> evenign

[18:00] <moritz> hi there

[18:09] *** hythm joined
[18:16] *** antoniogamiz joined
[18:19] <hythm> Lets say I want to add (append, pop, shift, unshift) methods to IO::Path, so I can run ('/tmp/delme'.IO.pop; # /tmp), Do I need to use `augment`? although docs discourage using augment. Also I don't want to create a separate class for it may be "Path::Util" for instance, I'd prefer If I would be able to call these methods directly on IO

[18:21] <ugexe> then use augment

[18:21] <hythm> ok

[18:21] <ugexe> what you are doing would be discouraged in general, nothing specific to augment

[18:21] <hythm> ah I see

[18:21] <clarkema> I've just uploaded my first module to CPAN.  I can see it in my homedir on PAUSE... do I need to do anything else from there to have it 'zef install'able?

[18:22] <ugexe> for instance -- what if some code/library expects an exception to be thrown if .pop is called on it? it is not aware of your change of behavior

[18:22] *** dogbert11 joined
[18:23] <hythm> right, so I think it's better to create anseparate class for it

[18:23] *** vrurg left
[18:23] <ugexe> yes, or use a mixin role on IO::Path

[18:23] *** vrurg joined
[18:23] *** pyrimidi_ joined
[18:23] <tobs> clarkema++: no, just wait a bit

[18:23] *** dogbert17 left
[18:23] *** pyrimidine left
[18:23] <ugexe> role PathThing { method pop { ... } }; my $foo = "foo".IO but PathThing;

[18:24] <hythm> makes sense, abnd sounds a better idea

[18:24] <clarkema> tobs: great, thanks

[18:24] <tobs> but I can't quantify "a bit"

[18:24] <moritz> hythm: the other option is to use multi subs instead of methods

[18:25] <moritz> multi sub pop(IO::Path:D $p) { ... }

[18:25] <moritz> and then call pop($thing.IO)

[18:26] <clarkema> tobs: I can't stand the suspense!

[18:26] <jmerelo> clarkema: did you upload it to the Perl6 directory?

[18:26] <clarkema> jmerelo: yes

[18:26] <jmerelo> clarkema: it will take a while to show up here and in Twitter. And ugexe's bots scan every two hours, so it will take a while more to appear in zef search

[18:27] <jmerelo> clarkema: modules.perl6.org should kick in at midnight, so tomorrow should be there too.

[18:29] <clarkema> jmerelo: ok, i'll let it percolate for a while

[18:29] <cpan-p6> New module released to CPAN! Pod::To::Man (0.1.0) by 03CLARKEMA

[18:29] <clarkema> ah, speak of the devil

[18:29] *** kurahaupo left
[18:29] <clarkema> ah, speak of the devil

[18:29] <hythm> thanks ugexe and moritz for the suggestions, I like the multi sub pop(IO::Path:D $p) { ... } , will use that.

[18:35] <tobs> m: multi sub tail (Str:D $_) { .comb.tail }; say "hallo".&tail;  # hythm: additionally there is .& to make sub calls look like method calls.

[18:35] <evalable6> tobs, rakudo-moar 847a2f0d2: OUTPUT: «o␤»

[18:36] <hythm> tobs: noted.

[18:49] *** Actualeyes left
[18:49] *** domidumont left
[18:56] *** natrys joined
[19:08] *** AlexDaniel joined
[19:08] <AlexDaniel> .

[19:08] <yoleaux> 10:26Z <jmerelo> AlexDaniel: congrats on your Master's defense :-)

[19:08] <AlexDaniel> thank you :)

[19:09] <Xliff> \o/

[19:09] <jmerelo> AlexDaniel: will you be publishing it? Did you get any trouble from the Jury?

[19:09] <AlexDaniel> everyone is so supportive, I hope you all don't hate for not doing enough perl6 wörk for the last few months

[19:09] <Xliff> M. S. AlexDaniel

[19:09] <AlexDaniel> don't hate me*

[19:09] <Xliff> LOL

[19:09] <Xliff> Don't worry. I am making up for you.

[19:10] <jmerelo> AlexDaniel: I've missed you re-opening doc issues I had closed alright

[19:10] <jmerelo> :-)

[19:10] <AlexDaniel> jmerelo: no, I did get some trouble from libreoffice though

[19:10] <Xliff> https://bitbucket.org/perl_amazon_ec2/p6-amazon-aws-ec2/

[19:10] <AlexDaniel> jmerelo: one slide showed up with broken images, and it crashed at least 2 times during the presentation

[19:11] <jmerelo> AlexDaniel: it's private. Anyway, why not LaTeX?

[19:11] <AlexDaniel> jmerelo: how do you include a video in a latex presentation? I don't know

[19:11] <jmerelo> AlexDaniel: ah. Reveal.js then.

[19:11] * AlexDaniel shrugs

[19:11] <jmerelo> AlexDaniel: yep, what's done is done.

[19:11] <AlexDaniel> libreoffice doesn't like videos too, that's why it was crashing…

[19:12] <AlexDaniel> but it was alright! I handled it well, I think

[19:12] <jmerelo> Congrats! 

[19:13] <jmerelo> Will you be continuing in academia or off to industry?

[19:13] *** cjkinni joined
[19:14] <AlexDaniel> I'll continue… doing military or alternative service, because in this country I have no other choice

[19:14] <AlexDaniel> unless a miracle happens, which I highly doubt

[19:15] <AlexDaniel> jmerelo: as for publishing, no related paper will be published, but you'll find a pdf of the thesis itself here: https://github.com/RGVID-EU/RoboRG-Docs/releases

[19:15] *** ravenousmoose joined
[19:15] <jmerelo> Good luck with that.

[19:16] <jmerelo> AlexDaniel: you should definitely try and publish, even if it's in ArXiV only.

[19:18] * jmerelo goes AFK to dinner...

[19:18] <AlexDaniel> jmerelo: personally I don't think academia is for me… not anymore. I don't see a point. People write a paper, submit it, and then drop that topic on the floor and move to the next paper. Oh and no sources published, of course

[19:19] *** jmerelo left
[19:19] <AlexDaniel> maybe in other fields this makes sense

[19:20] <Xliff> AlexDaniel: I still haven't forgotten your graph for GtkPlus. I've just been soo busy.

[19:20] <AlexDaniel> I don't think I want to fight that by going against the lfow…

[19:20] <Xliff> http://github.com/Xliff

[19:20] <AlexDaniel> flow*

[19:20] <AlexDaniel> so I'll just do something else, probably, but we will se in a year

[19:20] <Xliff> Working on the Amazon AWS Query API, now.

[19:20] <AlexDaniel> see* gah :)

[19:20] <AlexDaniel> Xliff: what gtk graph? I don't remember…

[19:21] <AlexDaniel> Xliff: compilation time across revisions? Or something?

[19:21] <Xliff> Horizontal. Perl 6 version vs total compile time

[19:21] <AlexDaniel> mmmm that'd be interesting

[19:21] <Xliff> Yeah. Noticed a real serious slow-down with the later compilers.

[19:22] <Xliff> Went from 2300 seconds to compile to like 4000 on the VM.

[19:24] <sena_kun> AlexDaniel, very sad to know you are likely to spend a year of life doing something LTA. I hope you will be able to think of something to make this time more interesting for yourself. :) Of course, nobody hates you(I hope), there is _a lot_ of your work contributed and it is valued, so be more proud of yourself. :)

[19:25] <AlexDaniel> sena_kun: I'll know in a week if it's going to be alternative service or not

[19:25] <AlexDaniel> sena_kun: and if so, I'll just have a 1 year job with minimum wage

[19:25] <sena_kun> AlexDaniel, I'll hope for this option.

[19:28] <sena_kun> it is just so damn inefficient from various points of view when people don't do something they are clearly better at. :/

[19:35] *** |Sno| left
[19:36] *** sena_kun left
[19:37] *** [Sno] joined
[19:39] *** sena_kun joined
[19:50] <clarkema> is it possible to provide a default for a named argument in a sub's arglist, or do you just have to do ||= later on in the body?

[19:57] <ugexe> m: sub foo(:$var = "default") { $var }; say foo()'

[19:57] <evalable6> ugexe, rakudo-moar 847a2f0d2: OUTPUT: «(exit code 1) 04===SORRY!04=== Error while compiling /tmp/hH338Z_fL9␤Two ter…»

[19:57] <evalable6> ugexe, Full output: https://gist.github.com/625ba9bce4dffd61d068457cb4e577f4

[19:58] <ugexe> m: sub foo(:$var = "default") { $var }; say foo()

[19:58] <evalable6> ugexe, rakudo-moar 847a2f0d2: OUTPUT: «default␤»

[19:58] <clarkema> thanks

[20:03] *** sena_kun left
[20:04] *** Sgeo__ joined
[20:07] *** Sgeo_ left
[20:09] *** antoniogamiz left
[20:13] *** veesh left
[20:17] <Geth> ¦ doc/p6doc-support-different-formats: 7796e0ff6e | (Mike Clarke)++ | bin/p6doc

[20:17] <Geth> ¦ doc/p6doc-support-different-formats: Teach p6doc to handle --format

[20:17] <Geth> ¦ doc/p6doc-support-different-formats: review: https://github.com/perl6/doc/commit/7796e0ff6e

[20:18] <clarkema> hmm, that was supposted to be to my own remote

[20:18] <clarkema> oh wel

[20:20] <mst> it's a branch so ... meh? :)

[20:23] *** veesh joined
[20:23] <Geth> ¦ doc: clarkema++ created pull request #2844: Teach p6doc to handle --format

[20:23] <Geth> ¦ doc: review: https://github.com/perl6/doc/pull/2844

[20:24] <clarkema> yeah, I was only going to PR it from there anyway, so it doesn't matter

[20:36] *** dolmen joined
[20:37] *** dolmen left
[20:37] *** dolmen joined
[20:37] *** farcas82regreg left
[20:38] *** ravenousmoose left
[20:50] <nadim_> evening, wha are you using for file extension for scripts and modules. I am still using pl and pm and wonder what the consensus  is

[20:53] *** natrys left
[20:59] *** hythm left
[21:02] <ugexe> use .pm6 for modules

[21:02] <leont> Some do .pm others do .pm6. I think the latter is winning

[21:02] <ugexe> and use .p6 or .pl6 for scripts

[21:02] <leont> More recently people have started doing .t6 for tests

[21:02] <ugexe> if we can get to *only* allow .pm6 then we can have distributions that contain perl 5 and 6 modules side by side

[21:12] <nadim_> thanks for the answers, I'll align to those.

[21:17] *** dolmen left
[21:23] *** squashable6 left
[21:24] *** squashable6 joined
[21:29] <Geth> ¦ doc: lukasvalle++ created pull request #2845: Adapt documentaion for pairup 

[21:29] <Geth> ¦ doc: review: https://github.com/perl6/doc/pull/2845

[21:33] <Geth> ¦ doc: 9c1d2058fc | lukasvalle++ | doc/Type/Any.pod6

[21:33] <Geth> ¦ doc: Adapt documentaion for https://github.com/rakudo/rakudo/commit/d73272e4c0f3d92ed82008eb366cfe756ae0c39b#diff-0bf1cf4b83dbeb7a105cd2e64f48fc44 (Consistify :U.pairup with :D one by returning a Seq )

[21:33] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/9c1d2058fc

[21:33] <Geth> ¦ doc: 263f435847 | (Elizabeth Mattijsen)++ (committed using GitHub Web editor) | doc/Type/Any.pod6

[21:33] <Geth> ¦ doc: Merge pull request #2845 from lukasvalle/master

[21:33] <synopsebot> Link: https://doc.perl6.org/type/Any

[21:33] <Geth> ¦ doc: 

[21:33] <Geth> ¦ doc: Adapt documentation for pairup

[21:33] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/263f435847

[21:44] *** Cabanossi left
[21:50] *** sena_kun joined
[21:56] *** Cabanossi joined
[22:02] *** Altai-man_ joined
[22:03] *** sena_kun left
[22:06] *** Voldenet left
[22:10] *** Voldenet joined
[22:10] *** Voldenet left
[22:10] *** Voldenet joined
[22:12] <leont> Personally, I wouldn't use any extension for scripts, and I see no reason why anyone else would want to do so

[22:15] <ugexe> the only reason i can think of, now that you mention it, is to give windows people some help

[22:20] *** Altai-man_ left
[22:25] *** molaf joined
[22:28] *** rindolf left
[22:52] *** molaf left
[23:03] *** Sgeo_ joined
[23:07] *** Sgeo__ left
[23:21] *** aborazmeh joined
[23:21] *** aborazmeh left
[23:21] *** aborazmeh joined
[23:22] *** mowcat joined
[23:22] *** clarkema left
[23:23] *** Test joined
[23:24] *** Test is now known as Guest79246

[23:32] *** |Sno| joined
[23:36] *** [Sno] left
