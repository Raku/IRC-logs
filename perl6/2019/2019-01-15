[00:12] <pony> this is my first time opening an issue. how do I insert new lines in my code?

[00:14] <Kaiepi> how can i get the name of a sub from within the sub?

[00:14] <sena_kun> pony, you mean github one? You can just enclose plain code with "```perl6\n" and "\n```"(without quotes) type of quoting(`\n` is a normal newline in this case).

[00:15] <pony> ahh, thanks

[00:15] <AlexDaniel> m: sub foo() { say &?ROUTINE.name }; foo

[00:16] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «foo␤»

[00:16] <AlexDaniel> Kaiepi: ↑?

[00:16] <sena_kun> pony, markdown works for comments there.

[00:16] <pony> got it working, thanks :)

[00:16] <Kaiepi> thanks 

[00:17] *** SHODAN joined
[00:17] *** p6bannerbot sets mode: +v SHODAN

[00:17] <sena_kun> pony++

[00:17] *** w_richard_w joined
[00:18] *** p6bannerbot sets mode: +v w_richard_w

[00:23] *** huyna joined
[00:23] *** p6bannerbot sets mode: +v huyna

[00:23] <pony> c: 2018.10 say $*DISTRO

[00:24] <committable6> pony, ¦2018.10: «debian (9.stretch)␤»

[00:26] *** w_richard_w left
[00:27] <pony> done https://github.com/rakudo/rakudo/issues/2609

[00:32] <AlexDaniel> pony++

[00:32] <pony> :D

[00:34] *** sena_kun left
[00:44] *** huyna left
[00:44] *** zacts joined
[00:44] *** p6bannerbot sets mode: +v zacts

[01:14] *** zacts left
[01:36] *** dncefan left
[01:49] *** zachk joined
[01:50] *** p6bannerbot sets mode: +v zachk

[01:54] *** sno left
[01:57] *** dncefan joined
[01:58] *** p6bannerbot sets mode: +v dncefan

[02:02] *** zachk left
[02:02] *** zachk joined
[02:02] *** leguin.freenode.net sets mode: +v zachk

[02:02] *** p6bannerbot sets mode: +v zachk

[02:05] *** eseyman left
[02:07] *** eseyman joined
[02:07] *** p6bannerbot sets mode: +v eseyman

[02:08] *** dncefan left
[02:24] *** sno joined
[02:25] *** p6bannerbot sets mode: +v sno

[02:28] *** sno left
[02:31] <SmokeMachine> Xliff:it looks that there’s a way to call function poiters!!! https://docs.perl6.org/language/nativecall#Function_pointers

[02:41] <Geth> ¦ doc: 479fbfb9eb | cfa++ | doc/Type/Signature.pod6

[02:41] <Geth> ¦ doc: Signature: indentation fixes.

[02:41] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/479fbfb9eb

[02:43] <Xliff> SmokeMachine: Oh! Is that what you meant?

[02:43] <Xliff> Sorry, m8! I misunderstood!

[02:43] <Xliff> *blush*

[02:43] <Xliff> I haven't tried that method, though.

[02:44] <Xliff> Let me know if you have code you want another set of eyes on. 

[02:46] *** molaf left
[03:00] <Geth> ¦ doc: 49482f0dce | cfa++ | 7 files

[03:00] <Geth> ¦ doc: A few more indentation fixes.

[03:00] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/49482f0dce

[03:04] <Kaiepi> how can i add metadata to a function?

[03:04] *** ufobat_ joined
[03:04] <lookatme_q> what metadata ?

[03:04] *** p6bannerbot sets mode: +v ufobat_

[03:05] <Kaiepi> i have a module with methods that i want to add an administrative attribute to

[03:06] <Kaiepi> i could make a class with the method and the administrative Bool but it'd be really awkward to write since i have a lot of them

[03:07] *** ufobat left
[03:07] *** lizmat left
[03:35] *** zachk left
[03:35] *** sno joined
[03:36] *** p6bannerbot sets mode: +v sno

[03:36] *** jme` joined
[03:37] *** p6bannerbot sets mode: +v jme`

[03:40] *** sno left
[03:49] <Xliff> Kaiepi: The only way I can think to do that is to have a private hash attribute in a class.

[03:49] <Xliff> The keys are the names of the method.

[03:49] <Xliff> Then you can populate it with any kind of attribute you want and check them via a regular hash lookup.

[03:50] <cpan-p6> New module released to CPAN! Net-NNG (0.0.1) by 03SAMGWISE

[03:53] <Xliff> Then you can do something like: multi sub trait_mod:<is>(Method:D \meth, :$admin!) is export { %!hash{meth.name}<admin> = 1 }

[03:54] <Xliff> Then define methods as: method somename is admin { ... }

[04:06] <cpan-p6> New module released to CPAN! Hastebin (0.0.3) by 03KAIEPI

[04:07] *** sno joined
[04:08] *** p6bannerbot sets mode: +v sno

[04:12] *** sno left
[04:22] <cpan-p6> New module released to CPAN! OO-Plugin (v0.0.3) by 03VRURG

[04:25] *** Cabanossi joined
[04:26] *** Cabanoss- left
[04:26] *** p6bannerbot sets mode: +v Cabanossi

[04:28] *** perlWisher joined
[04:28] *** p6bannerbot sets mode: +v perlWisher

[04:33] <perlWisher> I had used perl 5.0 for performing small tasks, however, continuously for a few years.  That was 10 years ago.  Despite perl 5's cryptic nature, I liked it.  Can anyone here tell me what is special about perl 6 as there are already abundant / distinct programming languages available?  I have read the features of perl 6.  Just I want to know what is special about perl 6.  Thank you.

[04:36] <Brynn> perl 6 has many of the features of perl 5 but for example has good support for smalltalk and lisp/scheme programmers

[04:41] <Geth> ¦ doc: 68f85dbcbd | cfa++ | 24 files

[04:41] <Geth> ¦ doc: Further indentation fixes.

[04:41] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/68f85dbcbd

[04:41] *** perlWisher left
[04:46] <AlexDaniel> again, I think this is something that is answered greatly by this: https://docs.perl6.org/language/faq#Why_should_I_learn_Perl_6?_What's_so_great_about_it?

[04:47] <AlexDaniel> but they always leave so fast :)

[04:48] *** sno joined
[04:49] *** p6bannerbot sets mode: +v sno

[04:49] *** sauvin joined
[04:49] *** p6bannerbot sets mode: +v sauvin

[04:53] *** sno left
[04:56] <Xliff> AlexDaniel: True enough. Can't force them to stay. If they really wanted an answer to the question, they'd have waited.

[04:56] <Xliff> For me, as a Perl5/C/C++/C# programmer when I started here in 2016, all I needed to do was read up on the project.

[04:56] <Xliff> It sold itself.

[05:04] *** smallick joined
[05:04] <smallick> m: say 5;

[05:04] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «5␤»

[05:05] <smallick> m: .say for(1..10);

[05:05] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Missing semicolon␤at <tmp>:1␤------> 3.say7⏏5 for(1..10);␤»

[05:05] <AlexDaniel> m: .say for (1..10);

[05:05] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «1␤2␤3␤4␤5␤6␤7␤8␤9␤10␤»

[05:06] <smallick> m: for(1..10).say;

[05:06] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Undeclared routine:␤    for used at line 1␤␤»

[05:06] <AlexDaniel> m: .say for 1..10;

[05:06] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «1␤2␤3␤4␤5␤6␤7␤8␤9␤10␤»

[05:06] <AlexDaniel> space after `for`

[05:06] <Xliff> or...

[05:06] <Xliff> m: .say for ^10

[05:06] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «0␤1␤2␤3␤4␤5␤6␤7␤8␤9␤»

[05:06] <Xliff> Oh... you want to include the 10!

[05:06] <Xliff> m: .say for ^11

[05:06] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «0␤1␤2␤3␤4␤5␤6␤7␤8␤9␤10␤»

[05:06] <AlexDaniel> Xliff: and 1

[05:06] <AlexDaniel> :P

[05:06] <AlexDaniel> I mean, no 0

[05:06] <Xliff> Well... FINE! :P

[05:07] <smallick> thank you.

[05:07] <Xliff> Don't mind me an AlexDaniel.

[05:07] <Xliff> He's sane. I'm not. %)

[05:07] <Xliff> AlexDaniel: I've decided to cave to your demands.

[05:08] <Xliff> I'm stuck with a GTk

[05:08] <Xliff> Gah1

[05:08] <Xliff> I'm stuck with a GTK::Grid issue (in addition with my Pango issue, which is related to a cairo issue)

[05:08] <Xliff> But it will be done. 

[05:08] <AlexDaniel> Xliff: oh, then I demand current release blockers to be resolved :)

[05:09] <Xliff> What release blockers?

[05:09] <AlexDaniel> releasable6: status

[05:09] <releasable6> AlexDaniel, Next release in ≈4 days and ≈13 hours. 6 blockers. 104 out of 217 commits logged (⚠ 41 warnings)

[05:09] <releasable6> AlexDaniel, Details: https://gist.github.com/bb62a215a52af095e73b015ba9c73a98

[05:09] <Xliff> Oh.

[05:09] <lookatme_q> Maybe FALLBACK method will helpful, if I understand right

[05:09] <Xliff> I have no intent to go that far. That would be considered a Cave-In

[05:09] <Xliff> lookatme_q: ??

[05:10] <Xliff> (FALLBACK is useful)

[05:10] <lookatme_q> yeah, useful :)

[05:11] <Xliff> .... OK... BE cryptic! :)

[05:11] <Geth> ¦ doc: 005458b477 | cfa++ | doc/404.pod6

[05:11] <Geth> ¦ doc: Remove trailing whitespace.

[05:11] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/005458b477

[05:11] <Geth> ¦ doc: 76ffe3a6af | cfa++ | doc/Type/Any.pod6

[05:11] <Geth> ¦ doc: Correct typo, pass space-after-comma.t

[05:11] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/76ffe3a6af

[05:11] <AlexDaniel> Xliff: ok, then at least one will do :)

[05:12] <smallick> m: say ([*] (1..10));

[05:12] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «3628800␤»

[05:14] <Xliff> m: say 1 * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10

[05:14] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «3628800␤»

[05:15] <AlexDaniel> m: say (1, * * ++$ … ∞)[10]

[05:15] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «3628800␤»

[05:15] <AlexDaniel> m: say (1, * × ++$ … ∞)[10]

[05:15] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «3628800␤»

[05:15] <smallick> m: say 2^10;

[05:15] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «one(2, 10)␤»

[05:16] <Xliff> m: say 2 ** 10

[05:16] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «1024␤»

[05:16] <AlexDaniel> smallick: oh yes, that gives a junction. If you meant to use a bitwise op, then that's +^

[05:16] <AlexDaniel> m: say 2 +^ 10

[05:16] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «8␤»

[05:16] <Xliff> No. I think he ment pow

[05:17] <Xliff> s/ment/meant/

[05:17] <smallick> yes, i meant

[05:17] <AlexDaniel> s/he/they/ :)

[05:17] <Xliff> s/they/them/

[05:17] <smallick> s/i/I/

[05:17] <AlexDaniel> m: say 2¹⁰ # also works :)

[05:17] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «1024␤»

[05:17] <Xliff> m: say (1, * × ++$ … ∞)[20]

[05:17] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «2432902008176640000␤»

[05:17] <Xliff> %-)

[05:18] <smallick> what was that?

[05:18] *** molaf joined
[05:18] <Xliff> m: say [*](1..20)

[05:18] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «2432902008176640000␤»

[05:19] <smallick> okay, i understand

[05:19] <Xliff> TIMTOWTDI

[05:19] *** p6bannerbot sets mode: +v molaf

[05:19] <smallick> philosophy?

[05:19] <Xliff> :)

[05:19] <Xliff> There Is More than One Way to Do It.

[05:19] <Xliff> Yes. Philosophy

[05:19] <smallick> i know

[05:20] <Xliff> Oh! My bad.

[05:20] <Xliff> Most languages try to impose Their Way.

[05:20] <Xliff> Many people don't think that way.

[05:21] <smallick> ackermann 4,2 would work here?

[05:22] <smallick> ackermann 4,2 would work here?

[05:22] *** sno joined
[05:22] *** p6bannerbot sets mode: +v sno

[05:25] <smallick> m: say (1..999).grep({ $_ %% 3 or $_ %% 5 }).reduce({ $^a + $^b }) ;

[05:25] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «233168␤»

[05:25] <smallick> great!

[05:27] <AlexDaniel> m: say (1..999).grep({ $_ %% 3 or $_ %% 5 }).sum

[05:27] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «233168␤»

[05:27] *** sno left
[05:28] <smallick> m: say (1, 1, *+*, .. * > 4e6).grep({ $_ %% 2 }).reduce({ $^a + $^b }) ;

[05:28] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Preceding context expects a term, but found infix .. instead.␤at <tmp>:1␤------> 3say (1, 1, *+*, ..7⏏5 * > 4e6).grep({ $_ %% 2 }).reduce({ $^a␤»

[05:28] <AlexDaniel> three dots and no , before dots

[05:28] <lookatme_q> that's not range, using ...

[05:29] <AlexDaniel> m: say (1, 1, *+* ... * > 4e6).grep({ $_ %% 2 }).reduce({ $^a + $^b })

[05:29] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «4613732␤»

[05:30] <smallick> m: say (1, 1, *+* .. * > 4e6).grep({ $_ %% 2 }).reduce({ $^a + $^b });

[05:30] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «Cannot resolve caller Real(WhateverCode:D: ); none of these signatures match:␤    (Mu:U \v: *%_)␤  in block <unit> at <tmp> line 1␤␤»

[05:31] *** sno joined
[05:31] *** p6bannerbot sets mode: +v sno

[05:32] <smallick> m: say ([+] (1, 1, *+* ... * > 4e6).grep({ $_ %% 2 })) ;

[05:32] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «4613732␤»

[05:33] <smallick> is there any way to sum up 3rd, 6th, 9th ... terms of an array?

[05:33] <Geth> ¦ doc: finanalyst++ created pull request #2569: replace invalid links with valid links to primary sources

[05:33] <Geth> ¦ doc: review: https://github.com/perl6/doc/pull/2569

[05:34] <AlexDaniel> m: say <a b c d e f g h>[3,6...∞]

[05:34] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «(d g)␤»

[05:34] <AlexDaniel> m: say <a b c d e f g h>[2,5...∞]

[05:34] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «(c f)␤»

[05:34] <AlexDaniel> m: say (0..50)[2,5...∞]

[05:34] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «(2 5 8 11 14 17 20 23 26 29 32 35 38 41 44 47 50)␤»

[05:35] <AlexDaniel> smallick: like that should work

[05:35] <AlexDaniel> m: say (1, 1, *+* ... * > 4e6)[2,5...∞].sum

[05:35] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «4613732␤»

[05:35] <AlexDaniel> not the best example maybe, but still :)

[05:36] <smallick> it works :)

[05:37] * AlexDaniel goes to bed

[05:37] <smallick> by phone doesn't support utf-8 chars completely; what was after that [2,5... 

[05:38] <AlexDaniel> smallick: [2,5...Inf] or [2,5...*]

[05:38] <smallick> oh, sorry!

[05:38] <AlexDaniel> smallick: it was an infinity sign

[05:38] <smallick> okay

[05:39] <AlexDaniel> both Inf and * will work just fine as an alternative here

[05:39] <smallick> thanks and bye.

[05:40] *** smallick left
[05:48] *** curan joined
[05:48] *** p6bannerbot sets mode: +v curan

[06:00] *** Cabanossi left
[06:01] *** Cabanossi joined
[06:01] *** smallick joined
[06:02] *** p6bannerbot sets mode: +v Cabanossi

[06:02] *** p6bannerbot sets mode: +v smallick

[06:03] <smallick> how to calculate sum of digits of a Int ?

[06:04] <pony> m: say 123.comb.sum

[06:04] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «6␤»

[06:05] <smallick> m: say ((2 ** 1000).comb.sum);

[06:05] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «1366␤»

[06:06] <smallick> m: say (([*] (1..100)).comb.sum);

[06:06] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «648␤»

[06:07] *** sno left
[06:09] <smallick> well... being more "precise" (i.e. getting more precision) of some calculation like atan(Inf) to 100 digits after decimal

[06:10] *** PavelB left
[06:10] <smallick> maybe that is too precise

[06:11] <smallick> m: say 1/7 ;

[06:11] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «0.142857␤»

[06:12] <smallick> only 6 digits?

[06:12] <smallick> m: say 1/11

[06:12] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «0.090909␤»

[06:12] <smallick> m: say pi

[06:12] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «3.141592653589793␤»

[06:13] <smallick> m: say e

[06:13] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «2.718281828459045␤»

[06:13] <smallick> m: say (1+(5.sqrt))/2

[06:13] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «1.618033988749895␤»

[06:14] <smallick> m: say (-1).sqrt 

[06:14] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «NaN␤»

[06:15] <smallick> m: say 1i

[06:15] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «0+1i␤»

[06:15] <smallick> why -1.sqrt != 1i ??

[06:16] <smallick> m: say (e ** (pi*1i)) + 1

[06:16] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «0+1.2246467991473532e-16i␤»

[06:16] *** robertle left
[06:16] <smallick> m: say 2 ** 10i

[06:16] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «0.7971196172184872+0.603821427116869i␤»

[06:17] <smallick> perl6 has 0.1 + 0.2 == 0.3 but not e^i*pi == -1

[06:18] <smallick> m: say e ** (pi * 1i) - 1 == 0

[06:18] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «False␤»

[06:18] <Xliff> It's a precision thing

[06:18] <Xliff> Please note it was 1.224e-16i

[06:18] <smallick> very close 

[06:19] <smallick> but != 0

[06:19] <Xliff> Most languages special case that so it comes out as 0

[06:19] <Xliff> m: 0+1.2246467991473532e-16i =~= 0

[06:19] <camelia> rakudo-moar 54fe8a1a8: ( no output )

[06:19] <Xliff> m: say 0+1.2246467991473532e-16i =~= 0

[06:19] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «True␤»

[06:20] <Xliff> =~= -> is approximately

[06:20] <smallick> ok. What about 1/7, 1/13, how can i get more, like 20, digits of them?

[06:20] <smallick> after .

[06:21] <Xliff> Hmmm. Not sure.

[06:21] <Xliff> I know someone was working on it.

[06:21] <SmokeMachine> m: say (1..999).grep(* %% 3 | 5).sum

[06:21] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «499500␤»

[06:21] <Xliff> m: use full-precision; say 1/7

[06:21] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «0.142857␤»

[06:21] *** domidumont joined
[06:22] <Xliff> m: use full-precision; say 1/20

[06:22] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «0.05␤»

[06:22] *** p6bannerbot sets mode: +v domidumont

[06:23] <Xliff> m: use full-precision; say 20/7

[06:23] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «2.857143␤»

[06:23] <Xliff> I wonder if that was removed.

[06:23] <smallick> one can't get full precisions to irrationals, i want some 100 digits after decimal

[06:24] <Xliff> m: say FatRat.new(1/7)

[06:24] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «Type check failed in binding to parameter 'nu'; expected Int but got Rat (<1/7>)␤  in block <unit> at <tmp> line 1␤␤»

[06:24] <Xliff> m: say FatRat.new(1,7)

[06:24] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «0.142857␤»

[06:24] <SmokeMachine> m: $*FULL-PRECISION = True; say 1/7

[06:24] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «0.142857␤»

[06:26] <smallick> smokemachine: 3 | 5 is 7

[06:26] <Xliff> m: say FatRat.new(1,7).Num

[06:26] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «0.14285714285714285␤»

[06:26] <smallick> is that what you wanted?

[06:26] <Xliff> There we go.

[06:26] <SmokeMachine> smallick: no... 3|7 is any(3 ,5)

[06:27] <SmokeMachine> m: say 3 | 5

[06:27] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «any(3, 5)␤»

[06:27] <smallick> see above

[06:27] <Xliff> m: $*FULL-PRECISION = True; say FatRat.new(1,7).Num

[06:27] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «0.14285714285714285␤»

[06:27] <SmokeMachine> Sorry, 3|5 is any(3,5)

[06:28] <Xliff> I suppose that's the limit since you can't get any more out of a 64-bit number

[06:28] *** molaf left
[06:28] <SmokeMachine> m: say ^10 .grep: * %% 3|5

[06:28] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «(0 1 2 3 4 5 6 7 8 9)␤»

[06:29] <SmokeMachine> m: say (^10).grep: * %% 3|5

[06:29] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «(0 1 2 3 4 5 6 7 8 9)␤»

[06:29] <Xliff> m: say (^10).grep: * %% 3

[06:29] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «(0 3 6 9)␤»

[06:29] <Xliff> m: say (^10).grep: * % 3

[06:29] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «(1 2 4 5 7 8)␤»

[06:29] <smallick> if 3|5 is any(3, 5) where is bitwise op? Thrown away, i think

[06:30] <SmokeMachine> m: say 3 +| 5

[06:30] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «7␤»

[06:30] <Xliff> m: say (^10).grep: * %% (3, 5).any

[06:30] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «(0 3 5 6 9)␤»

[06:30] <smallick> changed, huh!

[06:30] <Xliff> m: say (^10).grep: * %% (3|5)

[06:30] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «(0 3 5 6 9)␤»

[06:30] <SmokeMachine> bisect: say ^10 .grep: * %% 3|5

[06:30] <bisectable6> SmokeMachine, Problem with 54fe8a1 commit: Commit exists, but a perl6 executable could not be built for it

[06:31] <SmokeMachine> bisect: new=HEAD say ^10 .grep: * %% 3|5

[06:31] *** sno joined
[06:31] <bisectable6> SmokeMachine, Problem with 54fe8a1 commit: Commit exists, but a perl6 executable could not be built for it

[06:32] *** p6bannerbot sets mode: +v sno

[06:32] <smallick> m: say (1/13).Num

[06:32] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «0.07692307692307693␤»

[06:33] <SmokeMachine> c: 2018.11 say ^10 .grep: * %% 3|5

[06:33] <committable6> SmokeMachine, ¦2018.11: «(0 1 2 3 4 5 6 7 8 9)␤»

[06:33] <SmokeMachine> m: say ^10 .grep: * %% (3|5)

[06:33] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «(0 3 5 6 9)␤»

[06:34] <SmokeMachine> m: say (^10 + 1).grep: * %% (3|5)

[06:34] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «(3 5 6 9 10)␤»

[06:34] <smallick> great!

[06:35] <smallick> m: say ([+] (1..999).grep({ $_ %% (3|5) }));

[06:35] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «233168␤»

[06:37] <smallick> if 3|5 is any(3, 5) then what is all(3,5) and none(3,5)

[06:38] <smallick> m: say 3&5

[06:38] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «all(3, 5)␤»

[06:38] <smallick> oh!

[06:39] <smallick> m: say 3^5

[06:39] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «one(3, 5)␤»

[06:40] <smallick> is there any built-in prime sieve

[06:41] <SmokeMachine> m: say 1 & 2 | 3 ^ 4

[06:41] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Only identical operators may be list associative; since '|' and '^' differ, they are non-associative and you need to clarify with parentheses␤at <tmp>:1␤------> 3say 1 & 2 | 37⏏5 ^ 4␤    exp…»

[06:41] <pony> there's no operator for none()

[06:41] <pony> m: say 3.is-prime

[06:41] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «True␤»

[06:42] <smallick> how to get the effect of none: like not all(), i think

[06:43] <pony> none() :)

[06:43] <pony> none()'s a thing, there's just no operator for it

[06:44] <smallick> getting mean of an Int array?

[06:45] *** domidumont left
[06:45] <Xliff> You have to do that the hard way.

[06:45] <Xliff> m: my @a = ^5; say sum / .elems given @a

[06:45] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «5===SORRY!5===␤Regex not terminated.␤at <tmp>:1␤------> 3my @a = ^5; say sum / .elems given @a7⏏5<EOL>␤Unable to parse regex; couldn't find final '/'␤at <tmp>:1␤------> 3my @a = ^5; say sum / .elems given @a7⏏5<EOL>␤    e…»

[06:45] *** jmerelo joined
[06:45] <Xliff> m: my @a = ^5; say /sum / .elems given @a

[06:45] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «1␤»

[06:45] <Xliff> m: my @a = ^5; say .sum / .elems given @a

[06:45] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «2␤»

[06:46] <Xliff> m: my @a = ^5; say @a.sum / @a.elems

[06:46] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «2␤»

[06:46] *** p6bannerbot sets mode: +v jmerelo

[06:46] <Xliff> m: my @a = 1..5; say @a.sum / @a.elems

[06:46] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «3␤»

[06:46] <smallick> m: my $a = (2..10).grep(is-prime); say ([+] $a)/($a.count);

[06:46] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Calling is-prime() will never work with signature of the proto ($, *%)␤at <tmp>:1␤------> 3my $a = (2..10).grep(7⏏5is-prime); say ([+] $a)/($a.count);␤»

[06:46] <Xliff> m: my $a = (2..10).grep(*.is-prime); say ([+] $a)/($a.count);

[06:46] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «No such method 'count' for invocant of type 'Seq'. Did you mean any of these?␤    conj␤    round␤␤  in block <unit> at <tmp> line 1␤␤»

[06:46] <Xliff> m: my $a = (2..10).grep(*.is-prime); say ([+] $a)/($a.elems);

[06:46] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «The iterator of this Seq is already in use/consumed by another Seq␤(you might solve this by adding .cache on usages of the Seq, or␤by assigning the Seq into an array)␤  in block <unit> at <tmp> line 1␤␤»

[06:47] <Xliff> m: my @a = (2..10).grep(*.is-prime); say @a.sum/@a.elems

[06:47] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «4.25␤»

[06:48] <Xliff> Can also be written as:

[06:48] <Xliff> m: my @a = (2..10).grep({ $_.is-prime }); say @a.sum/@a.elems

[06:48] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «4.25␤»

[06:48] <Xliff> Or even...

[06:48] <Xliff> m: my @a = (2..10).grep({ .is-prime }); say @a.sum/@a.elems

[06:48] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «4.25␤»

[06:48] <smallick> m: say (1..2e6).grep(*.is-prime).sum

[06:49] <Xliff> Oooo

[06:49] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «(timeout)»

[06:49] <smallick> what happened?

[06:49] <Xliff> Took too long to Iterate. It's easier to ask for the first n primes than to go over a range.

[06:49] <smallick> too much calculation...

[06:50] <Xliff> m: my @a = (1..Inf).map( *.is-prime ); say @a[^100]

[06:50] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «(False True True False True False True False False False True False True False False False True False True False False False True False False False False False True False True False False False False False True False False False True False True False …»

[06:50] <smallick> i want primes under 2e6

[06:50] <Xliff> m: my @a = (1..Inf).grep( *.is-prime ); say @a[^100]

[06:50] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «(2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 101 103 107 109 113 127 131 137 139 149 151 157 163 167 173 179 181 191 193 197 199 211 223 227 229 233 239 241 251 257 263 269 271 277 281 283 293 307 311 313 317 331 337 347 349…»

[06:50] <Xliff> Easier to pick a number and wait until you get to 2e6

[06:51] <Xliff> m: my @a = (1..Inf).map( *.is-prime ); say @a.grep( * < 2e6)

[06:51] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «(...)␤»

[06:51] <Xliff> m: my @a = (1..Inf).map( *.is-prime ); say eager @a.grep( * < 2e6)

[06:51] <Xliff> Yeah. That will blow up.

[06:52] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «(timeout)»

[06:52] <Xliff> m: my @a = (1..Inf).map( *.is-prime ); for @a { last if $_ > 2e6; .say }

[06:52] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «(timeout)False␤True␤True␤False␤True␤False␤True␤False␤False␤False␤True␤False␤True␤False␤False␤False␤True␤False␤True␤False␤False␤False␤True␤False␤False␤False␤False␤False␤True␤False␤True␤False…»

[06:52] <Xliff> m: my @a = (1..Inf).grep( *.is-prime ); for @a { last if $_ > 2e6; .say }

[06:53] <SmokeMachine> m: say .sum/.elems given (2..10).grep(:is-prime)

[06:53] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «(timeout)2␤3␤5␤7␤11␤13␤17␤19␤23␤29␤31␤37␤41␤43␤47␤53␤59␤61␤67␤71␤73␤79␤83␤89␤97␤101␤103␤107␤109␤113␤127␤131␤137␤139␤149␤151␤157␤163␤167␤173␤179␤181␤191␤193␤197␤1…»

[06:53] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «Cannot resolve caller grep(Range:D: :is-prime); none of these signatures match:␤    ($: Bool:D $t, *%_)␤    ($: Mu $t, *%_)␤  in block <unit> at <tmp> line 1␤␤»

[06:53] <Xliff> m: my @a = (1..Inf).grep( *.is-prime ); say @a[^200]

[06:53] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «(2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 101 103 107 109 113 127 131 137 139 149 151 157 163 167 173 179 181 191 193 197 199 211 223 227 229 233 239 241 251 257 263 269 271 277 281 283 293 307 311 313 317 331 337 347 349…»

[06:53] <Xliff> m: my @a = (1..Inf).grep( *.is-prime ); say @a[^300]

[06:53] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «(2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 101 103 107 109 113 127 131 137 139 149 151 157 163 167 173 179 181 191 193 197 199 211 223 227 229 233 239 241 251 257 263 269 271 277 281 283 293 307 311 313 317 331 337 347 349…»

[06:53] <Xliff> ^^ Much faster.

[06:54] <SmokeMachine> m: say .sum/.elems given (2..10).grep(:is-prime)

[06:54] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «Cannot resolve caller grep(Range:D: :is-prime); none of these signatures match:␤    ($: Bool:D $t, *%_)␤    ($: Mu $t, *%_)␤  in block <unit> at <tmp> line 1␤␤»

[06:54] <smallick> i see

[06:54] <SmokeMachine> m: say .sum/.elems given (2..10).Seq.grep(:is-prime)

[06:54] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «Cannot resolve caller grep(Seq:D: :is-prime); none of these signatures match:␤    ($: Bool:D $t, *%_)␤    ($: Mu $t, *%_)␤  in block <unit> at <tmp> line 1␤␤»

[06:55] <pony> you're passing a pair to grep

[06:55] <pony> namely is-prime => True

[06:55] <SmokeMachine> m: say (1,2,3,4,5). grep: :is-prime

[06:55] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «Cannot resolve caller grep(List:D: :is-prime); none of these signatures match:␤    ($: Bool:D $t, *%_)␤    ($: Mu $t, *%_)␤  in block <unit> at <tmp> line 1␤␤»

[06:56] <pony> grep(*.is-prime)

[06:56] <smallick> how to get 100 th digit of 0.123456789101112... ?

[06:56] <SmokeMachine> m: say 10 ~~ :is-prime

[06:56] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «False␤»

[06:56] <SmokeMachine> m: say 11 ~~ :is-prime

[06:56] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «True␤»

[06:57] <SmokeMachine> pony: ^^

[06:57] <pony> oh, hmm, weird

[06:57] <pony> I don't know the semantics of smart matching a pair like that

[06:57] <SmokeMachine> pony: that’s expected...

[06:58] <SmokeMachine> It calls the method with the key name...

[06:58] <pony> TIL

[06:58] <Geth> ¦ doc: finanalyst++ created pull request #2570: Remove sec links

[06:58] <Geth> ¦ doc: review: https://github.com/perl6/doc/pull/2570

[06:58] <SmokeMachine> I am almost sure grep: :is-prime used to work...

[06:59] *** domidumont joined
[07:00] *** p6bannerbot sets mode: +v domidumont

[07:00] <Xliff> smallick: I don't know how to do that one.

[07:01] <Xliff> Oh... wait!

[07:01] <smallick> Xliff: I do not know that also.

[07:02] <SmokeMachine> m: ^10 .grep: (:is-prime)

[07:02] <camelia> rakudo-moar 54fe8a1a8: ( no output )

[07:02] <Xliff> (1..100).join().say

[07:02] <Xliff> m: (1...100).join().say

[07:02] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100␤»

[07:02] <pony> m: (1..100).join('').comb[99]

[07:02] <camelia> rakudo-moar 54fe8a1a8: ( no output )

[07:02] <SmokeMachine> m: say ^10 .grep: (:is-prime)

[07:02] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «(2 3 5 7)␤»

[07:02] <pony> m: (1..100).join('').comb[99].put

[07:02] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «5␤»

[07:02] <Xliff> LOL! And pony beats me.

[07:02] <smallick> say (1..100).map(*.Str).join('')[100]

[07:03] <Xliff> smallick: You don't need the .map

[07:04] <smallick> oh, everything is cool

[07:04] <pony> is join lazy?

[07:04] <SmokeMachine> 05:02 <pony> m: (1..100).join('').substr(99, 1).put

[07:04] <SmokeMachine> m: (1..100).join('').substr(99, 1).put

[07:04] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «5␤»

[07:05] <pony> nice

[07:05] <smallick> m: say (1..100).join('')[99]

[07:05] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «Index out of range. Is: 99, should be in 0..0␤  in block <unit> at <tmp> line 1␤␤»

[07:05] <pony> m: (1..100).join('').is-lazy.so.ay

[07:05] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «No such method 'ay' for invocant of type 'Bool'. Did you mean any of these?␤    any␤    say␤␤  in block <unit> at <tmp> line 1␤␤»

[07:05] <pony> m: (1..100).join('').is-lazy.so.say

[07:05] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «False␤»

[07:06] <Xliff> (1..100).is-lazy.so.say

[07:06] <Xliff> m: (1..100).is-lazy.so.say

[07:06] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «False␤»

[07:06] <Xliff> m: (^100).is-lazy.so.say

[07:06] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «False␤»

[07:06] <Xliff> m: (^100).is-lazy.say

[07:06] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «False␤»

[07:06] <pony> (1...100).join('').is-lazy.so.say

[07:06] <pony> m: (1...100).join('').is-lazy.so.say

[07:06] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «False␤»

[07:06] * pony is-lazy

[07:06] <Xliff> m: (1, 2, 3 ... *).is-lazy.say

[07:06] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «True␤»

[07:07] <Xliff> m: (lazy (1..100).is-lazy.say

[07:07] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Unable to parse expression in parenthesized expression; couldn't find final ')' (corresponding starter was at line 1)␤at <tmp>:1␤------> 3(lazy (1..100).is-lazy.say7⏏5<EOL>␤    expecting any…»

[07:07] <Xliff> m: (lazy (1..100)).is-lazy.say

[07:07] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «True␤»

[07:07] <pony> I thought ranges were lazy

[07:07] <Xliff> Me too!

[07:08] <smallick> can you calculate sum of digits of Ack(4, 2)

[07:09] <SmokeMachine> m: say ^10 .Seq.is-lazy

[07:09] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «False␤»

[07:10] <pony> what

[07:10] <Xliff> pony: https://en.wikipedia.org/wiki/Ackermann_function

[07:10] <pony> no the other thing

[07:10] <Xliff> I would love to see that golf.

[07:10] <pony> I thought Seq was lazy

[07:10] <Xliff> m: say ^10.Seq.is-lazy

[07:10] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «Potential difficulties:␤    Precedence of ^ is looser than method call; please parenthesize␤    at <tmp>:1␤    ------> 3say ^107⏏5.Seq.is-lazy␤^0␤»

[07:11] <Xliff> m: say (^10).Seq.is-lazy

[07:11] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «False␤»

[07:11] <Xliff> m: use v6.c; say (^10).Seq.is-lazy

[07:11] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «False␤»

[07:11] <Xliff> m: use v6.c; say (^10).lazy.Seq.is-lazy

[07:11] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «True␤»

[07:12] <Xliff> OK. Good night! o7

[07:12] <pony> night

[07:13] *** smallick left
[07:17] *** smallick joined
[07:18] *** p6bannerbot sets mode: +v smallick

[07:19] <smallick> m: sub A { if m == 0 { n + 1 } else if n == 0 { A(m-1, 1) } else { A(m-1, A(m, n-1)) } } ; say A(4, 2).comb.sum

[07:19] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «5===SORRY!5===␤Null regex not allowed␤at <tmp>:1␤------> 3sub A { if m =7⏏5= 0 { n + 1 } else if n == 0 { A(m-1, 1)␤Missing block␤at <tmp>:1␤------> 3sub A { if m ==7⏏5 0 { n + 1 } else if n == 0 { A(m-1, 1) ␤    expectin…»

[07:20] <smallick> huh?

[07:22] <smallick> m: sub A { m == 0 ? n + 1 : n == 0 ? A(m-1, m) : A(m-1, A(m, n-1)) } ; say A(4, 2).comb.sum

[07:22] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «5===SORRY!5===␤Null regex not allowed␤at <tmp>:1␤------> 3sub A { m =7⏏5= 0 ? n + 1 : n == 0 ? A(m-1, m) : A(m-1␤Two terms in a row␤at <tmp>:1␤------> 3sub A { m ==7⏏5 0 ? n + 1 : n == 0 ? A(m-1, m) : A(m-1,␤    expecting…»

[07:24] <smallick> m: sub A (m, n) { m == 0 ?? n + 1 !! n == 0 ?? A(m-1, 1) !! A(m-1, A(m, n-1)) } ; say A(4, 2).comb.say

[07:24] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Couldn't find terminator , (corresponding , was at line 1)␤at <tmp>:1␤------> 3sub A (m, n7⏏5) { m == 0 ?? n + 1 !! n == 0 ?? A(m-1, ␤    expecting any of:␤        ,␤»

[07:26] <smallick> m: sub (2e6..*).grep(*.is-prime)[0]

[07:26] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Malformed parameter␤at <tmp>:1␤------> 3sub (2e67⏏5..*).grep(*.is-prime)[0]␤    expecting any of:␤        constraint␤        formal parameter␤»

[07:26] <smallick> m: say (2e6..*).grep(*.is-prime)[0]

[07:26] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «2000003␤»

[07:28] <smallick> m: (199990..2e6).grep(*.is-prime).say

[07:28] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «(199999 200003 200009 200017 200023 200029 200033 200041 200063 200087 200117 200131 200153 200159 200171 200177 200183 200191 200201 200227 200231 200237 200257 200273 200293 200297 200323 200329 200341 200351 200357 200363 200371 200381 200383 20040…»

[07:30] <smallick> m: ((2e6-10)..2e6).grep(*.is-prime).say

[07:30] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «(1999993)␤»

[07:31] <smallick> m: (2, 3, 5, 7, *+2 > 2e6).grep(*.is-prime).sum

[07:31] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «No such method 'is-prime' for invocant of type 'WhateverCode'␤  in block <unit> at <tmp> line 1␤␤»

[07:32] <smallick> m: say (2, 3, *+2 ... * > 2e6).grep: :is-prime

[07:32] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «Cannot resolve caller grep(Seq:D: :is-prime); none of these signatures match:␤    ($: Bool:D $t, *%_)␤    ($: Mu $t, *%_)␤  in block <unit> at <tmp> line 1␤␤»

[07:33] <smallick> m: say (2, 3, *+2 ... * > 2e6).grep(*.is-prime).sum

[07:33] <SmokeMachine> m: sub A (\m, \n) { m == 0 ?? n + 1 !! n == 0 ?? A(m-1, 1) !! A(m-1, A(m, n-1)) } ; say A(4, 2).comb.say

[07:34] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «(timeout)»

[07:34] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «(timeout)»

[07:34] <smallick> oh!!! I forgot about $igils

[07:37] <smallick> we cannot have custom precision like 50 or 100 digits after decimal point

[07:38] <smallick> m: say (1/2047).Num

[07:38] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «0.0004885197850512946␤»

[07:39] <smallick> just 19 digits

[07:42] <smallick> nativecallable6:  

[07:42] <nativecallable6> smallick, I cannot recognize this command. See wiki for some examples: https://github.com/perl6/whateverable/wiki/Nativecallable

[07:43] *** smallick left
[07:44] *** Sgeo left
[07:45] *** Sgeo joined
[07:45] *** p6bannerbot sets mode: +v Sgeo

[07:46] <SmokeMachine> m: (1/7).Rat: 20

[07:46] <camelia> rakudo-moar 54fe8a1a8: ( no output )

[07:46] <SmokeMachine> m: say (1/7).Rat: 20

[07:46] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «0.142857␤»

[07:47] <SmokeMachine> m: say (1/7).Num.Rat: 20

[07:47] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «0␤»

[07:48] <SmokeMachine> m: say (1/7).Real.Rat: 20

[07:48] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «0.142857␤»

[07:48] <SmokeMachine> m: say FatRat.new: 1, 7

[07:48] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «0.142857␤»

[07:50] <SmokeMachine> m: say FatRat.new(1, 7).Num

[07:50] <camelia> rakudo-moar 54fe8a1a8: OUTPUT: «0.14285714285714285␤»

[07:57] *** robertle joined
[07:57] *** p6bannerbot sets mode: +v robertle

[08:12] <tyil> AlexDaniel: I don't mind, so long as I can push/pull

[08:12] <tyil> I'll probably move it to git.tyil.nl once I get started on writing the k8s deployment for it

[08:12] *** w17t joined
[08:12] *** p6bannerbot sets mode: +v w17t

[08:13] *** rindolf joined
[08:14] *** p6bannerbot sets mode: +v rindolf

[08:16] *** lizmat joined
[08:16] *** p6bannerbot sets mode: +v lizmat

[08:32] *** sno left
[08:35] *** sno joined
[08:36] *** p6bannerbot sets mode: +v sno

[08:40] *** dakkar joined
[08:41] *** p6bannerbot sets mode: +v dakkar

[08:44] *** eiro1 left
[08:45] *** eiro joined
[08:45] *** eiro left
[08:53] *** [Sno] joined
[08:54] *** p6bannerbot sets mode: +v [Sno]

[08:54] *** kensanata joined
[08:54] *** p6bannerbot sets mode: +v kensanata

[08:55] *** sno left
[09:27] *** ExtraCrispy joined
[09:28] *** p6bannerbot sets mode: +v ExtraCrispy

[09:43] * lizmat drops a pin

[09:43] *** PotatoGim joined
[09:43] *** p6bannerbot sets mode: +v PotatoGim

[10:02] <jmerelo> Someone might want to take a look at this: https://github.com/perl6/doc/issues/2572

[10:09] *** rindolf left
[10:14] <cpan-p6> New module released to CPAN! Unix-Groups (0.0.4) by 03JSTOWE

[10:17] *** kst left
[10:23] *** rindolf joined
[10:24] *** p6bannerbot sets mode: +v rindolf

[10:26] <Geth> ¦ DBIish: 606089631f | (Jonathan Worthington)++ (committed using GitHub Web editor) | META6.json

[10:26] <Geth> ¦ DBIish: Bump version

[10:26] <Geth> ¦ DBIish: review: https://github.com/perl6/DBIish/commit/606089631f

[10:34] <Geth> ¦ doc: 616218a12f | (JJ Merelo)++ | doc/Language/classtut.pod6

[10:34] <Geth> ¦ doc: Minor changes, deindent, reflow

[10:34] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/616218a12f

[10:34] <Geth> ¦ doc: d45fabe5b1 | (JJ Merelo)++ | 2 files

[10:34] <Geth> ¦ doc: Modules.pod6 restructured

[10:34] <Geth> ¦ doc: 

[10:34] <Geth> ¦ doc: Mainly for correct indexing of use. This refs #2568, because, lo and

[10:34] <Geth> ¦ doc: behold, the generated document is back, although the search.js *does

[10:34] <Geth> ¦ doc: not point to it*. Anyway, this closes #2572.

[10:34] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/d45fabe5b1

[10:42] *** aborazmeh joined
[10:42] *** aborazmeh left
[10:42] *** aborazmeh joined
[10:42] *** p6bannerbot sets mode: +v aborazmeh

[10:43] *** p6bannerbot sets mode: +v aborazmeh

[11:03] <timotimo> skarsnik's post is being shared a lot on twitter, it's really nice to see

[11:05] *** domidumont left
[11:06] <lizmat> and in the top 20 of HN  :-)

[11:06] <jmerelo> Link?

[11:06] <lizmat> https://news.ycombinator.com

[11:06] <lizmat> #14 atm

[11:07] <tadzik> https://news.ycombinator.com/item?id=18904144

[11:07] <tadzik> I assume this :)

[11:07] <jmerelo> Cool!

[11:07] <lizmat> leejo++

[11:08] <lizmat> hmm... how do I slip an Array into a parameterize in nqp ?

[11:12] <lizmat> #11

[11:25] *** scimon joined
[11:25] *** p6bannerbot sets mode: +v scimon

[11:28] *** kensanata left
[11:38] *** MasterDuke left
[11:39] *** leah2 joined
[11:40] *** p6bannerbot sets mode: +v leah2

[11:58] *** kensanata joined
[11:58] *** p6bannerbot sets mode: +v kensanata

[12:04] *** sena_kun joined
[12:05] *** p6bannerbot sets mode: +v sena_kun

[12:20] *** aborazmeh left
[12:28] *** domidumont joined
[12:29] *** p6bannerbot sets mode: +v domidumont

[12:33] *** thundergnat joined
[12:33] *** p6bannerbot sets mode: +v thundergnat

[12:34] <thundergnat> .tell smallick 	smallick > ... custom precision like 50 or 100 digits after decimal point. - Maybe look into the module Rat::Precise for configurable precision?  https://modules.perl6.org/search/?q=Rat%3A%3APrecise

[12:34] <yoleaux> thundergnat: I'll pass your message to smallick.

[12:35] <lizmat> #7  :-)

[12:36] *** thundergnat left
[12:39] <Geth> ¦ doc: 7f4fa0ce9a | (Elizabeth Mattijsen)++ | doc/Type/Parameter.pod6

[12:39] <Geth> ¦ doc: First stab at documenting Parameter.new

[12:39] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/7f4fa0ce9a

[12:50] *** aborazmeh joined
[12:50] *** aborazmeh left
[12:50] *** aborazmeh joined
[12:50] *** p6bannerbot sets mode: +v aborazmeh

[12:50] *** p6bannerbot sets mode: +v aborazmeh

[12:53] *** mowcat left
[12:57] <Altreus> I've discovered a problem in Perl5's cpan where you cannot delete files from a previous installation of a module, thus forcing you to constantly be vigilant that every version you release can cope with the existence of such files

[12:57] <Altreus> Does this problem exist in zef too?

[12:57] <Altreus> Or in the general case of installing Perl6 modules?

[12:57] <Altreus> (If there is one)

[13:00] *** pmurias joined
[13:00] *** p6bannerbot sets mode: +v pmurias

[13:01] <pmurias> is there a way to warn with a full stack trace?

[13:02] <lizmat> pmurias: not afaik

[13:03] <tyil> CATCH { .note; .resume } ?

[13:03] <tyil> and then just die instead of warn

[13:07] <moritz> aren't warnings control exceptions? you'd use CONTROL then

[13:08] <moritz> m: CONTROL { say .^name; resume }; warn "42 bottles"

[13:08] <camelia> rakudo-moar eb50d8cef: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Undeclared routine:␤    resume used at line 1. Did you mean 'reduce', 'rename'?␤␤»

[13:08] <moritz> m: CONTROL { say .^name; .resume }; warn "42 bottles"

[13:08] <camelia> rakudo-moar eb50d8cef: OUTPUT: «CX::Warn␤»

[13:08] <lizmat> moritz: but the exception didn't get generated with a backtrace, out of performance reasons afaik

[13:08] <moritz> m: CONTROL { when CX::Warn { say .backtrace; note $_; .resume } }; warn "42 bottles"

[13:08] <camelia> rakudo-moar eb50d8cef: OUTPUT: «Backtrace(2 frames)␤42 bottles␤  in block <unit> at <tmp> line 1␤␤»

[13:08] <lizmat> ah, so it did ?

[13:09] <moritz> m: CONTROL { when CX::Warn { say .backtrace; note $_; .resume } }; sub f() { warn "42 bottles" }; sub g() { f() }; g()

[13:09] <camelia> rakudo-moar eb50d8cef: OUTPUT: «Backtrace(4 frames)␤42 bottles␤  in sub f at <tmp> line 1␤  in sub g at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[13:09] <moritz> lizmat: handler is run before the stack is unwound

[13:09] <moritz> so you still have all the information you need for the backtrace

[13:09] <moritz> (iirc)

[13:10] <lizmat> then it's just a matter of adding a method to CX::Warn ?

[13:10] <moritz> (also, I'm on painkillers, so everything I write could be halluzination-induced)

[13:10] * lizmat knows the feeling

[13:10] <lizmat> my back gave out last weekend pretty badly... better now

[13:13] <moritz> eeks

[13:13] <moritz> for me, it was third molars removal

[13:16] *** [Sno] left
[13:16] *** eiro joined
[13:16] *** eiro left
[13:17] <lizmat> ah, that fun....

[13:17] <lizmat> been there, done that as well  :-)

[13:18] *** eiro joined
[13:18] *** sno joined
[13:19] *** p6bannerbot sets mode: +v eiro

[13:19] *** p6bannerbot sets mode: +v sno

[13:36] *** smallick joined
[13:37] *** p6bannerbot sets mode: +v smallick

[13:38] <smallick> m: use Rat::Precise; say (1/2047).precise(100);

[13:38] <yoleaux> 12:34Z <thundergnat> smallick: smallick > ... custom precision like 50 or 100 digits after decimal point. - Maybe look into the module Rat::Precise for configurable precision?  https://modules.perl6.org/search/?q=Rat%3A%3APrecise

[13:38] <camelia> rakudo-moar eb50d8cef: OUTPUT: «===SORRY!===␤Could not find Rat::Precise at line 1 in:␤    /home/camelia/.perl6␤    /home/camelia/rakudo-m-inst-2/share/perl6/site␤    /home/camelia/rakudo-m-inst-2/share/perl6/vendor␤    /home/camelia/rakudo-m-inst-2/share/perl6␤    CompU…»

[13:40] <smallick> how to work with huge numbers precisely, like 100! or something like that...

[13:41] <smallick> m: say [*] [2..100]

[13:41] <camelia> rakudo-moar eb50d8cef: OUTPUT: «93326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000␤»

[13:41] <smallick> m: say [*] 2..1000

[13:42] <camelia> rakudo-moar eb50d8cef: OUTPUT: «40238726007709377354370243392300398571937486421071463254379991042993851239862902059204420848696940480047998861019719605863166687299480855890132382966994459099742450408707375991882362772718873251977950595099527612087497546249704360141827809464649629105…»

[13:42] <smallick> oh, it **just** works!

[13:43] <smallick> m: # how about a

[13:43] <camelia> rakudo-moar eb50d8cef: ( no output )

[13:43] <smallick> sub postfix:<!> (Int $n) {

[13:43] <smallick>   [*] 2..$n

[13:43] <smallick> }

[13:44] <smallick> oh, crap!

[13:44] *** aborazmeh left
[13:45] <smallick> m: sub postfix:<!> (Int $n) { [*] 2..$n } ; say 20!

[13:45] <camelia> rakudo-moar eb50d8cef: OUTPUT: «2432902008176640000␤»

[13:46] <smallick> camelia: help

[13:46] <camelia> smallick: Usage: <(prof-m|rakudo-jvm|nqp-js|nqp-moarvm|nqp-jvm|debug-cat|p5-to-p6|star-m|rakudo-moar|rm|star|nqp-q|master|p56|r|j|rakudo|sm|rj|p6|nqp-mvm|nqp|r-j|nqp-m|perl6|r-m|m|r-jvm)(?^::\s(?!OUTPUT)) $perl6_program>

[13:47] <smallick> who are r and j

[13:47] <smallick> and sm

[13:48] <dalek> Inline-Perl6: 9e5c196 | niner++ | / (2 files):

[13:48] <yoleaux> 3 Aug 2018 19:03Z <AlexDaniel> dalek: I miss you!

[13:48] <dalek> Inline-Perl6: Use the same perl6-m executable from configure time also at runtime

[13:48] <dalek> Inline-Perl6: 

[13:48] <dalek> Inline-Perl6: Fixes issues with precompilation failing due to a hard coded perl6 executable

[13:48] <dalek> Inline-Perl6: name.

[13:48] <dalek> Inline-Perl6: review: https://github.com/niner/Inline-Perl6/commit/9e5c1968e1

[13:48] <dalek> Inline-Perl6: f1c1717 | niner++ | / (2 files):

[13:48] <dalek> Inline-Perl6: Support nqp with non-standard libdir

[13:48] <dalek> Inline-Perl6: review: https://github.com/niner/Inline-Perl6/commit/f1c17179d6

[13:48] <smallick> and sm 

[13:49] <sena_kun> r: say $*VM;

[13:49] <sena_kun> j: say $*VM;

[13:49] <camelia> rakudo-jvm 08b449e1a: OUTPUT: «jvm (1.8)␤»

[13:49] <camelia> ..rakudo-moar eb50d8cef: OUTPUT: «moar (2018.12.13.g.473324.ee.3)␤»

[13:49] <camelia> rakudo-jvm 08b449e1a: OUTPUT: «jvm (1.8)␤»

[13:49] <sena_kun> sm: say $*VM;

[13:49] <camelia> star-m 2017.07: OUTPUT: «moar (2017.07)␤»

[13:49] <sena_kun> sm == star distribution, r is rakudo-moar + rakudo-jvm, I think, and j == rakudo-jvm. :)

[13:50] <smallick> thanks

[13:51] <smallick> std: say 1

[13:53] <smallick> how can i calculate median of an Num array?

[13:54] <sena_kun> m: my @a = <1 2 4 3 5>; say @a[@a.elems / 2];

[13:54] <camelia> rakudo-moar 8ad750ab5: OUTPUT: «4␤»

[13:55] <sena_kun> smallick, like this?

[13:55] <dalek> Inline-Perl6: 0162fc5 | niner++ | / (2 files):

[13:55] <dalek> Inline-Perl6: Disable broken test for now - needs rethinking

[13:55] <dalek> Inline-Perl6: review: https://github.com/niner/Inline-Perl6/commit/0162fc50f9

[13:56] <sena_kun> m: my @a = <1 2 4 3 5>; say @a[*/2];

[13:56] <camelia> rakudo-moar 8ad750ab5: OUTPUT: «4␤»

[13:56] <sena_kun> is shorter. :)

[13:57] <smallick> sena_kun: you have to sort it before, which is what i want to know how to do. Just a .sort 

[13:57] <dalek> Inline-Perl6: b3e667c | niner++ | / (2 files):

[13:57] <dalek> Inline-Perl6: Version 0.09

[13:57] <dalek> Inline-Perl6: review: https://github.com/niner/Inline-Perl6/commit/b3e667cf1d

[13:57] <smallick> m: say (2, 3, 5, 1, 7, 9).sort

[13:57] <camelia> rakudo-moar 8ad750ab5: OUTPUT: «(1 2 3 5 7 9)␤»

[13:57] <smallick> that works!

[13:57] <sena_kun> then .sort[*/2]; :)

[13:58] <smallick> huh? [*/2]

[13:59] <sena_kun> smallick, see https://docs.perl6.org/type/Whatever

[13:59] <smallick> m: say (2,3,5,6,3,9).sort[*/2]

[13:59] <camelia> rakudo-moar 8ad750ab5: OUTPUT: «5␤»

[13:59] <sena_kun> m:  my @a = <3 2 1 2 3>; say @a.sort[-> $length { $length / 2}];

[13:59] <camelia> rakudo-moar 8ad750ab5: OUTPUT: «2␤»

[14:00] <sena_kun> the thing is that `[]` can not only use numbers, but also a code block that recieves length as an argument. You can get it explicitly, but `*` is just a short notation for it.

[14:00] <sena_kun> s/use/receive/

[14:01] <sena_kun> super explicit way will be...

[14:01] <sena_kun> m: sub median-index($length) { $length / 2 }; my @a = <1 2 4 3 5>; @a.sort[&median-index].say;

[14:01] <camelia> rakudo-moar 8ad750ab5: OUTPUT: «3␤»

[14:02] <smallick> m: say <3 2 1 3 5>.sort[*/2]

[14:02] <camelia> rakudo-moar 8ad750ab5: OUTPUT: «3␤»

[14:02] <sena_kun> here we are explicitly defining a subroutine that will calculate an index based on length passed and pass this subroutine to `[]` operator.

[14:02] <smallick> okay, and what about mode?

[14:02] <sena_kun> well...

[14:03] <sena_kun> it might be not the best way, I think, but I'd do it like this:

[14:04] <sena_kun> m: my @a = <1 1 1 2 2>; @a.Bag.antipairs.max.value.say;  # so long. :)

[14:04] <camelia> rakudo-moar 8ad750ab5: OUTPUT: «1␤»

[14:04] <smallick> what?

[14:05] <sena_kun> here we are converting our array to Bag (https://docs.perl6.org/type/Bag) which is a "collection of distinct elements in no particular order that each have an integer weight assigned to them signifying how many copies of that element are considered "in the bag".".

[14:05] <sena_kun> so it is basically an associative(hash) from value to number of a value encountered.

[14:06] <jnthn> I guess @a.Bag.max(*.value).key.say is a bit shorter

[14:06] <sena_kun> then we are calling `.antipairs` to swap keys and values(thus having number of occurrences being key and a value being a, well, value) and call `.max` on it to get an element with the most occurrences, and getting value of this element.

[14:06] <smallick> how many sub classes are there of Mu (direct sub classes)

[14:07] <sena_kun> jnthn, yes, that's probably also easier to understand.

[14:07] <jnthn> Yeah, for me at least :)

[14:07] <jnthn> .Bag is a neat way to do it though

[14:07] <jnthn> smallick: In the builtins, I think just Any and Junction

[14:07] <sena_kun> smallick, direct ones, I think, are `Any` and `Junction`.

[14:08] <sena_kun> https://docs.perl6.org/type/Mu <- you can see a type graph at the bottom of the page.

[14:08] <smallick> going to see it...

[14:08] *** smallick left
[14:09] * sena_kun .oO ( `max value key say` is surprisingly neat to read )

[14:12] <lizmat> m: <a a b b>.Bag.max(*.value).say for ^10

[14:12] <camelia> rakudo-moar 8ad750ab5: OUTPUT: «a => 2␤a => 2␤b => 2␤b => 2␤a => 2␤b => 2␤b => 2␤a => 2␤b => 2␤b => 2␤»

[14:12] <lizmat> I guess .max on Bag needs to return a Seq

[14:17] <jnthn> ?

[14:17] <jnthn> Why?

[14:18] <lizmat> well...  if you have 2 entries in the Bag that have the max value, then the one you will see is indeterminate

[14:18] <jnthn> Both are correct, though?

[14:18] <lizmat> yes

[14:19] <jnthn> You'll get this effect whatever you do if the solution involves a hash

[14:19] <jnthn> Short of storing original index too

[14:19] <lizmat> true

[14:23] <Geth> ¦ doc: 2dda092ad8 | (Elizabeth Mattijsen)++ | doc/Type/Set.pod6

[14:23] <Geth> ¦ doc: Elaborate a bit about Set.new and my %s is Set

[14:23] <Geth> ¦ doc: 

[14:23] <Geth> ¦ doc: Noting the new parameterization feature as available since 2019.01

[14:23] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/2dda092ad8

[14:28] *** smallick joined
[14:28] *** sno left
[14:28] *** p6bannerbot sets mode: +v smallick

[14:29] <smallick> how you can have the postfix op ! for Int to calculate factorial **built-in**

[14:30] *** jmerelo left
[14:30] *** sno joined
[14:31] <smallick> i tried

[14:31] <smallick> m: sub postfix:<!> (Int $n) { [*] 2..$n } ; say 10!

[14:31] <camelia> rakudo-moar 8ad750ab5: OUTPUT: «3628800␤»

[14:31] *** p6bannerbot sets mode: +v sno

[14:31] <smallick> m: say 5!

[14:31] <camelia> rakudo-moar 6a8f08b95: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Bogus postfix␤at <tmp>:1␤------> 3say 57⏏5!␤    expecting any of:␤        infix␤        infix stopper␤        postfix␤        statement end␤        statement modifier␤        sta…»

[14:32] <sena_kun> smallick, camelia doesn't remember previous input.

[14:32] <smallick> so ! is not a built in

[14:32] <tyil> sena_kun: one of the things I like of Perl 6 is how easy it is to read when you chain calls like that

[14:32] <moritz> it's not part of the language, so you have to either define it, or import it from a module

[14:32] <tyil> makes it easy to write concise and clean code

[14:32] <smallick> can you add it to the language

[14:33] <sena_kun> tyil, indeed. reminds me of better parts of Haskell in this regard.

[14:33] <tyil> though it seems you cannot put one call per line if you have a .&call

[14:34] *** PavelB joined
[14:34] *** p6bannerbot sets mode: +v PavelB

[14:34] * pmurias hates the .&sub thing 

[14:35] *** molaf joined
[14:35] <jnthn> smallick: You'd just put it in a module, export it, and `use` that module.

[14:35] <tyil> pmurias: the postfix call part or the & part of the postfix call specifically?

[14:36] *** p6bannerbot sets mode: +v molaf

[14:37] <pmurias> tyil: the combination of it looking super ugly and making a sub call look like a method call when it's not ;)

[14:37] <smallick> m: (2 ** 500).comb.sum.say

[14:37] <camelia> rakudo-moar 6a8f08b95: OUTPUT: «679␤»

[14:37] <tyil> to differentiate between the two is what the & does

[14:38] <tyil> my issue is that I can't write it spread over multiple lines when there's a & (example: https://tio.run/##K0gtyjH7/7@4NEkhLT9fQUMlUVOhWkElUaGWi0upJLW4RIlLQUFPDSgHoosTK63//wcA)

[14:38] <smallick> how to know how much time a code needs to evaluate?

[14:38] <tyil> smallick: my $begin = now; { do your code }; say "Took {now - $begin}";

[14:39] <sena_kun> m: my $time = now; (2 ** 500).comb.sum.say; say now - $time;

[14:39] <camelia> rakudo-moar 6a8f08b95: OUTPUT: «679␤0.00687025␤»

[14:40] <smallick> m: my $t = now; say (2 ** 500500).comb.sum; say now - $t;

[14:40] <camelia> rakudo-moar 6a8f08b95: OUTPUT: «678112␤12.454888␤»

[14:41] <smallick> built in for factorize

[14:42] <vrurg> m: (2 ** 500).comb.sum.say; say now - BEGIN now;

[14:42] <camelia> rakudo-moar 6a8f08b95: OUTPUT: «679␤0.0146382␤»

[14:44] <smallick> begin "takes" more time?!!

[14:45] <jnthn> m: (2 ** 500).comb.sum.say; say now - INIT now;

[14:45] <camelia> rakudo-moar 6a8f08b95: OUTPUT: «679␤0.0067555␤»

[14:45] <smallick> m: say (1 .. 24).grep(24%%*)

[14:45] <camelia> rakudo-moar 6a8f08b95: OUTPUT: «(1 2 3 4 6 8 12 24)␤»

[14:45] <jnthn> BEGIN runs at compile time, so you're counting the time it takes for compile/optimize/assemble the code

[14:45] *** sno left
[14:46] <smallick> m: (1 .. 678112).grep(678112%%*).say

[14:46] <camelia> rakudo-moar 6a8f08b95: OUTPUT: «(1 2 4 8 16 32 21191 42382 84764 169528 339056 678112)␤»

[14:47] <smallick> m: say 2.even; say 3.even;

[14:47] <camelia> rakudo-moar 6a8f08b95: OUTPUT: «No such method 'even' for invocant of type 'Int'␤  in block <unit> at <tmp> line 1␤␤»

[14:48] <smallick> no even??

[14:48] <smallick> m: say (546754%%2) # to test evenness

[14:48] <camelia> rakudo-moar 6a8f08b95: OUTPUT: «True␤»

[14:49] <smallick> how to get binary format of a number (11 ===> 1011)

[14:49] <smallick> or to other bases

[14:50] <moritz> m: say 11.base(2)

[14:50] <camelia> rakudo-moar 6a8f08b95: OUTPUT: «1011␤»

[14:50] <sena_kun> m: say 15.base(17)

[14:50] <camelia> rakudo-moar 6a8f08b95: OUTPUT: «F␤»

[14:51] <sena_kun> m: say 17.base(17)

[14:51] <camelia> rakudo-moar 6a8f08b95: OUTPUT: «10␤»

[14:51] <sena_kun> m: say 17.base(4)

[14:51] <camelia> rakudo-moar 6a8f08b95: OUTPUT: «101␤»

[14:51] <smallick> m: 678112.base(2).say

[14:51] <camelia> rakudo-moar 6a8f08b95: OUTPUT: «10100101100011100000␤»

[14:52] <tyil> m: dd 10 %% 2 # is even

[14:52] <camelia> rakudo-moar 6a8f08b95: OUTPUT: «Bool::True␤»

[14:52] <tyil> smallick: ^

[14:53] <tyil> oh, you found it a little while after already

[14:53] <tyil> ignore me!

[14:53] <smallick> what is dd

[14:53] <lizmat> smallick: dd is a tiny data dumper, so tiny it has lost the 't'

[14:54] <smallick> how to convert to base 10 (ff ===> 255)

[14:54] *** sno joined
[14:55] <tyil> m: "0xff".Int

[14:55] <camelia> rakudo-moar 6a8f08b95: ( no output )

[14:55] <tyil> m: "0xff".Int.say

[14:55] <camelia> rakudo-moar 6a8f08b95: OUTPUT: «255␤»

[14:55] *** p6bannerbot sets mode: +v sno

[14:55] <smallick> other than base 16 ?

[14:55] <moritz> m: say :16('ff')

[14:55] <camelia> rakudo-moar 6a8f08b95: OUTPUT: «255␤»

[14:56] <moritz> m: say :17('ff')

[14:56] <camelia> rakudo-moar 6a8f08b95: OUTPUT: «270␤»

[14:56] <smallick> m: :36('smallick').say

[14:56] <camelia> rakudo-moar 6a8f08b95: OUTPUT: «2242726743332␤»

[14:57] <smallick> m: dd :2

[14:57] <camelia> rakudo-moar 6a8f08b95: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Malformed radix number␤at <tmp>:1␤------> 3dd :27⏏5<EOL>␤    expecting any of:␤        number in radix notation␤»

[14:57] <smallick> oh, notation

[14:58] *** Actualeyes joined
[14:58] *** sno left
[14:58] <moritz> m: say 'ff'.parse-base(16)

[14:58] <camelia> rakudo-moar 6a8f08b95: OUTPUT: «255␤»

[14:59] <Geth> ¦ doc: 8a76fff6c8 | (Elizabeth Mattijsen)++ | doc/Type/SetHash.pod6

[14:59] <Geth> ¦ doc: Elaborate a bit about my %s is SetHash

[14:59] <Geth> ¦ doc: 

[14:59] <Geth> ¦ doc: Also noting the new parameterization feature as available since 2019.01

[14:59] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/8a76fff6c8

[14:59] *** p6bannerbot sets mode: +v Actualeyes

[14:59] <smallick> oh, sooo many ways!

[15:01] <smallick> how many operators are there in this language?

[15:01] *** sno joined
[15:02] *** p6bannerbot sets mode: +v sno

[15:02] <tyil> at least 14

[15:02] <sena_kun> https://docs.perl6.org/language/operators <- smallick 

[15:03] *** smallick left
[15:09] *** w17t left
[15:10] *** jme` left
[15:11] *** curan left
[15:17] <Util> sena_kun: Great reference! I see that we also need to add the atomic operators.

[15:18] *** molaf left
[15:21] *** smallick joined
[15:21] *** pmurias left
[15:21] *** p6bannerbot sets mode: +v smallick

[15:22] <smallick> exhausted...

[15:22] *** pmurias joined
[15:22] *** p6bannerbot sets mode: +v pmurias

[15:23] <smallick> m: (২..১০).say

[15:23] <camelia> rakudo-moar 6a8f08b95: OUTPUT: «2..10␤»

[15:26] <smallick> why (-1).sqrt != 1i

[15:26] <smallick> m: say 1i != (-1).sqrt

[15:26] <camelia> rakudo-moar 6a8f08b95: OUTPUT: «True␤»

[15:27] <smallick> m: say 1i ** 2

[15:27] <camelia> rakudo-moar 6a8f08b95: OUTPUT: «-1+1.2246467991473532e-16i␤»

[15:28] <smallick> what is that??

[15:28] <pmurias> tyil: you can make it work like that: https://tio.run/##K0gtyjH7/7@4NEkhLT9fQUMlUVOhWkElUaGWi0upJLW4RCE3vyhVKYZLQUFPDagCzChOrLT@/x8A

[15:28] <pmurias> tyil: with a trailing \

[15:28] <tyil> heh

[15:28] <moritz> smallick: it's floating-point math

[15:28] <tyil> that's very unsexy

[15:28] <smallick> m: say 1i * 1i =~= -1

[15:28] <camelia> rakudo-moar 6a8f08b95: OUTPUT: «True␤»

[15:30] <moritz> m: say i*i

[15:30] <camelia> rakudo-moar 6a8f08b95: OUTPUT: «-1+0i␤»

[15:30] <moritz> m: say i*i == -1

[15:30] <camelia> rakudo-moar 6a8f08b95: OUTPUT: «True␤»

[15:30] <smallick> m: say 1i == i

[15:30] <camelia> rakudo-moar 6a8f08b95: OUTPUT: «True␤»

[15:31] <smallick> m: say 1i * 1i

[15:31] <camelia> rakudo-moar 6a8f08b95: OUTPUT: «-1+0i␤»

[15:31] <smallick> m: say i ** 2 == i * i

[15:31] <camelia> rakudo-moar 6a8f08b95: OUTPUT: «False␤»

[15:33] <smallick> m: say (1/2 + (i*3.sqrt)/2) ** 3

[15:33] <camelia> rakudo-moar 6a8f08b95: OUTPUT: «-0.9999999999999997+1.2246467991473527e-16i␤»

[15:35] <smallick> uhh! Where

[15:35] <smallick> m: say 0.1 + 0.2 == 0.3

[15:35] <smallick> what it is?!

[15:35] <camelia> rakudo-moar 6a8f08b95: OUTPUT: «True␤»

[15:36] <sena_kun> smallick, well... Perl 6. :)

[15:36] *** apathor left
[15:36] <sena_kun> ah, didn't backlog enough, sorry.

[15:37] <sena_kun> I think there are still some issues around imaginary numbers. :( Likely bugreported already though.

[15:37] <smallick> that's okay.

[15:37] <SmokeMachine> m: dd i * i; dd i ** 2

[15:37] <camelia> rakudo-moar 6a8f08b95: OUTPUT: «<-1+0i>␤<-1+1.2246467991473532e-16i>␤»

[15:37] <sena_kun> at least I saw a conversation about i ** 2 not being -1 as a bug.

[15:39] *** apathor joined
[15:39] <pmurias> tyil: IMHO the unsexy trailing \ fits perfectly with the .& syntax ;)

[15:40] <tyil> heh

[15:40] *** p6bannerbot sets mode: +v apathor

[15:40] <tyil> I think the & to indicate you're calling a sub instead of a method isn't too bad

[15:40] <tyil> there's at least a good reason for it (indicate its about a sub)

[15:41] <tyil> but I don't see any good reason to not allow .&foo on a new line, but every other .sub is ok

[15:45] <smallick> m: say -i ** 4

[15:45] <camelia> rakudo-moar 6a8f08b95: OUTPUT: «-1+2.4492935982947064e-16i␤»

[15:45] <smallick> m: say (-i)**4

[15:45] <camelia> rakudo-moar 6a8f08b95: OUTPUT: «1+2.4492935982947064e-16i␤»

[15:46] *** cpan-p6 left
[15:46] *** cpan-p6 joined
[15:46] <cpan-p6> 03cpan-p6 reporting for duty! [Perl 6] 02https://git.tyil.nl/perl6/app-cpan-uploadnotifierbot

[15:46] <smallick> so, pow with imaginary seems to have bugs

[15:46] <cpan-p6> New module released to CPAN! Object-Permission-Group (0.0.3) by 03JSTOWE

[15:46] <cpan-p6> New module released to CPAN! Object-Permission (0.0.3) by 03JSTOWE

[15:46] <moritz> smallick: how so?

[15:46] <tyil> one small issue with cpan-p6 

[15:47] *** p6bannerbot sets mode: +v cpan-p6

[15:47] <smallick> see above

[15:47] <smallick> m: say i*i != i**2

[15:47] <camelia> rakudo-moar 6a8f08b95: OUTPUT: «True␤»

[15:47] <tyil> whenever an exception occurs in the start { } block (https://git.tyil.nl/perl6/app-cpan-uploadnotifierbot/src/branch/master/lib/App/CPAN/UploadNotifierBot/Notify.pm6#L56), it doesn't seem to recover at all, even though I have added a .resume call in the CATCH { }

[15:48] <moritz> first of all, normal exceptions aren't usually .resume'able

[15:48] <smallick> morits: saw that

[15:49] <smallick> sorry 

[15:49] <moritz> smallick: floating point imprecsion, not a bug

[15:49] <moritz> m: say i*i - i**2

[15:49] <camelia> rakudo-moar 6a8f08b95: OUTPUT: «0-1.2246467991473532e-16i␤»

[15:49] <smallick> so 1i is stored as float

[15:50] <moritz> yes

[15:50] *** Sgeo_ joined
[15:50] <smallick> great

[15:50] <moritz> the design document speculated about a parameterizable Complex, but nobody bothered implementing it yet

[15:50] *** Sgeo left
[15:51] <smallick> m: say e ** (i * pi) + 1

[15:51] <camelia> rakudo-moar 6a8f08b95: OUTPUT: «0+1.2246467991473532e-16i␤»

[15:51] *** p6bannerbot sets mode: +v Sgeo_

[15:52] <smallick> what is the minimum error of perl6 float?

[15:53] <moritz> it's more of a question of what errors operations have, not floats

[15:54] <smallick> so what's the epsilon here

[15:55] <moritz> looks like it's 1.2e-16 for this operation

[15:55] <smallick> and what is the smallest number > 0 here

[15:56] <AlexDaniel> nine: please change Inline-Perl6 to use Geth

[15:56] <AlexDaniel> .tell dalek I miss you!

[15:56] <yoleaux> AlexDaniel: I'll pass your message to dalek.

[15:58] *** smallick left
[15:58] <Geth> ¦ URI-Encode: cfa++ created pull request #10: Support lexical $_ (v6.d), bump version number.

[15:58] <Geth> ¦ URI-Encode: review: https://github.com/perl6-community-modules/URI-Encode/pull/10

[15:59] *** Sgeo_ left
[15:59] *** Sgeo_ joined
[15:59] *** cfa joined
[15:59] *** p6bannerbot sets mode: +v cfa

[16:00] *** p6bannerbot sets mode: +v Sgeo_

[16:01] *** Harzilein joined
[16:01] <Harzilein> hi

[16:02] <sena_kun> Harzilein, o/

[16:02] <moritz> hello Harzilein 

[16:02] *** p6bannerbot sets mode: +v Harzilein

[16:02] <Harzilein> is the last version of rakudo that will work with parrot (specifically, build inside plumage) documented somewhere?

[16:04] <pmurias> Harzilein: what are you planning? ;)

[16:05] <Harzilein> pmurias: i set up plumage ages ago and want to "catch them all" wrt building (preferably running) its projects in whatever state

[16:06] <tyil> moritz: you started with a first of all, is there any other info you can give me to be able to catch the exceptions in that start { } block while keeping that code running correctly?

[16:07] <tyil> if not, I might look into any exception in the start { } block to kill the bot compeltely, and make it autostart whenever it dies

[16:07] *** pmurias left
[16:08] *** pmurias joined
[16:08] *** p6bannerbot sets mode: +v pmurias

[16:09] <moritz> tyil: sorry, where does the exception come from?

[16:10] <Harzilein> oh well, guess i'll need to turn over some old archives of smoke test results and work up from there...

[16:10] <tyil> the last one came from .get on https://git.tyil.nl/perl6/app-cpan-uploadnotifierbot/src/branch/master/lib/App/CPAN/UploadNotifierBot/Notify.pm6#L79

[16:11] <moritz> have you gotten rid of the .resume yet?

[16:11] <tyil> no, the code in that repo is the same as that runs

[16:11] <tyil> I'm at work, but I intend to apply fixes once I get home

[16:11] <moritz> well, get rid of it as a first step

[16:12] <moritz> the point is that code throws exceptions because it can't handle with an error condition, and thus escaletes it to its caller

[16:12] <jnthn> Harzilein: 9a75383d91d69 was the Rakudo commit that removed Parrot support

[16:12] <tyil> moritz: I shall

[16:13] <moritz> when you instead try to resume the exception, you are putting code into a condition that it was not designed for

[16:13] <tyil> I added the .resume with the intention of it not killing the entire thread

[16:13] <tyil> but if it's not doing that, there's no reason to keep it for me

[16:14] <El_Che> As we are lacking LDAP modules, this may be relevant to Perl 6 people as well: https://bugzilla.redhat.com/show_bug.cgi?id=1663063 (RHEL/CentOS 8 will remove perl-LDAP).

[16:14] <SmokeMachine> moritz: but why i ** 2 is different from i * i?

[16:15] <moritz> SmokeMachine: because ** is a general operator that deals with all kinds of right-hand sides, and thus uses a very generic algorithm

[16:16] <Harzilein> jnthn: i'll start with that then, thanks :)

[16:16] <moritz> and the generic algorithm has numerical associated with it that 1i * 1i can avoid

[16:18] <cpan-p6> New module released to CPAN! App-CPAN (0.0.1) by 03TYIL

[16:19] <moritz> also, lots of people mention the fact that there is some small imprecision, but nobody so far has mentioned a use case where this small imprecision hurts more than general floatin point imprecisions

[16:19] *** apathor left
[16:20] <sena_kun> El_Che, how though? I just see RedHat maintainers being a bit LTA.

[16:22] *** jmerelo joined
[16:22] *** p6bannerbot sets mode: +v jmerelo

[16:23] <moritz> tyil: btw you need to smart-match $_ in a CATCH block to mark the exception has handled

[16:24] <moritz> if you don't care about the exception type, use CATCH { default { ... } }

[16:25] <moritz> though in this case, I'd go with putting all that extra code in a separate method, and then calling  try self.interval-callback() or so

[16:25] <El_Che> sena_kun: "Love To All"?

[16:26] <sena_kun> El_Che, less than awesome.

[16:26] *** kensanata left
[16:26] <sena_kun> El_Che, I mean, that's odd to remove a package without any reasonable explanation provided, but I am not sure what is the link to Perl 6 here. :)

[16:28] <El_Che> sena_kun: we don't have ldap support, so people may be using the Perl 5 bindings

[16:29] <sena_kun> El_Che, ah, I see. That's unfortunate though.

[16:29] * sena_kun works on ldap module

[16:29] <sena_kun> s/though/then/

[16:35] *** powerbit left
[16:35] <El_Che> sena_kun: are you?

[16:35] <b2gills> .tell smallick You can choose the number of digits after the decimal with `.base` on Rationals  `(1/2047).base(10,50)`, or get all the precision with `.base-repeating`

[16:35] <yoleaux> b2gills: I'll pass your message to smallick.

[16:35] <b2gills> .tell Altreus zef can't have the cpan problem of uninstalled files being left behind because different versions of a module are stored at different places

[16:35] <yoleaux> b2gills: I'll pass your message to Altreus.

[16:35] <sena_kun> El_Che, am I what? :)

[16:36] <Altreus> excellent

[16:36] <yoleaux> 16:35Z <b2gills> Altreus: zef can't have the cpan problem of uninstalled files being left behind because different versions of a module are stored at different places

[16:36] *** lucasb joined
[16:36] *** p6bannerbot sets mode: +v lucasb

[16:36] *** w17t joined
[16:36] *** p6bannerbot sets mode: +v w17t

[16:36] <Altreus> So that different things can rely on different versions of the same module?

[16:36] <El_Che> sena_kun: working on a LDAP module

[16:36] <jmerelo> Altreus: so that installed modules are immutable.

[16:37] <b2gills> As long as one or more of version/auth/api are different, the module is different

[16:37] <Altreus> smart

[16:37] *** powerbit joined
[16:37] <Altreus> :)

[16:37] *** domidumont left
[16:37] *** p6bannerbot sets mode: +v powerbit

[16:40] <b2gills> It also means that you can write a module that inherits from an earlier version of the module `constant old-version = do { use Foo:version<0.1> }; class Foo is old-version {…}`

[16:41] *** sno left
[16:41] <b2gills> That should be `constant old-version = do { use Foo:version<0.1>; Foo };

[16:43] <b2gills> That would make more sense to do that if you had to create a company specific variant of a module

[16:43] <sena_kun> El_Che, I do. If you have looked up a repo on github, I didn't post the code yet. Sadly, it is in very alpha right now and cannot do anything too useful, because I spent last couple of months building essential support of ASN.1 we didn't have. (and still fighting with it somewhat). But, of course, if anyone is willing to provide any help even with that, I'd be more than happy to upload current stuff and help with what I can. Main issue 

[16:43] <sena_kun> I am having(well, besides not having too much time to spend on it) is that I didn't really used LDAP before, so a someone who knows e.g. common use cases will be awesome to have around.

[16:49] *** smallick joined
[16:49] <cpan-p6> New module released to CPAN! Algorithm-LDA (0.0.9) by 03TITSUKI

[16:49] *** p6bannerbot sets mode: +v smallick

[16:50] <smallick> p6: say 0/0;

[16:50] <yoleaux> 16:35Z <b2gills> smallick: You can choose the number of digits after the decimal with `.base` on Rationals  `(1/2047).base(10,50)`, or get all the precision with `.base-repeating`

[16:50] <camelia> rakudo-moar c0f837882: OUTPUT: «Attempt to divide by zero when coercing Rational to Str␤  in block <unit> at <tmp> line 1␤␤»

[16:51] <El_Che> sena_kun: I use ldap often (also not a lot of time atm, but my schedule will clear up in some months)

[16:51] <b2gills> m: say (0/0).Num

[16:51] <camelia> rakudo-moar c0f837882: OUTPUT: «NaN␤»

[16:51] <smallick> what is ldap

[16:52] <b2gills> Lightweight Directory Access Protocol

[16:52] <smallick> m: say 1/7.base(10,50)

[16:52] <camelia> rakudo-moar c0f837882: OUTPUT: «0.142857␤»

[16:52] <b2gills> m: (1/7).base(10,50)

[16:52] <camelia> rakudo-moar c0f837882: ( no output )

[16:53] <b2gills> m: say (1/7).base(10,50)

[16:53] <camelia> rakudo-moar c0f837882: OUTPUT: «0.14285714285714285714285714285714285714285714285714␤»

[16:53] <b2gills> m: say 7.base(10,50)

[16:53] <camelia> rakudo-moar c0f837882: OUTPUT: «7.00000000000000000000000000000000000000000000000000␤»

[16:53] <smallick> good

[16:53] <b2gills> m: say 1/(7.base(10,50))

[16:53] <camelia> rakudo-moar c0f837882: OUTPUT: «0.142857␤»

[16:53] <sena_kun> El_Che, oh, that's great to know. I hope I be able to finish my ASN.1 stuff until February and then proceed to looking at SASL and other details and will try to have some stuff working. I'll open source it pretty quickly, I think, and then can ping you.

[16:54] <smallick> m: say (1/673).base(10,100)

[16:54] <camelia> rakudo-moar c0f837882: OUTPUT: «0.0014858841010401188707280832095096582466567607726597325408618127786032689450222882615156017830609212␤»

[16:55] <sena_kun> Not like I am the smartest person when it comes to implementing LDAP but I have participated in implementing a couple of network protocols already and thought "Ok, I can try to do this one too". :)

[16:55] *** ilmari_ left
[16:55] <timotimo> ASN.1 is, for some reason, extremely prone to security-critical bugs

[16:56] <smallick> how to get the recurring portion of a frac (1/7 ===> 142857)

[16:57] <b2gills> m: say (1/7).base-repeating

[16:57] <camelia> rakudo-moar c0f837882: OUTPUT: «(0. 142857)␤»

[16:57] <b2gills> m: say (1/7 + 1/6).base-repeating

[16:57] <camelia> rakudo-moar c0f837882: OUTPUT: «(0.3 095238)␤»

[16:57] <sena_kun> timotimo, doesn't it come from having C part under high-level one with a possibility of overflows && set of other issues?

[16:57] <timotimo> not really sure

[16:57] <sena_kun> timotimo, and yes, security bugs me too, as I am not an expert in this field even super-remotely...

[16:58] <timotimo> just thought i should probably point it out :)

[16:58] <sena_kun> :]

[16:59] *** domidumont joined
[16:59] <smallick> m: say (2..100).grep({ not( $_ %% 2 or $_ %% 5 ) }).map(1/*).map(*.base-recurring).max

[16:59] <camelia> rakudo-moar c0f837882: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Unable to parse expression in argument list; couldn't find final ')' (corresponding starter was at line 1)␤at <tmp>:1␤------> 3say (2..100).grep({ not( $_ %% 27⏏5 or $_ %% 5 ) }).map(1/*).map(*…»

[17:00] *** p6bannerbot sets mode: +v domidumont

[17:00] <b2gills> .base-repeating returns two values, the part that doesn't repeat, and the part that does

[17:00] *** lizmat left
[17:00] *** kkrev left
[17:01] *** abraxxa left
[17:01] <b2gills> m: say (2..100).grep({ $_ %% none( 2 , 5 ) }).map(1/*).map(*.base-repeating).max

[17:01] <camelia> rakudo-moar c0f837882: OUTPUT: «(0. 3)␤»

[17:02] <b2gills> Note that `not` is not a subroutine, so you needed a space after it.

[17:02] <smallick> oh, max in number of digits ( 142857 > 16 )

[17:02] <b2gills> m: say (2..100).grep({ $_ %% none( 2 , 5 ) }).map(1/*).map(*.base-repeating).max(*.chars)

[17:02] <camelia> rakudo-moar c0f837882: OUTPUT: «(0. 010309278350515463917525773195876288659793814432989690721649484536082474226804123711340206185567)␤»

[17:03] <SmokeMachine> m: say (2..100).grep(* %% none(2,5)).map((1/*$.base-recurring.tail).max

[17:03] <camelia> rakudo-moar c0f837882: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Two terms in a row␤at <tmp>:1␤------> 3y (2..100).grep(* %% none(2,5)).map((1/*7⏏5$.base-recurring.tail).max␤    expecting any of:␤        infix␤        infix stopper␤        statement…»

[17:03] <b2gills> m: say (2..100).grep({ $_ %% none( 2 , 5 ) }).map(1/*).map(*.base-repeating).max(*[1].chars)

[17:03] <camelia> rakudo-moar c0f837882: OUTPUT: «(0. 010309278350515463917525773195876288659793814432989690721649484536082474226804123711340206185567)␤»

[17:03] *** robertle left
[17:04] *** patrickb joined
[17:04] <SmokeMachine> m: say (2..100).grep(* %% none(2,5)).map((1/*).base-recurring.tail).max

[17:04] <camelia> rakudo-moar c0f837882: OUTPUT: «No such method 'base-recurring' for invocant of type 'Rat'␤  in block <unit> at <tmp> line 1␤␤»

[17:05] *** p6bannerbot sets mode: +v patrickb

[17:05] <smallick> i want the number for which reciprocal has biggest recurring cycle in a range

[17:05] <b2gills> m: say (2..100).grep({ $_ %% none( 2 , 5 ) }).max((1/*).base-repeating[1].chars)

[17:05] <camelia> rakudo-moar c0f837882: OUTPUT: «97␤»

[17:05] <b2gills> m: say (1/97).base-repeating.tail

[17:05] <camelia> rakudo-moar c0f837882: OUTPUT: «010309278350515463917525773195876288659793814432989690721649484536082474226804123711340206185567␤»

[17:06] <smallick> aha!

[17:07] *** patrickz joined
[17:07] *** lizmat joined
[17:07] *** p6bannerbot sets mode: +v lizmat

[17:07] *** p6bannerbot sets mode: +v patrickz

[17:08] <smallick> m: say (2010..2030).filter(*.is-prime)

[17:08] <camelia> rakudo-moar c0f837882: OUTPUT: «No such method 'filter' for invocant of type 'Range'␤  in block <unit> at <tmp> line 1␤␤»

[17:08] <b2gills> You could have added a challenge(question) on CodeGolf.StackExchange.com asking for that, and I'm sure someone would have come up with a Perl6 version

[17:08] <timotimo> m: say (2010..2030).grep(*.is-prime)

[17:08] <camelia> rakudo-moar c0f837882: OUTPUT: «(2011 2017 2027 2029)␤»

[17:09] <smallick> m: (2010..2030).grep(*.is-prime).say # forgot!!

[17:09] <camelia> rakudo-moar c0f837882: OUTPUT: «(2011 2017 2027 2029)␤»

[17:09] <b2gills> smallick: I think that using `grep` for that precedes using `filter`

[17:09] <SmokeMachine> m: say (2..100).grep(* %% none(2,5)).map((1/*).base-repeating).max: *.tail.chars

[17:09] <camelia> rakudo-moar c0f837882: OUTPUT: «(0. 010309278350515463917525773195876288659793814432989690721649484536082474226804123711340206185567)␤»

[17:10] <b2gills> What I mean is the text editor that grep was formed from is older than any language that uses the word `filter` for that.

[17:10] *** patrickb left
[17:11] <b2gills> At least I think so.

[17:11] <smallick> i don't know if there is a question on code-golf on that

[17:12] <b2gills> As you start writing it, there should be some questions that it thinks are related

[17:12] *** Sgeo joined
[17:12] <b2gills> Make sure that it is a good one before posting. Perhaps look at others to make sure you are following the rules.

[17:13] *** p6bannerbot sets mode: +v Sgeo

[17:13] <smallick> what is fastest way to sum all primes upto a number

[17:15] *** Sgeo_ left
[17:15] *** pmurias left
[17:15] <smallick> huh?

[17:15] <b2gills> m: say (1..100).grep(*.is-prime).sum

[17:15] <camelia> rakudo-moar 08d87f706: OUTPUT: «1060␤»

[17:16] *** pmurias joined
[17:16] *** p6bannerbot sets mode: +v pmurias

[17:16] <smallick> m: say (1..1000).grep(*.is-prime).sum ; say now - INIT;

[17:16] <camelia> rakudo-moar 08d87f706: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Whitespace required after keyword 'INIT'␤at <tmp>:1␤------> 030).grep(*.is-prime).sum ; say now - INIT7⏏5;␤»

[17:16] <b2gills> m: say (1..1000).grep(*.is-prime).sum ; say now - INIT now;

[17:16] <camelia> rakudo-moar 08d87f706: OUTPUT: «76127␤0.0089776␤»

[17:16] <b2gills> INIT is a phaser

[17:17] <smallick> m: say (1..1e5).grep(*.is-prime).sum; say now - INIT

[17:17] <camelia> rakudo-moar 08d87f706: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Whitespace required after keyword 'INIT'␤at <tmp>:1␤------> 3e5).grep(*.is-prime).sum; say now - INIT7⏏5<EOL>␤»

[17:17] <b2gills> m: LEAVE say 'leave'; END say 'end'; ENTER say 'enter'; INIT say 'init'; BEGIN say 'begin'

[17:17] <camelia> rakudo-moar 08d87f706: OUTPUT: «begin␤init␤enter␤leave␤end␤»

[17:18] *** pmurias left
[17:18] <smallick> thanks, i understood

[17:18] <b2gills> INIT is a statement prefix. Meaning it has to have something after it

[17:19] <smallick> m: say (1..1e6).grep(*.is-prime).sum; say now - INIT now ;

[17:20] <b2gills> I mean phasers are a type of statement prefix. There are also other statement prefixes like `start` and `react`.

[17:20] <camelia> rakudo-moar 08d87f706: OUTPUT: «(timeout)»

[17:20] <b2gills> m: say (1..Int(1e6)).grep(*.is-prime).sum; say now - INIT now ;

[17:20] *** pmurias joined
[17:20] *** p6bannerbot sets mode: +v pmurias

[17:20] <camelia> rakudo-moar 08d87f706: OUTPUT: «(timeout)»

[17:21] <b2gills> m: say (1..Int(1e6)).race.grep(*.is-prime).sum; say now - INIT now ;

[17:21] <camelia> rakudo-moar 08d87f706: OUTPUT: «(signal XCPU)»

[17:21] <b2gills> There is really no built-in fast way to get a sequence of primes

[17:22] <smallick> m: say (2, 3, *+2 ... * > 1e5).grep(*.is-prime).sum; sum now - INIT now ;

[17:22] <camelia> rakudo-moar 08d87f706: OUTPUT: «(timeout)»

[17:22] <b2gills> That would be faster if you used an Int rather than the float 1e5

[17:23] <smallick> is there a generator for prime

[17:24] *** dct joined
[17:24] *** p6bannerbot sets mode: +v dct

[17:24] <smallick> no one-liners for it, then

[17:25] *** zakharyas joined
[17:26] <b2gills> m: my $prime-seq = lazy gather { my $iterator = (2..*).iterator; loop { take my $p = $iterator.pull-one; $iterator = Seq.new($iterator).grep(* % $p).iterator }}; say $prime-seq.head(100)

[17:26] *** p6bannerbot sets mode: +v zakharyas

[17:26] <camelia> rakudo-moar 08d87f706: OUTPUT: «(2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 101 103 107 109 113 127 131 137 139 149 151 157 163 167 173 179 181 191 193 197 199 211 223 227 229 233 239 241 251 257 263 269 271 277 281 283 293 307 311 313 317 331 337 347 349…»

[17:27] <smallick> m:  (([*] 1..11) + 1).is-prime.say

[17:27] <camelia> rakudo-moar 08d87f706: OUTPUT: «True␤»

[17:27] <smallick> more smaller way to do that generating

[17:30] <smallick> how that works you wrote

[17:30] <b2gills> It would be slower

[17:32] <smallick> i used heapque and generator in python and it worked for 2e6 in < 1s

[17:32] <tyil> moritz: alright, I'll update that part too :)

[17:33] <tyil> I thought you didn't need a default { } if you didn't try to smartmatch it

[17:36] <smallick> how 'start' and 'react' work, examples plz

[17:36] <b2gills> m: my $promise = start { sleep 1; say 'done sleeping' }; say 'doing something else'; await $promise

[17:36] <camelia> rakudo-moar 08d87f706: OUTPUT: «doing something else␤done sleeping␤»

[17:37] <b2gills> `react` doesn't make sense without `whenever`

[17:38] <b2gills> m: react whenever Promise.in(1) { say 'done sleeping' }

[17:38] <camelia> rakudo-moar 08d87f706: OUTPUT: «done sleeping␤»

[17:38] <smallick> what does react do anyway

[17:38] <b2gills> m: react { whenever Promise.in(1) { say 'done sleeping' }; whenever Supply.interval(0.5) { .say }}

[17:38] <b2gills> m: react { whenever Promise.in(1) { say 'done sleeping'; done }; whenever Supply.interval(0.5) { .say }}

[17:38] <camelia> rakudo-moar 08d87f706: OUTPUT: «(timeout)0␤»

[17:38] <camelia> rakudo-moar 08d87f706: OUTPUT: «0␤1␤done sleeping␤»

[17:39] <b2gills> m: react { whenever Promise.in(1) { say 'done sleeping'; done }; whenever Supply.interval(0.1) { .say }}

[17:39] <camelia> rakudo-moar 08d87f706: OUTPUT: «0␤1␤2␤3␤4␤5␤6␤7␤8␤9␤10␤done sleeping␤»

[17:40] <smallick> looks like js setTimeout and setInterval

[17:40] <b2gills> `react` with `whenever` acts as a sort of arbiter of asynchronous operations.

[17:40] <smallick> hmm

[17:40] *** dakkar left
[17:41] <b2gills> The `Promise.in` and `Supply.interval` were just short ways to get something to work on.

[17:41] <smallick> what are the other models of async operations

[17:42] *** scimon left
[17:43] <b2gills> https://docs.perl6.org/language/concurrency

[17:43] <moritz> you can also work with Promise.then directly, for example

[17:43] <b2gills> Note that Promise.then produces another Promise

[17:44] <b2gills> m: Promise.in(.1).then({ sleep .1 }).then({ sleep .1 }).then({ sleep .1 }).then({ say 'done' })

[17:44] <camelia> rakudo-moar 08d87f706: ( no output )

[17:44] <b2gills> m: await Promise.in(.1).then({ sleep .1 }).then({ sleep .1 }).then({ sleep .1 }).then({ say 'done' })

[17:44] <camelia> rakudo-moar 08d87f706: OUTPUT: «done␤»

[17:46] <smallick> thanks

[17:47] <smallick> m: -> $p { print $p }(1)

[17:47] <camelia> rakudo-moar 08d87f706: OUTPUT: «1»

[17:48] <smallick> other ways to create lambdas?

[17:49] *** melezhik joined
[17:49] *** p6bannerbot sets mode: +v melezhik

[17:50] <b2gills> *.print        { print $^p }        sub ($p) {print $p}        anon sub print ($p) {print $p}

[17:50] <b2gills> { print $_ }        { print @_ }        { print $:p }

[17:51] <smallick> bye

[17:51] *** smallick left
[17:59] *** zacts joined
[17:59] *** p6bannerbot sets mode: +v zacts

[18:03] <Xliff> \o

[18:04] *** mowcat joined
[18:04] *** p6bannerbot sets mode: +v mowcat

[18:05] <jmerelo> hi!

[18:07] *** robertle joined
[18:08] *** p6bannerbot sets mode: +v robertle

[18:12] *** zakharyas left
[18:16] *** dct left
[18:19] *** abraxxa joined
[18:20] *** p6bannerbot sets mode: +v abraxxa

[18:25] <Geth> ¦ doc: 21c8088404 | (Elizabeth Mattijsen)++ | doc/Type/Bag.pod6

[18:25] <Geth> ¦ doc: Elaborate a bit about Bag.new and my %b is Bag

[18:25] <Geth> ¦ doc: 

[18:25] <Geth> ¦ doc: Noting the new parameterization feature as available since 2019.01

[18:25] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/21c8088404

[18:25] <Geth> ¦ doc: 7b654f4b83 | (Elizabeth Mattijsen)++ | doc/Type/BagHash.pod6

[18:25] <Geth> ¦ doc: Elaborate a bit about my %b is BagHash

[18:25] <Geth> ¦ doc: 

[18:25] <Geth> ¦ doc: Also noting the new parameterization feature as available since 2019.01

[18:25] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/7b654f4b83

[18:27] *** sauvin left
[18:27] *** atweiden-air joined
[18:28] *** p6bannerbot sets mode: +v atweiden-air

[18:29] *** abraxxa left
[18:29] *** abraxxa joined
[18:30] *** p6bannerbot sets mode: +v abraxxa

[18:32] <SmokeMachine> m: say do if True { $_ }

[18:32] <camelia> rakudo-moar 08d87f706: OUTPUT: «(Any)␤»

[18:33] <lizmat> I suspect the Any is the result of a Nil being caught by an untyped container

[18:33] <lizmat> dinner&

[18:34] <moritz> m: say $_

[18:34] <camelia> rakudo-moar 08d87f706: OUTPUT: «(Any)␤»

[18:34] <moritz> my: if 'bla' { .say }

[18:34] <moritz> m: if 'bla' { .say }

[18:34] <camelia> rakudo-moar 08d87f706: OUTPUT: «(Any)␤»

[18:34] <moritz> it's just that if { } doesn't set $_ by default

[18:43] *** abraxxa left
[18:44] *** abraxxa joined
[18:45] *** p6bannerbot sets mode: +v abraxxa

[18:47] *** abraxxa left
[18:48] *** abraxxa joined
[18:49] *** p6bannerbot sets mode: +v abraxxa

[18:51] *** sno joined
[18:52] *** p6bannerbot sets mode: +v sno

[18:53] <b2gills> m: say do if True { $_ } given 42

[18:53] <camelia> rakudo-moar 08d87f706: OUTPUT: «42␤»

[18:55] <SmokeMachine> The Any answer was what I where expecting...

[18:57] *** pecastro joined
[18:58] <SmokeMachine> https://colabti.org/irclogger/irclogger_log/perl6?date=2019-01-14#l131

[18:58] <sena_kun> m: say do if True { $_ } given 42;

[18:58] <camelia> rakudo-moar 08d87f706: OUTPUT: «42␤»

[18:58] *** pmurias left
[18:58] *** p6bannerbot sets mode: +v pecastro

[18:58] <sena_kun> head: say do if True { $_ } given 42;

[18:58] <sena_kun> ugh

[18:58] *** pmurias joined
[18:58] *** p6bannerbot sets mode: +v pmurias

[18:59] <sena_kun> camelia, help

[18:59] <camelia> sena_kun: Usage: <(prof-m|rakudo-jvm|nqp-js|nqp-moarvm|nqp-jvm|debug-cat|p5-to-p6|star-m|rakudo-moar|rm|star|nqp-q|master|p56|r|j|rakudo|sm|rj|p6|nqp-mvm|nqp|r-j|nqp-m|perl6|r-m|m|r-jvm)(?^::\s(?!OUTPUT)) $perl6_program>

[18:59] <sena_kun> master: say do if True { $_ } given 42;

[18:59] <camelia> rakudo-moar 08d87f706: OUTPUT: «42␤»

[18:59] <sena_kun> ok, probably receiving `(LoweredAwayLexical)` was fixed since 2018.12-211-ge87b7afb0. :)

[19:00] <b2gills> https://github.com/rakudo/rakudo/commit/c0f8378827

[19:01] *** pmurias left
[19:01] <sena_kun> heh

[19:01] <sena_kun> jnthn++

[19:01] *** pmurias joined
[19:01] *** p6bannerbot sets mode: +v pmurias

[19:02] *** abraxxa left
[19:02] *** abraxxa joined
[19:03] *** p6bannerbot sets mode: +v abraxxa

[19:03] *** abraxxa left
[19:03] *** abraxxa joined
[19:04] *** p6bannerbot sets mode: +v abraxxa

[19:11] *** dct joined
[19:11] *** p6bannerbot sets mode: +v dct

[19:11] *** pmurias left
[19:12] *** abraxxa left
[19:12] *** pmurias joined
[19:12] *** p6bannerbot sets mode: +v pmurias

[19:13] *** abraxxa joined
[19:13] *** abraxxa left
[19:13] *** abraxxa joined
[19:14] *** p6bannerbot sets mode: +v abraxxa

[19:15] *** abraxxa left
[19:16] *** abraxxa joined
[19:16] *** p6bannerbot sets mode: +v abraxxa

[19:31] *** reach_satori left
[19:31] *** reach_satori joined
[19:32] *** p6bannerbot sets mode: +v reach_satori

[19:40] *** abraxxa left
[19:48] *** zacts left
[19:54] <Xliff> Is Iterator.pull-one or gather/take the closest equivalent to Python's yield statement?

[19:55] *** abraxxa joined
[19:56] *** p6bannerbot sets mode: +v abraxxa

[19:56] <sena_kun> I think so. At least I didn't see anything closer.

[19:56] <Xliff> sena_kun: So which one is it? :) Or are both valid alternatives?

[19:56] <sena_kun> ah

[19:57] <sena_kun> well, not sure about this one. I'd say gather/take is.

[19:58] <sena_kun> lazy one, at least, as python "freezes" its generators iirc.

[20:03] <sena_kun> m: my $vals = (lazy gather { loop { take $++ } }).iterator; say $vals.pull-one for ^3;

[20:03] <camelia> rakudo-moar 08d87f706: OUTPUT: «0␤1␤2␤»

[20:03] <sena_kun> m: my $vals = (lazy gather { loop { take $++ } }).iterator; say $vals.pull-one for ^10;

[20:03] <camelia> rakudo-moar 08d87f706: OUTPUT: «0␤1␤2␤3␤4␤5␤6␤7␤8␤9␤»

[20:05] *** lucasb left
[20:06] *** jmerelo left
[20:08] * sena_kun have tried to write equivalent Python code, but it was just a pathetic try

[20:16] <cpan-p6> New module released to CPAN! Tomtit (0.0.28) by 03MELEZHIK

[20:16] *** kst joined
[20:17] *** p6bannerbot sets mode: +v kst

[20:18] *** domidumont left
[20:20] *** lizmat left
[20:21] * [Coke] wakes up from sleeping off the con crud from last week. Oy.

[20:24] *** marmor joined
[20:25] *** p6bannerbot sets mode: +v marmor

[20:25] *** lizmat joined
[20:25] *** p6bannerbot sets mode: +v lizmat

[20:36] *** zachk joined
[20:36] *** atweiden-air left
[20:36] *** zachk left
[20:37] *** zachk joined
[20:37] *** zachk left
[20:37] *** zachk joined
[20:37] *** p6bannerbot sets mode: +v zachk

[20:38] *** p6bannerbot sets mode: +v zachk

[20:38] *** molaf joined
[20:39] *** p6bannerbot sets mode: +v molaf

[20:51] *** w17t left
[20:56] *** lizmat left
[20:58] *** abraxxa left
[21:03] *** lizmat joined
[21:03] *** p6bannerbot sets mode: +v lizmat

[21:24] *** abraxxa joined
[21:24] *** p6bannerbot sets mode: +v abraxxa

[21:25] *** kensanata joined
[21:25] *** p6bannerbot sets mode: +v kensanata

[21:34] *** melezhik left
[21:35] *** pmurias left
[21:35] *** pmurias joined
[21:35] *** p6bannerbot sets mode: +v pmurias

[21:36] *** Sgeo_ joined
[21:36] *** p6bannerbot sets mode: +v Sgeo_

[21:36] *** marmor left
[21:38] *** kensanata left
[21:39] *** Sgeo left
[21:40] *** webstrand joined
[21:41] *** p6bannerbot sets mode: +v webstrand

[21:41] *** rindolf left
[21:41] *** entonian joined
[21:42] *** rindolf joined
[21:42] *** p6bannerbot sets mode: +v entonian

[21:42] *** p6bannerbot sets mode: +v rindolf

[21:47] *** entonian left
[21:49] *** molaf left
[21:58] *** Manifest0 left
[21:59] *** Manifest0 joined
[21:59] *** p6bannerbot sets mode: +v Manifest0

[22:02] <Xliff> Is there a way to get the filename a nativecall sub is bound to?

[22:02] <Xliff> Er...

[22:02] <Xliff> Is there a way to get the library filename a nativecall sub is bound to?

[22:02] *** kensanata joined
[22:02] *** p6bannerbot sets mode: +v kensanata

[22:05] *** ufobat_ left
[22:05] *** patrickz left
[22:09] *** pmurias left
[22:10] *** pmurias joined
[22:10] *** p6bannerbot sets mode: +v pmurias

[22:11] <Xliff> Does perl6 supress output from C functions?

[22:11] <Xliff> If called by NativeCall?

[22:12] *** kensanata left
[22:13] *** abraxxa left
[22:14] <jnthn> Xliff: No; I'm not sure how it could if it wanted to... That said, such output won't know anything about the output buffering Perl 6 IO handles might do

[22:15] <jnthn> Hm, I guess in theory it could do something with the standard handles, actually...but that isn't happening.

[22:18] <Xliff> jnthn: Thanks. I'm just wondering why I am not seeing output from my custom copy of libpango.

[22:18] <Xliff> And I wanted to be sure that I am using the right copy of the library.

[22:19] <Xliff> No worries. I will play around, and if I find anything concrete, I'll let you know.

[22:27] *** pmurias left
[22:28] *** pmurias joined
[22:28] *** p6bannerbot sets mode: +v pmurias

[22:51] *** cfa left
[22:52] *** dct left
[23:11] *** pecastro left
[23:25] *** pmurias left
[23:26] *** pmurias joined
[23:26] *** p6bannerbot sets mode: +v pmurias

[23:29] <yoleaux> AlexDaniel: Check if Facepalm + ZWJ + Male sign finally renders a male version

[23:30] *** pmurias left
[23:31] *** pmurias joined
[23:31] *** p6bannerbot sets mode: +v pmurias

[23:48] *** jme` joined
[23:49] *** p6bannerbot sets mode: +v jme`

[23:49] *** pmurias left
[23:54] *** nst^ joined
[23:55] *** p6bannerbot sets mode: +v nst^

[23:55] *** rindolf left
