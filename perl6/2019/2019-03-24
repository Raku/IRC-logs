[00:00] <jnthn> Kaiepi: You can't; a hash is unordered. You perhaps want https://modules.perl6.org/dist/ArrayHash:cpan:HANENKAMP

[00:01] <Kaiepi> i can't use that for what i'm doing

[00:03] *** zachk left
[00:05] <TreyHarris> Kaiepi: Why not? What are you doing?

[00:11] *** cpan-p6 left
[00:11] *** cpan-p6 joined
[00:14] *** RaycatWhoDat left
[00:18] <Kaiepi> i'm writing a module for creating custom enums that can take a hash as an argument TreyHarris 

[00:18] <Kaiepi> i want to ensure the order of the pairs stays the same so it can match the behaviour of native enums

[00:19] <timotimo> maybe you can change the api to take a list of pairs instead? or is that exactly what you don't want?

[00:25] *** leont joined
[00:25] *** cpan-p6 left
[00:25] *** cpan-p6 joined
[00:28] <Kaiepi> i'd rather avoid it if possible

[00:30] *** Kaiepi left
[00:30] *** Kaiepi joined
[00:32] <Kaiepi> would it be possible to somehow coerce a hash to a list of pairs in the method's signature timotimo?

[00:34] <timotimo> can't think of a way off-hand

[00:34] <timotimo> i think unpacking syntax only likes attributes

[00:35] <timotimo> m: my %foo = :1a, :2b; sub test-it($has (:$pairs)) { say $pairs.perl }; test-it %foo

[00:35] <camelia> rakudo-moar c26ca6b08: OUTPUT: «2 unexpected named arguments passed (a,b) in sub-signature of parameter $has␤  in sub test-it at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[00:35] <timotimo> ah, it implements its own .Capture, which makes a whole lot of sense

[00:37] <Kaiepi> m: my %foo = :1a, :2b, :3c; sub foo(%foo is copy) { .say for %foo }; foo %foo

[00:37] <camelia> rakudo-moar c26ca6b08: OUTPUT: «b => 2␤c => 3␤a => 1␤»

[00:37] <Kaiepi> m: my %foo = :1a, :2b, :3c; sub foo(%foo is copy) { .say for %foo.sort }; foo %foo

[00:37] <camelia> rakudo-moar c26ca6b08: OUTPUT: «a => 1␤b => 2␤c => 3␤»

[00:38] <Kaiepi> ok maybe i could allow passing a sort callback to it

[00:39] *** cpan-p6 left
[00:39] *** cpan-p6 joined
[00:46] <ugexe> seems like you could wire something up fairly simple using Associative role, AT|BIND|etc-KEY, and an array to remember the order new keys are added

[00:46] <timotimo> does the default whence on the containers returned from a hash go through the "official" methods?

[00:50] *** aborazmeh left
[00:53] *** isomorphismes left
[00:55] *** isomorphismes joined
[01:01] *** cpan-p6 left
[01:02] *** cpan-p6 joined
[01:12] <Kaiepi> wdym ugexe?

[01:14] <timotimo> Hash::Agnostic or something like that is a module in the ecosystem that'll make it easier to build your own custom hashes

[01:16] *** rindolf left
[01:16] *** cpan-p6 left
[01:16] *** cpan-p6 joined
[01:21] <Kaiepi> wait a second

[01:21] <Kaiepi> m: my %foo = :1a, :2b, :3c; enum Foo (|%foo); say a.succ

[01:21] <camelia> rakudo-moar c26ca6b08: OUTPUT: «5===SORRY!5===␤Undeclared routine:␤    a used at line 1␤␤Other potential difficulties:␤    No values supplied to enum (does |%foo need to be declared constant?)␤    at <tmp>:1␤    ------> 3y %foo = :1a, :2b, :3c; enum Foo (|%foo)7…»

[01:23] <Kaiepi> m: enum Foo (|%(:1a, :2b, :3c)); say a.succ

[01:23] <camelia> rakudo-moar c26ca6b08: OUTPUT: «c␤»

[01:23] <Kaiepi> m: enum Foo (|%(:1a, :2b, :3c)); say a.succ

[01:23] <camelia> rakudo-moar c26ca6b08: OUTPUT: «a␤»

[01:23] <Kaiepi> m: enum Foo (|%(:1a, :2b, :3c)); say a.succ

[01:23] <camelia> rakudo-moar c26ca6b08: OUTPUT: «a␤»

[01:23] <Kaiepi> ok so i don't have to care about the hash values' order

[01:34] *** lucasb left
[01:36] <Kaiepi> what are the nqp serialization context ops for, and do i need to use them for my custom enum package the same way declaring enums normally does?

[01:38] *** cpan-p6 left
[01:39] *** cpan-p6 joined
[02:02] *** dmaestro joined
[02:02] *** cpan-p6 left
[02:02] *** cpan-p6 joined
[02:03] <dmaestro> m: say "foobaz" ~~ / foo <!before bar> /;

[02:03] <camelia> rakudo-moar c26ca6b08: OUTPUT: «｢foo｣␤»

[02:04] <dmaestro> m: 'C' ~~ / \w <!before a..z> /

[02:04] <camelia> rakudo-moar c26ca6b08: ( no output )

[02:04] <dmaestro> m: say 'C' ~~ / \w <!before a..z> /

[02:04] <camelia> rakudo-moar c26ca6b08: OUTPUT: «｢C｣␤»

[02:04] <dmaestro> m: say 'C' ~~ / \w <!before \w> /

[02:04] <camelia> rakudo-moar c26ca6b08: OUTPUT: «Nil␤»

[02:05] <dmaestro> m: say 'C' ~~ / \w <!before <[a..z]> > /

[02:05] <camelia> rakudo-moar c26ca6b08: OUTPUT: «Nil␤»

[02:05] <dmaestro> Thought you could use any pattern in a 'before' zero-width assertion? What am I missing?

[02:06] <dmaestro> m: say 'C0' ~~ / \w <!before <[a..z]> > /

[02:06] <camelia> rakudo-moar c26ca6b08: OUTPUT: «｢C｣␤»

[02:06] <dmaestro> m: say 'Cc' ~~ / \w <!before <[a..z]> > /

[02:06] <camelia> rakudo-moar c26ca6b08: OUTPUT: «Nil␤»

[02:06] <dmaestro> m: say 'Cc' ~~ / \w <before <[a..z]> > /

[02:06] <camelia> rakudo-moar c26ca6b08: OUTPUT: «｢C｣␤ before => ｢｣␤»

[02:07] <dmaestro> m: say 'Cc' ~~ / \w <[a..z]> /

[02:07] <camelia> rakudo-moar c26ca6b08: OUTPUT: «｢Cc｣␤»

[02:08] <dmaestro> m: say 'Cc' ~~ / \w <?before <[a..z]> > /

[02:08] <camelia> rakudo-moar c26ca6b08: OUTPUT: «｢C｣␤»

[02:08] <dmaestro> m: say 'Cc' ~~ / \w <!before <[a..z]> > /

[02:08] <camelia> rakudo-moar c26ca6b08: OUTPUT: «Nil␤»

[02:08] <dmaestro> m: say 'C0' ~~ / \w <!before <[a..z]> > /

[02:08] <camelia> rakudo-moar c26ca6b08: OUTPUT: «｢C｣␤»

[02:09] <dmaestro> m: say 'C' ~~ / \w <!before <[a..z]> > /

[02:09] <camelia> rakudo-moar c26ca6b08: OUTPUT: «Nil␤»

[02:10] <dmaestro> Why would that last one be a non-match ??

[02:10] *** netrino left
[02:21] *** leont left
[02:25] *** cpan-p6 left
[02:26] *** cpan-p6 joined
[02:32] <vrurg> dmaestro: because you need explicitly define $ in before.

[02:33] <vrurg> m: say 'C' ~~ / \w <!before [<[a..z]> | $] > /

[02:33] <camelia> rakudo-moar c26ca6b08: OUTPUT: «Nil␤»

[02:35] <vrurg> oops, its !before. 

[02:50] *** cpan-p6 left
[02:50] *** cpan-p6 joined
[02:55] *** kurahaupo joined
[03:04] *** cibs left
[03:06] *** cibs joined
[03:11] *** cpan-p6 left
[03:12] *** cpan-p6 joined
[03:21] *** ufobat_ joined
[03:24] <kybr> is there a channel for Comma IDE?

[03:25] *** ufobat__ left
[03:26] *** RaycatWhoDat joined
[03:27] <RaycatWhoDat> Hello again.

[03:27] <RaycatWhoDat> Is there an easy way to generate a sequence of the same character?

[03:28] <RaycatWhoDat> Of course, I can make a variable and concatenate but I was wondering if there was a more Perl-like way to do it.

[03:32] <ryanth> m: say 'A' x 50;

[03:32] <camelia> rakudo-moar c26ca6b08: OUTPUT: «AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA␤»

[03:32] <RaycatWhoDat> Oh. It's just that easy.

[03:32] <ryanth> :-)

[03:32] <RaycatWhoDat> Thanks, friendo.

[03:33] *** cpan-p6 left
[03:33] *** cpan-p6 joined
[03:34] *** MilkmanDan left
[03:36] *** MilkmanDan joined
[03:36] <ryanth> And then if you want an array, you can use 'xx', like @a = 'A' xx 10; # @a = [A A A A A A A A A A]

[03:37] <RaycatWhoDat> That's sick.

[03:38] *** Black_Ribbon left
[03:38] *** Black_Ribbon joined
[03:50] <RaycatWhoDat> My God...

[03:50] <RaycatWhoDat> I started looking at my code the Perl way and so many lines were optimized

[03:51] <ryanth> Yup, you can write C code in almost any language. :-)

[03:51] <RaycatWhoDat> I went from 28 sloc to like, 10.

[03:51] <RaycatWhoDat> That's insane. And the code is still readable.

[03:52] <RaycatWhoDat> ryanth: I'm realizing that now.

[03:55] *** cpan-p6 left
[03:56] *** cpan-p6 joined
[04:12] *** cpan-p6 left
[04:14] *** kurahaupo left
[04:14] *** kurahaupo joined
[04:17] *** zacts joined
[04:18] *** zacts left
[04:45] *** RaycatWhoDat left
[04:49] *** dominix joined
[05:49] *** notable6 left
[05:49] *** unicodable6 left
[05:49] *** statisfiable6 left
[05:49] *** evalable6 left
[05:49] *** bisectable6 left
[05:49] *** benchable6 left
[05:49] *** greppable6 left
[05:49] *** committable6 left
[05:49] *** undersightable6 left
[05:49] *** releasable6 left
[05:49] *** nativecallable6 left
[05:49] *** bloatable6 left
[05:49] *** squashable6 left
[05:49] *** reportable6 left
[05:49] *** quotable6 left
[05:49] *** coverable6 left
[05:49] *** shareable6 left
[05:49] *** committable6 joined
[05:49] *** ChanServ sets mode: +v committable6

[05:49] *** releasable6 joined
[05:49] *** ChanServ sets mode: +v releasable6

[05:49] *** bisectable6 joined
[05:50] *** greppable6 joined
[05:50] *** ChanServ sets mode: +v greppable6

[05:50] *** benchable6 joined
[05:50] *** unicodable6 joined
[05:50] *** ChanServ sets mode: +v unicodable6

[05:50] *** squashable6 joined
[05:50] *** ChanServ sets mode: +v squashable6

[05:50] *** notable6 joined
[05:50] *** evalable6 joined
[05:50] *** coverable6 joined
[05:51] *** shareable6 joined
[05:52] *** undersightable6 joined
[05:52] *** ChanServ sets mode: +v undersightable6

[05:52] *** quotable6 joined
[05:52] *** bloatable6 joined
[05:52] *** ChanServ sets mode: +v bloatable6

[05:53] *** statisfiable6 joined
[05:53] *** ChanServ sets mode: +v statisfiable6

[05:53] *** nativecallable6 joined
[05:54] *** reportable6 joined
[05:54] *** ChanServ sets mode: +v reportable6

[06:00] *** dominix left
[06:21] *** molaf joined
[07:10] *** mowotter left
[07:36] *** jmerelo joined
[07:38] *** epony left
[07:42] *** grondilu joined
[07:42] <grondilu> m: say [pi] ~~ Array[Real];

[07:42] <camelia> rakudo-moar c26ca6b08: OUTPUT: «False␤»

[07:42] * grondilu was expecting True here

[07:49] <grondilu> m: subset Vector of Array where *.all ~~ Real; say [pi] ~~ Vector;

[07:49] <camelia> rakudo-moar c26ca6b08: OUTPUT: «False␤»

[07:51] <grondilu> m: subset Vector of Array where [&&] * >>~~>> Real; say [pi] ~~ Vector;

[07:51] <camelia> rakudo-moar c26ca6b08: OUTPUT: «True␤»

[07:51] <grondilu> m: subset Vector of Array where [&&] * >>~~>> Real; say [pi, 7] ~~ Vector;

[07:51] <camelia> rakudo-moar c26ca6b08: OUTPUT: «True␤»

[07:51] <grondilu> m: subset Vector of Array where [&&] * >>~~>> Real; say [pi, 7, "foo"] ~~ Vector;

[07:51] <camelia> rakudo-moar c26ca6b08: OUTPUT: «True␤»

[07:54] <grondilu> m: subset Vector of Array where -> $x { [&&] $x >>~~>> Real }; say [pi, 7] ~~ Vector;

[07:54] <camelia> rakudo-moar c26ca6b08: OUTPUT: «True␤»

[07:54] <grondilu> m: subset Vector of Array where -> $x { [&&] $x >>~~>> Real }; say [pi, 7, "foo"] ~~ Vector;

[07:54] <camelia> rakudo-moar c26ca6b08: OUTPUT: «True␤»

[07:55] <grondilu> m: subset Vector of Array where -> $x { [&&] @$x >>~~>> Real }; say [pi, 7, "foo"] ~~ Vector;

[07:55] <camelia> rakudo-moar c26ca6b08: OUTPUT: «False␤»

[07:55] <grondilu> m: subset Vector of Array where -> $x { [&&] @$x >>~~>> Real }; say [pi, 7] ~~ Vector;

[07:55] <camelia> rakudo-moar c26ca6b08: OUTPUT: «True␤»

[08:03] *** epony joined
[08:12] *** holyghost left
[08:13] *** holyghost joined
[08:36] *** rindolf joined
[08:37] *** rindolf left
[08:38] *** molaf left
[08:40] *** sena_kun joined
[08:46] <dmaestro> vrurg: thanks for looking at that - so it's surprising to you, too?

[08:46] *** rindolf joined
[08:48] <dmaestro> m: say 'C' ~~ / \w [ <!before <[a..z]> > | $ ] /

[08:48] <camelia> rakudo-moar c26ca6b08: OUTPUT: «｢C｣␤»

[08:48] <dmaestro> m: say 'Cc' ~~ / \w [ <!before <[a..z]> > | $ ] /

[08:48] <camelia> rakudo-moar c26ca6b08: OUTPUT: «｢c｣␤»

[08:50] <dmaestro> m: say 'Cc' ~~ / \w  <!before \w >  /

[08:50] <camelia> rakudo-moar c26ca6b08: OUTPUT: «Nil␤»

[08:51] <dmaestro> m: say 'Cc' ~~ / :r \w  <!before \w >  /

[08:51] <camelia> rakudo-moar c26ca6b08: OUTPUT: «Nil␤»

[08:51] <dmaestro> m: say 'C ' ~~ /  \w  <!before \w >  /

[08:51] <camelia> rakudo-moar c26ca6b08: OUTPUT: «｢C｣␤»

[08:52] *** kurahaupo left
[08:53] *** kurahaupo joined
[08:53] <dmaestro> m: say 'C' ~~ / :r \w  <!before c >  /

[08:53] <camelia> rakudo-moar c26ca6b08: OUTPUT: «｢C｣␤»

[08:54] <dmaestro> m: say 'C' ~~ / :r \w  <!before <[ c ]> >  /

[08:54] <camelia> rakudo-moar c26ca6b08: OUTPUT: «｢C｣␤»

[08:54] <dmaestro> m: say 'C' ~~ / :r \w  <!before <[ cd ]> >  /

[08:54] <camelia> rakudo-moar c26ca6b08: OUTPUT: «｢C｣␤»

[08:54] <dmaestro> m: say 'C' ~~ / :r \w  <!before <[ \w ]> >  /

[08:54] <camelia> rakudo-moar c26ca6b08: OUTPUT: «Nil␤»

[08:55] <dmaestro> m: say 'C' ~~ / \w  <!before <[ cd ]> >  /

[08:55] <camelia> rakudo-moar c26ca6b08: OUTPUT: «｢C｣␤»

[08:55] *** grondilu left
[08:55] <dmaestro> m: say 'C' ~~ / \w  <!before <[ \w ]> >  /

[08:55] <camelia> rakudo-moar c26ca6b08: OUTPUT: «Nil␤»

[08:56] <dmaestro> m: say 'C' ~~ / \w  <!before \w >  /

[08:56] <camelia> rakudo-moar c26ca6b08: OUTPUT: «Nil␤»

[08:57] <dmaestro> m: say 'C' ~~ / :r \w [ <!before \w > | $ ]  /

[08:57] <camelia> rakudo-moar c26ca6b08: OUTPUT: «｢C｣␤»

[08:58] <dmaestro> m: say 'C ' ~~ / :r \w [ <!before \w > | $ ]  /

[08:58] <camelia> rakudo-moar c26ca6b08: OUTPUT: «｢C｣␤»

[08:58] <dmaestro> m: say 'Cc' ~~ / :r \w [ <!before \w > | $ ]  /

[08:58] <camelia> rakudo-moar c26ca6b08: OUTPUT: «｢c｣␤»

[08:59] <dmaestro> m: say 'Cc' ~~ / :r <Lu> [ <!before \w > | $ ]  /

[08:59] <camelia> rakudo-moar c26ca6b08: OUTPUT: «No such method 'Lu' for invocant of type 'Match'␤  in block <unit> at <tmp> line 1␤␤»

[08:59] <dmaestro> m: say 'Cc' ~~ / :r <:Lu> [ <!before \w > | $ ]  /

[08:59] <camelia> rakudo-moar c26ca6b08: OUTPUT: «Nil␤»

[08:59] <dmaestro> m: say 'C0' ~~ / :r <:Lu> [ <!before \w > | $ ]  /

[08:59] <camelia> rakudo-moar c26ca6b08: OUTPUT: «Nil␤»

[09:00] <dmaestro> m: 'C' ~~ / <:Lu> /

[09:00] <camelia> rakudo-moar c26ca6b08: ( no output )

[09:00] <dmaestro> m: say 'C' ~~ / <:Lu> /

[09:00] <camelia> rakudo-moar c26ca6b08: OUTPUT: «｢C｣␤»

[09:00] <dmaestro> m: say 'c' ~~ / <:Lu> /

[09:00] <camelia> rakudo-moar c26ca6b08: OUTPUT: «Nil␤»

[09:02] <dmaestro> m: say 'C0' ~~ / :r <:Lu> [ <!before <:Lu> > | $ ]  /

[09:02] <camelia> rakudo-moar c26ca6b08: OUTPUT: «｢C｣␤»

[09:02] <dmaestro> m: say 'C0' ~~ / <:Lu> <!before <:Lu> >  /

[09:02] <camelia> rakudo-moar c26ca6b08: OUTPUT: «｢C｣␤»

[09:03] <dmaestro> m: say 'C0' ~~ / <:Lu> <!before <:L> >  /

[09:03] <camelia> rakudo-moar c26ca6b08: OUTPUT: «｢C｣␤»

[09:03] <dmaestro> m: say 'C' ~~ / <:Lu> <!before <:L> >  /

[09:03] <camelia> rakudo-moar c26ca6b08: OUTPUT: «｢C｣␤»

[09:06] <dmaestro> Zero-width negative assertion works with simple patterns and property tests, but not with character classes when testing against end-of-string ... seems like a bug to me ...

[09:17] <timotimo> sounds like you just won an all-expenses-paid trip to the source code of the regex compiler <3

[09:17] <timotimo> just kidding, you don't have to, of course

[09:18] *** Black_Ribbon left
[09:33] *** zakharyas joined
[09:41] <dmaestro> timotimo: There's a regex debugger somewhere isn't there? I'd like to see what it says about this ...

[09:42] <dmaestro> before filing an issue :-)

[09:48] <jmerelo> dmaestro: there's a rakudo debugger, and a grammar debugger... I don't think there's a regex-only debugger.

[09:49] <dmaestro> Where is the grammar debugger, do you know?

[09:49] <jmerelo> dmaestro: you have to "use" a specific module. Let me see if I find it.

[09:49] <jmerelo> dmaestro: I think it's Grammar::Tracer

[09:50] <jmerelo> dmaestro: https://github.com/jnthn/grammar-debugger actually, two modules, one of them actually called Grammar::Debugger

[09:50] <dmaestro> jmerelo: sounds like I could try that, thanks!

[09:50] <jmerelo> dmaestro: sure :-)

[09:53] *** netrino joined
[10:09] <timotimo> there's not really enough of a difference between regex and grammar

[10:09] *** MidCheck joined
[10:17] *** zakharyas left
[10:23] *** molaf joined
[10:26] *** kurahaupo left
[10:26] *** kurahaupo joined
[10:54] *** kurahaupo left
[10:58] *** zacts joined
[10:59] *** pecastro joined
[11:02] *** zacts left
[11:10] *** kurahaupo joined
[11:12] *** kurahaupo left
[11:15] *** kurahaupo joined
[11:22] <jmerelo> .seen cpan-p6

[11:22] <yoleaux> I saw cpan-p6 23 Mar 2019 21:44Z in #perl6: <cpan-p6> New module released to CPAN! FindBin (0.2.0) by 03LEMBARK

[11:28] *** holyghost left
[11:31] *** molaf left
[12:00] *** natrys joined
[12:16] *** kurahaupo left
[12:16] *** kurahaupo joined
[12:17] *** Kaiepi left
[12:18] *** Kaiepi joined
[12:21] *** tadzik left
[12:27] *** tadzik joined
[12:46] *** sno left
[12:47] *** leont joined
[12:48] *** sno joined
[13:02] <jmerelo> Just in case anyone's interested, here's a draft of the objectives of the redesign of the Perl documentation system: https://github.com/perl6/doc/wiki/Ultimate-objectives-of-the-Perl-6-documentation-tooling

[13:03] <jmerelo> Mainly for the Google Summer of Code prospects, but also, well, in general for everyone.

[13:04] <El_Che> jmerelo: how is the GSC going?

[13:05] <El_Che> I was fairly surprise Perl got accepted after all these years

[13:05] <jmerelo> El_Che: well, we put together a good proposal, I guess

[13:06] <hahainternet> i've grown so tired with python i'm back writing Perl 5 or 6 wherever I can

[13:06] <El_Che> jmerelo's grant superpower

[13:06] <jmerelo> El_Che: we have a few students interested, but actually I just know about the ones that are interested in the project ideas I have proposed. We won't know until it opens tomorrow

[13:06] <hahainternet> need an inventory script for Ansible and I can't bring myself to write it in python again

[13:06] <hahainternet> and what else is there? Ruby? it's like a perl that had an accident

[13:06] <jmerelo> hahainternet: use Sparrowdo

[13:06] <jmerelo> hahainternet: that's rich :-)

[13:07] <hahainternet> jmerelo: with the greatest respect, i doubt sparrowdo has what i'm after either

[13:07] <El_Che> hahainternet: I mostly try to stick with perl6 and go

[13:07] <hahainternet> but as i did say respect, i'm going to go read :)

[13:07] <hahainternet> El_Che: yeah good choice imho, Go is what i'm trying to make my day job

[13:07] <hahainternet> can't wait till i can embed p6 in my Go code

[13:07] <El_Che> depending on the exitence of modules and deployment strategy

[13:07] <hahainternet> yeah sparrowdo reminds me of cfengine i think

[13:08] <hahainternet> but 'master host', 'target host', i'm not happy about that

[13:08] <El_Che> I am probably more fluent in Go (it's a very small language), but perl 6 code is written way faster.

[13:08] <hahainternet> with ansible, i can't encode the concept of 'a container in X'

[13:08] <El_Che> certainly for smaller stuff

[13:08] <hahainternet> every ansible target must be reachable over ssh, and if you want to disable facts you need to do that in a different place

[13:08] <hahainternet> it's tiresome, and El_Che Go is beautifully simple isn't it

[13:09] <hahainternet> it amuses me when people say they have to 'learn Go' because you learn it differently to everything else

[13:09] <hahainternet> most language tutorials try and carefully shove you into the right way to do things, wheras Go is mostly 'here is how you do all the common stuff, now read this page of tips and you're grand'

[13:09] <El_Che> If you know some other languages (like C or Java) I don't think you learn much with Go

[13:10] <El_Che> it's not revolutionary at all

[13:10] <hahainternet> i think the principles of embedding and implicit interfaces are very valuable, but yeah as a language it's so basic it's wonderful

[13:10] <El_Che> it's simple and handy

[13:10] <hahainternet> anyway Python is dead to me after broken assigment expressions

[13:10] <El_Che> some colleagues with a Ruby background have trouble with pointers

[13:10] <hahainternet> that is a broken language and a broken process

[13:11] <El_Che> I don't because I thinkg of Perl 5's references :)

[13:11] <jmerelo> hahainternet: what's happened with assignment expression?

[13:11] <hahainternet> jmerelo: it was introduced into the language

[13:11] <hahainternet> jmerelo: it is strictly against the zen of python

[13:11] <hahainternet> but it was introduced to avoid parsing ambiguity, because their parser is crap too

[13:11] <jmerelo> hahainternet: link?

[13:11] <hahainternet> it's hack on hack on hack, it's like perl but without even a good minimal core set

[13:12] <hahainternet> jmerelo: https://www.python.org/dev/peps/pep-0572/

[13:12] <hahainternet> it's why what's his face quit

[13:12] <El_Che> https://www.python.org/dev/peps/pep-0572/

[13:12] <hahainternet> because he pushed this through regardless of how non-pythonic it is

[13:12] <hahainternet> and then complained people fought against it

[13:13] <hahainternet> it deeply irritates me, the pythonic mantra has always been 'one way to do it, explicitly'

[13:14] <hahainternet> but now there's like 4 different string formatting methods, two different ways of assigning variables etc

[13:15] <jmerelo> hahainternet: right...

[13:15] <El_Che> hahainternet: pretty much like perl6 :P

[13:15] <hahainternet> i dunno, other than limitations on strict typing, 6 feels pretty coherent to me

[13:15] <jmerelo> hahainternet: there are many ways to do it. But at least we're honest about it.

[13:16] <hahainternet> honestly i can't think how many different ways 6 has

[13:16] <hahainternet> but the problem with python's diff ways is they're all distinct features

[13:16] <hahainternet> so f strings, .format, % operator

[13:16] <hahainternet> at the least

[13:18] <jmerelo> hahainternet: but Python has a nice documentation system, versioned and all. We don't. Have I mentioned we need help writing the Perl 6 documentation?

[13:18] <hahainternet> I assure you that documentation for python and python modules are amongst the worst that exists

[13:18] <hahainternet> jmerelo: do you know Go?

[13:19] <hahainternet> and if i can help with documentation i'd love to, but i don't have an authoritative understanding of how rakudo does its thing

[13:19] <jmerelo> hahainternet: Yep, I've used it from time to time. More familiar with Python (among non-perl things)

[13:19] <tadzik> eh, the zen of python is a bit like the pirate codex

[13:19] <tadzik> it's only followed when it fits the decision already made, it seems

[13:19] <jmerelo> hahainternet: you don't need to in most cases. Just check out the issues in the doc repo.

[13:19] <hahainternet> the problem with python docs is that they're always designed as a tutorial, but there are few lists of methods and the types they return etc

[13:19] <tadzik> "explicit is better than implicit, except when we implicitely pass `self` to the method being called"

[13:20] <hahainternet> in fact listing types seems discouraged in general, and it's rare to see a list of exceptions a method can throw

[13:20] <hahainternet> tadzik: @property, explicit my ass :(

[13:20] <hahainternet> jmerelo: rgr that

[13:20] <tadzik> hahainternet: hehe, that's even better

[13:21] <tadzik> but hey, you decorate these explicitely! :P

[13:21] * hahainternet cries

[13:21] <tadzik> anyway, I'm not too mad about assignment expressions

[13:21] <hahainternet> i explained to a guy the other day why Go's 'whatever, err := some_call()' is far superior to exceptions, but i think it fell on deaf ears

[13:21] <tadzik> but I'd be happier if someone made the closure scoping not garbage

[13:21] <hahainternet> tadzik: they're just assignments, but the parser is incapable of distinguishing them so i understand

[13:22] <hahainternet> well there's no scoping in conditionals either, which is quite annoying

[13:22] <tadzik> no scoping in blocks except if it's a try block :>

[13:22] <hahainternet> hah i had forgotten that was the case, haven't done pro python in a couple years now

[13:23] <hahainternet> tadzik: there's also the issue that you can't reliably distinguish a list from a string in a generic way

[13:23] <hahainternet> because both can be iterated or what-have-you

[13:23] <tadzik> but eh, saying that multiple assignment is superior to exceptions is a *very* long shot

[13:23] <hahainternet> tadzik: it's certainly much more pythonic

[13:23] <El_Che> tadzik: I find it easier to understand, personnaly

[13:23] <tadzik> it's not even really an alternative to them: at best you can use them as an ersatz of proper exceptions

[13:23] <tadzik> hahainternet: oh, pythonic. I don't care about that P

[13:23] <tadzik> :P

[13:23] <hahainternet> tadzik: the issue with exceptions is undocumented control flow

[13:24] <hahainternet> when will your function return? well, in Go, it's when you tell it to or it panics

[13:24] <tadzik> El_Che: oh, absolutely. But they serve a completely different purpose imho

[13:24] <hahainternet> wheras in Python it's: literally any exception that you didn't handle

[13:25] <hahainternet> programming resiliently in the face of potential failures is seriously hard in python

[13:25] <hahainternet> and it's practically mandatory and automatic in Go

[13:25] <tadzik> eeh

[13:25] <hahainternet> Failure in p6 is a wonderful approach

[13:25] <tadzik> have you tried Rust? :)

[13:25] <hahainternet> best of both worlds

[13:25] <hahainternet> hah, not to the extent i'm managing exceptions across stack frames

[13:25] <hahainternet> it is on my list however

[13:25] <tadzik> Failure, Error or whatever you call it is perfectly fine if your code is functional-ish

[13:26] <tadzik> but if function have side effects, ignoring the return value is a perfectly normal thing

[13:26] <tadzik> which is when Failures and Errors are useless

[13:26] <hahainternet> i'm so used to Go now that ignoring return values is exceptionally rare

[13:26] <El_Che> I wouldn't say say

[13:27] <hahainternet> i'm pretty sure if you sink a failure that it becomes an Exception too

[13:27] <El_Che> result, _ := funcThatAlsoReturnsAnError()

[13:27] <tadzik> hmm, I don't know about that. Perhaps

[13:27] <El_Che> that's pretty common

[13:27] <tadzik> El_Che: well, but then at least you're explicitely doing the wrong thing :P

[13:27] <El_Che> yeah, but it's pretty common

[13:28] <tadzik> true

[13:28] <hahainternet> tadzik: yeah try it in the repl

[13:28] <hahainternet> it'll throw

[13:28] <tadzik> hahainternet: yeah, indeed

[13:28] <tadzik> cool :)

[13:28] <hahainternet> El_Che: metalinters will also bitch at you for that

[13:31] <hahainternet> right i gotta brb, i dunno if Failure was inspired by another language, but it is one of the things in p6 that changed how i think about things, and that is the most valuable thing in the world: a new perspective

[13:31] *** lucasb joined
[13:32] <El_Che> hahainternet: try wearing your underwear on top of your pants!

[13:32] <El_Che> new perspective all right :)

[13:32] <hahainternet> El_Che: 'pants' means underwear, British :)

[13:32] <El_Che> damn :)

[13:32] <El_Che> trousers, my dear

[13:32] <hahainternet> one agrees

[13:33] <El_Che> it reminds me of Australian friends that hated the word "kids" with passion

[13:38] *** jmerelo left
[13:54] <tbrowder> SmokeMachine: are you available?

[13:54] <yoleaux> 23 Mar 2019 15:01Z <SmokeMachine> tbrowder: ive fixed your code... there was also another Red bug... please pull last Red master and try it again...

[13:59] <SmokeMachine> Sorry, I’m going to the super marketing...

[13:59] <tbrowder> SmokeMachine: good news: your last bug fix did the trick! after making one more set of changes to the models i got a successful total db load. now i am pushing all to the  PR. then, later today, i will  work on the queries and better docs in README.md plus internal in the models.

[13:59] <SmokeMachine> tbrowder: but, please let me know if I can help...

[13:59] <tbrowder> okay, will do

[14:00] <SmokeMachine> Great!!!

[14:00] <SmokeMachine> Looking forward!

[14:02] <tbrowder> oops i have a conflict so will have to push to PR later, got to go for a while...

[14:18] *** Xliff_ left
[14:29] *** reach_satori left
[14:30] *** Sgeo__ joined
[14:31] *** Sgeo__ left
[14:31] *** Sgeo__ joined
[14:33] *** kerrhau joined
[14:33] *** Sgeo_ left
[14:33] *** Sgeo joined
[14:37] *** Sgeo__ left
[14:38] *** kerrhau is now known as jaja

[14:40] <AlexDaniel> .tell RaycatWhoDat actually, if you show us your code maybe we'll be able to optimize it further to like… one or two lines maybe :)

[14:40] <yoleaux> AlexDaniel: I'll pass your message to RaycatWhoDat.

[14:45] *** mowcat joined
[14:53] *** uzl joined
[14:53] *** antoniogamiz joined
[14:54] <uzl> .seen moritz

[14:54] <yoleaux> 20 Mar 2019 22:52Z <tbrowder> uzl: fwiw i say "on" website most of the time around techies, "at" mostly around non-techies, and

[14:54] <yoleaux> I saw moritz 22 Mar 2019 21:08Z in #perl6: <moritz> but checking with (elem) would reify @foo, which blocks the 'gather', so deadlock

[14:55] *** imcsk8 left
[14:55] <antoniogamiz> \o/

[14:56] <antoniogamiz> what tests should have a module? in general, I know that specific ones depends on the module

[14:56] *** imcsk8 joined
[14:57] <uzl> tbrowder: Oh, I see. Now that I think about it, I probably only use "at" with email addresses ;-).

[14:57] *** reach_satori joined
[14:58] <uzl> .tell moritz Do you mind looking at this PR( https://github.com/perl6/doc/pull/2691 )? Thanks!

[14:58] <yoleaux> uzl: I'll pass your message to moritz.

[15:01] *** uzl left
[15:27] *** Kaiepi left
[15:27] *** Kaiepi joined
[15:36] <tbrowder> antoniogamiz: hi

[15:38] <tbrowder> look at my most recent module for my use of tests as one example: Date::Names. the first few tests are applicable to most modules i think.

[15:39] <tbrowder> search on modules.docs.org

[15:44] <antoniogamiz> tbrowder: oh I will take a look at it, thanks :)

[15:48] *** leont left
[15:52] *** leont joined
[16:08] *** MidCheck left
[16:11] *** jmerelo joined
[16:11] <Geth> ¦ doc: ad049302b7 | (JJ Merelo)++ | doc/Language/performance.pod6

[16:11] <Geth> ¦ doc: Reflow while (unnecessarily) checking #2695

[16:11] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/ad049302b7

[16:11] <Geth> ¦ doc: d1e0c450c5 | (JJ Merelo)++ | 3 files

[16:11] <Geth> ¦ doc: Just reflow, re-check #2695

[16:11] <synopsebot> Link: https://doc.perl6.org/language/performance

[16:11] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/d1e0c450c5

[16:22] *** molaf joined
[16:22] *** molaf left
[16:23] <tbrowder> .tell SmokeMachine working PR has been pushed

[16:23] <yoleaux> tbrowder: I'll pass your message to SmokeMachine.

[16:29] *** scovit_ left
[16:41] *** Xliff joined
[16:50] *** SCHAPiE left
[16:50] *** jmerelo left
[16:54] *** SCHAAP137 joined
[17:00] *** patrickb joined
[17:06] *** RaycatWhoDat joined
[17:06] <RaycatWhoDat> Hello again.

[17:06] <yoleaux> 14:40Z <AlexDaniel> RaycatWhoDat: actually, if you show us your code maybe we'll be able to optimize it further to like… one or two lines maybe :)

[17:06] <RaycatWhoDat> wait what

[17:07] <RaycatWhoDat> Ooh, they must have said this when I left.

[17:07] <AlexDaniel> yes :) hello

[17:08] <RaycatWhoDat> Right then. So, this was the code I was working on last night: https://github.com/RayMPerry/kitchen-sink/blob/master/perl6/get-files.p6

[17:08] <RaycatWhoDat> This is what I'm working on today. Would love any tips or optimizations you have for either. https://gist.github.com/RayMPerry/677d71e1565c09ed378f87a3f27a5257

[17:10] <AlexDaniel> RaycatWhoDat: maybe you can use IO() instead of Str

[17:10] <AlexDaniel> like sub list_files(IO() $directory = './',

[17:11] <RaycatWhoDat> Oh, weird. That just works 1:!

[17:11] <RaycatWhoDat> 1:1*

[17:11] <RaycatWhoDat> Thought I was passing in strings.

[17:11] <leont> You might want to try Path::Finder, it would make your code easier

[17:12] <AlexDaniel> m: say ‘foo’.indent(2)

[17:12] <camelia> rakudo-moar 888cf8cdc: OUTPUT: «  foo␤»

[17:12] <AlexDaniel> RaycatWhoDat: maybe also make use of this ↑

[17:13] <AlexDaniel> RaycatWhoDat: `my Str @foo` is probably just as good, no need to do `Str[]`

[17:13] <RaycatWhoDat> Got it.

[17:15] <RaycatWhoDat> So, for the second snippet of code, I'm trying to embrace the Perl way but I find myself falling back on C-style constructs.

[17:17] <AlexDaniel> `for $directory.dir.grep({.basename ~~ none @ignored-paths}) -> $current-file`

[17:17] <AlexDaniel> I wonder if that works

[17:17] <AlexDaniel> not any more readable, so probably not worth it

[17:18] <AlexDaniel> ah wait

[17:18] <AlexDaniel> there's a test thingie in `dir`, right?

[17:19] <AlexDaniel> `for $directory.dir(test => none @ignored-paths) -> $current-file`

[17:19] <AlexDaniel> does that work?

[17:19] <RaycatWhoDat> Ooh. Lemme see.

[17:21] <RaycatWhoDat> Yep, that works!

[17:23] <AlexDaniel> but okay, maybe I lied that it will be two lines, that's already pretty short :)

[17:23] <AlexDaniel> of course you can use a module to do that, but that's different

[17:24] <RaycatWhoDat> Right, right.

[17:26] <AlexDaniel> `if so %card_face{'mana_cost'}` why not `if %card_face<mana_cost>`

[17:30] <RaycatWhoDat> Oh, we can do that?

[17:31] <RaycatWhoDat> Yep, that works.

[17:31] <sena_kun> only for strings though.

[17:32] <sena_kun> <$foo> won't work unless you have literal `$foo` key.

[17:33] <RaycatWhoDat> Got it.

[18:03] *** kurahaupo left
[18:04] *** kurahaupo joined
[18:05] *** kurahaupo left
[18:05] *** kurahaupo joined
[18:07] *** antoniogamiz left
[18:09] *** adu joined
[18:23] *** TreyHarris left
[18:23] <AlexDaniel> RaycatWhoDat: `if ! so` can be written as `if not`

[18:24] <RaycatWhoDat> Got it.

[18:24] <AlexDaniel> RaycatWhoDat: `if (so %card{'card_faces'}) {` no need here for so and no need for () too :)

[18:24] <AlexDaniel> sorry I was away for a bit :)

[18:25] <RaycatWhoDat> Yep. I actually updated it a little.

[18:25] <RaycatWhoDat> https://github.com/RayMPerry/kitchen-sink/blob/master/perl6/scryfall.p6

[18:25] *** kurahaupo left
[18:25] *** kurahaupo joined
[18:26] *** Black_Ribbon joined
[18:26] <AlexDaniel> RaycatWhoDat: in perl 6, it's a bit unusual to see “print_card” instead of “print-card”

[18:27] <AlexDaniel> RaycatWhoDat: it's preference, and it's your choice, but just saying that kebab case is somewhat more common

[18:27] <RaycatWhoDat> Oh, do you use kebab-case her- Ah, I see.

[18:29] <AlexDaniel> RaycatWhoDat: also, if I was writing that code, I'd probably use `put` instead of `say`

[18:29] <AlexDaniel> the difference is discussed here: https://docs.perl6.org/language/faq#How_and_why_do_say,_put_and_print_differ?

[18:30] <AlexDaniel> for simple strings it doesn't matter, but in other cases it does

[18:30] <AlexDaniel> like

[18:30] <AlexDaniel> m: say 1..20

[18:30] <camelia> rakudo-moar 888cf8cdc: OUTPUT: «1..20␤»

[18:30] <AlexDaniel> m: put 1..20

[18:30] <camelia> rakudo-moar 888cf8cdc: OUTPUT: «1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20␤»

[18:30] *** netrino_ joined
[18:31] <RaycatWhoDat> Ah. Got it. Updated.

[18:32] *** kurahaupo left
[18:32] *** netrino left
[18:32] *** kurahaupo joined
[18:36] <AlexDaniel> oh wow URI::Encode doesn't have kebab-case variants…

[18:37] *** TreyHarris joined
[18:37] <Geth> ¦ doc: 1dad2d78b7 | cfa++ | doc/Language/nativetypes.pod6

[18:37] <Geth> ¦ doc: Remove leading m:

[18:37] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/1dad2d78b7

[18:37] <synopsebot> Link: https://doc.perl6.org/language/nativetypes

[18:37] <AlexDaniel> sena_kun: is there a Crolternative for URI::Encode?

[18:38] <sena_kun> AlexDaniel, we have an URI implementation, though I wonder how nice it is compared to URI::Encode.

[18:39] <sena_kun> give me a minute

[18:39] *** domidumont joined
[18:40] <AlexDaniel> URI::Encode is just 45 lines of code, one of which is `use v6.c` on the very top… I don't like it

[18:40] <sena_kun> I don't think we have "encode". We do have "decode" though.

[18:40] <AlexDaniel> oooooh https://github.com/perl6-community-modules/URI-Encode/issues/12

[18:41] <sena_kun> yes, that's likely a better thing

[18:41] <AlexDaniel> RaycatWhoDat: check it out ↑

[18:42] <AlexDaniel> RaycatWhoDat: seems like it's better to use uri-escape and uri-unescape from URI module

[18:42] <AlexDaniel> RaycatWhoDat: https://github.com/perl6-community-modules/uri

[18:42] <RaycatWhoDat> Got it.

[18:43] <RaycatWhoDat> Thank you for the insight.

[18:58] *** kurahaupo left
[18:58] *** kurahaupo joined
[19:14] *** jmerelo joined
[19:14] *** adu left
[19:15] *** brainbuz joined
[19:18] <MasterDuke> anybody up for helping me with a git problem?

[19:21] *** Black_Ribbon left
[19:22] *** Black_Ribbon joined
[19:23] <jmerelo> MasterDuke: shoot

[19:23] <MasterDuke> i need to rebase https://github.com/perl6/nqp/pull/518 onto master's HEAD

[19:24] <jmerelo> MasterDuke: but the binary files are the ones in conflict.

[19:24] <MasterDuke> but the merge conflicts are in the binary boostrap files

[19:24] <jmerelo> MasterDuke: but those binary files shouldn't be in the repo

[19:25] <MasterDuke> yes, those are the bootstraps

[19:25] <jmerelo> MasterDuke: you want _your_ files to overwrite theirs?

[19:26] <MasterDuke> i need to generate new ones after the first commit in my branch (and then again after another couple commits)

[19:26] <jmerelo> MasterDuke: (anyway, for the future you should keep binary files outside the repo, using "releases", for instance)

[19:26] <jmerelo> MasterDuke: you can create a branch from a checkout

[19:27] <MasterDuke> i'm not adding new binary files, just replacing new ones that are required to build nqp at all

[19:27] <jmerelo> MasterDuke: 

[19:28] <jmerelo> MasterDuke: let me see. You have to generate new binary files from an old commit, and then merge those with another old commit, right?

[19:28] *** RaycatWhoDat left
[19:28] <jmerelo> MasterDuke: then generate again those binary files from that new-old commit, and merge I guess with Master

[19:29] <MasterDuke> well, i want to rebase my first commit onto master's HEAD, then generate new bootstraps. then rebase the next couple commits, then generate another new bootstrap. then continue rebasing the final commits

[19:30] <jmerelo> first starting with the last one?

[19:30] <jmerelo> that is, HEAD^

[19:30] <MasterDuke> so start a rebase, pause in the middle and replace some of the commits, continue

[19:31] <MasterDuke> first is HEAD~13 or so on my branch

[19:31] <jmerelo> MasterDuke: you know about git checkout --theirs / --ours, right?

[19:32] <MasterDuke> yeah, but my branch will break if i just take master's bootstrap files. i have to create new ones

[19:32] <jmerelo> MasterDuke: then I think it's back again to create branches from commits

[19:34] <jmerelo> MasterDuke: check out first commit, convert it into a branch, generate bootstraps, merge, take your generated files, check out next commit, create branch, merge, take whatever files are the correct ones, and so on...

[19:35] <MasterDuke> yeah, i was hoping there was an easier way. but i guess not

[19:35] <jmerelo> MasterDuke: can't think of one... 

[19:38] <jmerelo> MasterDuke: sorry...

[19:45] <AlexDaniel> why rebase it?

[19:46] <AlexDaniel> just merge master into your branch, generate new binary files, done

[19:46] <AlexDaniel> no?

[19:52] <AlexDaniel> MasterDuke: silence :)

[19:52] <AlexDaniel> maybe my question is that stupid xD

[19:59] <MasterDuke> AlexDaniel: maybe that would work. but wouldn't the merge back into master of my branch then look quite odd?

[20:03] <AlexDaniel> MasterDuke: no

[20:10] *** SergiusUA joined
[20:11] <MasterDuke> anyway, i don't know what i was thinking. when i do start a rebase it does in fact pause at the conflicting commits. i generate new files and add them and just --continue

[20:12] *** kensanata joined
[20:19] *** domidumont left
[20:31] *** jmerelo left
[20:39] *** natrys left
[20:42] *** natrys joined
[20:55] *** choiboi left
[20:56] *** choiboi joined
[20:59] *** kensanata left
[21:06] <TreyHarris> MasterDuke: I didn't look at your issue before you force-pushed (unless that's a common ocurrence, you should follow it with another commit saying "FORCE PUSHED TO GITHUB", btw, as well as notifying any channels or mailing lists that may have people working on their own branch that's now going to conflict), but git rerere should've worked well for this...

[21:08] <TreyHarris> So on another note: I just managed to use Signature.new to create a routine at runtime. What I'm wondering is, can I use a signature (either with Signature.new or with the :(...) syntax) to abstract out a repeated set of named options that always occur together, e.g. in doing a complex set of App::Cmd subcommands (think git's many recurring flags)?

[21:09] <moritz> not really, I think

[21:09] <yoleaux> 14:58Z <uzl> moritz: Do you mind looking at this PR( https://github.com/perl6/doc/pull/2691 )? Thanks!

[21:12] <moritz> left my comment there

[21:13] <TreyHarris> moritz: I can do `my $textargs = :(Encoding :$encoding, Int $:buffering, Bool :$overwrite);` or whatever, but I can't re-use $textargs in a declaration in any way? So copy-paste's my only alternative short of using (|) and then dispatching to a middleman multi that unpacks the args before returning control (which is how it's often done in other languages but always leaves a bad taste in my mouth)?

[21:14] *** bobby left
[21:14] <TreyHarris> (Erm, not sure why I said "middleman multi". The alliteration, maybe. "Shim routine" of whatever kind.)

[21:14] *** bobby joined
[21:15] *** [Sno] joined
[21:15] <TreyHarris> This may be better as a mailing list question, it might be one of those "not quite but almost nearly as good" things that tend to be handled better in email...

[21:18] <moritz> TreyHarris: I understand what you want, but I know no good way

[21:18] *** sno left
[21:20] <TreyHarris> moritz: I'm sure you do, but somebody might have a clever thought. Isn't there a way to augment (English sense, not P6 sense) the argument list of a method when subclassing? I seem to recall it, but I can't find an example now

[21:24] *** sena_kun left
[21:28] *** bobby left
[21:30] *** bobby joined
[21:43] *** bobby left
[21:44] *** bobby joined
[21:46] <ugexe> if its a shim then you just sub MAIN(*%_) { my-shim(|%_) }; and let the shim take care of the typing errors. of course you also want the auto code generation from multi main i imagine which makes things more complicated.

[21:46] <ugexe> if you need to reference items in MAIN then %_<item> or whatnot

[21:47] <ugexe> alternatively maybe you could figure out something with macros.

[21:50] <ugexe> not sure technically why would couldnt let someone create a signature and attach it to their subs to avoid redundancy. but it comes up every so often and the answer doesn't seem like it will change anytime soon.

[21:50] *** kurahaupo left
[21:50] <TreyHarris> ugexe: I didn't consider macros, that's a good idea. I'd really very much like the subcommand to self-document as much as possible, so that seems better than the slurpy--I hopefully can keep the flag handling as before

[21:50] *** kurahaupo joined
[21:50] <TreyHarris> A macro could potentially preserve the auto-USAGE stuff even

[22:06] <TreyHarris> Is this expected behavior and, if yes, can I workaround it?

[22:06] <TreyHarris> m: sub MAIN(Str :$flag) { say $flag.perl }; BEGIN @*ARGS="--flag=False"

[22:06] <camelia> rakudo-moar 888cf8cdc: OUTPUT: «Usage:␤  <tmp> [--flag=<Str>]␤»

[22:06] <TreyHarris> m: sub MAIN(Str :$flag) { say $flag.perl }; BEGIN @*ARGS="--flag=false"

[22:06] <camelia> rakudo-moar 888cf8cdc: OUTPUT: «"false"␤»

[22:07] <TreyHarris> I was trying a test sequence of strings that happened to include the word False

[22:08] <ugexe> looks like a bug to me

[22:18] <TreyHarris> m: sub MAIN(Str() :$flag) { say $flag.perl }; BEGIN @*ARGS="--flag=False"

[22:18] <camelia> rakudo-moar 888cf8cdc: OUTPUT: «"False"␤»

[22:18] <TreyHarris> In the context of MAIN, Str should be equivalent to `Str()`, I think?

[22:19] <TreyHarris> (In effect--it obviously is not in practice.)

[22:25] <ugexe> that is what allmorphs are for

[22:25] <ugexe> and sub MAIN(Int $a) { } can work even though everything on the command line is a string

[22:26] <ugexe> m: sub MAIN($a) { say $a.WHAT }; BEGIN @*ARGS = "1"

[22:26] <camelia> rakudo-moar 888cf8cdc: OUTPUT: «(IntStr)␤»

[22:29] <ugexe> m: sub MAIN(:$foo) { say $foo.WHAT }; BEGIN @*ARGS = "--/foo=True";

[22:29] <camelia> rakudo-moar 888cf8cdc: OUTPUT: «(Bool)␤»

[22:29] <ugexe> m: sub MAIN(:$foo) { say $foo.WHAT }; BEGIN @*ARGS = "--/foo=true";

[22:29] <camelia> rakudo-moar 888cf8cdc: OUTPUT: «(Str+{<anon|1>})␤»

[22:30] <ugexe> the bool stuff should be handled like the last example

[22:31] <TreyHarris> There is no BoolStr though

[22:31] <ugexe> no, but the last example mixes in False to the string value of "true"

[22:31] <TreyHarris> Right.

[22:36] <TreyHarris> ugexe: what is the function of the slash in `--/foo=`?

[22:37] <TreyHarris> I can't find it documented

[22:42] <japhb> TreyHarris: It's like --no-foo in some other argument parsers.  The slash is just a boolean negator that doesn't annoy command shells.

[22:42] <yoleaux> 21 Mar 2019 18:22Z <ab6tract> japhb: sent a followup email :)

[22:44] <japhb> .tell ab6tract Saw the follow up email, thanks!  SGTM, but can't work on it right now because of $day-job stuff.  I'll keep it on my back burner for fun coding time though.  :-)

[22:44] <yoleaux> japhb: I'll pass your message to ab6tract.

[22:45] *** natrys left
[22:45] <TreyHarris> japhb: thanks--I knew --no- didn't work but I wasn't aware that existed

[22:46] *** pecastro left
[22:47] <TreyHarris> m: sub MAIN(:$foo) { say $foo.WHAT.perl }; BEGIN @*ARGS = "--/foo=true";

[22:47] <camelia> rakudo-moar 888cf8cdc: OUTPUT: «Str+{<anon|1>}␤»

[22:48] <TreyHarris> The above makes me think that "Str+<mumble>" should work as a type constraint in code; does it? The naive tries I've attempted don't

[22:48] <timotimo> nah, that's just a fun way to stringify it

[22:48] <timotimo> you'd have to use "but" or something like that

[23:00] <TreyHarris> m: my $x where Int|Bool; for (3, True, 3.5, 'hi') -> $v { $x = $v; say "YES to $x"; CATCH { when X::TypeCheck { say "NO to $v"; } } }

[23:00] <camelia> rakudo-moar 888cf8cdc: OUTPUT: «YES to 3␤YES to True␤NO to 3.5␤NO to hi␤»

[23:01] <TreyHarris> you can do it as a where, but not as a type constraint. I see.

[23:01] *** lucasb left
[23:01] <TreyHarris> m: my Int|Bool $x = False;

[23:01] <camelia> rakudo-moar 888cf8cdc: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Malformed my␤at <tmp>:1␤------> 3my Int7⏏5|Bool $x = False;␤»

[23:11] <TreyHarris> thanks, I submitted https://github.com/rakudo/rakudo/issues/2794

[23:17] <leont> «Incompatible MROs in P6opaque rebless for types Perl6::Metamodel::PackageHOW and Stash»

[23:17] <leont> Now that is a new error

[23:18] <leont> (for me)

[23:20] <timotimo> since the latest stable release you can only mix mixins into other things

[23:20] <timotimo> committable6: 2018.12,2019.03 my $a = 99 but Scalar

[23:20] <committable6> timotimo, ¦2018.12,2019.03: «Cannot mix in non-composable type Scalar into object of type Int␤  in block <unit> at /tmp/9h_AGCzRbJ line 1␤␤ «exit code = 1»»

[23:20] <timotimo> committable6: 2018.6,2019.03 my $a = 99 but Scalar

[23:20] <committable6> timotimo, ¦2018.6: «Cannot find this revision (did you mean “2018.06”?)» ¦2019.03: «Cannot mix in non-composable type Scalar into object of type Int␤  in block <unit> at /tmp/mXvzzVhx9W line 1␤␤ «exit code = 1»»

[23:20] <timotimo> committable6: 2018.06,2019.03 my $a = 99 but Scalar

[23:20] <committable6> timotimo, ¦2018.06,2019.03: «Cannot mix in non-composable type Scalar into object of type Int␤  in block <unit> at /tmp/AncylkByDD line 1␤␤ «exit code = 1»»

[23:20] <timotimo> oh, type objects

[23:21] <timotimo> committable6: 2018.06,2019.03 my $a = 99 but Scalar.new

[23:21] <committable6> timotimo, ¦2018.06,2019.03: «Cannot make a Scalar object using .new␤  in block <unit> at /tmp/akwIrtq1SV line 1␤␤ «exit code = 1»»

[23:21] <timotimo> committable6: 2018.06,2019.03 my $a = 99 but (my $).VAR

[23:21] <committable6> timotimo, ¦2018.06,2019.03: «»

[23:21] <timotimo> hum.

[23:21] <leont> This error happens during compilation

[23:21] *** rindolf left
[23:21] <timotimo> yeah

[23:21] <timotimo> probably during class definition somewhere

[23:21] <leont> http://paste.scsys.co.uk/583621

[23:22] <leont> But only in one of my test files

[23:22] <TreyHarris> committable6: my $x = 99 but 3

[23:22] <committable6> TreyHarris, ¦my: «Cannot find this revision (did you mean “all”?)»

[23:22] <leont> That doesn't contain but or does

[23:22] <TreyHarris> oops

[23:23] <TreyHarris> committable6: 2018.12,2019.03 my $x = 99 but 3

[23:23] <committable6> TreyHarris, ¦2018.12,2019.03: «»

[23:23] <TreyHarris> I thought that gave a warning at one point

[23:26] <leont> Ah, It seems my problem is File::Temp related

[23:28] <leont> What. This is bizarre.

[23:28] <leont> If I move the File::Temp below my «use lib» line, everything works. But above it, it fails.

[23:28] <TreyHarris> .tell grondilu I think you want `.ACCEPTS(Array) && .all ~~ Num given [pi]`

[23:28] <yoleaux> TreyHarris: I'll pass your message to grondilu.

[23:29] <TreyHarris> m: .ACCEPTS(Array) && .all ~~ Num given [pi]

[23:29] <camelia> rakudo-moar 888cf8cdc: ( no output )

[23:29] <TreyHarris> m: say so (.ACCEPTS(Array) && .all ~~ Num given [pi])

[23:29] <camelia> rakudo-moar 888cf8cdc: OUTPUT: «True␤»

[23:32] <leont> Latest error: «No such method 'reify-until-lazy' for invocant of type 'NQPArray'»…

[23:32] <MasterDuke> TreyHarris: i force pushed to my own branch in my own fork, so i doubt it'd mess anybody up. but yeah, i don't force push to master of the main repo

[23:33] <MasterDuke> leont: huh, NPQArrays aren't really supposed to leak out

[23:34] <TreyHarris> MasterDuke: Oh! I followed your link by launching it from IRC and didn't notice it wasn't the canonical. Sorry!

[23:35] <leont> Yeah, I would imagine so

[23:35] <leont> It appears the issue is «use lib» is the issue. Or at least loading something from that dir

[23:35] <leont> Sometimes

[23:36] <leont> The dir contains a lib A that loads a lib B.

[23:36] <TreyHarris> MasterDuke: If you haven't played with git-rerere, I highly recommend it--one of those hidden git gems

[23:36] <MasterDuke> TreyHarris: np, it isn't obvious

[23:36] <leont> Loading B before the use lib causes really weird errors

[23:36] <MasterDuke> never heard of it, i'll take a look

[23:36] <leont> Loading B after works fine

[23:36] *** SergiusUA left
[23:38] <TreyHarris> It's like git-stash or git-wip, one of those things that can really be a revelation before you know it exists. More so than git-wip, maybe, since it's built-in to the Git distro and doesn't need config fiddling and editor integration like git-wip does

[23:43] *** entonian joined
[23:48] *** entonian left
[23:51] <leont> My problem was solved by manually removing my t/lib/.precomp

[23:52] <TreyHarris> leont: ouch. I've never needed to do that so it would've taken forever to occur to me

