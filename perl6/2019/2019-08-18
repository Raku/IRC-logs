[00:00] *** reportable6 left
[00:00] *** wildtrees left
[00:01] *** reportable6 joined
[00:01] *** ChanServ sets mode: +v reportable6

[00:09] *** thundergnat left
[00:37] *** mowcat left
[00:37] *** molaf left
[00:59] *** Xliff left
[01:15] *** jaldhar left
[01:16] *** jaldhar joined
[01:21] *** jaldhar left
[01:21] *** jaldhar joined
[01:39] *** fake_space_whale joined
[02:04] *** Manifest0 left
[02:04] *** Manifest0 joined
[02:30] *** Cabanossi left
[02:41] *** Cabanossi joined
[02:59] <fake_space_whale> Is there a inbuilt function like 'say' but that returns the thing passed to it. For example, if it was called echo then "echo(4) == 4" would be true. this sort of function can be very helpful during debugging, and while it is trivial to define it yourself, I was wondering if it was prebuilt

[03:02] <aearnus[m]> m: 'hello'.say.say;

[03:02] <camelia> rakudo-moar ecf2b1e4f: OUTPUT: ¬´hello‚ê§True‚ê§¬ª

[03:02] <aearnus[m]> huh, I thought that was how it worked...

[03:11] *** jaldhar left
[03:12] *** jaldhar joined
[03:20] *** jaldhar left
[03:20] *** jaldhar joined
[03:22] <aearnus[m]> m: 'hello'.&{ .say }.say;

[03:22] <camelia> rakudo-moar ecf2b1e4f: OUTPUT: ¬´hello‚ê§True‚ê§¬ª

[03:45] *** fake_space_whale left
[03:54] *** hythm joined
[04:08] <Elronnd> m: sub echo($x) { say $x; $x; } echo echo 5

[04:08] <camelia> rakudo-moar ecf2b1e4f: OUTPUT: ¬´5===SORRY!5=== Error while compiling <tmp>‚ê§Strange text after block (missing semicolon or comma?)‚ê§at <tmp>:1‚ê§------> 3sub echo($x) { say $x; $x; }7‚èè5 echo echo 5‚ê§    expecting any of:‚ê§        infix‚ê§        infix stopper‚ê§       ‚Ä¶¬ª

[04:08] <Elronnd> m: sub echo($x) { say $x; $x; }; echo echo 5

[04:08] <camelia> rakudo-moar ecf2b1e4f: OUTPUT: ¬´5‚ê§5‚ê§¬ª

[04:16] <aearnus[m]> m: use MONKEY-TYPING; augment class Mu { method echo { self.say; self } }; 'hello'.echo.echo;

[04:16] <camelia> rakudo-moar ecf2b1e4f: OUTPUT: ¬´No such method 'echo' for invocant of type 'Str'. Did you mean any of these?‚ê§    chop‚ê§    chr‚ê§    echo‚ê§    sech‚ê§‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[04:17] <aearnus[m]> uhh? Isn't that supposed to work

[04:32] *** mahafyi left
[04:34] *** pilne left
[04:34] *** mahafyi joined
[04:48] *** hythm left
[04:58] *** jaldhar left
[05:15] *** Xliff joined
[06:00] *** reportable6 left
[06:04] *** reportable6 joined
[06:04] *** ChanServ sets mode: +v reportable6

[06:39] *** molaf joined
[06:52] *** Xliff left
[06:55] <MasterDuke> aearnus[m]: i think augment only works for new instances of classes, you'd need to recompose pre-existing ones

[06:55] <MasterDuke> m: use MONKEY-TYPING; augment class Mu { method echo { self.say; self } }; Str.^compose; "hello".echo.echo;

[06:55] <camelia> rakudo-moar ecf2b1e4f: OUTPUT: ¬´hello‚ê§hello‚ê§¬ª

[06:55] <aearnus[m]> MasterDuke: Is there an automatic way to recompose all classes which have the base class in its mro then?

[06:57] <MasterDuke> aearnus[m]: i don't think so, but this is stuff i've only seen in the channel, not played with myself. i'd suggest searching the channel logs for '^compose' and see if you find anything interesting

[06:58] <aearnus[m]> hmm will do. the idea of "getting every class which inherits from some other class" is 99% of the time totally XY'ed, but this is the 1% of times when i actually want that functionality, haha

[07:01] <MasterDuke> yeah, i don't think it'll be easy, classes know who they inherit from, but not who inherits from them. oO(`Mu.^reverse-mro`)

[07:16] *** ravenous_ joined
[07:16] <aearnus[m]> is there an easy way to print columns?

[07:17] <aearnus[m]> (easier than printf'ing over a list, at least)

[07:20] <MasterDuke> i'm not thinking of anything built it, but there are several table-related module

[07:23] <MasterDuke> xliff[m]: you might be interested in https://github.com/rakudo/rakudo/commit/23cfe1c697

[07:30] *** cpage left
[07:31] *** rindolf joined
[07:41] *** sjm_uk joined
[07:54] *** obfusk__ left
[07:55] *** obfusk__ joined
[08:12] *** obfusk__ left
[08:13] *** obfusk__ joined
[08:16] *** rindolf left
[08:22] *** S007 left
[08:22] *** S007 joined
[08:25] *** S007 left
[08:25] *** S007 joined
[08:46] <Geth> ¬¶ ecosystem: 86da237b1d | lukasvalle++ (committed using GitHub Web editor) | META.list

[08:46] <Geth> ¬¶ ecosystem: Add jsonhound to ecosystem

[08:46] <Geth> ¬¶ ecosystem: 

[08:46] <Geth> ¬¶ ecosystem: Add jsonhound "a system for parsing JSON data structures and identifying anomalies" (https://github.com/oposs/jsonhound) to ecosytem.

[08:46] <Geth> ¬¶ ecosystem: review: https://github.com/perl6/ecosystem/commit/86da237b1d

[08:46] <Geth> ¬¶ ecosystem: 32b78d0a9d | (Jonathan Stowe)++ (committed using GitHub Web editor) | META.list

[08:46] <Geth> ¬¶ ecosystem: Merge pull request #464 from perl6/lukasvalle-patch-1

[08:46] <Geth> ¬¶ ecosystem: 

[08:46] <Geth> ¬¶ ecosystem: Add jsonhound to ecosystem

[08:46] <Geth> ¬¶ ecosystem: review: https://github.com/perl6/ecosystem/commit/32b78d0a9d

[08:47] <aearnus[m]> what's the opinion on pushing binary-only modules to the module repository

[09:02] *** Manifest0 left
[09:02] *** Manifest0 joined
[09:09] *** [Sno] left
[09:11] *** [Sno] joined
[09:13] *** holyghost joined
[09:13] <daxim> https://comic.browserling.com/95

[09:14] *** rindolf joined
[09:25] *** leont joined
[09:40] *** sjm_uk left
[09:43] <moritz> aearnus[m]: I don't think the ecosystem is designed for that

[09:45] <tadzik> :)

[09:46] <tadzik> are compiled modules relocatable (across systems?)

[09:47] <nine> tadzik: yes

[09:47] <moritz> but not across rakudo versions, are they?

[09:47] <nine> Actually there's really not much missing for supporting binary only modules

[09:47] <nine> moritz: no, not across versions

[09:49] *** domidumont joined
[09:50] <tadzik> right

[09:57] *** Black_Ribbon left
[09:59] *** chloekek joined
[10:03] *** hcit joined
[10:20] *** cygx joined
[10:21] <cygx> tadzik: precompiled modules aren't all that useful, though

[10:21] *** ravenous_ left
[10:21] <cygx> as far as I'm aware, you'd have to fix exact versions of all dependencies

[10:21] <cygx> but precompiled applications are another matter

[10:21] <cygx> that's something I'd like to see happening

[10:23] <AlexDaniel> Juerd: hello

[10:26] *** fake_space_whale joined
[10:26] <AlexDaniel> Juerd: not sure if my PMs will arrive, so letting you know that you should now be able to comment on problem-solving issues :)

[10:28] *** Kaiepi left
[10:29] *** Kaiepi joined
[10:36] *** nadim joined
[10:38] <nine> cygx: precompiled libraries with dependencies are exactly what binary Linux distributions are good at handling

[10:42] *** ravenous_ joined
[10:47] *** sjm_uk joined
[10:50] <leont> precompiled applications sound useful, yes

[10:52] <cygx> nine: in conclusion, let's ship modules via the system package manager ;)

[10:53] * chloekek is working on that in case the system is NixOS

[10:56] <cygx> leont: in principle, you can already do that if you implement all the logic yourself

[10:56] <cygx> eg https://github.com/cygx/p6-freezer/blob/master/recorder.p6 is how I record a list of modules a program needs

[10:57] <nine> cygx: that's in fact how we install Perl 6 modules on our servers: https://build.opensuse.org/project/show/devel:languages:perl6

[10:59] <cygx> nine: correct me if I'm wrong, but I assume that means having to cut new releases every time a dependency gets a security fix?

[11:00] <nine> cygx: yes. But that's quite trivial since the whole packaging process is automated. Makes deployment and having the same versions on all machines a breeze

[11:00] <chloekek> What's the alternative? You can't just automatically download the latest version of every distribution, since that itself is a security problem.

[11:01] <chloekek> (See the npm disaster that happens every other week.)

[11:02] <cygx> freezing deps at application instead of library level

[11:04] <cygx> library Foo:ver<0.5> depends on Bar:ver<0.3.5..*>, and an application usinf Foo and Bar will depend on exact versions

[11:08] <chloekek> If the package repository has those versions then that would work just fine.

[11:10] *** ravenous_ left
[11:12] *** cygx left
[11:23] <El_Che> maybe is looking at "minimal version selection" algorythm golang uses useful

[11:23] <El_Che> as a static compiled language it makes sense, so it could make sense if a perl 6 app bundles binary modules

[11:25] <El_Che> https://github.com/golang/go/wiki/Modules#version-selection

[11:29] *** cygx joined
[11:31] <cygx> there's a lso supposed to be recommendation managers, which I imagine would correspond to a list of 'known-good' versions

[11:33] <El_Che> well, it depends a little on what model you take. Recommendation managers make sense for shared modules

[11:33] <El_Che> go goes for the app+modules packages, which is nice

[11:34] <El_Che> I think that's a model that would appeal to people running apps written in dynamic languages

[11:34] <El_Che> deploying perl/ruby/python in production is painfully sucky

[11:34] <El_Che> (compared to java or go)

[11:35] <El_Che> relocatable rakudo and binary relocatable modules could lead to a jar like deployment process

[11:36] <El_Che> which would rock

[11:39] <cygx> that's basically possible right now

[11:39] <cygx> I've written a proof of concept, it seems to work

[11:39] <cygx> I'm more ambitious than that

[11:40] <cygx> the goal is a single-file executable

[11:40] <cygx> when run, it unpacks resources to disk and loads bytecode directly from memory

[11:40] <cygx> there are still pieces missing to make that a reality

[11:41] <cygx> the jar-like thing can in pprinciple be done right now in 'user-space'

[11:41] <timotimo> cygx: i fixed update_ops.p6 recently btw

[11:42] *** lichtkind__ joined
[11:42] <cygx> timotimo++

[11:45] *** lichtkind_ left
[11:46] <cygx> ~~

[11:47] *** cygx left
[11:49] <El_Che> does it include the runtime?

[11:52] *** chloekek left
[11:55] *** aborazmeh joined
[11:55] *** aborazmeh left
[11:55] *** aborazmeh joined
[12:00] *** reportable6 left
[12:05] *** reportable6 joined
[12:20] *** aborazmeh left
[12:20] *** mahafyi left
[12:22] *** mahafyi joined
[12:40] *** ravenous_ joined
[12:42] *** kiwi_21 joined
[12:43] <kiwi_21> p6: $_ = 'a'; .say for m/a/, m/a/; .say for m/a/, m/b/; .say for m/b/, m/a/;

[12:43] <camelia> rakudo-moar ecf2b1e4f: OUTPUT: ¬´ÔΩ¢aÔΩ£‚ê§ÔΩ¢aÔΩ£‚ê§Nil‚ê§Nil‚ê§ÔΩ¢aÔΩ£‚ê§ÔΩ¢aÔΩ£‚ê§¬ª

[12:44] *** Ven`` joined
[12:51] *** leont left
[12:53] *** chloekek joined
[12:54] <kiwi_21> ah, got it, m/.../ doesn't just return the match object but also binds (not assigns) to $/

[12:54] *** kiwi_21 left
[12:55] <chloekek> p6: $/.VAR.say; given 'foo' { m/o/; $/.VAR.say }; $/.VAR.say

[12:55] <camelia> rakudo-moar ecf2b1e4f: OUTPUT: ¬´Nil‚ê§ÔΩ¢oÔΩ£‚ê§ÔΩ¢oÔΩ£‚ê§¬ª

[13:00] *** Kaiepi left
[13:00] *** Kaiepi joined
[13:01] <timotimo> m: Hello Perl 6

[13:01] <camelia> rakudo-moar ecf2b1e4f: OUTPUT: ¬´5===SORRY!5=== Error while compiling <tmp>‚ê§Two terms in a row‚ê§at <tmp>:1‚ê§------> 3Hello Perl7‚èè5 6‚ê§    expecting any of:‚ê§        infix‚ê§        infix stopper‚ê§        postfix‚ê§        statement end‚ê§        statement modifier‚ê§‚Ä¶¬ª

[13:01] <timotimo> you think we could do better for this?

[13:03] *** Kaiepi left
[13:03] *** Kaiepi joined
[13:05] <chloekek> Enclose any actual code inside <?perl6 ... ?> brackets and write any text outside of those to stdout.

[13:05] <chloekek> Oh you mean the LTA error message.

[13:06] <timotimo> yeah, the latter

[13:07] <timotimo> i mean, Perl is actually a valid class

[13:07] *** molaf left
[13:07] <timotimo> Hello isn't though

[13:07] <timotimo> but subs are allowed to be post-declared

[13:07] *** nadim left
[13:07] <timotimo> so the problem here is that Perl is a class, and that makes it definitely-not-a-sub

[13:07] <timotimo> m: Hello World 6

[13:07] <camelia> rakudo-moar ecf2b1e4f: OUTPUT: ¬´5===SORRY!5=== Error while compiling <tmp>‚ê§Undeclared names:‚ê§    Hello used at line 1‚ê§    World used at line 1‚ê§‚ê§¬ª

[13:09] *** pamplemousse joined
[13:10] *** mowcat joined
[13:12] <chloekek> Ah.

[13:12] <timotimo> the "expecting any of:" list isn't especially readable to someone who just started out with perl6, tbh

[13:13] <timotimo> *shrug* maybe someone will come up with something smart at some point

[13:14] <MasterDuke> if you remember, i made a PR a while ago that removed those unless you'd done --ll-exceptions (or something like that), but it was rejected

[13:16] <timotimo> now if we could somehow output what the recent text has been "parsed as" in a simplified format, that could perhaps be interesting

[13:17] <chloekek> I think the message you want here is something like: "can't apply Perl to 6 since it's not a sub but a class"

[13:18] *** nadim joined
[13:32] *** tellable6 joined
[13:32] *** ChanServ sets mode: +v tellable6

[13:35] *** lizmat joined
[13:46] *** nadim left
[13:48] *** evalable6 left
[13:49] *** evalable6 joined
[14:04] *** Ven`` left
[14:11] *** ravenous_ left
[14:12] *** ravenous_ joined
[14:17] *** Ven`` joined
[14:22] *** lucasb joined
[14:23] *** Cabanossi left
[14:29] *** Cabanossi joined
[14:40] *** pilne joined
[14:40] *** chloekek left
[14:49] *** evalable6 left
[14:52] *** evalable6 joined
[14:52] *** ChanServ sets mode: +v evalable6

[14:55] *** khisanth_ left
[14:59] *** nadim joined
[15:02] *** leont joined
[15:06] *** nepugia joined
[15:08] *** khisanth_ joined
[15:11] *** sjm_uk left
[15:16] *** ExtraCrispy joined
[15:16] *** ExtraCrispy left
[15:18] *** nadim_ joined
[15:21] *** nadim left
[15:25] *** zakharyas joined
[15:34] *** Sgeo__ joined
[15:37] *** Sgeo_ left
[15:52] *** evalable6 left
[15:56] *** evalable6 joined
[15:56] *** ChanServ sets mode: +v evalable6

[16:00] *** mhasch joined
[16:06] <mhasch> Hi p6 crowd, where would be a good place to discuss Perl 6 language features? I take it the rakudo issue tracker on github is more about compiler issues.

[16:07] <moritz> mhasch: here

[16:10] *** dogbert17 joined
[16:11] *** aborazmeh joined
[16:11] *** aborazmeh left
[16:11] *** aborazmeh joined
[16:12] <mhasch> moritz: chat is nice and direct, but too telegram style. I'd rather elaborate a bit in an article somewhere. We could always chat later.

[16:13] <timotimo> there's also the perl6-language (or so?) mailing list

[16:15] *** Ven`` left
[16:20] <mhasch> The mailing list perl6-language exists and looks appropriate. Also somewhat comatose. But I'll try that. Thanks.

[16:21] <timotimo> i'm sure people are reactive when something does get posted

[16:23] <mhasch> Yes, it is not necessarily bad if the language as such gets less discussion than implementation topics.

[16:24] *** lembark left
[16:31] *** ravenou__ joined
[16:33] *** ravenous_ left
[16:34] <lucasb> Maybe write a gist and share it here. Or create an issue in the PS repo. See the "language" issues: https://github.com/perl6/problem-solving/labels/language

[16:40] <AlexDaniel> mhasch: correct, problem-solving repo is what you're looking for

[16:42] <lucasb> sorry for the "PS", I'm was lazy to type :)

[16:43] <lucasb> also, s/problem-solving/proposals/ ?

[16:46] <Kaiepi> idk, i've opened issues there that aren't so much proposals but rather "this needs to happen, but how should it be approached?"

[16:47] <AlexDaniel> well, previously we had a little issue with people proposing things without really defining what the actual problem is, so‚Ä¶

[16:47] <lucasb> understood. "proposals" doesn't catch all uses of the issue queue

[16:48] <lucasb> and "rfcs" is already an overloaded term in the P6 history :)

[16:50] *** MilkmanDan left
[16:51] <mhasch> Ah yes, the problem-solving repo feels about right.  I'll have to browse what has already been addressed there. If I chime in, I will try to be specific.

[16:51] *** molaf joined
[16:52] *** MilkmanDan joined
[16:52] <timotimo> do you want to give us a brief preview of what you'll be addressing?

[16:52] <AlexDaniel> mhasch: in a few words, what do you have in mind? Maybe I'll be able to point you into the right direction if there are existing efforts in that area

[16:53] *** Black_Ribbon joined
[16:56] *** evalable6 left
[16:57] <Kaiepi> what did i miss with the language name changing situation over the past week? i couldn't really keep up with it for reasons

[16:57] <mhasch> Of course. I'd like to talk about how the (numerical) type system could be made more suitable for computer algebra programming and at the same time safer to use. My main concern is how precise types (Int, Rat, FatRat) will happily eat all your memory unless used with great care.

[16:57] <Kaiepi> interesting!

[16:59] *** evalable6 joined
[16:59] *** ChanServ sets mode: +v evalable6

[17:00] <moritz> mhasch: are you aware that Rat automatically degrades to Float if the denominator gets too big?

[17:02] <El_Che> moritz: maybe that does not falls under safely?

[17:03] <mhasch> moritz: yes i am aware of that, but Rats can still explode like Ints, and for math purposes you need to catch overflows rather than switch to unprecise silently.

[17:04] <AlexDaniel> Kaiepi: there's a PR https://github.com/perl6/problem-solving/pull/89

[17:04] <AlexDaniel> Kaiepi: feedback is welcome

[17:04] <AlexDaniel> (if anybody wants to review it seriously but can't because of the lock, let me know, I'll fix that for you)

[17:06] <timotimo> didn't we just recently get something like $*PRECISION for rats?

[17:06] <AlexDaniel> timotimo: yeah, but it's unlikely to get into the release

[17:07] <timotimo> 'k

[17:07] <Kaiepi> thanks

[17:07] <AlexDaniel> mhasch: so, how big are your numbers?

[17:07] <lucasb> R#3122

[17:07] <synopsebot> R#3122 [open]: https://github.com/rakudo/rakudo/pull/3122 Introduce the $*PRECISION variable

[17:08] <AlexDaniel> yeah, it's a useful change because people keep demaning non-floaty behavior :)

[17:08] <mhasch> AlexDaniel: depends. But finite. Small fraction of RAM anyways.

[17:10] <AlexDaniel> mhasch: I'm wondering because I don't remember any code eating memory just because Ints or Rats are growing too fast, but there's a lot of code out there that simply becomes really slow

[17:11] <mhasch> Pull 3122 actually sounds not half bad. But, like I said, Rat denominar limit does by far bot catch all dangerous cases.

[17:11] <AlexDaniel> and in general performance of Rats or huge Ints is not exactly fixable, something still needs to crunch all the numbers

[17:12] <Kaiepi> the only input i have about the name change is even though i argued for the name change because of perl's reputation, i was still hesitant about it because we also lose the recognizability that comes with the name. but if marketed properly this could be a really good thing for the language

[17:13] <mhasch> It is not a performance issue, it is a question of catching large numbers before your os starts panicking.

[17:14] *** ravenous_ joined
[17:16] *** ravenou__ left
[17:17] <mhasch> AlexDaniel: Perl 6 behaves similar to python when numbers grow.  The program (and everything else on your machine) slows down for sheer memory consumption. Not considered safe.

[17:18] *** aborazmeh left
[17:20] *** ravenous_ left
[17:20] *** ravenou__ joined
[17:22] *** Sgeo joined
[17:24] *** Sgeo__ left
[17:25] <AlexDaniel> mhasch: not exactly. Really big numbers still have relatively small memory footprint, it's just that operations with big numbers take time to finish. It doesn't affect anything else on your machine (well OK you can have a process crunching numbers 100% of a core, but that's about it). And what's unsafe about it, exactly? People still have to validate your input, so might as well check how big of a thing they received (you have to do

[17:25] <AlexDaniel> that for strings anyway, so why not for numbers)

[17:28] *** CIAvash joined
[17:28] <timotimo> i mean, we don't re-use big integers at the moment, so you end up with lots of copies

[17:28] <timotimo> until the next GC run

[17:28] <MasterDuke> well, the underlying big int object (in libtommath) can get large

[17:29] <timotimo> which will happen earlier if you're working with many big, big, big integers

[17:29] <MasterDuke> though we now track their size better for GC purposes than we used to

[17:30] <AlexDaniel> timotimo: but you probably run into the same issue with small numbers too, and in fact it's probably easier to generate a bunch of small objects anyway?

[17:31] <timotimo> if your number is hundreds of megabytes big, you'll eat up your ram with just a few operations

[17:31] <AlexDaniel> why would you have a number that big

[17:31] <timotimo> because you're a mathematician, physician, number theorist, whatever?

[17:32] *** netrino joined
[17:33] <AlexDaniel> ok, let me rephrase that

[17:33] <robertle> but isn't it possible to create a really large FatRat by accident? even without being a mathmatician? just by multiplying up other rats where the denomniators are coprime-ish?

[17:33] <AlexDaniel> where do you get that number from?

[17:33] <AlexDaniel> like a binary file that is hundreds of megabytes big, generated by something else?

[17:34] <AlexDaniel> I don't think this is the use case that mhasch is concerned about

[17:34] <timotimo> robertle: i think adding is much more dangerous in that regard?

[17:35] <AlexDaniel> robertle: not exactly

[17:35] <robertle> yeah, quite possibly. I am thinking of cases like gauss elimination on a large matrix. a quite common thing to do. wouldn't the FatRats get really large quickly? 

[17:36] <robertle> note that I think that may be a good thing, after all the alternative is to do the math wrong, but just saying that they can get large by doing math on them, not only by using large numbers as inputs to your maths...

[17:36] <AlexDaniel> they'll be slow but not too big

[17:38] <robertle> ok, I guess subjectively that feels like the same thing to me :)

[17:38] <tobs> timotimo: not really. The denominator of a sum is the lcm of denominators worst-case and for a product it's the product of denominators, where the lcm is the best case.

[17:38] <mhasch> It does not take much to get big numbers from small ones with just a few operations. Think 5 ** 5 ** 5 ** 5.

[17:39] <AlexDaniel> mhasch: that's correct, and it'll take a lot of time to compute that

[17:39] <AlexDaniel> although in this case we just die with numeric overflow‚Ä¶

[17:40] <AlexDaniel> m: say 5 ** 5 ** 5 ** 5

[17:40] <evalable6> AlexDaniel, rakudo-moar 23cfe1c69: OUTPUT: ¬´(exit code 1) Numeric overflow‚ê§  in block <unit> at /tmp/xhAmgvk_rD line 1‚ê§‚ê§¬ª

[17:40] <camelia> rakudo-moar ecf2b1e4f: OUTPUT: ¬´Numeric overflow‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[17:40] <timotimo> tobs: gets fantastic when you add up 1/n

[17:40] <tobs> timotimo: or well, depends on how much you can cancel in the result, too...

[17:41] <AlexDaniel> but it gets slow before that

[17:41] <AlexDaniel> m: my $x = 5 ** 5 ** 13

[17:41] <evalable6> AlexDaniel, rakudo-moar 23cfe1c69: OUTPUT: ¬´(signal SIGHUP) ¬´timed out after 10 seconds¬ª¬ª

[17:42] <mhasch> Oh, so we do have overflow exceptions. Last time I checked, the slowly grinding to a halt thing happened. I wonder what triggeres it?

[17:42] <timotimo> no, that's just the bot

[17:42] <timotimo> it kills everything that takes too long

[17:42] <AlexDaniel> timotimo: see the previous eval

[17:43] <timotimo> oh

[17:43] <timotimo> but that's only for some operations i think?

[17:43] <mhasch> Might be a simple check on the second ** argument though.  Real life examples can be less obvious.

[17:45] <AlexDaniel> mhasch: so the problem is that things can become slow?

[17:45] *** camelia left
[17:46] <mhasch> No. Slowliness is collateral, size is the issue.

[17:46] *** camelia joined
[17:48] <camelia> rakudo-moar ecf2b1e4f: OUTPUT: ¬´(timeout)¬ª

[17:48] *** ChanServ sets mode: +v camelia

[17:49] <mhasch> A FattishRat type limited to $FATTISHRATSIZE bytes perhaps, with an overflow exception. No exception, precise result. Exception, no result, but no harm done to the envirnment either.

[17:49] <AlexDaniel> mhasch: now, I don't know how libtommath works exactly, but generally with every added bit you get twice the range. How come size could possibly be an issue?

[17:50] <mhasch> AlecDaniel: Very easy.  Coefficients of interpolation polynomials, say.

[17:50] <moritz> the assumption is that if you use FatRat, you kinda know what you're doing, and take care of limiting sizes yourself

[17:50] <AlexDaniel> and *even if* memory consumption was an issue, you still need to run things under ulimit if you're worried that they'll eat all your ram

[17:51] <moritz> the problem is that if you add checks, then that slows down every operation, even in scenarios where you don't need them

[17:51] <mhasch> AlexDaniel: Still not right. Ulimit kills my program, I want the operator to give me a result or say "bonk".

[17:52] <AlexDaniel> check your inputs then

[17:52] <timotimo> then you have to put the checks everywhere :\

[17:52] <moritz> no

[17:52] <AlexDaniel> no, only in places where this is relevant

[17:52] <moritz> often when you implement an algorithm, you have a pretty good idea where your numbers grow

[17:53] <moritz> so you can do it much more intelligently than if the setting needs to insert it EVERYWHERE

[17:54] <mhasch> Moritz: Yes, I was thinking along the lines of adding new types with slower but safer operations.

[17:54] <AlexDaniel> now, if you suggested that it should be possible to cancel math operations midway from another thread, then I would at least understand that‚Ä¶ but memory consumption? meh

[17:56] <timotimo> we'll eventually get "throw an exception for another thread", but that won't be able to interrupt internal loops like what tommath would use to implement a lengthy operation

[17:56] <AlexDaniel> yeah, but at least I would understand the concern

[18:00] *** reportable6 left
[18:00] <moritz> mhasch: you could implement that as a module. If it works and has many use cases, we could decide that it goes into the core setting

[18:03] *** reportable6 joined
[18:07] <Kaiepi> has anyone else been running into deadlocks that never used to happen before using at least release 2019.07.1

[18:08] <Kaiepi> i can't post the main example of this i have since it's several thousand lines of code across several modules, but t/02-pod-valid.t in the docs repo also does this

[18:09] <Kaiepi> t/02-pod-valid.t works when i set TEST_THREADS=1 fwiw

[18:09] *** ravenou__ left
[18:12] <mhasch> moritz: Modules are fine, of course. I still would like the attention of language designers, as some consequences of standard behaviour might not be fully understood so far. But ymmv.

[18:14] *** ravenous_ joined
[18:16] <Geth> ¬¶ doc: e8c3cfebf1 | (Ben Davies)++ | doc/Type/Metamodel/EnumHOW.pod6

[18:16] <synopsebot> Link: https://doc.perl6.org/type/Metamodel::EnumHOW

[18:16] <Geth> ¬¶ doc: Make a couple corrections to Metamodel::EnumHOW's type page

[18:16] <Geth> ¬¶ doc: 

[18:16] <Geth> ¬¶ doc: The example code for creating an enum directly using Metamodel::EnumHOW

[18:16] <Geth> ¬¶ doc: wasn't adding the Enumeration role to the new type, and .add_enum_value

[18:16] *** cpan-p6 left
[18:16] <Geth> ¬¶ doc: takes an instance of the enum itself, not a Pair.

[18:16] <Geth> ¬¶ doc: review: https://github.com/perl6/doc/commit/e8c3cfebf1

[18:16] *** cpan-p6 joined
[18:16] *** cpan-p6 left
[18:16] *** cpan-p6 joined
[18:36] *** domidumont left
[18:36] <AlexDaniel> m: say 42

[18:36] <camelia> rakudo-moar ecf2b1e4f: OUTPUT: ¬´42‚ê§¬ª

[18:36] *** evalable6 left
[18:37] *** evalable6 joined
[18:53] <Kaiepi> m: sub foo($p) { say CALLER::MY =:= $p }; foo MY

[18:53] <evalable6> Kaiepi, rakudo-moar 23cfe1c69: OUTPUT: ¬´False‚ê§¬ª

[18:53] <camelia> rakudo-moar ecf2b1e4f: OUTPUT: ¬´False‚ê§¬ª

[18:53] <Kaiepi> m: sub foo($p) { say CALLER::MY =:= $p<> }; foo MY

[18:53] <evalable6> Kaiepi, rakudo-moar 23cfe1c69: OUTPUT: ¬´False‚ê§¬ª

[18:53] <camelia> rakudo-moar ecf2b1e4f: OUTPUT: ¬´False‚ê§¬ª

[18:53] <Kaiepi> m: sub foo($p) { say CALLER::MY === $p }; foo MY

[18:53] <evalable6> Kaiepi, rakudo-moar 23cfe1c69: OUTPUT: ¬´False‚ê§¬ª

[18:53] <camelia> rakudo-moar ecf2b1e4f: OUTPUT: ¬´False‚ê§¬ª

[18:53] <Kaiepi> m: sub foo($p) { say CALLER::MY ~~ $p }; foo MY

[18:53] <evalable6> Kaiepi, rakudo-moar 23cfe1c69: OUTPUT: ¬´False‚ê§¬ª

[18:53] <camelia> rakudo-moar ecf2b1e4f: OUTPUT: ¬´False‚ê§¬ª

[18:53] <Kaiepi> argh

[18:55] <Kaiepi> m: sub foo($p) { say CALLER::MY.WHICH =:= $p.WHICH }; foo MY

[18:55] <evalable6> Kaiepi, rakudo-moar 23cfe1c69: OUTPUT: ¬´False‚ê§¬ª

[18:55] <camelia> rakudo-moar ecf2b1e4f: OUTPUT: ¬´False‚ê§¬ª

[18:55] <Kaiepi> m: sub foo($p) { say CALLER::MY.WHICH; say $p.WHICH }; foo MY

[18:55] <evalable6> Kaiepi, rakudo-moar 23cfe1c69: OUTPUT: ¬´MY|U94739801515896‚ê§MY|U94739801515968‚ê§¬ª

[18:55] <camelia> rakudo-moar ecf2b1e4f: OUTPUT: ¬´MY|U63428736‚ê§MY|U63428808‚ê§¬ª

[18:55] *** ufobat joined
[18:56] <AlexDaniel> uhhhh

[18:56] <AlexDaniel> evalable!! you're doing it wrong!

[18:56] *** evalable6 left
[18:56] <AlexDaniel> I'll turn it off for now

[18:57] <Kaiepi> m: use nqp; sub foo($p) { say nqp::eqaddr(nqp::getattr(CALLER::MY.WHO, PseudoStash, '$!ctx'), nqp::getattr($p.WHO, PseudoStash, '$!ctx')) }; foo MY

[18:57] <camelia> rakudo-moar ecf2b1e4f: OUTPUT: ¬´0‚ê§¬ª

[18:57] <Kaiepi> ...wait a minute

[18:58] <Kaiepi> m: my $foo = 1; sub foo { say CALLER::MY.keys }; foo

[18:58] <camelia> rakudo-moar ecf2b1e4f: OUTPUT: ¬´()‚ê§¬ª

[18:58] <Kaiepi> m: my $foo = 1; sub foo { say CALLERS::MY.keys }; foo

[18:58] <camelia> rakudo-moar ecf2b1e4f: OUTPUT: ¬´()‚ê§¬ª

[18:58] <Kaiepi> m: my $foo = 1; sub foo { say CALLER::.keys }; foo

[18:58] <cpan-p6> New module released to CPAN! Bailador (0.0.19) by 03UFOBAT

[18:58] <camelia> rakudo-moar ecf2b1e4f: OUTPUT: ¬´($=finish $=pod $?PACKAGE $/ &foo GLOBALish EXPORT $¬¢ $! !UNIT_MARKER $foo ::?PACKAGE $_)‚ê§¬ª

[18:58] <Kaiepi> m: my $foo = 1; sub foo { say CALLER::LEXICAL.keys }; foo

[18:58] <camelia> rakudo-moar ecf2b1e4f: OUTPUT: ¬´()‚ê§¬ª

[18:59] *** adu joined
[18:59] <Kaiepi> m: my $foo = 1; sub foo { say CALLER::LEXICAL::.keys }; foo

[18:59] <camelia> rakudo-moar ecf2b1e4f: OUTPUT: ¬´($¬¢ $! $/ $=pod $_ $=finish &foo !UNIT_MARKER GLOBALish $foo EXPORT ::?PACKAGE $?PACKAGE)‚ê§¬ª

[19:00] <Kaiepi> m: my $foo = 1; sub foo { say CALLER::MY::.keys }; foo

[19:00] <camelia> rakudo-moar ecf2b1e4f: OUTPUT: ¬´(!UNIT_MARKER ::?PACKAGE $! $foo $?PACKAGE &foo EXPORT $_ $/ $¬¢ $=finish $=pod GLOBALish)‚ê§¬ª

[19:01] <Kaiepi> m: sub foo($p) { say nqp::eqaddr(nqp::getattr(CALLER::MY.WHO, Map, '$!storage'), nqp::getattr($p.WHO, Map, '$!storage')) }; foo MY

[19:01] <camelia> rakudo-moar ecf2b1e4f: OUTPUT: ¬´5===SORRY!5=== Error while compiling <tmp>‚ê§Could not find nqp::getattr, did you forget 'use nqp;' ?‚ê§at <tmp>:1‚ê§------> 3etattr(CALLER::MY.WHO, Map, '$!storage')7‚èè5, nqp::getattr($p.WHO, Map, '$!storage')‚ê§¬ª

[19:01] <Kaiepi> m: use nqp; sub foo($p) { say nqp::eqaddr(nqp::getattr(CALLER::MY.WHO, Map, '$!storage'), nqp::getattr($p.WHO, Map, '$!storage')) }; foo MY

[19:01] <camelia> rakudo-moar ecf2b1e4f: OUTPUT: ¬´0‚ê§¬ª

[19:01] <Kaiepi> m: sub foo($p) { say CALLER.WHO =:= $p.WHO }; foo MY

[19:01] <camelia> rakudo-moar ecf2b1e4f: OUTPUT: ¬´False‚ê§¬ª

[19:01] <Kaiepi> m: sub foo($p) { say CALLER.WHO ~~ $p.WHO }; foo MY

[19:02] <camelia> rakudo-moar ecf2b1e4f: OUTPUT: ¬´False‚ê§¬ª

[19:05] <Kaiepi> m: sub foo($p) { say CALLER.WHO.VAR }; foo MY

[19:05] <camelia> rakudo-moar ecf2b1e4f: OUTPUT: ¬´PseudoStash.new((!UNIT_MARKER => (!UNIT_MARKER), $! => Nil, $/ => Nil, $=finish => (Mu), $=pod => [], $?PACKAGE => (GLOBAL), $_ => (Any), $¬¢ => Nil, &foo => &foo, ::?PACKAGE => (GLOBAL), EXPORT => (EXPORT), GLOBALish => (GLOBAL)))‚ê§¬ª

[19:05] <Kaiepi> m: sub foo($p) { say CALLER.WHO.VAR =:= $p.WHO.VAR }; foo MY

[19:05] <camelia> rakudo-moar ecf2b1e4f: OUTPUT: ¬´False‚ê§¬ª

[19:07] <Kaiepi> m: sub foo($p) { say nqp::hllizefor(nqp::getattr(CALLER::MY.WHO, Map, '$!storage'), 'perl6') === nqp::hllizefor(nqp::getattr($p.VAR.WHO, Map, '$!storage'), 'perl6') }; foo MY

[19:07] <camelia> rakudo-moar ecf2b1e4f: OUTPUT: ¬´5===SORRY!5=== Error while compiling <tmp>‚ê§Could not find nqp::getattr, did you forget 'use nqp;' ?‚ê§at <tmp>:1‚ê§------> 3etattr(CALLER::MY.WHO, Map, '$!storage')7‚èè5, 'perl6') === nqp::hllizefor(nqp::getat‚ê§¬ª

[19:07] <Kaiepi> m: use nqp; sub foo($p) { say nqp::hllizefor(nqp::getattr(CALLER::MY.WHO, Map, '$!storage'), 'perl6') === nqp::hllizefor(nqp::getattr($p.VAR.WHO, Map, '$!storage'), 'perl6') }; foo MY

[19:07] <camelia> rakudo-moar ecf2b1e4f: OUTPUT: ¬´Type check failed in binding to parameter '<anon>'; expected Any but got BOOTContext (?)‚ê§  in sub foo at <tmp> line 1‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[19:08] <Kaiepi> m: use nqp; sub foo($p) { say nqp::hllizefor(nqp::getattr(CALLER::MY.WHO, Map, '$!storage'), 'perl6') ~~ nqp::hllizefor(nqp::getattr($p.VAR.WHO, Map, '$!storage'), 'perl6') }; foo MY

[19:08] <camelia> rakudo-moar ecf2b1e4f: OUTPUT: ¬´Type check failed in binding to parameter '<anon>'; expected Any but got BOOTContext (?)‚ê§  in sub foo at <tmp> line 1‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[19:09] *** mhasch left
[19:10] <Kaiepi> m: sub foo($p) { say $p.VAR.WHO.Map eqv CALLER::MY.WHO.Map }; foo MY

[19:10] <camelia> rakudo-moar ecf2b1e4f: OUTPUT: ¬´False‚ê§¬ª

[19:10] <Kaiepi> m: sub foo($p) { say $p.VAR.WHO.Map }; foo MY

[19:10] <camelia> rakudo-moar ecf2b1e4f: OUTPUT: ¬´Map.new(())‚ê§¬ª

[19:10] <Kaiepi> m: sub foo($p) { say $p.WHO.Map }; foo MY

[19:10] <camelia> rakudo-moar ecf2b1e4f: OUTPUT: ¬´PseudoStash.new((!UNIT_MARKER => (!UNIT_MARKER), $! => Nil, $/ => Nil, $=finish => (Mu), $=pod => [], $?PACKAGE => (GLOBAL), $_ => (Any), $¬¢ => Nil, &foo => &foo, ::?PACKAGE => (GLOBAL), EXPORT => (EXPORT), GLOBALish => (GLOBAL)))‚ê§¬ª

[19:10] <Kaiepi> m: sub foo($p) { say $p.WHO.Map eqv CALLER::MY.WHO.Map }; foo MY

[19:10] <camelia> rakudo-moar ecf2b1e4f: OUTPUT: ¬´Type check failed in binding to parameter '<anon>'; expected Any but got Mu (Mu)‚ê§  in sub foo at <tmp> line 1‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[19:11] <Kaiepi> m: sub foo(PseudoStash:U $p) { say $p.WHO.Map eqv CALLER::MY.WHO.Map }; foo MY

[19:11] <camelia> rakudo-moar ecf2b1e4f: OUTPUT: ¬´Type check failed in binding to parameter '$p'; expected PseudoStash but got MY (MY)‚ê§  in sub foo at <tmp> line 1‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[19:11] <Kaiepi> m: sub foo(PseudoStash $p) { say $p.WHO.Map eqv CALLER::MY.WHO.Map }; foo MY

[19:11] <camelia> rakudo-moar ecf2b1e4f: OUTPUT: ¬´Type check failed in binding to parameter '$p'; expected PseudoStash but got MY (MY)‚ê§  in sub foo at <tmp> line 1‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[19:12] <Kaiepi> m: sub foo(Map $p) { say $p.WHO.Map eqv CALLER::MY.WHO.Map }; foo MY

[19:12] <camelia> rakudo-moar ecf2b1e4f: OUTPUT: ¬´Type check failed in binding to parameter '$p'; expected Map but got MY (MY)‚ê§  in sub foo at <tmp> line 1‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[19:13] <Kaiepi> m: sub foo(Mu $p) { say $p.WHO.Map eqv CALLER::MY.WHO.Map }; foo MY

[19:13] <camelia> rakudo-moar ecf2b1e4f: OUTPUT: ¬´Type check failed in binding to parameter '<anon>'; expected Any but got Mu (Mu)‚ê§  in sub foo at <tmp> line 1‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[19:13] <Kaiepi> ffs

[19:14] <Kaiepi> m: sub foo(Mu $p) { my Map $my = CALLER::MY.WHO.Map; my Map $other = $p.WHO.Map; say $my eqv $other }; foo MY

[19:14] <camelia> rakudo-moar ecf2b1e4f: OUTPUT: ¬´Type check failed in binding to parameter '<anon>'; expected Any but got Mu (Mu)‚ê§  in sub foo at <tmp> line 1‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[19:15] <Kaiepi> m: sub foo(Mu $p) { my Map $my = CALLER::MY.WHO.Map; my Map $other = $p.Map; say $my eqv $other }; foo MY.WHO

[19:15] <camelia> rakudo-moar ecf2b1e4f: OUTPUT: ¬´Type check failed in binding to parameter '<anon>'; expected Any but got Mu (Mu)‚ê§  in sub foo at <tmp> line 1‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[19:16] <Kaiepi> ok it must be because there's something of type Mu in $!storage of CALLER::MY.WHO.Map or something

[19:16] <Kaiepi> m: sub foo(Mu $p) { my Map $my = CALLER::MY.WHO.Map; my Map $other = $p.WHO.Map; say $my ~~ $other }; foo MY

[19:16] <camelia> rakudo-moar ecf2b1e4f: OUTPUT: ¬´False‚ê§¬ª

[19:16] <Kaiepi> m: sub foo(Mu $p) { my Map $my = CALLER::MY.WHO.Map; my Map $other = $p.WHO.Map; say $other ~~ $my }; foo MY

[19:16] <camelia> rakudo-moar ecf2b1e4f: OUTPUT: ¬´False‚ê§¬ª

[19:18] <AlexDaniel> Kaiepi: I mean‚Ä¶ you can pm camelia :)

[19:19] *** Sgeo left
[19:19] <Kaiepi> lol yeah, that'd probably help

[19:22] *** Sgeo joined
[19:31] *** zakharyas left
[19:40] *** mowcat left
[19:40] *** adu left
[19:44] <Kaiepi> m: use nqp; sub compare-package(Mu $p) { my $other := nqp::getattr($p.WHO, Map, '$!storage'); my $my := nqp::getattr(CALLER::MY.WHO, Map, '$!storage'); my $iter := nqp::iterator($my); my int $elems = nqp::elems($my); while --$elems { my $pair := nqp::shift($iter); return False unless nqp::existskey($other, nqp::iterkey_s($pair)) && nqp::eqaddr(nqp::atkey($other, nqp::iterkey_s($pair)), nqp::iterval($pair)) }; return True; }; say compare-package MY

[19:44] <camelia> rakudo-moar ecf2b1e4f: OUTPUT: ¬´True‚ê§¬ª

[19:44] <Kaiepi> m: use nqp; sub compare-package(Mu $p) { my $other := nqp::getattr($p.WHO, Map, '$!storage'); my $my := nqp::getattr(CALLER::MY.WHO, Map, '$!storage'); my $iter := nqp::iterator($my); my int $elems = nqp::elems($my); while --$elems { my $pair := nqp::shift($iter); return False unless nqp::existskey($other, nqp::iterkey_s($pair)) && nqp::eqaddr(nqp::atkey($other, nqp::iterkey_s($pair)), nqp::iterval($pair)) }; return True; }; say compare-package OUR

[19:44] <camelia> rakudo-moar ecf2b1e4f: OUTPUT: ¬´False‚ê§¬ª

[19:44] <Geth> ¬¶ problem-solving/path-to-raku: c5cb2c97fe | (Elizabeth Mattijsen)++ | solutions/language/PATH-TO-RAKU.md

[19:44] <Geth> ¬¶ problem-solving/path-to-raku: Add mention of $*PERL and Perl class

[19:44] <Geth> ¬¶ problem-solving/path-to-raku: review: https://github.com/perl6/problem-solving/commit/c5cb2c97fe

[19:45] <Kaiepi> this is really ugly, but since i'm already forced to use nqp for what i'm doing...

[19:45] <aearnus[m]> <Kaiepi "this is really ugly, but since i"> what are you even trying to do there Kaiepi ?

[19:46] <aearnus[m]> I've read those snippets like 5 times and all I've gleaned is dark magic haha

[19:47] <Kaiepi> i'm trying to compare MY from another context to CALLER::MY for an update to Type::EnumHOW

[19:47] <aearnus[m]> huh

[19:49] <Kaiepi> it does something hacky where it installs symbols for enums you create with it on composition, but it can only install lexical symbols if MY is passed as the package since it's not a slang and isn't aware of any other lexpads besides the current one

[19:49] <Kaiepi> CALLER::MY, UNIT::MY, etc. won't work

[19:49] <Kaiepi> but it doesn't have a very good way to check what package was actually passed

[19:50] <aearnus[m]> ahh

[19:50] <aearnus[m]> This would mean a lot more if I knew what `::MY` was

[19:50] <Kaiepi> MY is where lexical symbols end up

[19:50] <Kaiepi> stuff you declare with my

[19:51] <aearnus[m]> So I see!

[19:52] <Kaiepi> m: use nqp; say nqp::hllizefor((1,2,3), 'nqp').^name

[19:52] <camelia> rakudo-moar ecf2b1e4f: OUTPUT: ¬´List‚ê§¬ª

[19:52] <Kaiepi> damn

[19:57] *** Sgeo_ joined
[19:59] <kawaii> Hello Perl friends, I hope everyone is well. :)

[19:59] <kawaii> AlexDaniel: my laptop arrives tomorrow so I think it's only fair we burn it in with a Blin run!

[20:00] <kawaii> Put those 6 cores and 12 threads to good use

[20:00] <Kaiepi> what do blin runs do?

[20:00] <lizmat> roast the ecosystem

[20:00] <Kaiepi> ahh

[20:00] <Kaiepi> handy

[20:00] <kawaii> Kaiepi: they test the module ecosystem against two different perl versions

[20:00] <kawaii> i.e. a release vs HEAD

[20:00] <kawaii> to tell us what we broke

[20:01] *** Sgeo left
[20:01] <kawaii> I'm also super excited to see how quickly my new laptop can comple Star

[20:01] <kawaii> compile*

[20:02] *** lichtkind__ left
[20:03] <MasterDuke> kawaii: what cpu?

[20:04] <kawaii> MasterDuke: 4.5 GHz i7-9750H

[20:04] <kawaii> 6 cores, 12 threads and a 12 MB cache

[20:04] <MasterDuke> nice. i'm curious what parse time is for rakudo on it

[20:05] <Kaiepi> i'm still pissed the usable cores on my laptop's cpu got cut in half because of spectre/meltdown

[20:05] <aearnus[m]> ooh, that's a sweet cpu. got an SSD?

[20:05] <Kaiepi> used to be able to use 8, now can only use 4

[20:07] <kawaii> aearnus[m]: 512 GB NVMe :)

[20:07] <aearnus[m]> Nice!!

[20:07] <kawaii> Going to compile perl at hyperspeeds

[20:07] <aearnus[m]> Kaiepi: https://twitter.com/whitequark/status/1162295541947981825?s=19

[20:08] <Kaiepi> lmao

[20:10] *** jcallen joined
[20:10] <Kaiepi> m: use nqp; say nqp::ctxlexpad(nqp::getattr(MY.WHO, PseudoStash, '$!ctx')).^name

[20:10] <camelia> rakudo-moar ecf2b1e4f: OUTPUT: ¬´BOOTContext‚ê§¬ª

[20:10] <Kaiepi> oh

[20:10] <Kaiepi> i never needed to compare packages at all, i can just do that

[20:13] <Kaiepi> m: use nqp; sub commit-a-sin { $*W.install_lexical_symbol: nqp::ctxlexpad(nqp::getattr(CALLER::MY.WHO, PseudoStash, '$!ctx')), 'ayy', 'lmao' }; sub bar { BEGIN foo; say ayy }; bar

[20:13] <camelia> rakudo-moar ecf2b1e4f: OUTPUT: ¬´5===SORRY!5=== Error while compiling <tmp>‚ê§Undeclared routine:‚ê§    foo used at line 1‚ê§‚ê§¬ª

[20:13] <Kaiepi> m: use nqp; sub commit-a-sin { $*W.install_lexical_symbol: nqp::ctxlexpad(nqp::getattr(CALLER::MY.WHO, PseudoStash, '$!ctx')), 'ayy', 'lmao' }; sub ayy-lmao { BEGIN commit-a-sin; say ayy }; ayy-lmao

[20:13] <camelia> rakudo-moar ecf2b1e4f: OUTPUT: ¬´BEGIN TIME EXCEPTION IS AT <tmp> at 1‚ê§EXCEPTION: Cannot find method 'symbol' on 'BOOTContext': no method cache and no .^find_method‚ê§5===SORRY!5=== Error while compiling <tmp>‚ê§An exception occurred while evaluating a BEGIN‚ê§at <tmp>:1‚ê§Exce‚Ä¶¬ª

[20:14] <Kaiepi> damn it wants the QAST for the lexpad

[20:15] *** ufobat left
[20:16] <aearnus[m]> `sub commit-a-sin` ahahaha

[20:17] <Kaiepi> this is by far the nastiest perl i've ever had to write

[20:20] *** woolfy joined
[20:20] *** woolfy left
[20:21] *** woolfy joined
[20:21] <SmokeMachine> Im trying to write a blog schema to use as a Red example... could someone take a look and comment how could it be better, please? https://github.com/FCO/BlogSchema

[20:22] <aearnus[m]> not a comment on code quality or anything, just piping in to say that Red is really pretty

[20:23] <SmokeMachine> aearnus[m]: thanks! :)

[20:23] <aearnus[m]> what kind of magic do you have to do to get Rakudo to recognize `model` as a keyword? like in `unit module ...`

[20:26] <SmokeMachine> aearnus[m]: it's just this: https://github.com/FCO/Red/blob/master/lib/Red.pm6#L34

[20:27] *** huf left
[20:28] *** woolfy left
[20:28] <aearnus[m]> Just makes me realize how I really need to learn how the HOW works

[20:28] <kawaii> Oh Red is first on the list of modules for me to try when I get my laptop and environment set up again but it looks scary and amazing at the same time :(

[20:29] <kawaii> I have an old app using DBIish, maybe I'll try and convert it to Red as my first project

[20:29] *** woolfy joined
[20:33] <SmokeMachine> kawaii: why is it scary?

[20:35] <kawaii> looks complicated :(

[20:35] <kawaii> but I'll try figure it out!

[20:35] <SmokeMachine> kawaii: really? It should be simple... :(

[20:35] <aearnus[m]> The documentation just looked spotty that's what's stopped me

[20:36] <kawaii> I'm not as smart as people think I am, it's probably a lot easier than I anticipate!

[20:36] <SmokeMachine> aearnus[m]: yes, the documentation is terrible... (as my english...)

[20:36] <SmokeMachine> aearnus[m]: I really need some help to write the documentation...

[20:37] <SmokeMachine> kawaii: have you took a look on this blog example?

[20:37] <kawaii> Yes! I somewhat understand it :)

[20:37] <aearnus[m]> SmokeMachine:  your English is really good though, I would have never noticed

[20:37] <aearnus[m]> And I'd be happy to contribute some documentation when I get around to trying it

[20:38] <SmokeMachine> aearnus[m]: thank you! I'm looking forward your help! :)

[20:39] <SmokeMachine> kawaii: great!

[20:40] *** Kaiepi left
[20:40] <MasterDuke> SmokeMachine: going to the london perl workshop?

[20:40] <SmokeMachine> MasterDuke: yesÀú

[20:40] <MasterDuke> cool

[20:41] <SmokeMachine> MasterDuke: are you?

[20:41] <MasterDuke> yep

[20:42] <SmokeMachine> \o/

[20:42] <El_Che> it's before 31th october 

[20:42] <El_Che> so no need to take guns and antibiotics and a mad max outfit it seems

[20:43] <SmokeMachine> MasterDuke: I was thinking of sending a talk propose... but I think I'll do a lightning one...

[20:43] <MasterDuke> no *need*...but if you could why wouldn't you?

[20:43] <MasterDuke> i would like to see a Red talk

[20:43] <SmokeMachine> the last english one wasn't very good...

[20:44] <SmokeMachine> MasterDuke: I have to find out to talk about Red without showing so many code... 

[20:44] <MasterDuke> heh

[20:45] <SmokeMachine> MasterDuke: have you seen the last one?

[20:45] <MasterDuke> no. is it available somewhere?

[20:46] <SmokeMachine> MasterDuke: yes, it is... I'm searching...

[20:47] <SmokeMachine> MasterDuke: https://www.youtube.com/watch?time_continue=17&v=aiGz_9dvPeA

[20:47] *** Kaiepi joined
[20:47] <aearnus[m]> When's the next Perl meetup in the US?

[20:47] *** ravenous_ left
[20:47] <kawaii> I'll be at LPW too

[20:48] <aearnus[m]> (or, perl6 specifically)

[20:48] <SmokeMachine> kawaii: \o/

[20:48] *** Kaypie joined
[20:50] <MasterDuke> SmokeMachine: cool, i'll give it a watch

[20:51] <SmokeMachine> MasterDuke: please, forgive my english...

[20:55] <SmokeMachine> After the talk I realised the way I wrote `Red ORM` on my slides looks something different...

[21:00] <SmokeMachine> any comment about the blog schema?

[21:02] <aearnus[m]> As someone who doesn't know anything about Red, I found it really readable

[21:03] <aearnus[m]> I like how in the `model` you can do things like `is column .= now` to set it in one line automatically

[21:05] <SmokeMachine> :)

[21:10] *** sena_kun joined
[21:10] *** pamplemousse left
[21:11] *** stux|RC-only joined
[21:12] *** sena_kun left
[21:17] <Kaiepi> i think i'll need to make a slang for my Type::EnumHOW module and make it a v1.0.0 release

[21:17] *** nepugia left
[21:18] <Kaiepi> for a module that just makes it easier to make custom enums it has way too much hacky code that really belongs in the grammar

[21:23] <MasterDuke> SmokeMachine: are everything in a map/grep on a result sequence converted into sql?

[21:23] <SmokeMachine> Yes... everything it knows how to translate...

[21:25] <SmokeMachine> MasterDuke: for example:

[21:25] <SmokeMachine> MasterDuke:  https://www.irccloud.com/pastebin/HvqUZ7K8/

[21:26] *** huf joined
[21:26] <SmokeMachine> MasterDuke: that SQL was generated by this: https://github.com/FCO/BlogSchema/blob/master/blog.p6#L92

[21:26] <MasterDuke> what about stuff it doesn't know how to translate?

[21:27] *** netrino left
[21:27] <SmokeMachine> it should run the query it knows and than map/grep it... but it's not doing that yet...

[21:29] <SmokeMachine> MasterDuke: other thing is: you should never add side-effects on your map/grep... and that should be pure...

[21:47] <SmokeMachine> MasterDuke: what do you think about it?

[22:03] *** fake_space_whale left
[22:09] <MasterDuke>  SmokeMachine: i find it intriguing. i actually really like writing sql, but i also like writing perl 6...

[22:11] <kawaii> I like writing SQL too, or well, designing database schemas

[22:11] <Geth> ¬¶ whateverable: 23c2ebbe23 | (Aleks-Daniel Jakimenko-Aleksejev)++ | xbin/Coverable.p6

[22:11] <Geth> ¬¶ whateverable: Move misplaced `is copy` (oops)

[22:11] <Geth> ¬¶ whateverable: review: https://github.com/perl6/whateverable/commit/23c2ebbe23

[22:13] *** epony left
[22:14] *** nadim_ left
[22:17] <SmokeMachine> I like SQL... but not have to think in SQL and use simple perl Seqs is better, IMO...

[22:19] *** coverable6 left
[22:22] *** coverable6 joined
[22:23] *** Cabanossi left
[22:28] *** Sgeo joined
[22:29] *** Sgeo_ left
[22:36] *** Sgeo_ joined
[22:37] *** rindolf left
[22:37] *** Cabanossi joined
[22:39] *** epony joined
[22:39] *** Sgeo left
[22:48] *** coverable6 left
[22:55] *** coverable6 joined
[22:55] *** ChanServ sets mode: +v coverable6

[22:57] *** coverable6 left
[22:59] *** coverable6 joined
[23:00] *** coverable6 left
[23:03] *** leont left
[23:06] *** coverable6 joined
[23:08] *** coverable6 left
[23:12] *** coverable6 joined
[23:12] *** ChanServ sets mode: +v coverable6

[23:12] *** coverable6 left
[23:12] *** [particle] joined
[23:12] *** [particle]1 left
[23:13] *** coverable6 joined
[23:13] *** ChanServ sets mode: +v coverable6

[23:15] <Geth> ¬¶ whateverable: 31472879aa | (Aleks-Daniel Jakimenko-Aleksejev)++ | services/whateverable@.service

[23:15] <Geth> ¬¶ whateverable: Start bots using a local path

[23:15] <Geth> ¬¶ whateverable: 

[23:15] <Geth> ¬¶ whateverable: This should ‚Äúfix‚Äù gisted error messages.

[23:15] <Geth> ¬¶ whateverable: review: https://github.com/perl6/whateverable/commit/31472879aa

[23:15] *** coverable6 left
[23:17] *** coverable6 joined
[23:17] *** ChanServ sets mode: +v coverable6

[23:19] *** [particle] left
[23:19] *** [particle]1 joined
[23:26] <Geth> ¬¶ whateverable: 4d8d9e7924 | (Aleks-Daniel Jakimenko-Aleksejev)++ | xbin/Coverable.p6

[23:26] <Geth> ¬¶ whateverable: Fix coverable gists by removing bitrot

[23:26] <Geth> ¬¶ whateverable: 

[23:26] <Geth> ¬¶ whateverable: As suggested by the comments.

[23:26] <Geth> ¬¶ whateverable: review: https://github.com/perl6/whateverable/commit/4d8d9e7924

[23:27] <Geth> ¬¶ whateverable: 0900ceaf8d | (Aleks-Daniel Jakimenko-Aleksejev)++ | xbin/Coverable.p6

[23:27] <Geth> ¬¶ whateverable: Remove accidental characters (oops)

[23:27] <Geth> ¬¶ whateverable: review: https://github.com/perl6/whateverable/commit/0900ceaf8d

[23:27] *** coverable6 left
[23:28] *** coverable6 joined
[23:44] *** [particle] joined
[23:45] *** vike left
[23:46] *** [particle]1 left
