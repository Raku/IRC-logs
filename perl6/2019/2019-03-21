[00:00] *** cpan-p6 joined
[00:08] *** theangryepicbana joined
[00:12] *** theangryepicbana left
[00:18] *** cpan-p6 left
[00:19] *** Ven`````` left
[00:22] *** rindolf left
[00:22] *** cpan-p6 joined
[00:27] *** cusion left
[00:28] *** zachk left
[00:38] *** sftp left
[00:38] *** sftp joined
[00:39] *** cjkinni joined
[00:41] *** cpan-p6 left
[00:43] *** cpan-p6 joined
[00:48] *** MasterDuke joined
[00:49] *** w_richard_w joined
[00:49] *** MasterDuke left
[00:49] *** MasterDuke joined
[01:06] *** dr_df0 left
[01:06] *** cpan-p6 left
[01:08] *** cpan-p6 joined
[01:22] *** cpan-p6 left
[01:22] *** cpan-p6 joined
[01:24] *** zacts joined
[01:25] *** leont left
[01:28] *** zakharyas joined
[01:36] *** cpan-p6 left
[01:36] *** cpan-p6 joined
[01:54] *** cpan-p6 left
[01:54] *** cpan-p6 joined
[02:08] *** cpan-p6 left
[02:10] <ugexe> zef install . --deps-only --to=inst#local --/test --debug --contained # install *all* depends into local/

[02:10] <ugexe> zef list --installed inst#local # list exact versions of all depends for current app

[02:10] <ugexe> perl6 -I inst#local -e '...' # use self contained local lib to run app

[02:11] <ugexe> so i was thinking about how to do e.g. cpanfile.snapshot type functionality in zef. its mostly there

[02:11] <ugexe> just need to add a way to read the output of the file generated from `zef list --installed inst#local`

[02:12] <ugexe> maybe add an option for an argument of `-` that means read stdin line-by-line (reading a list of modules)

[02:20] <lucs> How can I do something like: use Inline::Perl5; use lib ｢path to Perl5 Foo module｣; use Foo:from<Perl5>  # That 'use lib …' doesn't reach Perl5, eh.

[02:20] <lucs> ( use lib:from<Perl5>… something? )

[02:20] <ugexe> yes use lib:from<Perl5> 'something'

[02:20] <lucs> Oh, that simple eh :) Trying...

[02:22] <lucs> I think it's working (but getting some other kind of error, my mistakes probably).

[02:23] *** GaborSzabo joined
[02:23] <GaborSzabo> H

[02:23] <lucs> H to you too ;)

[02:24] <discord6> <Rogue> I agree. H.

[02:24] <GaborSzabo> Im f

[02:24] <GaborSzabo> And a

[02:25] <GaborSzabo> U guys pro?

[02:25] *** zacts left
[02:25] <lucs> GaborSzabo: Um, you're a bit hard to follow...

[02:34] *** cpan-p6 joined
[02:36] *** GaborSzabo left
[02:40] *** zacts joined
[02:49] *** cpan-p6 left
[02:50] *** cpan-p6 joined
[03:01] *** Sgeo_ joined
[03:04] *** Sgeo left
[03:06] *** cpan-p6 left
[03:06] *** cpan-p6 joined
[03:19] *** cpan-p6 left
[03:19] *** cpan-p6 joined
[03:23] *** zacts left
[03:37] *** cpan-p6 left
[03:42] *** zacts joined
[03:43] *** squashable6 left
[03:45] *** squashable6 joined
[03:45] *** ChanServ sets mode: +v squashable6

[03:50] *** abe_ joined
[04:00] *** abe_ left
[04:13] *** sauvin joined
[04:20] *** MidCheck left
[04:54] *** reach_satori left
[05:00] *** cpan-p6 joined
[05:03] *** Sgeo joined
[05:05] *** Sgeo_ left
[05:13] *** discord61 joined
[05:14] *** cpan-p6 left
[05:14] *** discord6 left
[05:14] *** discord61 is now known as discord6

[05:14] *** cpan-p6 joined
[05:20] *** discord62 joined
[05:20] *** cpan-p6 left
[05:21] *** discord6 left
[05:21] *** cpan-p6 joined
[05:21] *** discord62 is now known as discord6

[05:27] *** cpan-p6 left
[05:29] *** Actualeyes joined
[05:31] *** cpan-p6 joined
[05:48] *** cpan-p6 left
[05:49] *** curan joined
[06:07] *** cpan-p6 joined
[06:09] *** jmerelo joined
[06:16] *** robertle left
[06:21] *** cpan-p6 left
[06:21] *** molaf joined
[06:21] *** cpan-p6 joined
[06:23] <xinming> m: class T is Hash { has $.abc is required; submethod (:$!abc) { } }; my %x is T = (:a<b>, :c<d>); %x.perl.say; %x.abc.perl.say;

[06:23] <camelia> rakudo-moar 68c2c9fea: OUTPUT: «{:a("b"), :c("d")}␤Any␤»

[06:23] <xinming> In this case, the abc is *required*, But doesn't fail, Is this correct behaivor?

[06:23] <xinming> And also, How do we init the $!abc in this case?

[06:25] <xinming> m: role T { has $.xxx is required; }; my %x = (:a<b>, :c<d>) does T(123); %x.xxx.perl.say;

[06:25] <camelia> rakudo-moar 68c2c9fea: OUTPUT: «No such method 'xxx' for invocant of type 'Hash'␤  in block <unit> at <tmp> line 1␤␤»

[06:25] *** w_richard_w left
[06:26] <xinming> And for the later one, Where I did wrong?

[06:27] <xinming> m: role T { has $.xxx is required; }; my %x = (:a<b>, :c<d>);  %x does T(123) ; %x.xxx.perl.say;

[06:27] <camelia> rakudo-moar 68c2c9fea: OUTPUT: «123␤»

[06:27] <xinming> m: role T { has $.xxx is required; }; (my %x = (:a<b>, :c<d>)) does T(123) ; %x.xxx.perl.say;

[06:27] <camelia> rakudo-moar 68c2c9fea: OUTPUT: «123␤»

[06:27] <xinming> So, later one get fixed. :-)

[06:28] *** domidumont joined
[06:44] <Geth> ¦ doc: ab74b86a9f | (JJ Merelo)++ | doc/Type/Code.pod6

[06:44] <Geth> ¦ doc: Corrections and prefixed method, refs #2683

[06:44] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/ab74b86a9f

[06:44] <Geth> ¦ doc: 62c7f85638 | (JJ Merelo)++ | doc/Type/Slip.pod6

[06:44] <Geth> ¦ doc: Revised Slip

[06:44] <Geth> ¦ doc: 

[06:44] <Geth> ¦ doc: Adds definitions, reflows. Actually, no need to prefix anything with

[06:44] <Geth> ¦ doc: sub, so this closes #2683

[06:44] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/62c7f85638

[06:58] *** domidumont left
[07:02] <Geth> ¦ doc: 33dafa9600 | (JJ Merelo)++ | doc/Language/traps.pod6

[07:02] <Geth> ¦ doc: Reflows while revising for #1265

[07:02] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/33dafa9600

[07:03] <jmerelo> xinming: above, submethod should have a name, right?

[07:03] <jmerelo> xinming: you're probably past that, but anyway. Surprised it didn't complain.

[07:08] *** zakharyas left
[07:10] *** daemon is now known as cortana

[07:10] *** cortana is now known as daemon

[07:11] *** daemon is now known as cortana

[07:19] *** jmerelo left
[07:28] *** pistacchio left
[07:28] *** pistacchio joined
[07:32] *** w_richard_w joined
[07:38] *** domidumont joined
[07:40] *** guifa left
[07:41] <xinming> m: sub test () { return %(:a, :b) }; sub wrap-test { my $res = test; $res; }; my %t = test; %t.perl.say; my %x = wrap-test; %x.perl.say;

[07:41] <camelia> rakudo-moar 68c2c9fea: OUTPUT: «{:a, :b}␤{:a, :b}␤»

[07:41] <xinming> Anyone here would clarify why will $res auto unbox to %hash successfully? What is the reasoning behind it?

[07:42] *** domidumont left
[07:43] *** domidumont joined
[07:43] *** domidumont left
[07:44] <lookatme_q> m: my %x = ${:A, :C}; say %x

[07:44] <camelia> rakudo-moar 68c2c9fea: OUTPUT: «{A => True, C => True}␤»

[07:44] <lookatme_q> m: my %x = ${:A, :C}; dd %x

[07:44] <camelia> rakudo-moar 68c2c9fea: OUTPUT: «Hash %x = {:A, :C}␤»

[07:44] <moritz> xinming: https://docs.perl6.org/syntax/Single%20Argument%20Rule

[07:44] <xinming> moritz: Thanks

[07:45] *** domidumont joined
[08:05] *** ravenousmoose left
[08:06] *** ravenousmoose joined
[08:06] *** rindolf joined
[08:08] *** zakharyas joined
[08:23] *** patrickb joined
[08:29] *** molaf left
[08:58] <lizmat> hmmm  looks like docs.perl6.org is stuck at  88383891  ?

[09:01] *** dakkar joined
[09:03] <masak> that's a suspiciously decimal hex prefix.

[09:05] *** Actualeyes left
[09:05] <masak> m: my $prob = (10/16) ** 8; say "Things like that happen with a probability of {($prob * 100).fmt("%.1f")}%"

[09:05] <camelia> rakudo-moar 68c2c9fea: OUTPUT: «Things like that happen with a probability of 2.3%␤»

[09:06] *** w_richard_w left
[09:06] <masak> m: my $prob = (10/16) ** 8; say "There's a one in {ceiling 1 / $prob} chance of it happening"

[09:07] <camelia> rakudo-moar 68c2c9fea: OUTPUT: «There's a one in 43 chance of it happening␤»

[09:08] <lizmat> masak: with the number of commits we're doing on doc, that will happen like once every few weeks ?

[09:13] <masak> if you know the approximate rate of commits, a Poisson distribution will tell you how often

[09:15] <masak> m: my $prob = (10/16) ** 8; my $n = 100; say "Among {$n} commits, there's a {((1 - (1 - $prob) ** $n) * 100).fmt("%.2f")}% chance of at least one decimal prefix"

[09:15] <camelia> rakudo-moar 68c2c9fea: OUTPUT: «Among 100 commits, there's a 90.52% chance of at least one decimal prefix␤»

[09:16] <masak> so, yeah. not rare :)

[09:16] *** zakharyas left
[09:17] *** pmurias joined
[09:17] <masak> I'm trying to come to grips with what the spec means by 'listop' exactly

[09:18] <pmurias> ugexe: re nqp::cpucores pull request is nqp::cpucores supposed to return the number of CPUs in the machine or the ones that the process can make use of?

[09:19] <lizmat> pmurias: that the process can make use of, I'd say...  it's intended to be used as a way to determine how many workers to allow

[09:19] <masak> is this a correct understanding, you think? "an operator from the 'List prefix' category, which, because it's looser than commas, tends to consume the rest of the expression up until the next surrounding terminator"

[09:19] <lizmat> and that wouldn't make any sense if thee CPU's are there and not usable  :-)

[09:22] <pmurias> hmm, v8 has worker threads (which don't share memory)

[09:23] <pmurias> but is single threaded in terms of Perl 6 threads

[09:24] <lizmat> hmmm... not sure how to handle that then

[09:25] *** molaf joined
[09:57] <SmokeMachine> m: sub infix:<< £ >>(Int $a; Int $b; Int $c) is assoc<list> { "$b is between $a, $c" }; say 1 £ 2 £ 3

[09:57] <camelia> rakudo-moar 9399ea119: OUTPUT: «2 is between 1, 3␤»

[09:57] <SmokeMachine> m: sub infix:<< < >>(Int $a; Int $b; Int $c) is assoc<list> { "$b is between $a, $c" }; say 1 < 2 < 3

[09:57] <camelia> rakudo-moar 9399ea119: OUTPUT: «Too few positionals passed; expected 3 arguments but got 2␤  in sub infix:«<» at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[09:58] <SmokeMachine> why it doesn't work with <?

[10:01] *** robertle joined
[10:05] <moritz> SmokeMachine: I don't think you can change the associativity of an existing operator

[10:06] <SmokeMachine> moritz: shouldn't it be possible?

[10:07] <jnthn> Well, the other thing is that all the chaining operators receive special compilation anyway

[10:07] <yoleaux> 20 Mar 2019 20:22Z <DrForr> jnthn: No worries at all, it's by no means crucial and I might even be able to provide you a patch when I've got some spare tuits myself.

[10:07] *** dr_df0 joined
[10:07] <jnthn> They're not compiled into simple sub calls, because they need to ensure they only compile each operand once

[10:08] <SmokeMachine> jnthn: same problem as && and || right?

[10:08] <jnthn> SmokeMachine: Well, "problem", but yeah, those also cannot be straight sub calls and receive special compilation as a result

[10:09] <jnthn> (Becuase we shouldn't evaluate the RHS always)

[10:09] <SmokeMachine> I'd love if it would be possible to override &&, ||, >, <, >=, <= to use it on Red...

[10:10] <SmokeMachine> https://github.com/FCO/Red/issues?q=is%3Aissue+is%3Aopen+label%3A%22more+complex+than+it+looks%22

[10:15] <SmokeMachine> jnthn: isn't it an issue? I mean, should this be "fixed"?

[10:15] *** MidCheck joined
[10:16] *** Black_Ribbon left
[10:21] *** dr_df0 left
[10:21] <jnthn> SmokeMachine: Which one?

[10:22] <SmokeMachine> jnthn: &&, ||, >, >=, < and <=

[10:22] <SmokeMachine> jnthn: all of them

[10:23] <jnthn> Well, question is how would be fix it?

[10:24] <jnthn> *we

[10:25] <SmokeMachine> jnthn:  is it possible to change the behaviour only if the operator was overwritten?

[10:26] <SmokeMachine> jnthn: maybe set a $*AND_WAS_OVERWITTEN = True

[10:26] <jnthn> SmokeMachine: But even then, what would be be compiling it in to?

[10:27] <jnthn> && and || don't compile into a sub call

[10:27] <SmokeMachine> couldn't it be compiled to a subcall receiving 2 blocks?

[10:28] <jnthn> In theory, yes

[10:28] <jnthn> Though perhaps this is more of a job for macros

[10:31] <SmokeMachine> m: use experimental :macros; macro infix:<&&>($a, $b) { quasi { say "OK" } }; say 1 && 2

[10:31] <camelia> rakudo-moar 9399ea119: OUTPUT: «WARNINGS for <tmp>:␤OK␤True␤Useless use of constant integer 2 in sink context (line 1)␤Useless use of constant integer 1 in sink context (line 1)␤»

[10:31] <SmokeMachine> jnthn: maybe something like this could work?

[10:32] *** cortana is now known as daemon

[10:33] <SmokeMachine> jnthn: but how could I test if any of its arguments is a Red::AST?

[10:33] <SmokeMachine> $a and $b are AST... (not Red::AST...)

[10:33] <jnthn> It's compile time so you don't know?

[10:34] <SmokeMachine> jnthn: back to the same problem?

[10:35] *** Ven`` joined
[10:35] <SmokeMachine> jnthn: AST has an annotation field, hasn't it?

[10:39] <jnthn> SmokeMachine: Well, hash, which putting arbitrary annotations on it, yes

[10:40] <SmokeMachine> jnthn: would it be possible to annotate my AST... never mind...

[10:43] <jnthn> SmokeMachine: Dunno...maybe if you can always tell at compile time that's what it is, though you're certainly in slang territory (and using non-specified API that could change) by this point.

[10:43] <SmokeMachine> jnthn: maybe I should run the left part and see he type of what it returns... and decided based on that...

[10:44] <SmokeMachine> but my && would only work if starting with a Red::AST...

[10:45] <jnthn> Yeah, that's why I was curious what you were going to do with it :)

[10:49] <SmokeMachine> jnthn: if the first part isn't a Red::AST, but is true, I run the second one if it returns a Red::AST I create my return, else I just return it...

[10:50] <SmokeMachine> Im luck cause if the first part is false, my version of && should return False anyway... :)

[10:56] <masak> nit pick: `&&` et al are not "chaining", they're "list-associative"

[10:57] <masak> I only recently learned of this distinction

[10:57] <masak> "chaining" is for the comparison ops, that tend to result in a truthiness value

[10:57] <masak> "list associative" is for infix ops that conceptually take N operands, not 2

[10:57] <SmokeMachine> masak: like <, >, <=, >=, == right?

[10:57] <masak> N ~~ 0..*

[10:58] <masak> those are the chaining ones, yes

[10:58] <SmokeMachine> yes...

[10:58] <masak> SmokeMachine: if your question is "how to override", I think you'll have to wait until we have macros for that

[10:58] <masak> in current Rakudo, they're just "special-cased"

[10:58] <masak> from the point of 007, they're macros

[10:59] *** k-man left
[11:00] <SmokeMachine> masak: but when we can overwride (or in 007), how do we know if we should use the override on or the core one?

[11:01] <masak> that is all resolved with normal lexical lookup

[11:01] <masak> the override is used whenever its definition is still visible

[11:02] <SmokeMachine> masak: I mean: if its operands are Red::AST I'd like to use my &&, and the core's one other wise...

[11:03] <masak> m: use experimental :macros; macro infix:<und>($l, $r) { quasi { if my $t = {{{$l}}} { $t = {{{$r}}} }; $t } }; say(5 und 7)

[11:03] <camelia> rakudo-moar 9399ea119: OUTPUT: «WARNINGS for <tmp>:␤Useless use of constant integer 7 in sink context (line 1)␤Useless use of constant integer 5 in sink context (line 1)␤Cannot assign to an immutable value␤  in any  at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[11:03] <masak> (not really sure why I get those warnings)

[11:03] <masak> (or that error)

[11:03] <masak> SmokeMachine: I think you'd like a thing that I wrote recently-ish

[11:03] <masak> hold on, gonna dig it up

[11:04] *** k-man joined
[11:04] <masak> SmokeMachine: https://github.com/masak/007/issues/294#issuecomment-392330477

[11:05] *** leont joined
[11:06] <masak> speaking of "list associative" ops, it's quite funny, I realized. infix:<&&> and infix:<||> don't actually _need_ to be list-associative, because they'd work the same (as macros) even if they were left-associative

[11:06] <masak> but the operator that really, _really_ needs to be list-associative is infix:<^^> :D

[11:06] <masak> see https://github.com/masak/007/issues/464 for details

[11:14] *** antoniogamiz joined
[11:14] <antoniogamiz> o/

[11:15] *** sena_kun joined
[11:29] <masak> \o

[11:32] <kawaii> I have a module I'm working on which asks an API for some values, and then I'd like to be able to pull those values out and display them nicely for clarity. `say $result<attributeScores><{@models}>.map: *<summaryScore><value>;` I was hoping this would iterate over anything in my @models array but I just get an `((Any))` back in return, ideas?

[11:32] <kawaii> `my MODEL @models = TOXICITY, SPAM;`, this is what my array looks like

[11:33] <jnthn> I bet <{@models}> should just be {@models}

[11:33] <jnthn> Otherwise you're looking up a literal string key '<{@modules}>'

[11:33] <jnthn> *models

[11:34] <kawaii> jnthn: `(0.017453287 0.4579174)` you're right!

[11:34] <kawaii> is there a way I can prefix each value with the name of the model in the array?

[11:35] <jnthn> say @models Z~ ...

[11:36] <jnthn> Though you maybe want it formatted nicely too :)

[11:37] <jnthn> I guess you can :p after {@models} and you'll get Pairs out where .key is the thing for @models and the .value is what you are getting now

[11:38] <masak> SmokeMachine: anyway, with current Rakudo, I'm afraid infix:<&&> are too special-cased to override. :( from my macro-infused perspective, that's because we haven't defined them in core as (overridable) macros.

[11:39] <SmokeMachine> masak: what about it?

[11:39] <SmokeMachine> m: use experimental :macros; macro infix:<&&>($a, $b) { quasi { say "OK" } }; say 1 && 2

[11:39] <camelia> rakudo-moar 9399ea119: OUTPUT: «WARNINGS for <tmp>:␤OK␤True␤Useless use of constant integer 1 in sink context (line 1)␤Useless use of constant integer 2 in sink context (line 1)␤»

[11:39] <SmokeMachine> it was overrides, no?

[11:39] <masak> hm, so it seems

[11:39] <kawaii> jnthn: worked nicely, thanks :)

[11:39] <masak> then that's slightly better news than I thought :)

[11:40] <pmurias> in regards to using Perl 6 to generate queries from isn't that something that should be done more with code inspection rather then overriding operators

[11:40] <pmurias> ?

[11:40] <SmokeMachine> masak: I was thinking to use something like that...

[11:42] <antoniogamiz> what module would you use for scraping with perl6?

[11:42] *** leont left
[11:43] *** [particle] joined
[11:43] <kawaii> antoniogamiz: scraping HTML or?

[11:43] <pmurias> as it seems like we really want to just compile a subset of Perl 6 to a SQL/some query structure

[11:43] *** [particle]1 left
[11:44] <antoniogamiz> kawaii: yep html 

[11:45] <kawaii> I'd probably use Cro::HTTP::Client for something like that

[11:45] <SmokeMachine> masak: now Im trying something like this (but its not working...)

[11:45] <SmokeMachine> m: use experimental :macros; macro infix:<&&>($a, $b) { quasi { $a ~~ Int ?? "MyOwnObject" !! (so $a ?? ($b ~~ Int ?? "MyOwnObject" !! $b) !! False) } }; say 1 && 2

[11:45] <camelia> rakudo-moar 9399ea119: OUTPUT: «WARNINGS for <tmp>:␤True␤Useless use of constant integer 2 in sink context (line 1)␤Useless use of constant integer 1 in sink context (line 1)␤»

[11:45] <antoniogamiz> I've been looking Gumbo and LWP::Simple

[11:46] <antoniogamiz> I'll take a look at Cro::HTTP

[11:46] <antoniogamiz> ::Client*

[11:47] <SmokeMachine> masak: something that would be converted to something like this:

[11:47] <SmokeMachine> m: my $a = 1; my $b = 2; say $a ~~ Int ?? "MyOwnObject" !! (so $a ?? ($b ~~ Int ?? "MyOwnObject" !! $b) !! False)

[11:47] <camelia> rakudo-moar 9399ea119: OUTPUT: «MyOwnObject␤»

[11:47] <sena_kun> antoniogamiz, you _may_ look at `deredere` module which uses Gumbo for parsing and HTTP::UserAgent. Though keep in mind that it is super-basic and for any non-trivial case you have to either extend it or rewrite things, maybe stealing some approach.

[11:48] *** kensanata joined
[11:49] <antoniogamiz> sena_kun: I will use for something a bit complex so I'm going to choose cro instead, but thanks for the info :)

[11:51] <sena_kun> antoniogamiz, we always can upgrade this module to use Cro. ;) But sure, use whatever is more suitable for the job.

[11:58] <antoniogamiz> tbrowder: I've reading the discussion about #2529

[11:58] <kawaii> jnthn: Z=> turned out to be a better operator for clarity by the way :)

[11:58] <antoniogamiz> tbrowder: and I've though that maybe the minidocs should be "dockerized" (I dont know if that work exists)

[11:59] <antoniogamiz> tbrowder: what do you think?

[12:00] *** guifa joined
[12:01] <sena_kun> antoniogamiz, there is a minimal Docker container with Perl 6 installation, manual repo clone && some building may be needed though.

[12:04] <tbrowder> antoniogamiz: i don't know much about docker, but let me look at that issue...

[12:04] <antoniogamiz> sena_kun:  yeah I know, but that dockerfile is used for the entire doc 

[12:06] <antoniogamiz> sena_kun: the issue I've sent (#2529) says that a minidoc repository would be helpful

[12:06] <antoniogamiz> in order to test of the tooling with a self-contained subset of the current doc

[12:09] <tbrowder> antoniogamiz: that looks like a good one to me. i see my comment there. i would start filling out more details to address that after checking with jj

[12:09] <antoniogamiz> tbrowder: ok :) I'm telling you this because I've had a meeting this morning with him and we have been discussing the new proposal

[12:11] <tbrowder> ok, he's more on top of that, and you're in good hands with him

[12:12] <antoniogamiz> tbrowder: thanks :)

[12:12] <tbrowder> any progress on doc tooling is a giant plus

[12:12] <antoniogamiz> well, are you going to participate in the perl weekly challenge? :D

[12:16] *** MidCheck left
[12:18] <sena_kun> is there any explanation on rules and stuff like that?

[12:19] <masak> SmokeMachine: I'm sorry, I don't follow :/

[12:23] *** mowcat joined
[12:24] *** mowotter joined
[12:25] *** mowotter left
[12:38] *** Ven``` joined
[12:40] *** Ven`` left
[12:42] *** squashable6 left
[12:43] *** squashable6 joined
[12:48] *** pistacchio left
[12:48] *** pistacchio joined
[13:05] *** pistacchio left
[13:06] *** pistacchio joined
[13:14] *** antoniogamiz left
[13:15] <xinming> In class declaration, Is it possible to apply role after the after class definition?

[13:17] <sena_kun> only using MOP

[13:17] <sena_kun> FooClass.^add_role(FooRole); FooClass.^compose;

[13:17] <xinming> m: role R { method test () { "before".say; callsame; "after".say;  }; }; class T does R { method test () { "class method".say; } }; T.new.test;

[13:17] <camelia> rakudo-moar 1f066d96a: OUTPUT: «class method␤»

[13:17] <xinming> sena_kun: Ok, Thanks, that's what I want.

[13:18] <xinming> sena_kun: I'd wish we can have something like,  later-does R

[13:18] <xinming> role R { method test () { "before".say; callsame; "after".say;  }; }; class T last-does R { method test () { "class method".say; } }; T.new.test;

[13:19] <xinming> maybe last-does  or later-does

[13:19] <sena_kun> xinming, you can create a custom trait.

[13:19] <xinming> or deferred-does

[13:19] <sena_kun> but traits are applied at compile time anyway.

[13:19] <xinming> Will learn that, Just thought though

[13:20] <xinming> sena_kun: Can we use ::?ClASS.^add_role(FooRole); within class definition to achieve the same thing?

[13:20] <sena_kun> both does and a possible custom `does-later` will be executed at compile time, so not so much difference.

[13:21] <sena_kun> maybe if we knew your initial intention, something better could be proposed.

[13:21] <xinming> m: role R { method test () { "before".say; callsame; "after".say;  }; }; class T { method test () { "class method".say; } }; T.^add_role(R); T.^compose; T.new.test;

[13:21] <camelia> rakudo-moar 1f066d96a: OUTPUT: «class method␤»

[13:22] *** kurahaupo left
[13:22] <sena_kun> m: role A { method test {1.say} }; class C { method a { ::?CLASS.^add_role(A); ::?CLASS.^compose; } }

[13:22] <camelia> rakudo-moar 1f066d96a: ( no output )

[13:22] <sena_kun> m: role A { method test {1.say} }; class C { method a { ::?CLASS.^add_role(A); ::?CLASS.^compose; } }; C.test;

[13:22] <camelia> rakudo-moar 1f066d96a: OUTPUT: «No such method 'test' for invocant of type 'C'. Did you mean any of these?␤    List␤    Set␤    gist␤    list␤␤  in block <unit> at <tmp> line 1␤␤»

[13:22] <sena_kun> m: role A { method test {1.say} }; class C { method a { ::?CLASS.^add_role(A); ::?CLASS.^compose; } }; C.a; C.test;

[13:22] <camelia> rakudo-moar 1f066d96a: OUTPUT: «1␤»

[13:22] <xinming> sena_kun: I had a role, Which will wrap some methods for a class, that class will provide the method to for role to wrap;

[13:23] <sena_kun> xinming, ^

[13:23] *** ChoHag_ joined
[13:23] *** ChoHag left
[13:24] <xinming> m: role R { method test () { "before".say; callsame; "after".say;  }; }; class T { method test () { "class method".say; } }; T.^add_role(R); T.^compose; T.new.test;

[13:24] <camelia> rakudo-moar 1f066d96a: OUTPUT: «class method␤»

[13:24] <xinming> sena_kun: Why won't my example work?

[13:25] <xinming> I called T.^add_role(R); and T.^compose;

[13:25] <sena_kun> well, your class method overrides one from role.

[13:26] <sena_kun> so it is getting called.

[13:26] <sena_kun> m: role R { method test () { "before".say; callsame; "after".say;  }; }; class T { }; T.^add_role(R); T.^compose; T.new.test

[13:26] <camelia> rakudo-moar 1f066d96a: OUTPUT: «before␤after␤»

[13:26] <xinming> sena_kun: Actually, In my example, what I want to do is that method test in R will wrap the method test in T class.

[13:26] <xinming> is it possible to do?

[13:27] <jnthn> Composition is flattening, so only one method wins, and that'll be the one in the class

[13:27] <jnthn> It looks more like you want to do a runtime mixin of the role, though that'd not affect the original class, but that's probably a good thing anyway :)

[13:27] <xinming> jnthn: I want to affect the original class.

[13:27] <jnthn> (Doing runtime role addition to an existing class like that will probably win you precomp conflicts)

[13:28] <xinming> Ok, so, Seems, I need to consider other approach.

[13:28] <jnthn> xinming: Yes, that sounds wise 

[13:30] <xinming> m: role R { method test () { "before".say; callsame; "after".say;  }; }; class T { method test () { "class method".say; } }; my $x = T.new; $x does R; $x.test;

[13:30] <camelia> rakudo-moar 1f066d96a: OUTPUT: «before␤class method␤after␤»

[13:31] <xinming> jnthn: how to mix the role to the T class at compile time in this case?

[13:32] <sena_kun> m: role R { method test () { "before".say; callsame; "after".say;  }; }; class T { method test () { "class method".say; } }; my $x = T.new; infix:<does>($x, R); $x.test;

[13:32] <camelia> rakudo-moar 63657986f: OUTPUT: «before␤class method␤after␤»

[13:32] <sena_kun> probably

[13:33] <sena_kun> m: role R { method test () { "before".say; callsame; "after".say;  }; }; class T { method test () { "class method".say; } }; sub ap($x, $role) { infix:<does>($x, R); }; my $x = T.new; $x.test;

[13:33] <camelia> rakudo-moar 63657986f: OUTPUT: «class method␤»

[13:33] <sena_kun> m: role R { method test () { "before".say; callsame; "after".say;  }; }; class T { method test () { "class method".say; } }; sub ap($x, $role) { infix:<does>($x, R); }; my $x = T.new; ap($x, R); $x.test

[13:33] <camelia> rakudo-moar 63657986f: OUTPUT: «before␤class method␤after␤»

[13:34] <jnthn> xinming: Maybe something like my constant T = anon class T { ... } does role R { ... };

[13:34] <jnthn> uh, *but role R

[13:34] <xinming> let me try.

[13:34] <jnthn> I don't actually know what you're overall trying to achieve though, so there may be a much cleaner solution to the original problem :)

[13:37] <xinming> jnthn: I have classes only do computation, and I have a role will save to keep the results of the computation when condition meets.

[13:38] <sena_kun> maybe a dynamic variable will help? if it is a logger-like kind of thing

[13:38] <xinming> in this case, the class T will be the class do computation, And R will save the results somewhere. So if I want the computation class to keep history, I can give it "does R" to keep the history.

[13:38] <xinming> sena_kun: Not logger-like, It's per-class, Not per object.

[13:39] <xinming> m: role R { method test () { "before".say; callsame; "after".say;  }; }; my constant T = anon class T { method test () { "class method".say; } } does R; my $x = T.new; $x.test;

[13:39] <camelia> rakudo-moar 63657986f: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤An exception occurred while evaluating a constant␤at <tmp>:1␤Exception details:␤  Cannot use 'does' operator on a type object T.␤    in block  at <tmp> line 1␤␤»

[13:39] <xinming> m: role R { method test () { "before".say; callsame; "after".say;  }; }; my constant T = class T { method test () { "class method".say; } } does R; my $x = T.new; $x.test;

[13:39] <camelia> rakudo-moar 63657986f: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤An exception occurred while evaluating a constant␤at <tmp>:1␤Exception details:␤  Cannot use 'does' operator on a type object T.␤    in block  at <tmp> line 1␤␤»

[13:40] <xinming> jnthn: Will this be a bug? :-)

[13:40] <vrurg> xinming: why inheritance doesn't work for you?

[13:40] <sena_kun> m: my $*SAVE = class anon { method save { say 'saved' }; method is-good { True } }; class A { method test { $*SAVE.save if $*SAVE.is-good } }; A.test

[13:40] <camelia> rakudo-moar 63657986f: OUTPUT: «saved␤»

[13:40] <xinming> vrurg: Because the class T will provide the calcuation method

[13:41] <jnthn> xinming: I corrected it to `but`

[13:41] <sena_kun> (but the dynamic variable thing is a rough emulation for inheritance that is full of design flaws though)

[13:42] <vrurg> xinming: And? If your other code relies on class T – can't that code get particular class through some kind of a function/method which would return the right class for them?

[13:42] <xinming> m: role R { method test () { "before".say; callsame; "after".say;  }; }; my constant T = anon class T { method test () { "method".say; } } but R; my $x = T.new; $x.test;

[13:42] <camelia> rakudo-moar 63657986f: OUTPUT: «before␤method␤after␤»

[13:42] <xinming> This worked. :-)

[13:43] <xinming> vrurg: The T class is not base class, they are the class provide calculation implementation.

[13:45] <xinming> vrurg: It can be done via per-object bias to determine which object to keep history, and which object doesn't. I just try to make it for class instead of per object.

[13:45] <sena_kun> xinming, I think the idea is to have "Saver" class/role with a defined interface, so `class Calc does Saver { method calc { call-saver-method; } }`

[13:45] *** mowcat left
[13:45] <masak> m: say 1 || 2 // 3

[13:45] <camelia> rakudo-moar 63657986f: OUTPUT: «1␤»

[13:45] <vrurg> xinming: It doesn't make sense for me. Any class can be a base class. But as I don't have the full picture I can't judge. 

[13:45] <masak> according to S03, this should parsefail ^^

[13:46] <masak> (because different list-associative operators on the same precedence level need to be disambiguated with parentheses)

[13:46] <masak> jnthn: thoughts?

[13:46] <masak> TimToady: if you're there, thoughts? :)

[13:46] <masak> S03:79, fwiw

[13:47] <masak> I can easily believe that S03 shouldn't be implemented as it stands -- but in that case, we need to put down a new rule _somewhere_

[13:47] <xinming> sena_kun: This is what I thought first. But later, i realized that subclass don't need to call the call-saver-method at all.

[13:48] <sena_kun> xinming, why it doesn't? because you want to make it work using role/callsame magic?

[13:48] <masak> something like "sequences of list-associative operators of the same precedence implicitly group by exact operator, and the groups associate to the left"

[13:48] <xinming> sena_kun: My first implementation does something like, self.keep-history(%result);  in each method in subclasses. But later, I try to make this process "transpernt"

[13:48] <masak> that is, `1 || 2 // 3` means `(1 || 2) // 3`

[13:49] <jnthn> masak: Those are left associative, not list associative

[13:49] <kawaii> So I've seen some people use inline pod on their modules, and others put all the pod at the end of the module, is there some consensus on what users prefer for documentation?

[13:49] <masak> jnthn: again, not according to S03

[13:49] <xinming> m: role Saver { method calc () { my $res = callsame; "save-result-here".say;  }; }; my constant T = anon class T { method calc () { "do-calculation".say; } } but R; my $x = T.new; $x.test;

[13:49] <camelia> rakudo-moar 63657986f: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Undeclared name:␤    R used at line 1␤␤»

[13:50] <xinming> m: role Saver { method calc () { my $res = callsame; "save-result-here".say;  }; }; my constant T = anon class T { method calc () { "do-calculation".say; } } but Saver; my $x = T.new; $x.test;

[13:50] <camelia> rakudo-moar 63657986f: OUTPUT: «No such method 'test' for invocant of type 'T+{Saver}'. Did you mean any of these?␤    List␤    Set␤    gist␤    list␤␤  in block <unit> at <tmp> line 1␤␤»

[13:50] <sena_kun> xinming, not sure if applicable, but I would not hide the call at all.

[13:50] <jnthn> masak: S* are more of historical interest now; it's the spectest suite that defines how things should be

[13:50] <masak> jnthn: I had a feeling you would say that; I find that answer... somewhat unsatisfactory. was there a decision in-between S03 and the spectest suite to make those operators left-associative?

[13:50] <xinming> m: role Saver { method calc () { my $res = callsame; "save-result-here".say;  }; }; my constant T = anon class T { method calc () { "do-calculation".say; } } but Saver; my $x = T.new; $x.calc;

[13:50] <camelia> rakudo-moar 63657986f: OUTPUT: «do-calculation␤save-result-here␤»

[13:51] <masak> if not, why were they made left-associative?

[13:51] <xinming> sena_kun: This what I mean    :-)

[13:51] <xinming> I know I can do run time mix-in for single objects.

[13:51] <jnthn> masak: Quite possibly, but I don't have time to do the digging.

[13:53] <jnthn> masak: It's also, of course, possible that it was just implemented that way because it would have been a pain to do different from a code-gen point of view, and nobody noticed

[13:53] <jnthn> (until now)

[13:54] <masak> jnthn: in the Perl 6 grammar, `|| ^^ //` all have prec %tight_or, which is list-associative

[13:54] <masak> so I don't think they are left-associative

[13:54] <masak> (notice, again, that for `|| //`, there's no noticeable difference in semantics)

[13:55] <jnthn> Which Perl 6 grammar are you looking at?

[13:55] <jnthn> Rakudo's has:

[13:55] <jnthn>     token infix:sym<||>   { <sym>  <O(|%tight_or, :iffy(1), :assoc<left>, :pasttype<unless>)> }

[13:55] <jnthn>     token infix:sym<^^>   { <sym>  <O(|%tight_or, :iffy(1), :pasttype<xor>, :thunky<..t>)> }

[13:55] <jnthn>     token infix:sym<//>   { <sym>  <O(|%tight_or, :assoc<left>, :pasttype<defor>)> }

[13:55] <jnthn> See the :assoc<left>

[13:56] <masak> I was looking at those lines, yes. but apparently reading them wrong :)

[13:56] <jnthn> ah :)

[13:56] <masak> oh, so the operators pick first a precedence, and then _override_ the associativity. fun.

[13:56] <masak> this... messes with my mental model of precedence and associativity a bit

[13:57] <masak> ok, but that answers my question. thank you, jnthn.

[13:57] *** robertle left
[13:57] <jnthn> Not really, O just receives a set of named args

[13:57] <jnthn> And so the "override" is just arg passing semantics

[13:58] <jnthn> And the O that handles precedence never knows the difference 

[13:58] <masak> yes yes

[13:58] <xinming> sena_kun: What will you do to solve my problem? The Saver thing.

[13:58] <masak> it's just that... to me, associativity is something that a _precedence level_ has. that's in fact quite clear from the (S03) precedence table

[13:58] *** robertle joined
[13:59] <masak> and so if operators devidate from their level's precedence, then that's... an interesting form of anarchy, model-wise

[13:59] <masak> deviate*

[13:59] <sena_kun> xinming, what is the problem? a boilerplate method call in every calculation method?

[14:00] <sena_kun> I wouldn't consider it as an issue in the first place, I think, unless it is some disaster type of thing.

[14:00] <masak> jnthn: I come at this as someone who has spent a *lot* of the past 4-5 years thinking really hard about custom operators. doesn't mean I'm right, of course, but... getting an associativity that's separate from the one from your precedence level is a thing that Worries Me.

[14:01] <jnthn> masak: Hm, but the concept of predence level doesn't really exist so far as the Perl 6 OPP goes

[14:01] <jnthn> It's a model concept of the language user, perhaps, but it ain't really one of the parser

[14:02] <masak> it's about how the optable parser is meant to build the tree. first it tiebreaks by precedence, and then it tiebreaks by (that precedence level's) associativity

[14:02] <masak> but if the two ops in question each have an associativity, the second tiebreak may be inconclusive

[14:04] <xinming> sena_kun: I don't like boilerplate method call for each of the subclass. But just now, I thought through about what you said, each class should be considered inheritable. Then my sollution makes these class not suitable for inheritance. 

[14:04] <masak> what if you do `a X b Y c`, and X says to associate to the right but Y says to be non-associative?

[14:05] *** lizmat left
[14:05] <masak> (X and Y being of equal precedence)

[14:05] <SmokeMachine> m: class R { method test () { "before".say; callsame; "after".say;  }; }; class T last-does R { method test () { "class method".say; } }; T.^add_parent: R; T.new.test;

[14:05] <camelia> rakudo-moar 63657986f: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Unable to parse class definition␤at <tmp>:1␤------> 3y; callsame; "after".say;  }; }; class T7⏏5 last-does R { method test () { "class m␤    expecting any of:␤        generic role␤»

[14:05] *** lizmat joined
[14:05] <SmokeMachine> m: class R { method test () { "before".say; callsame; "after".say;  }; }; class T { method test () { "class method".say; } }; T.^add_parent: R; T.new.test;

[14:05] <camelia> rakudo-moar 63657986f: OUTPUT: «Parents cannot be added to class 'T'after it has been composed␤  in block <unit> at <tmp> line 1␤␤»

[14:06] <SmokeMachine> m: class R { method test () { "before".say; callsame; "after".say;  }; }; class T is R { method test () { "class method".say; } }; T.new.test;

[14:06] <camelia> rakudo-moar 63657986f: OUTPUT: «class method␤»

[14:06] <xinming> SmokeMachine: Because the method in T wins.

[14:06] <xinming> the    my constant T = anon class T { .. } but xx     version works

[14:07] <masak> in a way, associativity is _meant_ to be "when precedence is not enough, we at least build the tree in this unambiguous way". if associativity comes back with conflicting results, we're in trouble.

[14:07] <sena_kun> xinming, what's the issue with inheritance here? you want different savers for different children classes?

[14:08] <xinming> Nothing wrong with inheritance, just want to make the Saver transparent. :-)

[14:09] <xinming> ignore me though, I'll go with inheritance, But good to know how to achieve something I want in perl6. :-)

[14:09] <sena_kun> xinming, well, I am at no use here then, sorry. I'd consider it a bad design solution, to be honest. I mean, you are intentionally hiding execution parts from the user. It becomes harder to understand, debug and change.

[14:10] <SmokeMachine> xinming: why don't you transform the computation class into roles and the saves into classes?

[14:10] *** lizmat_ joined
[14:10] *** lizmat left
[14:10] *** lizmat__ joined
[14:12] <sena_kun> a method call approach is surely more boilerplate (which is not bad considering the code piece is sensible), but instead it can be easily disabled for a particular case, overloaded and so on. while "One Rule Them All" solution is less customize-able.

[14:12] <sena_kun> but that's just me. :)

[14:14] <xinming> SmokeMachine: I thought calculation is the important part, and keep results is a "feature". But now, I think in each calc method, explictly keep-result may not be that bad.

[14:14] *** lizmat_ left
[14:15] <SmokeMachine> xinming: if you are saving it on the database, you could do it with a Red model... :)

[14:20] *** lizmat__ left
[14:29] *** lizmat joined
[14:33] *** isomorphismes joined
[14:33] <masak> m: sub infix:<po>(*@v) is assoc<list> { @v.join(" po ") }; sub infix:<fi>(*@v) is equiv(&infix:<po>) is assoc("list") { @v.join(" fi ") }; say 1 po 2 po 3 fi 4 fi 5

[14:33] <camelia> rakudo-moar 787d5bf6e: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Only identical operators may be list associative; since 'po' and 'fi' differ, they are non-associative and you need to clarify with parentheses␤at <tmp>:1␤------> 3t") { @v.join(" fi ") }; say 1 po…»

[14:33] <masak> good news: we do have a warning in place \o/

[14:34] <masak> s/warning/error/

[14:35] <xinming> SmokeMachine: No need to advertise, My next project will try Red. I've used Xoo, It works, But Still lacks many features I want. At least not to the level DBIC can offer

[14:38] *** woolfy left
[14:39] *** squashable6 left
[14:41] <masak> my first foray into the spectest suite indicates that it's non-committal over the associativity of infix:<||> and infix:<&&>. I will mess around with building Rakudo in various ways to try to confirm this

[14:42] <masak> for the record, I skimmed through S03-operators/precedence.t and S03-operators/short-circuit.t, both of which looked promising

[14:42] *** squashable6 joined
[14:42] *** isomorphismes left
[14:43] *** Khisanth left
[14:44] *** kensanata left
[14:50] *** squashable6 left
[14:52] *** Cabanossi left
[14:52] *** lizmat left
[14:55] *** Cabanossi joined
[14:56] *** squashable6 joined
[14:56] *** ChanServ sets mode: +v squashable6

[14:57] *** MidCheck joined
[14:57] *** Khisanth joined
[15:06] <ugexe> pmurias: i looked at node ( https://github.com/nodejs/node/blob/f2064dfc1fee2daa0537bc27d79d5aa0f734faaf/src/node_os.cc#L114 ) and moarvm source (https://github.com/MoarVM/MoarVM/blob/d15906711f9a3a75cb72929c9f3c284b636cbe22/src/platform/sys.c#L9 ) for uv_cpu_info -- so that pr will give the same result as moarvm. what exactly that result represents is not immediately clear to me from the documentation (

[15:06] <ugexe> http://docs.libuv.org/en/v1.x/misc.html#c.uv_cpu_info_t )

[15:10] *** isomorphismes joined
[15:13] *** zacts left
[15:15] *** Actualeyes joined
[15:15] *** pistacchio left
[15:19] *** isomorphismes left
[15:22] *** ExtraCrispy joined
[15:33] *** pmurias left
[15:35] *** robertle left
[15:39] *** pmurias joined
[15:41] *** molaf left
[15:47] <patrickb> Is there an easy way to look at the installed sources of a module?

[15:53] <tobs> patrickb: `zef look` will take you there

[15:54] <sena_kun> patrickb, just keep in mind that they are not meant to be edited by hands.

[15:55] *** lookatme_q left
[15:55] <patrickb> tobs: does `zef look` display installed modules or the ones from the repo?

[15:55] <timotimo> i think it checks out the repo for you

[15:55] <patrickb> :-(

[15:56] *** lookatme_q joined
[16:02] <ugexe> zef locate ...

[16:03] <ugexe> editing those sources won’t do what you want though. But that’s how you locate installed sources to view 

[16:05] <xinming> m: role T { method t () { "method".say; } }; sub x (%t is copy) { %t.WHAT.say; }; my @a; my %h= (:a, :b); %h does T; @a.push: %h; x(%h);

[16:05] <camelia> rakudo-moar 787d5bf6e: OUTPUT: «(Hash)␤»

[16:05] <xinming> In this case, How can I also copy the "role"?

[16:06] <xinming> with is-copy, role info are dropped.

[16:07] <ugexe> m: my $test-dist = $*REPO.repo-chain.grep(CompUnit::Repository::Installable).map(*.candidates("NativeCall")).first.head; say $test-dist.content("lib/Test.pm6").slurp

[16:07] <camelia> rakudo-moar 787d5bf6e: OUTPUT: «use MONKEY-GUTS;          # Allow NQP ops.␤␤unit module Test;␤# Copyright (C) 2007 - 2018 The Perl Foundation.␤␤# settable from outside␤my int $perl6_test_times = ?%*ENV<PERL6_TEST_TIMES>;␤my int $die_on_fail      = ?%*ENV<PERL6_TEST_DIE…»

[16:08] <ugexe> you can query for a dist that contains some short-name, then ask for the content of a file in that distribution as shown above

[16:10] <patrickb> ugexe: Great! I don't want to edit them. It's helpful to look at installed stuff during error hunting.

[16:11] *** domidumont left
[16:12] *** pmurias left
[16:16] *** epony left
[16:28] *** [Sno] left
[16:28] *** jmerelo joined
[16:30] *** epony joined
[16:30] *** zacts joined
[16:32] *** cpan-p6_ joined
[16:32] *** cpan-p6 left
[16:34] *** leont joined
[16:35] *** choiboi left
[16:36] *** choiboi joined
[16:43] *** genese joined
[16:46] *** cpan-p6_ left
[16:46] *** cpan-p6 joined
[16:51] *** TimToady left
[16:52] *** TimToady joined
[16:52] *** molaf joined
[16:56] <tyil> rakudo.org is down

[16:56] <tyil> or not

[16:56] <tyil> my internet is dodgy

[16:57] <xinming> Another suggestion, Can we have a warning in    if $x => 1 == ablabla { }   ??

[16:57] <xinming> Today, I got typo with     if $x => 1   takes a while to find the problem.

[17:00] *** cpan-p6 left
[17:00] *** cpan-p6 joined
[17:05] *** MidCheck left
[17:09] *** Ven```` joined
[17:10] *** Ven``` left
[17:16] *** sauvin left
[17:20] <moritz> what were you trying to write?

[17:21] <timotimo> like "numerical equivalence of pairs is useless, did you mean >= instead of =>?"

[17:28] *** dakkar left
[17:30] <moritz> m: say (a => 1) == (b => 1)

[17:30] <camelia> rakudo-moar 787d5bf6e: OUTPUT: «Cannot resolve caller Numeric(Pair:D: ); none of these signatures match:␤    (Mu:U \v: *%_)␤  in block <unit> at <tmp> line 1␤␤»

[17:31] <moritz> seems like an error message that doesn't trigger a minute-long search

[17:31] <moritz> though "Cannot coerce Pair to Numeric" would be a better message

[17:32] <xinming> timotimo: Yes, something like that.

[17:33] <xinming> Just now, I have something like    if $idx => @history-reversed.elems - 1;

[17:33] <xinming> Which I actually should write   if $idx >= @history-reversed.elems -1

[17:34] <xinming> So, if there is warning here, can save a lot of time for people

[17:35] *** cpan-p6 left
[17:35] *** cpan-p6 joined
[17:36] *** mowcat joined
[17:37] *** lucasb joined
[17:37] *** mowotter joined
[17:43] *** reach_satori joined
[17:46] *** robertle joined
[17:47] *** lizmat joined
[17:48] *** domidumont joined
[17:48] *** lizmat left
[17:48] *** profan left
[17:48] *** lizmat joined
[17:48] *** cpan-p6 left
[17:49] *** cpan-p6 joined
[17:49] *** patrickb left
[17:50] *** profan joined
[17:52] <timotimo> https://decentraleyes.org/ - awesome!!

[17:55] <tadzik> "download an install to learn more" rubs me the wrong way

[17:55] <tadzik> but there's a readme in the gitlab link :)

[17:56] <tadzik> it is very cool though :)

[17:58] <timotimo> it's so obvious

[18:00] <tadzik> at the same time, I think that's something that caching is supposed to solve

[18:00] <timotimo> it should, but there's still the original request

[18:01] <tadzik> true. But with this extension, you don't know if the content you get is authentic, do you?

[18:02] <tadzik> websites use this checksum mechanism for validating external resources, except when they don't

[18:02] *** cpan-p6 left
[18:03] <timotimo> ha

[18:03] *** cpan-p6 joined
[18:03] <timotimo> for that you'd have to trust the extension does the right thing

[18:03] <timotimo> these checksums are in use on many sites, and of course should be used on every one of them

[18:03] <timotimo> then again, who says that you're getting the authentic thing from whatever cdn the site is using

[18:14] *** zacts left
[18:15] *** lizmat left
[18:16] *** cpan-p6 left
[18:17] *** cpan-p6 joined
[18:21] *** lizmat joined
[18:22] *** ab6tract joined
[18:22] <ab6tract> .tell japhb sent a followup email :)

[18:22] <yoleaux> 14 Mar 2019 21:59Z <japhb> ab6tract: No, I hadn't noticed that, though it's been a while since I checked all my mail accounts and folders.  I'll see if I can find it.

[18:22] <yoleaux> ab6tract: I'll pass your message to japhb.

[18:30] *** cpan-p6 left
[18:31] *** cpan-p6 joined
[18:44] *** netrino joined
[18:44] *** cpan-p6 left
[18:44] *** molaf left
[18:45] *** cpan-p6 joined
[18:53] *** patrickb joined
[18:55] *** netrino_ joined
[18:56] *** netrino left
[19:15] *** patrickb left
[19:21] *** cpan-p6 left
[19:22] *** cpan-p6 joined
[19:24] *** kurahaupo joined
[19:25] *** mowotter left
[19:25] *** mowcat left
[19:34] *** lizmat left
[19:35] *** cpan-p6 left
[19:35] *** cpan-p6 joined
[19:36] *** lizmat joined
[19:40] *** domidumont left
[19:49] *** cpan-p6 left
[19:49] *** cpan-p6 joined
[19:50] *** reach_satori left
[19:50] *** reach_satori joined
[19:56] *** reach_satori left
[19:57] *** MasterDuke left
[20:03] *** jmerelo left
[20:03] *** cpan-p6 left
[20:03] *** cpan-p6 joined
[20:05] *** reach_satori joined
[20:14] *** Ven````` joined
[20:15] *** Ven```` left
[20:17] *** cpan-p6 left
[20:17] *** cpan-p6 joined
[20:20] *** lizmat left
[20:25] *** lizmat joined
[20:30] *** lizmat left
[20:31] *** cpan-p6 left
[20:31] *** cpan-p6 joined
[20:38] *** reach_satori left
[20:40] *** zacts joined
[20:46] *** cpan-p6 left
[20:46] *** cpan-p6 joined
[20:56] *** mowcat joined
[20:57] *** mowotter joined
[20:58] *** cpup left
[20:58] *** cpup joined
[21:02] *** Skarsnik joined
[21:05] *** ufobat joined
[21:07] <Skarsnik> Hello there. I rerun my gumbo benchmark, and I admit I am kinda disapointed to be only 4x faster since rakudo 2016.01 x) https://gist.github.com/Skarsnik/2161a360cca691f979f8588c8fc6d9d8

[21:07] <timotimo> could you perhaps do a "perf record" and "perf report --stdio" of that benchmark? and perhaps another with the jit turned off?

[21:08] <ufobat> mhm 2019.03.1 segfaulted on the first attempt of compiling it

[21:08] <timotimo> core dump please? :3

[21:08] <Skarsnik> what does that do? x)

[21:08] <timotimo> perhaps "coredumpctl"?

[21:09] <timotimo> Skarsnik: it's a profiler that'll sample what function it hits (actually which exact instruction) a few thousand times per second (adjustable frequency)

[21:09] <Skarsnik> Hoo you mean as rakudo option

[21:09] <timotimo> just "perf record perl6 blah"

[21:10] <timotimo> it'll also tell us what parts of gumbo take how much time

[21:10] <Skarsnik> the call to the lib C (gumbo parse html function) take like 0.01 x)

[21:10] * ufobat tries to make a coredump

[21:11] <timotimo> ufobat: maybe coredumpctl has one for you already?

[21:11] <timotimo> Skarsnik: damn :D

[21:11] <ufobat> coredumpctl is not installed

[21:11] <timotimo> OK

[21:11] *** sena_kun left
[21:12] <Skarsnik> hm 0.02 sec

[21:13] <timotimo> i mean, that's still like 10% :) :)

[21:13] *** molaf joined
[21:13] *** cpan-p6 left
[21:13] <Skarsnik> so basicly it take 10 time to time to parse the html5 to just transform the C struct to Perl 6 object

[21:13] <timotimo> mhm

[21:14] *** cpan-p6 joined
[21:14] <Skarsnik> does 2019.03.1 is up2date for your profiler? x)

[21:14] <timotimo> yeah, i believe so

[21:16] <Skarsnik> still no dock image or stuff to easily install it? x)

[21:17] <timotimo> nope, but now... now we have relocateable perl6 launchers!

[21:17] <timotimo> it can become an appimage!!

[21:18] <Skarsnik> I guess I just have to send the profile file xD

[21:18] <ufobat> it doesnt segfault anymore, i tried it 5 times

[21:18] <Skarsnik> this is weird, I had no issue compiling 2019.03.1

[21:19] <timotimo> i feel like i already started on a Dockerfile, but i can't find it any more :|

[21:21] <Skarsnik> I saved a lot of time patching XML and removing some NCast call between the 2 runs of my benchmark.  rakudo-2018.09, gumboxml.p6, 0.52847010577  vs rakudo-2018.09, gumboxml.p6, 0.3243064942

[21:21] <timotimo> impressive

[21:22] <Skarsnik> I run the test 50 times for each release and do an average, it's not a single run

[21:23] *** domidumont joined
[21:23] *** sena_kun joined
[21:23] <Skarsnik> ./rakudo-2016.01.1/install/bin/perl6 --profile --profile-filename testgumbo.json to get a profile?

[21:24] <ufobat> is there a rakudo brew clean command?

[21:24] <ufobat> it just dont segfault anymore

[21:25] *** zacts left
[21:25] <Skarsnik> you could cd rakudo and make distclean I guess?

[21:27] *** domidumont left
[21:27] *** cpan-p6 left
[21:27] *** cpan-p6 joined
[21:30] *** Black_Ribbon joined
[21:32] *** pecastro joined
[21:33] <timotimo> nah, you'll have to use .sql for the filename

[21:33] <timotimo> ufobat: "nuke" is the one, it hink

[21:34] <ufobat> jup..

[21:34] <ufobat> last try

[21:35] <Skarsnik> the sql file is html lol

[21:37] <timotimo> in that case the filename didn't take? somehow?

[21:37] <timotimo> oh

[21:37] <timotimo> you're in 2016.01

[21:37] <Skarsnik> I ran the wrong rakudo yes lol

[21:38] <Skarsnik> https://gist.github.com/Skarsnik/47cbaa4020e31800dc608a082ffac864

[21:39] <timotimo> crap, my hard drive is *super* filled up to the brim

[21:39] <timotimo> need to do some emergency cleaning

[21:40] <Skarsnik> I have too many hard drive xD

[21:41] *** cpan-p6 left
[21:41] *** cpan-p6 joined
[21:42] *** sno joined
[21:48] <Skarsnik> C:              233G  138G   95G  60% /mnt/c

[21:48] <Skarsnik> F:              1.9T  1.3T  619G  67% /mnt/f

[21:48] <Skarsnik> G:              1.9T  344M  1.9T   1% /mnt/g

[21:48] <Skarsnik> K:              448G   70G  378G  16% /mnt/k

[21:50] <El_Che>  /mnt and disk as drive letters

[21:50] <El_Che> a little schizzo :)

[21:51] <Skarsnik> it's WPL

[21:51] <El_Che> WSL?

[21:52] <Skarsnik> yes? the win 10 stuff to have a linux env ^^

[21:52] <Skarsnik> very handy

[21:55] *** curan left
[21:55] *** cpan-p6 left
[21:55] *** cpan-p6 joined
[21:59] *** sena_kun left
[22:00] *** ab6tract left
[22:04] *** ravenousmoose_ joined
[22:04] *** ravenousmoose left
[22:05] *** john_parr left
[22:06] *** john_parr joined
[22:09] *** zacts joined
[22:09] *** cpan-p6 left
[22:09] *** cpan-p6 joined
[22:14] <Xliff> m: class A { method a { say ::?CLASS.name }; }; class B is A { }; A.new.a.say; B.new.a.say

[22:14] <yoleaux> 20 Mar 2019 09:16Z <SmokeMachine> Xliff: https://github.com/FCO/Red/issues/15#issuecomment-474745855

[22:14] <camelia> rakudo-moar 787d5bf6e: OUTPUT: «No such method 'name' for invocant of type 'A'. Did you mean any of these?␤    none␤    note␤    take␤␤  in method a at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[22:14] <Xliff> m: class A { method a { say ::?CLASS.^name }; }; class B is A { }; A.new.a.say; B.new.a.say

[22:14] <camelia> rakudo-moar 787d5bf6e: OUTPUT: «A␤True␤A␤True␤»

[22:18] <Xliff> Is there any way to get the second "A" to say "B"?

[22:18] <Skarsnik> self::?CLASS.^name?

[22:19] <jnthn> Xliff: self.^name

[22:22] <guifa> Are there any rough style guideliness for when to pass named args in or out of the parenthetical main args?

[22:23] *** cpan-p6 left
[22:23] *** cpan-p6 joined
[22:23] <guifa> By that I mean, foo(5, :$bar) is the same as foo(5) :$bar … or is it?

[22:24] <Xliff> m: class A { method a { say self.^name }; }; class B is A { }; A.new.a.say; B.new.a.say

[22:24] <camelia> rakudo-moar 787d5bf6e: OUTPUT: «A␤True␤B␤True␤»

[22:26] <Skarsnik> hm

[22:26] <Skarsnik> m: class A { method a { say self.^name }; }; class B does A { }; A.new.a.say; B.new.a.say

[22:26] <camelia> rakudo-moar 787d5bf6e: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤A is not composable, so B cannot compose it␤at <tmp>:1␤»

[22:28] <ugexe> why are you "does"ing a class?

[22:28] <Skarsnik> dunno

[22:28] <timotimo> that code has too high a doesage

[22:32] *** lizmat joined
[22:32] <Xliff> jnthn++

[22:32] <Skarsnik> I think Perl 6 class and heritance is always super confusing x)

[22:34] <moritz> Skarsnik: why? it works exactly like in any other language

[22:36] <Skarsnik> m: class A { method foo(){say "foo"} }; class B is A { method foo(Int $a) { say "foo Int"}}; B.new.foo(42);

[22:36] <camelia> rakudo-moar 787d5bf6e: OUTPUT: «foo Int␤»

[22:36] <Skarsnik> Hoo this work now

[22:38] <Skarsnik> m: role A { method foo(){say "foo"} }; class B does A { method foo(Int $a) { say "foo Int"}}; B.new.foo(42);

[22:38] <camelia> rakudo-moar 787d5bf6e: OUTPUT: «foo Int␤»

[22:46] *** woolfy joined
[22:49] *** pecastro left
[22:50] *** cpan-p6 left
[22:51] *** cpan-p6 joined
[22:54] *** molaf left
[22:57] <lizmat> weekly: https://brrt-to-the-future.blogspot.com/2019/03/reverse-linear-scan-allocation-is.html

[22:57] <notable6> lizmat, Noted!

[23:01] *** woolfy left
[23:02] *** woolfy joined
[23:03] *** cpan-p6 left
[23:03] *** cpan-p6 joined
[23:04] *** rindolf left
[23:05] <guifa> is there any syntactical sugar for converting a scalar into an array in a method signature, or should I just keep going with multi’s for that? (where I assume a list will be passed but want to accept a scalar rather than make someone create a single item list)

[23:07] <discord6> <Vendethiel> *@ or **@ or +@?

[23:07] <lizmat> m: sub a(*@a) { dd @a }; a 42

[23:07] <camelia> rakudo-moar 787d5bf6e: OUTPUT: «Array element = [42]␤»

[23:09] <guifa> That’ll work great in this case, actually.  (although if it were the first of several positionals, I guess it wouldn’t)

[23:09] <guifa> Vandethiel++ lizmat++

[23:09] <lizmat> sleep&

[23:09] <discord6> <Vendethiel> Perl 6 alas doesn’t treat end of lists as much like first citizens as beginning of lists (because of fear of the laziness abyss)

[23:09] *** Geth left
[23:18] *** cpan-p6 left
[23:18] *** cpan-p6 joined
[23:19] *** Ven`````` joined
[23:20] *** Ven````` left
[23:24] *** MasterDuke joined
[23:24] *** MasterDuke left
[23:24] *** MasterDuke joined
[23:29] *** zacts left
[23:32] *** cpan-p6 left
[23:32] *** cpan-p6 joined
[23:34] <guifa> Interesting.  The docs say that %?RESOURCES<foo> returns an IO::Path object, but it’s actually a Distribution::Resource one that holds an IO::Path inside, so it fails type checks

[23:42] <timotimo> i think IO::Path used to be what it did and then it was changed but not updated in the docs? perhaps?

[23:42] *** mowotter left
[23:43] <guifa> That sounds likely.  There’s zero documentation for Distribution::Resource

[23:43] *** mowcat left
[23:43] *** mowcat joined
[23:43] *** mowcat left
[23:44] *** mowcat joined
[23:44] <discord6> <Vale> Hey I have a general question

[23:44] *** mowcat left
[23:44] <discord6> <Vale> How can I compare 2 strings char by char with a loop?

[23:44] *** mowcat joined
[23:45] <discord6> <Vale> my ($first, $second) = @_;     foreach my $charA, $charB ($first, $second){         #compare $charA with $charB     }

[23:45] <discord6> <Vale> Let $first and $second be strings

[23:45] <discord6> <Vale> is this even possible like this?

[23:45] <timotimo> you can get a list of characters with .comb and you can get a matching one from each with the Z metaop

[23:46] <timotimo> m: my ($first, $second) = ("hello", "goodbye")>>.comb; for $first Z $second -> $a, $b { say "$a-$b" }

[23:46] <camelia> rakudo-moar 787d5bf6e: OUTPUT: «Too few positionals passed; expected 2 arguments but got 1␤  in block <unit> at <tmp> line 1␤␤»

[23:46] <timotimo> m: my ($first, $second) = ("hello", "goodbye")>>.comb; for $first Z $second -> ($a, $b) { say "$a-$b" }

[23:46] <camelia> rakudo-moar 787d5bf6e: OUTPUT: «h e l l o-g o o d b y e␤»

[23:46] <timotimo> nope

[23:46] <timotimo> m: my ($first, $second) = ("hello", "goodbye")>>.comb; for @$first Z @$second -> ($a, $b) { say "$a-$b" }

[23:46] <camelia> rakudo-moar 787d5bf6e: OUTPUT: «h-g␤e-o␤l-o␤l-d␤o-b␤»

[23:46] <timotimo> see how it ends when the shorter string ends

[23:46] <timotimo> that's a thing that Z does that you have to be aware of

[23:48] <timotimo> m: my ($first, $second) = ("hello", "goodbye")>>.comb; for @$first »,« @$second -> ($a, $b) { say "$a-$b" } # if you want it to throw an exception when the lists aren't the same length use »,«

[23:48] <camelia> rakudo-moar 787d5bf6e: OUTPUT: «Lists on either side of non-dwimmy hyperop of infix:<,> are not of the same length while recursing␤left: 5 elements, right: 7 elements␤  in block <unit> at <tmp> line 1␤␤»

[23:49] <timotimo> m: my ($first, $second) = ("hello", "goodbye")>>.comb; for @$first «,» @$second -> ($a, $b) { say "$a-$b" } # if you want it to repeat the shorter one until the longer one is exhausted, use «,»

[23:49] <camelia> rakudo-moar 787d5bf6e: OUTPUT: «h-g␤e-o␤l-o␤l-d␤o-b␤h-y␤e-e␤»

[23:49] <discord6> <Vale> hmm

[23:50] *** netrino_ left
[23:50] <timotimo> `Z` is equivalent to `Z,` but you can also use other operators there

[23:50] <discord6> <Vale> Alright thanks

[23:51] <discord6> <Vale> This is helpful

[23:51] <timotimo> m: .perl.say for (<a b c d e> Z=> <1 2 3 4 5>)

[23:51] <discord6> <Vale> 😃

[23:51] <camelia> rakudo-moar 787d5bf6e: OUTPUT: «:a(IntStr.new(1, "1"))␤:b(IntStr.new(2, "2"))␤:c(IntStr.new(3, "3"))␤:d(IntStr.new(4, "4"))␤:e(IntStr.new(5, "5"))␤»

[23:51] <timotimo> ha, that's not such helpful output actually

[23:51] <timotimo> m: .perl.say for ("a b c d e".words Z=> "1 2 3 4 5".words)

[23:51] <camelia> rakudo-moar 787d5bf6e: OUTPUT: «:a("1")␤:b("2")␤:c("3")␤:d("4")␤:e("5")␤»

[23:54] *** Skarsnik left
