[00:03] *** reach_satori left
[00:05] *** reach_satori joined
[00:07] *** reach_satori left
[00:26] *** reach_satori joined
[00:31] *** ravenousmoose joined
[00:37] *** ravenousmoose left
[01:00] *** Kaiepi left
[01:01] *** Kaiepi joined
[01:02] *** AbdallahDeBourgo joined
[01:03] <AbdallahDeBourgo> Hi

[01:05] *** AbdallahDeBourgo left
[01:06] *** Flegeudigen joined
[01:07] *** wamba left
[01:11] *** ravenousmoose joined
[01:12] *** molaf left
[01:15] *** ravenousmoose left
[01:23] *** Flegeudigen left
[01:24] *** molaf joined
[01:31] *** reach_satori left
[01:33] *** reach_satori joined
[01:55] *** softmoth left
[02:05] *** Sgeo_ left
[02:06] *** ravenousmoose joined
[02:06] *** Sgeo_ joined
[02:06] *** lucasb left
[02:11] *** ravenousmoose left
[02:16] <Doc_Holliwood> AbdallahDeBourgo Ho

[02:17] <guifa> It’s off to work we go

[02:47] *** huyna joined
[03:23] *** agentzh left
[03:25] *** agentzh joined
[03:25] *** agentzh left
[03:25] *** agentzh joined
[04:06] *** huyna left
[04:19] *** nebuchad` joined
[04:21] *** nebuchadnezzar left
[05:03] *** Doc_Holliwood left
[05:09] *** Black_Ribbon left
[05:19] *** Cabanossi left
[05:20] *** Cabanossi joined
[05:48] *** ravenousmoose joined
[05:52] *** wamba joined
[06:09] *** jmerelo joined
[06:09] *** krychu left
[06:09] <jmerelo> releasable6: status

[06:09] <releasable6> jmerelo, Next release in ≈13 days and ≈12 hours. R6 is down. At least 4 blockers. Unknown changelog format

[06:09] <releasable6> jmerelo, Details: https://gist.github.com/19b61b626e4e4b81e6c6d582fce47c77

[06:33] *** kylese joined
[06:37] <jmerelo> notable6: Perl 6 Quick Syntax Reference is out already: https://t.co/QQoX47iXJJ?amp=1

[06:37] <notable6> jmerelo, Noted! (weekly)

[06:40] *** nebuchad` is now known as nebuchadnezzar

[06:42] <discord6> <Aearnus> jmerelo++

[06:48] <jmerelo> Aearnus: thanks... It's been a rather long ride, but it's finally out.

[06:49] <discord6> <Aearnus> looks good! i'll check it out next paycheck hehe

[06:50] <jmerelo> Aearnus: Sure :-) Fortunately, it's not too expensive... I see it's also available in Safari, for those who have subscribed. 

[06:51] *** bobv joined
[06:54] *** MilkmanDan left
[06:55] *** sena_kun joined
[07:06] *** MilkmanDan joined
[07:31] *** krychu joined
[07:36] *** MilkmanDan left
[07:37] *** MilkmanDan joined
[07:44] *** bobv left
[07:58] *** chloekek joined
[08:03] *** Doc_Holliwood joined
[08:06] *** veesh left
[08:50] *** cpan-p6 left
[08:51] *** cpan-p6 joined
[08:51] *** cpan-p6 left
[08:51] *** cpan-p6 joined
[09:27] *** chloekek left
[09:40] *** agentzh left
[09:42] *** agentzh joined
[10:08] *** Xliff joined
[10:08] <Xliff> .

[10:08] <Xliff> o/

[10:10] *** chloekek joined
[10:11] <jmerelo> Xliff: hey!

[10:24] *** jaldhar joined
[10:27] *** Xliff left
[10:32] *** luk joined
[10:34] <luk> weekly: https://pointieststick.com/2019/09/28/this-week-in-kde-towards-plasma-5-18/

[10:34] <notable6> luk, Noted! (weekly)

[10:34] *** luk left
[10:42] *** Xliff joined
[10:53] <Xliff> m: say 'a'..'z'.join('') ~ 'A'..'Z'.join('')

[10:53] <camelia> rakudo-moar 6c35cef60: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Operators '..' and '..' are non-associative and require parentheses␤at <tmp>:1␤------> 3say 'a'..'z'.join('') ~ 'A'.7⏏5.'Z'.join('')␤»

[10:53] <Xliff> m: say ('a'..'z').join('') ~ ('A'..'Z').join('')

[10:53] <camelia> rakudo-moar 6c35cef60: OUTPUT: «abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ␤»

[11:08] *** jaldhar left
[11:24] <Xliff> m: (5..10).pick.say

[11:24] <camelia> rakudo-moar 6c35cef60: OUTPUT: «9␤»

[11:24] <Xliff> m: (5..10).pick.say

[11:24] <camelia> rakudo-moar 6c35cef60: OUTPUT: «9␤»

[11:24] <Xliff> m: (5..10).pick.say

[11:24] <camelia> rakudo-moar 6c35cef60: OUTPUT: «9␤»

[11:28] *** jmerelo left
[11:43] *** wamba left
[11:54] *** TravisRt2botio[m left
[11:54] *** JulianF left
[11:54] *** lance_w[m] left
[11:54] *** Demos[m] left
[11:54] *** MitarashiDango[m left
[11:54] *** matiaslina left
[11:54] *** rba[m] left
[11:54] *** unclechu left
[11:54] *** Matthew[m] left
[11:54] *** uzl[m] left
[11:54] *** mack[m]1 left
[11:54] *** tyil[m] left
[11:54] *** EuAndreh[m] left
[11:54] *** sergiotarxz[m] left
[11:54] *** folex left
[11:54] *** aearnus[m] left
[11:54] *** roy[m] left
[11:54] *** AlexDaniel` left
[11:54] *** batmanaod[m] left
[11:54] *** xliff[m] left
[11:54] *** Seance[m] left
[11:54] *** BlackChaosNL[m] left
[11:54] *** p_gurra joined
[11:59] <p_gurra> I'm trying to use a sub as a accumulator using a state hash as container and want to use multi-dispatch with a proto sub as setter (with parameters), and another as getter (w/o parameters). When a use the getter sub the hash always is empty. This is an example:

[12:00] <p_gurra> multi yyy (Str $s, @a) { state %h; %h{$s}.append: @a; say %h }

[12:00] <Xliff> p_gurra: yyy will always return true like that.

[12:01] <Xliff> If you want yyy to function like a get/set, try this:

[12:01] *** AlexDaniel` joined
[12:01] <p_gurra> sub multi yyy () { state %h; say %h; return %h }

[12:01] <Xliff> Yes

[12:01] <Xliff> m: sub yyy is rw {}

[12:01] <camelia> rakudo-moar 6c35cef60: ( no output )

[12:02] <Xliff> m: sub yyy (Str $s, @a) is rw { Proxy.new( FETCH => -> { %h{$s} }

[12:02] <camelia> rakudo-moar 6c35cef60: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Variable '%h' is not declared␤at <tmp>:1␤------> 3s, @a) is rw { Proxy.new( FETCH => -> { 7⏏5%h{$s} }␤»

[12:03] <Xliff> m: sub yyy (Str $s, @a) is rw { Proxy.new( FETCH => -> $, { %h{$s} }, STORE -> $, { %h{$s} = $a} ); }; yyy('hello') = 'b'; yyy('hello').say

[12:03] <camelia> rakudo-moar 6c35cef60: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Variable '%h' is not declared␤at <tmp>:1␤------> 3@a) is rw { Proxy.new( FETCH => -> $, { 7⏏5%h{$s} }, STORE -> $, { %h{$s} = $a} ); ␤»

[12:03] <Xliff> m: sub yyy (Str $s, @a) is rw { state %h; Proxy.new( FETCH => -> $, { %h{$s} }, STORE -> $, { %h{$s} = $a} ); }; yyy('hello') = 'b'; yyy('hello').say

[12:03] <camelia> rakudo-moar 6c35cef60: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Variable '$a' is not declared. Did you mean '@a'?␤at <tmp>:1␤------> 3> $, { %h{$s} }, STORE -> $, { %h{$s} = 7⏏5$a} ); }; yyy('hello') = 'b'; yyy('hello␤»

[12:03] <Xliff> m: sub yyy (Str $s, @a) is rw { state %h; Proxy.new( FETCH => -> $, { %h{$s} }, STORE -> $, $a { %h{$s} = $a} ); }; yyy('hello') = 'b'; yyy('hello').say

[12:03] <camelia> rakudo-moar 6c35cef60: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Undeclared name:␤    STORE used at line 1␤␤»

[12:03] <Xliff> m: sub yyy (Str $s, @a) is rw { state %h; Proxy.new( FETCH => -> $, { %h{$s} }, STORE => -> $, $a { %h{$s} = $a} ); }; yyy('hello') = 'b'; yyy('hello').say

[12:03] <camelia> rakudo-moar 6c35cef60: OUTPUT: «5===SORRY!5===␤Calling yyy(Str) will never work with declared signature (Str $s, @a)␤at <tmp>:1␤------> 3 STORE => -> $, $a { %h{$s} = $a} ); }; 7⏏5yyy('hello') = 'b'; yyy('hello').say␤Calling yyy(Str) will never work with declared s…»

[12:04] <Xliff> m: sub yyy (Str $s) is rw { state %h; Proxy.new( FETCH => -> $, { %h{$s} }, STORE => -> $, $a { %h{$s} = $a} ); }; yyy('hello') = 'b'; yyy('hello').say

[12:04] <camelia> rakudo-moar 6c35cef60: OUTPUT: «b␤»

[12:04] <Xliff> ^^^

[12:06] *** aborazmeh joined
[12:06] *** aborazmeh left
[12:06] *** aborazmeh joined
[12:09] <p_gurra> Hmm, maybe that's a bit to sofisticated for my needs. I'd like  output like this: my %hh = yyy();

[12:10] <Xliff> OK. Your initial description was unclear.

[12:10] <p_gurra> Sorry!

[12:10] <Xliff> The problem there is that it sounds like you are looking for more of an object than a sub.

[12:11] *** chloekek left
[12:11] <Xliff> m: class yyy does Associative { }; my $y = yyy.new; $y<me> = 1; $y.gist.say

[12:11] <camelia> rakudo-moar 6c35cef60: OUTPUT: «Associative indexing implementation missing from type yyy␤  in block <unit> at <tmp> line 1␤␤»

[12:12] <Xliff> p_gurra: See this page: https://docs.perl6.org/type/Associative

[12:13] <Xliff> You'd really only need to implement AT-KEY and EXISTS-KEY.

[12:14] <p_gurra> OK, maybe so. As a newcomber to p6 I intented to create a more elegant solution than a namespace- or a closure, which I would have used in p5

[12:14] <p_gurra> Aha, thanks

[12:15] *** Demos[m] joined
[12:15] *** Matthew[m] joined
[12:15] *** EuAndreh[m] joined
[12:15] *** BlackChaosNL[m] joined
[12:15] *** lance_w[m] joined
[12:15] *** TravisRt2botio[m joined
[12:15] *** tyil[m] joined
[12:15] *** rba[m] joined
[12:15] *** sergiotarxz[m] joined
[12:15] *** unclechu joined
[12:15] *** JulianF joined
[12:15] *** roy[m] joined
[12:15] *** batmanaod[m] joined
[12:15] *** aearnus[m] joined
[12:15] *** mack[m]1 joined
[12:15] *** uzl[m] joined
[12:15] *** matiaslina joined
[12:15] *** xliff[m] joined
[12:15] *** folex joined
[12:15] *** Seance[m] joined
[12:15] *** MitarashiDango[m joined
[12:15] <Xliff> m: class yyy does Associative { has %!h; method AT-KEY (\key) { %!h{key} }; method EXISTS-KEY (\key) { %!h{key}:exists }; }; my $y = $yyy.new; $yyy<me> = 'b'; my %h = $y; %h.gist.say

[12:15] <lizmat> p_gurra: https://github.com/lizmat/Hash-Agnostic may be of help

[12:15] <camelia> rakudo-moar 6c35cef60: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Variable '$yyy' is not declared. Did you mean 'yyy'?␤at <tmp>:1␤------> 3 (\key) { %!h{key}:exists }; }; my $y = 7⏏5$yyy.new; $yyy<me> = 'b'; my %h = $y; %h␤»

[12:16] <Xliff> m: class yyy does Associative { has %!h; method AT-KEY (\key) { %!h{key} }; method EXISTS-KEY (\key) { %!h{key}:exists }; }; my $y = yyy.new; $yyy<me> = 'b'; my %h = $y; %h.gist.say

[12:16] <camelia> rakudo-moar 6c35cef60: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Variable '$yyy' is not declared. Did you mean 'yyy'?␤at <tmp>:1␤------> 3 %!h{key}:exists }; }; my $y = yyy.new; 7⏏5$yyy<me> = 'b'; my %h = $y; %h.gist.say␤»

[12:16] <Xliff> m: class yyy does Associative { has %!h; method AT-KEY (\key) { %!h{key} }; method EXISTS-KEY (\key) { %!h{key}:exists }; }; my $y = yyy.new; $y<me> = 'b'; my %h = $y; %h.gist.say

[12:16] <camelia> rakudo-moar 6c35cef60: OUTPUT: «Cannot modify an immutable 'Any' type object␤  in block <unit> at <tmp> line 1␤␤»

[12:17] <Xliff> m: class yyy does Associative { has %.h is rw; method AT-KEY (\key) { %!h{key} }; method EXISTS-KEY (\key) { %!h{key}:exists }; }; my $y = yyy.new; $y<me> = 'b'; my %h = $y; %h.gist.say

[12:17] <camelia> rakudo-moar 6c35cef60: OUTPUT: «Cannot modify an immutable 'Any' type object␤  in block <unit> at <tmp> line 1␤␤»

[12:17] <Xliff> Yeah. I'd go with lizmat's solution.

[12:17] *** woolfy joined
[12:18] *** woolfy left
[12:23] *** gabiruh_ joined
[12:23] <p_gurra> Thank you all! I'll try that suggestion.

[12:25] *** gabiruh left
[12:28] *** aborazmeh left
[12:29] *** domidumont joined
[12:33] *** domidumont left
[12:33] *** domidumont1 joined
[12:47] *** p_gurra left
[12:56] *** MilkmanDan left
[12:57] *** MilkmanDan joined
[13:12] *** Xliff left
[13:19] *** Cabanossi left
[13:24] <lizmat> .u not equal

[13:24] <unicodable6> lizmat, U+2244 NOT ASYMPTOTICALLY EQUAL TO [Sm] (≄)

[13:24] <unicodable6> lizmat, U+2246 APPROXIMATELY BUT NOT ACTUALLY EQUAL TO [Sm] (≆)

[13:24] <unicodable6> lizmat, 27 characters in total (≄≆≉≠≨≩⊊⊋⋠⋡⋢⋣⋤⋥⋬⋭⍯⪇⪈⪱⪲⪵⪶⪹⪺⫋⫌): https://gist.github.com/00ebdbb4a513347b05f9adc5bb3402bf

[13:24] *** Cabanossi joined
[13:25] <lizmat> .u unequal

[13:25] <unicodable6> lizmat, Found nothing!

[13:26] <lizmat> .u not greater

[13:26] <unicodable6> lizmat, U+2269 GREATER-THAN BUT NOT EQUAL TO [Sm] (≩)

[13:26] <unicodable6> lizmat, U+226F NOT GREATER-THAN [Sm] (≯)

[13:26] <unicodable6> lizmat, 5 characters in total (≩≯⋧⪈⪊): https://gist.github.com/80d172fb1ca730b31c65e57ae2ff23b0

[13:29] <lizmat> weekly: https://perl6.eu/binary-clock.html

[13:29] <notable6> lizmat, Noted! (weekly)

[13:30] *** pecastro joined
[13:45] *** sena_kun left
[13:46] *** sena_kun joined
[13:47] *** cpan-p6 left
[13:47] *** cpan-p6 joined
[13:48] *** cpan-p6 left
[13:48] *** cpan-p6 joined
[13:50] *** chloekek joined
[14:01] <SmokeMachine> m: my %h; multi yyy { %h = () }; multi yyy($key) is rw { %h{ $key } }; multi yyy($key, *@value where .elems) { %h{ $key }.append: @value }; yyy "bla", "ble", "bli"; say yyy "bla"; dd yyy

[14:01] <camelia> rakudo-moar 6c35cef60: OUTPUT: «[ble bli]␤Hash %h = {}␤»

[14:07] *** lucasb joined
[14:10] *** krychu left
[14:21] *** MilkmanDan left
[14:23] *** MilkmanDan joined
[14:27] <guifa> Any preference between Intl::Date.new($gregorian, :hebrew) or Intl::Date.new($gregorian, :calendar<hebrew>) ?  (or any effect on performance?  Seems about the same from code maintanence)

[14:29] <sena_kun> guifa, how many other alternatives to hebrew are there?

[14:30] <guifa> presently…. none :-)  (Hebrew is probably the most complicated of the calendars so I tackled it first ha).  But near future, a dozen, long term, probably three dozen

[14:31] <sena_kun> then :$calendar you can work with sounds wiser

[14:31] <sena_kun> I don't know how is it done internally, but it sounds strange to me that you are saying they are the same from code maintanence perspective

[14:32] <sena_kun> e.g. this...

[14:32] <sena_kun> m: sub a(:$a, :$b, :$c) { with $a { 1.say} orwith $b { 2.say } orwith $c {3.say} }; a(:a);

[14:32] <camelia> rakudo-moar 6c35cef60: OUTPUT: «1␤»

[14:32] <sena_kun> or

[14:32] <Doc_Holliwood> when I look at all the solutions for the current challenge, it seems people have no idea `react / whenever` are in the language

[14:33] <Doc_Holliwood> everybody uses Promises or even `sleep`

[14:33] <sena_kun> m: sub a(:$d) { my %h = :1a, :2b, :3c; say %h{$d}; }; a(:d<a>);

[14:33] <camelia> rakudo-moar 6c35cef60: OUTPUT: «1␤»

[14:33] <sena_kun> the second one seems a lot more scale-able to me

[14:34] <sena_kun> guifa, I mean, you can have three dozens of named arguments... but this does not sound very cool to me

[14:35] <sena_kun> and performance-wise too, because you either have to init a single variable or three dozens of them, even when only one is used

[14:35] * sena_kun votes for `Intl::Date.new($gregorian, :calendar<hebrew>)`

[14:36] <guifa> sena_kun: the way I saw it, the first method just means lots of multisubs: method new(Date $g, :$hebrew! where True), or even slurping *%s and grabbing the key 

[14:37] <sena_kun> still probably more dispatch and possibly boilerplate

[14:39] <sena_kun> *% option is in the middle, maybe

[14:40] <cpan-p6> New module released to CPAN! Slang::Subscripts (0.0.2) by 03ELIZABETH

[14:40] <sena_kun> but it opens the door for bugs with wrong named arguments passed silently. it might be viewed as not a big deal, but I like to avoid that

[14:40] <sena_kun> m: sub foo(*%foo) { say %foo<a> }; foo(:42a, :24hours);

[14:40] <camelia> rakudo-moar 6c35cef60: OUTPUT: «42␤»

[14:41] <sena_kun> m: sub foo(:$a) { say $a }; foo(:42a, :24hours);

[14:41] <camelia> rakudo-moar 6c35cef60: OUTPUT: «Unexpected named argument 'hours' passed␤  in sub foo at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[14:41] *** Xliff joined
[14:42] <Xliff> o/

[14:42] <sena_kun> o/

[14:45] *** _jrjsmrtn left
[14:46] <chloekek> p6: sub 🤷 { (*) }

[14:46] <camelia> rakudo-moar 6c35cef60: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Missing block␤at <tmp>:1␤------> 3sub7⏏5 🤷 { (*) }␤    expecting any of:␤        new name to be defined␤»

[14:46] <chloekek> p6: sub term:<🤷> { (*) }

[14:46] <camelia> rakudo-moar 6c35cef60: ( no output )

[14:46] *** __jrjsmrtn__ joined
[14:46] <chloekek> p6: sub term:<🤷> { (*) }; say 🤷

[14:46] <camelia> rakudo-moar 6c35cef60: OUTPUT: «*␤»

[14:47] <chloekek> p6: sub term:<🤷> { (*) }; say 🤷🏽‍♀️

[14:47] <camelia> rakudo-moar 6c35cef60: OUTPUT: «5===SORRY!5===␤Argument to "say" seems to be malformed␤at <tmp>:1␤------> 3sub term:<🤷> { (*) }; say7⏏5 🤷🏽‍♀️␤Bogus postfix␤at <tmp>:1␤------> 3sub term:<🤷> { (*) }; say 7⏏5🤷🏽‍♀️␤    expectin…»

[14:47] <chloekek> Is there an easy way to define all skin tone and gender variations of the emoji to be the same term?

[14:51] <guifa> chloekek: maybe with a slang?  From a unicode perspective, an undefined-toned man shrugging, a white man shrugging, a black man shrugging, and a black woman shrugging are as a different as a, á, à, À — which are all recognized as different by Perl 6

[14:54] <guifa> sena_kun: Now that I’m thinking about it, they could coexist nicely if I use *%s.  I could just call samewith $gregorian, %s.keys[0]; and in the main :$calendar one there should be a catch for an unknown calendar type anyways with a hard fail for unknown calendar type

[14:55] <cpan-p6> New module released to CPAN! Algorithm::LibSVM (0.0.6) by 03TITSUKI

[14:56] <sena_kun> guifa, if you are not pedantic enough to be concerned with the thing I described (as in, *% silencing wrong nameds), then the way you see fitting is best. :)

[14:59] <guifa> fair ha

[14:59] * guifa just hates line noise whenever possible :-)

[14:59] <guifa> But I think I can have it catch and bomb on wrong nameds 

[15:00] <sena_kun> how does the second approach add noise?

[15:05] * guifa is thinking from user’s perspective

[15:05] <guifa> Intl::Date.new(Date.today, :calendar<gregorian>) vs Intl::Date(Date.today, :gregorian)

[15:06] * guifa is probably overthinking all of this anyways

[15:07] <chloekek> guifa: thought so.

[15:07] <chloekek> Might be sufficiently easy with EXPORT.

[15:16] *** gabiruh_ left
[15:28] *** epony left
[15:56] *** agentzh left
[15:58] *** agentzh joined
[15:58] *** agentzh left
[15:58] *** agentzh joined
[16:03] *** epony joined
[16:15] *** jmerelo joined
[16:15] *** krychu joined
[16:18] *** khisanth_ left
[16:23] *** veesh joined
[16:25] *** wamba joined
[16:32] *** khisanth_ joined
[16:45] *** cinch left
[16:49] *** cinch joined
[17:10] <SmokeMachine> .tell ugexe Hi, I'm thinking of PRing something like this on zef (it still is using `no precompilation` and I'll try to fiz that before PRing) that way I think it will be easier to use zef inside of other code... what do you think about that? https://github.com/FCO/zef/commit/1c95922ad6897a302f76e5bf8c1fc7b6d7c220e0

[17:10] <tellable6> SmokeMachine, No! It wasn't me! It was the one-armed man! Backtrace: https://gist.github.com/6bab10d57e37f2824a388e4468dd5b58

[17:11] <SmokeMachine> s/fiz/fix/

[17:11] <AlexDaniel> .tell timotimo test ` test

[17:11] <tellable6> AlexDaniel, No! It wasn't me! It was the one-armed man! Backtrace: https://gist.github.com/7e493867739fb8223ab1fc1178badf21

[17:11] <AlexDaniel> SmokeMachine: ok can you please try again without ` ? :)

[17:11] <AlexDaniel> I'll fix that later

[17:12] <AlexDaniel> .tell timotimo test test

[17:12] <tellable6> AlexDaniel, No! It wasn't me! It was the one-armed man! Backtrace: https://gist.github.com/2ed51e51fa9ebf065161aa7fe33f360a

[17:12] <AlexDaniel> ok, well…

[17:12] <AlexDaniel> SmokeMachine: nevermind, it's currently broken

[17:13] <SmokeMachine> :)

[17:13] <SmokeMachine> AlexDaniel: what about a new feature: s/// to fix the last message?

[17:13] <AlexDaniel> SmokeMachine: that'd be awesome!

[17:15] *** Kaiepi left
[17:16] *** Kaiepi joined
[17:41] <xinming_> in object, the "self" is a keyword or a function?

[17:42] <xinming_> It seems, to me, that self is like a function where it return an dynamic container which contains the current class.

[17:45] *** kybr left
[17:46] *** kybr joined
[17:46] <chloekek> xinming_: it's special syntax: https://github.com/rakudo/rakudo/blob/6c35cef60e03ef805311accaa564e29d6e326d6a/src/Perl6/Grammar.nqp#L3006

[17:47] <SmokeMachine> .tell SmokeMachine am I crazy?

[17:47] <tellable6> SmokeMachine, I'll pass that message to your doctor

[17:48] <xinming_> Thanks

[17:48] *** Kaiepi left
[17:49] <xinming_> Is it possible to add a customized keyword like self in rakudo at runtime?

[17:50] <xinming_> let's say, we now have   self.object-method         another-self-like-kw.object-method

[17:51] *** Kaiepi joined
[17:55] <Geth_> ¦ doc: 78708c44ef | (JJ Merelo)++ | doc/Language/grammars.pod6

[17:55] <synopsebot> Link: https://doc.perl6.org/language/grammars

[17:55] <Geth_> ¦ doc: Changes a bit the example

[17:55] <Geth_> ¦ doc: 

[17:55] <Geth_> ¦ doc: So that it can be expanded to fulfill #1759

[17:55] <Geth_> ¦ doc: review: https://github.com/perl6/doc/commit/78708c44ef

[17:57] *** softmoth joined
[18:19] *** molaf left
[18:23] *** domidumont1 left
[18:23] *** domidumont joined
[18:26] *** khisanth_ left
[18:26] *** domidumont1 joined
[18:29] *** domidumont left
[18:29] *** domidumont1 left
[18:29] <AlexDaniel> u: \uD83E\uDD37\uD83C\uDFFD‍

[18:29] <unicodable6> AlexDaniel, U+005C REVERSE SOLIDUS [Po] (\)

[18:29] <unicodable6> AlexDaniel, U+0075 LATIN SMALL LETTER U [Ll] (u)

[18:29] <unicodable6> AlexDaniel, 25 characters in total: https://gist.github.com/53472d14c0b64b320aa768347ecfc3df

[18:29] <AlexDaniel> u: \uD83E \uDD37 \uD83C \uDFFD‍

[18:29] <unicodable6> AlexDaniel, U+D83E <surrogate-D83E> [Cs] (unencodable character)

[18:29] <unicodable6> AlexDaniel, U+DD37 <surrogate-DD37> [Cs] (unencodable character)

[18:29] <unicodable6> AlexDaniel, No! It wasn't me! It was the one-armed man! Backtrace: https://gist.github.com/fd224bbe055f9963bd9a58647ea1a4d1

[18:30] <AlexDaniel> timotimo: no idea what's going on but I have a feeling that JSON::Fast encoded something that it cannot decode later

[18:33] *** domidumont joined
[18:40] *** Kaiepi left
[18:40] *** domidumont left
[18:44] *** Kaiepi joined
[18:46] *** chloekek left
[18:50] *** khisanth_ joined
[18:58] *** jmerelo left
[19:23] *** ravenousmoose left
[19:29] *** krychu left
[19:30] *** krychu joined
[19:50] *** krychu left
[19:51] *** krychu joined
[19:53] *** krychu left
[20:00] *** krychu joined
[20:24] *** ChoHag left
[20:25] *** ChoHag joined
[20:35] *** Kaiepi left
[20:36] *** Kaiepi joined
[20:47] *** molaf joined
[20:53] *** sena_kun left
[20:54] <cpan-p6> New module released to CPAN! ORM::ActiveRecord (0.0.7) by 03GDONALD

[20:58] *** wamba left
[21:00] *** kylese left
[21:20] *** krychu left
[21:45] *** gtodd joined
[21:46] *** gtodd left
[21:48] *** webart joined
[21:48] <webart> is it true that perl (from perl 4 and 5 era) is an acronym?

[21:52] <sjn> No. People later made acronyms after the fact, but mostly for fun

[21:53] <sjn> the actual name is "Perl" (capital P, lowercase otherwise)

[21:55] <webart> hmm a romaji acronym for "raku"  =  rangeji anrakuna koka-teki umai   (commodious effective beautiful language)     

[21:57] <Juerd> That's often called a "backronym"

[21:57] <sjn> "Pathologically Eclectic Rubbish Lister" :)

[21:58] <webart> but I don't know japanese very well and got the romaji from a mess of katakana hiragana and kanji :-D  ... a japanese speakers said I was wrong  and that acronyms inromaji don't exist (they are not a native speaker)

[21:58] <webart> ランゲージ  安楽な 効果的 うまい   =~ rangeji anrakuna koka-teki umai   (commodious effective beautiful language)

[22:01] <webart> anyway the renaming thing is marketing and I hope if the name change happens that when I open up the REPL it says "Welcome to raku (Perl 6.d)" :-D  ... for years I logged into Solaris boxes that knew their inner sleves as SunOS :-D

[22:02] <webart> sort of a rose by any other name kinda thing ... 

[22:05] *** bazzaar joined
[22:05] <webart> and I think romaji acronyms *DO* exist .... https://japanese.stackexchange.com/a/71730

[22:07] *** softmoth left
[22:08] <Grinnz> any outward indication that it is "perl" will unfortunately defeat part of the purpose of the rename

[22:12] *** bazzaar left
[22:16] *** bazzaar joined
[22:23] *** bazzaar left
[22:23] *** softmoth joined
[22:36] *** lucasb left
[22:39] *** rainmanjam joined
[23:06] *** pecastro left
[23:13] *** Elronnd is now known as MoonChild

[23:13] *** MoonChild is now known as Moon_Child

[23:13] *** Moon_Child is now known as Moon_child

[23:19] *** Moon_child is now known as moon_child

[23:36] <AlexDaniel> timotimo: https://colabti.org/irclogger/irclogger_log/perl6?date=2019-10-06#l267

[23:37] <AlexDaniel> timotimo: that message

[23:37] <AlexDaniel> timotimo: this is how it was encoded: say \uD83E\uDD37\uD83C\uDFFD‍♀️

[23:37] <AlexDaniel> timotimo: note the ♀ character and also ZWJ before it

[23:37] <AlexDaniel> I guess it was supposed to turn them into \u sequences but didn't

[23:38] <AlexDaniel> .tell timotimo test

[23:38] <tellable6> AlexDaniel, No! It wasn't me! It was the one-armed man! Backtrace: https://gist.github.com/8c855c1ce29da85809b8fc3ac6416fc3

[23:38] <AlexDaniel> .tell timotimo test

[23:38] <tellable6> AlexDaniel, I'll pass your message to timotimo

[23:38] <AlexDaniel> “fixed”

[23:39] <AlexDaniel> timotimo: also it seems to have generated some weird escape codoes

[23:39] <AlexDaniel> codes*

[23:39] <Xliff> m: class Metamodel::myClass is Metamodel::ClassHOW { method compose package ($o, :$compiler_services) { samewith($o, :$compiler_services); say 'MYCLASS!'; } package EXPORTHOW { package DECLARE { constant class = Metamodel::myClass }; }; class A { }; A.new

[23:39] <camelia> rakudo-moar 6c35cef60: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Missing block␤at <tmp>:1␤------> 3 is Metamodel::ClassHOW { method compose7⏏5 package ($o, :$compiler_services) { sam␤»

[23:40] <AlexDaniel> .tell ugexe https://colabti.org/irclogger/irclogger_log/perl6?date=2019-10-06#l298

[23:40] <Xliff> m: class Metamodel::myClass is Metamodel::ClassHOW { method compose ($o, :$compiler_services) { samewith($o, :$compiler_services); say 'MYCLASS!'; } package EXPORTHOW { package DECLARE { constant class = Metamodel::myClass }; }; class A { }; A.new

[23:40] <camelia> rakudo-moar 6c35cef60: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Strange text after block (missing semicolon or comma?)␤at <tmp>:1␤------> 3 :$compiler_services); say 'MYCLASS!'; }7⏏5 package EXPORTHOW { package DECLARE { c␤    expecting any of:␤       …»

[23:40] <tellable6> AlexDaniel, I'll pass your message to ugexe

[23:40] <Xliff> m: class Metamodel::myClass is Metamodel::ClassHOW { method compose ($o, :$compiler_services) { samewith($o, :$compiler_services); say 'MYCLASS!'; }; package EXPORTHOW { package DECLARE { constant class = Metamodel::myClass }; }; class A { }; A.new

[23:40] <camelia> rakudo-moar 6c35cef60: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Missing block␤at <tmp>:1␤------> 3amodel::myClass }; }; class A { }; A.new7⏏5<EOL>␤    expecting any of:␤        statement end␤        statement modifier␤        statement modifier loo…»

[23:40] <Xliff> m: class Metamodel::myClass is Metamodel::ClassHOW { method compose ($o, :$compiler_services) { samewith($o, :$compiler_services); say 'MYCLASS!'; }; }; package EXPORTHOW { package DECLARE { constant class = Metamodel::myClass }; }; class A { }; A.new

[23:40] <camelia> rakudo-moar 6c35cef60: ( no output )

[23:41] <Xliff> m: class Metamodel::myClass is Metamodel::ClassHOW { method compose ($o, :$compiler_services) { samewith($o, :$compiler_services); say 'MYCLASS!'; }; }; package EXPORTHOW { package DECLARE { constant class = Metamodel::myClass }; }; class A { }; A.HOW.name.say

[23:41] <camelia> rakudo-moar 6c35cef60: OUTPUT: «Too few positionals passed; expected 2 arguments but got 1␤  in block <unit> at <tmp> line 1␤␤»

[23:41] <Xliff> m: class Metamodel::myClass is Metamodel::ClassHOW { method compose ($o, :$compiler_services) { samewith($o, :$compiler_services); say 'MYCLASS!'; }; }; package EXPORTHOW { package DECLARE { constant class = Metamodel::myClass }; }; class A { }; A.HOW.^name.say

[23:41] <camelia> rakudo-moar 6c35cef60: OUTPUT: «Perl6::Metamodel::ClassHOW␤»

[23:45] <Xliff> m: class Metamodel::myClass is Metamodel::ClassHOW { method compose ($o, :$compiler_services) { samewith($o, :$compiler_services); say 'MYCLASS!'; }; }; package EXPORTHOW { package DECLARE { constant class = Metamodel::myClass }; }; Metamodel::myClass.^mro.say

[23:45] <camelia> rakudo-moar 6c35cef60: OUTPUT: «((myClass) (ClassHOW) (Any) (Mu))␤»

[23:45] <Xliff> ^^ What am I doing wrong, here?

[23:50] <Xliff> m: class Metamodel::myClass is Metamodel::ClassHOW { method compose ($o, :$compiler_services) { samewith($o, :$compiler_services); say 'MYCLASS!'; }; }; package EXPORTHOW { constant class = Metamodel::myClass }; A.new

[23:50] <camelia> rakudo-moar 6c35cef60: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Undeclared name:␤    A used at line 1␤␤»

[23:50] <Xliff> m: class Metamodel::myClass is Metamodel::ClassHOW { method compose ($o, :$compiler_services) { samewith($o, :$compiler_services); say 'MYCLASS!'; }; }; package EXPORTHOW { constant class = Metamodel::myClass }; class A { }; A.new

[23:50] <camelia> rakudo-moar 6c35cef60: ( no output )

[23:50] <Xliff> m: class Metamodel::myClass is Metamodel::ClassHOW { method compose ($o, :$compiler_services) { samewith($o, :$compiler_services); say 'MYCLASS!'; }; }; package EXPORTHOW { constant class = Metamodel::myClass }; class A { }; A.HOW.^name.say

[23:50] <camelia> rakudo-moar 6c35cef60: OUTPUT: «Perl6::Metamodel::ClassHOW␤»

[23:51] <Xliff> m: class Metamodel::myClass is Metamodel::ClassHOW { method compose ($o, :$compiler_services) { samewith($o, :$compiler_services); say 'MYCLASS!'; }; }; my module EXPORTHOW { constant class = Metamodel::myClass }; class A { }; A.HOW.^name.say

[23:51] <camelia> rakudo-moar 6c35cef60: OUTPUT: «Perl6::Metamodel::ClassHOW␤»

[23:52] *** Doc_Holliwood left
[23:52] <Xliff> m: class Metamodel::myClass is Metamodel::ClassHOW { method compose ($o, :$compiler_services) { samewith($o, :$compiler_services); say 'MYCLASS!'; }; }; my module EXPORTHOW { constant class = Metamodel::myClass }; EXPORTHOW; class A { }; A.HOW.^name.say

[23:52] <camelia> rakudo-moar 6c35cef60: OUTPUT: «WARNINGS for <tmp>:␤Perl6::Metamodel::ClassHOW␤Useless use of constant value EXPORTHOW in sink context (line 1)␤»

[23:53] <Xliff> m: class Metamodel::myClass is Metamodel::ClassHOW { method compose ($o, :$compiler_services) { samewith($o, :$compiler_services); say 'MYCLASS!'; }; }; my module EXPORTHOW { constant class = Metamodel::myClass }; use EXPORTHOW

[23:53] <camelia> rakudo-moar 6c35cef60: OUTPUT: «===SORRY!===␤EXPORTHOW is a builtin type, not an external module␤»

