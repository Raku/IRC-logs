[00:00] *** vike left
[00:04] *** vike joined
[00:06] <vrurg> Xliff: I'm not totally sure, but EXPORTHOW would only if declared in a compunit.

[00:06] <vrurg> *would work

[00:06] <Xliff> vrurg: Figured as much.

[00:07] <Xliff> vrurg: It would be nice to be able to do everything you can with compunits in a REPL

[00:07] <vrurg> maybe something like module Foo { my module EXPORTHOW { } }; import Foo – would work? Not sure though.

[00:08] <Xliff> Oh! I keep forgetting about import. LOL!

[00:08] <Xliff> Anyway, this is an odd duck:

[00:08] <Xliff> "Type check failed in binding to parameter '$o'; expected Any but got A (?)"

[00:09] <Xliff> I thought Any accepted anything,.

[00:10] <vrurg> Xliff: no. Remember, there is Mu which is Perl6 root of everything.

[00:12] <Xliff> OK. So I'm trying to override Metamodel::ClassHOW.compose.

[00:12] <Xliff> And it's not doing what I'd expect the logical thing to be.

[00:13] <vrurg> Xliff: Why can't you do a trait and just apply a role to ClassHOW?

[00:13] <Xliff> "class Metamodel::myClass is Metamodel::ClassHOW { method compose ($o, :$compiler_services) {" <- the error is coming from the compose signature check. It's also taking a long time to run.

[00:15] <vrurg> Xliff: try looking at my AttrX::Mooish. I intercept compose with a mixin role.

[00:16] <Xliff> Ah! Thanks!

[00:17] <vrurg> But I don't think you could gain any additional performance. It's Perl6, signature check will be there.

[00:17] <vrurg> Ah, besides, compose can only be method compose(Mu);

[00:17] <Xliff> OH!

[00:18] <vrurg> Basically, typical signature for ClassHOW in Perl6 is compose(Mu \type, :$compiler-services)

[00:19] <Xliff> That's what I'm doing.

[00:19] <vrurg> Raw parameter speeds things up a bit because it doesn't cont/decont value.

[00:20] <vrurg> Perhaps the problem is $o which is Any but has to be Mu? Sorry if I'm not following well, but fighting a bug alongside. :)

[00:21] <Xliff> Ah. Hope you feel better. I am getting over one, too.

[00:21] <Xliff> I'm probably not explaining well, either.

[00:22] <vrurg> Basically, I understand the idea. But not sure if you really need to override all classes.

[00:23] <vrurg> Perhaps, if you want to go this way, it'd be better to declare another keywords? like my-class instead of ?

[00:23] <vrurg> of 'class'?

[00:23] <Xliff> Hrm... no. Want to change 'class' like Grammar::Debugger HAS to change 'grammar'

[00:24] <Xliff> Although that might be a decent compromise for the moment.

[00:25] <Xliff> Oooh! I like this approach!

[00:26] <vrurg> I briefly checked through Grammar/Actions – EXPORTHOW must work for class keyword anyway.

[00:26] <vrurg> What approach excactly? ;)

[00:27] <Xliff> Kinda viral. Applying a Mooish trait to an Attribute will attach a role to the implementing object's HOW.

[00:28] <vrurg> Glad I helped! :)

[00:28] <Xliff> :>

[00:29] *** Doc_Holliwood joined
[00:46] <Xliff> vrurg: Are roles composed independently of classes?

[00:47] <vrurg> yes, if I get you correctly. They have own compose method.

[00:47] <vrurg> Basically, any typeobject of composable archetype has compose.

[00:48] *** Doc_Holliwood left
[00:50] <Xliff> vrurg: OK. Tell me if I'm crazy -- https://gist.github.com/Xliff/103cb6c06a6f565194bf3fcc6a16b00a

[00:51] <Xliff> I'm thinking the fix for my issue is to defer alias additions until the class is composed.

[00:52] <vrurg> Xliff: no, it's better if you add a method before compose.

[00:53] <Xliff> I am. Immediately before.

[00:53] <SmokeMachine> https://t.co/fmMwEwPCme?amp=1

[00:53] <vrurg> But, you might not get the right method in method.package. 

[00:53] <Xliff> Yeah. Just thought of that.

[00:53] <Xliff> But it's resolvable if I do a deep dive through ^roles and ^mro, yes?

[00:53] <vrurg> Xliff: see what you get in there. Perhaps you'd need to use $*PACKAGE which is the being compiled package.

[00:54] <Xliff> Ah!

[00:55] <Xliff> Something like this? (updated)

[00:55] <vrurg> Due to the uncertain order of things at compile time, attributes doesn't get theit package set correctly. Same could happen to methods.

[00:55] * vrurg hopes to get his hands on this issue at some point.

[00:56] <Xliff> Or is $*PACKAGE the FILE name and not the CLASS name?

[00:56] <Xliff> (assiming compunit is a unit class)

[00:57] <vrurg> $*PACKAGE will be your class because you're applying the trait to a method.

[00:57] <Xliff> OK

[00:57] <vrurg> See what you have in method.package and I'm afraid it wouldn't be the class the method belongs to. This is also where you have to use $*PACKAGE.

[00:58] <vrurg> Also, if you apply the trait to more than one method – you'll mixin your role more than once into the same HOW object.

[00:58] <Xliff> so is $*PACKAGE =:= ::?CLASS?

[00:58] <vrurg> Yes, at this point of time.

[00:59] <vrurg> Remember, that after all module, class, role – they're all packages.

[00:59] <Xliff> So then it's $*PACKAGE.^name, right?

[01:01] <vrurg> Xliff: actually, yes.

[01:02] <vrurg> SmokeMachine: you mean no more additional List is needed?

[01:02] <vrurg> SmokeMachine: I mean, coercion of .^all output

[01:02] <Xliff> vrurg: OK. Updated.

[01:04] <vrurg> Xliff: but you still miss the point about method.package.HOW does MyHOW. method.package could be not what you expect. I don't know exactly if I'm right but I highly suspect it is.

[01:04] <SmokeMachine> vrurg: sorry? I didn’t understand...

[01:05] <vrurg> SmokeMachine: I always had to do Model.^all.Seq or otherwise it didn't work.

[01:06] <SmokeMachine> vrurg: for Set and Bag it did work (if I’m not wrong) but now it run specific query for each...

[01:07] <vrurg> Ah, that's the point! Anyway, a most certainly great thing! Congrats!

[01:08] <SmokeMachine> vrurg: and I’ve also fixed a .classify bug after a .map...

[01:09] <vrurg> SmokeMachine: not sure what is it about. But, anyway, I have too little time left. Need to focus on the bug. :(

[01:10] *** molaf left
[01:12] *** cpan-p6 left
[01:13] *** cpan-p6 joined
[01:13] *** cpan-p6 left
[01:13] *** cpan-p6 joined
[01:18] <Xliff> vrurg: Oh! Those shouold be $*PACKAGE as well. 

[01:19] <vrurg> Xliff: and don't forget to check if $*PACKAGE.HOW ~~ MyHOW before applying MyHOW

[01:19] <Xliff> Heh. Thanks!

[01:22] <vrurg> welcome! :)

[01:22] <Xliff> OK. Updated again.

[01:23] *** molaf joined
[01:48] *** wamba joined
[02:20] <Xliff> vrurg: Well... $*PACKAGE didn't work

[02:20] <Xliff> It took the name of the role, rather than the name of the class. I will have to do a deep dive.

[02:21] <vrurg> Of course and it will be always that way. Because method belongs to the role at compile time. 

[02:21] <Xliff> Yeah. Forgot

[02:22] <vrurg> Xliff: unfortunately, there is no yet a way to catch the moment when role is being applied to a class. 

[02:23] <vrurg> But as a first approach you can try intercept specialize method on PatametericRoleHOW. 

[02:23] <vrurg> ClassHOW compise calls it before applying concretized role to itself.

[02:23] *** Cabanossi left
[02:29] <Xliff> Yeah. That's what's happening.

[02:29] <Xliff> At class compose time, it doesn't look to have any roles.

[02:29] <Xliff> I would think the roles would be there prior to compose.

[02:34] *** Cabanossi joined
[02:37] <Xliff> .^roles_to_compose(\obj) returns nothing...

[02:38] <Xliff> Ah! I see what you meant by .specialize.

[02:40] <vrurg> roles_to_compose list gets emptied by ClassHOW compose method.

[02:40] <Xliff> Yeah, but I have role overriding ClassHOW.compose

[02:40] <Xliff> it calls nextsame at the end.

[02:41] <vrurg> I'm just sharing some knowledge. :)

[02:41] <Xliff> Ah.

[02:41] <Xliff> I'm just confused why it is empty before ClassHOW.compose

[02:41] <vrurg> BTW, AttrX::Mooish does it all. AttrXMooishRoleHOW actually does override specialize.

[02:42] <Xliff> Looking.

[02:42] <vrurg> Before? Hm, it shouldn't be. 

[02:42] <Xliff> AHHH!

[02:44] <vrurg> BTW, note that most likely you'd have to postpone actual aliasing and do it not when the trait is called but when class compose is executed.

[02:44] <vrurg> This compilcates things because I'd have to iterate over the methods and extract those you've marked for processing.

[02:44] <vrurg> s/I'd/You'd/

[02:45] <Xliff> Hehe

[02:45] <Xliff> That's what I'm doing NOW

[02:45] <Xliff> Postponing until class compose

[02:45] <vrurg> time for supper. cu tomorrow!

[02:45] <vrurg> o/

[02:45] <Xliff> o/

[03:01] *** ravenousmoose joined
[03:07] *** ravenousmoose left
[03:07] *** ravenousmoose joined
[03:07] <Xliff> m: class A {}; say A.WHO.^name

[03:07] <camelia> rakudo-moar 6c35cef60: OUTPUT: «Stash␤»

[03:20] *** japhb left
[03:33] *** softmoth left
[04:02] *** wamba left
[04:04] *** ravenousmoose left
[04:13] *** cinch_ joined
[04:13] *** cinch left
[04:17] <Xliff> m: Int.gist.^is_dispatcher.say

[04:17] <camelia> rakudo-moar 6c35cef60: OUTPUT: «No such method 'is_dispatcher' for invocant of type 'Perl6::Metamodel::ClassHOW'␤  in block <unit> at <tmp> line 1␤␤»

[04:17] <Xliff> m: Int.^find_method('gist').is_dispatcher.say

[04:17] <camelia> rakudo-moar 6c35cef60: OUTPUT: «True␤»

[04:19] *** Cabanossi left
[04:20] *** japhb joined
[04:23] *** agentzh left
[04:25] *** agentzh joined
[04:27] *** rainmanjam left
[04:30] *** Cabanossi joined
[04:37] *** Doc_Holliwood joined
[05:11] *** molaf left
[05:14] *** jmerelo joined
[05:35] <xinming_> Is it possible to make perl6 like javascript, to dynamic initialize the self?

[05:36] <xinming_> Something like,     code.apply($self-object, ['arg1', 'arg2', 'arg3']);

[05:38] <Xliff> xinming: I don't know exactly what you mean. 

[05:38] <Xliff> Do you have a use case?

[05:39] <xinming_> In js, we can have the 'this' to be intialized to a different object. 

[05:40] <xinming_> let's say,    function test () { console.log(this); };     test.apply("Hello");      test.apply([]);       <---  In this case, the this will be initialized to a string, and a array according to the arg passed.

[05:41] <Xliff> Ah.

[05:41] <xinming_> What I mean is, wether it's possible to call a method in perl6 like this, that we provide different self to the method.

[05:43] <Xliff> m: class A { has $!value; submethod BUILD (:$!value) {}; method new($a) { self.bless( value => $a ) }; method test { $!value.say }; }: say A.new('Hello').test; say A.new([]).test

[05:43] <camelia> rakudo-moar 6c35cef60: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Confused␤at <tmp>:1␤------> 3 $a ) }; method test { $!value.say }; }:7⏏5 say A.new('Hello').test; say A.new([]).␤    expecting any of:␤        colon pair␤»

[05:43] <Xliff> m: class A { has $!value; submethod BUILD (:$!value) {}; method new($a) { self.bless( value => $a ) }; method test { $!value.say }; }; say A.new('Hello').test; say A.new([]).test

[05:43] <camelia> rakudo-moar 6c35cef60: OUTPUT: «Hello␤True␤[]␤True␤»

[05:43] <Xliff> m: class A { has $!value; submethod BUILD (:$!value) {}; method new($a) { self.bless( value => $a ) }; method test { $!value.say }; }; A.new('Hello').test; A.new([]).test

[05:43] <camelia> rakudo-moar 6c35cef60: OUTPUT: «Hello␤[]␤»

[05:44] <Xliff> xinming_: ^^ Something like that?

[05:45] <xinming_> Nope

[05:46] <Xliff> Still confused, then. 

[05:46] <Xliff> Why do you need $!value to be self?

[05:46] <xinming_> class T { method x () { self.perl.say; } };    T.x.apply("abc");     T.x.apply([]);         <---   the self here will be changed to "abc"  or []

[05:47] <xinming_> it's like multi, but not truely multi

[05:47] <Xliff> Again, you aren't sufficiently explainingh why X can't use an attribute instead of self

[05:48] <Xliff> Javascript's 'this' is an OO mutt.

[05:48] <Xliff> This is so that Javascript can BE OO

[05:48] <xinming_> Xliff: because I wish that all that class methods will be changed to another "object"

[05:49] <xinming_> It's a bit like  localize the  self    before callign a method

[05:49] <Xliff> But again. why do you need that to be self?

[05:49] <Xliff> You're basically asking for an Object without a defined type. Perl6 doesn't do that.

[05:49] <Xliff> "self" represents either the Class object, or the Class instance.

[05:49] <xinming_> Yea, that's what I'm asking.

[05:50] <xinming_> IIRC, we can use multi to achieve that.

[05:50] <Xliff> If you need something to be mutable like this, then you should use an attribute.

[05:50] <xinming_> Ok.

[05:50] <Xliff> And yes, you can use multi's.

[05:50] <xinming_> Will think a different way to achieve this.

[05:50] <Xliff> OK.

[05:54] <Xliff> m: class A { multi method x (Str $a) { sau 

[05:54] <camelia> rakudo-moar 6c35cef60: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Missing block␤at <tmp>:1␤------> 3class A { multi method x (Str $a) { sau7⏏5<EOL>␤    expecting any of:␤        statement end␤        statement modifier␤        statement modifier loop␤»

[05:54] <Xliff> m: class A { multi method x (Str $a) { say

[05:54] <camelia> rakudo-moar 6c35cef60: OUTPUT: «5===SORRY!5===␤Argument to "say" seems to be malformed␤at <tmp>:1␤------> 3class A { multi method x (Str $a) { say7⏏5<EOL>␤Missing block␤at <tmp>:1␤------> 3class A { multi method x (Str $a) { say7⏏5<EOL>␤    expecting an…»

[05:56] <Xliff> m: class A { multi method x (Str $a) { say 'Str handled here'; }; multi method x (Int $a) { say 'Int handled here' }; multi method x (%a) { say 'Hash handled here'; }; }; A.x('Hello'); A.x(42); A.x( { me => 'bleh' });

[05:56] <camelia> rakudo-moar 6c35cef60: OUTPUT: «Str handled here␤Int handled here␤Hash handled here␤»

[05:56] <Xliff> xinming_: ^^ Something more like that?

[05:56] <Xliff> It has the advantage of not needing to be instantiated.

[06:02] *** Doc_Holliwood left
[06:08] <Xliff> xinming_: If you want it so that you can apply() a value before calling methods on X, like so that A.apply("abc").x says "abc", then you can do that like this:

[06:10] <Xliff> m: class A { has $!value; method apply($a) { $!value = $a; self }; method x { $!value.perl.say }; }; A.new.apply("abc}

[06:10] <camelia> rakudo-moar 6c35cef60: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Unable to parse expression in double quotes; couldn't find final '"' (corresponding starter was at line 1)␤at <tmp>:1␤------> 3$!value.perl.say }; }; A.new.apply("abc}7⏏5<EOL>␤    expecting …»

[06:10] *** DarthGandalf left
[06:10] <Xliff> m: class A { has $!value; method apply($a) { $!value = $a; self }; method x { $!value.perl.say }; }; A.new.apply("abc)

[06:10] <camelia> rakudo-moar 6c35cef60: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Unable to parse expression in double quotes; couldn't find final '"' (corresponding starter was at line 1)␤at <tmp>:1␤------> 3$!value.perl.say }; }; A.new.apply("abc)7⏏5<EOL>␤    expecting …»

[06:10] <Xliff> m: class A { has $!value; method apply($a) { $!value = $a; self }; method x { $!value.perl.say }; }; A.new.apply("abc")

[06:10] *** domidumont joined
[06:10] <camelia> rakudo-moar 6c35cef60: ( no output )

[06:10] <Xliff> m: class A { has $!value; method apply($a) { $!value = $a; self }; method x { $!value.perl.say }; }; A.new.apply("abc").x

[06:10] <camelia> rakudo-moar 6c35cef60: OUTPUT: «"abc"␤»

[06:10] <Xliff> For that to work without instantiation....

[06:11] <Xliff> m: class A { my $value; method apply($a) { $value = $a; self }; method x { $value.perl.say }; }; A.apply("abc").x

[06:11] <camelia> rakudo-moar 6c35cef60: OUTPUT: «"abc"␤»

[06:11] <Xliff> But then you can't hold "abc" and then have another A that is (1, 2, 3) because $value exists as a class attribute

[06:13] *** DarthGandalf joined
[06:28] <rba> currently trying to to trouble-shoot modules.perl6.org. Seems that the dists from CPAN not got unpacked. Any idea?

[06:29] *** wamba joined
[06:31] *** jmerelo left
[06:37] <SmokeMachine> m: my &meth = Int.^lookup(“is-prime”); say 42.&meth

[06:37] <camelia> rakudo-moar 6c35cef60: OUTPUT: «False␤»

[06:38] <SmokeMachine> xinming_: were you asking for something like this ^^?

[06:46] <Xliff> SmokeMachine: I don't think that's it. For one thing you need &meth from a type lookup.

[06:52] <El_Che> https://insights.stackoverflow.com/survey/2019 <- it may interest some people here

[07:00] *** wamba left
[07:04] *** wamba joined
[07:21] *** p9s``` left
[07:21] *** p9s``` joined
[07:27] *** abraxxa joined
[07:31] *** abraxxa left
[07:32] *** abraxxa joined
[07:36] <Xliff> WOO HOO!!!

[07:36] * Xliff found a solution for https://github.com/lizmat/Method-Also/issues/1

[07:40] *** zakharyas joined
[07:41] *** sena_kun joined
[07:52] <xinming_> m: method test { self.perl.say; }; 4.&test; "Hello".&test;

[07:52] <camelia> rakudo-moar 6c35cef60: OUTPUT: «5===SORRY!5===␤Undeclared routine:␤    test used at line 1␤␤Other potential difficulties:␤    Useless declaration of a has-scoped method in mainline (did you mean 'my method test'?)␤    at <tmp>:1␤    ------> 3method7⏏5 test { s…»

[07:53] <xinming_> SmokeMachine: I want something like this. :-)

[07:53] <xinming_> m: my method test { self.perl.say; }; 4.&test; "Hello".&test;

[07:53] <camelia> rakudo-moar 6c35cef60: OUTPUT: «4␤"Hello"␤»

[07:53] <xinming_> and I have to say, I never thought this could work.

[07:53] <xinming_> :-)

[07:53] <xinming_> Thanks for your example.

[07:54] <Xliff> m: sub test ($a) { $a.say }; 4.&test; "Hello".&test

[07:54] <camelia> rakudo-moar 6c35cef60: OUTPUT: «4␤Hello␤»

[07:55] <Xliff> xinming_: ^^^ There is no "self" in that case. Just the invocant, which could be anything.

[07:55] <xinming_> I'm still trying something else.

[07:58] <xinming_> m: class A { has $.a = 3 is rw; method t { $!a += 10; $!a.perl.say; }; }; my $x = A.new(:a(5));  my $y = A.new(:a(6)); my &meth = T.^lookup('t');  $x.&meth(); $y.&meth();

[07:58] <camelia> rakudo-moar 6c35cef60: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Two terms in a row␤at <tmp>:1␤------> 3class A { has $.a = 37⏏5 is rw; method t { $!a += 10; $!a.perl.s␤    expecting any of:␤        infix␤        infix stopper␤        postfix␤    …»

[07:59] <xinming_> m: class A { has $.a = 3 is rw; method t { $!a += 10; $!a.perl.say; }; };

[07:59] <camelia> rakudo-moar 6c35cef60: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Two terms in a row␤at <tmp>:1␤------> 3class A { has $.a = 37⏏5 is rw; method t { $!a += 10; $!a.perl.s␤    expecting any of:␤        infix␤        infix stopper␤        postfix␤    …»

[07:59] <xinming_> m: class A { has $.a is rw = 3; method t { $!a += 10; $!a.perl.say; }; }; my $x = A.new(:a(5));  my $y = A.new(:a(6)); my &meth = T.^lookup('t');  $x.&meth(); $y.&meth();

[07:59] <camelia> rakudo-moar 6c35cef60: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Undeclared name:␤    T used at line 1␤␤»

[07:59] <xinming_> m: class A { has $.a is rw = 3; method t { $!a += 10; $!a.perl.say; }; }; my $x = A.new(:a(5));  my $y = A.new(:a(6)); my &meth = A.^lookup('t');  $x.&meth(); $y.&meth();

[07:59] <camelia> rakudo-moar 6c35cef60: OUTPUT: «15␤16␤»

[07:59] *** kensanata joined
[07:59] <xinming_> Xliff: This is what I want.

[08:00] <xinming_> I want the "self" to be referenced dynamically, but also able to reference their values too.

[08:00] <xinming_> *their attributes*

[08:01] <xinming_> m: class A { has $.a is rw = 3; method t { $!a += 10; $!a.perl.say; }; }; class B { has $.a = 4; }; my $x = B.new(:a(5));  my $y = B.new(:a(6)); my &meth = A.^lookup('t');  $x.&meth(); $y.&meth();

[08:01] <camelia> rakudo-moar 6c35cef60: OUTPUT: «Type check failed in binding to parameter '<anon>'; expected A but got B (B.new(a => 5))␤  in method t at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[08:01] <xinming_> m: class A { has $.a is rw = 3; method t { $!a += 10; $!a.perl.say; }; }; class B is A { }; my $x = B.new(:a(5));  my $y = B.new(:a(6)); my &meth = A.^lookup('t');  $x.&meth(); $y.&meth();

[08:01] <camelia> rakudo-moar 6c35cef60: OUTPUT: «15␤16␤»

[08:07] <SmokeMachine> m: class A { has $.a is rw = 3; method t { $!a += 10; $!a.perl.say; }; }; class B is A { }; my $x = B.new(:a(5));  my $y = B.new(:a(6)); $x.t; $y.t # xinming_, why not call the method?

[08:07] <camelia> rakudo-moar 6c35cef60: OUTPUT: «15␤16␤»

[08:08] <xinming_> SmokeMachine: Because I want to provide these methods as callbacks

[08:08] <SmokeMachine> m: class A { has $.a is rw = 3; method t { $!a += 10; $!a.perl.say; }; }; class B is A { }; my $x = B.new(:a(5));  my $y = B.new(:a(6)); my $meth = "t"; $x."$meth"(); $y."$meth"() # xinming_, or do that by the name?

[08:08] <camelia> rakudo-moar 6c35cef60: OUTPUT: «15␤16␤»

[08:08] <xinming_> I'm still trying

[08:09] <SmokeMachine> hum...

[08:10] <xinming_> m: sub t { $!a += 10; $!a.perl.say; }; }; class A { has $.a is rw = 3; }; my $x = A.new(:a(5));  my $y = A.new(:a(6));   $x.&t(); $y.&t();

[08:10] <camelia> rakudo-moar 6c35cef60: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Variable $!a used where no 'self' is available␤at <tmp>:1␤------> 3sub t { $!a7⏏5 += 10; $!a.perl.say; }; }; class A { ha␤»

[08:10] <xinming_> m: my method t { $!a += 10; $!a.perl.say; }; }; class A { has $.a is rw = 3; }; my $x = A.new(:a(5));  my $y = A.new(:a(6));   $x.&t(); $y.&t();

[08:10] <camelia> rakudo-moar 6c35cef60: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Cannot understand $!a in this context␤at <tmp>:1␤------> 3my method t { $!a7⏏5 += 10; $!a.perl.say; }; }; class A { ha␤»

[08:10] <SmokeMachine> m: sub bla(&what-to-do) { say 42.&what-to-do }; bla Int.^lookup: "is-prime" # xinming_: something like this?

[08:10] <camelia> rakudo-moar 6c35cef60: OUTPUT: «False␤»

[08:10] <xinming_> Nope;

[08:11] <xinming_> I want to privde the code like that.

[08:12] <SmokeMachine> m: sub t { .a += 10; .a.perl.say; }; }; class A { has $.a is rw = 3; }; my $x = A.new(:a(5));  my $y = A.new(:a(6));   $x.&t(); $y.&t();

[08:12] <camelia> rakudo-moar 6c35cef60: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Unexpected closing bracket␤at <tmp>:1␤------> 3sub t { .a += 10; .a.perl.say; }; 7⏏5}; class A { has $.a is rw = 3; }; my $x␤»

[08:13] *** reach_satori left
[08:14] <SmokeMachine> m: sub t($_) { .a += 10; .a.perl.say; }; class A { has $.a is rw = 3; }; my $x = A.new(:a(5));  my $y = A.new(:a(6)); $x.&t; $y.&t

[08:14] <camelia> rakudo-moar 6c35cef60: OUTPUT: «15␤16␤»

[08:15] <SmokeMachine> m: my &t = method { self.a += 10; self.a.perl.say; }; class A { has $.a is rw = 3; }; my $x = A.new(:a(5));  my $y = A.new(:a(6)); $x.&t; $y.&t

[08:15] <camelia> rakudo-moar 6c35cef60: OUTPUT: «15␤16␤»

[08:18] <xinming_> SmokeMachine: Is it possible to convert a "sub" into a method?

[08:18] <xinming_> I mean a code block

[08:18] <xinming_> let's say,   my &.code = -> {  self.a += 10; self.a.perl.say; };

[08:18] <xinming_> soemthing like that.

[08:19] <xinming_> or, we'll have to use the method

[08:19] <xinming_> my &.code = method { };

[08:30] <SmokeMachine> why do you need to use self? isn't $_ good enough?

[08:31] <Xliff> xinming_: See? ;>

[08:31] <SmokeMachine> m: my &t = { .a += 10; .a.perl.say; }; class A { has $.a is rw = 3; }; my $x = A.new(:a(5));  my $y = A.new(:a(6)); $x.&t; $y.&t

[08:31] <camelia> rakudo-moar 6c35cef60: OUTPUT: «15␤16␤»

[08:31] <xinming_> needs to be out for a while, talk to you later. :-)

[08:31] <Xliff> o/

[08:32] <SmokeMachine> o/

[08:32] <xinming_> SmokeMachine: yea, $_ is the thing I consider. i'm still think about it though

[08:37] *** wamba left
[08:38] *** dakkar joined
[08:49] *** reach_satori joined
[08:59] *** ChoHag left
[09:02] *** cinch_ is now known as cinch

[09:02] *** p9s```` joined
[09:02] *** cinch left
[09:02] *** cinch joined
[09:05] *** p9s``` left
[09:05] *** wamba joined
[09:18] *** cinch left
[09:19] *** Cabanossi left
[09:23] *** Cabanossi joined
[09:24] *** molaf joined
[09:32] *** molaf left
[09:43] *** p9s```` left
[09:43] *** p9s```` joined
[09:47] *** bazzaar joined
[09:53] *** cgfbee left
[09:53] *** pat_js joined
[10:11] *** ChoHag joined
[10:13] *** reach_satori_ joined
[10:15] *** Guest93 joined
[10:16] *** reach_satori left
[10:16] *** p9s```` left
[10:17] *** p9s```` joined
[10:23] <kawaii> Are there any inotify bindings for P6? Google failed me.

[10:24] <kawaii> Need to monitor a file for changes and do something `whenever` that happens.

[10:26] <SmokeMachine> m: start react whenever ".".watch { .say }; "./bla.test".IO.spurt: "test"; sleep 1

[10:26] <camelia> rakudo-moar 6c35cef60: OUTPUT: «Unhandled exception in code scheduled on thread 4␤Failed to open file /home/camelia/bla.test: Permission denied␤  in block <unit> at <tmp> line 1␤␤»

[10:27] <SmokeMachine> m: start react whenever "/tmp".watch { .say }; "/tmp/bla.test".IO.spurt: "test"; sleep 1

[10:27] <camelia> rakudo-moar 6c35cef60: OUTPUT: «Unhandled exception in code scheduled on thread 4␤A react block:␤  in code  at <tmp> line 1␤␤Died because of the exception:␤    No such method 'watch' for invocant of type 'Str'. Did you mean any of these?␤        batch␤        match␤ …»

[10:27] <SmokeMachine> m: start react whenever "/tmp".IO.watch { .say }; "/tmp/bla.test".IO.spurt: "test"; sleep 1

[10:27] <camelia> rakudo-moar 6c35cef60: OUTPUT: «/tmp/bla.test: FileChanged␤<tmp>: FileChanged␤»

[10:27] <SmokeMachine> kawaii: ^^

[10:27] <kawaii> Ooooo that looks like it'll work

[10:28] <kawaii> Thank you SmokeMachine!

[10:28] <SmokeMachine> kawaii: np

[10:34] *** wamba left
[10:36] *** bazzaar left
[10:37] *** bazzaar joined
[10:38] *** bazzaar left
[10:40] *** Maylay left
[10:46] *** wamba joined
[10:46] *** reach_satori joined
[10:46] *** ChoHag left
[10:47] *** reach_satori_ left
[10:58] *** isBEKaml joined
[10:58] *** zakharyas left
[10:59] *** isBEKaml left
[11:00] *** zakharyas joined
[11:10] *** pat_js left
[11:24] <SmokeMachine> Xliff: but that's the same as `%results.values.map({ <complex function> if <some condition>})`, right?

[11:26] *** pmurias joined
[11:26] <SmokeMachine> m: say (^10).map({ do if .is-prime { say "here"; $_ * 2 }}).head

[11:26] <camelia> rakudo-moar 6c35cef60: OUTPUT: «here␤4␤»

[11:27] <SmokeMachine> m: say (^10).map({ do if .is-prime { say "here"; $_ * 2 }}).head(3)

[11:27] <camelia> rakudo-moar 6c35cef60: OUTPUT: «here␤here␤here␤(4 6 10)␤»

[11:27] <pmurias> lizmat: the WIP rakudo.js report is still WIP so don't put it in the weekly just yet, will finish it up once I fix some bugs I found in things I wanted to mention as working in the report ;)

[11:28] *** Maylay joined
[11:33] <Xliff> SmokeMachine: That depends. Do you want to be doing large and complex programming inside of .map()?

[11:34] <Xliff> m: say (^10).map({ Nil }).elems

[11:34] <camelia> rakudo-moar 6c35cef60: OUTPUT: «10␤»

[11:34] <Xliff> m: say (^10).map({ do if .is-prime { say "here"; $_ * 2 }}).elems

[11:34] <camelia> rakudo-moar 6c35cef60: OUTPUT: «here␤here␤here␤here␤4␤»

[11:35] *** wamba left
[11:35] <SmokeMachine> Xliff: that’s not Nil... that’s Empty...

[11:35] <Xliff> m: say (^10).map({ 5 if $_ == 5 }).elems

[11:35] <camelia> rakudo-moar 6c35cef60: OUTPUT: «1␤»

[11:35] <Xliff> Yeah. I never use map like that.

[11:35] <Xliff> Nice to know, though.

[11:36] <Xliff> But in that situation, even though it works it may not be easy for everyone to write.

[11:36] <Xliff> There are a lot of gotchas there.

[11:36] <SmokeMachine> m: say (^10).map({Empty}).elems

[11:36] <camelia> rakudo-moar 6c35cef60: OUTPUT: «0␤»

[11:36] <Xliff> So while you are correct, it does give a similar result. It's not really about the result. It's about the thinking behind the way the result was obtained.

[11:37] <Xliff> TIMTOWTDI

[11:42] *** p9s```` left
[11:58] *** pat_js joined
[12:01] *** wamba joined
[12:02] *** p9s```` joined
[12:05] *** zakharyas left
[12:05] *** mensvaga joined
[12:15] <lizmat> weekly: https://rakuist.io/articles/from-the-perspective-of-an-outsider-more-or-less

[12:15] <notable6> lizmat, Noted! (weekly)

[12:22] <Xliff> Is there a way I could run a list of values through an object constructor for a list of objects initialized with those values?

[12:26] <sena_kun> Xliff, can you clarify a bit what you want?

[12:26] <sena_kun> maybe I can't read today, though. :)

[12:27] <SmokeMachine> m: say (^10).map({ Int.new: $_ }) # Xliff: like this?

[12:27] <camelia> rakudo-moar 6c35cef60: OUTPUT: «(0 1 2 3 4 5 6 7 8 9)␤»

[12:27] <Xliff> Something like... ($a, $b, $c) = (1, 2, 3, 4, 5)».&Object.new

[12:27] <Xliff> I'd rather not have the map.

[12:28] <Xliff> Thanks, though.

[12:28] <sena_kun> you don't need to specify type, actually

[12:28] <sena_kun> m: say (^10).map({ $_.new: $_ })

[12:28] <camelia> rakudo-moar 6c35cef60: OUTPUT: «(0 1 2 3 4 5 6 7 8 9)␤»

[12:28] <SmokeMachine> m: say (^10).&{ Int.new: $_ } # ???

[12:28] <camelia> rakudo-moar 6c35cef60: OUTPUT: «10␤»

[12:28] <SmokeMachine> m: say (^10)>>.&{ Int.new: $_ } # ???

[12:28] <camelia> rakudo-moar 6c35cef60: OUTPUT: «(0 1 2 3 4 5 6 7 8 9)␤»

[12:28] <Xliff> Guys. Lose the Int

[12:28] <Xliff> Arbitrary object.

[12:29] <SmokeMachine> sena_kun: I was meaning Int being any class...

[12:29] <Xliff> Oh. Missed the second one.

[12:29] *** reach_satori left
[12:29] <sena_kun> SmokeMachine, yes, I meant that as a side note, sorry.

[12:29] <SmokeMachine> sena_kun: np :)

[12:30] <sena_kun> m: class A { has $.a }; my @a = A.new(a => $_) for <1 2 3 4>; say @a;

[12:30] <camelia> rakudo-moar 6c35cef60: OUTPUT: «[A.new(a => IntStr.new(4, "4"))]␤»

[12:30] <sena_kun> m: class A { has $.a }; my @a = A.new(a => $_) for |<1 2 3 4>; say @a;

[12:30] <camelia> rakudo-moar 6c35cef60: OUTPUT: «[A.new(a => IntStr.new(4, "4"))]␤»

[12:30] <sena_kun> erm

[12:30] <sena_kun> m: class A { has $.a }; my @a := A.new(a => $_) for <1 2 3 4>; say @a;

[12:30] <camelia> rakudo-moar 6c35cef60: OUTPUT: «Type check failed in binding; expected Positional but got A (A.new(a => IntStr.new(...)␤  in block <unit> at <tmp> line 1␤␤»

[12:31] <sena_kun> m: class A { has $.a }; my $a = A.new(a => $_) for <1 2 3 4>; say $a;

[12:31] <camelia> rakudo-moar 6c35cef60: OUTPUT: «A.new(a => IntStr.new(4, "4"))␤»

[12:31] <sena_kun> ok, just ignore me

[12:32] <SmokeMachine> m: class C { has Int $.a; has Str $.b }; say [\(:1a, :b<um>), \(:2a, :b<dois>), \(:3a, :b<tres>)]>>.&{ C.new: |$_ }

[12:32] <camelia> rakudo-moar 6c35cef60: OUTPUT: «[C.new(a => 1, b => "um") C.new(a => 2, b => "dois") C.new(a => 3, b => "tres")]␤»

[12:33] <sena_kun> m: class A { has $.a }; my @a = [A.new(a => $_) for <1 2 3 4>]; say @a;

[12:33] <camelia> rakudo-moar 6c35cef60: OUTPUT: «[A.new(a => IntStr.new(1, "1")) A.new(a => IntStr.new(2, "2")) A.new(a => IntStr.new(3, "3")) A.new(a => IntStr.new(4, "4"))]␤»

[12:34] <SmokeMachine> m: class C { has Int $.a; has Str $.b }; say do for [\(:1a, :b<um>), \(:2a, :b<dois>), \(:3a, :b<tres>)] -> Capture c { C.new: |c }

[12:34] <camelia> rakudo-moar 6c35cef60: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Malformed parameter␤at <tmp>:1␤------> 3 :b<dois>), \(:3a, :b<tres>)] -> Capture7⏏5 c { C.new: |c }␤    expecting any of:␤        constraint␤        formal parameter␤»

[12:35] <daxim> > Merging is blocked

[12:35] <daxim>  – Merging can be performed automatically with 13 approving reviews.

[12:35] <daxim> any more objections, or what's the delay?

[12:35] <Xliff> This seems to have worked. Thanks SmokeMachine!

[12:35] <Xliff> my ($m, $s) = .[0,1]».&{ GIO::FileAttributeMatcher.new($_) };

[12:36] <SmokeMachine> Xliff: np! :)

[12:36] <lizmat> weekly: https://rakuist.io/articles/rakudo-perl-6-meta-programming-capabilities-using-fallback

[12:36] <notable6> lizmat, Noted! (weekly)

[12:36] <lizmat> daxim: the voting period is not over yet

[12:37] <lizmat> :-(

[12:37] <daxim> ok

[12:39] <lizmat> https://github.com/perl6/problem-solving/pull/89#issuecomment-536451971   # a week ago, one week to go

[12:42] <SmokeMachine> m: class Bla { has $.a }; say Bla.^attributes; Bla.^add_attribute: Attribute.new(:package(Bla), :name<$!b>, :type(Int)); say Bla.^attributes # that's possible...

[12:42] <camelia> rakudo-moar 6c35cef60: OUTPUT: «(Mu $!a)␤(Mu $!a Int $!b)␤»

[12:44] <SmokeMachine> m: class Bla { has $.a }; say Bla.^attributes; Bla.^add_attribute: Attribute.new(:package(Bla), :name<$!b>, :type(Int)); say Bla.^attributes; say Bla.new: :42a, :13b

[12:44] <camelia> rakudo-moar 6c35cef60: OUTPUT: «(Mu $!a)␤(Mu $!a Int $!b)␤Bla.new(a => 42)␤»

[12:44] <SmokeMachine> m: class Bla { has $.a }; say Bla.^attributes; Bla.^add_attribute: Attribute.new(:package(Bla), :name<$!b>, :type(Int)); say Bla.^attributes; Bla.^compose; say Bla.new: :42a, :13b

[12:44] <camelia> rakudo-moar 6c35cef60: OUTPUT: «(Mu $!a)␤(Mu $!a Int $!b)␤Bla.new(a => 42)␤»

[12:44] <SmokeMachine> hum... got it...

[12:49] <SmokeMachine> m: class C { has Int $.a; has Str $.b }; my &n = C.^lookup("new").assuming(C:); say [\(:1a, :b<um>), \(:2a, :b<dois>), \(:3a, :b<tres>)]>>.&n # it would be cool if it would be possible doing something like this... (I don't know with what syntax...)

[12:49] <camelia> rakudo-moar 6c35cef60: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Unable to parse expression in argument list; couldn't find final ')' (corresponding starter was at line 1)␤at <tmp>:1␤------> 3 }; my &n = C.^lookup("new").assuming(C:7⏏5); say [\(:1a, :b<um>),…»

[12:50] <pmurias> SmokeMachine: what do we want a gist on js objects to do?

[12:50] <SmokeMachine> pmurias: I think .toString() on that could be good enough, what do you think?

[12:51] <SmokeMachine> pmurias: or maybe return what console.log would print... (I don't know how)

[12:53] *** lucasb joined
[12:58] *** Doc_Holliwood joined
[13:00] <pmurias> lizmat: the way the migration will be done seems sane, I don't feel qualified to vote if the rename is a good thing tho

[13:01] <pmurias> SmokeMachine: .toString() seems better than nothing

[13:01] <lizmat> pmurias: that's ok

[13:01] <lizmat> wish I was 100% sure, still think it's the best of the bad alternatives

[13:02] *** wamba left
[13:02] <pmurias> lizmat: the proposal mentions a raku symlink is that intentional or a mistake?

[13:03] *** sena_kun left
[13:03] <lizmat> not a mistake

[13:03] <lizmat> if you realize that rakudo is an implementation of a language, you realize that the executable should be called "rakudo"

[13:06] <pmurias> what I mean is do we want to have a raku symlink pointing to rakudo?

[13:07] *** wamba joined
[13:09] <pmurias> `raku` and `perl6` should

[13:09] <pmurias> be symlinks

[13:21] <SmokeMachine> pmurias: maybe a `"JSObjectWrapper:" + JSON.stringify(obj)`?

[13:28] <SmokeMachine> pmurias: `"JavaScriptWrappedObject|" + obj.constructor.name + "|" + JSON.stringify(obj)`?

[13:28] <SmokeMachine> pmurias: a WHICH as well?\

[13:32] <lizmat> pmurias: indeed

[13:36] *** Guest3346 joined
[13:36] <pmurias> lizmat: so raku is the replacement for perl6 and rakudo the executable name if someone want's to distinguish implementations?

[13:37] <lizmat> the idea is that rakudo becomes the name of the executable, and that both "perl6" and "raku" become symlinks

[13:38] <lizmat> that can be customized by users should they want to have multiple Perl 6 / Raku implementations around

[13:38] <lizmat> this is actually not really about the renaming process at all, just correcting an error made in the past, in my view

[13:46] <pmurias> replacing the Rakudo excecutable with anything that's not forked from it will be hard

[13:55] <SmokeMachine> pmurias: I think the idea was use something like this: https://linux.die.net/man/8/alternatives

[13:56] *** zakharyas joined
[13:58] *** scimon joined
[13:59] *** gabiruh joined
[14:10] *** [Sno] left
[14:11] *** [Sno] joined
[14:14] *** Actualeyes joined
[14:15] <xinming_> SmokeMachine: https://termbin.com/6k0u2

[14:15] <xinming_> SmokeMachine: In this case, Is it possible that we don't pass the "method", but isntead, we pass the -> { }    ?

[14:15] <AlexDaniel> rakuist.io xDDD

[14:16] *** [Sno] left
[14:16] <AlexDaniel> what a wonderful domain name

[14:16] <AlexDaniel> gdonald++

[14:18] <SmokeMachine> xinming_: like that?  https://www.irccloud.com/pastebin/VJioCxoP/

[14:18] <vrurg> AlexDaniel: it sounds... Familiar? :D

[14:18] *** Seance[m] left
[14:18] *** aearnus[m] left
[14:18] *** Matthew[m] left
[14:18] *** tyil[m] left
[14:19] *** folex left
[14:19] *** xliff[m] left
[14:19] *** JulianF left
[14:19] *** uzl[m] left
[14:19] *** matiaslina left
[14:19] *** roy[m] left
[14:19] *** mack[m]1 left
[14:19] *** batmanaod[m] left
[14:19] *** MitarashiDango[m left
[14:19] *** sergiotarxz[m] left
[14:19] *** BlackChaosNL[m] left
[14:19] *** EuAndreh[m] left
[14:19] *** rba[m] left
[14:19] *** lance_w[m] left
[14:19] *** unclechu left
[14:19] *** [Sno] joined
[14:19] *** AlexDaniel` left
[14:19] *** TravisRt2botio[m left
[14:19] *** cpan-p6 left
[14:19] *** Demos[m] left
[14:21] *** cpan-p6 joined
[14:21] *** cpan-p6 left
[14:21] *** cpan-p6 joined
[14:24] <lizmat> And another Perl 6 Weekly hits the Net: https://p6weekly.wordpress.com/2019/10/07/2019-40-quick-syntaxing/

[14:25] <sjn> yay!

[14:27] <Xliff> lizmat++

[14:28] *** p9s```` left
[14:28] <Xliff> m: my %h = ( a => 1, b => 2, c => 4 ); my @a = %h.pairs.map( .value *= 2 ); @a.say; %h.pairs.say;

[14:28] <camelia> rakudo-moar 6c35cef60: OUTPUT: «No such method 'value' for invocant of type 'Any'. Did you mean 'values'?␤  in block <unit> at <tmp> line 1␤␤»

[14:28] <Xliff> m: my %h = ( a => 1, b => 2, c => 4 ); my @a = %h.pairs.map( *.value *= 2 ); @a.say; %h.pairs.say;

[14:28] <camelia> rakudo-moar 6c35cef60: OUTPUT: «[8 4 2]␤(c => 8 b => 4 a => 2)␤»

[14:29] <Xliff> m: my %h = ( a => 1, b => 2, c => 4 ); my @a = [ %h.pairs.map( *.value *= 2 ).flat ]; @a.say; %h.pairs.say;

[14:29] <camelia> rakudo-moar 6c35cef60: OUTPUT: «[8 4 2]␤(c => 8 b => 4 a => 2)␤»

[14:30] <Xliff> m: my %h = ( a => 1, b => 2, c => 4 ); my @a = ( %h.pairs.map( *.value *= 2 ).flat ); @a.say; %h.pairs.say;

[14:30] <camelia> rakudo-moar 6c35cef60: OUTPUT: «[2 4 8]␤(a => 2 b => 4 c => 8)␤»

[14:30] *** ambs left
[14:30] <Xliff> m: my %h = ( a => 1, b => 2, c => 4 ); my @a = ( %h.pairs.map({ .value *= 2; .clone }).flat ); @a.say; %h.pairs.say;

[14:30] <camelia> rakudo-moar 6c35cef60: OUTPUT: «[b => 4 c => 8 a => 2]␤(b => 4 c => 8 a => 2)␤»

[14:30] *** ambs joined
[14:31] <Xliff> m: my %h = ( a => 1, b => 2, c => 4 ); my @a = ( %h.pairs.map({ my $o = .clone; $o.value *= 2; $o }).flat ); @a.say; %h.pairs.say;

[14:31] <camelia> rakudo-moar 6c35cef60: OUTPUT: «[b => 4 a => 2 c => 8]␤(b => 2 a => 1 c => 4)␤»

[14:32] <Xliff> m: my %h = ( a => 1, b => 2, c => 4 ); my %d = %h.clone; %d.gist.say

[14:32] <camelia> rakudo-moar 7e76762c5: OUTPUT: «{a => 1, b => 2, c => 4}␤»

[14:33] <Xliff> m: my %h = ( a => 1, b => 2, c => 4 ); my %d = %h.clone; %d<b> *= 2; %d.gist.say

[14:33] <camelia> rakudo-moar 7e76762c5: OUTPUT: «{a => 1, b => 4, c => 4}␤»

[14:33] <Xliff> m: my %h = ( a => 1, b => 2, c => 4 ); my %d = %h.clone; %d<b> *= 2; %d.gist.say; %h.gist.say

[14:33] <camelia> rakudo-moar 7e76762c5: OUTPUT: «{a => 1, b => 4, c => 4}␤{a => 1, b => 2, c => 4}␤»

[14:41] *** wamba left
[14:43] *** ChoHag joined
[14:47] *** wamba joined
[14:48] *** Doc_Holliwood left
[14:48] <xinming_> SmokeMachine: So, by default, sub will have $_ as default invocant, right?

[14:49] <SmokeMachine> xinming_: a block...

[14:49] <xinming_> What about the pointy block?

[14:49] <SmokeMachine> m: {;}.signature.say; sub {}.signature.say

[14:49] <camelia> rakudo-moar 7e76762c5: OUTPUT: «(;; $_? is raw)␤()␤»

[14:49] <SmokeMachine> m: {;}.signature.say; sub {}.signature.say; ->{}.signature.say

[14:49] <camelia> rakudo-moar 7e76762c5: OUTPUT: «(;; $_? is raw)␤()␤()␤»

[14:50] <SmokeMachine> xinming_: ^^

[14:50] <xinming_> https://termbin.com/rxw2

[14:50] <SmokeMachine> m: {;}.signature.say; sub {}.signature.say; ->{}.signature.say; sub { $^not-self }.signature.say

[14:50] <camelia> rakudo-moar 7e76762c5: OUTPUT: «(;; $_? is raw)␤()␤()␤($not-self)␤»

[14:50] <xinming_> How can we do this?

[14:51] <SmokeMachine> xinming_: for that you should use $value.xx... (the -> ($value) {...} is not what you want...)

[14:51] *** lumin left
[14:52] <SmokeMachine> m: -> $value { say $value }.(42); -> ($value) { say $value }.(42)

[14:52] <camelia> rakudo-moar 7e76762c5: OUTPUT: «42␤Cannot unpack or Capture `42`.␤To create a Capture, add parentheses: \(...)␤If unpacking in a signature, perhaps you needlessly used parentheses? -> ($x) {} vs. -> $x {}␤or missed `:` in signature unpacking? -> &c:(Int) {}␤  in block <uni…»

[14:52] <SmokeMachine> m: -> $value { say $value }.(42); -> ($value) { say $value }.([42])

[14:52] <camelia> rakudo-moar 7e76762c5: OUTPUT: «42␤42␤»

[14:52] <SmokeMachine> xinming_: ^^

[14:54] <xinming_> Is it possible that I alias the $_ to another variable, But still pass the capture values correctly?

[14:54] <xinming_> m:  (-> { }).perl.say;   ({}).perl.say;

[14:54] <camelia> rakudo-moar 7e76762c5: OUTPUT: «->  { #`(Block|56929680) ... }␤{}␤»

[14:54] <xinming_> m:  (-> { }).perl.say;   ({ ... }).perl.say;

[14:55] <camelia> rakudo-moar 7e76762c5: OUTPUT: «->  { #`(Block|62309488) ... }␤-> ;; $_? is raw { #`(Block|63467456) ... }␤»

[14:55] <SmokeMachine> xinming_: why do you want an alias?

[14:55] <xinming_> so pointy block is the same as pointy block with signatures

[14:55] <xinming_> SmokeMachine: I need to pass additional arg to the callback

[14:58] <xinming_> well, will pass this with explicit arg

[14:58] <xinming_> something like     my &.method-cb =  -> $self, $value { };

[14:59] <SmokeMachine> xinming_: you mean like this? https://www.irccloud.com/pastebin/ozeQq0cS/

[15:00] *** pmurias left
[15:03] <SmokeMachine> xinming_: what about something like this? https://www.irccloud.com/pastebin/7WtvemrS/

[15:03] <moritz> Hi all

[15:03] <moritz> I seem to remember that the ebook version of one Andrew Shitov's books is now available for free

[15:04] <moritz> can anybody remember which one, and maybe give me a download link?

[15:06] <moritz> ah, https://perl6.online/using-perl6/

[15:07] <SmokeMachine> xinming_: ok, now I'm exaggerating... https://www.irccloud.com/pastebin/0byn472W/

[15:07] *** pmurias joined
[15:08] *** kylese joined
[15:08] *** p9s```` joined
[15:18] *** stnly joined
[15:20] *** stnly left
[15:23] *** sena_kun joined
[15:24] *** sena_kun left
[15:32] <xinming_> SmokeMachine: The first one is fine, almost the same as    &.method-cb = -> $self, $value { };

[15:32] <xinming_> SmokeMachine: Will choose that anyway.

[15:38] <SmokeMachine> pmurias: have you seen my second suggestion?

[15:39] <SmokeMachine> pmurias: `"JavaScriptWrappedObject|" + obj.constructor.name + "|" + JSON.stringify(obj)`?

[15:39] <pmurias> any feedback on the rakudo.js report draft: http://blogs.perl.org/users/pawel_murias/2019/10/wip-rakudojs-final-grant-update-1.html

[15:41] <pmurias> SmokeMachine: there seem to be ports of what console.log does in node.js to the browser

[15:41] <pmurias> SmokeMachine: maybe it makes sense to use that?

[15:41] <SmokeMachine> pmurias: I do think so! :)

[15:42] *** daxim left
[15:42] <moritz> pmurias: in this paragraph: "A couple of tests don't work due to either being impossible in the browser (due to using file system IO) or rakudo itself having a fair amount of bugs that pop up when precompiling code (in usual runs tests aren't precompiled so they go undetected)"

[15:43] <moritz> are these bugs that are also present in rakudo-moar? If yes, adding a half-sentence to clarify this would be helpful

[15:44] <moritz> also, really impressive work! pmurias++

[15:45] <pmurias> moritz: will clarify, they are present in precompiled modules but not tests or scripts :(

[15:47] <xinming_> pmurias: Are you maintainer of rakudo.js?

[15:47] <xinming_> IIRC, you are the dev, or I remember wrong.

[15:48] <pmurias> xinming_: yes

[15:49] <pmurias> xinming_: the main author

[15:49] <xinming_> pmurias: Do you have plan to export perl module to js?

[15:50] <pmurias> xinming_: I can add support for that if you want to use that

[15:50] <xinming_> I think this is useful.

[15:50] <xinming_> compile perl6 module to js, So, we can use the perl6 in nodejs.

[15:51] <xinming_> I mean import perl6 in js

[15:51] <SmokeMachine> pmurias: is IO impossible even using the js file api?

[15:51] <xinming_> SmokeMachine: I don't think so.

[15:52] <SmokeMachine> https://www.javascripture.com/File

[15:53] <Geth_> ¦ problem-solving: Kaiepi assigned to jnthn Issue Perl 6 needs better ways to deal with network addresses https://github.com/perl6/problem-solving/issues/111

[15:54] <pmurias> SmokeMachine: afair the File wasn't offering a direct access to the file system but allowing to ask the user for permission to read the contents of some files

[15:55] *** zakharyas left
[15:55] <SmokeMachine> pmurias: I've never used File... and have read about that too long ago... (sorry if not helping...)

[15:55] <SmokeMachine> s/if not/if I'm not/

[15:57] <pmurias> IO *is* possible to at an extent supported on node.js

[15:58] *** pat_js left
[15:59] <pmurias> xinming_: I'll look at exposing Perl 6 modules to node.js once I wrap up the grant

[15:59] <pmurias> got to run, will backlog and bbl&

[15:59] <xinming_> Ok, Thanks. That way, We make  js <-> perl6

[16:03] *** domidumont left
[16:06] *** pmurias left
[16:21] *** Sgeo_ left
[16:23] *** rindolf3 joined
[16:23] <rindolf3> Hi all

[16:23] <rindolf3> TimToady: hi.

[16:24] <AlexDaniel> .seen TimToady

[16:24] <tellable6> AlexDaniel, I saw TimToady 2019-07-22T20:38:55Z in #perl6-dev: * TimToady had the power company swapping his electric meter, and it broke my / key

[16:25] *** Sgeo joined
[16:28] *** scimon left
[16:29] *** domidumont joined
[16:30] *** mack[m] joined
[16:31] *** Sgeo left
[16:33] *** Sgeo joined
[16:36] *** dakkar left
[16:38] *** wildtrees joined
[16:39] *** MilkmanDan left
[16:39] *** [Sno] left
[16:40] *** MilkmanDan joined
[16:42] *** kylese left
[16:44] *** Demos[m] joined
[16:44] *** sergiotarxz[m] joined
[16:44] *** rba[m] joined
[16:44] *** xliff[m] joined
[16:44] *** Matthew[m] joined
[16:44] *** JulianF joined
[16:44] *** BlackChaosNL[m] joined
[16:44] *** lance_w[m] joined
[16:44] *** EuAndreh[m] joined
[16:44] *** TravisRt2botio[m joined
[16:44] *** roy[m] joined
[16:44] *** AlexDaniel` joined
[16:44] *** unclechu joined
[16:44] *** tyil[m] joined
[16:44] *** batmanaod[m] joined
[16:44] *** uzl[m] joined
[16:44] *** MitarashiDango[m joined
[16:44] *** matiaslina joined
[16:44] *** Seance[m] joined
[16:44] *** folex joined
[16:44] *** aearnus[m] joined
[16:46] *** [Sno] joined
[16:47] <uzl[m]> moritz: This one https://perl6.online/perl6-at-a-glance/ ?

[16:49] <Kaiepi> m: my package Foo { constant MIN = 1; constant MAX = 100; }; subset Foo of Int:D where (Foo::MIN..Foo::MAX); say 1 ~~ Foo;

[16:49] <camelia> rakudo-moar 7e76762c5: OUTPUT: «True␤»

[16:49] <Kaiepi> m: my package Foo { constant MIN = 1; constant MAX = 100; }; subset Foo of Int:D where (Foo::MIN..Foo::MAX); say Foo::MIN;

[16:49] <camelia> rakudo-moar 7e76762c5: OUTPUT: «1␤»

[16:49] <Kaiepi> m: my package Foo { constant MIN = 1; constant MAX = 100; }; subset Foo of Int:D where (Foo::MIN..Foo::MAX); say OUR::.kv;

[16:49] <camelia> rakudo-moar 7e76762c5: OUTPUT: «(Foo (Foo))␤»

[16:49] <Kaiepi> is it a bad idea to be messing with symbols this heavily?

[16:50] <uzl[m]> moritz: I also have the Perl 6 Deep Dive pdf that I got from a coupon that one time

[16:50] *** [Sno] left
[16:52] *** kensanata left
[16:55] *** [Sno] joined
[16:56] <rindolf3> TimToady: here?

[16:57] *** wamba left
[17:03] <tony-o> does ctilmes idle here?

[17:06] <Geth_> ¦ ecosystem: 90471b8ca3 | tony-o++ (committed using GitHub Web editor) | META.list

[17:06] <Geth_> ¦ ecosystem: refactoring DB::Xoos

[17:06] <Geth_> ¦ ecosystem: 

[17:06] <Geth_> ¦ ecosystem: so that you don't need to install DBIish & DB::Pg & DB::MySQL & etc.

[17:06] <Geth_> ¦ ecosystem: review: https://github.com/perl6/ecosystem/commit/90471b8ca3

[17:10] <AlexDaniel> .seen ctilmes

[17:10] <tellable6> AlexDaniel, I saw ctilmes 2019-07-08T15:29:01Z in #perl6: <ctilmes> rfold, see https://stackoverflow.com/questions/55209334/nativecall-buf-lifetime-and-garbage-collector

[17:10] <AlexDaniel> notable6: sorta

[17:10] <notable6> AlexDaniel, No notes for “sorta”

[17:10] <AlexDaniel> oops

[17:10] <AlexDaniel> tony-o: sorta!

[17:11] <tony-o> ah, maybe i'll catch him soon

[17:16] *** softmoth joined
[17:17] <SmokeMachine> pmurias: look how interesting: https://perl6.github.io/6pad/#9789cd026063730cd45d617aaa2d489f

[17:17] <tellable6> SmokeMachine, I'll pass your message to pmurias

[17:19] *** wamba joined
[17:20] *** [Sno] left
[17:23] *** sno joined
[17:30] *** molaf joined
[17:44] *** Black_Ribbon joined
[17:49] *** bazzaar joined
[17:55] *** hankache joined
[18:03] *** Doc_Holliwood joined
[18:05] *** pecastro joined
[18:16] *** ravenousmoose joined
[18:24] *** rindolf3 left
[18:30] *** kensanata joined
[18:33] *** wamba left
[18:36] <tony-o> .tell ctilmes how production ready do you suppose 

[18:36] <tellable6> tony-o, I'll pass your message to ctilmes

[18:36] <tony-o> .tell ctilmes DB::MySQL is?

[18:36] <tellable6> tony-o, I'll pass your message to ctilmes

[18:36] <tony-o> stupid fat fingers

[18:38] *** molaf left
[18:55] *** ChoHag left
[18:56] *** ChoHag joined
[19:01] <Geth_> ¦ problem-solving: vrurg assigned to jnthn Issue Role concretization needs big improvements. https://github.com/perl6/problem-solving/issues/112

[19:01] *** domidumont left
[19:04] *** Black_Ribbon left
[19:05] *** Black_Ribbon joined
[19:06] *** Black_Ribbon left
[19:06] *** Black_Ribbon joined
[19:08] *** Black_Ribbon left
[19:09] *** Black_Ribbon joined
[19:12] *** cooper joined
[19:17] <uzl[m]> m: given 1, 2 -> $a, $b { say "$a $b" }

[19:17] <camelia> rakudo-moar 7e76762c5: OUTPUT: «Too few positionals passed; expected 2 arguments but got 1␤  in block <unit> at <tmp> line 1␤␤»

[19:18] <uzl[m]> How do I localize several values using given?

[19:18] <Kaiepi> m: given 1, 2 -> ($a, $b) { say "$a $b" }

[19:18] <camelia> rakudo-moar 7e76762c5: OUTPUT: «1 2␤»

[19:18] <Kaiepi> 1, 2 is a list in that context

[19:18] <Kaiepi> er, maybe an array

[19:18] <Kaiepi> m: say WHAT my $ := 1, 2

[19:18] <camelia> rakudo-moar 7e76762c5: OUTPUT: «(List)␤»

[19:20] *** kensanata left
[19:25] *** hythm joined
[19:30] <uzl[m]> Thanks Kaiepi

[19:30] <Kaiepi> np

[19:31] <bazzaar> m: given (1, 2), 3 -> ($a, $b) { say "$b" }

[19:31] <camelia> rakudo-moar 7e76762c5: OUTPUT: «3␤»

[19:31] *** cgfbee joined
[19:31] <bazzaar> m: given (1, 2), 3 -> ($a, $b) { say $b }

[19:31] <camelia> rakudo-moar 7e76762c5: OUTPUT: «3␤»

[19:32] <bazzaar> m: given (1, 2), 3 -> ($a, $b) { say $b.^name }

[19:32] <camelia> rakudo-moar 7e76762c5: OUTPUT: «Int␤»

[19:32] <bazzaar> m: given (1, 2), 3 -> ($a, $b) { say "$b.^name" }

[19:32] <camelia> rakudo-moar 7e76762c5: OUTPUT: «3.^name␤»

[19:33] <Grinnz> complete non-stakeholder curiosity but, is there a reason assigning people to github issues gets announced but not the issues being opened?

[19:34] <hythm> m: use Cro::Uri; grammar G { proto token location { * }; token location:sym<uri> { <uri> }; token location:sym<path> { <path> }; token uri { .* { try Cro::Uri.parse: $/ } }; token path { .* } }; say G.parse( 'https://raku.org', :rule<location> ); say G.parse( '/tmp', :rule<location> );

[19:34] <camelia> rakudo-moar 7e76762c5: OUTPUT: «===SORRY!===␤Could not find Cro::Uri at line 1 in:␤    inst#/home/camelia/.perl6␤    inst#/home/camelia/rakudo-m-inst-2/share/perl6/site␤    inst#/home/camelia/rakudo-m-inst-2/share/perl6/vendor␤    inst#/home/camelia/rakudo-m-inst-2/share/p…»

[19:36] <hythm> is it possible to do something like the above? basically if Cro::Uri can parse the token then <uri> should match, if not then <path> should match.

[19:36] <SmokeMachine> Is https://modules.perl6.org giving error for someone else?

[19:40] <bazzaar> SmokeMachine: yes, same for me in firefox on linux (Host Error:The web server reported a gateway time-out error)

[19:47] <rba> SmokeMachine: Sorry, trouble-shooting modules.perl6.org right now. Will bring back ASAP.

[19:48] <SmokeMachine> rba: ok, thanks!

[19:50] *** wamba joined
[19:52] *** antoniogamiz joined
[19:52] <antoniogamiz> o/

[19:55] <bazzaar> m: my $a = 42; say join(':', "$a.^name", $a.^name); # method call has less precedence than double quotes?

[19:55] <camelia> rakudo-moar 7e76762c5: OUTPUT: «42.^name:Int␤»

[19:55] <MasterDuke> m: my $a = 42; say join(':', "$a.^name()", $a.^name); # yeah, unless you use parens

[19:55] <camelia> rakudo-moar 7e76762c5: OUTPUT: «Int:Int␤»

[19:56] <antoniogamiz> mm I have rakudo-pkg 2019.07.1-01 but the perl6 version is 2018.03 

[19:56] <antoniogamiz> any idea how to update it?

[19:56] <SmokeMachine> how do I set Perl 6 SDK for the project on COMMAIDE?

[19:58] <bazzaar> MasterDuke: thanks

[19:58] <MasterDuke> np

[20:00] <MasterDuke> SmokeMachine: i see a "new" button to the right of the "project sdk" dropdown when i create a new project

[20:03] <SmokeMachine> MasterDuke: thanks!

[20:05] *** cooper left
[20:14] *** mensvaga left
[20:17] *** wamba left
[20:18] *** wamba joined
[20:19] *** ravenousmoose left
[20:27] *** molaf joined
[20:35] *** krychu joined
[20:43] *** pmurias joined
[20:43] *** hankache left
[20:47] *** antoniogamiz left
[20:56] *** agentzh left
[20:58] *** agentzh joined
[20:58] *** agentzh left
[20:58] *** agentzh joined
[21:27] *** Black_Ribbon left
[21:36] *** wamba left
[21:41] <Geth_> ¦ ecosystem: b1c3156bab | threadless-screw++ (committed using GitHub Web editor) | META.list

[21:41] <Geth_> ¦ ecosystem: Update META.list

[21:41] <Geth_> ¦ ecosystem: 

[21:41] <Geth_> ¦ ecosystem: Add String::FuzzyIndex to ecosystem

[21:41] <Geth_> ¦ ecosystem: See https://github.com/threadless-screw/String-FuzzyIndex

[21:41] <Geth_> ¦ ecosystem: review: https://github.com/perl6/ecosystem/commit/b1c3156bab

[21:48] *** hythm left
[22:05] *** squashable6 left
[22:08] *** squashable6 joined
[22:08] *** ChanServ sets mode: +v squashable6

[22:21] *** softmoth left
[22:26] <Geth_> ¦ modules.perl6.org: 18a9b80d6c | (Roman Baumer)++ | lib/ModulesPerl6/DbBuilder/Dist/Source/CPAN.pm

[22:26] <Geth_> ¦ modules.perl6.org: make sure tempdir is in the user home dir and change dist_dir handling to make sure the directory move is working

[22:26] <Geth_> ¦ modules.perl6.org: review: https://github.com/perl6/modules.perl6.org/commit/18a9b80d6c

[22:40] *** krychu left
[22:41] *** krychu joined
[22:41] *** krychu left
[22:42] *** krychu joined
[22:43] *** vike left
[22:47] *** bazzaar left
[22:48] <Geth_> ¦ modules.perl6.org: 77b8804055 | (Roman Baumer)++ | update-modules.perl6.org

[22:48] <Geth_> ¦ modules.perl6.org: fix: Can't load application from file /home/modules.perl6.org/modules.perl6.org/bin/ModulesPerl6.pl: iCCP: known incorrect sRGB profile at /home/modules.perl6.org/modules.perl6.org/bin/../lib/ModulesPerl6/SpriteMaker.pm line 30.

[22:48] <Geth_> ¦ modules.perl6.org: review: https://github.com/perl6/modules.perl6.org/commit/77b8804055

[22:48] *** pecastro left
[22:50] *** krychu left
[22:54] *** Black_Ribbon joined
[23:02] *** gabiruh left
[23:07] *** softmoth joined
[23:13] *** reach_satori joined
[23:17] *** pmurias left
[23:19] *** reach_satori left
[23:20] *** vike joined
[23:37] *** reach_satori joined
[23:39] *** reach_satori left
[23:44] *** reach_satori joined
[23:52] *** reach_satori_ joined
[23:52] *** reach_satori left
[23:57] *** reach_satori_ left
[23:58] *** reach_satori joined
