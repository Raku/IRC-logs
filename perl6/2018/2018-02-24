[00:03] *** mcmillhj joined
[00:05] *** wamba joined
[00:07] *** konsolebox left
[00:08] *** konsolebox joined
[00:08] *** mcmillhj left
[00:12] *** someuser joined
[00:16] *** skids joined
[00:18] *** telex left
[00:20] *** mcmillhj joined
[00:20] *** telex joined
[00:22] <Geth> ¦ perl6.org: 37d234bffb | (Zoffix Znet)++ (committed using GitHub Web editor) | source/downloads/index.html

[00:22] <Geth> ¦ perl6.org: List linux packages in side panel

[00:22] <Geth> ¦ perl6.org: 

[00:22] <Geth> ¦ perl6.org: This somewhat violates our original principle of advertising Rakudo Star

[00:22] <Geth> ¦ perl6.org: only, but I'll take confusion over Start vs. Compiler-Only than users using[^1] 

[00:22] <Geth> ¦ perl6.org: 2016.01 rakudo or thinking we don't have packages at all.

[00:22] <Geth> ¦ perl6.org: 

[00:22] <Geth> ¦ perl6.org: [1] https://www.facebook.com/groups/perl6/permalink/2050023465264002/

[00:22] <Geth> ¦ perl6.org: review: https://github.com/perl6/perl6.org/commit/37d234bffb

[00:24] *** mcmillhj left
[00:33] *** pierre joined
[00:35] *** pharv left
[00:35] *** pharv joined
[00:36] *** mcmillhj joined
[00:41] *** mcmillhj left
[00:41] *** mcmillhj joined
[00:46] *** mcmillhj left
[00:48] *** mcmillhj joined
[00:51] *** pierre left
[00:52] *** mcmillhj left
[00:59] *** MasterDuke joined
[01:04] *** Cabanossi left
[01:04] *** mcmillhj joined
[01:05] *** Cabanossi joined
[01:12] *** mcmillhj left
[01:21] *** pierre joined
[01:22] *** pierre left
[01:24] *** mcmillhj joined
[01:24] *** ChoHag left
[01:27] *** pharv left
[01:29] *** pharv joined
[01:33] *** mcmillhj left
[01:33] *** pharv left
[01:39] *** wamba left
[01:41] *** konsolebox left
[01:41] *** pharv joined
[01:42] *** konsolebox joined
[01:44] *** AlexDaniel joined
[01:46] *** pharv left
[01:47] *** mcmillhj joined
[01:48] *** xi- left
[01:48] *** xi- joined
[01:51] *** mcmillhj left
[01:52] *** pierre joined
[01:57] *** pierre left
[02:03] *** mcmillhj joined
[02:08] *** mcmillhj left
[02:16] *** pharv joined
[02:20] *** ramortegui joined
[02:21] *** pharv left
[02:26] <skids> https://gist.github.com/skids/0745bfc48eac0c0f8ddf99fd81bf50ed

[02:26] *** jjore left
[02:29] *** llfourn left
[02:34] *** someuser left
[02:35] *** mcmillhj joined
[02:40] *** mcmillhj left
[02:45] *** ilbot3 left
[02:48] *** Zoffix joined
[02:49] <MasterDuke> skids: i'd recommend linking that over in #perl6-dev also

[02:49] <skids> good idea.

[02:51] <MasterDuke> and i'd also suggest giving at least a one sentence explanation of what it is. without any context someone might assume it was just an errant miss-click or accidental copy/paste

[02:52] *** mcmillhj joined
[02:53] <Zoffix> skids: wouldn't it make more sense for dynamic optimizer to figure stuff like this out? The optimize stage already chews up 10% of compilation. If you're doing fancy analysis to save 2% off runtime in tight loops at the cost of extra 5% compile time, you're effectively slowing down development time of the programmer.

[02:54] <Zoffix> skids: unless I'm misremembering, I may even seen jnthn++ say something that we shouldn't overcomplicate static optimizer to do things that that spesh can do

[02:56] *** ilbot3 joined
[02:56] *** ChanServ sets mode: +v ilbot3

[02:56] <Zoffix> One immediate thing that comes to mind is doing reverse constant folding of op chains, so stuff like `"long line" ~ "long line" ~ "long line" ~ $bar` becomes `"long line long line long line" ~ $bar` (currently it isn't). Same can be done with some math ops. But I just left it alone, because it wasn't 100% trivial, and I thought we weren't doing fancy analysis in the static optimizer

[02:56] *** mcmillhj left
[02:57] <MasterDuke> what i'm definitely not sure of is the limitations of each (MoarVM optimizations vs Rakudo optimizations)

[02:58] <skids> A) I doubt an opt like that would add 5%  B) Obviously spesh isn't  C) runtime is much more important than compiler time given 95% of your code ends up in libraries if you are doing it right and D) Non-VM-specific optimization has it's merits and E) it's much easier to work on.

[02:58] <Zoffix> I don't know anything about spesh, but static optimizer's limitations is basically "you can only use what's known at compile time and can't change during runtime"

[03:00] *** cdg joined
[03:00] <MasterDuke> it might make sense to have some additional optimization levels in Rakudo that e.g., are used to precompile stuff when modules are install by zef

[03:01] *** mcmillhj joined
[03:01] <MasterDuke> but perhaps aren't the default

[03:04] *** cdg left
[03:06] <Zoffix> skids: (A) it was a generalization. If you're optimizing for some special case I'm not using I'm paying for the analysis without getting anything in return. (B) Because few people are working on it. (C) That's not true. In 99% of my programs I couldn't give two shits if my program finishes in 5.7s vs 5.9s, while in 100% of my program I care about lag I have to suffer each time I make a change in my program.

[03:06] <Zoffix> Try developing a Cro web app and tell me compile time isn't that important. (D) Sure, but reading your article, you seem to be proposing an analysis of call chains done within `while` to see whether a dynamic variable can be eliminated. (E) it's also easy to do it wrong.

[03:06] *** mcmillhj left
[03:07] *** mcmillhj joined
[03:08] <Zoffix> In fact, there were two bugs made in the static optimizer just in the past month, one by me and one by jnthn++. jnthn's was caught by Toasting. Mine, it just occured to me that I may have messed it up and when I checked I did... It involved type-only Junctions in where clauses on Mu params. Quite specific hole that may not have been covered by tests.

[03:08] *** greppable6 left
[03:09] *** greppable6 joined
[03:10] <Zoffix> .ask jnthn is there any rule of thumb of what sort of things/complexity are fine to analyse in the static optimizer and what is best left for spesh? RE: https://irclog.perlgeek.de/perl6/2018-02-24#i_15852630

[03:10] <yoleaux> Zoffix: I'll pass your message to jnthn.

[03:11] <MasterDuke> skids: are you just sort of generally wondering why more optimization isn't done at the Rakudo level? or do you have some stuff in mind you'd like to work on? if the former, Zoffix has some good points, but if the latter, i'd certainly be interested in seeing PRs

[03:11] <skids> Well, I don't share your experience of valuing compile time over runtime... if I find myself in that situation I start to suspect the project is not well strictured.

[03:11] <skids> I'm just documenting my explorations, really.

[03:12] *** mcmillhj left
[03:14] <Zoffix> It's not valuing compile time over runtime. It's saying that compile time isn't irrelevant.

[03:14] <skids> (I'm also slightly annoyed that the core is becoming more unreadable)

[03:16] <Zoffix> skids: I think your (E) point has some responsibility there

[03:16] <Zoffix> (it's easier to write nqp ops than make static/dynamic optimizer work)

[03:17] <Zoffix> skids: OTOH, I recall brrt say nqp-fied code isn't just for humans, but JIT can work better on it or something

[03:18] <MasterDuke> skids: well please keep exploring and documenting, documentation and measurements are great

[03:18] *** mcmillhj joined
[03:18] *** ufobat_ joined
[03:22] *** ufobat left
[03:22] <skids> On E) I think I can agree with that assessment... and the brrt counterpoint is valid too.  I think there is a balance to be struck, and asking whether we should be using nqp::while as much seems to me to be a good place to at least start figuring out where that balance point is... it does't seem to be all that hard to statically optimize and it bears a lot of the blame for disrupting the look and feel of Perl6 control flow.

[03:23] *** mcmillhj left
[03:24] <Zoffix> I also think we could be more methodological with optimizations. Grepping my own modules, I have 4 instances of `while` (all in same module) and 15 instances of `loop`. A monster project could be making Toaster generate SQL profile of the entire ecosystem and then optimize the most used routines :P

[03:25] <skids> And as I said in the gist, I'm not even sure if those $_ binds are even supposed to be there... are we treating immediate blocks and inlined stuff too similarly?

[03:26] <skids> Anyway I have way more reading of Opntimizer.nqp to do before I can really mount a more informed argment.

[03:31] <Zoffix> skids: it looks kinda broken to me. $_ is a dynamic var, isn't it? But there's it's made lexical to preserve outer $_, which make it fail to preseve stuff if the dynamic $_ is accessed

[03:32] <Zoffix> m: $_.VAR.dynamic.say; { $_.VAR.dynamic.say }; while $++ < 2 { $_.VAR.dynamic.say }

[03:32] <camelia> rakudo-moar 748d1a57b: OUTPUT: «True␤True␤True␤True␤»

[03:32] <Zoffix> interesting...

[03:32] <Zoffix> m: class Foo { method bar { CALLER::<$_> = 42; } }; say $_; { Foo.bar; $_ = 55}; .say

[03:32] <camelia> rakudo-moar 748d1a57b: OUTPUT: «(Any)␤55␤»

[03:32] <Zoffix> m: class Foo { method bar { CALLER::<$_> = 42; } }; say $_; while $++ < 1 { Foo.bar; $_ = 55}; .say

[03:32] <camelia> rakudo-moar 748d1a57b: OUTPUT: «(Any)␤55␤»

[03:34] *** pierre__ joined
[03:34] *** mcmillhj joined
[03:35] <Zoffix> m: while $++ < 5 { $_ = 55 }; .say

[03:35] <camelia> rakudo-moar 748d1a57b: OUTPUT: «55␤»

[03:35] <Zoffix> This one has those two binds and the comments for them say "# Hand back the statements, but be sure to preserve $_ around them if the block uses it."  and I do use it and it's presevering nothing....

[03:36] <skids> m: class Foo { method bar { CALLER::<$_> = 42; } }; say $_; while $++ < 1 { $_ = 55; Foo.bar }; .say

[03:36] <camelia> rakudo-moar 748d1a57b: OUTPUT: «(Any)␤42␤»

[03:37] <Zoffix> I don't get why not though.

[03:37] *** pierre__ left
[03:37] *** pierre__ joined
[03:37] <Zoffix> Oh, 'cause it's just binding, isn't it? So the change that's done to $_ is done to `pres_topic__1` too

[03:39] *** mcmillhj left
[03:39] <Zoffix> m: $_ =  42; my $pres_topic := $_; while $++ < 5 { $_ = 55 }; $pres_topic.say

[03:39] <camelia> rakudo-moar 748d1a57b: OUTPUT: «55␤»

[03:39] <Zoffix> yup

[03:39] <Zoffix> m: $_ =  42; my $pres_topic = $_; while $++ < 5 { $_ = 55 }; $pres_topic.say

[03:39] <camelia> rakudo-moar 748d1a57b: OUTPUT: «42␤»

[03:40] <Zoffix> m: $_ =  42; my $pres_topic = $_; while $++ < 5 { my $_ = 55 }; $pres_topic.say

[03:40] <camelia> rakudo-moar 748d1a57b: OUTPUT: «Potential difficulties:␤    Redeclaration of symbol '$_'␤    at <tmp>:1␤    ------> 3 $pres_topic = $_; while $++ < 5 { my $_7⏏5 = 55 }; $pres_topic.say␤42␤»

[03:40] <Zoffix> m: $_ =  42; my $pres_topic := $_; while $++ < 5 { my $_ = 55 }; $pres_topic.say

[03:40] <camelia> rakudo-moar 748d1a57b: OUTPUT: «Potential difficulties:␤    Redeclaration of symbol '$_'␤    at <tmp>:1␤    ------> 3$pres_topic := $_; while $++ < 5 { my $_7⏏5 = 55 }; $pres_topic.say␤55␤»

[03:41] <Zoffix> So really, it's worse :) It's not that the binding can be eliminated, but that it's buggy and it needs to use the more expensive nqp::p6store :P

[03:44] *** lcamdy joined
[03:44] *** lcamdy left
[03:44] <Zoffix> m: class Foo { method bar { CALLER::<$_> = 42; } }; say $_; while $++ < 2; { my $x; Foo.bar; $_ = 55}; .say

[03:44] <camelia> rakudo-moar 748d1a57b: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Missing block␤at <tmp>:1␤------> 3R::<$_> = 42; } }; say $_; while $++ < 27⏏5; { my $x; Foo.bar; $_ = 55}; .say␤    expecting any of:␤        block or pointy block␤»

[03:44] <Zoffix> m: class Foo { method bar { CALLER::<$_> = 42; } }; say $_; while $++ < 2 { my $x; Foo.bar; $_ = 55}; .say

[03:44] <camelia> rakudo-moar 748d1a57b: OUTPUT: «(Any)␤55␤»

[03:45] <Zoffix> m: class Foo { method bar { CALLER::<$_> = 42; } }; say $_; $_ = 42; while $++ < 2 { my $x; Foo.bar; $_ = 55}; .say

[03:45] <camelia> rakudo-moar 748d1a57b: OUTPUT: «(Any)␤55␤»

[03:45] <Zoffix> m: class Foo { method bar { CALLER::<$_> = 42; } }; say $_; $_ = 42; while $++ < 2 { my $x; Foo.bar;}; .say

[03:45] <camelia> rakudo-moar 748d1a57b: OUTPUT: «(Any)␤42␤»

[03:45] <Zoffix> m: class Foo { method bar { CALLER::<$_> = 42; } }; say $_; $_ = 43; while $++ < 2 { my $x; Foo.bar;}; .say

[03:45] <camelia> rakudo-moar 748d1a57b: OUTPUT: «(Any)␤42␤»

[03:46] <skids> Is a while or immediate block *supposed* to establish a local topic?

[03:46] *** mcmillhj joined
[03:46] <Geth> ¦ doc: 3c5b34b8e4 | (Alex Chen)++ (committed using GitHub Web editor) | lib/Perl6/TypeGraph.pm

[03:46] <Geth> ¦ doc: Update TypeGraph.pm

[03:46] <Geth> ¦ doc: 

[03:46] <Geth> ¦ doc: Co perl6/6.d-prep#5

[03:46] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/3c5b34b8e4

[03:47] <Zoffix> skids: I think all blocks have the $_, don't they?

[03:47] <Zoffix> In the ASTs for the last few above, I see there is a lexical $_ declared for the block (but it's bound to the outer $_)... which makes me wonder what's the point of those two binds that supposed to preserve something

[03:51] *** mcmillhj left
[03:52] <Zoffix> skids: they're present in `if 1 { say 42 }`. I think they're useless there as well.

[03:53] <Zoffix> I mean `if 1 {}` period. Regardless of what's inside (other than implied params)

[03:53] <Zoffix> skids: are you gonna look more into this? I'm really sleepy right now, but right now to me those binds look entirely useless.

[03:54] <Zoffix> If not, I'll set myself a reminder to look

[03:54] <skids> I was just about to say, I'm getting pretty bleary and will probably start making less and less sense.

[03:54] <skids> :-)

[03:55] <skids> I do have nothing to do tomorrow, though, so I'll probably at least try to get some questions answered by trolling throug code/docs/roast.

[03:55] <Zoffix> |30d was anything done about the possibly useless `pres_topic` stuff in opt that removes blocks on `if`/`while`, etc. https://irclog.perlgeek.de/perl6/2018-02-24#i_15852854

[03:55] <ZofBot> Zoffix, Will remind you on 2018-03-25T22:55:17.706197-05:00 about was anything done about the possibly useless `pres_topic` stuff in opt that removes blocks on `if`/`while`, etc. https://irclog.perlgeek.de/perl6/2018-02-24#i_15852854

[03:55] <Zoffix> OK :)

[03:55] * Zoffix drops to hbed.

[03:55] <Zoffix> \o

[03:55] <skids> gnight

[03:55] *** Zoffix left
[04:00] *** mcmillhj joined
[04:05] *** mcmillhj left
[04:17] *** mcmillhj joined
[04:23] *** mcmillhj left
[04:51] *** pierre__ left
[04:53] *** llfourn joined
[04:54] *** Cabanossi left
[04:54] *** pharv joined
[04:57] *** Cabanossi joined
[05:05] *** eythian left
[05:07] *** eythian joined
[05:11] *** khw left
[05:16] *** wamba joined
[05:19] *** espadrine left
[05:21] *** espadrine joined
[05:22] *** konsolebox left
[05:23] *** troys left
[05:25] *** llfourn_ joined
[05:28] *** konsolebox joined
[05:29] *** llfourn left
[05:29] *** eliasr left
[05:31] *** skids left
[05:34] *** pharv left
[05:35] *** pharv joined
[05:39] *** pharv left
[05:56] *** llfourn joined
[05:59] *** llfourn_ left
[06:14] *** masak joined
[06:14] <masak> o hai, #perl6

[06:14] <yoleaux> 9 Feb 2018 00:13Z <Zoffix> masak: RE RT#124226 Yes, you can resolve types at compile time, but can you resolve methods? If the idea in the ticket is implemented, this, for example, would begin to crash, no? `class Foo { has $!foo; method foo { $!foo } }; INIT Foo.^lookup("foo").wrap: -> | { "not an error".say }; Foo.foo`

[06:14] <synopsebot> RT#124226 [open]: https://rt.perl.org/Ticket/Display.html?id=124226 [BUG] Opportunity to catch syntactically detectable calls to attribute-accessing methods on type objects in Rakudo

[06:15] *** mcmillhj joined
[06:18] <masak> Zoffix: ...yes. I think you've convinced me.

[06:18] * masak .oO( hoist by its own dynamism )

[06:20] *** ramortegui left
[06:20] *** mcmillhj left
[06:21] *** epony left
[06:26] *** mcmillhj joined
[06:27] *** epony joined
[06:32] *** mcmillhj left
[06:38] *** shinobi-cl joined
[06:39] <shinobi-cl> hi all: how can i check if a variable is a hash or an array?

[06:40] <shinobi-cl> m: my Sa = (1,2,3); say ?(Sa  ~~ Positional); say ?(Sa ~~ Associative);

[06:40] <camelia> rakudo-moar d3a7d7d2e: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Malformed my (did you mean to declare a sigilless \Sa or $Sa?)␤at <tmp>:1␤------> 3my Sa7⏏5 = (1,2,3); say ?(Sa  ~~ Positional); sa␤»

[06:42] <AlexDaniel> m: my $Sa = (1,2,3); say ?(Sa  ~~ Positional); say ?(Sa ~~ Associative);

[06:42] <camelia> rakudo-moar d3a7d7d2e: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Expected a term, but found either infix ~~ or redundant prefix ~␤  (to suppress this message, please use a space like ~ ~)␤at <tmp>:1␤------> 3my $Sa = (1,2,3); say ?(Sa  ~~7⏏5 Positional); s…»

[06:42] *** mcmillhj joined
[06:42] <AlexDaniel> m: my $Sa = (1,2,3); say ?($Sa  ~~ Positional); say ?($Sa ~~ Associative);

[06:42] <camelia> rakudo-moar d3a7d7d2e: OUTPUT: «True␤False␤»

[06:43] <shinobi-cl> m: my $a = (1,2,3); say ?($a  ~~ Positional); say ?($a ~~ Associative);

[06:43] <camelia> rakudo-moar d3a7d7d2e: OUTPUT: «True␤False␤»

[06:43] <shinobi-cl> mm

[06:44] <shinobi-cl> m: my $a = {a => 1, b =>2 , c => 3}; say ?($a  ~~ Positional); say ?($a ~~ Associative)

[06:44] <camelia> rakudo-moar d3a7d7d2e: OUTPUT: «False␤True␤»

[06:44] <shinobi-cl> m: my $a = (a => 1, b =>2 , c => 3); say ?($a  ~~ Positional); say ?($a ~~ Associative)

[06:44] <camelia> rakudo-moar d3a7d7d2e: OUTPUT: «True␤False␤»

[06:45] <shinobi-cl> m: my $a = (a => 1, b =>2 , c => 3); say ?($a[0]  ~~ Positional); say ?($a[0] ~~ Associative)

[06:45] <camelia> rakudo-moar d3a7d7d2e: OUTPUT: «False␤True␤»

[06:46] <shinobi-cl> m: my $a = {a => 1, b =>2 , c => 3}; say ?($a[0]  ~~ Positional); say ?($a[0] ~~ Associative)

[06:46] <camelia> rakudo-moar d3a7d7d2e: OUTPUT: «False␤True␤»

[06:46] <AlexDaniel> shinobi-cl: you can also check against Hash or Array if you want to be that precise

[06:47] <shinobi-cl> thanks AlexDaniel++, i will try that! 

[06:47] *** mcmillhj left
[06:48] <shinobi-cl> I just wonder if there is any case where both are true.. associative AND positional at the same time

[06:50] <AlexDaniel> m: my $x = ((42 does Associative) does Positional); say $x ~~ Associative; say $x ~~ Positional

[06:50] <camelia> rakudo-moar d3a7d7d2e: OUTPUT: «True␤True␤»

[06:50] <AlexDaniel> m: my $x = (42 does Associative) does Positional; say $x ~~ Associative; say $x ~~ Positional

[06:50] <camelia> rakudo-moar d3a7d7d2e: OUTPUT: «True␤True␤»

[06:50] <AlexDaniel> m: my $x = (42 does Associative) does Positional; say $x ~~ Associative; say $x ~~ Positional; say $x

[06:50] <camelia> rakudo-moar d3a7d7d2e: OUTPUT: «True␤True␤42␤»

[06:50] <AlexDaniel> xD

[06:51] <shinobi-cl>  m: my $x = (42 does Associative) does Positional; say $x ~~ Associative; say $x ~~ Positional; say $x.perl;

[06:51] <camelia> rakudo-moar d3a7d7d2e: OUTPUT: «True␤True␤42␤»

[06:51] <shinobi-cl>  m: my $x = (42 does Associative) does Positional; say $x.kv.perl;

[06:51] <camelia> rakudo-moar d3a7d7d2e: OUTPUT: «(0, 42).Seq␤»

[06:52] <shinobi-cl> i see... thanks! :)

[06:53] *** mcmillhj joined
[06:56] *** skids joined
[06:58] *** mcmillhj left
[07:01] *** skids left
[07:02] *** pierre joined
[07:07] *** mcmillhj joined
[07:12] *** mcmillhj left
[07:13] *** rindolf joined
[07:17] *** Diddi joined
[07:25] *** mcmillhj joined
[07:29] *** mcmillhj left
[07:43] *** mcmillhj joined
[07:48] *** mcmillhj left
[07:50] *** SyrupThinker joined
[07:55] <Diddi> I'm trying to wrap my head around live supplies and while I got it sort of working I'm not quite sure it's the right way to do it :) What I'm curious about is if I do a start {} in the live supply and it dies, my react/whenever block never exits unless I explicitly CATCH the die and call .quit in the supply

[07:56] <Diddi> example: https://pastebin.com/cKkYLCdn   is that the way it's supposed to work or am I going at it the wrong way here?

[07:56] *** mcmillhj joined
[07:59] *** darutoko joined
[08:00] *** mcmillhj left
[08:01] *** SyrupThinker left
[08:01] *** SyrupThinker joined
[08:03] *** rindolf left
[08:08] *** someuser joined
[08:09] *** mcmillhj joined
[08:13] *** rindolf joined
[08:14] *** wamba left
[08:14] *** mcmillhj left
[08:27] *** mcmillhj joined
[08:31] *** mcmillhj left
[08:43] *** mcmillhj joined
[08:44] *** domidumont joined
[08:44] *** sena_kun joined
[08:46] *** Shawn joined
[08:47] *** Shawn is now known as Guest75201

[08:47] *** mcmillhj left
[08:50] *** domidumont left
[08:50] *** domidumont joined
[08:51] *** Guest75201 left
[08:52] *** wamba joined
[08:53] *** kurahaupo joined
[08:56] *** mcmillhj joined
[09:02] *** mcmillhj left
[09:28] *** [particle] left
[09:28] *** [particle] joined
[09:49] *** mcmillhj joined
[09:53] *** mcmillhj left
[10:04] *** masak left
[10:18] *** pierre left
[10:29] *** pierre joined
[10:29] *** pierre left
[10:41] *** andrzejku joined
[10:59] *** pierre joined
[11:00] *** konsolebox left
[11:05] *** pierre left
[11:07] *** hankache joined
[11:07] *** konsolebox joined
[11:25] *** agwind left
[11:25] *** agwind joined
[11:33] *** hankache left
[11:36] *** pharv joined
[11:40] *** pmurias joined
[11:42] *** hankache joined
[11:44] *** konsolebox left
[11:49] *** hankache left
[11:49] *** konsolebox joined
[11:52] *** andrzejku left
[11:52] *** pierre joined
[11:53] *** masak joined
[11:55] *** SyrupThinker left
[11:56] <timotimo> Diddi: using an explicit Supplier will not give you any automatic handling of exceptions and other things; a supply block would do that, for example. if you want to hook it up in a simpler way, you can also $promise.then({ if .status ~~ PromiseStatus::Broken { $supplier.break(.cause) } });

[11:58] *** SyrupThinker joined
[12:00] <timotimo> huggable: bump

[12:00] <huggable> timotimo, nothing found

[12:00] <timotimo> what were people using to make the pretty bump messages?

[12:02] *** konsolebox left
[12:02] <timotimo> oh, it looks like geth puts those in the channel

[12:03] *** konsolebox joined
[12:04] <AlexDaniel> timotimo: pretty bump commits are generated by z script

[12:05] <AlexDaniel> huggable: z

[12:05] <huggable> AlexDaniel, Helper script for Rakudo Perl 6 core development: https://github.com/zoffixznet/z

[12:05] <AlexDaniel> Geth: ver https://github.com/rakudo/rakudo/commit/704b1cfb7876093fad054fc531830b8b479e19d1

[12:05] <Geth> AlexDaniel, version bump brought in these changes: https://github.com/perl6/nqp/compare/2018.01-99-g43d4336...2018.01-109-g5132d42

[12:06] <AlexDaniel> and Geth just generates a link

[12:06] <timotimo> oh, right

[12:06] <timotimo> no problem, though. my little description should suffice

[12:06] <Diddi> timotimo: ah, that makes sense and is consistent with what I'm seeing. the .then() is a nice take on it it aswell, thanks :)

[12:06] <timotimo> YW

[12:06] <AlexDaniel> .oO( and I generate multiple sentences using the same words )

[12:19] *** bisectable6 left
[12:19] *** bisectable6 joined
[12:19] *** ChanServ sets mode: +v bisectable6

[12:27] *** tt_ joined
[12:30] *** konsolebox left
[12:31] *** konsolebox joined
[12:37] *** pharv left
[12:38] *** pharv joined
[12:43] *** pharv left
[12:56] *** albongo left
[12:57] *** albongo joined
[13:05] *** konsolebox left
[13:06] *** konsolebox joined
[13:17] *** espadrine left
[13:18] *** tt_ left
[13:42] *** bobv joined
[13:51] *** someuser left
[13:54] *** wamba left
[13:54] *** pharv joined
[13:57] *** sena_kun left
[13:57] *** dogbert17 joined
[14:01] *** Bucciarati joined
[14:02] *** jargan joined
[14:04] *** tyilanmenyn joined
[14:04] *** [particle]1 joined
[14:04] <Diddi> given this code https://pastebin.com/xu1PVEL3 , why does print-vlan-id(Nil) give an error saying it expects Int, while print-vlan-id(9999) says it's expecting VLAN? 

[14:04] *** tobs_ joined
[14:05] *** telex left
[14:05] <Diddi> I'd expect in both cases getting an error saying it expects VLAN, not Int :P

[14:05] *** telex joined
[14:06] *** manu3 joined
[14:06] *** konsolebox_ joined
[14:06] <timotimo> the subset thing is made up of two parts

[14:06] <timotimo> first it checks the type, then it checks the constraint

[14:06] <Diddi> ah, that's actually the first part of the error.. I see that now

[14:07] <timotimo> Nil already fails the check against Int so it doesn't even have to try to check the "where" clause

[14:07] <Diddi> fair enough

[14:07] <timotimo> though maybe we want to change the output to still refer to the subset name there

[14:07] *** BucciaratiVEVO left
[14:08] <Diddi> in the end I suppose that's what the user is interested in, as trying to "fix" it by passing an Int only yields another error (as I'm doing with 9999)

[14:08] <El_Che> good point

[14:08] <El_Che> Diddi: raise an issue

[14:09] <Diddi> cool, what where? :)

[14:09] <timotimo> we might have spec tests that ask for the resulting error to be something particular, but in that case we can make a new exception that derives from the expected one and has a better error message

[14:09] <timotimo> though given you can make subsets of subsets, that could be a bit complicated

[14:09] <El_Che> Diddi: https://github.com/rakudo/rakudo/issues

[14:09] *** dogbert11 left
[14:10] *** konsolebox left
[14:10] *** tyil left
[14:10] <Diddi> El_Che: thanks I'll open an issue for it

[14:10] <timotimo> might also be interesting to look at the interplay of different placements of :D there; VLAN:D vs VLAN being a subset of Int:D instead of just Int

[14:10] *** eythian left
[14:10] *** tobs left
[14:10] *** tobs_ is now known as tobs

[14:10] *** Lynx_ left
[14:10] *** Gothmog_ left
[14:10] *** manu2 left
[14:10] *** [particle] left
[14:10] *** jast left
[14:10] *** S007 left
[14:12] *** shareable6 left
[14:12] *** shareable6 joined
[14:12] *** S007 joined
[14:12] *** unicodable6 left
[14:12] *** quotable6 left
[14:12] *** benchable6 left
[14:13] *** Geth left
[14:13] *** Geth joined
[14:13] *** ChanServ sets mode: +v Geth

[14:13] *** greppable6 left
[14:13] *** Gothmog_ joined
[14:14] *** someuser joined
[14:16] *** Lynx_ joined
[14:21] *** xi- left
[14:22] *** someuser left
[14:24] *** xi- joined
[14:27] *** Zoffix joined
[14:28] <Zoffix> masak: I just realized the same argumentation can be applied to some of the optimizations we already do....

[14:28] <Zoffix> m: &postfix:<++>.wrap: -> | { "meow".say }; my int $x; $x++

[14:28] <camelia> rakudo-moar 7d72387bc: ( no output )

[14:28] <Zoffix> ^ wrap isn't called, because postfix ++ is getting optimized into an nqp call

[14:30] <timotimo> if you don't mark it "soft" you'll get what's coming to you, no?

[14:31] <Zoffix> m: use soft; &postfix:<++>.wrap: -> | { "meow".say }; my int $x; $x++

[14:31] <camelia> rakudo-moar 7d72387bc: ( no output )

[14:31] <timotimo> that's NYI :D

[14:31] <timotimo> hm, actually

[14:31] <timotimo> does that just refer to things you're declaring in that scope perhaps?

[14:32] <Zoffix> m: use soft; &postfix:<++>.wrap: -> | { "meow".say }; dd &postfix:<++>.soft

[14:32] <camelia> rakudo-moar 7d72387bc: OUTPUT: «Bool::True␤»

[14:33] <Zoffix> timotimo: so the opts just needs to check if the thing is soft and not optimize if it is?

[14:33] <timotimo> i believe so

[14:33] <Zoffix> Actually no need for `use soft`; looks like the .wrap mixes in that method already

[14:33] <timotimo> but that wrapping still happens at run time, though

[14:33] <timotimo> m: use soft; sub test { }; say &test.soft

[14:33] <camelia> rakudo-moar 7d72387bc: OUTPUT: «True␤»

[14:34] <Zoffix> oh crap yeah

[14:34] <Zoffix> m: use soft; &postfix:<++>.wrap: -> | { "meow".say }; BEGIN dd &postfix:<++>.soft

[14:34] <camelia> rakudo-moar 7d72387bc: OUTPUT: «Nil␤»

[14:36] <Zoffix> m: &infix:<|>.wrap: -> | { "meow".say }; -> $ where {$_ ~~ Int|Num} { say "foo" }(42)

[14:36] <camelia> rakudo-moar 7d72387bc: OUTPUT: «foo␤»

[14:36] <Zoffix> m: &infix:<|>.wrap: -> | { "meow".say }; -> $ where Int|Num { say "foo" }(42)

[14:36] <camelia> rakudo-moar 7d72387bc: OUTPUT: «foo␤»

[14:42] <Geth> ¦ doc: titsuki++ created pull request #1797: Add Shifting and scaling intervals section

[14:42] <Geth> ¦ doc: review: https://github.com/perl6/doc/pull/1797

[14:42] <Geth> ¦ doc: c964ce0e32 | (Itsuki Toyota)++ | doc/Type/Range.pod6

[14:42] <Geth> ¦ doc: Add Shifting and scaling intervals section

[14:42] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/c964ce0e32

[14:42] <Geth> ¦ doc: f739bcb618 | (Itsuki Toyota)++ (committed using GitHub Web editor) | doc/Type/Range.pod6

[14:42] <Geth> ¦ doc: Merge pull request #1797 from titsuki/add-range-example

[14:42] <synopsebot> Link: https://doc.perl6.org/type/Range

[14:42] <Geth> ¦ doc: 

[14:42] <Geth> ¦ doc: Add Shifting and scaling intervals section

[14:42] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/f739bcb618

[14:44] *** eythian joined
[14:44] *** eythian left
[14:44] *** eythian joined
[14:47] <Zoffix> Filed as R#1561

[14:47] <synopsebot> R#1561 [open]: https://github.com/rakudo/rakudo/issues/1561 Multiple static optimizations break .wrap() feature

[14:54] <jnthn> I think to be wrappable, then either the declaration of the routine must be in the scope of a "use soft" or be explicitly marked "is soft", *or* the wrap should take place at compile time.

[14:54] <yoleaux> 03:10Z <Zoffix> jnthn: is there any rule of thumb of what sort of things/complexity are fine to analyse in the static optimizer and what is best left for spesh? RE: https://irclog.perlgeek.de/perl6/2018-02-24#i_15852630

[14:55] <jnthn> CORE.setting has no `use soft` nor is anything in it marked `is soft`

[14:55] <jnthn> So I'd not expect to be able to wrap anything from there

[14:59] <jnthn> As for the static analyzer, obviously anything that involves virtual or late-bound behavior can't be done there, so it's mostly things we can determine from lexically available information.

[15:00] <jnthn> Some things make a lot of sense to do in the static optimizer because they involve things that are far easier to spot with a Perl 6 AST than at bytecode level

[15:00] <timotimo> the pres_topic using binding and then not allocating a new Scalar is a bug, right? annoyingly, we won't be able to take advantage of the "$_ will be lazily allocated only if it's used" feature this way

[15:01] <timotimo> so once we "fix" that, we'll be allocating *so* many scalars

[15:01] <jnthn> Not aware of a bug in that area. Got an example where it changes observable behavior?

[15:02] <Zoffix> timotimo: the later discussion there arrived to the conclusion that pres_topic binding stuff is useless

[15:02] <timotimo> yeah, zoffix ran a few lines against camelia earlier today

[15:02] <timotimo> if you assign to $_ inside a block that gets inlined the value will be visible outside of it, too

[15:03] <Zoffix> Because the block is removed and without the binding the $_ is used from parent block and that's what'd normally happen *with* a block (which declares a lexical $_ but it's bound to outer $_)

[15:04] <jnthn> Things like this are why I ripped all routine inlining except for native operators out of the static optimizer

[15:04] <timotimo> iiuc we stash the $_ away to "preserve" it, but since we just bind, we just end up referencing the same scalar and nothing happens

[15:04] <jnthn> That sort of thing just is easier to get right in spesh

[15:05] <jnthn> As for $_, probably we need some more careful analysis there

[15:08] <Zoffix> jnthn: I guess yesterday's discussion's question largely centered on how to decide what is OK to put in static optimizer; especially given that many more devs are able to write static optimizer code but don't know much about spesh. If it's possible to do, then it could be done? Is that an acceptable answer? For example, I can think of optimizing things like `42 + 50 + 40 + $var` but I left that alone because I

[15:08] <Zoffix> thought we weren't doing "fancy" analysis in the static optimizer and that stuff is for spesh. But I've no idea how spesh works and what's good for spesh

[15:09] <jnthn> I think the static optimizer already does that constant-folding case?

[15:09] <jnthn> Constant-folding does make sense to do in the static optimizer, though, because "is pure" is a Perl 6 level thing that we don't push down any further - at least, not at the moment

[15:10] *** pharv left
[15:10] *** benchable6 joined
[15:10] *** greppable6 joined
[15:10] <Zoffix> No, it sees the last $var and gives up on the whole chain, without constant folding the constant bits because it's a nested chain. But for this particular op, the order doesn't matter, so it could fold the "top" of the chain, leaving just one op unfolded to deal with the non-compiletime-known $var

[15:10] *** pharv joined
[15:11] <jnthn> As to "many more devs are able to write static optimizer code" - maybe, but can they account for all the things needed to do it correctly? :)

[15:11] *** comborico1611 joined
[15:12] <jnthn> (Because spesh is dealing at the bytecode level, it's actually *easier* to reason about correctness at that level.)

[15:12] <Zoffix> Ah, I had $var in wrong place, it's when it's at the start I meant.

[15:12] <Zoffix> m: for ^1000_000 { my $ = rand + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 }; say now - INIT now

[15:12] <camelia> rakudo-moar 7d72387bc: OUTPUT: «1.9165407␤»

[15:12] <Zoffix> m: for ^1000_000 { my $ = 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + rand }; say now - INIT now

[15:12] <camelia> rakudo-moar 7d72387bc: OUTPUT: «0.44049105␤»

[15:13] <Zoffix> and with opt, the two would come out to run for the same time

[15:13] <jnthn> *nod*

[15:13] <jnthn> That'd seem sensible enough

[15:13] <mst> jnthn: it wouldn't surprise me that spesh is easier to reason about once you grok it in fullness but has a sharper learning curve to being able to reason about at all

[15:13] <mst> many things in technology seem to involve that trade-off

[15:14] <jnthn> Well, plus it's written in C, not Perl 6

[15:14] <jnthn> So yes, certainly steeper learning curve

[15:15] * mst wonders if eventually you could extract the components of a DSL from the so-far-written spesh optimisations

[15:15] *** pharv left
[15:17] <Zoffix> .tell skids some continuation for yesterday's discussion on what is OK to put into static optimizer: https://irclog.perlgeek.de/perl6/2018-02-24#i_15854047

[15:17] <yoleaux> Zoffix: I'll pass your message to skids.

[15:26] *** pharv joined
[15:27] *** comborico1611 left
[15:33] *** natrys joined
[15:34] <pmurias> Zoffix: the big problem with the static optimizer in Rakudo that it works in a very adhoc "here are a bunch of ifs" way

[15:34] <yoleaux> 14:02Z <tbrowder> pmurias: any debugging ideas about situation where nqp tests on jvm pass on my local host but fail on travis-ci?

[15:35] <Zoffix> pmurias: what's a better way?

[15:42] <pmurias> Zoffix: I don't have a ready solution that objectively better, but other more powerfull optimizers work in more complex ways

[15:42] <Zoffix> Not sure what you mean by that.

[15:42] <pmurias> Zoffix: like turning the AST into a intermediate more easily optimizable form where info can be easily attached

[15:43] <Zoffix> pmurias: but you can already easily attach info with annotations. And push-pull/method-call to mutate the QAST

[15:43] <Zoffix> *push-pop

[15:44] <Zoffix> positional access for positional kids and method calls for nameds

[15:44] <Zoffix> The only easier thing I can think of is having a .replace method on QAST::Node 

[15:45] <Zoffix> (that replaces the node itself in its place [somehow] so you don't have to keep track of what the parent is and where in the parent the node is at)

[15:47] *** tobs left
[15:48] *** tobs joined
[15:48] * pmurias searches for links to how other interesting optimizers work

[15:49] * Zoffix &

[15:49] *** Zoffix left
[15:59] *** pharv left
[15:59] *** pharv_ joined
[16:04] *** pharv_ left
[16:14] *** AlexDaniel left
[16:14] *** AlexDaniel joined
[16:24] *** skids joined
[16:24] *** pharv joined
[16:26] *** eliasr joined
[16:29] *** p6lert left
[16:29] *** p6lert joined
[16:29] *** wamba joined
[16:37] *** p6lert left
[16:37] *** p6lert joined
[16:42] <timotimo> pmurias: maybe check out what luajit can do :)

[16:47] <pmurias> timotimo: isn't luajit fast because of how simplistic lua is instead of the JIT being super smart

[16:49] *** natrys left
[16:51] <timotimo> it also has lots of clever things on top of that

[16:52] *** dct_ joined
[16:52] <timotimo> jimmyz has pointed out a few techniques it does that we should try stealing; i remember at least "allocation sinking"

[16:54] *** pharv left
[16:54] <pmurias> https://github.com/v8/v8/wiki/TurboFan - has a bunch of iteresting stuff

[16:55] *** pharv joined
[16:56] <pmurias> and in terms of optimizing stuff hoopl offers an interesting approach: https://www.microsoft.com/en-us/research/wp-content/uploads/2016/07/hoopl-haskell10.pdf?from=http%3A%2F%2Fresearch.microsoft.com%2Fen-us%2Fum%2Fpeople%2Fsimonpj%2Fpapers%2Fc--%2Fhoopl-haskell10.pdf

[16:57] <timotimo> i believe many optimizations depend on loops being a first-class datastructure?

[16:58] *** kurahaupo left
[16:59] *** pharv left
[17:04] *** bobv left
[17:13] *** tyilanmenyn is now known as tyil

[17:14] *** dct_ left
[17:18] <pmurias> timotimo: what do you mean by first-class datastructure?

[17:18] <timotimo> having an explicit class to hold all information we need

[17:19] <timotimo> currently if you want to figure out if something's a loop you have to go through the BBs and do some loop detection algorithm; i'm told they are rather tricky

[17:23] <skids> .tell Zoffix https://gist.github.com/skids/21eaaad37969c5123ce7e9c48be35274 research so far on that pres_topic issue

[17:23] <yoleaux> 15:17Z <Zoffix> skids: some continuation for yesterday's discussion on what is OK to put into static optimizer: https://irclog.perlgeek.de/perl6/2018-02-24#i_15854047

[17:23] <yoleaux> skids: I'll pass your message to Zoffix.

[17:24] *** kurahaupo joined
[17:25] *** natrys joined
[17:25] <pmurias> timotimo: you mean in the JIT optimizer?

[17:27] *** khw joined
[17:27] <tbrowder> pmurias: thanks!

[17:30] <skids> I'm just starting to read the optimizer so I'm balefully ill equipped to make intelligent comments, but one thing I noted is a few opts like changing for ^6 to a while just return after completing, with no chance to further optimize now that you have a "while"

[17:31] <tbrowder> hm, could be slight diff in debian vs trusty...trying the last ditch “install travis env on local host” method...

[17:35] *** pierre left
[17:39] *** domidumont left
[17:48] *** pharv joined
[17:52] <timotimo> pmurias: i'd say we ought to have that in spesh already

[17:53] <timotimo> the jit doesn't cross BB boundaries by itself yet, i think

[17:53] *** ChoHag joined
[17:57] <timotimo> m: subset VLAN of Int where 1..4095; say 0 ~~ VLAN; say 1 ~~ VLAN; say 1095 ~~ VLAN; say 1096 ~~ VLAN;

[17:57] <camelia> rakudo-moar 7d72387bc: OUTPUT: «False␤True␤True␤True␤»

[17:57] <timotimo> m: subset VLAN of Int where 1..4095; say 0 ~~ VLAN; say 1 ~~ VLAN; say 1095 ~~ VLAN; say 4096 ~~ VLAN;

[17:57] <camelia> rakudo-moar 7d72387bc: OUTPUT: «False␤True␤True␤False␤»

[17:57] <timotimo> m: subset VLAN of Int where 1..4095; say 0 ~~ VLAN; say 1 ~~ VLAN; say 4095 ~~ VLAN; say 4096 ~~ VLAN;

[17:57] <camelia> rakudo-moar 7d72387bc: OUTPUT: «False␤True␤True␤False␤»

[17:57] <timotimo> Diddi: you can write your subset more succintly this way

[17:58] *** unicodable6 joined
[18:00] <timotimo> also, 0 < $_ < 4096 is also shorter than 0 < $_ && $_ < 4096

[18:01] <timotimo> also, writing "also" twice per line is also not very good also

[18:02] <TimToady> that would be more like 0 ^..^ 4096

[18:02] <timotimo> well, that's why i spelled it 1..4095, though of course that has the same result

[18:03] <TimToady> if you can get non-integers as input

[18:03] <timotimo> in this example we're starting out with "subset ... of Int" :)

[18:03] <Diddi> timotimo: thanks, I do feel I'm unnecessarily expressive when I write some code and I know there are a lot of shortcuts so I appreciate such tips :)

[18:03] <timotimo> \o/

[18:06] <Kaiepi> does anyon have the link to that guide on getting into perl 6 dev that included information on how nqp and moarvm work?

[18:06] <Kaiepi> s/anyon/anyone

[18:06] <Kaiepi> should've bookmarked it last time

[18:08] <timotimo> that's probably the nqp and rakudo internals workshop?

[18:09] <timotimo> rakudo and nqp internals workshop

[18:09] <Kaiepi> yeah that

[18:09] <timotimo> https://github.com/edumentab/rakudo-and-nqp-internals-course

[18:09] <Kaiepi> thanks

[18:09] <timotimo> do we have a feature to ask huggable if it has some key that points at a given value? i.e. if it knows this link already?

[18:09] <timotimo> huggable: source

[18:09] <huggable> timotimo, Install latest version of Rakudo from source: https://github.com/zoffixznet/r#table-of-contents

[18:10] <timotimo> haha, not that

[18:10] <timotimo> buggable: source

[18:10] <buggable> timotimo, See: https://github.com/zoffixznet/perl6-buggable

[18:12] <timotimo> it doesn't have that feature, maybe i'll send a feature request

[18:12] <Xliff> What am I doing wrong, here?

[18:12] <Xliff> m: "use Parser::SQL::Tokens;" ~~ m:g/'use' \s+ $<word>=\w+ [ '::' $<word>=\w+ ]* ';'/; dd $/<word>;

[18:12] <camelia> rakudo-moar 7d72387bc: OUTPUT: «&CORE::infix:<orelse>(Failure.new(exception => X::AdHoc.new(payload => "Type List does not support associative indexing."), backtrace => Backtrace.new), *.self)␤»

[18:13] *** Cabanossi left
[18:13] <shinobi-cl> Hi all :)

[18:13] <shinobi-cl> m: my %h = 'A' => 20, 'B' => 10, 'C' => 20, 'D' => 40; say %h.perl

[18:13] <camelia> rakudo-moar 7d72387bc: OUTPUT: «{:A(20), :B(10), :C(20), :D(40)}␤»

[18:14] <Xliff> m: my token word { \w+ }; say "use Parser::SQL::Tokens;" ~~ m:g/'use' \s+ <word> [ '::' <word> ]* ';'/; 

[18:14] <camelia> rakudo-moar 7d72387bc: OUTPUT: «(｢use Parser::SQL::Tokens;｣␤ word => ｢Parser｣␤ word => ｢SQL｣␤ word => ｢Tokens｣)␤»

[18:14] <timotimo> in your code $/ is a list, not a match object

[18:14] *** Cabanossi joined
[18:14] <shinobi-cl> So i have this array. I want to get the Keys sorted by: 1st: value, and for the same value, alfabetically. How should i do this?

[18:15] <Xliff> timotimo: Why would $/ not be a match object?

[18:15] <timotimo> Xliff: because of :g

[18:15] <Xliff> \/o\

[18:15] <timotimo> m: "abcde" ~~ m:g/./; say $/.^name; say $/.perl

[18:15] <Xliff> Right.

[18:15] <camelia> rakudo-moar 7d72387bc: OUTPUT: «List␤$(Match.new(list => (), made => Any, pos => 1, hash => Map.new(()), orig => "abcde", from => 0), Match.new(list => (), made => Any, pos => 2, hash => Map.new(()), orig => "abcde", from => 1), Match.new(list => (), made => Any, pos => 3, hash =>…»

[18:16] <Xliff> m: "use Parser::SQL::Tokens;" ~~ m:g/'use' \s+ $<word>=\w+ [ '::' $<word>=\w+ ]* ';'/; dd $/[0]<word>;

[18:16] <timotimo> shinobi-cl: you mean if the value is the same, use the key alphabetically?

[18:16] <camelia> rakudo-moar 7d72387bc: OUTPUT: «[Match.new(list => (), made => Any, pos => 10, hash => Map.new(()), orig => "use Parser::SQL::Tokens;", from => 4), Match.new(list => (), made => Any, pos => 15, hash => Map.new(()), orig => "use Parser::SQL::Tokens;", from => 12), Match.new(list => (…»

[18:16] <shinobi-cl> timotimo, yes

[18:16] <Xliff> m: "use Parser::SQL::Tokens;" ~~ m:g/'use' \s+ $<word>=\w+ [ '::' $<word>=\w+ ]* ';'/; dd $/[0]<word>[*-1].Str;

[18:16] <camelia> rakudo-moar 7d72387bc: OUTPUT: «"Tokens"␤»

[18:16] <timotimo> in that case i believe you can .sort({ .value, .key })

[18:16] <shinobi-cl> :o

[18:17] <timotimo> m: my %h = 'A' => 20, 'B' => 10, 'C' => 20, 'D' => 40; %h.sort({ .value, .key }).perl.say

[18:17] <camelia> rakudo-moar 7d72387bc: OUTPUT: «(:B(10), :A(20), :C(20), :D(40)).Seq␤»

[18:17] <moritz> m: "use Parser::SQL::Tokens;" ~~ m:g/'use' \s+ [$<word>=\w+]+ % '::' /

[18:17] <camelia> rakudo-moar 7d72387bc: ( no output )

[18:17] <timotimo> m: my %h = 'A' => 20, 'B' => 10, 'C' => 20, 'D' => 40; %h.sort({ -.value, .key }).perl.say

[18:17] <camelia> rakudo-moar 7d72387bc: OUTPUT: «(:D(40), :A(20), :C(20), :B(10)).Seq␤»

[18:17] <moritz> m: say "use Parser::SQL::Tokens;" ~~ m:g/'use' \s+ [$<word>=\w+]+ % '::' /

[18:17] <camelia> rakudo-moar 7d72387bc: OUTPUT: «(｢use Parser::SQL::Tokens｣␤ word => ｢Parser｣␤ word => ｢SQL｣␤ word => ｢Tokens｣)␤»

[18:17] <shinobi-cl> :O :O 

[18:17] <pmurias> timotimo: I haven't looked into spesh at all yet

[18:18] <shinobi-cl> thanks timotimo++ !! damn ... i love perl6

[18:18] <timotimo> <3

[18:18] *** pharv left
[18:18] <timotimo> pmurias: if you got any questions i'm here for you :)

[18:19] *** pharv joined
[18:23] *** pharv left
[18:27] *** pharv joined
[18:29] *** Kaiepi left
[18:33] *** Kaiepi joined
[18:35] *** Kaiepi left
[18:35] *** Kaiepi joined
[18:49] <shinobi-cl> m: sub sub1($x) { return ($x, $x);  }; my $v = sub1(100); my @a = sub1(100); say $v.perl; say @a.perl;

[18:49] <camelia> rakudo-moar 7d72387bc: OUTPUT: «$(100, 100)␤[100, 100]␤»

[18:50] <shinobi-cl> ok, so, how should i make it so $v is the scalar 100 only?

[18:51] <TimToady> m: sub sub1($x) { return ($x, $x);  }; my ($v) = sub1(100); my @a = sub1(100); say $v.perl; say @a.perl;

[18:51] <camelia> rakudo-moar 7d72387bc: OUTPUT: «100␤[100, 100]␤»

[18:53] <TimToady> if you're asking for an equivalent to wantarray, we don't try to predict the future in p6

[18:53] <shinobi-cl> hmmm, i see. Well the idea is: i have a method that can reject some data passed to it, i want to return only the useful info, but if the user wants it, i can give it back the discarded data.

[18:54] <TimToady> then "wants" needs to be passed in as a parameter, or you need the user to throw away the extra info as above

[18:54] <TimToady> or return an object and let the user pull out what they want

[18:56] <shinobi-cl> yes, that makes sense, i will put the option to pass a named parameter with a ref to return the discarded data there. Thanks!

[18:56] <TimToady> but we can't really have both wantarray and multiple dispatch, and in p6 the latter is much more important

[18:58] *** pharv left
[18:58] <timotimo> m: sub split-it(@incoming, :$discarded is rw) { @$discarded = @incoming.grep(Str); return @incomint.grep(none(Str)) }; my @out; say split-it((1, 2, "hi", 3, 4, "foo"), discarded => @out); say @out.perl

[18:58] <camelia> rakudo-moar 7d72387bc: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Cannot use 'is rw' on optional parameter '$discarded'.␤at <tmp>:1␤»

[18:58] <timotimo> m: sub split-it(@incoming, :$discarded is raw) { @$discarded = @incoming.grep(Str); return @incomint.grep(none(Str)) }; my @out; say split-it((1, 2, "hi", 3, 4, "foo"), discarded => @out); say @out.perl

[18:58] <camelia> rakudo-moar 7d72387bc: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Variable '@incomint' is not declared. Did you mean '@incoming'?␤at <tmp>:1␤------> 3discarded = @incoming.grep(Str); return 7⏏5@incomint.grep(none(Str)) }; my @out; sa␤»

[18:58] *** pharv joined
[18:58] <timotimo> m: sub split-it(@incoming, :$discarded is raw) { @$discarded = @incoming.grep(Str); return @incoming.grep(none(Str)) }; my @out; say split-it((1, 2, "hi", 3, 4, "foo"), discarded => @out); say @out.perl

[18:58] <camelia> rakudo-moar 7d72387bc: OUTPUT: «(1 2 3 4)␤["hi", "foo"]␤»

[18:58] <timotimo> shinobi-cl: ^

[18:59] <timotimo> of course you want to check if $discarded is actually present first

[18:59] *** darutoko left
[19:00] *** eliasr left
[19:02] *** someuser joined
[19:03] *** pharv left
[19:11] *** AlexDaniel left
[19:16] *** jstuder joined
[19:22] *** SyrupThinker left
[19:25] *** espadrine joined
[19:27] <jstuder> hey 6ers i have a question

[19:28] <jstuder> should Str words method split on a non-breaking space?

[19:28] <jstuder> the sub in nqp for the same task does not split on nbsp

[19:28] <jstuder> the sub used for quotewords and such

[19:28] <jstuder> Str words does not

[19:28] *** pharv joined
[19:28] <jstuder> So one of them has to be wrong?

[19:29] <jstuder> I didn't see anything in the spec docs about it

[19:29] <timotimo> are you refering to method split_words in Grammar.nqp?

[19:29] <jstuder> yes

[19:30] <MasterDuke> you said both did *not*, was that a typo and one actually does?

[19:30] <jstuder> split_words in the grammar does not split

[19:30] <jstuder> Str words in rakudo does

[19:30] <jstuder> a typo 

[19:30] <MasterDuke> ah

[19:31] <jstuder> a test in S32-str/words.t has is splitting on nbsp. I'm not sure if that is right or a mistake

[19:32] <jstuder> I kind of feel like it shouldn't split

[19:32] <jstuder> especially since it doesn't in the grammar

[19:34] *** espadrine left
[19:36] <jstuder> m: say "a\c[NO-BREAK SPACE]bc d".words;

[19:36] <camelia> rakudo-moar 7d72387bc: OUTPUT: «(a bc d)␤»

[19:36] <jstuder> m: say "a\c[NO-BREAK SPACE]bc d".words.elems;

[19:36] <camelia> rakudo-moar 7d72387bc: OUTPUT: «3␤»

[19:39] *** cpup left
[19:42] <MasterDuke> m: say <<a\c[NO-BREAK SPACE]bc d>>.perl

[19:42] <camelia> rakudo-moar 7d72387bc: OUTPUT: «("a bc", "d")␤»

[19:42] <MasterDuke> m: say "a\c[NO-BREAK SPACE]bc d".words.perl

[19:42] <camelia> rakudo-moar 7d72387bc: OUTPUT: «("a", "bc", "d").Seq␤»

[19:45] <jstuder> yeah the behavior is different. which doesn't seem right to me

[19:45] *** Kaiepi left
[19:46] *** Kaiepi joined
[19:56] *** cpup joined
[20:12] *** zakharyas joined
[20:15] *** comborico1611 joined
[20:20] *** zakharyas left
[20:21] *** SyrupThinker joined
[20:23] *** Zoffix joined
[20:24] <Zoffix> m: say .comb(/\S+/).List eqv .split(/\s+/, :skip-empty).List eqv .words.List with "a\c[NO-BREAK SPACE]b\c[narrow no-break space]c\c[zero width no-break space]d"

[20:24] <yoleaux> 17:23Z <skids> Zoffix: https://gist.github.com/skids/21eaaad37969c5123ce7e9c48be35274 research so far on that pres_topic issue

[20:24] <camelia> rakudo-moar 7d72387bc: OUTPUT: «True␤»

[20:24] *** zakharyas joined
[20:25] <Zoffix> This is what'd I'd expect, so I'd say it's the quotewords that are wrong

[20:25] <Zoffix> And .comb not always returning Seq :/

[20:25] <Zoffix> m: say "".comb.^name; say "".comb(/./).^name

[20:25] <camelia> rakudo-moar 7d72387bc: OUTPUT: «Seq␤List␤»

[20:28] <jstuder> so should we change the split_words behavior in nqp to match?

[20:28] <jstuder> so that it will also split on nbsp?

[20:29] <jstuder> although I still feel like it shouldn't split on a nbsp. though it's not my call to make

[20:30] <Zoffix> jstuder: why not? It's has Zs property

[20:31] *** zakharyas left
[20:32] *** khisanth_ left
[20:32] <jstuder> that's true. I don't know why, just that no-break behavior seems like it should behave differently. BUt it's just a gut feeling and not rooted in anything more.

[20:34] *** zakharyas joined
[20:34] <TimToady> it depends on how the definition of break breaks

[20:35] *** tt_ joined
[20:36] <jstuder> TimToady: I'm afraid I don't understand

[20:36] <Zoffix> .ask samcv does Unicode have some sort of "non-break" property? In .words and with \S/\s we split on \x00A0\x2007\x202F chars because they're Zs and don't split on \xFEFF because it ain't. But when parsing quotewords we have code explitly not splitting on "\x00A0\x2007\x202F\xFEFF" and I don't know why these 4 chars were chosen to be special exactly (other than having "non-break" in the name)

[20:36] <yoleaux> Zoffix: I'll pass your message to samcv.

[20:38] <TimToady> if someone's intent in putting a no-break in is to prevent treatment as multiple words, it seems a bit antisocial for .words to treat them as multiple words

[20:39] <TimToady> just because something doesn't have a particular unicode category doesn't mean it isn't a unique character with unique semantics

[20:39] <TimToady> that's why we have separate characters, after all :)

[20:39] <jstuder> I guess that is the way I saw it too. That the use of the no-break is odd enough that it would signify a clear intent.

[20:40] <jstuder> that the user intends not to split/break on this character

[20:40] <TimToady> to me, it falls a bit into the category of "torment the implementer" to handles it the way the user expects

[20:40] <Zoffix> Yeah, but if someone used &nbsp; as a spacer in HTML markup, and you try to work with as just text, now you got broken code. And "splits on whitespace" is easier to understand and remember than "splits on whitespace unless it's a whitespace character that has "no-break" in its name"

[20:41] <TimToady> arguable &nbsp; as a spacer is a misuse of the character, but I understand that it happens with some frequency

[20:44] <Zoffix> .tell samcv context: https://irclog.perlgeek.de/perl6/2018-02-24#i_15854900

[20:44] <yoleaux> Zoffix: I'll pass your message to samcv.

[20:45] *** khisanth_ joined
[20:46] <jstuder> So if we were to implement a CCLASS_NBSP, would that be appropriate? Are CCLASSes more about the unicode standard or about groupings that help the implementer? seems more like the latter to me, from looking at the code.

[20:46] <TimToady> I just know I get really ticked off when a program thinks it knows better than me whether to split up "Perl 6"

[20:46] <jstuder> That's a really good point

[20:47] <Zoffix> It's a no-break, not a no-split :P

[20:47] <TimToady> and if you're splitting HTML up using .words, &nbsp; is the least of your worries

[20:47] <Zoffix> No, splitting text given from HTML parser

[20:47] <samcv> Zoffix: well no break is really no split

[20:47] <yoleaux> 20:44Z <Zoffix> samcv: context: https://irclog.perlgeek.de/perl6/2018-02-24#i_15854900

[20:48] <samcv> since it splits across lines

[20:48] <TimToady> when ah splits a hunk o' wood, it breaks

[20:48] <samcv> though there is line break property and word break property

[20:48] <samcv> that are separate, though mostly they are the same

[20:50] *** pharv left
[20:50] *** pharv joined
[20:50] <Zoffix> samcv: what about space-break or something? Basically, so we'd quiery by some property rather than hardcoding specific codepoints.

[20:51] <samcv> well we would use the word break property

[20:51] *** Kaiepi left
[20:51] <samcv> not sure when word break is different than line break though i know it exists

[20:51] *** Kaiepi joined
[20:52] <samcv> like nbsp it doesn't break on lines, but it breaks on words

[20:53] <Zoffix> gah, I DOM::Tiny auto-converts &nbsp; to regular spaces.

[20:54] <mst> *DOM* *DOM* *DOM* *DOMMMMM*

[20:55] *** pharv left
[20:58] *** labster joined
[20:59] <Zoffix> I filed R#1562 so we don't forget about it.

[21:00] <synopsebot> R#1562 [open]: https://github.com/rakudo/rakudo/issues/1562 [RFC] Inconsistent handling between Str.words and «....» quoters

[21:00] <Zoffix> robot! do my bidding!

[21:00] *** synopsebot left
[21:00] *** synopsebot joined
[21:01] <Zoffix> R#1562

[21:01] <synopsebot> R#1562 [open]: https://github.com/rakudo/rakudo/issues/1562 [RFC] Inconsistent handling between Str.words and «....» quoters

[21:01] *** Zoffix left
[21:01] <jstuder> https://en.wikipedia.org/wiki/Whitespace_character

[21:02] <jstuder> What if we have a CCLASS_NBSP and include the 5 chars listed as not Wrappable in this doc?

[21:02] *** labster left
[21:02] *** labster joined
[21:02] <jstuder> and don't split on those?

[21:02] *** ChanServ sets mode: +v synopsebot

[21:03] *** Zoffix joined
[21:03] *** Zoffix left
[21:03] *** Zoffix joined
[21:06] <Zoffix> I don't see a difference between that and hardcoding the codepoints next to split_words in HLL::Grammar.

[21:07] <Zoffix> samcv: how to quiery word break property?

[21:07] <TEttinger> we need break break properties so we know if breaks will break correctly or if they will break

[21:07] <Zoffix> m: "\x[A0]".uniprop('Word_Break').say

[21:07] <camelia> rakudo-moar 7d72387bc: OUTPUT: «Other␤»

[21:07] <Zoffix> m: " ".uniprop('Word_Break').say

[21:07] <camelia> rakudo-moar 7d72387bc: OUTPUT: «Other␤»

[21:08] <samcv> Zoffix: https://unicode.org/reports/tr29/#Default_Word_Boundaries well it's complicated

[21:08] <samcv> err meant to link this section https://unicode.org/reports/tr29/#Word_Boundary_Rules

[21:09] <samcv> but there's rules regarding the Word_Break property similar to Grapheme_Cluster_Break property

[21:10] <jstuder> Did I open a huge can of worms? :P

[21:12] <TEttinger> zero-width no-break space

[21:13] <samcv> i don't have time to get into it at this exact second but I will read into it later today

[21:13] <Zoffix> Well, my vote is to keep .words as is. "Breaks on whitespace characters" is easy to understand and if someone wants to be fancy and not break on non-breakables the burden of remembering all the codepoints on is on them (e.g. doing "a\x[A0]b c".split(/<[\s]-[\x[A0]]>+/)). The words given by .words aren't quite "words" as is it, so KISS is my thought on it.

[21:13] <Zoffix> Don't care as much about «...». Would be nice for it to be consistent, but I can live with it doing special things.

[21:14] <Zoffix> jstuder: not that huge :)

[21:14] <Zoffix> There've been bigger cans... like D#1428

[21:14] <synopsebot> D#1428 [closed]: https://github.com/perl6/doc/issues/1428 [docs][update] List method flatmap is inappropriately discouraged

[21:15] * Zoffix 

[21:15] *** Zoffix left
[21:15] <TEttinger> bucket of worms

[21:15] <TEttinger> bathtub of worms

[21:16] <moritz> bitbucket of bits

[21:16] <TEttinger> bitbucket is still around right?

[21:17] *** Kaiepi left
[21:17] <TEttinger> gitlab is pretty darn stiff competition

[21:17] *** Kaiepi joined
[21:19] <moritz> I think bitbucket's main selling point is that it's well integrated with Atlassian's other stuff, like Jira

[21:20] <TEttinger> haha

[21:21] <TEttinger> "I think chewing tobacco's main selling point is that it's well integrated with throat cancer"

[21:21] *** pharv joined
[21:22] <jstuder> What if we implemented a CCLASS_NBSP with the few hard-coded values, tell .words not to split on it, and refine as necessary in the future depending on samcv's research. That seems like a good option to me.

[21:23] <moritz> each change to .words is a backwards-incompatible change, and we shouldn't make those lightly

[21:24] <jstuder> i see

[21:33] <Xliff> W8 WAT?!?

[21:33] <Xliff> <moritz> m: say "use Parser::SQL::Tokens;" ~~ m:g/'use' \s+ [$<word>=\w+]+ % '::' /

[21:33] <Xliff> I missed that.

[21:35] <Xliff> \o/

[21:35] *** pharv left
[21:35] <Xliff> I must now rewrite several rules

[21:35] <Xliff> moritz++

[21:36] <moritz> Xliff: please /msg me your email address

[21:38] <Xliff> m: say "a, b" ~~ /. % [ ',' \s* ]

[21:38] <camelia> rakudo-moar 7d72387bc: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Missing quantifier on the left argument of %␤at <tmp>:1␤------> 3say "a, b" ~~ /. %7⏏5 [ ',' \s* ]␤»

[21:38] <Xliff> m: say "a, b" ~~ /. % [ ',' \s* ]/

[21:38] <camelia> rakudo-moar 7d72387bc: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Missing quantifier on the left argument of %␤at <tmp>:1␤------> 3say "a, b" ~~ /. %7⏏5 [ ',' \s* ]/␤»

[21:39] <Xliff> m: say "a, b" ~~ / [ . ] % [ ',' \s* ]/

[21:39] <camelia> rakudo-moar 7d72387bc: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Missing quantifier on the left argument of %␤at <tmp>:1␤------> 3say "a, b" ~~ / [ . ] %7⏏5 [ ',' \s* ]/␤»

[21:39] <Xliff> m: say "a, b" ~~ / [ . ] % ',' /

[21:39] <camelia> rakudo-moar 7d72387bc: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Missing quantifier on the left argument of %␤at <tmp>:1␤------> 3say "a, b" ~~ / [ . ] %7⏏5 ',' /␤»

[21:39] <Xliff> m: say "a, b" ~~ / .  % ',' /

[21:39] <camelia> rakudo-moar 7d72387bc: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Missing quantifier on the left argument of %␤at <tmp>:1␤------> 3say "a, b" ~~ / .  %7⏏5 ',' /␤»

[21:39] <moritz> % is a modifier on a quantifier

[21:39] <Xliff> Oh

[21:40] <moritz> so the patter is always <atom><quantifier> % <separator>

[21:40] <Xliff> m: say "a, b" ~~ / .* % [ ',' \s* ]/

[21:40] <moritz> *pattern

[21:40] <camelia> rakudo-moar 7d72387bc: OUTPUT: «｢a, b｣␤»

[21:40] <Xliff> m: say "a,b" ~~ / .* % [ ',' \s* ]/

[21:40] <camelia> rakudo-moar 7d72387bc: OUTPUT: «｢a,b｣␤»

[21:40] <Xliff> m: say "a," ~~ / .* % [ ',' \s* ]/

[21:40] <camelia> rakudo-moar 7d72387bc: OUTPUT: «｢a｣␤»

[21:40] <moritz> you can use %% if you want to allow trailing separators

[21:40] <Xliff> OK, but I was just curious as to whether <separator> could be an <atom>

[21:40] <Xliff> And looks like the answer is yes.

[21:43] *** pharv joined
[21:47] *** pharv left
[21:50] *** espadrine joined
[22:04] *** SyrupThinker left
[22:09] *** rindolf left
[22:26] <jstuder> exit

[22:26] *** jstuder left
[22:37] *** zakharyas left
[22:45] *** pharv joined
[22:50] *** pharv left
[23:06] <Geth> ¦ doc: 8b05b467b4 | (Brad Gilbert)++ | 4 files

[23:06] <Geth> ¦ doc: .Bool on allomorphs return False when numerically 0

[23:06] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/8b05b467b4

[23:12] *** someuser left
[23:12] *** natrys left
[23:14] *** jargan is now known as jast

[23:17] *** von_cheam joined
[23:18] <von_cheam> Hullo! Can I just ask, what's the syntax for constraining a subroutine's return type to a list-type obj? 

[23:18] <von_cheam> Specifically, I want to return an array of strings, but both --> @Str and --> Array[Str] fail.

[23:19] <Geth> ¦ doc: 8a070b2f75 | (Will "Coke" Coleda)++ | doc/Type/Hash.pod6

[23:19] <Geth> ¦ doc: remove trailing whitespace

[23:19] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/8a070b2f75

[23:19] <Geth> ¦ doc: f50db4372f | (Will "Coke" Coleda)++ | xt/code.pws

[23:19] <Geth> ¦ doc: note recently added code snippets

[23:19] <synopsebot> Link: https://doc.perl6.org/type/Hash

[23:19] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/f50db4372f

[23:20] <jnthn> m: sub foo(--> Array[Str]) { my Str @a = 'x', 'y'; return @a; }; say foo

[23:20] <camelia> rakudo-moar 7d72387bc: OUTPUT: «[x y]␤»

[23:21] <jnthn> von_cheam: Array[Str] should be fine, but make sure the thing being returned is a declared Array of Str, not just an Array that happens to contain Str objects

[23:22] <von_cheam> Okay, thanks. I thought I had, but --> Array[Str] fails with something along the liunes of expected Array[Str] but got Array[Str].new("examplestring")

[23:22] <von_cheam> I'll go back and check my code!

[23:23] * [Coke] was too slow.

[23:25] *** quotable6 joined
[23:41] *** pharv joined
[23:42] *** teatime left
[23:45] *** pharv left
[23:52] *** comborico joined
[23:53] *** comborico1611 left
[23:54] *** maybelearn joined
[23:54] *** tt_ left
[23:55] *** maybelearn left
