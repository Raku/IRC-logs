[00:00] <geekosaur> 2013's a long time ago, it's been is DEPRECATED for a while

[00:01] <geekosaur> but the implenentation was iirc causing problems in precompiled code so lizmat redid it

[00:01] <geekosaur> but that introduced breaking changes for other cases. but people generally care about not having to recompile everything on the fly

[00:01] <geekosaur> (which is slow)

[00:02] <geekosaur> nd the precompiled deprecations issue was breaking a lot of other stuff, so.

[00:03] <Xliff_> OK. PR incoming

[00:05] <Geth> ¦ DBIish: Xliff++ created pull request #122: - Commits changes addressing issue #121.

[00:05] <Geth> ¦ DBIish: review: https://github.com/perl6/DBIish/pull/122

[00:07] <Xliff_> I can confirm this as now allowing DBIish to install.

[00:22] *** aindilis left
[00:29] *** w_richard_w joined
[00:34] *** markong left
[00:34] *** markong joined
[00:38] *** molaf left
[00:40] *** aindilis joined
[00:41] *** athenot joined
[00:43] *** comborico left
[00:47] *** pilne left
[00:47] *** athenot left
[00:55] *** Kaiepi left
[00:57] *** Kaiepi joined
[00:58] *** markong left
[01:03] *** BenGoldberg joined
[01:11] *** [particle] joined
[01:13] *** [particle]1 left
[01:15] *** [particle] left
[01:16] *** [particle] joined
[01:19] *** [particle]1 joined
[01:20] *** [particle] left
[01:29] *** [particle] joined
[01:29] *** [particle]1 left
[01:33] *** [particle]1 joined
[01:35] *** [particle] left
[01:36] *** donpdonp joined
[01:36] *** comborico1611 left
[01:39] <Geth> ¦ DBIish: 8d8f59ba72 | [email@hidden.address] | 4 files

[01:39] <Geth> ¦ DBIish: - Commits changes addressing issue #121.

[01:39] <Geth> ¦ DBIish: review: https://github.com/perl6/DBIish/commit/8d8f59ba72

[01:39] <Geth> ¦ DBIish: b2b7e1edeb | (Zoffix Znet)++ (committed using GitHub Web editor) | 4 files

[01:39] <Geth> ¦ DBIish: Merge pull request #122 from Xliff/master

[01:39] <Geth> ¦ DBIish: 

[01:39] <Geth> ¦ DBIish: - Commits changes addressing issue #121.

[01:39] <Geth> ¦ DBIish: review: https://github.com/perl6/DBIish/commit/b2b7e1edeb

[01:40] *** [particle]1 left
[01:40] *** kjk joined
[01:41] <Geth> ¦ DBIish: 58d2a4e5d2 | (Zoffix Znet)++ (committed using GitHub Web editor) | META6.json

[01:41] <Geth> ¦ DBIish: Bump version and fix incorrect `perl` attribute

[01:41] <Geth> ¦ DBIish: 

[01:41] <Geth> ¦ DBIish: `perl` specifies the minimum perl6 version the module works with,

[01:41] <Geth> ¦ DBIish: but `v6` is after `v6.c`

[01:41] <Geth> ¦ DBIish: review: https://github.com/perl6/DBIish/commit/58d2a4e5d2

[01:45] *** ilbot3 left
[01:52] *** [particle] joined
[01:56] *** enheh joined
[01:56] *** ilbot3 joined
[01:56] *** ChanServ sets mode: +v ilbot3

[02:03] *** [particle] left
[02:04] *** [particle] joined
[02:08] *** [particle] left
[02:09] *** [particle] joined
[02:17] *** [particle]1 joined
[02:19] *** [particle] left
[02:22] *** [particle]1 left
[02:25] *** [particle] joined
[02:27] <rouking> jnthn: I was watching your talk on objects & concurrency, and I was wondering why `Supply.start(...)` returns a Supply of Supplies rather than a Supply of Promises, since each Supply will only ever produce one value (which seems more like a Promise). Is this just so that it can be used easily with `.migrate`?

[02:34] *** [particle] left
[02:41] *** [particle] joined
[02:44] *** [particle]1 joined
[02:45] *** [particle] left
[02:49] *** [particle]1 left
[02:59] *** raynold joined
[03:06] <lookatme> rouking, I think this just make one interface/method cooperate with another

[03:07] *** kjk left
[03:44] *** Herby_ joined
[03:44] <Herby_> \o

[04:02] *** Herby_ left
[04:29] *** w_richard_w left
[04:29] *** w_richard_w joined
[04:41] *** capcassiuscalhou left
[04:45] *** sno left
[04:46] *** parv joined
[04:47] *** curan joined
[04:56] *** [particle] joined
[04:56] *** aindilis left
[05:05] *** jmerelo joined
[05:06] *** curan left
[05:06] *** curan joined
[05:06] *** aindilis joined
[05:09] *** stevie left
[05:10] *** wamba joined
[05:32] *** domidumont joined
[05:37] *** HaraldJoerg joined
[05:39] *** domidumont left
[05:40] *** domidumont joined
[05:54] *** domidumont left
[05:59] *** sno joined
[06:07] <Geth> ¦ doc: 52d98f7c8d | (JJ Merelo)++ | doc/Language/structures.pod6

[06:07] <Geth> ¦ doc: Adds blocks refs #114

[06:07] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/52d98f7c8d

[06:07] <synopsebot> Link: https://doc.perl6.org/language/structures

[06:09] *** [particle]1 joined
[06:10] *** BenGoldberg left
[06:11] *** [particle] left
[06:12] *** psychoslave joined
[06:14] *** xtreak joined
[06:18] *** domidumont joined
[06:23] *** domidumont left
[06:23] *** domidumont joined
[06:30] *** aindilis left
[06:31] *** Sgeo__ joined
[06:31] *** jmerelo left
[06:33] *** Sgeo_ left
[06:35] *** espadrine_ left
[06:55] *** cibs joined
[07:10] *** dct joined
[07:15] *** jmerelo joined
[07:16] *** shareable6 joined
[07:31] *** jmerelo left
[07:33] *** jmerelo joined
[07:36] *** AlexDani` joined
[07:37] *** AlexDaniel left
[07:39] *** wamba left
[07:47] *** wamba joined
[07:51] <Geth> ¦ doc: 0964154c3c | (JJ Merelo)++ | doc/Language/regexes.pod6

[07:51] <Geth> ¦ doc: Eliminates :L as shorthand for alpha refs #2060

[07:51] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/0964154c3c

[07:51] <Geth> ¦ doc: d57ea25d6b | (JJ Merelo)++ | doc/Language/regexes.pod6

[07:51] <Geth> ¦ doc: Checks other references to the equivalence :L <=> alpha

[07:51] <synopsebot> Link: https://doc.perl6.org/language/regexes

[07:51] <Geth> ¦ doc: 

[07:51] <Geth> ¦ doc: Founds nothing. The OP of #2060 was right, so it has been eliminated. Also some reflow, closes #2060.

[07:51] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/d57ea25d6b

[07:52] *** darutoko joined
[08:17] <Geth> ¦ doc: 37279cc8c5 | (JJ Merelo)++ | doc/Language/regexes.pod6

[08:17] <Geth> ¦ doc: Eliminates non-working conjunctions.

[08:17] <Geth> ¦ doc: 

[08:17] <Geth> ¦ doc: Thanks to @ronaldxs for spotting them. Closes #2064.

[08:17] <Geth> ¦ doc: 

[08:17] <synopsebot> Link: https://doc.perl6.org/language/regexes

[08:17] <Geth> ¦ doc: Also some reflow around that change.

[08:17] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/37279cc8c5

[08:23] *** shareable6 left
[08:29] <Geth> ¦ doc: 5e488818db | (JJ Merelo)++ | doc/Language/regexes.pod6

[08:29] <Geth> ¦ doc: Fixes weird pod error

[08:29] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/5e488818db

[08:29] <synopsebot> Link: https://doc.perl6.org/language/regexes

[08:38] *** wamba left
[08:52] <lizmat> weekly: http://lancewicks.com/2018/05/25/tuning-a-production-perl6-web-application/

[08:52] <notable6> lizmat, Noted!

[09:04] *** Schepeers_ joined
[09:04] <Geth> ¦ doc: 9ef1469d81 | (JJ Merelo)++ | doc/Language/structures.pod6

[09:04] <Geth> ¦ doc: Adds info on functions refs #114

[09:04] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/9ef1469d81

[09:04] <synopsebot> Link: https://doc.perl6.org/language/structures

[09:07] *** Schepeers left
[09:08] *** xtreak left
[09:16] <jnthn> rouking: Yes, and both .migrate and .flat. Also, since `whenever` on a Promise and on a 1-element Supply look identical, and so does `await`, then most of the time you can get away without knowing.

[09:16] *** dct left
[09:18] <masak> argh, language design

[09:20] <masak> Feynman's "everything is interesting if you go into it deeply enough" has a dark side to it, too :P

[09:21] *** w_richard_w left
[09:32] *** xtreak joined
[09:33] <masak> interesting thing I never thought about before: all of (Perl 5, Perl 6, Python, JavaScript) run a module when you import it

[09:33] <masak> that's quite a bit of code that runs at "compile time"

[09:34] *** ChoHag joined
[09:34] <moritz> well, in Perl 6, not so much

[09:34] <masak> how do you mean?

[09:34] <moritz> the module mainline runs at compile time, not at "use" time

[09:35] <masak> "use" time _is_ compile time

[09:35] <moritz> ... unless the module is precompiled

[09:35] <moritz> which it is after the first loading

[09:35] <sjn> "compile time, or earlier" :)

[09:36] *** robertle joined
[09:37] *** wamba joined
[09:37] * sjn waves hello to #perl6 o/

[09:37] *** dustinm` joined
[09:37] * moritz waves back

[09:38] *** shareable6 joined
[09:38] *** ChanServ sets mode: +v shareable6

[09:42] *** ambs joined
[09:43] <Geth> ¦ doc: 0a43f8e7a2 | (JJ Merelo)++ | doc/Language/structures.pod6

[09:43] <Geth> ¦ doc: Fixes pod error refs #114

[09:43] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/0a43f8e7a2

[09:43] <synopsebot> Link: https://doc.perl6.org/language/structures

[09:50] <masak> sjn: *wave* \o

[09:52] <jnthn> Even if the module is precompiled, its mainline code runs on loading.

[09:52] <masak> moritz: I realize I have some gaps wrt precompilation... but I don't think we're in significant disagreement. modulo precompilation, when the parser sees a `use` statement, it goes and *runs* the imported module file.

[09:52] <moritz> jnthn: even the compile-time parts of the module, like class declarations?

[09:53] *** scott_ joined
[09:53] <masak> um, class declarations don't have any runtime behavior... :P

[09:53] <jnthn> moritz: Class declarations don't compile into code, they're meta-object method calls at compile time.

[09:53] <jnthn> But no, those aren't re-run

[09:53] *** zostay_ joined
[09:54] *** PotatoGim_ joined
[09:54] <masak> jnthn: does an imported module ever run more than once, for example if it's `use`d from multiple places in a code base?

[09:54] <jnthn> I was more referring to things like `my $the-singleton = Whisky.new; sub get-foo() is export { $the-singleton }` :)

[09:54] <jnthn> masak: No

[09:54] <masak> good

[09:54] <jnthn> Thus why my singleton example above works :)

[09:54] <masak> right

[09:55] <masak> I just arrived at the same conclusion in https://github.com/masak/007/issues/53#issuecomment-392474929

[09:55] *** wamba left
[09:55] <jnthn> (Also, this is not an endorsement of the singleton anti-pattern :P)

[09:55] <masak> jnthn: I think there's a bit of an overreaction sometimes to singletons being an anti-pattern

[09:56] <masak> jnthn: my conclusion from this the past few days is that modules *are* singletons, but (sort of) in the best of ways

[09:56] <El_Che> it's only an anti-pattern if you recognize it's a pattern :P

[09:56] <jnthn> masak: Yeah, it's not that they're always bad, it's just that I've seen a few too many mis-uses :)

[09:56] <masak> El_Che: I disagree. I think many people fruitfully use modules as singletons without realizing they are.

[09:57] <masak> when you import a module in multiple places in a code base, you *expect* the language not to do stupid things with re-running code it already ran

[09:57] <masak> that's because *modules are singletons*

[09:58] *** huf joined
[09:58] <masak> it's one very significant way in which modules differ from the other two big types of abstraction, functions and objects -- both of which have the ability to produce many instances from a common template

[09:59] <masak> functions and *classes, more like

[09:59] <masak> jnthn: aye, all the mis-uses of singletons are giving the singleton pattern a bad name.

[10:01] <moritz> whenever I consider a singleton, I ask myself "is there a chance I might want to two instances of this? for example when writing tests?"

[10:01] *** shareable6 left
[10:01] *** zostay_ is now known as zostay

[10:01] *** scott_ is now known as scott

[10:01] *** PotatoGim_ is now known as PotatoGim

[10:01] *** squashable6 joined
[10:01] *** ChanServ sets mode: +v squashable6

[10:01] <moritz> and often I can't think of a good reason first, and when I think about tests, I find some

[10:02] <masak> moritz: right, exactly. the risk inherent in singletons is actually that same old "I can't think of any use for this, so let's disallow it"

[10:02] <moritz> and then I ask myself "would that have any legitimate use cases outside of tests?", and most of the time the answer is "yes"

[10:03] <masak> moritz: I remember talking about this with mst, and I recall realizing that static attributes == globals == singletons in terms of the risk they create.

[10:04] <masak> ...and yes, writing tests is a good way to find those risks and limitations.

[10:05] <masak> applying the question "is there a chance I might want two instances of this?" to modules, I'd say the question is "no, because loading a module from disk into memory a second time should just be a no-op and give you the same module again"

[10:08] <masak> having two "instances" of the same module in different parts of a program would not add value, only muck things up

[10:10] <lizmat> masak: I assume you mean "same module" as having the same longname, right?  (including auth, version, api etc.)

[10:10] *** wictory[m] joined
[10:17] *** pmurias joined
[10:18] <pmurias> masak: isn't the what you refer to as "compile-time" in other dynamic languages more module load time?

[10:22] <pmurias> masak: JavaScript often has a separate compile time phase, one could even imagine a babel plugin to add BEGIN blocks to it

[10:24] <pmurias> masak: https://prepack.io/ - a tool to run code at minification time

[10:25] <lizmat> weekly: https://www.researchgate.net/publication/325320277_Perl_6_documentation_repository_through_time_dealing_with_issues

[10:25] <notable6> lizmat, Noted!

[10:30] <lizmat> .tell jmerelo re:https://twitter.com/jjmerelo/status/999601448718684160  ∅ is already the empty set, so no need to define it

[10:31] <lizmat> hmmm... did we lose yoleaux ?

[10:39] *** stux|RC joined
[10:42] <El_Che> 12:03 -!- yoleaux [~yoleaux@xn--ht-1ia18f.nonceword.org] has quit [Ping timeout: 240 seconds]

[10:42] <masak> lizmat: yes. (although this was in the context of 007, which just has "shortnames") :)

[10:43] <lizmat> *phew*  :-)

[10:45] <lizmat> notable6: weekly

[10:45] <notable6> lizmat, 6 notes: https://gist.github.com/b7b6a37c8496a994738173ecde4049f9

[10:59] <MasterDuke> dpk: looks like yoleaux pinged out of #perl, #perl6, and #moarvm

[11:00] *** yoleaux joined
[11:00] *** ChanServ sets mode: +v yoleaux

[11:00] <dpk> fixed, thanks for letting me know

[11:01] *** curan left
[11:02] <MasterDuke> that was fast, thanks!

[11:02] <lizmat> .tell jmerelo re:https://twitter.com/jjmerelo/status/999601448718684160  ∅ is already the empty set, so no need to define it

[11:02] <yoleaux> lizmat: I'll pass your message to jmerelo.

[11:02] <lizmat> dpk++

[11:05] <masak> pmurias: not sure I understand you completely, but I want to.

[11:05] <masak> pmurias: are you saying there's a separate "module load" phase that happens apart from compilation? how would that work?

[11:07] <masak> ok, I can see how handling the "lexical" things can happen all at compile time, but then actual module loading, and importing of actual values can happen at the start of runtime

[11:08] <masak> that seems like a really good idea, actually

[11:08] <masak> the difference is apparent in what would run first: an ordinary `say "module"` in an imported module, or a `BEGIN { say "main" }` after the `import` line in the main file

[11:16] *** raynold left
[11:18] *** Zoffix joined
[11:19] <Zoffix> .tell ktown your upload is broken. Looks like inner dir is packed inside another archive. Try using App::Mi6 it has a CPAN upload feature (but check it didn't bust your README.md file before uploading): https://irclog.perlgeek.de/perl6/2018-05-24#i_16202607

[11:19] <yoleaux> Zoffix: I'll pass your message to ktown.

[11:21] <Zoffix> .tell lizmat it's an illformatted upload (maybe PAUSE should be rejecting those?) So modules.perl6.org doesn't know how to work with it, so it's not on the site: https://irclog.perlgeek.de/perl6/2018-05-28#i_16213620

[11:21] <yoleaux> Zoffix: I'll pass your message to lizmat.

[11:21] *** Zoffix left
[11:21] *** itaipu joined
[11:25] *** Schepeers joined
[11:27] *** markong joined
[11:27] *** Schepeers_ left
[11:35] *** webstrand joined
[11:37] *** esh joined
[11:42] <Geth> ¦ doc: 2bd50837ea | (JJ Merelo)++ | doc/Language/structures.pod6

[11:42] <Geth> ¦ doc: Adds more role mixing stuff, refs #114

[11:42] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/2bd50837ea

[11:42] <synopsebot> Link: https://doc.perl6.org/language/structures

[11:42] <pmurias> masak: when precompiling the compilation phase and the module loading phase are clearly separated

[11:59] *** ChoHag left
[12:00] *** athenot_ joined
[12:09] <Geth> ¦ doc: 051f6fefed | (JJ Merelo)++ | doc/Language/structures.pod6

[12:09] <Geth> ¦ doc: Fixes error and adds text on subsets

[12:09] <Geth> ¦ doc: 

[12:09] <Geth> ¦ doc: Also reflows. Refs #114

[12:09] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/051f6fefed

[12:09] <synopsebot> Link: https://doc.perl6.org/language/structures

[12:15] *** athenot_ left
[12:16] *** athenot joined
[12:23] <Geth> ¦ doc: eb80d063a2 | (JJ Merelo)++ | doc/Language/structures.pod6

[12:23] <Geth> ¦ doc: Adds intro to introspection refs #114

[12:23] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/eb80d063a2

[12:23] <synopsebot> Link: https://doc.perl6.org/language/structures

[12:25] *** jmerelo left
[12:26] *** Schepeers left
[12:30] *** margeas joined
[12:32] *** markong left
[12:33] <masak> pmurias, jnthn: if `A` imports `b` from `B`, does `b` end up in the precompiled `A` module?

[12:36] *** margeas is now known as markong

[12:38] *** rindolf joined
[12:39] <masak> i.e. how self-contained is each precompiled module?

[12:53] *** athenot left
[12:56] *** Schepeers joined
[12:58] <jnthn> masak: They're statically linked against the modules they used

[13:04] <masak> so, only one copy of `b`: the one in `B`?

[13:06] *** jmerelo joined
[13:12] <jnthn> masak: Yes, in so far as they are linked, so we don't copy the code of b or even the code object. But if B changes then A's precompilation is invalidated.

[13:12] <jnthn> So it depends what you mean by "self-contained"

[13:12] <jnthn> If you write a custom EXPORT in B that does a closure clone per time the module is use'd then those closure clones would end up in the module that does the `use`

[13:16] <Geth> ¦ doc: 1f5fc5a40d | (JJ Merelo)++ | doc/Language/operators.pod6

[13:16] <Geth> ¦ doc: Rewrites link, refs #2067

[13:16] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/1f5fc5a40d

[13:16] <Geth> ¦ doc: e8b6eb9b6c | (JJ Merelo)++ | doc/Language/mop.pod6

[13:16] <Geth> ¦ doc: Improves HOW description

[13:16] <synopsebot> Link: https://doc.perl6.org/language/operators

[13:16] <synopsebot> Link: https://doc.perl6.org/language/mop

[13:16] <Geth> ¦ doc: 

[13:16] <Geth> ¦ doc: Which would effectively close #2067, besides the change in the link.

[13:16] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/e8b6eb9b6c

[13:17] *** jmerelo left
[13:24] *** domidumont left
[13:26] *** athenot joined
[13:28] *** Zoffix joined
[13:29] *** xtreak left
[13:29] <Zoffix> m: say 21824933675221.is-prime

[13:29] <camelia> rakudo-moar 740671273: OUTPUT: «True␤»

[13:29] <Zoffix> m: say sqrt(3) + sqrt(2) - sqrt(21824933675221/10**(pi.chars + pi.Int.chars)) == pi

[13:29] <camelia> rakudo-moar 740671273: OUTPUT: «True␤»

[13:29] <Zoffix> AMAZING! :)

[13:30] *** Zoffix left
[13:33] *** domidumont joined
[13:41] *** rindolf left
[13:45] *** rindolf joined
[13:46] *** domidumont1 joined
[13:46] *** domidumont left
[13:47] <masak> jnthn: right. "we don't copy" means the opposite of what I meant by "self-contained". good, then I understand.

[13:47] <masak> thanks for the explanation

[13:47] *** Tison joined
[13:48] <Tison> m: use nqp; nqp::say(42);

[13:48] <camelia> rakudo-moar 740671273: OUTPUT: «This type cannot unbox to a native string: P6opaque, Int␤  in block <unit> at <tmp> line 1␤␤»

[13:49] *** domidumont1 left
[13:49] <Tison> What's wrong with ⬆️? When use `nqp`, it prints 42 as expect.

[13:49] *** domidumont joined
[13:50] <lizmat> Tison: nqp proper does not automatically convert an Int to a Str

[13:50] <lizmat> when you say "use nqp" in Perl 6, then you're just enabling nqp:: ops,

[13:51] *** ChoHag joined
[13:55] *** athenot left
[14:06] <Tison> I see it prints 42 as expect if I use `nqp` command instead of `perl6`, such inconsistency confuses me

[14:07] <Tison> $ nqp -e 'use nqp; nqp::say(42)' # OUTPUT 42

[14:07] <timotimo> the nqp and rakudo compilers differ noticably in many respects

[14:07] <timotimo> in respect to their semantics, i mean

[14:08] <jnthn> It's because a string literal compiles into different things in Perl 6 and in NQP

[14:08] <timotimo> the most notable is that assignment doesn't exist in nqp

[14:08] <lizmat> ah, I got it backwards  :-)

[14:08] <timotimo> but if you "use nqp" you can still use assignment in your perl6 code

[14:08] <jnthn> And the thing it compiles into in Perl 6 won't magically turn itself into a string

[14:09] <Tison> get it

[14:09] <jnthn> If you're going to use `nqp::` ops, there's quite a few things that you'll need to spell out

[14:09] <jnthn> Though it still manages to do quite a few things for you 

[14:10] <timotimo> you often have to put nqp::decont in many places

[14:11] <timotimo> not "as opposed to in nqp" but "as opposed to in perl6"

[14:11] <Tison> XD

[14:20] *** wamba joined
[14:21] *** |oLa| joined
[14:22] *** Zoffix joined
[14:22] <Zoffix> Tison: the equivalent bot command is `nqp:` not `m:`

[14:23] <Zoffix> nqp: nqp::say(42);

[14:23] <camelia> nqp-moarvm: OUTPUT: «42␤»

[14:23] *** MasterDuke left
[14:23] <Zoffix> m: use nqp; nqp::say(nqp::unbox_i(42));

[14:23] <camelia> rakudo-moar 740671273: OUTPUT: «42␤»

[14:23] *** wamba left
[14:23] <Zoffix> m: use nqp; nqp::say(~42);

[14:23] <camelia> rakudo-moar 740671273: OUTPUT: «42␤»

[14:25] <Tison> thanks

[14:25] <Xliff_> \o

[14:25] *** Xliff_ is now known as Xliff

[14:26] *** MasterDuke joined
[14:26] <Xliff> I really wish HexChat had proper NickServ handling.

[14:26] <Zoffix> Xliff: proper is what?

[14:27] <Xliff> Zoffix: NickServ handling at other times than loading.

[14:27] <Xliff> And automatic nick reposession.

[14:27] <Xliff> I wonder how I would add Perl6 support to HexChat...

[14:28] <timotimo> worst case build a plugin in another language that just communicates via sockets

[14:28] <Xliff> timotimo++: Exactly my line of thinking

[14:28] <timotimo> next step up is probably to load libmoar and actually embed moarvm into the plugin itself, though that can have nasty effects when a plugin misbehaves 

[14:29] *** raschipi joined
[14:33] *** skids joined
[14:33] *** Zoffix left
[14:35] <Xliff> timotimo: That could be one large plugin.

[14:36] <timotimo> your best bet surely is to put the plugin into a docker container!

[14:40] <Geth> ¦ doc: KlappeZuAffeTot++ created pull request #2068: Create README.nl.md

[14:40] <Geth> ¦ doc: review: https://github.com/perl6/doc/pull/2068

[14:41] *** |oLa| left
[14:42] *** Tison left
[14:53] <Geth> ¦ doc: 523a7fe75f | KlappeZuAffeTot++ (committed using GitHub Web editor) | README.nl.md

[14:53] <Geth> ¦ doc: Create README.nl.md

[14:53] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/523a7fe75f

[14:53] <Geth> ¦ doc: 51699b951c | (Elizabeth Mattijsen)++ (committed using GitHub Web editor) | README.nl.md

[14:53] <Geth> ¦ doc: Merge pull request #2068 from KlappeZuAffeTot/patch-1

[14:53] <Geth> ¦ doc: 

[14:53] <Geth> ¦ doc: Create README.nl.md

[14:53] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/51699b951c

[14:58] <Geth> ¦ doc: 9f8c464a92 | (Jonas Kramer)++ (committed using GitHub Web editor) | doc/Type/Promise.pod6

[14:58] <Geth> ¦ doc: Fix typo

[14:58] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/9f8c464a92

[14:58] <synopsebot> Link: https://doc.perl6.org/type/Promise

[15:00] <Xliff> timotimo: I still need to learn those. :P

[15:03] <Xliff> Will ":(:$a, :$b, :$c, *:%e, *@a)" allow %e to slurp all the remaining named parameters into itself and still let @a grab the positionals?

[15:04] <jnthn> Should just be *%e

[15:04] <Xliff> I want just the positionals in @a.

[15:05] <Xliff> So...

[15:05] <Xliff> Will ":(:$a, :$b, :$c, *%e, *@a)" ?

[15:05] <lizmat> m: dd :(*@a, :$a, :$b, :$c, *%e)

[15:05] <camelia> rakudo-moar 740671273: OUTPUT: «:(*@a, :$a, :$b, :$c, *%e)␤»

[15:05] <lizmat> positionals before nameds

[15:06] <lizmat> m: dd :(:$a, :$b, :$c, *%e, *@a)

[15:06] <camelia> rakudo-moar 740671273: OUTPUT: «:(:$a, :$b, :$c, *%e, *@a)␤»

[15:06] <Xliff> OK. So that will work with MAIN, too?

[15:06] <lizmat> yup, it should

[15:06] <Xliff> lizmat++\

[15:06] <lizmat> if not, -> Issue

[15:07] <Xliff> Will do.

[15:25] *** rindolf left
[15:26] *** domidumont left
[15:29] *** rindolf joined
[15:36] *** jmerelo joined
[15:44] *** shareable6 joined
[15:49] *** psychoslave left
[15:52] *** domidumont joined
[16:00] *** kaare_ left
[16:02] <raschipi> u:  

[16:02] <unicodable6> raschipi, U+0020 SPACE [Zs] ( )

[16:03] <raschipi> u:  

[16:03] <unicodable6> raschipi, U+0020 SPACE [Zs] ( )

[16:03] <raschipi> u:  

[16:03] <unicodable6> raschipi, U+0020 SPACE [Zs] ( )

[16:04] *** kaare_ joined
[16:04] <raschipi> \msg unicodable6 

[16:08] *** robertle left
[16:15] *** domidumont1 joined
[16:17] *** sno left
[16:18] *** domidumont left
[16:21] *** molaf joined
[16:23] <Geth> ¦ doc: 1fe8938c82 | (JJ Merelo)++ | 2 files

[16:23] <Geth> ¦ doc: Finishes introspection

[16:23] <Geth> ¦ doc: 

[16:23] <Geth> ¦ doc: Adds some links and examples. Refs #114

[16:23] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/1fe8938c82

[16:28] *** shareable6 left
[16:30] *** wamba joined
[16:32] *** jmerelo left
[16:36] *** wamba left
[16:45] *** wamba joined
[16:49] *** enheh left
[16:55] <Xliff> lizmat: You were right. Things didn't work unless I had slurpy positional, first.

[16:55] <Xliff> Do you still want me to make an issue for that?

[17:01] <AlexDani`> u: a a

[17:01] <unicodable6> AlexDani`, U+000A <control-000A> [Cc] (control character)

[17:01] <unicodable6> AlexDani`, U+001A <control-001A> [Cc] (control character)

[17:01] <unicodable6> AlexDani`, Cowardly refusing to gist more than 5000 lines

[17:02] <AlexDani`> u: a ∞

[17:02] <unicodable6> AlexDani`, U+0061 LATIN SMALL LETTER A [Ll] (a)

[17:02] <unicodable6> AlexDani`, U+0020 SPACE [Zs] ( )

[17:02] <unicodable6> AlexDani`, U+221E INFINITY [Sm] (∞)

[17:02] *** AlexDani` is now known as AlexDaniel

[17:05] *** xinming left
[17:08] *** mcmillhj joined
[17:13] *** mcmillhj left
[17:20] *** isBEKaml joined
[17:20] *** isBEKaml left
[17:21] *** isBEKaml joined
[17:21] *** isBEKaml left
[17:22] *** mcmillhj joined
[17:24] *** isBEKaml joined
[17:24] *** isBEKaml left
[17:24] *** xinming joined
[17:25] *** isBEKaml joined
[17:26] *** shareable6 joined
[17:27] *** mcmillhj left
[17:33] *** wamba left
[17:37] <masak> this text vibed with me and reminded me of the Perl 6 RFC era: http://open-std.org/JTC1/SC22/WG21/docs/papers/2018/p0977r0.pdf

[17:40] *** mcmillhj joined
[17:44] *** mcmillhj left
[18:00] *** dct joined
[18:09] *** matzek joined
[18:11] <matzek> hello, i have fresh installed perl6 just right now on openbsd, freebsd and debian - on all installaations "race" do not work (simple 1 to 4 for loop). Any hints what coud be wrong?

[18:11] <timotimo> how do you measure "works"?

[18:11] <matzek> is simply doesnt "fork"

[18:12] <timotimo> you probably need to adjust the sizes for the race

[18:12] <timotimo> it probably just does all 4 units of work in one thread because it deems forking too expensive

[18:12] <timotimo> try this instead:

[18:12] <timotimo> m: (^100_000).hyper.grep(*.is-prime)[10_000].say

[18:12] *** dct left
[18:13] <camelia> rakudo-moar 740671273: OUTPUT: «Nil␤»

[18:13] <timotimo> oh?

[18:14] <matzek> hm?

[18:14] <timotimo> m: (^100_000).hyper.grep(*.is-prime)[9_500].say

[18:14] <camelia> rakudo-moar 740671273: OUTPUT: «98953␤»

[18:14] <timotimo> there simply aren't 10_000 primes between 0 and 100_000

[18:15] *** mcmillhj joined
[18:15] <timotimo> that's why there was a Nil

[18:15] <timotimo> but on my machine this uses ~320% cpu

[18:15] <timotimo> if you want to hyper over a very short sequence, do it like .hyper(:batch(1)) or so

[18:16] <timotimo> in the future, we may have a bit of adaptive code in there that tries to find out the right batch size for the work that is involved

[18:18] *** Zoffix joined
[18:18] <Zoffix> matzek: default batch size is 64. So if you only have 4 items, they'll be all in one batch. try .race(:1batch) to set it to batch by 1 item

[18:19] *** stmuk_ joined
[18:19] <matzek> nothing changed :(

[18:19] <Zoffix> matzek: and check you have 2018.01 or newer perl6 installed (perl6 -v). Just mentioning 'cause on some distros the packages are ancient and race was an experimental and largely broken feature until like end of 2017

[18:19] <AlexDaniel> matzek: what's your code?

[18:20] *** mcmillhj left
[18:20] <matzek> for (1..10).race(batch =>1){ .say; sleep 1;};

[18:20] <AlexDaniel> m: race for (1..10).race(batch =>1){ .say; sleep 1;};

[18:20] <camelia> rakudo-moar 740671273: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Missing block (whitespace needed before curlies taken as a hash subscript?)␤at <tmp>:1␤------> 3(1..10).race(batch =>1){ .say; sleep 1;}7⏏5;␤    expecting any of:␤        block or pointy b…»

[18:20] *** stmuk left
[18:20] <AlexDaniel> m: race for (1..10).race(batch =>1) { .say; sleep 1;};

[18:20] <camelia> rakudo-moar 740671273: OUTPUT: «1␤2␤3␤4␤5␤6␤7␤8␤9␤10␤»

[18:20] <Zoffix> matzek: `for` loops serialize RaceSeqs. Try a map or use `hyper for` to make for not serialize

[18:21] <timotimo> ooooh, of course

[18:21] <Zoffix> m: hyper for ^4 .race: :batch { sleep 1 }; say now - ENTER now

[18:21] <matzek> but this works in an 2017.* version..could that be?

[18:21] <camelia> rakudo-moar 740671273: OUTPUT: «1.05845854␤»

[18:21] <Zoffix> m: for ^4 .race: :batch { sleep 1 }; say now - ENTER now

[18:21] <camelia> rakudo-moar 740671273: OUTPUT: «4.00788434␤»

[18:21] <AlexDaniel> Zoffix: why hyper for and not race for?

[18:21] <Zoffix> m: race for ^4 .race: :batch { sleep 1 }; say now - ENTER now

[18:21] <camelia> rakudo-moar 740671273: OUTPUT: «1.04862536␤»

[18:22] <Zoffix> matzek: right, I meant `race for` not `hyper for`

[18:22] <Zoffix> AlexDaniel: brainffart

[18:22] <Zoffix> m: ^4 .race(:batch).map: { sleep 1 }; say now - ENTER now

[18:22] <camelia> rakudo-moar 740671273: OUTPUT: «1.0488654␤»

[18:22] <Zoffix> matzek: ^ or use a .map, which doesn't serialize

[18:23] <Zoffix> matzek: based on a bisect, you need about 2017.11 or newer rakudo for .hyper/.race to work right

[18:25] <matzek> mhm..i have someting to learn :D

[18:26] *** wamba joined
[18:26] *** sno joined
[18:27] <timotimo> the reasoning behind for requiring a hyper or race in front is that if you have a construction like for something() { } you can't tell if something() returns a Seq or HyperSeq, so a) an API change for something() can suddenly unexpectedly turn your for loop parallel, b) you can't see from just the code whether it'll parallelize or not

[18:27] <Zoffix> There's an open docs Issue D#1897   It has a link to the spreadsheet with the semantics of Race/Hyper Seqs with how they work with various methods. Still needs to be turned into proper docs.

[18:27] <synopsebot> D#1897 [open]: https://github.com/perl6/doc/issues/1897 [docs] Semantics of HyperSeq/RaceSeq appear to be undocumented

[18:27] <matzek> hmhm

[18:28] *** itaipu left
[18:28] *** itaipu joined
[18:28] <matzek> my plan is to have al loop and to start some parallel web requests via qqw{ lynx blabla}

[18:29] <matzek> so i have about 10000 hosts/domains to check its http header for example

[18:30] <matzek> race looks useful for that task

[18:30] <Zoffix> eco: Proc::Q

[18:30] <buggable> Zoffix, Proc::Q 'Queue up and run a herd of Procs': http://modules.perl6.org/dist/Proc::Q:github:Zoffix%20Znet

[18:31] <Zoffix> matzek: ^ don't know if the interface will be over your head, but you could use that module

[18:34] <matzek> ok i will try it. thank you for support!

[18:34] *** mcmillhj joined
[18:37] <Zoffix> matzek: this uses `curl` and prints headers. Default batch is 8: perl6 -MProc::Q -e 'my @domains = "https://" «~« <perl6.party rakudo.party perl6.org docs.perl6.org>; react whenever proc-q @domains.map({«curl -sD - -o "$*SPEC.devnull()" -- $_»}), :tags[@domains] { "**** {.tag}:\n{.out}".say }'

[18:39] *** mcmillhj left
[18:40] <matzek> wtf :D

[18:44] <masak> could you be more specific

[18:45] <Zoffix> `"https://" «~« <perl6.party ...>` just prepends `https://` to all the addresses, so then `@domains` has the domain addresses. Then `proc-q` is the sub from the module. It takes a list of lists of arguments to give to Proc::Async, so `@domains.map({«curl -sD - -o "$*SPEC.devnull()" -- $_»})` converts the list of domains to a list of lists of `curl` command with args and domain name in `$_`. The `:tags`

[18:45] <Zoffix> just has matching tags for the commands, so when the commands complete you can figure out which command finished (since they'd finish out of order). The `proc-q` sub returns a throttled Supply and `react whenever` reacts whenever a command finishes, and it runs the `"**** {.tag}:\n{.out}".say` code, which just prints the tag (in this case the domain) and the STDOUT of the completed `curl` command that has the

[18:45] <Zoffix> headers for that domain. When all commands finish processing the `react` block ends and the program exits.

[18:48] *** domidumont1 left
[18:49] <Geth> ¦ doc: 40703f7efb | (Tom Browder)++ (committed using GitHub Web editor) | doc/Language/regexes.pod6

[18:49] <Geth> ¦ doc: correct typo (should be plural form)

[18:49] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/40703f7efb

[18:49] <synopsebot> Link: https://doc.perl6.org/language/regexes

[18:50] *** mcmillhj joined
[18:51] *** Zoffix left
[18:52] <matzek> is the a way to tell Proc::Q how many procs it is allowed to handle at a time?

[18:52] *** fascinum joined
[18:54] *** mcmillhj left
[18:57] *** Zoffix joined
[18:58] <Zoffix> matzek: yeah, it's the `:batch` arg to `proc-q` sub: https://github.com/zoffixznet/perl6-Proc-Q#batch

[18:59] *** mcmillhj joined
[19:02] <matzek> i see

[19:06] *** espadrine_ joined
[19:07] *** darutoko left
[19:09] *** Zoffix left
[19:10] <matzek> ahh.. so your sub puts the arguments in the list as an shell command back into the perl script

[19:11] *** psychoslave joined
[19:14] *** mcmillhj left
[19:16] <Geth> ¦ doc: 4caa060cfa | (Tom Browder)++ (committed using GitHub Web editor) | doc/Language/regexes.pod6

[19:16] <Geth> ¦ doc: fix typo

[19:16] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/4caa060cfa

[19:16] <synopsebot> Link: https://doc.perl6.org/language/regexes

[19:20] *** xtreak joined
[19:20] <lizmat> Xliff: yes, please

[19:21] *** xtreak left
[19:22] *** shareable6 left
[19:25] *** Luneburg joined
[19:25] <Luneburg> Is there a simple way to check if a number is divisible by all numbers in a lazy list?

[19:26] <lizmat> how long do you want to wait ?

[19:26] <El_Che> lol

[19:27] <lizmat> Luneburg: is the lazy list finite or not ?

[19:27] <Luneburg> lizmat: Oh yeah, it's quite short

[19:28] <jnthn> %number %% all(@the-lazy-list) or some such

[19:28] <jnthn> %number %% all(eager @the-lazy-list) if it insists on being forced eager

[19:28] <jnthn> uh, and $number :)

[19:29] <Luneburg> Ah, I was was trying $number %% @lazylist.all

[19:29] <Luneburg> jnthn: Thanks :D

[19:30] <raschipi> m: say so 42 %% all(2,4,6...100), so 34243224702511976248246432895208185975118675053719198827915654463488000000000000 %% all(2,4,6...100)

[19:30] <camelia> rakudo-moar 740671273: OUTPUT: «FalseTrue␤»

[19:32] *** Ven`` joined
[19:33] *** molaf left
[19:33] *** jmerelo joined
[19:35] *** Ven` joined
[19:35] *** Ven`` left
[19:37] *** comborico1611 joined
[19:42] *** Ven` left
[19:43] *** mcmillhj joined
[19:46] *** matzek left
[19:47] <Geth> ¦ doc: 41107b7fe0 | (JJ Merelo)++ | 2 files

[19:47] <Geth> ¦ doc: Moves the reification tutorial glossary → structures

[19:47] <Geth> ¦ doc: 

[19:47] <Geth> ¦ doc: Which is probably a better place for it. Refs #114

[19:47] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/41107b7fe0

[19:48] *** mcmillhj left
[19:54] *** silug joined
[19:59] <Xliff> How much introspection can you do with tokens, rules and regex's?

[19:59] <Xliff> I would like to see if I can look into a rule or token and see what other descendant rules were used in it. Is that possible using rakudo?

[20:02] *** mcmillhj joined
[20:02] <jmerelo> Xliff: that's not exactly introspection, which is mainly looking at object metadata

[20:02] <yoleaux> 11:02Z <lizmat> jmerelo: re:https://twitter.com/jjmerelo/status/999601448718684160  ∅ is already the empty set, so no need to define it

[20:03] <jmerelo> m: say ∅.^name

[20:03] <camelia> rakudo-moar 740671273: OUTPUT: «Set␤»

[20:03] <jmerelo> Wow.

[20:03] <lizmat> :-)

[20:03] <jmerelo> lizmat: thanks!

[20:03] <jmerelo> Running to change the text.

[20:03] *** skids left
[20:05] <Geth> ¦ doc: fc3b34c2b1 | (JJ Merelo)++ | 2 files

[20:05] <Geth> ¦ doc: No need to define the empty set (thanks @lizmat)

[20:05] <Geth> ¦ doc: 

[20:05] <Geth> ¦ doc: Also adds some text to the data structures on using eager for early reification.

[20:05] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/fc3b34c2b1

[20:05] <jmerelo> lizmat: we'll probably have to add it somewhere else... 

[20:06] <jmerelo> lizmat: oh, it's added already. Never mind :-) Thanks anyway.

[20:06] *** mcmillhj left
[20:08] <Xliff> jmerelo: But is it possible?

[20:10] <MasterDuke> m: my token foo { "foo" }; my token bar { "bar" }; my $a = token { <foo> <bar> }; say $a.perl

[20:10] <camelia> rakudo-moar 740671273: OUTPUT: «token { <foo> <bar> }␤»

[20:10] <jmerelo> Xliff: I would say Grammar::Tracer is the closest thing 

[20:11] <MasterDuke> i guess you could parse it out of the .perl output. parsing Perl 6 is easy, right...

[20:12] <lizmat> AlexDaniel: if I'm going to mention the next Squashathon in the P6W, perhaps the Contributing.md should not be a 404 ?

[20:12] <Xliff> jmerelo: OK, thanks. I will look into that.

[20:13] *** mcmillhj joined
[20:14] *** parv left
[20:16] <Geth> ¦ doc: 216c1ff778 | (JJ Merelo)++ | doc/Language/math.pod6

[20:16] <Geth> ¦ doc: Reflows and uses lowercase ∅

[20:16] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/216c1ff778

[20:16] <synopsebot> Link: https://doc.perl6.org/language/math

[20:16] *** shareable6 joined
[20:16] <Xliff> Ah.

[20:16] <Xliff> So Grammar::Tracer is cheating.

[20:17] <Xliff> It takes over the normal grammar find_method and uses it for its own nefarious purposes.

[20:17] *** mcmillhj left
[20:17] <Xliff> Not... quite ... what I was looking for. It's kinda brute force.

[20:18] <Xliff> So, replace normal GrammarHOW with CustomGrammarHOW and run rule, in find_method, note all methods called and push them to a list. Restore normal GrammarHOW.

[20:19] <Xliff> If that sounds like I'm vaguely near the right track (to oblivion), please let me know.

[20:20] <Geth> ¦ doc: 9afe5ee053 | (JJ Merelo)++ | doc/Language/structures.pod6

[20:20] <Geth> ¦ doc: Document on data structures is completed.

[20:20] <Geth> ¦ doc: 

[20:20] <Geth> ¦ doc: I would be happy as a clam if this closed an issue, but it only means

[20:20] <Geth> ¦ doc: a feeble tick in the humongous #114. However, closer to the end, with

[20:20] <synopsebot> Link: https://doc.perl6.org/language/structures

[20:20] <Geth> ¦ doc: just a couple of pages to go...

[20:20] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/9afe5ee053

[20:20] <Xliff> But might that not catch all rules, especially since the Longest Term Alternation (oh noes! another LTA!) will optimize some out?

[20:21] <jmerelo> Xliff: really no idea. You could ask moritz, he's usually around... Or...

[20:21] <jmerelo> Xliff: ... wait for it ...

[20:21] <Xliff> jmerelo: LOL

[20:21] <jmerelo> Xliff: ... StackOverflow! 

[20:21] <Xliff> jmerelo: I'm really typing to myself, ATM

[20:21] <jmerelo> He is usually there, as well as, well, everyone else, including many that are not usually in this channel...

[20:21] <Xliff> jmerelo: I doubt SO has something this esoteric.

[20:21] <Xliff> I will wait for a bit and try, later.

[20:22] <Xliff> jmerelo: Oh, I know. I am on SO as well.

[20:22] <lizmat> .oO( das rubberducken ist fuer gegen zu reden )

[20:22] <Xliff> SO is the Facebook/Twitter for developers.

[20:22] <Xliff> Or am I wrong and it's more like the Reddit for Developers.

[20:22] <Xliff> ?

[20:22] * Xliff runs.

[20:22] <moritz> I am around, occasionally

[20:22] <lizmat> .oO( sparkenspitzen und blowenfusen )

[20:23] <moritz> if somebody has a question for me that doesn't require excessive backlogging, I'll try my best

[20:23] <Xliff> Did lizmat just blow a fuse?

[20:23] <Xliff> <Xliff> How much introspection can you do with tokens, rules and regex's?

[20:23] <Xliff> <Xliff> I would like to see if I can look into a rule or token and see what other descendant rules were used in it. Is that possible using rakudo?

[20:23] <lizmat> no, I was imagining the special effect while you were running :-)

[20:23] <jmerelo> And I'm AFK as of now. Take care, see you tomorrow CET

[20:23] <Xliff> lizmat: LOL!@

[20:23] <Xliff> lizmat: LOTS of smoke clouds.

[20:24] *** jmerelo left
[20:24] <moritz> Xliff: I'm not aware of that kind of introspection

[20:24] <Xliff> OK. Maybe I am using the wrong word.

[20:24] <Xliff> I don't know how deeply you can inspect grammars.

[20:25] <Xliff> Or grammar components for that matter.

[20:25] <Xliff> It's just that I have a token with a LOT of terms in it, and I want to try and gracefully unit test it.

[20:25] *** shareable6 left
[20:25] <Xliff> (Hint: gracefully is a Xliff-speak for lazy)

[20:26] <moritz> decompose it into a proto token with lots of alternatives

[20:26] <moritz> and test them individually

[20:27] <Xliff> But how to do so without a LOT of code?

[20:27] <moritz> table driven

[20:27] <moritz> the testing, at least

[20:27] <moritz> if you show me an example, maybe I have some more concrete hints

[20:28] <Xliff> https://github.com/Xliff/perl6-Parser-Sql/blob/master/lib/Parser/SQL/Grammar/Tokens.pm6#L658

[20:29] <Xliff> I guess I can grab the list of actual keyword tokens and just run them all through.

[20:29] <Xliff> I actually DO have that.

[20:30] <MasterDuke> Xliff: for something big, but relatively simple, maybe my half-joking answer would actually work

[20:30] <raschipi> I will close doc issue #114 and open two new issues for the two last pages to make jmerelo happy.

[20:30] <Xliff> MasterDuke: And what's that?

[20:30] <moritz> Xliff: I'd still rewrite it as a proto token

[20:30] <Xliff> moritz: Your reasoning, praytell?

[20:30] <moritz> Xliff: that allows adding of keywords through subclassing, for example

[20:31] <MasterDuke> m: my token foo { "foo" }; my token bar { "bar" }; my $a = token { <foo> <bar> }; say $a.perl

[20:31] <camelia> rakudo-moar 740671273: OUTPUT: «token { <foo> <bar> }␤»

[20:31] <moritz> or mixing in roles that add alternatives

[20:31] *** mcmillhj joined
[20:31] <moritz> extensibility, in a word

[20:31] <Xliff> moritz: Your last reason has serious merit.

[20:31] <Xliff> Because I would hope to expand this into something not MySQL specific.

[20:32] <Xliff> I may need to think about renaming the module close to release time for example.

[20:32] <Xliff> moritz: Can you give me an example of how you would proto that?

[20:32] <Xliff> Just 3 lines will help.

[20:33] <moritz> proto token keyword_sp { * }

[20:33] <MasterDuke> m: my token foo { "foo" }; my token bar { "bar" }; my $a = token { <foo> <bar> }; say $a.perl ~~ m:g/"<" ~ ">" [\w+]/

[20:33] <camelia> rakudo-moar 740671273: OUTPUT: «(｢<foo>｣ ｢<bar>｣)␤»

[20:34] <moritz> token keyword_sp:sym<ACTION> { <ACTION> }

[20:34] <moritz> token keyword_sp:sym<ADDDATE> { <ADDDATE> }

[20:34] <Xliff> Ah! That.

[20:34] <moritz> or if you don't need the separate rules, you can write it as

[20:34] <Xliff> You'd still need proto keyword_sp:sym<*>

[20:34] <moritz> token keyword_sp:sym<ACTION> { <sym> }

[20:35] <moritz> token keyword_sp:sym<ADDDATE> { <sym> }

[20:35] <Xliff> No, I'd just need a way to retrieve what keyword_sp matched.

[20:35] <moritz> ~$<keyword_sp>

[20:35] *** mcmillhj left
[20:35] <Xliff> kk

[20:36] <Xliff> moritz: That's an idea I should look into, for real.

[20:36] <Xliff> But that will blow my code size up quite a bit.

[20:36] <moritz> Xliff: real-world example of a proto token: https://github.com/moritz/json/blob/master/lib/JSON/Tiny/Grammar.pm#L11

[20:37] <moritz> well, only if you need the separate ACTION etc. rules

[20:37] <Xliff> Wish I could just run that through a loop and do it that way,.

[20:37] <Xliff> I don't think I will need separate ACTION rules since this will just all end up into a parsing data table.

[20:37] <Xliff> And if someone wants to do that, they can subclass and change everything.

[20:38] <Xliff> Or ... maybe fork....

[20:38] <Xliff> Probably fork.

[20:45] *** mcmillhj joined
[20:46] <Luneburg> Guys I have some simple (and beautiful ;) ) code that doesn't work properly, could someone take a look please?

[20:46] *** Libre joined
[20:46] *** dct joined
[20:46] <raschipi> Sure

[20:47] <Luneburg> raschipi: Cool, I'll put it in a pastebin

[20:49] *** Kaiepi left
[20:49] <Luneburg> raschipi: Here's the link (prepare to be delighted) https://0bin.net/paste/Mn9b7jsjVekOMz-L#zZw5YVRaXYMB3DScrkhbLAdq+XPOFpP2ZdFOvQKvxkA

[20:50] *** mcmillhj left
[20:50] <raschipi> what's the problem with it?

[20:50] <Luneburg> Well, it doesn't display all the positions properly

[20:51] <raschipi> why not?

[20:51] <Luneburg> So if I press w from the X in the centre-left, it doesn't go directly up

[20:51] <Luneburg> It goes to the centre up

[20:51] <Luneburg> Even though it looks fine in the code

[20:54] <raschipi> You insist on keeping the structure as-is?

[20:54] <timotimo> Luneburg: this might blow your mind, but did you know about heredocs, in particular that you can indent them?

[20:55] <raschipi> I don't see where $position is updated...

[20:55] <Luneburg> raschipi: I just haven't thought of a better way to do it yet :P

[20:55] <timotimo> are you interested in a tip that'd let you have an $x and $y position integer and it'd place the X for you?

[20:56] <Luneburg> timotimo: heredocs?

[20:56] <timotimo> yup! give me a second

[20:56] <Luneburg> timotimo: :O

[20:56] *** mcmillhj joined
[20:57] <timotimo> actually i need to get dinner out of the oven right now

[20:57] <Luneburg> raschipi: I think that is the problem with this code, as the structure is right now

[20:57] <timotimo> so i'll just send a documentation link fo rnow https://docs.perl6.org/syntax/heredocs%20:to

[21:00] <Luneburg> raschipi: Yup, now that I update the $position it works properly :D Thanks for the help

[21:00] <Luneburg> timotimo: That's cool :D Also, for when you come back from dinner, could you tell me about those $x and $y positions?

[21:01] <raschipi> If you put an Order::Same in a variable, it will have numeric value 0, and can only change into Order::More (value 1) or Order::Less (value -1).

[21:01] <timotimo> https://hub.mybinder.org/user/bduggan-p6-jupyter-kernel-n1fn8aza/notebooks/eg/Untitled.ipynb?kernel_name=perl6

[21:01] <timotimo> can you access this, Luneburg?

[21:01] *** mcmillhj left
[21:02] <raschipi> Gotta go, bye.

[21:02] <lizmat> and another Perl 6 Weekly hits the Net: https://p6weekly.wordpress.com/2018/05/28/2018-22-gdpr-to-you-too/

[21:04] *** rindolf left
[21:06] *** raschipi left
[21:07] *** ChoHag left
[21:07] *** rindolf joined
[21:07] <timotimo> Luneburg: the approach i'm using there scales poorly to multiple Xes; in that case i would build an actual array of arrays that has single characters in it and access it like @fields[$y][$x] = "X" (and taking care to reset them to " " whenever necessary)

[21:08] *** aindilis joined
[21:10] <Luneburg> timotimo: it's asking for a token or password

[21:10] <timotimo> oh, hmm

[21:11] *** mcmillhj joined
[21:12] <timotimo> https://0bin.net/paste/IzH1tn-qxJD7vwDk#71e6-OztKLMXF+iE0Xc2kYPCE/zJmYkFU8qFhgy3Qtl - this does not look very good, but it's what i did

[21:15] *** mcmillhj left
[21:16] <Luneburg> timotimo: Looks just fine :)

[21:16] <timotimo> it has the code above and output below

[21:19] <Luneburg> timotimo: Ah, it's a bit different

[21:20] <Luneburg> timotimo: The thing I was doing was getting it to move about with a, d, w, and s

[21:21] <timotimo> yes, now you only need to change $x and $y based on what letter was pressed

[21:21] <timotimo> have a "main loop" that goes as long as the player wants to play, show the field, grab a key, change the position, and back to the start

[21:23] *** molaf joined
[21:23] <Luneburg> timotimo: Having a main loop that keeps running is a great idea, it solves so many problems. Earlier I was using get statements for a space invaders game, but it was fully deterministic based on where you moved.

[21:23] <Luneburg> I mean given statements

[21:25] *** Libre left
[21:28] <timotimo> yes, that is an extremely tedious approach

[21:30] *** vike left
[21:35] *** vike joined
[21:36] <moritz> lizmat++ # weekly

[21:41] *** Luneburg left
[21:41] *** mcmillhj joined
[21:46] *** ryn1x left
[21:46] *** mcmillhj left
[21:46] *** ChoHag joined
[21:47] *** vike left
[21:47] *** ryn1x joined
[21:48] *** enheh joined
[21:51] *** vike joined
[21:54] *** mcmillhj joined
[21:59] *** mcmillhj left
[21:59] *** fascinum left
[21:59] *** molaf left
[22:12] *** mcmillhj joined
[22:13] *** ryn1x left
[22:14] *** rindolf left
[22:17] *** mcmillhj left
[22:30] *** HaraldJoerg left
[22:32] *** roguelazer joined
[22:33] *** mcmillhj joined
[22:36] *** fascinum joined
[22:37] *** mcmillhj left
[22:43] *** itaipu left
[22:53] *** titsuki joined
[23:00] *** mcmillhj joined
[23:04] *** fascinum left
[23:04] *** mcmillhj left
[23:09] *** giraffe joined
[23:10] *** giraffe is now known as Guest80598

[23:12] *** wamba left
[23:12] *** wamba joined
[23:15] *** psychoslave left
[23:16] *** mcmillhj joined
[23:19] *** w_richard_w joined
[23:20] *** mcmillhj left
[23:37] *** dct left
[23:37] *** espadrine_ left
[23:39] *** wamba left
[23:44] *** markong left
[23:44] *** fascinum joined
[23:47] *** mcmillhj joined
[23:51] *** mcmillhj left
[23:56] *** pmurias left
