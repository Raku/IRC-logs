[00:08] *** dct left
[00:10] <AlexDaniel> joya: maybe! I think I can argue either way

[00:11] <AlexDaniel> joya: but binding is a safe and clear way to do it

[00:11] <AlexDaniel> also, this gives a nice error message:

[00:11] <AlexDaniel> m: my %h = :{ (now) => "Instant", (DateTime.now) => "DateTime" };

[00:11] <camelia> rakudo-moar e9351cbaa: OUTPUT: «Potential difficulties:␤    Useless use of hash composer on right side of hash assignment; did you mean := instead?␤    at <tmp>:1␤    ------> 3Instant", (DateTime.now) => "DateTime" }7⏏5;␤»

[00:12] <turdmonkey> Given a sub my_sub { ... }

[00:12] <turdmonkey> what is the difference between 

[00:13] <turdmonkey> my_sub and &my_sub

[00:13] <Juerd> turdmonkey: my_sub calls the sub, &my_sub is the subroutine itself.

[00:14] <AlexDaniel> joya: also, with = you can probably do something like `my Mu %h{Any} = $foo`, right?

[00:14] <Juerd> turdmonkey: You can use &my_sub to pass the subroutine as an argument to another subroutine without calling(executing) it.

[00:14] <turdmonkey> Oh! Excellent

[00:15] <turdmonkey> That accidentally answers my next question.

[00:15] <timotimo> or call methods on the sub object

[00:15] <timotimo> for introspection and such

[00:15] <Juerd> turdmonkey: Note, though, that if you use &my_sub() with the paretheses, that *is* a call.

[00:15] <Juerd> s/pare/paren/

[00:19] <AlexDaniel> joya: but, if you stumbled upon this behavior on accident, and didn't intend it

[00:19] <AlexDaniel> joya: then maybe it should be documented here: https://docs.perl6.org/language/traps

[00:19] *** e5r joined
[00:19] <AlexDaniel> joya: please file a ticket on https://github.com/perl6/doc/issues/ if you feel strongly about it :)

[00:20] *** e5r left
[00:20] *** mcmillhj joined
[00:21] *** perlpilot joined
[00:22] <joya> AlexDaniel: it doesn't always give a nice error message

[00:25] *** mcmillhj left
[00:25] <raschipi> If the error messages are LTA (less than awesome), that's also a bug you'd file here: https://github.com/rakudo/rakudo/issues

[00:25] <joya> AlexDaniel: for example, if i do: my %hm = (1..10).classify: * <= 5

[00:26] <raschipi> Example of LTA issue: https://github.com/rakudo/rakudo/issues/1965

[00:26] <raschipi> m: my %hm = (1..10).classify: * <= 5

[00:26] <camelia> rakudo-moar e9351cbaa: ( no output )

[00:26] <joya> the hash has Str keys in it .. I can't think of a compelling reason why it shouldn't receive typed keys

[00:26] <raschipi> m: my %hm = (1..10).classify: * <= 5; say %hm

[00:26] <camelia> rakudo-moar e9351cbaa: OUTPUT: «{False => [6 7 8 9 10], True => [1 2 3 4 5]}␤»

[00:26] <joya> oh it's not an LTA issue

[00:26] <joya> basically the type gets erased with no warning

[00:27] <joya> now try %hm.keys[0].^name

[00:27] <joya> they're Str .... 'True' and 'False'

[00:27] <timotimo> assigning into a hash variable is different from binding in that sense

[00:27] <joya> yes i realize the advantage of binding

[00:27] <timotimo> when you %foo = %bar it'll unpack the pairs of %bar and stash them info %foo

[00:27] <timotimo> unless we want to make it illegal to assign into a more general hash i don't know what to do here

[00:27] <turdmonkey> Can you have optional function parameters e.g 'sub my_sub($var, $optional?) { ... }

[00:28] <timotimo> yes, you can, exactly the way you've suggested it

[00:28] <timotimo> either with a ? at the end, or with a default value after a =

[00:28] <joya> is there a way to specify types when you create the hash itself

[00:28] <timotimo> yes, of course

[00:28] <turdmonkey> well that is awesome

[00:28] <joya> ok, that is my problem then -- i do not know that

[00:28] <timotimo> m: my %foo{Any} = (1..10).classify: * <= 5; say %foo.keys.perl

[00:28] <camelia> rakudo-moar e9351cbaa: OUTPUT: «(Bool::False, Bool::True).Seq␤»

[00:28] <timotimo> m: my %foo = (1..10).classify: * <= 5; say %foo.keys.perl

[00:28] <camelia> rakudo-moar e9351cbaa: OUTPUT: «("True", "False").Seq␤»

[00:29] <joya> but can you do it on the same line as an assignment

[00:29] <joya> it's not perl unless i can put the entire program on one line

[00:29] <timotimo> my first example there should give you that answer

[00:29] <turdmonkey> hahahahahaha

[00:30] <joya> interesting because the {Any} actually makes it look like it is declared untyped

[00:31] <raschipi> It would be very surprising if the opposite was true, if Hash keys weren't typed as Str. That's what most people expect, "Object Hashes" are not an obvious feature and not easy to use due to the well known object comparisson issue (which exists in all languages)..

[00:31] <timotimo> the { } is intended to stand for "key goes here"

[00:31] <raschipi> Hashes have Str as default type for keys.

[00:31] <timotimo> but essentially, yes, you're going for an untyped array

[00:32] <timotimo> er, hash

[00:32] <joya> ok, i get what you mean

[00:32] <timotimo> you can of course have my %foo{Bool} in the classify example

[00:32] <joya> so would it be correct to say that my %hm; and my %hm{Str}; are equivalent

[00:32] <timotimo> m: say (my %foo).keyof.perl

[00:32] <camelia> rakudo-moar e9351cbaa: OUTPUT: «Str(Any)␤»

[00:32] <raschipi> Most people don't even know of non-Str Hash keys.

[00:33] <timotimo> joya: almost, since the default is actually a coercion type

[00:33] <timotimo> m: my %hm{Str} = (True) => 1;

[00:33] <camelia> rakudo-moar e9351cbaa: OUTPUT: «Type check failed in binding to parameter 'key'; expected Str but got Bool (Bool::True)␤  in block <unit> at <tmp> line 1␤␤»

[00:33] <timotimo> m: my %hm{Str(Any)} = (True) => 1;

[00:33] <camelia> rakudo-moar e9351cbaa: OUTPUT: «Type check failed in binding to parameter 'key'; expected Str(Any) but got Bool (Bool::True)␤  in block <unit> at <tmp> line 1␤␤»

[00:33] <timotimo> er, oops?

[00:34] <raschipi> Is Bool Str(Any)? Rakudo is confused.

[00:34] <turdmonkey> lol @ 'spurt' and 'slurp'

[00:34] <timotimo> i think it's not doing it right

[00:35] <timotimo> m: say (my %hm{Str(Any)}).keyof.perl

[00:35] <camelia> rakudo-moar e9351cbaa: OUTPUT: «Str(Any)␤»

[00:35] <timotimo> hm.

[00:36] *** mcmillhj joined
[00:37] <timotimo> anyway, i'll probably go to bed now. seeya!

[00:37] <joya> 'my %hm{Bool(*)} =' works

[00:38] <joya> although doesnt really refine things beyond %hm{Bool} alone

[00:39] <geekosaur> it probably should refuse coercion types there if it can;t handle them

[00:39] <raschipi> m: my %hm{Str(*)} = (True) => 1; dd %hm;

[00:39] <camelia> rakudo-moar e9351cbaa: OUTPUT: «Hash[Any] %hm = (my Any % = :True(1))␤»

[00:40] <raschipi> m: my %hm{Str(*)} = (True) => 1; dd %hm.keyof;

[00:40] <camelia> rakudo-moar e9351cbaa: OUTPUT: «Str(Any)␤»

[00:40] *** mcmillhj left
[00:40] <turdmonkey> if($foo) interprets it has a sub yes?

[00:41] <turdmonkey> so i have to do either: if ($foo) or if $foo

[00:42] <joya> i think the object key "strategy" should be made a little more obvious since people will be plugging boolean expressions into classify all the time

[00:43] <raschipi> turdmonkey: yes

[00:44] <raschipi> joya: It's the most obvious there is.

[00:45] <raschipi> People are usually surprised when they learn it's possible to have Hashes with anything other than Str as keys.

[00:46] *** statisfiable6 joined
[00:48] <joya> related question then: how does my Array %hm{Bool} differ from my %hm{Bool(Array)}

[00:49] <joya> does the second contain what you referred to as a coercion type

[00:50] <raschipi> m: my Array %hm{Bool}; my %mh{Bool(Array)}; dd %hm, %mh

[00:50] <camelia> rakudo-moar e9351cbaa: OUTPUT: «Hash[Array,Bool] %hm = (my Array %{Bool})␤Hash[Any,Bool(Array)] %mh = (my Any %{Bool(Array)})␤»

[00:51] <raschipi> Yes, Bool(Array) will take an array and coerce it to Bool, which is False if the Array is empty and True if it has something in it.

[00:52] <raschipi> Array is too restrictive, you'd want Positional, which can be Arrays, Lists and Seqs.

[00:52] <joya> ok i found the coercion types page

[00:52] <raschipi> m: my Array $n = <a b c>; say $n

[00:52] <camelia> rakudo-moar e9351cbaa: OUTPUT: «Type check failed in assignment to $n; expected Array but got List ($("a", "b", "c"))␤  in block <unit> at <tmp> line 1␤␤»

[00:53] *** mcmillhj joined
[00:53] <raschipi> A List isn't an Array.

[00:53] <raschipi> m: my Positional $n = <a b c>; say $n

[00:53] <camelia> rakudo-moar e9351cbaa: OUTPUT: «(a b c)␤»

[00:53] <raschipi> m: my Positional $n = ['a', 'b', 'c']; say $n, $n.^name

[00:53] <camelia> rakudo-moar e9351cbaa: OUTPUT: «[a b c]Array␤»

[00:54] <turdmonkey> Ok, this will be interesting.

[00:54] <raschipi> Oh, Seqs aren't Positional, sorry.

[00:54] <turdmonkey> Should I use Channels to open up a new worker each time my program finds a new URL ?

[00:54] <turdmonkey> With a limit.

[00:56] <raschipi> turdmonkey: Sorry, can't say, you need to explain more.

[00:57] *** mcmillhj left
[00:59] <joya> well, thanks for the help, raschipi and timo, 😅

[01:01] *** lookatme joined
[01:01] <turdmonkey> Well...

[01:02] <turdmonkey> I only know about Perl's Channel object

[01:02] <turdmonkey> in my web crawler, I want to open up a new thread every time it finds a link

[01:03] <turdmonkey> so i'm thinking something like

[01:04] <raschipi> joya: Wou're welcome.

[01:04] <turdmonkey> 'my $channel = Chanell.new; $channel.send($) for get-urls($url);

[01:04] <turdmonkey> $channel.send($_)

[01:04] <raschipi> You probably want a Supply.

[01:05] <raschipi> https://docs.perl6.org/type/Supply

[01:05] <raschipi> No, sorry, other way around.

[01:05] <raschipi> Supply is for when you want everyone to get the messages. Channel is when you want only one of the listeners to get it.

[01:06] <turdmonkey> oh, cool

[01:06] <turdmonkey> I figure I will have a separate Channel object for each link

[01:06] <turdmonkey> on my way to segfault land

[01:07] <turdmonkey> like this:

[01:07] <raschipi> Can have only one channel and when you send, only one thread will get it. It's like a queue.

[01:08] <turdmonkey> 'my @links; for 1..10 { push @links, start { while (my $link = $channel.poll) { process-urls; } } }

[01:09] *** zachk left
[01:10] <raschipi> Probably want it to block using .receive instead of .poll

[01:11] <turdmonkey> Ah yes...I definately do

[01:11] <turdmonkey> does that code do what I think?

[01:12] <turdmonkey> each time it receives a link, it will spawn a thread, up to a max of 10, and process it

[01:15] <raschipi> Probably want to use the for and while concurrent equivalents: https://docs.perl6.org/language/concurrency#index-entry-whenever-whenever

[01:17] <raschipi> I gotta go, back in few minutes.

[01:24] *** mcmillhj joined
[01:27] *** subroot left
[01:29] *** mcmillhj left
[01:43] *** mcmillhj joined
[01:45] <raschipi> I'M BACK!

[01:46] *** MasterDuke joined
[01:46] <raschipi> turdmonkey: any progress?

[01:47] <turdmonkey> Yes. I am reading up on and experimenting more with Perl's parallel and concurrent features before I try it in my own code

[01:47] *** mcmillhj left
[01:47] <raschipi> Did yu get what was wrong with your code earlier?

[01:48] <turdmonkey> poll?

[01:48] <raschipi> Let's go over it to see what would happen...

[01:49] <turdmonkey> ok

[01:50] <raschipi> did you get it to work?

[01:50] <turdmonkey> No, I didn't run it.

[01:53] *** Tideflat joined
[01:54] <raschipi> The return types were wrong too. I changed my mind and I don't think it's woth it going over, you were trying to use fundamentals to do it but you should start at a higher level.

[01:56] <turdmonkey> Yes.

[01:56] <turdmonkey> I realized I didn't really understand what I Was doing so now I am reading the docs and really trying to better understand how Perl does it

[01:57] <raschipi> It's like a new paradigm.

[02:01] *** kurahaupo_ joined
[02:03] *** joya left
[02:14] *** mcmillhj joined
[02:18] *** mcmillhj left
[02:33] *** mcmillhj joined
[02:38] *** mcmillhj left
[02:58] *** mcmillhj joined
[03:03] *** mcmillhj left
[03:09] *** titsuki_ joined
[03:13] *** BenGoldberg left
[03:19] *** raschipi left
[03:32] *** mcmillhj joined
[03:37] *** mcmillhj left
[03:51] *** mcmillhj joined
[03:55] *** mcmillhj left
[04:01] *** Tison joined
[04:01] <Tison> \o

[04:12] <lookatme> o/

[04:21] *** mcmillhj joined
[04:26] *** mcmillhj left
[04:36] *** kurahaupo joined
[04:38] *** turdmonkey joined
[04:39] *** kurahaupo_ left
[04:41] <turdmonkey> p6 say "lorfma"

[04:42] <turdmonkey> ;o

[04:42] <turdmonkey> p6: say "lorfma";

[04:42] <camelia> rakudo-moar e9351cbaa: OUTPUT: «lorfma␤»

[04:42] <turdmonkey> i win

[04:42] *** sno left
[04:48] *** turdmonkey left
[04:49] *** turdmonkey joined
[04:53] *** mcmillhj joined
[04:54] *** skids left
[04:58] *** curan joined
[04:58] *** mcmillhj left
[05:00] <turdmonkey> This sub runs concurrently, yes?

[05:00] <turdmonkey> sub print-urls($seed, $file?) {

[05:00] <turdmonkey> 21     await do for get-urls($seed) -> $e {

[05:00] <turdmonkey> 22         start {

[05:01] <turdmonkey> 23             say $e<href>;

[05:01] <turdmonkey> 24             if $file {

[05:01] <turdmonkey> 25                 my $fh = open "$file", :a;

[05:01] <turdmonkey> 26                 $fh.say("$e<href>", ':', $e.text);

[05:01] <turdmonkey> 27                 $fh.close;

[05:01] <turdmonkey> 28             }

[05:01] <turdmonkey> 29         }

[05:01] <turdmonkey> 30     }

[05:01] <turdmonkey> 31 }Y

[05:01] <turdmonkey> er

[05:01] <turdmonkey> it's "multi-threaded"

[05:02] *** jmerelo joined
[05:02] <turdmonkey> hi jmerelo 

[05:05] *** mcmillhj joined
[05:06] <jmerelo> turdmonkey: hi!

[05:06] <yoleaux> 25 Jun 2018 19:14Z <El_Che> jmerelo: if spain keep playing like that I will be force to cheer the other team :)

[05:06] <turdmonkey> are you familiar with concurrent programming with perl?

[05:06] <jmerelo> .tell El_Che you're very welcome to do that. Terrible playing... 

[05:06] <yoleaux> jmerelo: I'll pass your message to El_Che.

[05:09] <jmerelo> turdmonkey: I've used it a bit, yes.

[05:09] <turdmonkey> Would you tell me if my sub runs concurrently or not?

[05:10] <jmerelo> turdmonkey: if you use start, they should... 

[05:10] *** mcmillhj left
[05:10] <turdmonkey> yes

[05:10] <turdmonkey> sub print-urls($seed, $file?) {

[05:10] <turdmonkey> 21     await do for get-urls($seed) -> $e {

[05:10] <turdmonkey> 22         start {

[05:10] <turdmonkey> 23             say $e<href>;

[05:10] <turdmonkey> 24             if $file {

[05:10] <turdmonkey> 25                 my $fh = open "$file", :a;

[05:10] <turdmonkey> 26                 $fh.say("$e<href>", ':', $e.text);

[05:10] <turdmonkey> 27                 $fh.close;

[05:10] <turdmonkey> 28             }

[05:10] <turdmonkey> 29         }

[05:10] <turdmonkey> 30     }

[05:10] <turdmonkey> 31 }

[05:11] <jmerelo> turdmonkey: it's better if you link github or a gist. And this uses start, so it should run concurrently. Problem might be access to $file, which might be locked and can't be accessed concurrently

[05:11] *** ufobat_ joined
[05:12] <jmerelo> turdmonkey: why do you need to access concurrently a single file?

[05:12] <turdmonkey> Well, I'm about to modify the function so it crawls the links it gets

[05:13] <turdmonkey> so it will get a link, and spawn a thread, and follow that link onto its page, and get the links on there, etc.

[05:14] <jmerelo> turdmonkey: the best way to use data structures concurrently is to use a channel

[05:15] <jmerelo> turdmonkey: you crawl the web, get the URL, send it to a channel, there's another concurrent routine reading from a channel and it's the only one printing to a file

[05:15] *** wamba joined
[05:16] <jmerelo> you can also use as many threads you want to continuosly generate URLs and send them to a channel, you don't need to spawn them every time. You can do that if you need, but you might end up with lots of threads.

[05:16] <turdmonkey> cool

[05:17] <jmerelo> turdmonkey: channels are explained here https://docs.perl6.org/language/concurrency#Channels I needed additionally a couple of questions in StackOverflow, but it's not really impossible.

[05:17] <jmerelo> If I remember correctly, timotimo is the expert in this. He was really helpful back then.

[05:19] <turdmonkey> Thanks

[05:19] <jmerelo> turdmonkey: sure :-)

[05:24] *** titsuki_ left
[05:24] *** titsuki joined
[05:24] *** turdmonkey left
[05:29] *** sauvin joined
[05:35] *** mcmillhj joined
[05:40] *** mcmillhj left
[05:42] *** xtreak joined
[05:50] *** espadrine joined
[05:53] *** Tison left
[05:54] <Geth> ¦ doc: 249c0878c6 | (JJ Merelo)++ | doc/Language/contexts.pod6

[05:54] <synopsebot> Link: https://doc.perl6.org/language/contexts

[05:54] <Geth> ¦ doc: Expands explanation of string context

[05:54] <Geth> ¦ doc: 

[05:54] <Geth> ¦ doc: Including an explanation of why there could be problem when you mix

[05:54] <Geth> ¦ doc: the string contextualization super-power of `~` with its Buf

[05:54] <Geth> ¦ doc: concatenation super-power. I would say this closes #2124 if everyone

[05:54] <Geth> ¦ doc: is happy with it. I have preferred to document it here, but of course

[05:54] <Geth> ¦ doc: suggestions are welcome.

[05:54] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/249c0878c6

[05:58] *** releasable6 joined
[06:02] *** sno joined
[06:03] *** xinming joined
[06:09] *** xinming left
[06:15] *** espadrine left
[06:22] *** xinming joined
[06:29] *** mcmillhj joined
[06:31] *** |oLa| joined
[06:33] *** bwisti left
[06:33] *** mcmillhj left
[06:33] *** rindolf joined
[06:37] *** HaraldJoerg joined
[06:38] <tyil> according to pod docs, output/input should not have whitespace squeezed, but the output block gets newlines squeezed

[06:40] <tyil> https://b.catgirlsare.sexy/iQ5U.png

[06:41] <tyil> using the input as shows here https://b.catgirlsare.sexy/RBtl.png

[06:42] <jmerelo> tyil: where in Pod docs?

[06:43] <tyil> https://docs.perl6.org/language/pod#I/O_blocks "The =output block is used to specify pre-formatted terminal or file output, which should also be rendered without re-justification or whitespace-squeezing."

[06:43] *** Schepeers joined
[06:44] *** mcmillhj joined
[06:44] <jmerelo> tyil: well, that's a "should". I would have to look at the actual code... Might be it's already squeezed when interpreted, but maybe it's got to do with the rendering.

[06:45] *** jmerelo left
[06:46] <tyil> its squeezed by the time Pod::To::Pager gets it

[06:46] <tyil> meaning I *cant* render it without whitespace squeezing

[06:48] *** mcmillhj left
[06:49] *** psychoslave joined
[06:50] *** benjikun2 joined
[06:54] *** benjikun left
[06:54] *** parv joined
[06:58] *** wamba left
[07:05] *** Tideflat left
[07:10] *** mcmillhj joined
[07:15] *** mcmillhj left
[07:15] *** jmerelo joined
[07:17] *** domidumont joined
[07:20] *** jmerelo left
[07:24] *** domidumont left
[07:24] *** darutoko joined
[07:25] *** domidumont joined
[07:26] *** wamba joined
[07:33] *** kaare_ joined
[07:37] <ecocode> hmmm.. which ORM to choose: DB::ORM::Quicky or KOOS ?

[07:38] <tyil> I havent heard of either of them :(

[07:47] *** jmerelo joined
[07:47] *** dakkar joined
[07:48] *** brrt joined
[07:54] *** mcmillhj joined
[07:58] *** brrt left
[07:59] *** mcmillhj left
[08:06] *** brrt joined
[08:09] <jmerelo> exit

[08:09] <jmerelo> that is, AFK

[08:09] *** jmerelo left
[08:12] *** mcmillhj joined
[08:16] *** kurahaupo left
[08:17] *** mcmillhj left
[08:34] *** xtreak left
[08:36] *** xtreak joined
[08:38] *** xtreak left
[08:38] *** xtreak joined
[08:39] *** pmurias joined
[08:39] *** xtreak left
[08:41] *** vike1 joined
[08:46] *** mcmillhj joined
[08:48] *** lookatme left
[08:50] *** ChoHag joined
[08:50] *** mcmillhj left
[08:57] *** ChoHag left
[08:57] *** psychoslave left
[08:58] *** ChoHag joined
[09:00] *** xtreak joined
[09:02] *** wamba left
[09:07] *** kurahaupo joined
[09:09] *** kurahaupo left
[09:09] *** parv left
[09:16] *** wamba joined
[09:18] *** xtreak left
[09:32] *** mcmillhj joined
[09:34] *** kaare__ joined
[09:34] *** kaare_ left
[09:34] *** kaare__ is now known as kaare_

[09:37] *** mcmillhj left
[09:43] *** brrt left
[09:44] *** zakharyas joined
[09:46] *** mcmillhj joined
[09:51] *** mcmillhj left
[09:57] *** pecastro_ left
[10:08] *** mcmillhj joined
[10:12] *** ExtraCrispy joined
[10:13] *** mcmillhj left
[10:23] *** mcmillhj joined
[10:26] <tbrowder_> tyil: please file an issue on the pod input/output problem if you haven’t already

[10:26] <tyil> tbrowder_: on which repo?

[10:27] <tbrowder_> rakudo

[10:27] <tyil> I'm not sure if its a Perl or a documentation issue

[10:27] <tyil> alright

[10:27] *** mcmillhj left
[10:28] <tbrowder_> well, at least some pod whitespace squeezing is handled in nqp portion of rakudo

[10:33] *** benjikun joined
[10:33] <tyil> tbrowder_: https://github.com/rakudo/rakudo/issues/1968

[10:34] *** benjikun2 left
[10:34] <tbrowder_> thnx

[10:36] *** benjikun2 joined
[10:38] *** benjikun left
[10:47] *** brrt joined
[10:56] *** mcmillhj joined
[10:58] *** psychoslave joined
[10:59] *** giraffe joined
[11:00] *** giraffe is now known as Guest34814

[11:02] *** mcmillhj left
[11:06] *** lizmat joined
[11:06] *** dct joined
[11:11] *** mcmillhj joined
[11:12] * lizmat waves from Echt

[11:12] <yoleaux> 08:18Z <brrt> lizmat: most of the expr JIT templates came from samcv++

[11:16] *** mcmillhj left
[11:16] <El_Che> hey lizmat 

[11:16] <yoleaux> 05:06Z <jmerelo> El_Che: you're very welcome to do that. Terrible playing...

[11:17] <lizmat> El_Che  o/

[11:17] *** MasterDuke left
[11:24] <tyil> lizmat: how's it be to be back in civilization

[11:24] <tyil> how's it feel*

[11:28] <lizmat> mainly too tired from not really having slept last night

[11:28] <ecocode> ehlo lizmat 

[11:29] <lizmat> ecocode o/

[11:29] <ecocode> how is Wendy ?

[11:29] <lizmat> also really tired, unpacking stuff now

[11:30] *** dakkar left
[11:30] <ecocode> :) what did you bring back from USA ?

[11:30] *** dakkar joined
[11:33] <lizmat> ecocode: not a lot

[11:35] <ecocode> any new books ?

[11:35] <tyil> good memories? :D

[11:36] <timotimo> any good booze? ;)

[11:37] <jkramer> A Harley Davidson? :)

[11:37] <tyil> all of the above :o

[11:40] <lizmat> hehe.. we were just about overweight

[11:40] <lizmat> but mostly because of Wendy swapping Perl books for comic books

[11:40] <lizmat> ah, and a little pile of other books and CD's  :-)

[11:40] *** sena_kun joined
[11:40] *** wamba left
[11:42] *** cosimo joined
[11:42] *** gabiruh joined
[11:49] *** mcmillhj joined
[11:49] <tyil> [Coke]: ping~

[11:52] *** raschipi joined
[11:58] *** mcmillhj left
[12:02] *** mahafyi joined
[12:02] *** raschipi left
[12:07] <BinGOs> p/win 50

[12:10] <mahafyi> hello, I am trying to get a substring from XYZ00012345 ,  need to get 12345. Need to strip everything except the last digits until the left most char is 0. Basically, chop out everything including the zeroes.

[12:11] <mahafyi> ok never mind, i think i will try using replace with a regext that rids all alpha..

[12:12] <tyil> / "0" (\d+) $/ ?

[12:17] <masak> m: say "XYZ00012345" ~~ / <?before 0> <[1..9]> \d+ /

[12:17] <camelia> rakudo-moar e9351cbaa: OUTPUT: «Nil␤»

[12:17] <masak> m: say "XYZ00012345" ~~ / <?after 0> <[1..9]> \d+ /

[12:17] <camelia> rakudo-moar e9351cbaa: OUTPUT: «｢12345｣␤»

[12:17] <masak> mahafyi: ^^

[12:18] <masak> given your problem description, it's hard to know if this was *exactly* what you wanted. but hopefully it can give some ideas.

[12:18] <masak> m: say "XYZ00012345".comb(/ <[1..9]>+ /) # also works

[12:18] <camelia> rakudo-moar e9351cbaa: OUTPUT: «(12345)␤»

[12:19] <mahafyi> masak : thanks. 

[12:19] <masak> the first solution above will give back one Match object with digits. the second gives back a list with all matching substrings

[12:19] <masak> m: say "XYZ00012345".comb(/ <[1..9]> \d+ /) # variant, would also match "12305"

[12:19] <camelia> rakudo-moar e9351cbaa: OUTPUT: «(12345)␤»

[12:23] *** imcsk8 joined
[12:27] *** Ven` joined
[12:47] <jkramer> m: say +('XYZ00012345' ~~ /\d+$/)

[12:47] <camelia> rakudo-moar e9351cbaa: OUTPUT: «12345␤»

[12:48] <jkramer> (Assuming you want to extract it as integer anyway)

[12:55] *** mcmillhj joined
[12:57] *** dct left
[12:58] *** kaare_ left
[13:05] *** ChoHag left
[13:07] *** ChoHag joined
[13:11] *** lizmat left
[13:11] *** Khisanth left
[13:13] *** curan left
[13:25] *** Khisanth joined
[13:36] *** AlexDaniel joined
[13:44] *** kaare_ joined
[13:46] *** molaf joined
[13:46] *** mrdside joined
[13:46] <mrdside> how parse big XML file with unicode symbols?

[13:47] <mrdside> xpath

[13:48] *** Ven` left
[13:48] *** Ven` joined
[13:49] <ufobat_> there is XML::XPath

[13:51] *** brrt left
[13:51] *** markoong joined
[13:53] <mrdside> when try 'my $fh = open "data.xml", enc => "utf-8"; my $xpath = XML::XPath.new(xml => $fh.slurp-rest);' terminal hang

[13:54] <mrdside> `$fh.slurp-rest`output "/╨Ч╨╜╨░╤З╨╡╨╜╨╕╨╡><"

[14:02] *** zakharyas left
[14:03] *** zakharyas joined
[14:04] *** Zoffix joined
[14:05] <Zoffix> mrdside: is that all that's in that file? You said it's big, but that's not very big.

[14:05] <Zoffix> mrdside: also, you're writing too much to read from files. You can just do `"data.xml".IO.slurp`

[14:06] <Zoffix> mrdside: or, XML::XPath.new(xml => slurp 'data.xml')

[14:06] <Zoffix> mrdside: or, XML::XPath.new(file => 'data.xml')

[14:07] *** zakharyas left
[14:07] <mrdside> 137 Mbytes

[14:07] <Zoffix> oh

[14:07] *** HaraldJo` joined
[14:08] <Zoffix> mrdside: that module uses grammars and they haven't seen much optimization since our first release 2 years ago. I suspect it doesn't actually hang, but just taking ages to parse it.

[14:08] *** HaraldJoerg left
[14:09] <tyil> anyone using comma know how much ram I should let java have to make it possible for it to load the rakudo repo ;~;

[14:09] <Zoffix> mrdside: do you have Inline::Perl5 installed? You could see how well `perl6 -e 'use XML::XPath:from<Perl5>; XML::XPath.new: :filename<data.xml>'` performs

[14:09] <Zoffix> eco: Inline::Perl5

[14:09] <buggable> Zoffix, Inline::Perl5 'Use Perl 5 code in a Perl 6 program': https://github.com/niner/Inline-Perl5 1 other matching results: https://modules.perl6.org/s/Inline%3A%3APerl5

[14:10] <Zoffix> tyil: it loaded fine with whatever defaults Ubuntu and Windows have.

[14:10] <tyil> hmm

[14:10] <tyil> mine has failed loading with an error I should increase the Xmx value in comma64.vmoptions

[14:11] <tyil> are you using openjdk or a different java?

[14:11] <Zoffix> don't remember (and don't have access to that box ATM)

[14:11] <Zoffix> You could experiment with some values. I believe setting `export JAVA_OPTS="-Xmx51200000000"` will also work

[14:12] <Zoffix> (that's the value for rakudo jvm build; maybe I have it set in some config or something)

[14:12] <Zoffix> m: say 51200000000.polymod: 1024

[14:12] <camelia> rakudo-moar e9351cbaa: OUTPUT: «(0 50000000)␤»

[14:12] <AlexDaniel> mrdside: that's a very good question!

[14:12] <Zoffix> m: say 51200000000.polymod: 1024 xx *

[14:12] <camelia> rakudo-moar e9351cbaa: OUTPUT: «(0 128 700 47)␤»

[14:13] <AlexDaniel> mrdside: so we need something sax-like that doesn't manipulate the whole thing in memory

[14:14] <Zoffix> DOM::Tiny is also slow as ass with largish HTML files

[14:14] <AlexDaniel> well, in that case you can use Gumbo instead and that's much faster

[14:15] <AlexDaniel> also potentially more correct

[14:15] <Zoffix> Mojo::DOM works fast :)

[14:15] <Zoffix> in P5

[14:19] <Zoffix> BTW, with all the comments about whether p6 is faster than p5, I think we should start taking our measurements on Windows... This mojo web app I'm working on right now starts in ~1s on Linux and like 25s on Windows

[14:19] <timotimo> oh? wow

[14:19] <El_Che> wow

[14:20] <AlexDaniel> mrdside: alright, so what XML::XPath does, as far as I can see

[14:20] <AlexDaniel> mrdside: is that it calls from-xml-file from XML module

[14:20] <Zoffix> granted, it might be some bug with longer wait times for socket timeouts or something along those lines, but the difference is there :/

[14:20] <jnthn> Much of the early MoarVM optimization work was done on MSVC, so there was a time when Windows was the best place to benchmark. :)

[14:20] <AlexDaniel> mrdside: and XML is a basic dom parser as far as I can see

[14:20] <Zoffix> :)

[14:20] <jnthn> That's probably no longer true.

[14:21] <AlexDaniel> mrdside: which is obviously not the right approach for >100M files

[14:21] <mrdside> PS > Select-Xml -XPath "..." -Path "..." works well

[14:22] <AlexDaniel> what's that?

[14:22] <mrdside> PowerShell

[14:23] *** Ven` left
[14:24] <AlexDaniel> mrdside: so at this point, if I needed to do this, I'd probably use some C library through NativeCall, or Perl5 or Python module through Inline::Perl5 or Inline::Python

[14:24] *** skids joined
[14:24] <AlexDaniel> mrdside: this way you'd have very fast and efficient retrieval of needed data + you'd be able to work with unicode strings on Perl 6 level

[14:25] <AlexDaniel> but yes, I wish there was a module that'd do that for you, similar to Gumbo

[14:27] *** Zoffix left
[14:29] *** wamba joined
[14:30] <mrdside> i had try xmllint. but with '--shell' outputs '$#x41A;' in values but with normal xml node names

[14:35] *** mrdside left
[14:36] *** pmurias left
[14:37] *** pmurias joined
[14:43] *** Tison joined
[14:48] *** Tison_ joined
[14:49] *** Tison left
[14:51] *** Tison_ left
[14:53] *** perlpilot left
[14:59] *** xtreak joined
[15:02] *** bwisti joined
[15:06] *** domidumont left
[15:08] *** Tideflat joined
[15:10] *** perlpilot joined
[15:16] *** jmerelo joined
[15:17] *** turdmonkey joined
[15:17] <turdmonkey> Hello.

[15:17] *** uzl joined
[15:18] <jmerelo> hi, turdmonkey 

[15:18] <uzl> hello!

[15:20] *** Tideflat left
[15:20] <jmerelo> o/

[15:23] *** mahafyi left
[15:25] <uzl> m: my $wiring = 'EKMFLGDQVZNTOWYHXUSPAIBRCJ'; my @entry = [$_.ord - 'A'.ord for $wiring.comb];

[15:25] <camelia> rakudo-moar e9351cbaa: ( no output )

[15:26] *** mahafyi joined
[15:27] <AlexDaniel> jmerelo: re “I don't really see it as a trap”, here's the commit in question: https://github.com/perl6/whateverable/commit/04beb801aba61ee10ba0e0630f406419e8b7c278

[15:27] <AlexDaniel> jmerelo: my first attempt was to use [~] @chunks, it worked fine. Then I noticed some failing tests, because it was calling .decode on a Str

[15:27] <AlexDaniel> jmerelo: isn't that pretty much the definition of a trap? You write some code, it looks and works fine, but in reality it doesn't (in some cases)

[15:28] <jmerelo> AlexDaniel: let me rephrase that. The behavior is documented. Only I think it would be better when documenting contexts than as a trap

[15:29] <AlexDaniel> jmerelo: why not both?

[15:29] <jmerelo> AlexDaniel: that's what I have said in the issue. 

[15:29] *** Ven` joined
[15:30] <uzl> m: my $wiring = 'EKMFLGDQVZNTOWYHXUSPAIBRCJ'; my @entry = [$_.ord - 'A'.ord for $wiring.comb]; say @entry;

[15:30] <camelia> rakudo-moar e9351cbaa: OUTPUT: «[4 10 12 5 11 6 3 16 21 25 13 19 14 22 24 7 23 20 18 15 0 8 1 17 2 9]␤»

[15:30] <AlexDaniel> jmerelo: yes please, but with short example inlined on the traps page :)

[15:30] <AlexDaniel> jmerelo: I do agree that traps page should link to more wordy explanations, but the gist (or at least some short examples) should be right there

[15:30] <AlexDaniel> that's what I think, feel free to disagree :)

[15:31] <uzl> Is there any way to start populating the array at index 1 instead?

[15:31] <jmerelo> AlexDaniel: I'm happy, Spain is proceeding to the next phase in the world cup. So I'll try to comply :-)

[15:31] <AlexDaniel> jmerelo: by the way, have you seen https://mywiki.wooledge.org/BashPitfalls ?

[15:31] <jmerelo> uzl: you won't happen to be an undercover R spy, right?

[15:32] <AlexDaniel> jmerelo: that's my inspiration for the traps page :)

[15:32] *** Tideflat joined
[15:32] <uzl> I could do it with a foor loop but I'm wondering if it can be done in the list comprehension fashion?

[15:32] <jmerelo> AlexDaniel: I see. Kinda of "this is wrong, this is why it happens, this would be the right way"

[15:33] <uzl> jmerelo: No. Probably too invested in Perl 6.

[15:33] <jmerelo> uzl: R arrays start in 1 :-)

[15:33] <uzl> jmerelo: i think the same with Lua.

[15:34] <jmerelo> uzl: Anyway, this is not like Python. It's not "list comprehension". You're just putting the result in list context. Let's check this

[15:34] <AlexDaniel> m: my $wiring = ‘EKMFLGDQVZNTOWYHXUSPAIBRCJ’; my @entry = 0, |[$_.ord - ‘A’.ord for $wiring.comb]; say @entry

[15:34] <camelia> rakudo-moar e9351cbaa: OUTPUT: «[0 4 10 12 5 11 6 3 16 21 25 13 19 14 22 24 7 23 20 18 15 0 8 1 17 2 9]␤»

[15:34] <AlexDaniel> uzl: you mean something like this?

[15:34] <jmerelo>  m: my $wiring = 'EKMFLGDQVZNTOWYHXUSPAIBRCJ'; my @entry = $_.ord - 'A'.ord for $wiring.comb ; say @entry;

[15:34] <camelia> rakudo-moar e9351cbaa: OUTPUT: «[9]␤»

[15:35] <uzl> AlexDaniel: That will do.

[15:35] <AlexDaniel> jmerelo: it quacks very much like list comprehensions

[15:35] *** Tideflat left
[15:35] <jmerelo>  m: my $wiring = 'EKMFLGDQVZNTOWYHXUSPAIBRCJ'; say $wiring.comb.map: *.ord - 'A'.ord 

[15:35] <camelia> rakudo-moar e9351cbaa: OUTPUT: «(4 10 12 5 11 6 3 16 21 25 13 19 14 22 24 7 23 20 18 15 0 8 1 17 2 9)␤»

[15:35] <jmerelo>  m: my $wiring = 'EKMFLGDQVZNTOWYHXUSPAIBRCJ'; say 0, $wiring.comb.map: *.ord - 'A'.ord 

[15:35] <camelia> rakudo-moar e9351cbaa: OUTPUT: «0(4 10 12 5 11 6 3 16 21 25 13 19 14 22 24 7 23 20 18 15 0 8 1 17 2 9)␤»

[15:36] <jmerelo>  m: my $wiring = 'EKMFLGDQVZNTOWYHXUSPAIBRCJ'; say  ($wiring.comb.map: *.ord - 'A'.ord).unshift: 'Bookend'

[15:36] <camelia> rakudo-moar e9351cbaa: OUTPUT: «Cannot resolve caller unshift(Seq: Str); none of these signatures match:␤    (Any:U \SELF: |values is raw)␤  in block <unit> at <tmp> line 1␤␤»

[15:36] <uzl> if it quacks like list comprehension, then it's likely that is list comprehension ;)

[15:36] <uzl> probably not true!

[15:37] <AlexDaniel> m: my $wiring = ‘EKMFLGDQVZNTOWYHXUSPAIBRCJ’; my @entry = 0, |do $_.ord - ‘A’.ord for $wiring.comb; say @entry

[15:37] <camelia> rakudo-moar e9351cbaa: OUTPUT: «[0 4 10 12 5 11 6 3 16 21 25 13 19 14 22 24 7 23 20 18 15 0 8 1 17 2 9]␤»

[15:37] <jmerelo> uzl: that's DWIM by any other words. 

[15:37] <jmerelo>  m: my $wiring = 'EKMFLGDQVZNTOWYHXUSPAIBRCJ'; say  'Quak', | $wiring.comb.map: *.ord - 'A'.ord 

[15:37] <camelia> rakudo-moar e9351cbaa: OUTPUT: «Quak410125116316212513191422247232018150811729␤»

[15:38] <jmerelo>  m: my $wiring = 'EKMFLGDQVZNTOWYHXUSPAIBRCJ'; say  ('Quak', | $wiring.comb.map: *.ord - 'A'.ord ).join: '|'

[15:38] <camelia> rakudo-moar e9351cbaa: OUTPUT: «Quak|4|10|12|5|11|6|3|16|21|25|13|19|14|22|24|7|23|20|18|15|0|8|1|17|2|9␤»

[15:38] <AlexDaniel> uzl: maybe consider using Nil instead of 0

[15:39] <jmerelo>  m: my $wiring = 'EKMFLGDQVZNTOWYHXUSPAIBRCJ'; say  (Mu, | $wiring.comb.map: *.ord - 'A'.ord ).join: '|'

[15:39] <camelia> rakudo-moar e9351cbaa: OUTPUT: «Use of uninitialized value of type Mu in string context.␤Methods .^name, .perl, .gist, or .say can be used to stringify it to something meaningful.␤|4|10|12|5|11|6|3|16|21|25|13|19|14|22|24|7|23|20|18|15|0|8|1|17|2|9␤  in block <unit> at <tmp> l…»

[15:39] <jmerelo>  m: my $wiring = 'EKMFLGDQVZNTOWYHXUSPAIBRCJ'; say  (Nil, | $wiring.comb.map: *.ord - 'A'.ord ).join: '|'

[15:39] <camelia> rakudo-moar e9351cbaa: OUTPUT: «Use of Nil in string context␤|4|10|12|5|11|6|3|16|21|25|13|19|14|22|24|7|23|20|18|15|0|8|1|17|2|9␤  in block <unit> at <tmp> line 1␤»

[15:39] <jmerelo>  m: my $wiring = 'EKMFLGDQVZNTOWYHXUSPAIBRCJ'; say  ('', | $wiring.comb.map: *.ord - 'A'.ord ).join: '|'

[15:39] <camelia> rakudo-moar e9351cbaa: OUTPUT: «|4|10|12|5|11|6|3|16|21|25|13|19|14|22|24|7|23|20|18|15|0|8|1|17|2|9␤»

[15:39] <uzl> jmerelo: yesterday I mentioned that my pull request for the Spanish translation for Learn X in Y -- Perl 6 has been pushed to the website.

[15:39] <jmerelo> uzl: great!

[15:40] <uzl> jmerelo: probably you could take a look at it whenever you have time. Or somebody else!

[15:40] <uzl> it could benefit from some revision.

[15:41] <jmerelo> uzl: I'll outsource to family :-) 

[15:41] <uzl> AlexDaniel: That would be more according to what I was trying to do. So Nil makes more sense (in this case)!

[15:42] <uzl> jmerelo: that's great!

[15:42] <jmerelo> uzl: but thanks for taking the work to translate that :-)

[15:42] *** brrt joined
[15:42] *** perlpilot left
[15:43] <uzl> jmerelo: I guess that's my way to give back to the Perl community. So thanks to you all for the great work. 

[15:43] <jmerelo> uzl++

[15:44] <jmerelo> BTW, about to close this straw poll on the future of prescriptions for hashes in the Perl6 doc style guide: https://github.com/perl6/doc/issues/2117#issuecomment-399742781

[15:46] <uzl> Any consensus reached?

[15:47] *** mahafyi left
[15:47] <jmerelo> uzl: no consensus, just a simple majority.

[15:47] *** mahafyi joined
[15:48] <AlexDaniel> jmerelo: I'm surprised with “Have you used Perl 6 in academia?” responses

[15:48] <jmerelo> AlexDaniel: there are too many "yes", right?

[15:48] <AlexDaniel> yes, too many

[15:48] <AlexDaniel> which is great but I'm really surprised

[15:48] <AlexDaniel> jmerelo: I thought we're the odd ones but I guess we're not special at all :P :P

[15:49] <jmerelo> AlexDaniel: it's not you and me answering lots of times, right? moritz is also in academia, or was. 

[15:49] <uzl> jmerelo: Oh, I see!

[15:49] <jmerelo> AlexDaniel: we're the ones in computer architecture. That makes us special. We build the stuff that everyone else needs to run stuff.

[15:49] <uzl> Are the poll results out already?

[15:50] <jmerelo> uzl: they are to a lucky few.. who are in academia :-)

[15:50] <jmerelo> uzl: you can probably request access, I don't think benjikun will have a problem with that.

[15:51] <uzl> jmerelo: Oh, well! What a priviliged group! ;)

[15:51] *** psychoslave left
[15:51] <uzl> uzl: That's fine! I'll see it when it comes out!

[15:52] <jmerelo> AlexDaniel: actually, the responses are not so surprising. I would like to see whoever used it in a course, unless it was one of my students. And some people chose to use it by themselves, which should be expected...

[15:52] <jmerelo> AlexDaniel: 10 for research, that's great to hear :-)

[15:54] <sena_kun> oh, are survey results already can be seen?

[15:55] <jmerelo> sena_kun: let me see if I can publish the responses only

[15:55] <sena_kun> also, is there a way to know if a role is from CORE.setting or not?

[15:56] <sena_kun> jmerelo, thanks, that'd be interesting to see. :)

[15:56] <jmerelo> sena_kun: um. Not sure what you mean... (the roles)

[15:56] *** uzl left
[15:57] <sena_kun> m: class A does Positional {}; role Foo {}; class B does Foo {};

[15:57] <camelia> rakudo-moar e9351cbaa: ( no output )

[15:57] * AlexDaniel clickbaits https://docs.google.com/forms/d/e/1FAIpQLSdqrrcxTQWuN1ISAvz3j_XkpCCc2AuQw9uKgAhTivxHBFsweg/viewform

[15:57] *** mahafyi left
[15:58] <sena_kun> So Positional is from CORE, while Foo is just your user-defined role.

[15:58] <sena_kun> Was wondering if there is a way to check if role Foo user-defined or not. It is not really necessary, just can make some things easier. :)

[15:58] *** xtreak left
[15:59] <jmerelo> sena_kun: here are the responses: https://docs.google.com/forms/d/19qSBpGWWc9RNruxPWySHkmy3tppaqeqUNGfZpHhdsMs/viewanalytics

[15:59] <sena_kun> jmerelo, thanks!

[16:00] <jmerelo> sena_kun: Other than looking at the source, I don't see a way, easy or otherwise, to do that. All classes and roles use the same protocol...

[16:00] <jnthn> m: say Positional.^candidates[0].^body_block.file

[16:00] <camelia> rakudo-moar e9351cbaa: OUTPUT: «SETTING::src/core/Positional.pm6␤»

[16:00] <jnthn> sena_kun: ^^

[16:00] <sena_kun> jnthn, isn't it a bit fragile to depend on? Hmm.

[16:01] <jmerelo> jnthn: I really had no idea of that. Thanks! So it's a matter of smartmatching to core, right?

[16:01] <sena_kun> jnthn, anyway, will consider this option too, thanks.

[16:01] <jnthn> Well, the SETTING:: at the start may be better to match on and that bit may be a little fragile I guess

[16:02] <jnthn> The introspection bit...well, that bit of the MOP has been factored that way for probably close to a decade. :)

[16:02] <Juerd> Where is 'for' implemented? I'm curious :)

[16:05] <jnthn> Juerd: In multiple places, for performance reasons. At statement list level, it's compiled into a .iterator method call and a loop with a .pull-one method call and block invocation in it for some cases (like the single arg case). That's done in Actions.nqp. In Optimizer.nqp a loop like `for 1..5000 { }` is rewritten into a `loop (...) { }` style construct instead. For all other case, it's just .map + an

[16:05] <jnthn> appropriate contextualizer.

[16:05] <Juerd> Thanks!

[16:05] *** MilkmanDan joined
[16:05] *** mahafyi joined
[16:06] <Juerd> Also, that's incredibly interesting :)

[16:10] *** mcmillhj left
[16:13] *** sena_kun left
[16:13] *** sena_kun joined
[16:15] *** Zoffix joined
[16:15] <Zoffix> m: role Foo {}; class A does Positional does Foo {}; say "{.^name} is{" not" unless CORE::{.^name} === $_} from core" for A.^roles

[16:15] <camelia> rakudo-moar e9351cbaa: OUTPUT: «Foo is not from core␤Positional is from core␤»

[16:15] <Zoffix> sena_kun: ^ maybe that does the trick?

[16:16] <Zoffix> m: say CORE::<Positional> =:= $_ for class :: does Positional {}.^roles

[16:16] <camelia> rakudo-moar e9351cbaa: OUTPUT: «False␤»

[16:17] <Zoffix> m: say CORE::<Positional> =:= $_ for class :: does Positional {}.^roles.<>

[16:17] <camelia> rakudo-moar e9351cbaa: OUTPUT: «False␤»

[16:17] <Zoffix> m: say CORE::<Positional> =:= $_ for class :: does Positional {}.^roles».<>

[16:17] <camelia> rakudo-moar e9351cbaa: OUTPUT: «False␤»

[16:17] <Zoffix> Wonder why that's false

[16:17] <sena_kun> Zoffix, this is another option indeed. And it seems a bit less fragile to me than filename matching. Thanks.

[16:18] <timotimo> Zoffix: probably role group vs role instance?

[16:18] <timotimo> Zoffix: because positional's got a parameter?

[16:19] <Zoffix> timotimo: wouldn't the difference between === and =:= be just the different containers?

[16:19] <Zoffix> m: say CORE::<Positional> === $_ for class :: does Positional {}.^roles

[16:19] <camelia> rakudo-moar e9351cbaa: OUTPUT: «True␤»

[16:19] *** mcmillhj joined
[16:19] <Zoffix> Cause it's true with ===, only with =:= it's false and AFAIS they ain't in any containers

[16:19] <timotimo> don't know how === is implemented for this, tbh

[16:20] <Zoffix> s: &infix:<===>, \(CORE::<Positional>, class :: does Positional {}.^roles.head)

[16:20] <SourceBaby> Zoffix, Sauce is at https://github.com/rakudo/rakudo/blob/e9351cbaa/src/core/Any.pm6#L490

[16:20] *** Ven` left
[16:20] <timotimo> so it compares the WHICHes

[16:20] <Zoffix> ah, k, yeah

[16:20] <Zoffix> Alright, makes sense.

[16:20] <timotimo> m: Positional.WHICH.say; Positional[Any].WHICH.say

[16:20] <camelia> rakudo-moar e9351cbaa: OUTPUT: «Positional|U48023568␤Positional[Any]|U57988064␤»

[16:21] <timotimo> m: say CORE::<Positional>.WHICH; say (class :: does Positional {}.^roles)[0].WHICH

[16:21] <camelia> rakudo-moar e9351cbaa: OUTPUT: «Positional|U48583584␤Positional|U48583584␤»

[16:21] <timotimo> oh, huh?

[16:21] <Zoffix> Default is mu

[16:21] <timotimo> well, it seems to pun it anyway i guess?

[16:21] <Zoffix> m: Positional.WHICH.say; Positional[Mu].WHICH.say

[16:21] <camelia> rakudo-moar e9351cbaa: OUTPUT: «Positional|U29801408␤Positional[Mu]|U39763568␤»

[16:21] <Zoffix> hm

[16:21] * Zoffix shrugs

[16:22] <timotimo> it might pun the object to use it in ===

[16:24] *** brrt left
[16:24] *** mcmillhj left
[16:24] *** st_elmo joined
[16:27] *** lizmat joined
[16:30] *** Zoffix left
[16:31] *** telex joined
[16:34] *** dakkar left
[16:35] *** kalkin- joined
[16:35] <kalkin-> hi

[16:35] *** xinming left
[16:36] <kalkin-> so I see that some people started using in source-url: http://www.cpan.org/*.tar.gz, which just contains source files, but no .git information

[16:37] <kalkin-> this sucks, because now ddt hack Pod::To::Pager checkout the module code via git, so I can start hacking

[16:37] <kalkin-> What is the blessed way to communicate the VCS repository location for your module?

[16:40] <Geth> ¦ ecosystem: pheix++ created pull request #401: Add Net::Ethereum to ecosystem

[16:40] <Geth> ¦ ecosystem: review: https://github.com/perl6/ecosystem/pull/401

[16:41] *** mcmillhj joined
[16:41] *** mcmillhj left
[16:42] <Geth> ¦ ecosystem: e9d59bf4b1 | (Konstantin Narkhov)++ | META.list

[16:42] <Geth> ¦ ecosystem: Add Net::Ethereum to ecosystem

[16:42] <Geth> ¦ ecosystem: 

[16:42] <Geth> ¦ ecosystem: See https://gitlab.com/pheix/net-ethereum-perl6

[16:42] <Geth> ¦ ecosystem: review: https://github.com/perl6/ecosystem/commit/e9d59bf4b1

[16:42] <Geth> ¦ ecosystem: f49f7c5127 | (Juan Julián Merelo Guervós)++ (committed using GitHub Web editor) | META.list

[16:42] <Geth> ¦ ecosystem: Merge pull request #401 from pheix/master

[16:42] <Geth> ¦ ecosystem: 

[16:42] <Geth> ¦ ecosystem: Add Net::Ethereum to ecosystem

[16:42] <Geth> ¦ ecosystem: review: https://github.com/perl6/ecosystem/commit/f49f7c5127

[16:42] <AlexDaniel> kalkin-: I'm pretty sure that the source-url should be pointing to the git repo

[16:42] <AlexDaniel> but I could be wrong

[16:44] <kalkin-> Well S26 doesn't say anything about source-url

[16:44] <Geth> ¦ doc: 9c7b4ead97 | (JJ Merelo)++ | doc/Language/regexes.pod6

[16:44] <synopsebot> Link: https://doc.perl6.org/language/regexes

[16:44] <Geth> ¦ doc: Space added closes #2125. Thanks @devine for the detailed bug report

[16:44] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/9c7b4ead97

[16:45] *** sno left
[16:47] <kalkin-> Hmm now rereading my second message, I will explain it a little bit more for everyone. 

[16:48] <kalkin-> I have a tool(ddt) which checkouts the modules git repository via ”source-url” in META6.json (via zef). This is broken because some module have a cpan tar.gz file linked in source-url. The tar.gz file doesn't contain any git repo information.

[16:48] <kalkin-> The question is, what is expected in source-url? If this is defined, may be cpan/modules infrastructure could be patched to assert the right kind of value in source-url

[16:54] <turdmonkey> Does anyone else love kebab case as much as I? It makes typing functions quicker than underscore_case and more readable than crapCase

[16:55] <geekosaur> many people do, that's why perl 6 has it

[16:55] <geekosaur> and a small handful of other languages

[16:56] *** mcmillhj joined
[16:59] *** mahafyi left
[17:01] <kalkin-> kebab is great

[17:03] <[Coke]> tyil: yes, I saw your email.

[17:05] *** natrys joined
[17:05] <AlexDaniel> turdmonkey: yes ♥

[17:08] <turdmonkey> <3

[17:10] <turdmonkey> I'm working on the concurrent portion of my web crawler now, which is, realy, the main feature that I want to show off.

[17:10] *** aindilis joined
[17:10] <turdmonkey> Concurrent...rather...asynchronous? Because it may takes some links longer than others.

[17:12] <Geth> ¦ doc: 4f18e4e87b | (JJ Merelo)++ | doc/Language/traps.pod6

[17:12] <synopsebot> Link: https://doc.perl6.org/language/traps

[17:12] <Geth> ¦ doc: Adds also to trap section, *really* closes #2124

[17:12] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/4f18e4e87b

[17:15] <Geth> ¦ doc: e232c3883a | (JJ Merelo)++ | writing-docs/STYLEGUIDE.md

[17:15] <Geth> ¦ doc: Prescription for a particular form of declaring hashes eliminated

[17:15] <Geth> ¦ doc: 

[17:15] <Geth> ¦ doc: The tally was 6 votes for this option, 3 for not touching it, 4 for

[17:15] <Geth> ¦ doc: changing to {} (from %()). So, eliminated and closes #2117.

[17:15] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/e232c3883a

[17:15] *** turdmonkey left
[17:18] <Geth> ¦ doc: AlexDaniel self-assigned Potential trap with concatenating Bufs/Blobs, [~] returns a Str https://github.com/perl6/doc/issues/2124

[17:20] *** n1ge left
[17:23] <jmerelo> Have you seen this? https://twitter.com/JoinAppleSearch/status/1011474941416370176 is it legit? Or a bot?

[17:28] <AlexDaniel> if it's a bot, I like that bot

[17:29] <jmerelo> AlexDaniel: because it's mentioning perl 6, but I'm not sure it's taking it from somewhere else. It's probably triggered by some Apple thing.

[17:29] <jmerelo> Let me check.

[17:30] <jmerelo> Come to think of it, it's probably both things. That tweet is legit, but it's telling us how the bot works? I mean, has anyone heard of the DOHP stack? With Perl 6?

[17:36] *** zakharyas joined
[17:37] *** uzl joined
[17:38] *** Zoffix joined
[17:39] <uzl> Can somebody look into this and tell me where are the two implicit nested loops? (https://github.com/LaurentRosenfeld/thinkperl6/blob/f4e790f4d45c3c7e5a0444656e2d2ac985376e43/book/wordplay.tex#L516-L527)

[17:39] <uzl> I am struggling to find them!

[17:40] <Zoffix> kalkin-: that source-url is correct. The source lives on CPAN and it doesn't need to have any repo associated with it. If you download the tar itself, it should have the original META file that likely has the original source-url that's likely a git repo

[17:40] <jmerelo> uzl: index is a loop. It checks one by one

[17:41] <Zoffix> kalkin-: the other possibility is to use modules.perl6.org's API; the value should be in `repo-url` key for the dist. But note that the site currently needs distro name, it doesn't work if you specify a name of some module contained in the dist

[17:41] <geekosaur> uzl, one is explicit (the for), the other implicit (indexing through the other item). see the other varianbt at lines 499--505

[17:42] <Zoffix> kalkin-: though looks like some authors don't specify anything at all for the repo URL: https://modules.perl6.org/dist/Pod::To::Pager:cpan:TYIL/META6.json

[17:43] *** turdmonkey joined
[17:44] <Zoffix> I see only one loop in there :/

[17:44] <uzl> jmerelo, geekosaur: That totally over my head! I never thought of index in that way.

[17:44] <uzl> Thans for the clarification!

[17:44] <Zoffix> Why is index a loop? It's a routine call. How it is implemented is a secret.

[17:45] *** sno joined
[17:45] <jmerelo> uzl: sure :-)

[17:45] <uzl> Zoffix: So it shouldn't be thought as one?

[17:45] <geekosaur> Zoffix, but thinking of it that way obscures that you can make the other implementation

[17:46] * geekosaur looking at it with haskell eyes

[17:46] <jmerelo> Zoffix: it's got to check the argument against the string. Unless you've done some clever indexing of the string, it's going to be a loop. I doubt it's done otherwise for plain strings.

[17:46] * Zoffix is looking at it with practical eyes

[17:46] *** mcmillhj left
[17:46] <geekosaur> not very, if you can't see the other possibility

[17:47] <geekosaur> "practical" can mean "only see brute force solutions"

[17:48] <Zoffix> No, practical is I know only that I need to know: index "finds a string in another string". I don't need to know the details of how it's implemented to find the two methods to implement that routine. It's irrelevant how `index` is implemented for that purpose. In fact, you're merely assuming it's implemented as a loop and you claim that assumption gave you some special magic knowledge that made you see both

[17:48] <Zoffix> solutions, when you really just used the same method as I and saw the symmetry of looking for a thing in another thing.

[17:49] <jmerelo> Zoffix: but you know there's an implicit loop, that's implicit in the question. Any other candidate there?

[17:49] <Zoffix> jmerelo: I know nothing.

[17:50] <Zoffix> The definition of index routine is not present.

[17:50] <Zoffix> And the question is wrong.

[17:50] <jmerelo> Zoffix: Well, it says so in line 516: https://github.com/LaurentRosenfeld/thinkperl6/blob/f4e790f4d45c3c7e5a0444656e2d2ac985376e43/book/wordplay.tex#L516-L527

[17:51] <Zoffix> jmerelo: that doesn't make it correct.

[17:51] <Zoffix> Maybe you guys should assume there's an implicit loop around the book, so you could see it both ways, eh :P

[17:51] <jmerelo> Zoffix: that's rich :-)

[17:52] <jmerelo> Zoffix: but you don't have to look at the general truthiness or not of the book, just at the implicit assumptions of the text and the code. If we assume there's an implicit loop, that must be the one

[17:52] *** mcmillhj joined
[17:53] *** mcmillhj left
[17:53] <uzl> Zoffix: Do you think it could be expressed more clearly? As far I know, the book hasn't made any mention of the index routine being a loop.

[17:53] <jmerelo> Zoffix: in fact, it's the reverse of the code above in line 499, which uses index for the outer "for" loop. So that's it.

[17:54] <jmerelo> uzl: I don't know what's the point of identifying the number of loops there... But I guess the intention of the text is exactly that.

[17:54] *** MilkmanDan left
[17:55] *** MilkmanDan joined
[17:55] <Zoffix> uzl: yup: $forbidden.contains: none $word.comb

[17:56] *** zakharyas left
[17:57] <uzl> Zoffix: I meant the statement about the implicit loops.

[17:58] <uzl> I am probably ruminating too much on it. I guess it's just what jmerelo said.

[17:58] <Zoffix> uzl: dunno, I'd need to know why that paragraph is talking about loops to give a reasonable answer.

[18:00] <uzl> Zoffix: you're totally right about that!

[18:03] <Zoffix> Kinda bummed that example is so verbose. The `for 0..$forbidden.chars - 1 -> $idx` part can just be `for ^$forbidden.chars -> $idx`, the `for ^$forbidden.chars -> $idx { my $letter = substr $forbidden, $idx, 1;` could be just `for $forbidden.comb -> $letter {`, the `for $forbidden.chars -> $letter { return False if defined index $word, $letter;` could be just `for $forbidden.comb -> $letter { return False if

[18:03] <Zoffix> $word.contains: $letter;` which itself could just be `$forbidden.contains: none $word.comb`

[18:03] <Zoffix> Some of them use more advanced features, I can accept that, but surely `$word.contains: $letter` is simpler and more understandable than `defined index $word, $letter`

[18:08] *** mcmillhj joined
[18:08] *** dct joined
[18:09] <Zoffix> kalkin-: FWIW, http://modules.perl6.org/repo/$^module  redirects to the repo

[18:09] <Zoffix> Can't use `git clone http://modules.perl6.org/repo/$^module` tho, sadly

[18:10] *** tailgate joined
[18:12] *** tailgate left
[18:12] *** tailgate joined
[18:15] *** melezhik joined
[18:15] <Zoffix> kalkin-: and this is the "api" way (the API is poorly defined, mostly just a JSON view of some pages):    perl6 -MWWW -MURI::Escape -e 'sub MAIN { "http://modules.perl6.org/s/&uri-escape($^module)/.json".&jget<dists>.head<repo_url> andthen "Clonning $_".say && «git clone -- "$_"».&run orelse say "Not found" }' JSON::Tiny

[18:15] *** Zoffix left
[18:15] <melezhik> Hi! How to prove that array include some element ?

[18:16] <El_Che> m: [1,3,3].grep: 10

[18:16] <camelia> rakudo-moar e9351cbaa: ( no output )

[18:16] <El_Che> m: [1,3,3].grep: 3

[18:16] <camelia> rakudo-moar e9351cbaa: ( no output )

[18:17] <El_Che> m: say so [1,3,3].grep: 3

[18:17] <camelia> rakudo-moar e9351cbaa: OUTPUT: «True␤»

[18:17] <AlexDaniel> m: [1,3,3].contains: 3

[18:17] <camelia> rakudo-moar e9351cbaa: ( no output )

[18:17] <timotimo> but is that proof?

[18:17] <AlexDaniel> m: say [1,3,3].contains: 3

[18:17] <camelia> rakudo-moar e9351cbaa: OUTPUT: «True␤»

[18:18] <melezhik> Thanks, :AlexDaniel

[18:18] *** espadrine joined
[18:20] *** dct left
[18:20] <El_Che> .index can be handy as well, if you need that (nil if not present)

[18:21] <Geth> ¦ doc: 573cbf408a | (JJ Merelo)++ | doc/Language/regexes.pod6

[18:21] <synopsebot> Link: https://doc.perl6.org/language/regexes

[18:21] <Geth> ¦ doc: More consistent, closes #2126

[18:21] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/573cbf408a

[18:23] *** jmerelo left
[18:23] *** sauvin left
[18:25] *** robertle joined
[18:25] *** dct joined
[18:28] <Geth> ¦ doc: 376ca54578 | (Zoffix Znet)++ (committed using GitHub Web editor) | doc/Type/IO.pod6

[18:28] <synopsebot> Link: https://doc.perl6.org/type/IO

[18:28] <Geth> ¦ doc: Remove merge conflict markers

[18:28] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/376ca54578

[18:29] *** Zoffix joined
[18:29] <Zoffix> m: say [1,33].contains: 3

[18:29] <camelia> rakudo-moar e9351cbaa: OUTPUT: «True␤»

[18:29] <Zoffix> m: say [1,33].index: 3

[18:29] <camelia> rakudo-moar e9351cbaa: OUTPUT: «2␤»

[18:30] <AlexDaniel> wait uh

[18:30] <Zoffix> melezhik: depends on what how you define "contains" (object identity, string equivalence, numerical equivalence?) and what possible elements it might contains (will Nil ever be a possible value, are all values defined?)

[18:31] <AlexDaniel> melezhik: yeah don't listen to me, it was a brainfart…

[18:31] <Zoffix> s: [1, 2, 3].grep.iterator, 'bool-only', \()

[18:31] <SourceBaby> Zoffix, Something's wrong: ␤ERR: Cannot resolve caller grep(Array: ); none of these signatures match:␤    ($: Bool:D $t, *%_)␤    ($: Mu $t, *%_)␤  in block <unit> at -e line 6␤␤

[18:31] <Zoffix> s: [1, 2, 3].grep(3).iterator, 'bool-only', \()

[18:31] <AlexDaniel> melezhik: .contains is for strings, so most likely not what you're looking for if you have arrays

[18:31] <SourceBaby> Zoffix, Something's wrong: ␤ERR: Could not find candidate that can do \()␤  in sub sourcery at /home/zoffix/services/lib/CoreHackers-Sourcery/lib/CoreHackers/Sourcery.pm6 (CoreHackers::Sourcery) line 32␤  in block <unit> at -e line 6␤␤

[18:31] <Zoffix> boo

[18:32] <AlexDaniel> m: say so [1, 2, 3].any == 2

[18:32] <camelia> rakudo-moar e9351cbaa: OUTPUT: «True␤»

[18:33] <AlexDaniel> a few minutes ago I was thinking about something and hit my head against a wall real hard

[18:33] <AlexDaniel> not my day I guess :)

[18:33] <El_Che> AlexDaniel: hopefully not a Larry

[18:33] <El_Che> or gloria

[18:33] <AlexDaniel> that I wouldn't mind, but it was an actual concrete wall

[18:34] <Zoffix> melezhik: if you're OK with checking item identity (ie 42, <42>, and "42" are all different), then my favourite is `42 ∈ @teh-array`. Otherwise, if all possible array elements are definied, you could use with @array.first: $value { … }`. If `Nil` is a possible value, then I'd go with grep variant that was suggested above

[18:34] <Zoffix> hmm

[18:35] <Zoffix> m: my $s := gather { take 1; say "one"; take 2 }; $s.grep(1).so

[18:35] <camelia> rakudo-moar e9351cbaa: ( no output )

[18:35] <Zoffix> m: my $s := gather { take 1; say "one"; take 2 }; dd $s.grep(1).so

[18:35] <camelia> rakudo-moar e9351cbaa: OUTPUT: «Bool::True␤»

[18:36] <Zoffix> I guess .first is kind'of a perl5-ism, innit? Since in perl 6 grep is lazy and doesn't process all the values and stuff

[18:37] <Zoffix> m: my $s := gather { take 1; say "one"; take 2 }; dd $s.grep(1)

[18:37] <camelia> rakudo-moar e9351cbaa: OUTPUT: «one␤(1,).Seq␤»

[18:37] <Zoffix> m: my $s := gather { take 1; say "one"; take 2 }; dd $s.grep(1).head

[18:37] <camelia> rakudo-moar e9351cbaa: OUTPUT: «1␤»

[18:37] <Zoffix> :)

[18:38] *** turdmonkey is now known as Bowlslaw

[18:39] *** Bowlslaw is now known as turdmonkey

[18:39] <AlexDaniel> Zoffix: hm, it's also interesting that without args .head and .first are probably identical

[18:39] *** turdmonkey is now known as Bowlslaw

[18:39] <Zoffix> Yeah

[18:39] <Bowlslaw> cool

[18:39] <Zoffix> They used to differ around 2015 and .head returned (el,), but then was changed, making the two the same

[18:40] *** uzl left
[18:40] *** uzl joined
[18:41] <Zoffix> m: my @a := 1, 2, 3; my \n := 100_000; { for ^n { .grep(1).so; Nil }; say now - ENTER now }; { for ^n { .first(1).so; Nil }; say now - ENTER now };

[18:41] <camelia> rakudo-moar e9351cbaa: OUTPUT: «1.1955954␤0.5162271␤»

[18:43] <Zoffix> m: my @a := 1, 2, 3; my \n := 100_000; { for ^n { (1 ∈ @a).so; Nil }; say now - ENTER now }; { for ^n { my $ = .first(1).so; Nil }; say now - ENTER now };

[18:43] <camelia> rakudo-moar e9351cbaa: OUTPUT: «0.3567726␤0.4258263␤»

[18:43] <Zoffix> w00t :)

[18:43] <Zoffix> lizmat++ # optimizing ∈

[18:44] <El_Che> those pesky macbook users with their 1 and only use for that trackbar

[18:44] * El_Che ducks

[18:44] *** psychoslave joined
[18:44] * Zoffix never used a mac

[18:45] <Zoffix> well, I did remotely once, I guess to debug stuff

[18:45] <El_Che> Zoffix: I am teasing lizmat :)

[18:45] <Zoffix> ah

[18:45] <Zoffix> AlexDaniel: looks like one is like twice slower than the other tho

[18:45] <AlexDaniel> Zoffix: which one? :)

[18:46] <Zoffix> .first is slower

[18:47] <Zoffix> 3.24x slower, on a 3-el array

[18:47] <Bowlslaw> https://github.com/Bowlslaw/webcrawler/blob/master/crawler.p6

[18:47] *** st_elmo left
[18:47] <Bowlslaw> in order to follow the links, I would have get-urls return get-urls($dom.find('a[href]');, right?

[18:47] <Bowlslaw> recusively, right?

[18:48] <Zoffix> 3el list 

[18:49] <Zoffix> R#1973

[18:49] <synopsebot> R#1973 [open]: https://github.com/rakudo/rakudo/issues/1973 [perf] .first() is equivalent to .head(), but is 3x slower

[18:49] <AlexDaniel> Bowlslaw: but why not .race?

[18:49] <Bowlslaw> I don't know, haha.

[18:49] <Bowlslaw> I am still experimenting with Perl's concurrency features

[18:49] <AlexDaniel> should give more control over the amount of workers

[18:49] <Zoffix> Bowlslaw: that file will get clobbered

[18:50] <AlexDaniel> and yeah, that poor file

[18:50] <Bowlslaw> yes I know right now

[18:50] <Bowlslaw> er

[18:50] *** benji__ joined
[18:50] <melezhik> zoffix: value ∈ @array works for me, thanks

[18:50] <Bowlslaw> wait, it will?

[18:50] <Bowlslaw> i open it with :a

[18:50] <melezhik> btw this is the first time when I use unicode in my code )))

[18:50] <Zoffix> Bowlslaw: you're writing into it from multiple threads at the same time tho

[18:50] <Zoffix> you wanna lock it

[18:50] <Bowlslaw> ooh

[18:51] *** benji__ is now known as benjikun

[18:51] <Zoffix> Bowlslaw: https://docs.perl6.org/routine/lock.html#(IO::Handle)_method_lock

[18:51] <AlexDaniel> melezhik: you can also write `value (elem) @array`

[18:52] <geekosaur> you can get away with that if and only if you control buffering manually so you can ensure every write is atomic. or you lock the Handle so non-atomic writes don't get interleaved; but make sure you flush output before unlocking

[18:52] <Zoffix> Bowlslaw: as for `get-urls($dom.find('a[href]'))` <-- that would pass a list of DOM::Tiny objects as the argument. You want $dom.find('a[href]')»<href>».&get-urls

[18:52] <geekosaur> or disable buffering

[18:53] <Zoffix> Bowlslaw: in other words, you need to get the actual value of the `href` attribute and also you need to call your routine for each of the links in the list

[18:53] <Bowlslaw> >> is the "apply to all" operator?

[18:53] <Zoffix> Bowlslaw: more or less, yes

[18:53] *** benjikun2 left
[18:54] <melezhik> AlexDaniel: sure, thanks 

[18:55] <Zoffix> Bowlslaw: and another thing: some `href`s won't be full URLs, they could be `/some-page` or even `../some/page`. You need to normalize them based on current page's URL or `<base>` element, if one's preseent

[18:55] <Bowlslaw> yes, I've noticed

[18:55] *** mcmillhj left
[18:55] <Bowlslaw> thanks a lot

[18:55] <Bowlslaw> you're helping me make it much more concrete and giving me good direciton

[18:55] <melezhik> btw , zoffix: how to I input "∈" using standard keyboard? 

[18:56] <Zoffix> melezhik: depends on your OS

[18:57] <Zoffix> melezhik: Compose, i, n    does that work

[18:57] <Zoffix> u: ∈

[18:57] <unicodable6> Zoffix, U+2208 ELEMENT OF [Sm] (∈)

[18:57] <Bowlslaw> "$dom.find('a[href]')»<href>».&get-urls"

[18:57] *** psychoslave left
[18:57] <Zoffix> melezhik: or Ctrl+Shift+u, 2208   that's not the easiest way tho

[18:57] <melezhik> virtual  machine in google cloud centos7

[18:57] <AlexDaniel> there are some suggestions on https://docs.perl6.org/language/unicode_entry

[18:58] <Bowlslaw> that code gets the DOM::Tiny objects, uses '>>' to get all of the hrefs,and then passes all of those hrefs to get-urls, right?

[18:58] <El_Che> ∈ 

[18:58] <AlexDaniel> melezhik: what text editor do you use?

[18:58] <El_Che> it works wow

[18:58] <Zoffix> Bowlslaw: basically, yeah

[18:58] <Bowlslaw> Zoffix, that is very cool

[18:58] <El_Che> reminds me of wndows 3.11 in the nineties :)

[18:58] <Zoffix> Indeed

[18:58] <Bowlslaw> '>>' seems so useful...

[18:58] <El_Che> alt + 255 is one I remeber

[18:58] <El_Che> 255

[18:59] <Bowlslaw> Zoffix: so my code, as it stands, with await do ... and start { ... } I do not entirely understand what it is doing

[18:59] <Bowlslaw> it just makes one thread as it stands, right?

[18:59] *** mcmillhj joined
[19:00] <Bowlslaw> but when I add the recursive functionality to get-urls, it will spawn a thread for each URL ?

[19:00] <Zoffix> Bowlslaw: basically yeah

[19:00] <Zoffix> Bowlslaw: you're probably better off using a Supply. It got a throttle on it

[19:01] <Bowlslaw> yes, I am reading about the different concurrency etc. objects

[19:01] <Bowlslaw> they all use the Promise object?

[19:01] <Zoffix> Don't think so

[19:01] <Bowlslaw> so I make a Supply and throttle it to, say, 10, which would limit it to 10 workers?

[19:01] <Bowlslaw> or 10 threads?

[19:01] *** uzl left
[19:01] *** zachk joined
[19:02] <Zoffix> Promise is like a single value, while Supply is a list of values or whatever

[19:02] *** uzl joined
[19:02] <Zoffix> Bowlslaw: 10 jobs running at the same time.

[19:02] <Zoffix> When one completes, another one is started, until they're all done.

[19:03] <Bowlslaw> Sorry for so many questions, I've never written a concurrent app before

[19:03] * Zoffix neither

[19:03] <Zoffix> Like one maybe

[19:03] *** zachk left
[19:03] *** zachk joined
[19:04] *** darutoko left
[19:04] <Zoffix> Bowlslaw: and instead of opening the file and locking into it on each link, you could set up a Channel, which is thread-safe, and then the threads would send stuff to the channel and on the receiving way, you can just keep the file open and write to into it without a lock as data arrives

[19:04] <Zoffix> huggable: Channel

[19:04] <huggable> Zoffix, Thread-safe queue for sending values from producers to consumers: https://docs.perl6.org/type/Channel

[19:05] <melezhik> AlexDaniel: thanks , will look into this 

[19:05] <melezhik> AlexDaniel: nano

[19:05] <Bowlslaw> omg that is cool

[19:05] <Zoffix> Bowlslaw: you could also use .race, as AlexDaniel said

[19:05] <Bowlslaw> yes

[19:05] *** dct left
[19:06] <Bowlslaw> as in...

[19:06] <Bowlslaw> er...

[19:06] <Bowlslaw> where the heck do I put .race ?

[19:06] <Bowlslaw> await do for get-urls($seed) -> $e.race ?

[19:06] <Bowlslaw> get-urls($seed).race

[19:07] <Zoffix> The latter

[19:07] <Bowlslaw> I knew it!

[19:07] <Bowlslaw> my Perl 6 instinct increases!

[19:07] *** dct joined
[19:08] <Zoffix> Bowlslaw: just keep in mind, if you do `for @blah.race { ... }` that will be serial, you need `race for @blah`. That's a special thing that RaceSeq and HyperSeq get serialized by normal `for` 

[19:08] <Bowlslaw> do I need to remove 'await do' ?

[19:09] <Bowlslaw> await do race for @blah, lol

[19:09] *** mcmillhj left
[19:09] <Zoffix> Bowlslaw: yeah, remove it all

[19:10] <Zoffix> m: sub get-urls { $^v.comb }; get-urls("meows").race.map: { say "Got $_" }

[19:10] <camelia> rakudo-moar e9351cbaa: OUTPUT: «Got m␤Got e␤Got o␤Got w␤Got s␤»

[19:10] <Zoffix> m: sub get-urls { $^v.comb }; get-urls("meows").race(:batch).map: { say "Got $_" }

[19:10] <camelia> rakudo-moar e9351cbaa: OUTPUT: «Got m␤Got e␤Got o␤Got w␤Got s␤»

[19:10] <Zoffix> m: sub get-urls { $^v.comb }; get-urls("meows").race(:batch).map: { say "Got $_" }

[19:10] <camelia> rakudo-moar e9351cbaa: OUTPUT: «Got m␤Got e␤Got o␤Got w␤Got s␤»

[19:10] <Zoffix> m: sub get-urls { $^v.comb }; get-urls("meows").race(:batch).map: { say "Got $_"; sleep rand }

[19:10] <camelia> rakudo-moar e9351cbaa: OUTPUT: «Got m␤Got e␤Got o␤Got w␤Got s␤»

[19:10] <Zoffix> :|

[19:11] <Bowlslaw> lol

[19:11] <Zoffix> Does .race use afinity queue or general queue?

[19:12] <Zoffix> m: sub get-urls { $^v.comb }; get-urls("meows").race(:batch).map: { say "Got $_"; sleep 2 }; say now - ENTER now

[19:12] <camelia> rakudo-moar e9351cbaa: OUTPUT: «Got m␤Got e␤Got o␤Got w␤Got s␤4.0223487␤»

[19:12] <Zoffix> ok, so it's batching right, but they're all in order somehow :/

[19:14] <Zoffix> m: my int $n; sub get-urls { $^v.comb }; get-urls("meow").race(:batch).map: { print $_; sleep $n⚛++ }; say " ", now - ENTER now

[19:15] <camelia> rakudo-moar e9351cbaa: OUTPUT: «meow 3.051368␤»

[19:15] <Zoffix> oh, I'm dumb

[19:15] <Zoffix> I'm printing the stuff BEFORE it sleeps :P

[19:16] <Zoffix> no, still in order :/

[19:17] <AlexDaniel> m: my int $n; sub get-urls { $^v.comb }; get-urls("meow").race(:batch).map: { sleep rand; print $_ }; say " ", now - ENTER now

[19:17] <camelia> rakudo-moar e9351cbaa: OUTPUT: «wemo 0.98007657␤»

[19:17] <Bowlslaw> wemo!

[19:17] <AlexDaniel> m: my int $n; sub get-urls { $^v.comb }; get-urls("meowmeowmeowmeow").race(:batch).map: { sleep rand; print $_ }; say " ", now - ENTER now

[19:17] <camelia> rakudo-moar e9351cbaa: OUTPUT: «memwoeoowmeewwmo 2.17836912␤»

[19:17] <Zoffix> m: my int $n; sub get-urls { $^v.comb }; get-urls("meow").race(:batch).map({ say $n; sleep $n⚛++; $_ }).join.&say: " ", now - ENTER now

[19:18] <camelia> rakudo-moar e9351cbaa: OUTPUT: «0␤1␤2␤3␤meow 3.05100321␤»

[19:18] <AlexDaniel> looks racy to me

[19:18] <Zoffix> m: my int $n; sub get-urls { $^v.comb }; get-urls("meow").race(:batch).map({ say $n; sleep $n⚛++; $_ }).join.&say: " ", now - ENTER now

[19:18] <camelia> rakudo-moar e9351cbaa: OUTPUT: «0␤1␤2␤3␤meow 3.051496␤»

[19:18] <Zoffix> oh right

[19:18] <Zoffix> m: my int $n = 3; sub get-urls { $^v.comb }; get-urls("meow").race(:batch).map({ say $n; sleep $n⚛--; $_ }).join.&say: " ", now - ENTER now

[19:18] <camelia> rakudo-moar e9351cbaa: OUTPUT: «3␤2␤1␤0␤woem 3.0166136␤»

[19:19] *** HaraldJo` left
[19:20] *** mcmillhj joined
[19:21] <Zoffix> "Perl 6: conventient constructs for parallelism that save you time coding… so you could waste it trying to see if those construct give stuff out of order" :)

[19:21] <Bowlslaw> lol

[19:25] *** mcmillhj left
[19:26] *** dct left
[19:27] *** dct joined
[19:30] <Zoffix> m: sub get-urls($url) { gather { take $url; $url.chars > 1 and .take for get-urls $url.chop } }; await get-urls("meows").Supply.throttle: 3, {.say; sleep ½};

[19:30] <Zoffix> How come it never finishes?

[19:30] <camelia> rakudo-moar e9351cbaa: OUTPUT: «(timeout)meows␤»

[19:31] <Zoffix> ah, nm

[19:31] <Zoffix> the `and` is part of the `for` body

[19:31] <Zoffix> m: 'sub get-urls($url) { gather { take $url; $url.chars > 1 and (.take for get-urls $url.chop) } }; await get-urls("meows").Supply.throttle: 3, {.say; sleep ½};

[19:31] <camelia> rakudo-moar e9351cbaa: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Unable to parse expression in single quotes; couldn't find final "'" (corresponding starter was at line 1)␤at <tmp>:1␤------> 3s").Supply.throttle: 3, {.say; sleep ½};7⏏5<EOL>␤    expecting…»

[19:31] <Zoffix> m: sub get-urls($url) { gather { take $url; $url.chars > 1 and (.take for get-urls $url.chop) } }; await get-urls("meows").Supply.throttle: 3, {.say; sleep ½};

[19:31] <camelia> rakudo-moar e9351cbaa: OUTPUT: «meows␤meow␤meo␤me␤m␤»

[19:31] *** _uzl joined
[19:32] *** DeepIO joined
[19:32] *** DeepIO left
[19:33] *** uzl left
[19:34] <Zoffix> m: (my Channel $c .= new).Supply.tap: { say "Got URL: $_" };  sub get-urls($url) { gather { take $url; $url.chars > 1 and (.take for get-urls $url.chop) } }; await get-urls("meows").Supply.throttle: 3, {$c.send: $_}; $c.done

[19:34] <camelia> rakudo-moar e9351cbaa: OUTPUT: «(timeout)Got URL: meows␤»

[19:34] <Zoffix> Weird that it hangs if you erroneously call .done instead of .close on a channel, eh?

[19:35] <Zoffix> m: (my Channel $c .= new).Supply.tap: { say "Got URL: $_" };  sub get-urls($url) { gather { take $url; $url.chars > 1 and (.take for get-urls $url.chop) } }; await get-urls("meows").Supply.throttle: 3, {$c.send: $_}; $c.close

[19:35] <Zoffix> :/

[19:35] <camelia> rakudo-moar e9351cbaa: OUTPUT: «(timeout)Got URL: meows␤»

[19:35] <Zoffix> I guess I'm doing something wrong. 'cause this works locally

[19:35] <Zoffix> oh, ok, got it to hang

[19:36] <Zoffix> m: start react whenever (my Channel $c .= new) { say "Got URL: $_" };  sub get-urls($url) { gather { take $url; $url.chars > 1 and (.take for get-urls $url.chop) } }; await get-urls("meows").Supply.throttle: 3, {$c.send: $_}; $c.close

[19:36] <camelia> rakudo-moar e9351cbaa: OUTPUT: «Got URL: meows␤Got URL: meow␤Got URL: meo␤Got URL: me␤Got URL: m␤»

[19:36] <Zoffix> Bowlslaw: this is what I was talking about ^ but I dunno if it's right, I'm a n00b

[19:37] *** n1ge joined
[19:37] *** n1ge left
[19:38] <Bowlslaw> haha

[19:38] <Bowlslaw> yeah I was looking at reach whenever

[19:39] <Bowlslaw> i think jremelo suggested it last night

[19:39] <Bowlslaw> react*

[19:39] *** mcmillhj joined
[19:40] <Zoffix> Filed R#1974, just in case

[19:40] <synopsebot> R#1974 [open]: https://github.com/rakudo/rakudo/issues/1974 [ASYNC] Async code hangs on occasion, possibly because of the bug in the program

[19:42] *** Zoffix left
[19:44] <ecocode> by any chance: has somebody put the perl6 documentation in an epub ?

[19:44] *** mcmillhj left
[19:52] *** n1ge joined
[19:53] *** haj` joined
[19:53] <haj`> gq reboot

[19:53] *** haj` left
[19:54] *** n1ge left
[19:54] *** n1ge joined
[19:56] *** mcmillhj joined
[19:56] *** pmurias left
[20:02] *** dct left
[20:03] <lizmat> ecocode: there's one project to put all of the docs in one HTML file, so the epub should not be far away

[20:03] <lizmat> jjmerelo would probably know more about it, or [Coke] 

[20:06] *** melezhik left
[20:07] *** mr_ron joined
[20:07] *** aindilis left
[20:08] *** rindolf left
[20:08] *** aindilis joined
[20:10] <ecocode> https://github.com/perl6/doc/issues/1981

[20:13] *** rindolf joined
[20:17] *** reisinge joined
[20:25] *** pmurias joined
[20:32] *** reisinge left
[20:34] <buggable> New CPAN upload: FindBin-0.1.4.tar.gz by LEMBARK http://modules.perl6.org/dist/FindBin:cpan:LEMBARK

[20:58] *** pmurias left
[21:14] <buggable> New CPAN upload: FindBin-0.1.5.tar.gz by LEMBARK http://modules.perl6.org/dist/FindBin:cpan:LEMBARK

[21:14] <buggable> New CPAN upload: FindBin-0.1.6.tar.gz by LEMBARK http://modules.perl6.org/dist/FindBin:cpan:LEMBARK

[21:17] *** perlpilot joined
[21:25] *** mcmillhj left
[21:25] <tyil> eh

[21:26] <tyil> that FindBin dist has a README for Pod::To::Markdown

[21:32] *** __uzl joined
[21:32] *** rindolf left
[21:34] *** _uzl left
[21:39] *** mcmillhj joined
[21:43] *** mcmillhj left
[21:48] *** mcmillhj joined
[21:56] <Bowlslaw> Anyone here used Cro?

[21:57] <Bowlslaw> Also, can you set up the perl interpreter to be more like Haskell, in that you can load a file to it and import all of your symbols and use autocomplete on them, etc?

[22:00] <perlpilot> Bowlslaw, I have used cro a little bit.

[22:00] <Bowlslaw> What do you think? Pros and Cons?

[22:02] <perlpilot> Bowlslaw, well .... I think cro is the most perl6ian way to do a web framework and it seems well suited to be more than just a web framework (but I haven't played with the other services yet)

[22:03] *** Zoffix joined
[22:03] <perlpilot> as far as cons ... I'm not sure.  Maybe the documentation is a little opaque sometimes?  i.e. it would be nice to have a quick reference

[22:03] <Zoffix> ecocode: yeah, I got one from last October: https://temp.perl6.party/pub/2017/PSix-Docs-Oct-30-2017.epub

[22:04] <Zoffix> ecocode: you could gen newer one from this file: https://docs.perl6.org/perl6.html with calibre

[22:04] *** mr_ron left
[22:04] *** mr_ron joined
[22:04] <Zoffix> "Convert individually" and in "Table of Contents" use h1, h2, and h3 as selectors. And it should do the rest automagically

[22:05] <perlpilot> Bowlslaw, btw, I don't know if you can setup the Perl 6 REPL to be more like Haskell.  Loading a file doesn't seem too bad, but autocompleting the symbols might be a bit more work.

[22:06] <Zoffix> Bowlslaw: you might be able to repurpose this code for that purpose: https://github.com/perl6/routine-map/blob/master/mapper.p6#L64-L79

[22:07] <Zoffix> Bowlslaw: as for Cro. It's great. Tho I see it plugged as a Web Framework by many people, yet it's more a of microservices thing, to my eyes

[22:07] <Bowlslaw> hmm

[22:07] <Bowlslaw> That's exciting.

[22:07] <timotimo> more webappy stuff is on the way

[22:07] <timotimo> including a perl6-y template system that currently exists as an experiment

[22:07] <Bowlslaw> I think I need to write some more Perl 6 before I can meaningfully contribute to actually developing perl 6

[22:08] <Zoffix> timotimo: awesome

[22:08] <timotimo> https://github.com/jnthn/cro-webapp - aptly named

[22:08] <timotimo> ah, actually, it's currently only the template system

[22:09] <Zoffix> Bowlslaw: you can do both at the same time :)

[22:10] <perlpilot> Bowlslaw, lots of people have contributed to developing Perl 6 and some of them have barely known what they were doing at the time  (i.e. I've contributed some bits before  ;-)

[22:10] <Zoffix> Bowlslaw: there are tons of easy Issues to hack on: https://github.com/rakudo/rakudo/issues?q=is%3Aopen+is%3Aissue+label%3A%22easy+to+resolve%22

[22:10] <Bowlslaw> Zoffix: ahha, yes

[22:10] <perlpilot> I guess my i.e. was more of an e.g.

[22:12] <Bowlslaw> alright guys, cya later

[22:12] *** Bowlslaw left
[22:12] <Zoffix> \o

[22:12] *** Zoffix left
[22:15] *** skids left
[22:15] *** mcmillhj left
[22:18] *** wamba left
[22:30] *** mcmillhj joined
[22:35] *** mcmillhj left
[22:47] *** sena_kun left
[22:48] *** MasterDuke joined
[22:50] *** mcmillhj joined
[22:50] *** natrys left
[22:54] <buggable> New CPAN upload: Vroom-Reveal-0.0.2.tar.gz by JGOFF https://cpan.metacpan.org/authors/id/J/JG/JGOFF/Perl6/Vroom-Reveal-0.0.2.tar.gz

[22:55] *** mcmillhj left
[23:00] *** mr_ron left
[23:10] *** raynold joined
[23:20] *** turdmonkey joined
[23:20] *** turdmonkey is now known as Bowlslaw

[23:21] <Bowlslaw> Hello.

[23:33] *** __uzl left
[23:33] *** _uzl joined
[23:36] *** subroot joined
[23:42] *** mcmillhj joined
[23:46] *** mcmillhj left
[23:48] <Bowlslaw> Perl 6 is so weridly fun to code...

[23:52] *** mcmillhj joined
[23:53] <hobbs> that's our evil plan

[23:56] *** mahafyi joined
[23:57] *** mcmillhj left
