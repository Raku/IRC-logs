[00:08] <Xliff> I have two new methods: multi method new (GtkOrientation $orientation, gint $spacing), and multi method new (:$box). When I try and use the first one I get the following error: Default constructor for 'GTK::Box' only takes named arguments.

[00:09] <Xliff> I thought positionals superseded named arguments.

[00:10] <timotimo> i recommend overriding the default "new" method by putting a proto method in there

[00:12] <timotimo> m: class Test { }; say Test.^find_method("new").^candidates

[00:12] <camelia> rakudo-moar 49363d690: OUTPUT: «No such method 'candidates' for invocant of type 'Perl6::Metamodel::ClassHOW'␤  in block <unit> at <tmp> line 1␤␤»

[00:12] <timotimo> m: class Test { }; say Test.^find_method("new")[0].^candidates

[00:12] <camelia> rakudo-moar 49363d690: OUTPUT: «No such method 'candidates' for invocant of type 'Perl6::Metamodel::ClassHOW'␤  in block <unit> at <tmp> line 1␤␤»

[00:12] <timotimo> mhh

[00:12] <timotimo> m: class Test { }; say Test.^find_method("new")

[00:12] <camelia> rakudo-moar 49363d690: OUTPUT: «new␤»

[00:13] <timotimo> m: class Test { }; say Test.^find_method("new").^name

[00:13] <camelia> rakudo-moar 49363d690: OUTPUT: «Method␤»

[00:13] <timotimo> m: class Test { }; say Test.^find_method("new").^methods

[00:13] <camelia> rakudo-moar 49363d690: OUTPUT: «(gist <anon> leave <anon> <anon> wrap <anon> <anon> <anon> onlystar <anon> <anon> candidates <anon> package unwrap yada <anon> multi <anon> soft <anon> <anon> <anon> <anon> cando <anon> perl BUILDALL <anon> has-phaser set_why fire_if_phasers of phaser…»

[00:13] <timotimo> m: class Test { }; say Test.^find_method("new").perl

[00:13] <camelia> rakudo-moar 49363d690: OUTPUT: «proto method new (Mu: |) {*}␤»

[00:13] <timotimo> m: class Test { }; say Test.^find_method("new").candidates

[00:13] <camelia> rakudo-moar 49363d690: OUTPUT: «(new new)␤»

[00:13] <timotimo> m: class Test { }; say Test.^find_method("new").candidates>>.perl

[00:13] <camelia> rakudo-moar 49363d690: OUTPUT: «(multi method new (Mu: *%attrinit) { #`(Method|45274992) ... } multi method new (Mu: $, *@, *%_) { #`(Method|45275144) ... })␤»

[00:14] <Xliff> Hrm.

[00:14] <timotimo> it's got a slurpy positional there

[00:14] <Xliff> Can I define two protos?

[00:14] <Xliff> Yeah. I see that.

[00:14] <timotimo> not for the same name

[00:15] <timotimo> but you can just make its signature maximum free, like proto method new (|) {*}

[00:16] <Xliff> That kinda sucks though.

[00:16] <timotimo> how so?

[00:17] <Xliff> Because I can't do positionals OR named parameters. I have to do both.

[00:17] <timotimo> the proto has to accept anything you want to have a candidate for

[00:17] <timotimo> the union, so to speak

[00:18] <Xliff> So new(Int, Int) cannot coexist with new(:$nv) unless proto method new(Int?, Int? |)

[00:18] <timotimo> or new(|)

[00:18] <Xliff> new(|) won't accept two positionals.

[00:18] <Xliff> Just named arguments.

[00:18] <lookatme> maybe new(:$nv!)

[00:19] <timotimo> really?

[00:19] <Xliff> Don't want :$nv in case 1

[00:19] <Xliff> Yeah. Tried new(|) and it gave me an error

[00:19] <timotimo> m: proto sub blerp(|) {*}; multi blerp($a, $b) { say "two ints" }; multi blerp(:$nv) { say "nv" }; blerp(1, 2); blerp(nv => 99)

[00:19] <camelia> rakudo-moar 49363d690: OUTPUT: «two ints␤nv␤»

[00:19] <Xliff> Try method

[00:20] <timotimo> m: class Floop { proto method blerp(|) {*}; multi method blerp($a, $b) { say "two ints" }; multi method blerp(:$nv) { say "nv" }; }; Floop.blerp(1, 2); Floop.blerp(nv => 99)

[00:20] <camelia> rakudo-moar 49363d690: OUTPUT: «two ints␤nv␤»

[00:21] <Xliff> m: class Floop { proto new blerp(|) {*}; multi method new($a, $b) { say "two ints" }; multi method new(:$nv) { say "nv" }; }; Floop.new(1, 2); Floop.new(nv => 99

[00:21] <lookatme> m: class F { multi method new(:$nv!) { say "nv"; }; multi method new(Int $a?, Int $b?) { say "two"; }; }; say F.new(1, 2);

[00:21] <camelia> rakudo-moar 49363d690: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Missing block␤at <tmp>:1␤------> 3class Floop { proto new7⏏5 blerp(|) {*}; multi method new($a, $b) ␤    expecting any of:␤        new name to be defined␤»

[00:21] <camelia> rakudo-moar 49363d690: OUTPUT: «two␤True␤»

[00:21] <timotimo> you have "proto new" instead of "proto method"

[00:21] <Xliff> m: class Floop { proto new blerp(|) {*}; multi method new($a, $b) { say "two ints" }; multi method new(:$nv) { say "nv" }; }; Floop.new(1, 2); Floop.new(nv => 99);

[00:21] <camelia> rakudo-moar 49363d690: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Missing block␤at <tmp>:1␤------> 3class Floop { proto new7⏏5 blerp(|) {*}; multi method new($a, $b) ␤    expecting any of:␤        new name to be defined␤»

[00:21] <Xliff> OK. I will try mandatory named.

[00:22] <timotimo> do you see the problem with "proto new"?

[00:22] <lookatme> m: class F { multi method new(:$nv!) { say "nv"; }; multi method new(Int $a?, Int $b?) { say "two"; }; }; F.new(1, 2); F.new(nv => 22);

[00:22] <camelia> rakudo-moar 49363d690: OUTPUT: «two␤nv␤»

[00:22] <lookatme> m: class F { multi method new(:$nv) { say "nv"; }; multi method new(Int $a?, Int $b?) { say "two"; }; }; F.new(1, 2); F.new(nv => 22);

[00:22] <camelia> rakudo-moar 49363d690: OUTPUT: «two␤nv␤»

[00:22] <lookatme> m: class F { multi method new(:$nv) { say "nv"; }; multi method new(Int $a?, Int $b?) { say "two"; }; }; F.new();

[00:22] <camelia> rakudo-moar 49363d690: OUTPUT: «nv␤»

[00:23] <lookatme> :D

[00:23] <timotimo> yeah, the nv one is more specific, because it has exactly 0 positionals, whereas the Int? Int? one is for either 0, 1, or 2 ints

[00:24] <lookatme> what is 0 ints ?

[00:24] <lookatme> :(

[00:24] <timotimo> "0 parameters, all of them ints"

[00:26] <lookatme> I prefer they raise an compile error, or warning

[00:26] <timotimo> not possible with regular methods, as they are completely late-bound

[00:26] <lookatme> they are all can accept zero parameters obviously

[00:27] *** mst left
[00:27] <lookatme> oh

[00:28] <timotimo> do note that named parameters are only ever used to break ties, and every method has an implicit *% argument

[00:29] <lookatme> yeah, I know this recently

[00:34] *** mst joined
[00:34] *** mst left
[00:34] *** mst joined
[00:38] <Xliff> Now: class A { multi method new ($a, $b) { say "ab"; }; multi method new (:$box) { say "Box!" }: }; A.new(1, 2); A.new(:box(3);

[00:39] <Xliff> m: class A { multi method new ($a, $b) { say "ab"; }; multi method new (:$box) { say "Box!" }: }; A.new(1, 2); A.new(:box(3);

[00:39] <camelia> rakudo-moar 49363d690: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Unexpected closing bracket␤at <tmp>:1␤------> 3multi method new (:$box) { say "Box!" }:7⏏5 }; A.new(1, 2); A.new(:box(3);␤»

[00:39] <Xliff> m: class A { multi method new ($a, $b) { say "ab"; }; multi method new (:$box) { say "Box!" }; }; A.new(1, 2); A.new(:box(3);

[00:39] <camelia> rakudo-moar 49363d690: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Unable to parse expression in argument list; couldn't find final ')' (corresponding starter was at line 1)␤at <tmp>:1␤------> 3"Box!" }; }; A.new(1, 2); A.new(:box(3);7⏏5<EOL>␤    expecting …»

[00:39] <Xliff> m: class A { multi method new ($a, $b) { say "ab"; }; multi method new (:$box) { say "Box!" }; }; A.new(1, 2); A.new(:box(3));

[00:39] <camelia> rakudo-moar 49363d690: OUTPUT: «ab␤Box!␤»

[00:39] *** Ven` joined
[00:40] <Xliff> When I try that in my code, it says "Too few positionals passed; expected at least 2 arguments but got only 1"

[00:42] <timotimo> any more classes you derive from, roles you include, anything like that?

[00:42] <timotimo> version difference perhaps?!

[00:42] <timotimo> committable: releases class A { multi method new ($a, $b) { say "ab"; }; multi method new (:$box) { say "Box!" }; }; A.new(1, 2); A.new(:box(3));

[00:42] <committable6> timotimo, ¦releases (31 commits): «ab␤Box!␤»

[00:42] <timotimo> that's probably not it, hmm.

[00:43] *** Ven` left
[00:44] *** jeromelanteri joined
[00:44] <timotimo> anyway, i have to go get sleep

[00:49] *** jeromelanteri left
[00:55] <Xliff> nn "timo"x2

[00:55] <Xliff> m: ("timo" x 2).say

[00:55] <camelia> rakudo-moar 49363d690: OUTPUT: «timotimo␤»

[00:56] <Xliff> m: ("timo" xx 2).join.say

[00:56] <camelia> rakudo-moar 49363d690: OUTPUT: «timotimo␤»

[00:56] <lookatme> timotimo, good night :)

[00:57] *** Xliff left
[01:01] *** jameslenz joined
[01:02] *** jeromelanteri joined
[01:04] *** Kaypie left
[01:05] *** lizmat left
[01:05] *** jameslenz left
[01:06] *** subr left
[01:06] *** subroot joined
[01:10] *** spycrab0 left
[01:46] *** atweiden-air joined
[01:48] <atweiden-air> Hey you guys; i read in the newsletter something that will break a bunch of my code:the `is required` trait does not make sense on private attributes in a class because private attributes will never be assigned by the default object building logic (aka .new). To avoid confusion, adding is required to a private attribute is now a compilation error.

[01:48] <atweiden-air> i take issue with this change: `has $!thing is required` is perfectly reasonable assuming the class has a custom submethod BUILD.

[01:49] <atweiden-air> e.g. https://github.com/atweiden/mktxn/blob/8e6516aefbad2454264ed4953ab621c9c65987cf/lib/TXN.pm6#L56

[01:51] *** fake_space_whale joined
[01:54] <atweiden-air> for me it's a visual aid: i can know with certainty private attributes of a class marked `is required` had to have been derived during a custom instantiation process. it's perfectly self-documenting

[02:02] *** molaf left
[02:02] *** Zoffix joined
[02:03] <Zoffix> atweiden-air: but that's misleading code, because the check is not enforced.

[02:03] <Zoffix> You may as well just make those basic comments.

[02:03] <atweiden-air> i suppose this won't affect my code if I provide `has $.thing is required; method thing() {*}` ..?

[02:04] <atweiden-air> commit: https://github.com/rakudo/rakudo/commit/1ad34320e091949109523b6457939848aad1e7dd#diff-9e5f9979983fe8296ec533beecd070f1R104

[02:04] <committable6> atweiden-air, I cannot recognize this command. See wiki for some examples: https://github.com/perl6/whateverable/wiki/Committable

[02:04] <Zoffix> atweiden-air: then it's not a private attribute

[02:04] <atweiden-air> i mean `has $!thing is required`

[02:04] <atweiden-air> maybe that would pass the conditional check `$attr.has_accessor`

[02:05] <Zoffix> atweiden-air: it doesn't know it's an accessor

[02:05] <atweiden-air> m: class ABC { has $!thing is required; }; ABC.new.perl.say;

[02:05] <camelia> rakudo-moar 49363d690: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤'is required' only works on a public attribute $.thing, not a private $!thing␤at <tmp>:1␤»

[02:06] <atweiden-air> dunno how to show the error from the current stable release

[02:06] <atweiden-air> but it's `The attribute '$!thing' is required, but you did not provide a value for it.`

[02:06] <Zoffix> That is the error

[02:06] <atweiden-air> Zoffix: so i think this is currently enforced

[02:07] <Zoffix> ?

[02:07] <atweiden-air> Zoffix: you said earlier "because the check is not enforced."

[02:07] <Zoffix> c: 2018.06 class Foo { has $!foo is required;  }

[02:07] <committable6> Zoffix, ¦2018.06: «»

[02:07] <Zoffix> I meant before the change showing you have a bug in your code, the `is required` check was not enforced

[02:09] <Zoffix> atweiden-air: in either case. Such discussions are better had on the Issue tracker ( https://github.com/rakudo/rakudo/issues/new ), but I doubt you'll have much luck convincing the core devs they should leave in dead, misleading code because you've used it instead of a comment ( https://xkcd.com/1172/ ). You may choose an alternate strategy, such as suggesting making the attribute enforce that the private

[02:09] <Zoffix> attribute, but that runs into an issue of what "some value" really is, since the default default of the container is "some value"

[02:09] <atweiden-air> not sure what you mean. 2018.06 throws an error on this: `class ABC { has $!thing is required; }; ABC.new.perl.say;`

[02:09] <atweiden-air> the error message is: The attribute '$!thing' is required, but you did not provide a value for it.

[02:09] <Zoffix> Ah, I forgot a .new

[02:09] <Zoffix> c: 2018.06 class ABC { has $!thing is required; }; ABC.new.perl.say;

[02:09] <committable6> Zoffix, ¦2018.06: «The attribute '$!thing' is required, but you did not provide a value for it.␤  in submethod BUILDALL at /tmp/f1vpWNHMc8 line 1␤  in block <unit> at /tmp/f1vpWNHMc8 line 1␤␤ «exit code = 1»»

[02:09] <Zoffix> c: 2018.06 class ABC { has $!thing is required; submethod BUILD(:$!thing = 42) {} }; ABC.new.perl.say;

[02:09] <committable6> Zoffix, ¦2018.06: «ABC.new␤»

[02:09] <Zoffix> c: 2018.06 class ABC { has $!thing is required; submethod BUILD(:$!thing = Any) {} }; ABC.new.perl.say;

[02:09] <committable6> Zoffix, ¦2018.06: «ABC.new␤»

[02:12] <atweiden-air> Zoffix: i suppose i could open an issue on GH. i like venting on IRC tho :)

[02:12] <Zoffix> atweiden-air: filed an Issue for this: R#2083

[02:12] <synopsebot> R#2083 [open]: https://github.com/rakudo/rakudo/issues/2083 [LTA][regression] `is required` change removed useful feature

[02:13] <Zoffix> atweiden-air: well, then you may choose to vent on #perl6-dev that has higher chance of being noticed by coredevs :)

[02:16] <atweiden-air> attn coredevs

[02:16] * atweiden-air squints, shakes fist

[02:16] <Zoffix> :)

[02:17] <Zoffix> Actually, breakage of that module would've shown up on toaster run, and I'd guess the release manager would revert the change. But it's nice to also have an argument for why it was a useful feature to go along with it :)

[02:18] <Zoffix> greppable6: \$\!.+is required

[02:18] <greppable6> Zoffix, 13 lines, 9 modules: https://gist.github.com/c0349a59a74bf4406864c6aa3d89ae04

[02:18] <Zoffix> hm, wonder why your module doesn't show up in the list (was the issue of missing modules in all-modules repo fixed?)

[02:19] <Zoffix> Hhahaha

[02:19] <Zoffix> Even my own module is broken by the change: https://github.com/zoffixznet/perl6-WWW-vlc-Remote/blob/cd64c9aef50ea8445717af8df7e72398d3fb165d/lib/WWW/vlc/Remote.pm6#L6

[02:26] *** Zoffix left
[02:48] *** giraffe joined
[02:51] *** atweiden-air left
[03:00] *** Kaypie joined
[03:01] *** jameslenz joined
[03:04] *** El_Che left
[03:05] *** El_Che joined
[03:05] *** jameslenz left
[03:27] *** kjk joined
[03:29] <kjk> is there an existing method for updating a Hash with another such that if a key exists its value is replaced otherwise the new key value are added?

[03:32] <MasterDuke> m: my %orig = :1a, :2b; my %new = :5b, :6c; %orig ,= %new; dd %orig

[03:32] <camelia> rakudo-moar 49363d690: OUTPUT: «Hash %orig = {:a(1), :b(5), :c(6)}␤»

[03:33] *** aindilis left
[03:34] <MasterDuke> kjk: ^^^

[03:34] <kjk> MasterDuke: thanks for the solution. Is it optimized behind the scene so that it's not actually creating a new hash from both old and new and then overwrite %orig?

[03:36] <MasterDuke> i believe so, but not 100% sure

[03:37] <kjk> is that the idiomatic why to do it in perl6? sorry, new to perl6. In python, I'd just use the dict.update method

[03:38] <MasterDuke> pretty idomatic. it may or may not be what you want if there are multi-level hashes, depends on your use-case

[03:44] <MasterDuke> sleeping &

[03:44] <kjk> p6: my %orig = :1a, :2b; my %new = :5b, :6c; for %new.kv { %orig{$^k} = $^v }

[03:44] <camelia> rakudo-moar 49363d690: ( no output )

[03:44] <kjk> p6: my %orig = :1a, :2b; my %new = :5b, :6c; for %new.kv { %orig{$^k} = $^v }; dd %orig

[03:44] <camelia> rakudo-moar 49363d690: OUTPUT: «Hash %orig = {:a(1), :b(5), :c(6)}␤»

[03:50] *** subroot left
[03:53] *** MasterDuke left
[03:55] *** eliasr left
[03:55] <fake_space_whale> Is using $?FILE the proper way to construct a path relative to the executing file for loading resources? for example something like my $config = $?FILE.IO.sibling("config.txt").slurp;

[03:56] <Juerd> kjk: Why the loop? :)

[03:56] <Juerd> p6: my %orig = :1a, :2b; my %new = :5b, :6c; %orig{ %new.keys } = %new.values; dd %orig

[03:56] <camelia> rakudo-moar 49363d690: OUTPUT: «Hash %orig = {:a(1), :b(5), :c(6)}␤»

[03:57] *** sauvin joined
[03:57] <Juerd> fake_space_whale: $*PROGRAM.resolve.sibling(...)

[03:57] <kjk> Juerd: cool another way to do it

[03:57] <Juerd> fake_space_whale: $?FILE is compile-time and could be a module.

[03:58] <kjk> Juerd: so, is .keys guarrentee to return the keys in the same order as the their values?

[03:59] <Summertime> should do as long as the hash doesn't get mutated inbetween? assuming its like python's old dicts

[04:00] <Juerd> kjk: That's missing from the documentation. Would you care to create a github issue for that? I'm about to go to bed (6am here)

[04:00] <Juerd> https://github.com/perl6/doc/issues

[04:00] <Summertime> ? > Note that the order in which keys, values and pairs are retrieved is generally arbitrary, but the keys, values and pairs methods return them always in the same order when called on the same object.

[04:00] <Juerd> Good night!

[04:00] <Summertime> I'd say that implies it enough

[04:00] <kjk> I like MasterDuke's version better: %orig ,= %new     but I'm not sure if that's doing it the smart way behind the scene or creating a new hash from %orig and %new

[04:02] <Summertime> I'd assume it'd be making a new hash, you'd expect that it wouldn't mutate the original value, much like most other thing= uses

[04:05] <kjk> I kinda hope it would mutate the %orig in this case since it's going to reassign it anyway creating a copy, mutate it, and then assign it to %orig would be a waste.

[04:05] <fake_space_whale> Juerd: Thank you

[04:06] <kjk> Juerd: I'm not sure if you mean no doc on how to update a Hash with another or no doc about the order of .keys and .values

[04:06] <lookatme> no docs about the order

[04:07] <kjk> ok

[04:08] <Summertime> probably just needs some clarification in the third paragraph of the Map class documentation

[04:11] *** Ven` joined
[04:15] *** Ven` left
[04:50] *** curan joined
[05:01] *** jameslenz joined
[05:06] *** jameslenz left
[05:08] *** HaraldJoerg joined
[05:15] *** xtreak joined
[05:26] *** sno left
[05:32] *** troys left
[05:44] *** aindilis joined
[05:44] *** fake_space_whale left
[05:46] *** sarna joined
[05:48] <sarna> hey, how do I define a custom destructor?

[05:54] <geekosaur> submethod DESTROY() { ... }

[05:55] <sarna> thanks :)

[05:56] *** rindolf joined
[05:58] *** fake_space_whale joined
[06:12] *** fake_space_whale left
[06:25] *** robertle joined
[06:25] *** nebuchadnezzar joined
[06:32] *** sno joined
[06:35] *** wamba joined
[06:39] *** konsolebox left
[06:41] *** konsolebox joined
[07:02] *** jameslenz joined
[07:06] *** jameslenz left
[07:10] *** domidumont joined
[07:11] *** psychoslave joined
[07:14] *** pecastro joined
[07:16] *** wamba left
[07:17] *** domidumont left
[07:17] <perlawhirl> I'm unable to build NQP :(

[07:17] <perlawhirl> MoarVM panic: Memory allocation failed; could not allocate 4294967296 bytes

[07:18] *** domidumont joined
[07:20] <moritz> it tries to allocate 4GB RAM at once?

[07:21] <perlawhirl> seems that way.

[07:22] <perlawhirl> i might try a reboot first, and failing that, rollback commits on Moar and NQP and retry building

[07:26] *** woolfy left
[07:27] *** woolfy joined
[07:37] *** dakkar joined
[07:44] *** lizmat joined
[07:45] *** araujo left
[07:48] *** wamba joined
[07:48] * lizmat clickbaits https://p6weekly.wordpress.com/2018/07/16/2018-29-cross-pollination/

[07:52] *** wamba left
[07:53] *** wamba joined
[07:57] *** ilogger2 joined
[07:57] *** ChanServ sets mode: +v ilogger2

[08:04] *** scimon joined
[08:15] *** Ven` joined
[08:17] *** pmurias joined
[08:20] <El_Che> lizmat: you found an antagonist on perlmonks it seems

[08:21] *** faraco joined
[08:21] *** faraco left
[08:21] *** faraco joined
[08:21] *** subroot joined
[08:22] <ecocode> some software devs are reluctant to change ;)

[08:22] <El_Che> this one was rather vexed from somethong of 15y ago

[08:23] * faraco o/

[08:23] <lookatme> :)

[08:29] *** pmurias left
[08:29] *** pmurias joined
[08:36] *** faraco left
[08:48] *** wamba joined
[08:53] *** Woodi joined
[08:53] *** sarna joined
[08:55] *** subroot left
[08:55] <lizmat> El_Che: oddly enough, I didn't recall him being vexed 15 years ago

[08:58] <sarna> o/

[09:00] <lizmat> I only see a reaction from said person in 2008

[09:02] *** jameslenz joined
[09:03] <sarna> tyil: the link to GTK::Simple on your application programming tutorial 404s :)

[09:06] *** jameslenz left
[09:11] <El_Che> lizmat: I understand someone not agreeing with you, ar finding your argument false, but there is no discussion there. He's just venting/trolling

[09:12] <xq> thanks for that link

[09:14] <lizmat> El_Che: yeah, unfortunately  :-(

[09:17] *** mscha joined
[09:18] <mscha> p6: my $t = time; (1..25).race.map({ sleep 0.1 }); say time - $t;

[09:18] <camelia> rakudo-moar dd0cea31a: OUTPUT: «3␤»

[09:18] <mscha> p6: my $t = now; (1..25).race.map({ sleep 0.1 }); say now - $t;

[09:18] <camelia> rakudo-moar dd0cea31a: OUTPUT: «2.55431795␤»

[09:18] <mscha> Do race/hyper actually do something yet?  It seems not...

[09:19] *** pmurias left
[09:20] *** pmurias joined
[09:20] <moritz> m: my $t = time; (1..25).map({ sleep 0.1 }); say time - $t;

[09:20] <camelia> rakudo-moar dd0cea31a: OUTPUT: «2␤»

[09:20] <moritz> m: my $t = time; (1..25).race(jobs => 8).map({ sleep 0.1 }); say time - $t;

[09:20] <camelia> rakudo-moar dd0cea31a: OUTPUT: «2␤»

[09:21] <jnthn> p6: my $t = now; (1..25).race(:batch(1)).map({ sleep 0.1 }); say now - $t;

[09:21] <camelia> rakudo-moar dd0cea31a: OUTPUT: «0.73301941␤»

[09:21] <jnthn> The default batch size is 64 items

[09:21] <mscha> Ah, that explains it, thanks jnthn.  :-)

[09:21] <moritz> and you can't win chosing a smaller default, because then fast-ish maps become really slow due to the overhead

[09:23] <mscha> m: my $t = now; (^128).hyper.map({ sleep 0.01 }); say now - $t;

[09:23] <camelia> rakudo-moar dd0cea31a: OUTPUT: «0.73068783␤»

[09:23] <mscha> m: my $t = now; (^128).map({ sleep 0.01 }); say now - $t;

[09:23] <camelia> rakudo-moar dd0cea31a: OUTPUT: «1.32154434␤»

[09:23] <mscha> yup.  :-)

[09:23] *** sena_kun joined
[09:23] <tyil> sarna: I'll update it right away, thanks for notifying

[09:24] <sarna> tyil: no prob :) just letting you know

[09:24] <sarna> tyil: I've tried sending your tutorial to a friend and your website was offline yesterday :D

[09:24] <sarna> I'm glad it's back online, it's my cheatscheet for new projects

[09:24] <tyil> hmm, I didn't do much yesterday, other than the rss/atom feed

[09:25] <tyil> how's the more lightweight design? :.

[09:25] <tyil> :p

[09:25] <sarna> yesterday evening, I was getting nginx errors

[09:25] <sarna> I like it :)

[09:26] <tyil> if you have any ideas for tutorials, let me know

[09:26] <tyil> or hope that TPF approves my grant, then you'll get a whole book

[09:26] <sarna> woo!

[09:26] <sarna> please do http://norvig.com/lispy.html but better

[09:27] <tyil> heh

[09:27] <tyil> that could be interesting

[09:27] <tyil> I'll read through that and see if I can redo it in a timely manner in Perl 6 :>

[09:28] <sarna> I've tried :) it's pretty straightforward, but I ran out of steam

[09:29] <sarna> I think it'd be fun to implement some additional features

[09:29] <sarna> "look how easy it is in perl6!"

[09:30] <tyil> everything is easy to Perl 6 from my (limited) experience

[09:30] <tyil> and if it's not easy, I complain here 

[09:31] *** xtreak joined
[09:32] <sarna> "make the easy things easy and the hard things possible" :D

[09:33] <mscha> m: my $t = now; say +(^10_000).grep(&is-prime); say now - $t;

[09:33] <camelia> rakudo-moar dd0cea31a: OUTPUT: «1229␤1.5468864␤»

[09:33] <mscha> m: my $t = now; say +(^10_000).race.grep(&is-prime); say now - $t;

[09:33] <camelia> rakudo-moar dd0cea31a: OUTPUT: «1229␤0.6871809␤»

[09:37] <moritz> m: my $t = now; say +(^10_000).race(:batch(500)).grep(&is-prime); say now - $t

[09:37] <camelia> rakudo-moar dd0cea31a: OUTPUT: «1229␤0.64363365␤»

[09:38] <moritz> m: my $t = now; say +(^10_000).race(:batch(500), :jobs(8)).grep(&is-prime); say now - $t

[09:38] <camelia> rakudo-moar dd0cea31a: OUTPUT: «1229␤0.55715299␤»

[09:43] <sarna> does perl6 have a preference about bracing style?

[09:47] <lizmat> TIMTOWTDI  :-)

[09:47] <lizmat> Different Perl 6 books use different styles

[09:47] <lizmat> so I'd so, no, perl6 does not have a preference

[09:48] <lizmat> except for syntactical correctness

[09:48] <lizmat> which means in general, you *must* have whitespace before the opening {

[09:48] <sarna> ha! great :D

[09:51] <tbrowder_> hi, #perl6

[09:52] *** zakharyas joined
[09:53] <tyil> hi

[09:53] <tyil> sarna: even me and my gf have vastly different ways of writing our perl 6 programs

[09:54] <tyil> just write it in a way that makes you work best with it

[09:54] <tyil> when you're in a team, you might want to have some guidelines, to make it look consistent across the project, though

[09:54] <sarna> tyil: yeah, consistency is important

[09:55] <tbrowder_> my doc PR #2177 needs a look (and votes welcome) before a possible merge. it implements the Phase 2 doc Language listing reorg discussed in the doc wiki. AlexDaniel is not excited about it but i am. please review if you can and ask questions if something doesn’t make sense.

[09:55] <tbrowder_> tyil: hi

[09:56] <tyil> hi :>

[09:56] <tbrowder_> i am making progress on the proper handling of the =defn block

[09:57] <tyil> nice :>

[09:57] <tyil> do you think it will be able to get into this month's rakudo star?

[09:57] <tbrowder_> the grammar around it is somewhat ugly

[09:58] <tbrowder_> when is the star release cutoff?

[09:59] <tyil> AlexDaniel: would you know when the exact date is ^

[10:00] <AlexDaniel> most likely won't make it into the release

[10:00] <AlexDaniel> thing is that jnthn++ did a lot of nice work for perf improvements

[10:01] <AlexDaniel> but we saw some bugs appear because of that

[10:01] <AlexDaniel> see this ticket: https://github.com/rakudo/rakudo/issues/2047

[10:01] <AlexDaniel> now, we haven't fully decided *yet*, but it looks like the upcoming release will not include these changes

[10:02] <AlexDaniel> so that we can test them a bit more in the upcoming month

[10:02] <AlexDaniel> and that means that the release will be cut from a commit few weeks ago

[10:02] <tyil> ah

[10:02] <tyil> tbrowder_: in that case, no hurry :p

[10:02] <AlexDaniel> + some manually cherry-picked changes, if we find anything really important

[10:03] <Geth> ¦ doc: 320b82aeaf | (Elizabeth Mattijsen)++ | doc/Language/list.pod6

[10:03] <Geth> ¦ doc: Rwerite the "Testing for Elements" section

[10:03] <Geth> ¦ doc: 

[10:03] <Geth> ¦ doc: It assumed that you have to convert something to a Set before being able

[10:03] <Geth> ¦ doc: to use a set operator on it.  This is not true: set operators will take

[10:03] <synopsebot> Link: https://doc.perl6.org/language/list

[10:03] <Geth> ¦ doc: care of conversion when needed.  In the shown example, it was actually

[10:03] <Geth> ¦ doc: detrimental to first convert to a Set, because the (elem) operator can

[10:03] <Geth> ¦ doc: short-circuit whenever it finds a match, so it won't have to examine all

[10:03] <Geth> ¦ doc: <…commit message has 6 more lines…>

[10:03] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/320b82aeaf

[10:04] <sarna> I'd just like to say I'm thankful for all the work on Rakudo and stuff o/

[10:05] <AlexDaniel> samcv: btw we'll have to discuss this tomorrow-ish ↑

[10:07] <samcv> ok, now (maybe) works for me if it works for you

[10:08] <Geth> ¦ doc: ea2a05b8d8 | (Elizabeth Mattijsen)++ | doc/Language/list.pod6

[10:08] <Geth> ¦ doc: Duh, it's using the infix === , not infix =:=

[10:08] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/ea2a05b8d8

[10:08] <synopsebot> Link: https://doc.perl6.org/language/list

[10:13] *** robertle joined
[10:13] <AlexDaniel> samcv: well, I think jnthn also wanted to look at current blockers and stuff

[10:13] <samcv> ah ok

[10:14] <AlexDaniel> previous discussion: http://colabti.org/irclogger/irclogger_log/moarvm?date=2018-07-16#l328

[10:14] *** mscha left
[10:21] *** wamba1 joined
[10:23] *** wamba left
[10:24] <Ulti> < lizmat> Different Perl 6 books use different styles  <--- sure and at least one of those was universally disliked by anyone who was vociferous about something that pointless, Allman or K&R style pick one is not the worst advice...

[10:24] <tyil> sarna: are you going to the Perl Conference or Perl workshops? 

[10:25] <tyil> Ulti: which style was universally disliked? :o

[10:26] <lizmat> Ulti: I'm well aware of those feelings

[10:26] <Ulti> the easiest is to just look at what people are using in the ecosystem if you genuinely care about picking one

[10:26] <sarna> tyil: I'm currently in Denmark, haven't heard about any

[10:26] <tyil> ah

[10:27] <tyil> there's a conference in Glasgow next month, if that's doable for you

[10:27] <tyil> I don't know about other Perl 6 events that would be closer to you, sadly

[10:28] <Ulti> tyil: I believe it was a variant of Ratliff

[10:28] <Ulti> https://en.wikipedia.org/wiki/Indentation_style#Ratliff_style

[10:28] <tyil> oh

[10:28] <sarna> tyil: unfortunately no, I'm a poor uni student :D

[10:28] <Ulti> this sort of stuff is kind of weird it feels like psychology could probably measure which is actually "the best"

[10:28] <tyil> I've seen people use it, but I can admit I'm not too fond of that style either, Ulti :p

[10:28] <sarna> maybe I'll try to convince my colleagues to use perl6 and we'll organise something, who knows

[10:29] <tyil> sarna: I recently lost my job, so it's struggling for me as well to find the means to attend, but I do want to go there

[10:29] <Ulti> I think it only matters if you are used to a given style to the point you rapidly parse it visually

[10:29] <Ulti> in many ways Ratliff would make switching from P6 to Python simpler if you got used to it

[10:30] <Ulti> which is a definite bonus I can see and fits the concept of the braces exist to demark the end of a block, I can see the logic of it... I just cant quickly look at it is the only problem which is personal to me

[10:31] <Geth> ¦ doc: 5e73790ee6 | (Elizabeth Mattijsen)++ | doc/Language/operators.pod6

[10:31] <Geth> ¦ doc: Elaborate a bit about ===

[10:31] <Geth> ¦ doc: 

[10:31] <Geth> ¦ doc: - show that it disregards containers

[10:31] <Geth> ¦ doc: - put in link to ValueObjAt to create custom .WHICH methods

[10:31] <synopsebot> Link: https://doc.perl6.org/language/operators

[10:31] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/5e73790ee6

[10:32] <tyil> Ulti: I'd guess using a K&R-like style would work best, since that's what seems to be the standard used by many other books

[10:32] <tyil> but in the end, it all depends on what an individual likes best

[10:32] <tyil> it's impossible to make a book (or other article) that caters to everyone

[10:33] <Ulti> tyil: sure but even then the real zealots start to get into if you cuddle an } else {

[10:33] <Ulti> this is the sort of stuff thats seriously down in the weeds of importance

[10:36] <Ulti> I think I probably have an inconsistent use of cuddling too, if its a single if and else I will cuddle, if its a chain of elsif I will keep them all uncuddled for clarity and easy cut and paste movement

[10:37] <Ulti> which if you think about it is a good argument for never having cuddles

[10:37] <tyil> I tend to not use an elsif when possible

[10:37] <tyil> given/when looks cleaner imo when you have many cases

[10:38] <lizmat> tyil: but you can cuddle when's just as much

[10:38] <tyil> w-why

[10:38] <Ulti> whens you cuddle

[10:38] <lizmat> not saying that you should

[10:38] <tyil> I cuddle my } else {, if I have one

[10:38] <tyil> but generally I try to avoid those altogether

[10:39] <lizmat> } when {  :-)

[10:39] <tyil> no!

[10:40] <lizmat> :)

[10:40] <Ulti> the worst would be cuddling your phasers

[10:41] <lizmat> .oO( don't cross the streams! )

[10:41] <Ulti> this is really why I think programming at the developer level should be much more symbolic rather than about crafting text files

[10:42] <Ulti> there's no reason you couldn't render Perl 6 exactly like Python style white space and negotiate that with saving to file

[10:42] <Ulti> then all these really stupid arguments go away

[10:44] <tyil> wouldn't it be possible to use a slang to basically apply python style to a perl 6 program

[10:44] <Ulti> you would probably have to still allow braces for blocks otherwise you will lose a lot of expressivity 

[10:45] *** psychoslave joined
[10:45] <Ulti> but yeah Tux has his own Slang to just allow a single white space difference >:D

[10:46] <Ulti> https://github.com/FROGGS/p6-Slang-Tuxic

[10:46] <lizmat> Tux is very specific: he actually proxies HTML pages to filter out fonts he doesn't like  :-)

[10:47] <Ulti> you can probably reuse the code in the Rakudo grammar for indent of here docs too

[10:48] <sarna> is there a syntax for multiple traits? like 'is (required, rw)' instead of 'is required is rw'

[10:48] <Ulti> then implement all of the Python standard library.... and you have Python 4.0

[10:48] *** cognominal joined
[10:49] <jnthn> sarna: No

[10:49] <lizmat> sarna: no there isn't, afaik

[10:49] <sarna> :(

[10:49] <jnthn> "is" is a very short word :)

[10:49] <jnthn> m: say 'is (required, rw)'.chars

[10:49] <camelia> rakudo-moar dd0cea31a: OUTPUT: «17␤»

[10:49] <sarna> "repetition is bad" got burned into my brain, sorry

[10:49] <jnthn> m: say 'is required is rw'.chars

[10:49] <camelia> rakudo-moar dd0cea31a: OUTPUT: «17␤»

[10:49] <jnthn> It's not even shorter! :P

[10:50] <lizmat> sarna: also, if they get long, I tend to make it a multi-line, with "  is" at the start of each line

[10:50] <tyil> jnthn: but what if you could do is <required rw>

[10:50] <tyil> that will save you a character

[10:50] <jnthn> But traits aren't strings

[10:50] <tyil> not yet

[10:50] <sarna> lizmat: yep, that's what I do as well

[10:50] <tyil> that could be changed

[10:50] <jnthn> lol

[10:50] <jnthn> no

[10:50] <jnthn> Eww :)

[10:50] <Ulti> ^ needs more o's

[10:51] <jnthn> In the early says of Perl 6 implementation, on Parrot, various things - including types - we represented as strings. That was "fun" 

[10:51] <jnthn> *early days

[10:52] <tyil> if everything is a string

[10:52] <tyil> you'll have no conversion issues

[10:52] <jnthn> hah :)

[10:53] <Ulti> "fun"  <--- punned air quotes as a string?

[10:59] <Geth> ¦ modules.perl6.org: 71d4c79656 | (Zoffix Znet)++ (committed using GitHub Web editor) | lib/ModulesPerl6/DbBuilder/Dist/PostProcessor/p30METAChecker.pm

[10:59] <Geth> ¦ modules.perl6.org: Harden metachecker against undefs

[10:59] <Geth> ¦ modules.perl6.org: 

[10:59] <Geth> ¦ modules.perl6.org: Avoids immediate error causing 

[10:59] <Geth> ¦ modules.perl6.org: https://github.com/perl6/modules.perl6.org/issues/108

[10:59] <Geth> ¦ modules.perl6.org: review: https://github.com/perl6/modules.perl6.org/commit/71d4c79656

[10:59] *** stmuk joined
[11:02] *** jameslenz joined
[11:04] *** dakkar joined
[11:06] *** jameslenz left
[11:09] <sarna> how to say an array has to have, for example, seven ints? arr[7] and arr[Int], but how to connect those

[11:11] <timotimo> i think you want "my Int @arr[7]"

[11:11] <sarna> got it! my Int @arr[7] or my @arr[7] of int

[11:11] <sarna> yeah :D

[11:11] *** Ven` left
[11:11] <timotimo> shaped arrays are a little bit wonky in some respects, but really only if they have more than one dimension i think

[11:13] <sarna> `@arr[6;6] of Int` works just as well as his one-dimensional brother

[11:17] <lizmat> timotimo: I think I covered dimensions 1..3 pretty well, above that, it gets a bit wonky indeed  :-)

[11:18] <timotimo> unless you hit "partially dimensioned views NYI"

[11:18] <lizmat> ah, yes

[11:20] <Geth> ¦ doc: 208213bdb1 | (Elizabeth Mattijsen)++ | 2 files

[11:20] <Geth> ¦ doc: Document ValueObjAt

[11:20] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/208213bdb1

[11:27] <Geth> ¦ doc: a5899670b4 | (Elizabeth Mattijsen)++ | doc/Type/List.pod6

[11:27] <Geth> ¦ doc: Document my int @a; @a.sum(:wrap)

[11:27] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/a5899670b4

[11:27] <synopsebot> Link: https://doc.perl6.org/type/List

[11:30] <Geth> ¦ doc: e57e45852c | (Elizabeth Mattijsen)++ | doc/Type/ValueObjAt.pod6

[11:30] <Geth> ¦ doc: Adhere to the way we document actual output

[11:30] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/e57e45852c

[11:30] <synopsebot> Link: https://doc.perl6.org/type/ValueObjAt

[11:52] <pmurias> Ulti: re developement being more symbolic, making people switch editors is a gigantic barrier to programming language adoption

[11:55] <sarna> hey, how to access a private array from a class? self.arr doesn't work, even from inside the class

[11:56] <sarna> oh well, it's just `@!arr`, weird

[11:57] <lizmat> sarna: yeah, attributes inside a class can always be accessed with sigil ~ ! ~ name

[11:58] <lizmat> the @ sigil just means it needs to get something Positional:

[11:58] <lizmat> m: my @a := "foo" but Positional; dd @a; dd @a.WHAT

[11:58] <camelia> rakudo-moar 20b1756a7: OUTPUT: «"foo"␤Str+{Positional}␤»

[11:59] <lizmat> m: my @a := "foo"

[11:59] <camelia> rakudo-moar 20b1756a7: OUTPUT: «Type check failed in binding; expected Positional but got Str ("foo")␤  in block <unit> at <tmp> line 1␤␤»

[12:00] *** Ven` joined
[12:06] <kanbas> hey, is there any way to see if coercion to an enum failed? Currently I have enum Stuff( foo => 25, bar => 30 ), and I want to return True for e.g. Stuff(25) and false for e.g. Stuff(40)

[12:07] <kanbas> Stuff(40) is still of type Stuff and Mu, so I can't check with ~~ Stuff or ~~ Mu, and .HOW is also EnumHOW

[12:08] <lizmat> kanbas: enums are compile time, and I assume "40" is just an example of a runtime value, right ?

[12:08] *** markoong joined
[12:09] <kanbas> lizmat: yeah - I need to take some values and check if they would be valid as enums, but wondered if there was a better way than keeping a map of the Enum collection and looking the value up in it

[12:09] <lizmat> so you want to map numeric values to True/False ?

[12:09] <kanbas> Nah, I need to map keywords to numeric values and detect if an incoming Int would be a valid keyword

[12:10] <kanbas> i'm trying to write a telnet state machine atm, and using enums for the control codes

[12:13] <lizmat> so in fact you're mapping Ints to strings ?

[12:13] <lizmat> (or enums as that may be)

[12:14] <kanbas> yeah, though the current implementation is mapping strings to ints

[12:15] <kanbas> ideally i just want to be able to either lookup the string via the int, or the int via the string

[12:15] *** eliasr joined
[12:15] <kanbas> (well, it could do with doing both rather than one or the other)

[12:17] <lizmat> perhaps just 2 Maps would be best:

[12:17] <lizmat> m: my %f is Map = foo => 25, bar => 42; my %g is Map = %f.invert; dd %f, %g

[12:17] <camelia> rakudo-moar 20b1756a7: OUTPUT: «Map.new((:bar(42),:foo(25)))␤Map.new(("25" => "foo","42" => "bar"))␤»

[12:18] <lizmat> first one is by name, second one by integer value ?

[12:18] <kanbas> TIL Map.invert. Yeah that looks like it'd be perfect tbf. Thanks

[12:20] *** sarna left
[12:25] <Geth> ¦ whateverable: 465332e8e8 | (Aleks-Daniel Jakimenko-Aleksejev)++ | bin/Releasable.p6

[12:25] <Geth> ¦ whateverable: Link to rakudo wiki

[12:25] <Geth> ¦ whateverable: review: https://github.com/perl6/whateverable/commit/465332e8e8

[12:25] <Geth> ¦ whateverable: aeed5c233e | (Aleks-Daniel Jakimenko-Aleksejev)++ | config-default.json

[12:25] <Geth> ¦ whateverable: Spam every 20 hours by default

[12:25] <Geth> ¦ whateverable: 

[12:25] <Geth> ¦ whateverable: So that it shifts a bit every day to cover all timezones.

[12:26] <Geth> ¦ whateverable: review: https://github.com/perl6/whateverable/commit/aeed5c233e

[12:26] <tobs> m: enum Stuff(foo => 25, bar => 30); say so Stuff(25):exists; say so Stuff(50):exists

[12:26] <camelia> rakudo-moar 20b1756a7: OUTPUT: «True␤False␤»

[12:27] *** releasable6 joined
[12:27] *** ChanServ sets mode: +v releasable6

[12:34] <lizmat> tobs: TIL that works  :-)

[12:35] <lizmat> m: enum Stuff(foo => 25, bar => 30); say Stuff(25):exists; say Stuff(50):exists

[12:35] <camelia> rakudo-moar b6cc7168a: OUTPUT: «foo␤(Stuff)␤»

[12:35] <lizmat> hmmm... that feels wrong

[12:35] <lizmat> m: enum Stuff(foo => 25, bar => 30); say Stuff(25); say Stuff(50)

[12:35] <camelia> rakudo-moar b6cc7168a: OUTPUT: «foo␤(Stuff)␤»

[12:35] *** sena_kun left
[12:35] <lizmat> the :exists isn't necessary at all

[12:35] *** sena_kun joined
[12:35] <timotimo> m: enum Stuff(foo => 25); say Stuff(50):lolwhat

[12:35] <camelia> rakudo-moar b6cc7168a: OUTPUT: «(Stuff)␤»

[12:35] <lizmat> TIL that doesn't work, at least not for the reason you think

[12:36] <timotimo> it just ignores it

[12:36] <lizmat> yup

[12:36] <lizmat> however, you could use that with "with"

[12:36] <timotimo> yeah

[12:37] <lizmat> m: enum Stuff(foo => 25, bar => 30); with Stuff(25) { .say }; with Stuff(50 { die }  # doesn't die

[12:37] <camelia> rakudo-moar b6cc7168a: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Unable to parse expression in argument list; couldn't find final ')' (corresponding starter was at line 1)␤at <tmp>:1␤------> 3; with Stuff(25) { .say }; with Stuff(507⏏5 { die }  # doesn't die…»

[12:37] <kanbas> tobs: oh neat, ty also

[12:37] <lizmat> m: enum Stuff(foo => 25, bar => 30); with Stuff(25) { .say }; with Stuff(50) { die }  # doesn't die

[12:37] <camelia> rakudo-moar b6cc7168a: OUTPUT: «foo␤»

[12:38] <lizmat> m: enum Stuff(foo => 25, bar => 30); with Stuff(25) { .say }; without Stuff(50) { say "doesn't exist" }

[12:38] <camelia> rakudo-moar b6cc7168a: OUTPUT: «foo␤doesn't exist␤»

[12:39] <tobs>  m: enum Stuff(foo => 25, bar => 30); say so Stuff(25); say so Stuff(50)

[12:39] <camelia> rakudo-moar b6cc7168a: OUTPUT: «True␤False␤»

[12:39] <tobs> I see, lizmat++

[12:40] <AlexDaniel> FWIW we're currently at 50 tickets with testneeded tag

[12:40] <AlexDaniel> some of them are easy, others maybe not

[12:40] <AlexDaniel> but if anyone is looking for a way to help, perhaps that's a good start :)

[12:41] <AlexDaniel> https://github.com/rakudo/rakudo/issues?q=is%3Aissue+is%3Aopen+label%3Atestneeded

[12:41] <AlexDaniel> and https://fail.rakudo.party/t/TESTNEEDED

[12:41] <AlexDaniel> see also `easy to resolve` tickets: https://github.com/rakudo/rakudo/issues?q=is%3Aissue+is%3Aopen+label%3A%22easy+to+resolve%22

[12:43] *** xtreak left
[12:43] <Geth> ¦ doc: 4aaa191664 | (Zoffix Znet)++ (committed using GitHub Web editor) | doc/Type/IO/Handle.pod6

[12:43] <Geth> ¦ doc: Fix incorrect plurification

[12:43] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/4aaa191664

[12:43] <synopsebot> Link: https://doc.perl6.org/type/IO::Handle

[12:55] <Geth> ¦ marketing: 59df463292 | (Zoffix Znet)++ | 14 files

[12:55] <Geth> ¦ marketing: Add "Simple Handle" 6.d Teaser Flyer / ID 1531801752

[12:55] <Geth> ¦ marketing: review: https://github.com/perl6/marketing/commit/59df463292

[12:56] *** buggable joined
[12:56] *** ChanServ sets mode: +v buggable

[12:59] <Geth> ¦ doc: d6b162b2ff | (Elizabeth Mattijsen)++ | doc/Type/Attribute.pod6

[12:59] <Geth> ¦ doc: Document that "is required($reason)" is also possible

[12:59] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/d6b162b2ff

[12:59] <synopsebot> Link: https://doc.perl6.org/type/Attribute

[13:02] *** jameslenz joined
[13:03] *** Ven` left
[13:04] *** eythian joined
[13:04] *** eythian left
[13:04] *** eythian joined
[13:07] *** jameslenz left
[13:09] *** Ven` joined
[13:16] *** brrt joined
[13:25] *** skids joined
[13:41] *** molaf joined
[13:46] *** tbrowder_ joined
[13:47] *** HaraldJoerg1 joined
[13:55] *** uzl joined
[14:05] *** fake_space_whale joined
[14:06] <uzl> Hello to everybody!

[14:07] <timotimo> greetings uzl 

[14:10] <jkramer> Is there something in P6 that allows me to assign some value to nothing, like this:

[14:10] <jkramer> m: my @foo = <foo bar baz>; my ($a, _, $c) = @foo

[14:10] <camelia> rakudo-moar 7a7e5e96f: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Invalid typename '_' in parameter declaration.␤at <tmp>:1␤------> 3my @foo = <foo bar baz>; my ($a, _7⏏5, $c) = @foo␤»

[14:10] <AlexDaniel> m: my @foo = <foo bar baz>; my ($a, $, $c) = @foo

[14:10] <camelia> rakudo-moar 7a7e5e96f: ( no output )

[14:11] <jkramer> Oh true. But that's an actual assignment, isn't that costly?

[14:11] <AlexDaniel> if it is costly, then file a ticket. Can be optimized away I'm pretty sure

[14:11] *** zakharyas left
[14:11] <jkramer> I mean $ is an actual variable, even though it's value is lost afterwards

[14:11] *** zakharyas joined
[14:12] <uzl> greetings timotimo!

[14:12] <timotimo> could be optimized out, jkramer. maybe it isn't yet, though

[14:14] <uzl> To anyone interested: I've translated Think Perl 6 to Spanish. As of now, I'm going over the translation and fixing typos (at least the one I can spot) and doing minor corrections.

[14:14] <uzl> Nonetheless, I think it'd benefit from some proofreading.

[14:14] <timotimo> RT #124822

[14:14] <synopsebot> RT#124822 [new]: https://rt.perl.org/Ticket/Display.html?id=124822 [CONC] S17-supply/stable.t line:14 reason: doesn't work or can't test

[14:14] <AlexDaniel> .tell jmerelo http://colabti.org/irclogger/irclogger_log/perl6?date=2018-07-17#l631

[14:14] <yoleaux> AlexDaniel: I'll pass your message to jmerelo.

[14:14] <timotimo> huh.

[14:15] <AlexDaniel> weekly: http://colabti.org/irclogger/irclogger_log/perl6?date=2018-07-17#l631

[14:15] <notable6> AlexDaniel, Noted!

[14:15] <uzl> Gitlab repo: https://gitlab.com/uzluisf/piensaperl6 

[14:15] <uzl> Book (simple) page: https://uzluisf.gitlab.io/piensaperl6/

[14:15] <El_Che>  Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License

[14:15] *** zakharyas left
[14:15] <El_Che> nice

[14:16] <AlexDaniel> is it? Kinda non-free if you can't sell

[14:16] <AlexDaniel> I mean in terms of available resources for perl6 that's indeed not bad :)

[14:17] <El_Che> it's not software, o'reilly will not get beter version when somene adapt it and sells it

[14:17] <AlexDaniel> timotimo, jkramer: I think it's not optimized currently

[14:18] <uzl> El_Che: It has the same license as Think Perl 6.

[14:18] <El_Che> uzl: yes, that's the license I was referring to

[14:19] <uzl> But I think any derived work from it must have the same license?

[14:19] <uzl> El_Che: Oh, got it!

[14:19] <El_Che> uzl: https://creativecommons.org/licenses/by-nc-sa/3.0/

[14:19] <El_Che> ShareAlike — If you remix, transform, or build upon the material, you must distribute your contributions under the same license as the original. 

[14:19] *** brrt left
[14:22] <uzl> My intended purpose ;)

[14:22] <El_Che> uzl++

[14:29] <uzl> AlexDaniel: No commercial plan behind it!

[14:30] <El_Che> uzl: as long as oreilly does not public the book in Spanish, you have a captive market :)

[14:33] <uzl> El_Che: just a community effort for Perl 6 to reach far and beyond...

[14:34] *** MilkmanDan joined
[14:34] <El_Che> good, very useful

[14:37] <uzl> Now I'm wondering if using one of those printing services (lulu, etc) fall under commercial. I guess it's not since all the money goes into printing it. 

[14:39] <jkramer> Hmpf, in some regards P6 is really painfully slow, to a point where it just can't be used for real-life applications. :(

[14:39] <jkramer> https://bpaste.net/raw/a14abeaf6bcc - this is running for 8 minutes already for a ~130M text file.

[14:40] <timotimo> jkramer: i believe .tail(*-2) is a whole lot faster than .[2..*]

[14:40] *** nemo joined
[14:41] <jkramer> And using 2G of RAM :D

[14:41] <jkramer> Thanks, I'll try

[14:41] <nemo> been a looong time since I've been here.  how do I ask the bot a question again?

[14:41] <nemo> I mean. a snippet

[14:41] <nemo> camelia that is

[14:41] <timotimo> just m: the code

[14:41] <jkramer> Is .head also faster than .[0] maybe?

[14:41] <nemo> m: 729**⅓

[14:41] <camelia> rakudo-moar 7a7e5e96f: OUTPUT: «WARNINGS for <tmp>:␤Useless use of "**" in expression "729**⅓" in sink context (line 1)␤»

[14:41] <nemo> O_o

[14:42] <nemo> m: print 729**⅓

[14:42] <camelia> rakudo-moar 7a7e5e96f: OUTPUT: «8.999999999999998»

[14:42] <timotimo> oh, you have to explicitly "say" things

[14:42] <timotimo> or print, yes

[14:42] <nemo> hm

[14:42] <timotimo> jkramer: should be

[14:42] <nemo> ok. so. if I ask our haskell bot pow(729,1/3)

[14:42] <nemo> it returns 9 😝

[14:42] <nemo> so does calculator

[14:42] <nemo> what is nqp/camelia/rakudo doing?

[14:42] <nemo> gnome-calculator etc

[14:42] <timotimo> floating point calculations

[14:43] <nemo> well obv 😉

[14:43] <timotimo> rakudo just outputs it precisely

[14:43] *** Zoffix joined
[14:43] <nemo> hm

[14:43] <timotimo> can you check if the result == 9 or not?

[14:43] <nemo> timotimo: so you think the others are just rounding their fp eh

[14:43] <Zoffix> jkramer: what's some sample data you're feeding it with?

[14:43] <lizmat> m: my @a = ^10; @a[0] for ^10000; say now - INIT now

[14:43] <camelia> rakudo-moar 7a7e5e96f: OUTPUT: «0.00898764␤»

[14:43] <Zoffix> m: say 729 ** ⅓

[14:43] <camelia> rakudo-moar 7a7e5e96f: OUTPUT: «8.999999999999998␤»

[14:44] <jkramer> Hmm if I use .head and .tail it complains about the Seq already being used up. No I don't know what's faster/slowing, using .[0] instead of .head or .cache on the Seq :)

[14:44] <nemo> our haskell bot says that 729**⅓ ==9

[14:44] <timotimo> that's good

[14:44] <nemo> well. pow(729,1/3)==9

[14:44] <lizmat> m: my @a = ^10; @a.head for ^10000; say now - INIT now

[14:44] <camelia> rakudo-moar 7a7e5e96f: OUTPUT: «0.03005977␤»

[14:44] <lizmat> that is weird

[14:44] <Zoffix> nemo: what about (-125)**⅓ ?

[14:44] <timotimo> oh, it's muhc slower?

[14:44] <jkramer> Zoffix: Just plain text, about 1-10 words per line, plus a line number in the beginning and a separator (the element that's skipped)

[14:45] <nemo> Zoffix: -5

[14:45] <nemo> m: say -125**⅓

[14:45] <camelia> rakudo-moar 7a7e5e96f: OUTPUT: «-4.999999999999999␤»

[14:45] <nemo> m: say -125**⅓==-5

[14:45] <camelia> rakudo-moar 7a7e5e96f: OUTPUT: «False␤»

[14:45] <lizmat> m: my @a = ^10; for ^1000000 { my $a = @a[0]; say now - INIT now

[14:45] <camelia> rakudo-moar 7a7e5e96f: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Missing block␤at <tmp>:1␤------> 030000 { my $a = @a[0]; say now - INIT now7⏏5<EOL>␤    expecting any of:␤        postfix␤        statement end␤        statement modifier␤        sta…»

[14:45] <lizmat> m: my @a = ^10; for ^1000000 { my $a = @a[0] }; say now - INIT now

[14:45] <camelia> rakudo-moar 7a7e5e96f: OUTPUT: «0.3849081␤»

[14:46] <lizmat> m: my @a = ^10; for ^1000000 { my $a = @a.head }; say now - INIT now

[14:46] <camelia> rakudo-moar 7a7e5e96f: OUTPUT: «1.4415858␤»

[14:46] <lizmat> jkramer: when done on an array, [0] is definitely faster

[14:46] <Zoffix> nemo: -125**⅓ is no the same as (-125)**⅓

[14:46] <Zoffix> m: say (-125)**⅓

[14:46] <Zoffix> e: say (-125)**⅓

[14:46] <Zoffix> lag :(

[14:46] <camelia> rakudo-moar 7a7e5e96f: OUTPUT: «NaN␤»

[14:46] <timotimo> but .words is a Seq

[14:46] <evalable6> Zoffix, rakudo-moar 7a7e5e96f: OUTPUT: «NaN␤»

[14:47] <Zoffix> jkramer: well, what's the actual data?

[14:47] <jkramer> lizmat: But is it still worth it with the overhead of turning Seq into an Array? :)

[14:47] <lizmat> no, probably not :-)

[14:47] <jkramer> Zoffix: https://filebin.net/za13pgx296tpfpo3

[14:47] <timotimo> cool

[14:48] <lizmat> m: my $a = "foo " x 1000; $a.words[0] for ^100000; say now - INIT now

[14:48] <camelia> rakudo-moar 7a7e5e96f: OUTPUT: «0.5005249␤»

[14:48] <lizmat> m: my $a = "foo " x 1000; $a.words.head for ^100000; say now - INIT now

[14:48] <camelia> rakudo-moar 7a7e5e96f: OUTPUT: «0.26912142␤»

[14:48] <nemo> Zoffix: heh. true. guess I need to wait to see what camelia's response is though

[14:49] <Zoffix> nemo: the response is a NaN

[14:49] <Zoffix> You need to force explicit complex to do powers with negative numbers, even if the power is an odd power

[14:49] <Zoffix> e: say (-125+0i)**⅓

[14:49] <evalable6> Zoffix, rakudo-moar 7a7e5e96f: OUTPUT: «2.500000000000001+4.330127018922194i␤»

[14:50] <Zoffix> huh

[14:50] <nemo> why would it be NAN?

[14:50] <nemo> Zoffix: -5*-5*-5 = -125

[14:50] <nemo> oh

[14:50] <nemo> weird

[14:50] <nemo> required even for odd eh

[14:51] <Zoffix> e: say (<125+1i>)**⅓

[14:51] <evalable6> Zoffix, rakudo-moar 7a7e5e96f: OUTPUT: «5.000035554712788+0.013333175313586194i␤»

[14:51] <Zoffix> weird

[14:51] <timotimo> jkramer: it doesn't seem like it can even get past the first line :)

[14:52] <timotimo> ah, the first thing it does is assign to spot number 2087584

[14:52] <Zoffix> jkramer: are you sure your logic is correct? Starting with the first 6 lines of the file I already get an array with 2087584 elements in it

[14:53] <Zoffix> jkramer: what's this program meant to do?

[14:53] <timotimo> it's supposed to put the words after the # in the nth spot, where n is the first field

[14:54] <timotimo> i forgot to put input.txt into stdin m)

[14:54] <timotimo> that's why i didn't get any progress, it was waiting for me to type something in

[14:54] <timotimo> i'm smart

[14:55] <Zoffix> That just describes what it's doing…

[14:55] *** HaraldJoerg1 is now known as HaraldJoerg

[14:56] <timotimo> by outputting the +@line at the end, you could also just put all the numbers into a set

[14:56] <jkramer> Zoffix: It's a coding challenge. :) The number is the line number (the file is supposed to be a "shuffled" book), so I'm trying to assign the lines to the correct spot in the array instead of reading it all and then sorting by line number to save some time.

[14:56] <timotimo> but i don't think that's the goal, just a benchmark

[14:57] *** ruoso joined
[14:57] <jkramer> The code I posted above is just the beginning, there's some more stuff to do with the input, once I manage to read it :)

[14:57] <timotimo> we spend a whole lot of time GC-marking the huge array

[14:58] <Zoffix> jkramer: if it's a coding challenge, perhaps it's part of the challenge that you need to come up with a fast algo and has nothing to do with "P6 is really painfully slow, to a point where it just can't be used for real-life applications"

[14:58] <nemo> Zoffix: BTW your NaN thing applies to javascript at least

[14:59] <nemo> Zoffix: no idea how to even include a negative component in javascript ☺

[14:59] <nemo> er imaginary component

[14:59] <Zoffix> nemo: it's posible the NaN thing comes from IEEE standard

[14:59] <jkramer> Zoffix: Sorry if that came across as a complaint or bashing, but reading a big file is not a very difficult task and the way I'm doing it is already the fastest way (alternative would be to read all lines, then sort it).

[15:00] <timotimo> honestly, it'd be faster to store byte offsets into the file in a native integer array ;)

[15:00] <fake_space_whale> have you considered using a hash instead of an array? (I don't know if it would be faster or not)

[15:00] <fake_space_whale> since that way you wouldn't need to claim as big chunks of memory

[15:01] <fake_space_whale> at first at least

[15:02] *** jameslenz joined
[15:03] <Zoffix> jkramer: except the reading of the file takes just 11 seconds

[15:03] <Zoffix> "can't be used for real-life applications" is a pretty bold claim

[15:03] <Zoffix> 7 seconds if you .lines a .slurp

[15:04] <timotimo> fake_space_whale: it would actually be faster since it won't have to parse the numbers into an integer

[15:04] <timotimo> but i'm not actually sure how much time it spends parsing, i just saw that it does

[15:05] <jkramer> Zoffix: But that's not what I said or meant. I can't use it for this specific task which I consider a "real-life" scenario.

[15:06] *** pmurias left
[15:06] <scovit> jkramer: this is much faster for me, https://gist.github.com/scovit/f162349b4ac93bab757c7b7bd693afac

[15:06] <buggable> New CPAN upload: Image-Libexif-0.0.2.tar.gz by FRITH http://modules.perl6.org/dist/Image::Libexif:cpan:FRITH

[15:06] *** pmurias joined
[15:07] *** jameslenz left
[15:07] <jkramer> scovit: Thanks, I'll try that

[15:07] <scovit> dunno if it helps.. I often resort to perl5 for these kind of works

[15:08] <nemo> Zoffix: I bet Haskell is doing exact cube root while perl6 and javascript are doing floating point approximations

[15:09] <Zoffix> nemo: what about (-1953125)**(1/9) does that give -5 in Haskel?

[15:09] <jkramer> scovit: I already implemented it in perl5, I justed wanted to do in Perl6 as well :)

[15:10] <nemo> Zoffix: it does yes

[15:10] <nemo> Zoffix: and ofc 0.33333333333333333333333333333333333333333333333333!=(1/3)  ☺

[15:10] <scovit> jkramer point is that perl6 is encoding all the strings in unicode

[15:10] <nemo> Zoffix: which is true in javascript

[15:10] <scovit> even if it is not, it still carries all the logic

[15:11] <nemo> m: say 0.333333333333333333333333333333333333333333333333333==⅓

[15:11] <camelia> rakudo-moar 7a7e5e96f: OUTPUT: «False␤»

[15:11] <nemo> interesting!

[15:11] <nemo> well score one for camelia

[15:11] <Zoffix> m: say 0.33333333333333333333333333333333333333333333333333 ≠ ⅓

[15:11] <camelia> rakudo-moar 7a7e5e96f: OUTPUT: «True␤»

[15:11] <Zoffix> nemo: yeah, because in P6 that's a Rational number, but in JS it's a float, innit?

[15:11] <Zoffix> double

[15:11] *** pmurias left
[15:11] <Zoffix> not-rational

[15:12] <nemo> Zoffix: oh. ok. well that would explain why Math.pow(-125,1/3) fails in javascript but not perl6 then

[15:12] <Zoffix> Well, it does "fail". It gives you NaN

[15:12] <jkramer> scovit: Yours took about 2.5min on my machine, much better :)

[15:12] <nemo> Zoffix: but... odd that it does = -5 in perl6... if it is doing rationals

[15:12] <nemo> *doesn't*

[15:12] <nemo> m: say (-125)**⅓

[15:12] <camelia> rakudo-moar 7a7e5e96f: OUTPUT: «NaN␤»

[15:12] <Zoffix> nemo: the power op is just C's pow call

[15:12] <[Coke]> Folks - perlfoundation.org updated their website; please feel free to hit me up with any issues you find before it gets publicized more. Already known: YAPC not TPC, confusing YAPC::NA and YAPC north america links, donate button. hit me up with anything else.

[15:12] <nemo> oh oups. I thought that worked

[15:12] <nemo> doh

[15:13] <Zoffix> I think

[15:13] <nemo> m: say ⅓==1/3

[15:13] <camelia> rakudo-moar 7a7e5e96f: OUTPUT: «True␤»

[15:13] <nemo> oh good

[15:13] <Zoffix> s: &infix:<**>, \(-125, ⅓)

[15:13] <SourceBaby> Zoffix, Sauce is at https://github.com/rakudo/rakudo/blob/7a7e5e96f/src/core/Real.pm6#L147

[15:13] <scovit> jkramer happy it helps!

[15:14] <Zoffix> hmm

[15:14] <Zoffix> m: say (-125.0)**⅓

[15:14] <camelia> rakudo-moar 7a7e5e96f: OUTPUT: «NaN␤»

[15:14] <Zoffix> s: &infix:<**>, \(-125.0, ⅓)

[15:14] <SourceBaby> Zoffix, Sauce is at https://github.com/rakudo/rakudo/blob/7a7e5e96f/src/core/Real.pm6#L147

[15:15] <Zoffix> oh well

[15:16] *** uzl left
[15:16] <buggable> New CPAN upload: Desktop-Notify-0.3.4.tar.gz by FRITH http://modules.perl6.org/dist/Desktop::Notify:cpan:FRITH

[15:17] *** zakharyas joined
[15:18] <Zoffix> having trouble profiling jkramer's program

[15:18] <Zoffix> Got down to 400 entries and yet the profile is so huge, it kills my browser :/

[15:19] *** benjikun2 joined
[15:19] <Zoffix> At 285 entries it's empty :|

[15:20] <Zoffix> And at 145 entries, it's mostly red :/

[15:22] *** pmurias joined
[15:24] *** psychoslave left
[15:24] <timotimo> i wonder if the call graph gets bloated somehow

[15:25] <Zoffix> timotimo: looks like it. I managed to sit long enough to load a profile of doing a run over 365-line file. The call graph looks like a cardiogram lol: https://temp.perl6.party/out.html

[15:26] *** psychoslave joined
[15:26] <Zoffix> https://temp.perl6.party/z.png

[15:26] *** troys joined
[15:27] <timotimo> haha

[15:27] <timotimo> that is funny

[15:27] <timotimo> in my run it's got 2_704_613 nodes in the call graph

[15:27] <Zoffix> "There was no global deoptimization triggered by the profiled code. There was one global deoptimization triggered by the profiled code. There were 0 global deoptimization triggered by the profiled code."

[15:28] <Zoffix> lol wat? 0 and 1 and "no"?

[15:28] <timotimo> it's the bug that happens in some circumstances due to inlining

[15:28] *** zakharyas1 joined
[15:28] <timotimo> turn inlining off and the profile file should become tiny

[15:28] *** zakharyas left
[15:29] <Zoffix> timotimo: is there something wrong with the code that it made the callgraph look like that or is that just a deficiency in the profiler itself?

[15:29] <timotimo> it's a deficiency in the profiler part that lives in moarvm

[15:29] <Zoffix> ok

[15:29] <Zoffix> heh, it tells me <unit> took 2398076729582145.5ms to run :P

[15:29] <Zoffix> I'm older than I thought to have waited so long

[15:30] <timotimo> that's ... also a bug that annoys me

[15:31] <Geth> ¦ doc: coke assigned to lizmat Issue attribute example dies https://github.com/perl6/doc/issues/2184

[15:31] <Geth> ¦ doc: f8d9b441c8 | (Will "Coke" Coleda)++ | doc/Language/list.pod6

[15:31] <Geth> ¦ doc: fix example compilation

[15:31] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/f8d9b441c8

[15:31] <synopsebot> Link: https://doc.perl6.org/language/list

[15:32] *** raschipi joined
[15:32] *** psychoslave left
[15:34] <timotimo> postcircumfix:<[ ]> spends like a third(?) of its time in POSITIONS in that code

[15:34] *** pmurias left
[15:34] <timotimo> i imagine that's the 2..* part

[15:35] <Geth> ¦ doc: coke self-assigned attribute example dies https://github.com/perl6/doc/issues/2184

[15:35] *** pmurias joined
[15:36] <tbrowder_> [Coke]: site needs p6 logo and PERL6.ORG near PERL.ORG link

[15:37] <timotimo> push-exactly from Iterator.pm6 is on the top spot with 5.3%, and it's only jitted in small part

[15:37] <Zoffix> m: say 0.1150374/0.0808938

[15:37] <camelia> rakudo-moar 7a7e5e96f: OUTPUT: «1.4220793␤»

[15:38] <Zoffix> This version is about 42% faster than scovit's https://gist.github.com/zoffixznet/73f1cb0b0ae63e46de8fc14b8ae753f3

[15:39] <timotimo> oh i didn't see scovit suggest a change, let me scroll

[15:39] *** pmurias left
[15:39] <timotimo> ah, hypered the .words, eh?

[15:39] <Zoffix> Yeah

[15:40] <timotimo> i imagine that's a bit slower than the .words inside the for loop's body

[15:40] <Zoffix> yeah, like 

[15:40] <Zoffix> oh, yeah, I think that's where my speedup comes from

[15:40] <tbrowder_> [Coke]: would be nice to see EVENTS on the main top bar menu.

[15:41] <timotimo> i imagine it'd be most performant to only split the line in "before the separator" and "after the separator" and only lazily split the words off in the next step

[15:41] <timotimo> that way you have so many fewer long-lived objects on the heap

[15:42] <Zoffix> jkramer: how long does perl5's version take to run?

[15:44] <scovit> Zoffix I think that your version is faster because of Seq instead of List

[15:44] <timotimo> m: say 1000000 / 26

[15:44] <camelia> rakudo-moar 7a7e5e96f: OUTPUT: «38461.538462␤»

[15:44] <timotimo> 38.5k lines per second

[15:44] *** psychoslave joined
[15:44] <scovit> but it is surprising to me that the assignment in the for loop body leads to a .cache

[15:45] <Zoffix> scovit: @a = .words consumes the Seq and creates an Array

[15:45] <Zoffix> no cache

[15:46] <scovit> right

[15:46] <timotimo> my assumption it'd be faster with a hash was wrooooong

[15:46] <Zoffix> :)

[15:51] <timotimo> GC for arrays that are mostly null slots is extremely expensive

[15:52] *** wamba1 left
[15:55] *** pmurias joined
[15:55] <timotimo> if we knew that up front, we could switch to an implementation that tries to skip multiple slots at a time

[15:56] *** psychoslave left
[15:56] <Zoffix> What is it GCing tho? There's just one mostly-null-slot array in there, isn't there?

[15:56] <timotimo> yeah

[15:56] <timotimo> but it has to go through all 2 million or what slots

[15:56] <mienaikage> What's happening in the following? Switching to a block or using '==' works as expected. Does LHS not become the topic here?:

[15:56] <mienaikage> subset Tuesday of Date where *.day-of-week ~~ 2;

[15:56] *** brrt joined
[15:57] <Zoffix> timotimo: But why is it GCing it? It's one object that's living through the whole program?

[15:57] <timotimo> mienaikage: ~~ will make the RHS the topic of the LHS

[15:57] <Zoffix> mienaikage: the closure ends before the ~~

[15:57] <timotimo> Zoffix: check the difference between full and minor collections

[15:58] <timotimo> i have a profile here that looks like this: The profiled code did 5986 garbage collections. There were 9 full collections involving the entire heap.

[15:58] <timotimo> The average nursery collection time was 12.24ms. The average full collection time was 326.39ms.

[15:58] *** zakharyas1 left
[15:58] <timotimo> the trick is that the last gc run, number 5201, took 978ms

[15:58] <mienaikage> 👍

[15:59] <timotimo> number 3680 is 687.6ms

[16:00] <Zoffix> There's a doc issue for making info on whatevercodes clearer D#2017

[16:00] <synopsebot> D#2017 [open]: https://github.com/perl6/doc/issues/2017 [docs] Docs on Whatever curry could be clearer / don't cover everything

[16:00] <timotimo> but also the minor collections start at about 3ms, but end at about 19ms

[16:01] <Zoffix> You can also dump the QAST with --target=optimize and see the subset's matcher thunked your thing and it's basically a `{ *.day-of-week ~~ 2 }.ACCEPTS: $param's-value`: https://gist.github.com/zoffixznet/94af7dc1eb36cdda1317de5b556cde21

[16:01] <Zoffix> .oO( maybe this should warn... )

[16:02] <Zoffix> m: { *.so } # like we do here

[16:02] <camelia> rakudo-moar 7a7e5e96f: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Malformed double closure; WhateverCode is already a closure without curlies, so either remove the curlies or use valid parameter syntax instead of *␤at <tmp>:1␤------> 3{ *.so } # like we do here7…»

[16:03] *** brrt left
[16:04] <Zoffix> mienaikage: filed R#2086 for that

[16:04] <synopsebot> R#2086 [open]: https://github.com/rakudo/rakudo/issues/2086 [LTA][RFC] Maybe warn when thunking `*.foo ~~ $bar` constructs?

[16:05] *** Khisanth joined
[16:06] *** robertle left
[16:08] <jkramer> Zoffix: In total ~12sec, but that includes solving the actual challenge as well, not just reading and sorting lines into the array

[16:09] <Zoffix> Interesting. A mostly-nqp version of the code is a bit SLOWER than my last version above

[16:10] <Zoffix> for ~16K rows, the HLL version takes 0.5290986 and NQP one … oh, nm, they're the same… I think it was just noise, NQP is 0.52661446

[16:10] <Zoffix> This one: https://gist.github.com/zoffixznet/1670ac204a8f13a8eb2a3bf252eb94de

[16:11] <jkramer> I also have an implementation in rust (~5.5sec) and C (~1.1sec) :)

[16:11] <Zoffix> Which is awesome news, no? Means it's one of the cases where we *are* converting HLL version to basic bits that's NQP version

[16:11] <Zoffix> jkramer: is that 12 sec with full UTF8 encoding?

[16:13] * lizmat smells a blog post

[16:13] <jkramer> Zoffix: No, just https://bpaste.net/show/0e705b0135cf

[16:13] <Zoffix> mhm

[16:13] <jkramer> Oh actually that's a bit unfair because it doesn't split _all_ words

[16:13] <jkramer> No wait. It does, later in the code :)

[16:14] <Zoffix> That's one of the things that makes p6 version slower. You pay automatically for encoding and graphemes and all taht stuff

[16:14] <timotimo> it also doesn't - 1 on the $n

[16:15] <jkramer> timotimo: Yes but later when iterating over the sorted array it does a defined check on all rows. Actually I think removing that and doing the -1 instead would be faster

[16:15] <jkramer> I'm gonna try that

[16:15] <timotimo> i'll be afk for a bit

[16:17] *** Zoffix left
[16:17] <jkramer> No, didn't really change anything

[16:21] *** guest__ joined
[16:30] *** isacl joined
[16:31] *** scimon left
[16:34] *** wamba joined
[16:39] <tbrowder_> AlexDaniel: any objection to a doc merge if i use a different bar style row separator (thinner, but double-line)?

[16:39] *** dakkar left
[16:39] *** guest__ left
[16:48] <AlexDaniel> tbrowder_: uh… well… let's merge it and then modify to our liking…

[16:48] *** perlpilot joined
[16:56] <tbrowder_> ok, will do

[16:57] <Geth> ¦ doc/master: 7 commits pushed by (Tom Browder)++

[16:57] <Geth> ¦ doc/master: 3952836ddb | remove executable bit

[16:57] <Geth> ¦ doc/master: 04950bd363 | Auto-generate doc/Language/0-html-source pod6 target files

[16:57] <Geth> ¦ doc/master: c0458fb2b7 | remove spurious hyphen

[16:57] <Geth> ¦ doc/master: b2655723de | remove spurious hyphen

[16:57] <Geth> ¦ doc/master: 92013442cb | Merge branch 'phase2' of github.com:tbrowder/doc into phase2

[16:57] <Geth> ¦ doc/master: 289999efaa | add a new dir for travis

[16:57] <Geth> ¦ doc/master: 7afe426b83 | Merge pull request #2177 from tbrowder/phase2

[16:57] <Geth> ¦ doc/master: review: https://github.com/perl6/doc/compare/f8d9b441c82d...7afe426b839a

[17:01] *** donpdonp joined
[17:01] <donpdonp> whats the right way to give grep a block, this is my best non-funcitonal try: [1,2].grep {element == 2}  

[17:02] <timotimo> you need either a : after grep, or parenthesis around the block

[17:02] * donpdonp hmms

[17:02] <timotimo> because it's a method call

[17:02] <timotimo> sub calls take everything after themselves as arguments, method calls don't

[17:03] <donpdonp> what do I use for 'element'

[17:03] *** jameslenz joined
[17:03] <timotimo> oh

[17:03] <timotimo> $_ would be your candidate

[17:03] <timotimo> i mean, i'd probably have written it as a whatevercode, or with just the 2 instead of a block

[17:04] <timotimo> m: say "2" ~~ 2

[17:04] <camelia> rakudo-moar 7a7e5e96f: OUTPUT: «True␤»

[17:04] <timotimo> mhm mhm

[17:04] <donpdonp> interesting thx.

[17:04] <timotimo> because grep uses smartmatch

[17:04] <donpdonp> whats the significance of grep: {expr} over grep(expr)

[17:04] <timotimo> foo.grep: ... will take everything after it as arguments as well

[17:04] <raschipi> donpdonp: It's the same thing.

[17:05] <perlpilot> raschipi, not quite

[17:05] <timotimo> and you can't use : with grep if you use it as a sub

[17:05] <timotimo> grep: {expr} will be a label followed by a bare block

[17:05] <greppable6> timotimo, Found nothing!

[17:05] <timotimo> thank you greppable6 

[17:05] <timotimo> m: thissubdoesntevenexist: 1

[17:05] <camelia> rakudo-moar 7a7e5e96f: OUTPUT: «WARNINGS for <tmp>:␤Useless use of constant integer 1 in sink context (line 1)␤»

[17:05] <donpdonp> timotimo: great. thx.

[17:05] <raschipi> right, only works for methods.

[17:05] *** domidumont joined
[17:06] <raschipi> It's possible to call methods like they are subs using 'method Object: arg1, arg2' too. 

[17:07] *** jameslenz left
[17:10] <timotimo> yup, think of it like "new Foobar: 1, 2, 3"

[17:11] <[Coke]> timotimo: that's a label, no?

[17:13] <jkramer> Interestingly, reading the whole file first and then sorting the lines is faster than putting the lines into their slot directly :) my @input = lines.sort: { +.substr(0, .index(' ')) };

[17:13] <raschipi> It's indirect method call.

[17:13] <timotimo> [Coke]: no, only single identifiers in front of the : are labels

[17:13] <jkramer> This is about ~30s fast than scovit's approach from earlier today on my machine

[17:13] <jkramer> *er

[17:14] <timotimo> jkramer: that'll probably significantly cut down on GC time for all the empty slots that would otherwise be in the array early on

[17:17] <[Coke]> timotimo: thissubdoesntevenexist is a single identifier...

[17:18] <donpdonp> is there a way to say "use Cro::HTTP::Client as Client" so I can say "Client.get($url)" instead of "Cro::HTTP::Client.get($url)"

[17:18] <timotimo> const Client = Cro::HTTP::Client; should work

[17:18] <El_Che> make an object?

[17:19] <timotimo> [Coke]: oh, you meant that line. yes, that was an example of a label

[17:19] <[Coke]> perl6 --target==barf ... be nice if this told you what valid targets were.

[17:19] <raschipi> [Coke]: does it at least barfs though?

[17:25] <Geth> ¦ doc: 826c3b9e6f | (Aleks-Daniel Jakimenko-Aleksejev)++ | manage-page-order.p6

[17:25] <Geth> ¦ doc: Just say `Category` instead of annoying unicode art

[17:25] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/826c3b9e6f

[17:25] <[Coke]> yes, you get: Unknown compilation target '=barf'

[17:25] *** zakharyas joined
[17:25] <AlexDaniel> tbrowder_: so… let's talk about it a bit more…

[17:25] <[Coke]> but then a bunch of nqp stacktrace

[17:25] <AlexDaniel> tbrowder_: why can't we have a separate table for every category?

[17:25] <raschipi> So it's doing exactly what you asked for?

[17:27] <donpdonp> timotimo: where would be a good place to put that const in the .pm6? this is how not to do it: module { const Client = Cro::HTTP::client; sub go($url) { Client.get($url) }; 

[17:27] *** sarna joined
[17:27] <timotimo> you'll also need a "use", but other than that the position should be fine, as long as it's not an "our constant"

[17:27] <timotimo> constants are "my" scoped by default, right?

[17:27] <Geth> ¦ doc: 8cc0fde924 | (Aleks-Daniel Jakimenko-Aleksejev)++ | manage-page-order.p6

[17:27] <Geth> ¦ doc: Empty subtitle for categories

[17:27] <Geth> ¦ doc: 

[17:27] <Geth> ¦ doc: After thinking about it a bit more, no subtitle will make it more

[17:27] <Geth> ¦ doc: appealing visually. That's a temporary solution anyway.

[17:27] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/8cc0fde924

[17:27] <El_Che> my $client = Cro::HTTP::client.new; $client.get($url)

[17:28] <sarna> hey, so I have an object with a list of objects in it. how do I populate this list? I put a loop in BUILD() that creates objects, but it doesn't seem to work

[17:28] <donpdonp> El_Che: many sub's in the module will need Client, so im trying to put it at the module-level if thats possible

[17:28] <El_Che> donpdonp: I see

[17:29] <El_Che> is it OO? it could be an attribute

[17:29] <Geth> ¦ doc: 0d7b7c93a9 | (Rafael Schipiura)++ (committed using GitHub Web editor) | doc/Language/contexts.pod6

[17:29] <Geth> ¦ doc: Numeric context converts to numeric.

[17:29] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/0d7b7c93a9

[17:29] <synopsebot> Link: https://doc.perl6.org/language/contexts

[17:29] <tbrowder_> AlexDaniel: good idea for the next step.

[17:29] <donpdonp> timotimo: use Cro::HTTP::Client; module Commands { const Client = Cro::HTTP::Client; => Preceding context expects a term, but found infix = instead.

[17:30] <timotimo> oh?

[17:30] <perlpilot> donpdonp, except you'll want to spell "const" as "constant"   :)

[17:30] <timotimo> d'oh, yes, constant not const

[17:30] <timotimo> we can put a better error message for that in the parser!

[17:30] <donpdonp> ha thx perlpilot !

[17:30] <donpdonp> too much typescript i think.

[17:34] <raschipi> AlexDaniel tbrowder_ : Also, remove the bit about "mostly alphabetical order" at the top while you're at it.

[17:36] *** Xliff joined
[17:36] *** Xliff left
[17:40] *** Xliff joined
[17:40] <AlexDaniel> raschipi++

[17:40] <Geth> ¦ doc: 46a7470c01 | (Aleks-Daniel Jakimenko-Aleksejev)++ | htmlify.p6

[17:40] <Geth> ¦ doc: The list is no longer in alphabetical order

[17:40] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/46a7470c01

[17:43] <Xliff> \o

[17:43] <Xliff> <- New supporter of comma.

[17:43] <moritz> Xliff++

[17:44] <sena_kun> Xliff++

[17:46] <perlpilot> I like commas too  They go well between items  ;)

[17:47] <Geth> ¦ doc: a2336a5fe2 | (Zoffix Znet)++ (committed using GitHub Web editor) | doc/Type/Any.pod6

[17:47] <Geth> ¦ doc: Reword implementation-specific versioning of 6.d feature

[17:47] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/a2336a5fe2

[17:47] <synopsebot> Link: https://doc.perl6.org/type/Any

[17:48] <raschipi> But not periods.

[17:49] *** Zoffix joined
[17:49] <Zoffix> What's a really awesome example of .toggle's use? https://docs.perl6.org/routine/toggle

[17:49] <Xliff> Yeah. Does Comma come with any docs? I am trying to use it to debug p6 code.

[17:50] *** fbynite joined
[17:50] <timotimo> the debug support isn't quite fantastic yet

[17:50] <timotimo> https://commaide.com/docs - this is the odcs

[17:50] <tbrowder_> AlexDaniel: putting doc/Language categories alone on the language page with links to a separate page is good. Or we could have collapsible lists under the categories.

[17:52] <Zoffix> *crickets*

[17:52] <Xliff> m: ( (^10).toggle: * %% 2).say

[17:52] <camelia> rakudo-moar 7a7e5e96f: OUTPUT: «(0)␤»

[17:53] <tbrowder_> At any rate, for now I’m going to go back to working on pod =defn. Anyone is weclome to continue to move the docs toward your vision if they wish.

[17:53] <Xliff> m: ( (^10).toggle: * %% 2, :off, * > 8).say

[17:53] <camelia> rakudo-moar 7a7e5e96f: OUTPUT: «(0)␤»

[17:53] <perlpilot> Zoffix, maybe something with identifying a square wave out of some random data? (I clearly don't have any awesome examples)

[17:53] <Xliff> m: ( (^10).toggle: * %% 2,  * > 8).say

[17:53] <camelia> rakudo-moar 7a7e5e96f: OUTPUT: «(0 9)␤»

[17:53] <Xliff> m: ( (^10).toggle: * %% 2, :on, 7, * > 8).say

[17:53] <camelia> rakudo-moar 7a7e5e96f: OUTPUT: «No such method 'CALL-ME' for invocant of type 'Int'␤  in block <unit> at <tmp> line 1␤␤»

[17:53] <Zoffix> Xliff: so what does that do?

[17:53] <Xliff> m: ( (^10).toggle: * %% 2, :on, * == 7, * > 8).say

[17:53] <camelia> rakudo-moar 7a7e5e96f: OUTPUT: «(0 7)␤»

[17:54] <Xliff> Zoffix: I'm moving to camelia. Trying to figure it out.

[17:54] <Zoffix> heh

[17:54] <Zoffix> c'mon, it's a new feature in 6.d! It's meant to be awesome for something

[17:55] <perlpilot> Seems like an example that would be good for ff would also be good for .toggle  (but with extra behavior because of the callables)

[17:56] *** imcsk8_ joined
[17:57] <Zoffix> m: say ^10 .toggle: :off, * > 3, * < 8

[17:57] <camelia> rakudo-moar 7a7e5e96f: OUTPUT: «(4 5 6 7)␤»

[17:57] <Zoffix> m: say ^10 .grep: 3 < * < 8

[17:57] <camelia> rakudo-moar 7a7e5e96f: OUTPUT: «(4 5 6 7)␤»

[17:58] *** sarna left
[17:58] <Xliff> Yeah. The syntax of toggle is weird.

[17:58] <Xliff> Would be better if there was a clear indication of what is on and what is off

[17:58] <tyil> I reposted one of the reddit threads mentioned in the p6weekly to other subreddits, for those interested in a discussion: https://old.reddit.com/r/programming/comments/8zk5cy/what_are_some_features_new_to_perl_6_that_should/ and https://old.reddit.com/r/ProgrammingLanguages/comments/8zk5al/what_are_some_features_new_to_perl_6_that_should/

[17:59] <Geth> ¦ atom-language-perl6: threadless-screw++ created pull request #86:  Variable identifiers with embedded dashes/apostrophes highlight properly

[17:59] <Geth> ¦ atom-language-perl6: review: https://github.com/perl6/atom-language-perl6/pull/86

[17:59] <Zoffix> heh

[17:59] <Zoffix> visiting that URL killed my browser

[17:59] <Xliff> m: ( (^10).toggle: :on, * < 3, *.is-prime ).say

[17:59] <camelia> rakudo-moar 7a7e5e96f: OUTPUT: «(0 1 2 5 6 7 8 9)␤»

[17:59] <tyil> :(

[17:59] <Xliff> ^^ Not clear here as to what is going to show.

[18:00] <tyil> it shouldn't do that

[18:00] <Zoffix> Didn't get a chance to read the answer that started with "find relevance in modern programming language"

[18:00] <Xliff> 0, 1, 2 are there by the first condition. 4 is skipped by the *is-prime

[18:00] <Xliff> So why the 6, 7, 8, and 9?

[18:00] <Zoffix> Xliff: did you read the documentation for the method?

[18:00] <Xliff> Yeees.

[18:01] <perlpilot> you're missing an arg

[18:01] <Xliff> m: ( (^10).toggle: :on, * < 3, *.is-prime, :off ).say

[18:01] <camelia> rakudo-moar 7a7e5e96f: OUTPUT: «(0)␤»

[18:01] <perlpilot> I mean if you wanted is-prime to modulate the "on" values

[18:01] <Xliff> m: ( (^10).toggle: :on, * < 3, :on,*.is-prime, ).say

[18:01] <camelia> rakudo-moar 7a7e5e96f: OUTPUT: «(0 1 2 5 6 7 8 9)␤»

[18:02] <Xliff> Again. Docs aren't clear and neither is the syntax.

[18:02] <Zoffix> Xliff: :on is the default. It keeps producing els while first callable is true, that happens for 0, 1, 2, then it toggles and switches to the next callable in the list, which is *.is-prime, 5 makes that true, so it toggles again, and there are no other callables, so it remains on until the rest of the sequence, giving you 6, 7, 8, and 9

[18:03] <Xliff> I figured that out.

[18:03] <Zoffix> Xliff: there's no special syntax involved, so you using `:on` and `:off` named args in certain places has no effect on anything. They're unordered

[18:03] <Xliff> m: ( (^10).toggle: :on, * < 3, *.is-prime, *.is-prime ).say

[18:03] <camelia> rakudo-moar 7a7e5e96f: OUTPUT: «(0 1 2 5)␤»

[18:03] <Xliff> So why no 7?

[18:04] <Zoffix> Xliff: it toggles off on 6, and there are no more callables, in the list so it never switches back on

[18:04] <Zoffix> m: say ^10 .toggle: *.is-prime xx *

[18:04] <camelia> rakudo-moar 7a7e5e96f: OUTPUT: «(2 3 5 7)␤»

[18:04] <Zoffix> m: say ^100 .toggle: *.is-prime xx *

[18:04] <camelia> rakudo-moar 7a7e5e96f: OUTPUT: «(2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97)␤»

[18:04] <Zoffix> m: say ^100 .grep: *.is-prime

[18:04] <camelia> rakudo-moar 7a7e5e96f: OUTPUT: «(2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97)␤»

[18:04] <Xliff> m: ( (^10).toggle: :on, * < 3, *.is-prime xx 4 ).say

[18:04] <camelia> rakudo-moar 7a7e5e96f: OUTPUT: «(0 1 2 5 7)␤»

[18:04] <Xliff> m: ( (^100).toggle: :on, * < 3, *.is-prime xx 4 ).say

[18:04] <camelia> rakudo-moar 7a7e5e96f: OUTPUT: «(0 1 2 5 7)␤»

[18:05] <Zoffix> .ask lizmat do you remember what was the usecase for .toggle? I need something nice and awesome for a 6.d teaser poster

[18:05] <yoleaux> Zoffix: I'll pass your message to lizmat.

[18:05] <Xliff> ^^ That says to me that I should get the next 4 prime numbers.

[18:05] *** domidumont left
[18:05] <Xliff> m: ( (^100).toggle: :on, * < 3, *.is-prime xx 6 ).say

[18:05] <camelia> rakudo-moar 7a7e5e96f: OUTPUT: «(0 1 2 5 7 11)␤»

[18:06] <Xliff> ^^ You'd have to know where the next prime number is to get to 11

[18:06] *** domidumont joined
[18:06] <Zoffix> You'd just use .grep for that

[18:06] <Xliff> Well.... you asked for a cool use. I'm trying, here!

[18:07] <Xliff> Numbers less than 3, the next 4 prime numbers and numbers within a range.

[18:07] <Xliff> That would be a cool use of toggle. 

[18:07] <Xliff> m: ( (^100).toggle: * ~~ 10..30).say

[18:07] <camelia> rakudo-moar 7a7e5e96f: OUTPUT: «()␤»

[18:08] <Xliff> m: ( (^100).toggle: * < 10, * ~~ 10..30).say

[18:08] <camelia> rakudo-moar 7a7e5e96f: OUTPUT: «(0 1 2 3 4 5 6 7 8 9 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87…»

[18:08] <Xliff> m: ( (^100).toggle: * < 9, * ~~ 10..30).say

[18:08] <camelia> rakudo-moar 7a7e5e96f: OUTPUT: «(0 1 2 3 4 5 6 7 8 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 8…»

[18:09] <tyil> also, for what it's worth, the Den Bosch Linux User Group is now making use of Perl 6 on their mail server :>

[18:09] <Xliff> m: ( (^100).toggle: * < 9, * ~~ 10..30, &is-prime).say

[18:09] <camelia> rakudo-moar 7a7e5e96f: OUTPUT: «(0 1 2 3 4 5 6 7 8 10 11)␤»

[18:09] <Zoffix> Xliff: yeah, but that describes a grep condition.

[18:09] * Xliff throws hands up in the air.

[18:09] <Xliff> I guess I just don't grok the coolness, yet.

[18:10] <raschipi> You don't toggle the coolnesss. Yet.

[18:10] *** domidumont left
[18:11] *** donpdonp left
[18:11] <Xliff> A grep filter will do me just fine until I do.

[18:13] <perlpilot> Maybe in data processing where your conditions are something like "header lines match this pattern" and "data lines match this pattern" where you're given a sequence of lines where there's junk lines before/after the header/data lines

[18:14] <perlpilot> I dunno.  I can't imagine any neat examples for .toggle

[18:14] <Xliff> That sounds on the right track though, perlpilot 

[18:14] <AlexDaniel> yeah maybe something similar to stuff you'd use ff operator for: https://docs.perl6.org/routine/ff

[18:16] <Xliff> .toggle: *.is-header, ( (*.is-junk, *.is-data) xx 5 ).flat # Cover a header and 5 groupings of junk and data.

[18:17] <Zoffix> But again, that's a grep, not a toggle

[18:17] <Zoffix> m: say <a 42 b c d e 100 d> .toggle: :off, +*

[18:17] <perlpilot> yeah

[18:17] <camelia> rakudo-moar 7a7e5e96f: OUTPUT: «(42 b c d e 100 d)␤»

[18:18] <Zoffix> m: say gather for <a 42 b c d e 100 d> .lines { .take if 42 ff 100 }

[18:18] <camelia> rakudo-moar 7a7e5e96f: OUTPUT: «()␤»

[18:19] <Zoffix> .oO( does that docs example even work )

[18:19] <Zoffix> nope

[18:20] <Zoffix> yup (forgot to CTRL+S, I think)

[18:20] *** pmurias left
[18:21] <Zoffix> m: say gather for <a 42 b c d e 100 d> { .take if 42 ff 100 }

[18:21] <camelia> rakudo-moar 7a7e5e96f: OUTPUT: «(42 b c d e 100)␤»

[18:21] <Zoffix> m: say gather for <a 42 b c d e 100 d 100> { .take if 42 ff 100 }

[18:21] <camelia> rakudo-moar 7a7e5e96f: OUTPUT: «(42 b c d e 100)␤»

[18:22] *** zakharyas left
[18:22] <Zoffix> m: say <a 42 b c d e 100 d> .toggle: :off, * == 42, * == 100

[18:22] <camelia> rakudo-moar 7a7e5e96f: OUTPUT: «Cannot convert string to number: base-10 number must begin with valid digits or '.' in '3⏏5a' (indicated by ⏏)␤  in block <unit> at <tmp> line 1␤␤»

[18:22] <Zoffix> m: say <a 42 b c d e 100 d> .toggle: :off, {+$_ andthen $_ == 42}, {+$_ andthen $_ == 100}

[18:22] <camelia> rakudo-moar 7a7e5e96f: OUTPUT: «(42)␤»

[18:22] <Zoffix> m: say <a 42 b c d e 100 d> .toggle: {+$_ andthen $_ == 42}, {+$_ andthen $_ == 100}

[18:22] <camelia> rakudo-moar 7a7e5e96f: OUTPUT: «(100 d)␤»

[18:23] <perlpilot>  .toggle still makes me think of square waves and leading/trailing edges.

[18:23] <Zoffix> This kind of problems don't occur when devs document the stuff they implement, because they know why they're implementing

[18:24] <Zoffix> Instead of having some one else describe the behaviour of the implementation in the docs, rather than the purpose of the routine

[18:25] <SmokeMachine> Zoffix: is it cool? `ifconfig | perl6 -e 'say join "\n", lines.toggle: :off, * ~~ /^lo/, * ~~ /^\s+/'`

[18:26] <perlpilot> Zoffix, just look at the IRC logs from Nov 2017 and see what lizmat was thinking!  ;->

[18:26] <Zoffix> perlpilot: way ahead of you :)

[18:26] <Zoffix> The original names were skip-until and skip-while

[18:28] <TimToady> m: my %orig = :1a, :2b; my %new = :5b, :6c; %orig «=« %new; dd %orig

[18:28] <camelia> rakudo-moar 7a7e5e96f: OUTPUT: «Hash %orig = {:a(1), :b(5), :c(6)}␤»

[18:28] <TimToady> kjk: ^^^

[18:28] <Zoffix> SmokeMachine: I guess

[18:28] <Zoffix> I was expecting {/^eth1/}, {/^\s+/} to also work, 

[18:29] <Zoffix> m: my $c := {/^eth1/}; if $c("eth") {say 42 }

[18:29] <camelia> rakudo-moar 7a7e5e96f: ( no output )

[18:30] <Zoffix> Oh, I ran it with `perl`

[18:30] <Zoffix> $ perl -e 'my $c := {/^eth1/}; if $c("eth") {say 42 }'

[18:30] <Zoffix> Use of := for an empty attribute list is not allowed at -e line 1.

[18:30] <Zoffix> was gonna yell at it :}

[18:31] *** Xliff left
[18:31] <Zoffix> m: my $c := {?/^eth1/}; dd $c("eth")

[18:31] <camelia> rakudo-moar 7a7e5e96f: OUTPUT: «Bool::False␤»

[18:31] <Zoffix> m: my $c := {?/^eth1/}; dd $c("eth1")

[18:31] <camelia> rakudo-moar 7a7e5e96f: OUTPUT: «Bool::True␤»

[18:31] <Zoffix> oh

[18:31] <Zoffix> OK, now I get why {/^eth1/} doesn't work

[18:31] <Zoffix> SmokeMachine: the uncool part is * ~~ /^lo/ looks really gross :)

[18:32] <SmokeMachine> Zoffix: `*.starts-with("lo")` ?

[18:33] <Zoffix> I was thinking more of smartmatching

[18:33] <Zoffix> Like taking a bunch of matchers instead of just a bunch of callables

[18:33] <TimToady> kjk: Unless something has changed since I last looked at it, I suspect «=« is implemented key-by-key, but ,= is gonna do the stupid thing; one should try timing it both ways, of course

[18:33] <Zoffix> You could write it as .toggle: :off, /^lo/, /^\s/

[18:34] <SmokeMachine> Zoffix: why only `/^lo/` doesnt work? that have to be a Callable... why?

[18:34] <Geth> ¦ doc: d2a28d2c03 | (Clifton Wood)++ | doc/Language/nativecall.pod6

[18:34] <Geth> ¦ doc: - Fixes bad link in route page for nativecast.

[18:34] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/d2a28d2c03

[18:34] <Geth> ¦ doc: 43cbe0e463 | Altai-man++ (committed using GitHub Web editor) | doc/Language/nativecall.pod6

[18:34] <Geth> ¦ doc: Merge pull request #2180 from Xliff/master

[18:34] <Geth> ¦ doc: 

[18:34] <Geth> ¦ doc: - Fixes bad link in route page for nativecast.

[18:34] <synopsebot> Link: https://doc.perl6.org/language/nativecall

[18:34] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/43cbe0e463

[18:34] <SmokeMachine> Zoffix: that was my first try...

[18:34] <Zoffix> SmokeMachine: ifconfig | perl6 -e '/^eth1/ fff^ !/^\s+/ and .say for lines'

[18:34] <Zoffix> :)

[18:35] <Zoffix> SmokeMachine: why it has to be a Callable? Dunno, it was designed that way, I guess

[18:35] <Zoffix> But it's not too late to change it

[18:35] <SmokeMachine> https://www.irccloud.com/pastebin/lI8nQoWQ/

[18:36] <Zoffix> SmokeMachine: yeah, that's cause Regex is a Callable

[18:36] <Zoffix> but you can't just call it with a string

[18:36] <AlexDaniel> gah did I break the doc build

[18:37] <SmokeMachine> Zoffix: couldnt it be just like grep?

[18:37] <SmokeMachine> m: say grep ^100: /^2/

[18:37] <camelia> rakudo-moar 7a7e5e96f: OUTPUT: «(2 20 21 22 23 24 25 26 27 28 29)␤»

[18:39] <SmokeMachine> Zoffix: talking about grep... why this doesnt work?

[18:39] <SmokeMachine> m: say map ^100: :is-prime

[18:39] <camelia> rakudo-moar 7a7e5e96f: OUTPUT: «Cannot resolve caller map(Range: :is-prime); none of these signatures match:␤    ($: Hash \h, *%_)␤    (\SELF: &block;; :$label, :$item, *%_)␤  in block <unit> at <tmp> line 1␤␤»

[18:40] <SmokeMachine> m: say map ^100: * ~~ :is-prime # if it works...

[18:40] <camelia> rakudo-moar 7a7e5e96f: OUTPUT: «(False False True True False True False True False False False True False True False False False True False True False False False True False False False False False True False True False False False False False True False False False True False True …»

[18:40] <SmokeMachine> i mean with grep...

[18:40] <SmokeMachine> m: say grep ^100: :is-prime

[18:40] <camelia> rakudo-moar 7a7e5e96f: OUTPUT: «Cannot resolve caller grep(Range: :is-prime); none of these signatures match:␤    ($: Bool:D $t, *%_)␤    ($: Mu $t, *%_)␤  in block <unit> at <tmp> line 1␤␤»

[18:40] <SmokeMachine> m: say grep ^100: * ~~ :is-prime

[18:40] <camelia> rakudo-moar 7a7e5e96f: OUTPUT: «(2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97)␤»

[18:41] <Zoffix> m: say map ^100: (:is-prime)

[18:41] <camelia> rakudo-moar 7a7e5e96f: OUTPUT: «Cannot resolve caller map(Range: Pair); none of these signatures match:␤    ($: Hash \h, *%_)␤    (\SELF: &block;; :$label, :$item, *%_)␤  in block <unit> at <tmp> line 1␤␤»

[18:41] <Geth> ¦ doc: 78fd2efec4 | (Aleks-Daniel Jakimenko-Aleksejev)++ | manage-page-order.p6

[18:41] <Geth> ¦ doc: No subtitle instead of empty subtitle

[18:41] <Geth> ¦ doc: 

[18:41] <Geth> ¦ doc: Otherwise Pod::To::BigPage seems to be unhappy.

[18:41] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/78fd2efec4

[18:41] <Zoffix> m: say ^100 .grep: (:is-prime)

[18:41] <camelia> rakudo-moar 7a7e5e96f: OUTPUT: «(2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97)␤»

[18:42] <Zoffix> SmokeMachine: 'cause .map takes a mapper, not a matcher

[18:42] <SmokeMachine> isnt it mapping to Bool?

[18:43] <TimToady> it's smartmapping to Bool :P

[18:43] <Zoffix> SmokeMachine: it's not doing anything. There isn't any candidate that accepts Pair as a mapper

[18:44] <SmokeMachine> Zoffix: sure! its not using `~~`, sorry I was thinking of grep...

[18:44] <SmokeMachine> but shouldnt `.toggle` behave as grep?

[18:45] <SmokeMachine> TimToady: :P

[18:45] <Zoffix> R#2088

[18:45] <synopsebot> R#2088 [open]: https://github.com/rakudo/rakudo/issues/2088 [RFC] Make .toggle take matchers, not just Callables

[18:45] <SmokeMachine> :)

[18:45] <SmokeMachine> you are faster than I thought

[18:47] * TimToady suspects Zoffix downloaded his brain into a supercomputer a year or two ago

[18:47] *** Ven` left
[18:48] * Zoffix suspects there is more than one Zoffix and they all pretend to be the same person to appear to do stuff super fast

[18:48] <TimToady> you can say that again

[18:49] <Geth> ¦ doc: 6639ef1811 | (Will "Coke" Coleda)++ | xt/examples-compilation.t

[18:49] <Geth> ¦ doc: add note

[18:49] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/6639ef1811

[18:49] <Geth> ¦ doc: 896c9bd363 | (Will "Coke" Coleda)++ | doc/Type/List.pod6

[18:49] <Geth> ¦ doc: fix example compilation

[18:49] <synopsebot> Link: https://doc.perl6.org/type/List

[18:49] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/896c9bd363

[18:50] * [Coke] wonders why we have new top level .p6 files in doc

[18:50] <SmokeMachine> Do all Zoffix have a lock? how does they syncronize the job? whitch one do the boring tasks? :P

[18:50] <[Coke]> wasn't tbrowder_ one of the people that was just concerned about that?

[18:51] <Zoffix> SmokeMachine: here's another cool one. Get all the changes for last Rakudo release: ./perl6 -e 'for lines.toggle: :off, {?/^\S/}, {?/\s+/} { .say }' docs/ChangeLog

[18:52] <Zoffix> :)

[18:52] <SmokeMachine> :)

[18:52] <perlpilot> If .toggle had some way to distinguish between toggling from on to off and off to on and/or when to actually switch the callable, then it would have a way to do something with leading/trailing edges of square waves.  And it could also have the same distinction as ff and fff.  (I dunno how useful that is though given I don't entirely grok .toggle :-)

[18:53] <perlpilot> I mean, I understand what we've got, I just don't quite understand why we've got it  

[18:53] <Zoffix> ./perl6 -e 'for lines.toggle: :off, ({?/^\S/}, {?/\s+/}) xx 3 { .say }' docs/ChangeLog

[18:53] <Zoffix> Change log for last 3 releases

[18:54] <Zoffix> wooo, I think I finalle grok it :P

[18:57] <perlpilot> I think anyone who uses .toggle is going to have to do mental exercises each time to understand the results.  That's somewhat counter productive.   (Or maybe there just hasn't been an awesome enough example yet that makes it clear to everyone :-)

[18:58] <Zoffix> Or maybe the docs suckl

[18:59] <perlpilot> m: say ^20 .toggle: * < 4, * < 7, * < 12

[18:59] <camelia> rakudo-moar 7a7e5e96f: OUTPUT: «(0 1 2 3 5 6 7 8 9 10 11)␤»

[19:00] <perlpilot> I still have to *really* think about it to understand what's happening there.

[19:00] <Zoffix> The originally suggested .while/.until is kinda a better name **to understand the workings**:  `.toggle: :off, {?/^\S/}, {?/\s/}`  =>  (starting with off position) .until  {?/^\S/} is true, don't take stuff; then, .while {?/\s+/} is true take stuff; then, ooops.. ran out of toggles and we're toggled off, so we won't take any more stuff

[19:00] <perlpilot> I don't know that I'd go "oh!  of course!" if I ran across it in the wild

[19:01] <AlexDaniel> perlpilot: sure, but what's the alternative?

[19:01] <AlexDaniel> I mean, toggle was introduced because there was no better way, sort of

[19:01] <Zoffix> perlpilot: what you wrote is not the common case, I think. A common case is to toggle once (based on discussions in 2017 logs). So understanding `.toggle: * < 4, * < 7, * < 12` is equivalent to understanding a multi-line grep or something

[19:01] <perlpilot> Zoffix, "common case"?  Have you seen what sort of crazy stuff people write?  ;)

[19:02] <Zoffix> perlpilot: the common case designed for

[19:03] <Zoffix> @pressure-readings.toggle: * > .005 { FIRST say "our spacecraft entered the atmosphere!"; say "Current atmospheric presure: $_" }

[19:03] <perlpilot> AlexDaniel, the alternative is more code that is perhaps clearer in intent.

[19:03] *** jameslenz joined
[19:03] <Zoffix> That's a good example actually

[19:03] <AlexDaniel> perlpilot: well, that code should work nicely with Seqs :)

[19:04] *** fbynite left
[19:05] <Zoffix> Well, missing `:off`, but whatever

[19:06] <perlpilot> Show me an example that uses 3 or more conditions.  That would be the best for the docs IMHO.

[19:06] <Zoffix> In .toggle?

[19:06] <perlpilot> aye

[19:06] <Zoffix> "<Zoffix> perlpilot: what you wrote is not the common case,"

[19:06] <SmokeMachine> I would like `list.while(/^lo/).until(/^$/)`

[19:07] <Zoffix> That's like saying, show me a grep with a dozen conditions. That would be the best for the docs

[19:07] *** jameslenz left
[19:08] <perlpilot> eh, I don't think so.   Toggling once or twice is easy-ish *without* .toggle

[19:08] <Zoffix> perlpilot: ok, let's see it

[19:08] <Zoffix> in code

[19:08] <perlpilot> heh, I knew you were going to say that :)

[19:08] <Zoffix> :)

[19:08] <raschipi> 'say ^20 .toggle: * < 4, * < 7, * < 12' from the explanation above, I would expect this to be (0, 1, 2, 3, 7, 8, 9, 10, 11)

[19:09] <Zoffix> m: say ^20 .toggle: * < 4, * < 7, * < 12

[19:09] <camelia> rakudo-moar 7a7e5e96f: OUTPUT: «(0 1 2 3 5 6 7 8 9 10 11)␤»

[19:10] <perlpilot> raschipi, the * < 7 condition is used once and throw away (because of the toggling)

[19:10] <perlpilot> s/throw/thrown/

[19:11] <perlpilot> Zoffix, I don't have any code in my head right now, so I'll retract my statement until I can come up with some actual code for it.  But it still *feels* easyish given that I've written such code many times before (though not in P6 nor with a Seq)

[19:12] <Zoffix> 'say ^20 .toggle: * < 4, * < 7, * < 12' => we're starting in on position, so the first is `.while` => .while * < 4 is true, take stuff (we take 0, 1, 2, 3); we switch to .until => until * < 7 we don't take stuff, it's immediatelly true, so we toggle to .while => .while * < 12 is true, take stuff, so we take 5, 6, 7, 8, 9, 10, 11, now we toggle, there's no more callables, so we remain off

[19:13] <raschipi> I see, so it's not a toggle?

[19:13] <Zoffix> raschipi: what do you mean? It does toggle from on and off

[19:13] <Zoffix> SmokeMachine: yeah, the .while + .until pair is better than a single .toggle

[19:13] <raschipi> m: say ^20 .toggle: * > 4, * > 7, * > 12

[19:13] <camelia> rakudo-moar 7a7e5e96f: OUTPUT: «(8)␤»

[19:14] *** jmaslak joined
[19:19] <Zoffix> `m: say ^20 .toggle: * > 4, * > 7, * > 12` => `m: say ^20 .toggle: [take all that stuff that's * > 4], [ignore all the stuff that's * > 7], [take all the stuff that's * > 12]`

[19:20] <Zoffix> `m: say ^20 .toggle: * > 4, * > 7, * > 12` => `m: say ^20 .toggle: [take until * > 4], [ignore until * > 7], [take until * > 12]`

[19:20] <Zoffix> yeaaaah

[19:22] <Zoffix> m: say join ' ', ('^50 .toggle: * > 3, * > 7, * > 10, * < 15, * > 20'.split(/':'|','/) Z, ^10 .map: {<take ignore>[$++ %% 2] ~ " until"})

[19:22] <camelia> rakudo-moar 7a7e5e96f: OUTPUT: «^50 .toggle ignore until  * > 3 take until  * > 7 ignore until  * > 10 take until  * < 15 ignore until  * > 20 take until␤»

[19:22] *** pmurias joined
[19:22] <Zoffix> m: say join ' ', ('^50 .toggle: * > 3, * > 7, * > 10, * < 15, * > 20'.split(/':'|','/) Z, ^10 .map: {<ignore ignore>[$++ %% 2] ~ " until"})

[19:22] <camelia> rakudo-moar 7a7e5e96f: OUTPUT: «^50 .toggle ignore until  * > 3 ignore until  * > 7 ignore until  * > 10 ignore until  * < 15 ignore until  * > 20 ignore until␤»

[19:22] <Zoffix> bah

[19:23] <Zoffix> .oO( why are they all ignores... )

[19:24] <Zoffix> a bug?

[19:24] <Zoffix> m: say join ', ', ('^50 .toggle: * > 3, * > 7, * > 10, * < 15, * > 20'.split(/':'|','/) Z, ^10 .map: {my $v = $++; dd $v; <ignore take>[$v %% 2] ~ " until"})

[19:24] <camelia> rakudo-moar 7a7e5e96f: OUTPUT: «Int $v = 0␤^50 .toggle, take until,  * > 3, ignore until,  * > 7, take until,  * > 10, ignore until,  * < 15, take until,  * > 20, ignore until␤Int $v = 1␤Int $v = 2␤Int $v = 3␤Int $v = 4␤Int $v = 5␤Int $v = 6␤»

[19:24] <perlpilot> because you used <ignore ignore>

[19:24] <Zoffix> oh

[19:24] <Zoffix> haha

[19:25] <Zoffix> so that gives us: 0, 1, 2, 3, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20

[19:25] <Zoffix> m: ^50 .toggle: * > 3, * > 7, * > 10, * < 15, * > 20

[19:25] <camelia> rakudo-moar 7a7e5e96f: ( no output )

[19:25] <Zoffix> m: say ^50 .toggle: * > 3, * > 7, * > 10, * < 15, * > 20

[19:25] <camelia> rakudo-moar 7a7e5e96f: OUTPUT: «(8 10)␤»

[19:25] <Zoffix> -_-

[19:26] <perlpilot> initial condition is "on" and is toggled by the first condition

[19:28] <perlpilot> See? that's kind of my only objection here:  .toggle is too inscrutable.  

[19:30] *** japhb__ joined
[19:30] *** hythm_ joined
[19:30] *** japhb__ left
[19:31] <[Coke]> it's slightly more scrutable than "ff"

[19:32] <SmokeMachine> sorry, what means "inscrutable"?

[19:32] <Zoffix> inescrutável

[19:32] <Zoffix> inescrutable

[19:32] <Zoffix> hard to understand

[19:33] <Zoffix> Filed R#2089

[19:33] <synopsebot> R#2089 [open]: https://github.com/rakudo/rakudo/issues/2089 [6.d review][LTA][RFC] .toggle is hard to understand

[19:33] <perlpilot> [Coke]: I don't think so.  With 'ff' you only have to worry about a single "toggle"; a single bit of hidden information changing state

[19:33] <perlpilot> (changing state one time)

[19:34] <hythm_> Hi, is there a way to evaluate WhateverCode { ... } to actual code text?

[19:34] <hythm_> p6: my $c = * > *; say $c.perl; 

[19:34] <camelia> rakudo-moar 7a7e5e96f: OUTPUT: «{ ... }␤»

[19:34] <Zoffix> hythm_: noi

[19:35] <Zoffix> *no

[19:35] <Zoffix> hythm_: or at least not at the moment

[19:35] <hythm_> Ok, thank you

[19:35] <perlpilot> hythm_: in your mind perhaps  :-)  * > * is the same as { $^a < $^b } in any case

[19:37] <perlpilot> er, * > * is the same as { $^a > $^b }  even

[19:37] <hythm_> Hmm, i needed to serialize WhatEver code, which can be , * > * or 

[19:37] <perlpilot> (why do those keys have to be so close to each other? ;)

[19:38] <Zoffix> [Coke]: not really, you can understand `ff` without knowing what the data is. `2 ff 5` will give you the all the items between the first 2 and the first 5. With .toggle you can't say that. You must know the positions of 2 and 5 in the list. you might get all the data after the first 5, you might get the 2, and then all the data after the first 5, or you might *just* get the data after the first 5

[19:39] <[Coke]> perlpilot: I thought you were referring just to the routine name.

[19:39] *** pmurias left
[19:40] <perlpilot> no, the name is fine and makes good sense to me.  It's the implementation that seems surprising at times.

[19:41] <perlpilot> (even though it works as advertised)

[19:41] *** benji__ joined
[19:41] <perlpilot> btw, ff and fff both start in the "off" position.  I wonder if .toggle should too?

[19:41] <Zoffix> s/With/With .toggle: * == 2, * == 5/

[19:42] <Zoffix> perlpilot: I think it should be split off into two separate routines

[19:42] <Zoffix> perlpilot: but you should leave your comments on the ticket: https://github.com/rakudo/rakudo/issues/2089

[19:42] * Zoffix &

[19:42] *** Zoffix left
[19:44] *** benjikun2 left
[19:51] *** pmurias joined
[19:51] <hythm_> my $var can be assigned one of these values: ">" or "<", how can i create WhateverCode like: * $var *

[19:52] <raschipi> EVAL

[19:52] <timotimo> hythm_: if it's okay you can just store &infix:«>» and &infix:«<» instead of building a whatevercode

[19:53] <hythm_> EVAL did not work

[19:53] <SmokeMachine> Zoffix: yes, I dont know whats 'inescrutável' in portuguese either... :(

[19:54] <hythm_> timotimo: will try that

[19:54] <raschipi> It means incomprehensible

[19:55] <raschipi> But in an inescrutável way

[19:56] <SmokeMachine> raschipi: thanks!

[20:00] <geekosaur> 'inscrutable'

[20:00] <geekosaur> (== 'can't be scrutinized' / studied)

[20:01] *** ChoHag joined
[20:07] *** hythm_ left
[20:13] <hobbs> scruting the inscrutable since 1963

[20:15] *** perlpilot left
[20:17] *** zakharyas joined
[20:20] *** zakharyas1 joined
[20:20] <sena_kun> see the invisible, hear the unhearable, do the impossible...

[20:20] <geekosaur> I think "unscrewing the inscrutable" is the best take I've seen on that one

[20:21] *** zakharyas left
[20:21] *** sno joined
[20:23] <pmurias> in the browser should printing to stdout/stderr be mapped to console.log/console.error?

[20:24] *** raschipi left
[20:24] <sena_kun> I'd say, that's natural enough approach.

[20:29] *** zakharyas1 left
[20:50] * masak .oO( redirect it to the printer! )

[20:56] *** skids left
[21:03] *** jameslenz joined
[21:05] <SmokeMachine> what about `.take-while`, `.ignore-while`, `.take-until` and `ignore-until`?

[21:08] <jmaslak> I've got a user question here.  I'm looking for something like IO::Socket::Async where I can basically ask for a socket that listens on a system-assigned, available epithermal port (I.E. a high numbered port), and get the port number chosen back once it's listening.  Basically "I don't care what port you listen on, just let the system pick a port and then tell me what it picked."

[21:08] *** jameslenz left
[21:08] <jmaslak> Does anyone have any ideas on that?

[21:09] *** HaraldJoerg left
[21:09] <moritz> jmaslak: I'd approach this by using a random list of high ports and checking each one if it can be bound to

[21:10] <moritz> jmaslak: something like (1024..32255).roll(*).map(&try-connect).first

[21:10] *** p6fan joined
[21:10] <moritz> where sub try-connect($port) { ... } tries to bind to the port, and returns an undefined value if it fails

[21:11] <moritz> .first(&so) instead of .first

[21:11] <AlexDaniel> jmaslak: I had the same question some time ago

[21:11] <moritz> (I'm not aware of any system call that automatically allocates a free port in an atomic manner)

[21:12] <AlexDaniel> just using port 0 should work on linux

[21:12] <jmaslak> That's kind of where I was landing, but it seems not-terribly-elegant to code for something.  Plus it ignores the system configuration of epithermal ports, so it's possible I could randomly grab something something else doesn't expect me to grab.

[21:12] <AlexDaniel> but there was a problem of doing that from perl 6, IIRC

[21:12] <timotimo> we do get the ports for you, iirc

[21:13] <geekosaur> epithermal? too hot to touch?

[21:14] <p6fan> Popular youtuber Derek Banas has listed perl6.org as a supporter in his recent videos and has said that he is working on creating a Perl6 tutorial video! https://www.youtube.com/watch?v=I96uPDifZ1w

[21:14] <timotimo> that's bananas!

[21:15] <AlexDaniel> p6fan: what second in the video?

[21:15] <[Coke]> epithermal? ephemeral?

[21:16] <AlexDaniel> oh, I see something in the description of the video. Interesting

[21:16] <timotimo> oh, damn it

[21:16] <p6fan> The video link just shows perl6.org in the description. I messaged him about a perl6 tutorial and he said that it is one of the videos he is currently working on.

[21:16] <timotimo> we get the host and port (both remote and local) only when a connection comes in

[21:17] <AlexDaniel> p6fan: plz don't forget to let us know when it's out :) sounds very cool

[21:17] <b2gills> m: say (^100).toggle: :off, *==5, * <=10, *==23, * <= 30, *==50, * <=52; # (^100).toggle: :off, 5, 10, 23, 30, 50, 52

[21:17] <camelia> rakudo-moar 6ad096c8a: OUTPUT: «(5 6 7 8 9 10 23 24 25 26 27 28 29 30 50 51 52)␤»

[21:17] <AlexDaniel> jmaslak: can you file a ticket for that?

[21:17] <AlexDaniel> huggable: rakudobug

[21:17] <huggable> AlexDaniel, Report bugs on https://github.com/rakudo/rakudo/issues/new    If you don't have access to GitHub, you can email your report to [email@hidden.address] . See also: https://github.com/rakudo/rakudo/wiki/rt-introduction

[21:18] <p6fan> I followed the channel and will let you all know when it is out. I am really looking forward to it. I have actually watched a lot of his other tutorials.

[21:18] <AlexDaniel> timotimo: so I guess you can listen on port 0 but you wouldn't know what port that is?

[21:18] <timotimo> that's right. only once a connection has come in will you get the port

[21:18] <lizmat> doesn't 'cro stub' have some code to generate a port to listen on ?

[21:19] <timotimo> lizmat: i believe 'cro run' is the one you mean

[21:19] <lizmat> ah, could be  :-)

[21:19] <timotimo> since what port to use is more or less dynamic, based on what's in use

[21:23] *** raschipi joined
[21:24] <jmaslak> Yes, I can definitely put in a ticket.  It would help a lot of types of network code to have something along those lines.

[21:25] *** p6fan left
[21:25] <timotimo> does it make any sense to also feed back the host used from the VM to the perl6 code?

[21:25] <timotimo> i know it makes sense for the port if it's 0, but will the "actually used" host ever differ from what you passed in?

[21:27] <[Coke]> I like the idea of splitting toggle up into separate chunks of *until and *while

[21:27] <[Coke]> (and then you can more easily put a .race in front of it)

[21:30] <timotimo> On Windows if the addr is initialized to point to an unspecified address (0.0.0.0 or ::) it will be changed to point to localhost. This is done to match the behavior of Linux systems.

[21:30] <timotimo> sayeth the uv docs

[21:33] <Geth> ¦ doc/coke/build: 27 commits pushed by (Will "Coke" Coleda)++, Coke++

[21:33] <Geth> ¦ doc/coke/build: review: https://github.com/perl6/doc/compare/93709455703c...fcd0c9f66fd5

[21:35] <jmaslak> Hmmpf, looks like github is having problems, I got a 500 error from them when I submitted the ticket.  I'll try again in a bit.

[21:37] <AlexDaniel> jmaslak++ # persistence

[21:38] *** MasterDuke joined
[21:40] <xi-> does the <<terminator in string initialization work differently in perl6? it can't seem to find it https://p.nuxi.ca/pnmjoyqbx/sbv60s

[21:40] <[Coke]> https://docs.perl6.org/syntax/heredocs%20:to

[21:40] <[Coke]> (yes)

[21:40] <xi-> right, thank you

[21:44] <timotimo> jmaslak: i've got the right functions together, and the places it has to go. just need to decide on an API to use between moarvm/jvm and rakudo ...

[21:46] <jmaslak> https://github.com/rakudo/rakudo/issues/2091 - I apologize if anything is unclear in the ticket.

[22:00] *** sena_kun left
[22:10] *** wamba left
[22:10] *** Xliff joined
[22:12] <Xliff> m: grammar Test { token TOP { <A> || <B> }; token A { 'A' }; token B { 'B' }; }; Test.^methods.name.say;

[22:12] <camelia> rakudo-moar b30800c8e: OUTPUT: «No such method 'name' for invocant of type 'List'. Did you mean any of these?␤    none␤    note␤    race␤    take␤␤  in block <unit> at <tmp> line 1␤␤»

[22:12] <Xliff> m: grammar Test { token TOP { <A> || <B> }; token A { 'A' }; token B { 'B' }; }; Test.^methods.gist.say;

[22:12] <camelia> rakudo-moar b30800c8e: OUTPUT: «(token TOP { <A> || <B> } token A { 'A' } token B { 'B' } parse parsefile subparse chunks orig CURSOR set_how space punct !cursor_start_subcapture same INDRULE !LITERAL perl pos prematch !cursor_push_cstack ident switch_to_slang !DYNQUANT_LIMITS blank…»

[22:15] <Xliff> Is there a way to get the name assigned to a regex object?

[22:15] <Xliff> m: my regex A { 'A' }; A.^name.say

[22:15] <camelia> rakudo-moar b30800c8e: OUTPUT: «Too few positionals passed; expected 1 argument but got 0␤  in regex A at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[22:16] <Xliff> m: my token A { 'A' }; A.^name.say

[22:16] <camelia> rakudo-moar b30800c8e: OUTPUT: «Too few positionals passed; expected 1 argument but got 0␤  in regex A at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[22:16] <Xliff> m: my token A { 'A' }; my $a = /<A>/; $a.^name.say

[22:16] <camelia> rakudo-moar b30800c8e: OUTPUT: «Regex␤»

[22:19] <Xliff> m: my token A { 'A' }; my $a = /<A>/; $a.VAR.name

[22:19] <camelia> rakudo-moar b30800c8e: ( no output )

[22:19] <Xliff> m: my token A { 'A' }; my $a = /<A>/; $a.VAR.name.say

[22:19] <camelia> rakudo-moar b30800c8e: OUTPUT: «$a␤»

[22:19] <Xliff> Maahahahaaha!

[22:19] <xinming> is   'has $a'  the same as  'has $!a'   ?

[22:20] <Xliff> m: my token A { 'A' }; A.VAR.name.say

[22:20] <camelia> rakudo-moar b30800c8e: OUTPUT: «Too few positionals passed; expected 1 argument but got 0␤  in regex A at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[22:21] <jnthn> m: my token A { }; say A.name

[22:21] <camelia> rakudo-moar b30800c8e: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Null regex not allowed␤at <tmp>:1␤------> 3my token A { 7⏏5}; say A.name␤»

[22:21] <jnthn> m: my token A { xxx }; say A.name

[22:21] <camelia> rakudo-moar b30800c8e: OUTPUT: «Too few positionals passed; expected 1 argument but got 0␤  in regex A at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[22:21] <Xliff> m: grammar Agrammar{ token A { 'A' }; }; for A.^methods { when Regex { $_.VAR.name.say }; }; 

[22:21] <camelia> rakudo-moar b30800c8e: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Undeclared name:␤    A used at line 1␤␤»

[22:21] <jnthn> m: my token A { xxx }; say &A.name

[22:21] <camelia> rakudo-moar b30800c8e: OUTPUT: «A␤»

[22:21] <jnthn> duh :)

[22:21] <Xliff> Yeah. I figured it out. Thanks, jnthn++

[22:21] <jnthn> You just need .name.say there, not .VAR.name.say :)

[22:21] <xinming> is   'has $a'  the same as  'has $!a'   ?    <--- ANyone here? :-)

[22:21] <Xliff> xinming: Yes.

[22:21] <Xliff> Not the answer to your question. One sec.

[22:22] <Xliff> No. "has $a" is not the correct syntax.

[22:22] <jnthn> xinming: Yes, in that it declares $!a. It also adds a compile-time alias so you can write $a and it is rewritten to $!a

[22:22] <Xliff> Oops! Listen to jnthn.

[22:22] <Xliff> I didn't know that. :p

[22:22] <xinming> jnthn: Thanks. That answer makes more sense. :-)

[22:23] <xinming> I actually wish to understand the internal idea of the differences.

[22:23] <jnthn> It was a sop to people who don't like twigils, but the only folks I've ever seen objecting to them would just have found something else about Perl 6 to object to anyway. :P

[22:23] <jnthn> xinming: Every attribute is actually stored with with the ! twigil. Always.

[22:24] <xinming> jnthn: Yea, understand that, the $. only addess accessor method

[22:24] <jnthn> Yeah, it's similar for has $a :)

[22:24] <xinming> is rw makes the accessor writble.

[22:24] <xinming> writable*

[22:24] *** jmaslak left
[22:24] <jnthn> Except that by runtime there's actually no "evidence" left behind of the fact it was declared has $a

[22:25] <jnthn> The compiler just rewrites them as it sees it

[22:25] <xinming> Ok, Thanks.

[22:25] <jnthn> m: class C { has $a = 42; method m() { say $a } }; C.new.m

[22:25] <camelia> rakudo-moar b30800c8e: OUTPUT: «42␤»

[22:25] <jnthn> m: class C { has $a = 42; method m() { EVAL 'say $a' } }; C.new.m

[22:25] <camelia> rakudo-moar b30800c8e: OUTPUT: «5===SORRY!5=== Error while compiling /home/camelia/EVAL_0␤Variable '$a' is not declared. Did you mean '$!a'?␤at /home/camelia/EVAL_0:1␤------> 3say 7⏏5$a␤»

[22:25] <jnthn> Rumbled :)

[22:25] <xinming> I have several small projects, and they'll be in perl6. :-)

[22:26] <jnthn> :)

[22:27] <xinming> I've been here over 12 years, and sees the huge changes in perl6 for each development stage. :-)

[22:29] <jnthn> Wow, I think that's longer than me :D

[22:32] <[Coke]> if I have a #| pod section before a sub invocation, how can I refer to it from inside the sub?    #| some stuff \n add-it(3,4); sub add-it($a, $b) { ... what is the .WHY ? }

[22:32] <jnthn> &?ROUTINE.WHY?

[22:33] <jnthn> oh, the invocation

[22:33] <jnthn> duh

[22:33] <jnthn> Umm...I'm not sure that that pod declarator comment attaches to anything

[22:33] <jnthn> Though there's others who know the Pod6 stuff better than I

[22:35] <Xliff> jnthn: It looks like for grammars, you need the .VAR

[22:35] <Xliff>  m: grammar Test { token TOP { <A> || <B> }; token A { 'A' }; token B { 'B' }; }; for Test.^methods { .VAR.name.say };

[22:35] <camelia> rakudo-moar b30800c8e: OUTPUT: «TOP␤A␤B␤parse␤subparse␤parsefile␤prematch␤xdigit␤same␤!DELEGATE_ACCEPTS␤at␤switch_to_slang␤FAILGOAL␤postmatch␤Str␤!reduce␤clone_braid_from␤to␤!cursor_start_subcapture␤snapshot_braid␤print␤!cursor_init␤INDRUL…»

[22:36] <Xliff> The only problem comes when I want to filter by Regex

[22:36] <Xliff>  m: grammar Test { token TOP { <A> || <B> }; token A { 'A' }; token B { 'B' }; }; for Test.^methods { when Regex { .VAR.name.say };  };

[22:36] <camelia> rakudo-moar b30800c8e: OUTPUT: «TOP␤Died with X::Multi::NoMatch␤  in block <unit> at <tmp> line 1␤␤A␤B␤»

[22:37] <Xliff>  m: grammar Test { token TOP { <A> || <B> }; token A { 'A' }; token B { 'B' }; }; for Test.^methods { when Regex { .VAR.name.say }; default { .name.say }; };

[22:37] <camelia> rakudo-moar b30800c8e: OUTPUT: «TOP␤Died with X::Multi::NoMatch␤  in block <unit> at <tmp> line 1␤␤A␤B␤parse␤parsefile␤subparse␤»

[22:38] <jnthn> Ah, it's probably tripping over the various internal methods

[22:38] <jnthn> .^methods(:local) might help

[22:38] <Xliff> \o/

[22:38] <Xliff> Yep. That works. Thanks much!

[22:43] <[Coke]> jnthn: I feel like I might be able to abuse it with CALLER somehow. :P

[22:43] <Altreus> does 'is copy' apply deeply to a data structure?

[22:45] <Altreus> separately: is there a shortcut to the current class, so I can say a constructor will return one?

[22:46] *** benji__ is now known as benjikun

[22:48] <jnthn> Altreus: No, shallow

[22:48] <jnthn> And ::?CLASS for the second

[22:49] <Altreus> nice

[22:49] <Altreus> thanks :)

[22:49] <Altreus> turns out I actually want the input parameter to be ro

[22:49] <Altreus> so that one was ok

[23:03] *** jameslenz joined
[23:08] *** jameslenz left
[23:09] *** DarthGandalf joined
[23:15] *** testABC joined
[23:16] *** pmurias left
[23:17] <xinming> Is there a good web framework for perl6?

[23:18] <timotimo> xinming: Cro is a thing. it's more focused on "microservices", but it can do web apps, too

[23:19] <xinming> timotimo: THanks.

[23:19] <timotimo> xinming: cro.services is the web address

[23:21] *** testABC left
[23:25] <xinming> Thanks

[23:30] *** kerframil joined
[23:33] *** raschipi left
[23:34] *** Xliff left
[23:34] <SmokeMachine> is there any way to "mix"  a class into IterationEnd to "return some data" to the class is iterating the iterator? but make it continue to finish the loops

[23:37] <jnthn> No

[23:37] <SmokeMachine> :(

[23:38] <jnthn> IterationEnd is a constant, if you did find a way to mix in to it you'd affect it globally

[23:39] <SmokeMachine> jnthn: I meant something using `but` but:

[23:39] <timotimo> all code that i've seen compares against the constant "behind" IterationEnd

[23:40] <timotimo> m: say IterationEnd.^name

[23:40] <camelia> rakudo-moar b30800c8e: OUTPUT: «Mu␤»

[23:40] <SmokeMachine> m: say IterationEnd =:= IterationEnd but role :: {}

[23:40] <camelia> rakudo-moar b30800c8e: OUTPUT: «False␤»

[23:41] <jnthn> You can do that, but then it won't be the end of the iteration

[23:41] <jnthn> Just some object

[23:42] <SmokeMachine> jnthn: Yes... I tried that... :(

[23:42] <jnthn> I susggest finding some other way to do whatever you're trying to do

[23:43] <timotimo> throw a control exception :P

[23:43] <timotimo> like, a warn

[23:43] <b2gills> Maybe an empty Slip just before IterationEnd?

[23:44] <b2gills> Actually, I don't think that would work

[23:44] <SmokeMachine> I was trying to implement `.take-while` and `.ignore-until`...

[23:45] <SmokeMachine> I was trying something like this: https://www.irccloud.com/pastebin/XbfFizxy/

[23:46] <b2gills> I tried that once https://gist.github.com/b2gills/b877658f38dae51e3c88fbdc0990f581 except I went for .accept-while

[23:48] <MasterDuke> benchable6: HEAD compare my %orig = :1a, :2b; my %new = :5b, :6c; %orig «=« %new for ^10_000; dd %orig ||| my %orig = :1a, :2b; my %new = :5b, :6c; %orig ,= %new for ^10_000; dd %orig

[23:48] <benchable6> MasterDuke, starting to benchmark the 1 given commit

[23:48] <benchable6> MasterDuke, No new data found

[23:48] <MasterDuke> benchable6: compare HEAD my %orig = :1a, :2b; my %new = :5b, :6c; %orig «=« %new for ^10_000; dd %orig ||| my %orig = :1a, :2b; my %new = :5b, :6c; %orig ,= %new for ^10_000; dd %orig

[23:48] <benchable6> MasterDuke, starting to benchmark the 1 given commit

[23:48] <benchable6> MasterDuke, ¦HEAD: «Benchmark: ␤Hash %orig = {:a(1), :b(5), :c(6)}␤«timed out after 10 seconds»»

[23:49] <MasterDuke> benchable6: compare HEAD my %orig = :1a, :2b; my %new = :5b, :6c; %orig «=« %new for ^5_000; dd %orig ||| my %orig = :1a, :2b; my %new = :5b, :6c; %orig ,= %new for ^5_000; dd %orig

[23:49] <benchable6> MasterDuke, starting to benchmark the 1 given commit

[23:49] <benchable6> MasterDuke, https://gist.github.com/c74a3252c670db25a315ae70022e64ca

[23:49] <jnthn> m: sub take-while($matcher, Iterable \things) { gather { for things { if $matcher.ACCEPTS($_) { .take } else { last } } } }; say take-while(* < 3, 1..10)

[23:49] <camelia> rakudo-moar b30800c8e: OUTPUT: «(1 2)␤»

[23:49] <MasterDuke> TimToady, kjk: ^^^ (the benchable results)

[23:52] <SmokeMachine> jnthn: I was trying to make possible something like: `^10 .take-while(* < 3).ignore-until(5).take-while(* < 9)` and that would return `(0, 2, 5, 6, 7, 8)`

[23:54] <SmokeMachine> sorry: `(0, 1, 2, 5, 6, 7, 8)`

[23:54] <TimToady> MasterDuke: you mean the one that says "too few iterations" :)

[23:55] <jnthn> Ah, that'd be done by having an implementation of Iterable like TakeIgnoreIterable or some such

[23:55] <jnthn> And then add .ignore-until and .take-until methods on to that and stack them up

[23:56] <jnthn> And then apply them all at the point we really iterate

[23:56] <SmokeMachine> jnthn: yes, that makes sense...

[23:58] <SmokeMachine> jnthn: both, take-while and ignore-until, would make some changes on self and return self, right? (being self a Seq)

[23:59] <jnthn> No

[23:59] <jnthn> Always do immutable things

[23:59] <SmokeMachine> or a new instance of Seq?

[23:59] <SmokeMachine> ok

[23:59] <jnthn> But you might actually want a TakeIgnoreSeq or something (name to be bikeshed later :))

