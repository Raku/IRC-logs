[00:01] <lelf> smth more end-user-friendly?  the problem is that â€˜sub foo is nativeâ€™ is too lazy with regard to dyn library bindings

[00:02] <timotimo> if it's okay to be unix-specific, you can try binding dlopen and friends with nativecall

[00:04] *** markong joined
[00:04] *** margeas left
[00:17] *** margeas joined
[00:19] *** markong left
[00:23] *** ckraniak joined
[00:26] *** margeas left
[00:29] *** lookatme joined
[00:33] *** wamba left
[00:34] *** Grauwolf_ joined
[00:36] *** Grauwolf left
[00:36] *** Geth joined
[00:36] *** ChanServ sets mode: +v Geth

[00:37] *** epony left
[00:40] <lookatme> o|

[00:41] <TimToady> .oO(a grim cyclops?)

[00:41] *** S007 joined
[00:42] <lookatme> o_O

[00:44] <TimToady> .oO(the top of a movie projector?)

[00:47] *** troys_ is now known as troys

[00:48] <lookatme> (Â°ãƒ¼Â°ã€ƒ)

[00:50] *** S007 left
[00:51] <TimToady> .oO(an upside-down skateboard flying out of a dustcloud?)

[00:52] <gfldex> .oO(What is the hippie smokingâ€¦again?)

[00:53] <gfldex> .oO(And can I have some too?)

[00:53] <lookatme> (ï¼ _ï¼ ;)

[00:55] *** epony joined
[00:56] <TimToady> .oO(a winking snail towing another snail out of a tunnel?)

[00:56] *** S007 joined
[00:56] *** epony left
[00:57] *** epony joined
[00:57] <lookatme> (âŠ™ï¹âŠ™)

[00:58] <TimToady> .oO(hard to shoot at the target when I drank too much...)

[01:00] *** brrt left
[01:00] * lookatme back to work

[01:00] <TimToady> o|

[01:03] *** Cabanossi left
[01:05] *** Cabanossi joined
[01:13] <Geth> Â¦ ecosystem: a02d987859 | (Zoffix Znet)++ (committed using GitHub Web editor) | META.list

[01:13] <Geth> Â¦ ecosystem: Add CoreHacker::Q to ecosystem

[01:13] <Geth> Â¦ ecosystem: 

[01:13] <Geth> Â¦ ecosystem: "Perl 6 QAST Visualizer": https://github.com/zoffixznet/q

[01:13] <Geth> Â¦ ecosystem: review: https://github.com/perl6/ecosystem/commit/a02d987859

[01:13] *** Zoffix joined
[01:14] <Zoffix> .tell lizmat you had some interest in the module. The first baby version got released as CoreHackers::Q: https://github.com/zoffixznet/q

[01:14] <yoleaux> Zoffix: I'll pass your message to lizmat.

[01:15] *** Zoffix left
[01:16] *** nativecallable6 left
[01:16] *** nativecallable6 joined
[01:16] *** ChanServ sets mode: +v nativecallable6

[01:17] *** unicodable6 left
[01:17] *** quotable6 left
[01:17] *** unicodable6 joined
[01:17] *** quotable6 joined
[01:19] *** cdg_ left
[01:40] *** cdg joined
[01:45] *** cdg left
[02:06] *** troys is now known as troys_

[02:09] *** stmuk joined
[02:16] *** cdg joined
[02:21] *** cdg left
[02:35] *** troys_ is now known as troys

[02:40] *** squashable6 left
[02:40] *** bloatable6 left
[02:41] *** greppable6 left
[02:42] *** perlbot joined
[02:43] *** Actualeyes joined
[02:44] *** ilbot3 left
[02:50] *** cdg joined
[02:52] *** cdg left
[02:52] *** cdg joined
[03:01] *** ilbot3 joined
[03:01] *** ChanServ sets mode: +v ilbot3

[03:06] *** khisanth_ left
[03:06] *** troys is now known as troys_

[03:19] *** pilne left
[03:20] *** khisanth_ joined
[03:28] *** Todd_ joined
[03:34] <Todd_> Ji All.  I am stumped.  I just installed rakudo-pkg on a Fedora 27 server (removed all the zef's and rakudo's first) and I can't get anything to zef properly.  All packages have the same issue.  " --force-test" is required on all of them to complete.  When I go to "use xxx", you get an error messages as to it can;t find one of the long letter directories in the /opt path (it really isn't theWould someone mind looking at my vpaste and tel

[03:34] <Todd_> " --force-test" is required on all of them to complete.  If I force, when I go to "use xxx", you get an error messages as to it can't find one of the long letter directories in the /opt path (it really isn't there).  Would someone mind looking at my vpaste and telling me what I am doing wrong?

[03:34] <Todd_> http://vpaste.net/MnJEg

[03:35] <Todd_> sorry for the weird copy and paste.

[03:37] *** Zoffix joined
[03:38] <Zoffix> Todd_: do you have ~/.zef or ~/.perl6 directory by any chance?

[03:38] <Zoffix> I may be mistaken, but it's possible zef is installing the modules user-local, but the path when you `use` them doesn't include the path where it's installing them or something. 

[03:38] <Todd_> yes and yes

[03:39] <Zoffix> Todd_: and when you `use` the module? Does the error message list ~/.perl6 in the list?

[03:40] <Todd_> # eraseme.pl6 ===SORRY!=== Could not find Terminal::ANSIColor at line 9 in:     /home/linuxutil     /root/.perl6     /opt/rakudo-pkg/share/perl6/site     /opt/rakudo-pkg/share/perl6/vendor     /opt/rakudo-pkg/share/perl6     CompUnit::Repository::AbsolutePath<54193536>     CompUnit::Repository::NQP<30451248>     CompUnit::Repository::Perl5<30451288>

[03:41] <Zoffix> Todd_: are you root?

[03:42] <Todd_> yes and I just realized that and renamed /root/.zef and /root/.perl6

[03:42] <lookatme> Is it lake some test tool ? or something else

[03:42] <lookatme> like prove

[03:42] <Todd_> rerunning "zef install Terminal::ANSIColor" gives the same error

[03:43] <lookatme> I faced same problem in fresh installation of Fedora 27

[03:44] <Zoffix> Todd_: renamed to what?...

[03:44] <Todd_> mv ~/.zef ~/.zef.000     mv ~/.perl6 ~/.perl6.000

[03:45] <Todd_> both the root and users

[03:45] <Zoffix> No idea

[03:45] *** Zoffix left
[03:46] <Todd_> I am doing a "dnf --enablerepo=* upgrade" to see if that helps

[03:49] <lookatme> Todd_, you can try it with  --debug

[03:49] <Todd_> the zef command?

[03:49] <lookatme> yeah, it print the debug message

[03:50] <Todd_> in progress

[03:51] <Todd_> http://vpaste.net/21U9f

[03:53] <Todd_> Is this a hint:

[03:53] <Todd_> ListUtil.c: loadable library and perl binaries are mismatched

[03:53] <Todd_> where are these loadable libraries?

[03:54] <Todd_> I think I am on to something.  Don't anybody help me until I get back

[03:55] <Todd_> rats.  renaming .precomp did not help

[03:55] <lookatme> idk

[03:55] <lookatme> no idea :)

[03:56] <geekosaur> that message is a *perl 5* mismatch

[03:57] *** bloatable6 joined
[03:57] *** ChanServ sets mode: +v bloatable6

[03:57] <geekosaur> you have a perl 5 XS module that doesn't match the perl 5 executable (or shared library, depending on how perl was configured0

[03:58] <geekosaur> something tells me your F27 is much more hosed than just rakudo. or you have a perl 5 you copied over that needed to not be copied.

[03:58] <lookatme> so some perl5 script will failed ?

[03:58] <Todd_> ahhhh.  now it is starting to make sense.  I will try wiping p5 and reinstalling it.  I presume zef is using p5

[03:58] <lookatme> And I think the zef maybe use prove(a perl5 script for test) to test something

[03:58] <geekosaur> I think it uses Inline::Perl5 for some things

[03:58] <geekosaur> probably have to ask nine

[03:59] <Todd_> I have had the WORST luck with Inline::Perl5.  Probpably a good thing as it forced me to dive into p6 harder

[03:59] <lookatme> And I am wonder why you copy the Perl5 or Rakudo and other things ?

[04:00] <lookatme> The correct way is reinstall them, not copy 

[04:01] <geekosaur> and/or ugexe

[04:02] <Todd_> I am using `# dnf remove perl` and the corresponding install.  ther is a reinstall, but I wanted to hunt down any leftovers first

[04:04] <Todd_> removed and reinstalled p5.  Still get: loadable library and perl binaries are mismatched

[04:06] *** eliasr left
[04:12] *** telex joined
[04:19] *** troys_ is now known as troys

[04:35] <Todd_> update: the perl 5 chat guys are helping me fix battling cpan and installed binaries, which is causing the issue

[04:38] <Todd_> wish list: please update zef to use perl6 instead of perl5 to do its magic

[04:43] <Todd_> okay: # perl -v bash: /usr/bin/perl: No such file or directory

[04:44] *** Cabanossi left
[04:45] *** Cabanossi joined
[04:46] <Todd_> I useed find to hunt down any leftovers and now I will reinstall

[04:47] <Todd_> # dnf install perl perl-interpreter         this will be a while!

[04:49] *** lelf left
[05:09] <Todd_> Yippee!!!!  This command show the offender!  # perl -le 'for (@INC) { print $_ if -f "$_/DBI.pm" }'

[05:09] <Todd_> `mv /home/todd/perl5 /home/todd/perl5.000`  fix the issue

[05:10] *** troys is now known as troys_

[05:11] *** troys_ is now known as troys

[05:18] *** Actualeyes left
[05:20] *** kerframil left
[05:20] <Todd_> "if" Fedora had our moduels loaded up, would this be the right way to translate their names into the repo names (word in Perl 5):

[05:20] <Todd_> # dnf repoquery --whatprovides 'rakudo(DateTime::Format)'

[05:21] *** MasterDuke joined
[05:25] *** kerframil joined
[05:31] *** kerframil left
[05:46] *** eythian joined
[05:52] *** Kaiepi left
[05:52] *** Kaiepi joined
[06:03] *** Sgeo joined
[06:18] *** troys is now known as troys_

[06:21] *** troys_ is now known as troys

[06:29] <Todd_> I am having trouble installing modules on Fedora 26.  Would someone please look at my vpaste and see what I am doing wrong?  http://vpaste.net/x04uk

[06:30] <Todd_> All moduesl give the same error

[06:30] *** sena_kun joined
[06:31] *** khw left
[06:33] *** sena_kun left
[06:41] *** lowbro joined
[06:41] *** lowbro left
[06:41] *** lowbro joined
[07:07] <El_Che> Todd_: it looks like you're using system zef instead the one of the package

[07:07] <El_Che> /opt/rakudo-pkg/bin/zef (as root) or /opt/rakudo-pkg/bin/install_zef_as_user if you want them in your $HOME

[07:08] <El_Che> (the latter is the beter option for dev stuff)

[07:10] <El_Che> Todd_: rakudo-pkg does not touch system path to no interfere with system rakudo (if present). You need to look at the PATH section in the doc to prevent this type of error

[07:11] <El_Che> in short "export PATH=/opt/rakudo-pkg/bin:$PATH" will do (and adding ~/.perl6/bin if you install locally)

[07:14] <Todd_> I uninstalled the rakudo package and reinstalled Fedroa's and all is well.  Go figure ....

[07:16] <El_Che> it's not related

[07:16] <El_Che> you are using /usr/bin/zef

[07:16] <El_Che> while the package provides /opt/rakudo-pkg/bin/zef

[07:18] <El_Che> I decided not to change the user $PATH when I created the packages, maybe I need to review that, but not interfearing with system rakudo is a good thing, imho

[07:19] <El_Che> even when not adapting the path can lead to weird (but safe) results

[07:21] <Todd_>  I uninstalled rakudo and rakudo-ref.  Then did a global find and aced ANYTHING that had the letters "zef" in it.  I then installed the rakudo-pkg rpm.  That is when I got into trouble.  I did this same thing an fe hours earlier on a Fedora 27 server and it went perfectly, excewpt for the Perl 5 module mismatches that blew zef's mind.

[07:22] <Todd_> I have this Fedora 26 machien scheduels for upgrade to 27 tomorrow evening, so I may have to go through this again.

[07:23] <El_Che> well, having to manually delete binaries is a bad thing is they were installed from packages

[07:23] <El_Che> for the record, rakudo-okg is self contained in /opt/rakudo-pkg and modules installed locally are in ~/.perl6

[07:24] <El_Che> nothing is written elsewhere

[07:25] *** espadrine left
[07:35] *** troys left
[07:46] *** lichtkind joined
[07:47] *** ChoHag joined
[07:48] <Todd_> It is going to be a fun night.  Thank you all for the wonderful help!

[07:56] *** abraxxa joined
[08:05] *** zakharyas joined
[08:09] *** zakharyas1 joined
[08:11] *** zakharyas left
[08:14] *** sjn joined
[08:26] *** ChoHag left
[08:35] *** wamba joined
[08:41] *** darutoko joined
[08:45] <Geth> Â¦ doc: 7a0bb28bdc | (Luca Ferrari)++ | doc/Type/Any.pod6

[08:45] <Geth> Â¦ doc: Improve &exit documentation.

[08:45] <Geth> Â¦ doc: 

[08:45] <Geth> Â¦ doc: Specify that exit status code has to be interpreted by calling process, and

[08:45] <Geth> Â¦ doc: that LEAVE is prevented when using exit.

[08:45] <Geth> Â¦ doc: Remark that &exit should be used to terminate abnormally only the main process,

[08:45] <synopsebot> Link: https://doc.perl6.org/type/Any

[08:45] <Geth> Â¦ doc: while exceptions should be used for other cases (e.g., methods).

[08:45] <Geth> Â¦ doc: 

[08:45] <Geth> Â¦ doc: This does not remove the TODO item attached, but I believe

[08:45] <Geth> Â¦ doc: there's not a better place to document exit since it is already documented

[08:45] <Geth> Â¦ doc: with the usage of MAIN and the phasers.

[08:46] <Geth> Â¦ doc: review: https://github.com/perl6/doc/commit/7a0bb28bdc

[08:46] <Geth> Â¦ doc: fed435e1b2 | (Luca Ferrari)++ | doc/Language/functions.pod6

[08:46] <synopsebot> Link: https://doc.perl6.org/language/functions

[08:46] <Geth> Â¦ doc: Explain that 'return' in MAIN will produce always an exit code of zero.

[08:46] <Geth> Â¦ doc: review: https://github.com/perl6/doc/commit/fed435e1b2

[08:47] *** scimon joined
[08:58] *** melezhik joined
[09:03] *** ckraniak left
[09:04] *** zakharyas1 left
[09:06] *** zakharyas joined
[09:07] *** Todd_ left
[09:13] *** lookatme left
[09:13] <torbjorn> the token/rule names found in key names in the resulting Match object - is there magic involved in determining whta class they get?

[09:14] <torbjorn> ie token foo { [foo]* } # would that result in $/<foo> being an Array because of the * ?

[09:14] *** dakkar joined
[09:18] <moritz> [foo] doesn't capture

[09:18] <moritz> (foo)* does, and yes, $<foo> would be an array

[09:18] <moritz> the only exception is the ? quantifier, which produces either a Match or a Nil capture

[09:31] *** lowbro left
[09:32] *** lelf joined
[09:33] <torbjorn> ah yes, () of course

[09:34] <torbjorn> so token foo { foo } # woueld not be an array?

[09:34] <moritz> that doesn't even capture

[09:35] <moritz> well, $<foo> in the caller caputres

[09:36] <lelf> How do you do â€œ:(Foo[::T] \a, Foo[T] \b)â€? Akin to â€œ:(::T \a, T \b)â€. [Foo is defined]

[09:36] <moritz> m: my token foo { foo }; 'foo' ~~ /<foo>/ and say $<foo>.^name

[09:36] <camelia> rakudo-moar f02606cea: OUTPUT: Â«Matchâ¤Â»

[09:36] <moritz> m: my token foo { foo }; 'foo' ~~ /<foo>+/ and say $<foo>.^name

[09:36] <camelia> rakudo-moar f02606cea: OUTPUT: Â«Arrayâ¤Â»

[09:44] *** wamba left
[09:45] <Geth> Â¦ doc: e3edec2d40 | (Luca Ferrari)++ | doc/Language/functions.pod6

[09:45] <Geth> Â¦ doc: Small rephrasing about coercion.

[09:45] <Geth> Â¦ doc: 

[09:45] <Geth> Â¦ doc: Also define the example class Bar at the beginning of the example, there is

[09:45] <Geth> Â¦ doc: no point here to leave it abstract.

[09:45] <synopsebot> Link: https://doc.perl6.org/language/functions

[09:45] <Geth> Â¦ doc: review: https://github.com/perl6/doc/commit/e3edec2d40

[09:54] <dakkar> hmm. re: coercion, I feel it mixes "target type" and "method used to get it". I can't say Â«sub x(IO::Path() $d) { ... }Â», even though Â«sub x(IO() $d) { ... }Â» will actually coerce to IO::Path

[09:55] <dakkar> m: sub x(IO::Path()$d) { $d.^name.say}; x('a')

[09:55] <camelia> rakudo-moar f02606cea: OUTPUT: Â«No such method 'IO::Path' for invocant of type 'Str'â¤  in sub x at <tmp> line 1â¤  in block <unit> at <tmp> line 1â¤â¤Â»

[09:55] <dakkar> m: sub x(IO()$d) { $d.^name.say}; x('a')

[09:55] <camelia> rakudo-moar f02606cea: OUTPUT: Â«IO::Pathâ¤Â»

[10:00] *** travis-ci joined
[10:00] <travis-ci> Doc build errored. Luca Ferrari 'Small rephrasing about coercion.

[10:00] <travis-ci> https://travis-ci.org/perl6/doc/builds/327159440 https://github.com/perl6/doc/compare/fed435e1b268...e3edec2d409b

[10:00] *** travis-ci left
[10:00] <buggable> [travis build above] â˜  Did not recognize some failures. Check results manually.

[10:04] *** stmuk_ joined
[10:05] *** zakharyas1 joined
[10:06] *** stmuk left
[10:07] *** vichib left
[10:07] *** zakharyas left
[10:08] *** ChoHag joined
[10:25] *** cdg left
[10:30] *** wamba joined
[10:43] *** lichtkind left
[10:47] *** ChoHag left
[10:54] *** ChoHag joined
[10:54] *** dct left
[10:56] *** Zoffix joined
[10:59] <Zoffix> dakkar: it's just a convention that a method named "Foo" converts an object to type "Foo". The coersion merely calls a method with .^name of target type. Str does not have "IO::Path" method so that coersion rightly fails. IO::Path does role IO tho and Str type has IO method that returns an IO object (IO::Path in this case).

[11:00] <Zoffix> But nothing's stopping you from defining a method with IO::Path as a name and using IO::Path as target type in coercer

[11:00] <Zoffix> m: use MONKEY; augment class Str { method IO::Path { self.IO } }; -> IO::Path(Str) $x { dd $x }("foo")

[11:00] <camelia> rakudo-moar f02606cea: OUTPUT: Â«IO::Path.new("foo", :SPEC(IO::Spec::Unix), :CWD("/home/camelia"))â¤Â»

[11:01] *** dct joined
[11:04] <Zoffix> FWIW, there are also two paths in coersion: the slow path will try to see if there's a method and complain if there isn't:

[11:04] <Zoffix> m: try '-> IO::Path(Str) :foo(:bar(:$ber)) {}("x")'.EVAL; say [$!.^name, $!]

[11:04] <camelia> rakudo-moar f02606cea: OUTPUT: Â«[X::AdHoc Unable to coerce value for '$ber' from Str to IO::Path; no coercion method definedâ¤  in block <unit> at EVAL_0 line 1â¤  in block <unit> at <tmp> line 1â¤]â¤Â»

[11:05] <Zoffix> But the fast path will go right away to try to call it and will just throw method not found error as a result:

[11:05] <Zoffix> m: try '-> IO::Path(Str) {}("x")'.EVAL; say [$!.^name, $!]

[11:05] <camelia> rakudo-moar f02606cea: OUTPUT: Â«[X::Method::NotFound No such method 'IO::Path' for invocant of type 'Str'â¤  in block <unit> at EVAL_0 line 1â¤  in block <unit> at <tmp> line 1â¤]â¤Â»

[11:06] *** ckraniak joined
[11:07] <Zoffix> (that's an implementation detail, but perhaps the docs should be more vague about what gets thrown when coercion fails)

[11:11] *** rindolf joined
[11:13] <Zoffix> m: -> ::T \a where Array[T.of], \b where Array[T.of] {}(Array[Int], Array[Int])

[11:13] <camelia> rakudo-moar f02606cea: ( no output )

[11:13] <Zoffix> m: -> ::T \a where Array[T.of], \b where Array[T.of] {}(Array[Int], Array[Num])

[11:13] <camelia> rakudo-moar f02606cea: OUTPUT: Â«Constraint type check failed in binding to parameter 'b'; expected anonymous constraint to be met but got Array[Num] (Array[Num])â¤  in block <unit> at <tmp> line 1â¤â¤Â»

[11:13] *** ilmari joined
[11:13] *** ilmari left
[11:13] *** ilmari joined
[11:15] <Zoffix> lelf: doesn't look like that's implemented (filed as R#1383). That ^ looks like a slower workaround you could use

[11:15] <synopsebot> R#1383 [open]: https://github.com/rakudo/rakudo/issues/1383 [NYI] Type capture in parametarization NYI

[11:18] *** Zoffix left
[11:22] <lelf> ha! alright

[11:24] <lelf> m: (my Int @ = [1..3]).WHAT # â† is there a shortcut for this?

[11:24] <camelia> rakudo-moar f02606cea: ( no output )

[11:24] *** margeas joined
[11:30] <lelf> specifiying the *.of type I meanâ€¦  this is also too wordy:

[11:30] <lelf> m: Array[Int]([1..3]).of

[11:30] <camelia> rakudo-moar f02606cea: ( no output )

[11:32] *** ckraniak left
[11:36] <jnthn> Could be (my Int @ = 1..3) or Array[Int](1..3) I'd think

[11:36] <jnthn> Saves creating a throw-away Array

[11:49] <moritz> m: dd Array[Int].new(1, 2, 3)

[11:49] <camelia> rakudo-moar 7230b7651: OUTPUT: Â«Array[Int].new(1, 2, 3)â¤Â»

[11:53] <dakkar> re: type coercions, I understand everything that Zoffix said, and I know why it's that way. My issue is that the *documentation* says that in Â«Foo() $xÂ», Foo is the parameter type that things get coerced to.

[11:53] <dakkar> but that's not correct. It's both a type constraint, and the name of the conversion method

[11:54] <dakkar> if I want a IO::Path, but not a IO::Special, and allow my callers to pass me a stringâ€¦ I can't

[11:55] <dakkar> (and no, sub x(IO() $x where IO::Path) is a terrible work-around)

[11:55] <dakkar> could we add a Â«sub IO::PathÂ» alongside Â«sub IOÂ», and document more clearly what the coercion actually does?

[11:55] <dakkar> I may try doing that this weekendâ€¦

[12:01] <scimon> Generally if I want a string that should be a valid IO::Path I make a subset but that's me. subset DirPath of Str where *.IO.d   

[12:01] <scimon> That sort of thing.

[12:02] *** andrzejku joined
[12:03] <scimon> I dunno. I'm not feeling 100% at the moment so am probably not understanding.

[12:03] <andrzejku> hi

[12:03] <andrzejku> can you see my messages?

[12:04] *** dupadupakupa joined
[12:05] <DrForr> andrzejku: Yes.

[12:05] <andrzejku> thnks :)

[12:05] *** dupadupakupa left
[12:05] <andrzejku> I decided to use sublime for irc and it looks it is working

[12:06] <DrForr> irssi+tmux=shiny.

[12:06] *** zakharyas1 left
[12:15] <ilmari> tmux, schmux

[12:15] <ilmari> screen 4lyf

[12:17] *** rindolf left
[12:20] *** cdg joined
[12:22] <DrForr> I started out with screen, but split-display sold me.

[12:25] *** cdg left
[12:25] *** SCHAPiE joined
[12:26] <Altreus> irssi ftl

[12:26] <Altreus> weechat 4 lyf

[12:28] * moritz wtf

[12:29] <DrForr> Shrug.

[12:43] *** leah2 left
[12:45] *** leah2 joined
[12:50] *** leah2 left
[12:55] <lelf> I'm prob missing something trivial: how do you â€œX fff Yâ€ getting list of lists (one for each matching sequence)?

[12:55] <moritz> lelf: example?

[12:56] *** ckraniak joined
[12:57] <lelf> <begin 1 2 end begin 3 end X begin â€¦> â‡’ [[1,2], [3], â€¦]

[12:59] <masak> lelf: not sure `fff` is the best tool for that, but it's definitely doable with (say) a recursive function or a loop/given construction

[13:01] <masak> lelf: the problem you're bound to run into with `fff` is that its internal state is per *site* in the code -- which doesn't square well with needing one state per [] list

[13:01] <Geth> Â¦ doc: 0cfb87fb9e | (Luca Ferrari)++ | doc/Language/exceptions.pod6

[13:01] <Geth> Â¦ doc: Explain die uses $*ERR.

[13:01] <Geth> Â¦ doc: 

[13:01] <Geth> Â¦ doc: See issue #1722.

[13:01] <Geth> Â¦ doc: review: https://github.com/perl6/doc/commit/0cfb87fb9e

[13:01] <synopsebot> Link: https://doc.perl6.org/language/exceptions

[13:01] <Geth> Â¦ doc: 28d8512437 | (Luca Ferrari)++ | doc/Language/exceptions.pod6

[13:01] <Geth> Â¦ doc: Add a $*ERR.say on a simple catch block as example of how to use STDERR.

[13:01] <Geth> Â¦ doc: 

[13:01] <Geth> Â¦ doc: See discussion in issue #1722.

[13:01] <Geth> Â¦ doc: review: https://github.com/perl6/doc/commit/28d8512437

[13:02] <masak> (more exactly, there's one internal state per clone of the surrounding function. but that helps little here. I guess you *could* clone the function once per new list -- say, by re-entering the surrounding function -- but at this point I'd argue that we're far into X/Y land, and should use another tool.)

[13:02] <masak> lelf: on a high level, what you appear to be doing is turning SAX into DOM :)

[13:03] <masak> lelf: how do you plan to handle mis-nested data such as <end begin> or <begin end end begin> ?

[13:03] <masak> (another thing `fff` won't do for you)

[13:15] <lelf> no, no nesting

[13:19] *** raschipi joined
[13:21] <masak> no nesting? um, but `[1, 2]` is nested inside `[[1, 2], [3], ...]`

[13:22] *** leah2 joined
[13:23] <lelf> there can't be begin-end inside begin-end. soâ€¦ say, one-level nesting

[13:24] <masak> ok, now I see what you're saying

[13:26] *** travis-ci joined
[13:26] <travis-ci> Doc build passed. Luca Ferrari 'Add a $*ERR.say on a simple catch block as example of how to use STDERR.

[13:26] <travis-ci> https://travis-ci.org/perl6/doc/builds/327219218 https://github.com/perl6/doc/compare/e3edec2d409b...28d8512437a1

[13:26] *** travis-ci left
[13:26] <masak> m: my @result; my @part; for <begin 1 2 end begin 3 end> { when "begin" { @part = () }; when "end" { @result.push(@part) }; default { @part.push($_) } }; say @result.perl

[13:26] <camelia> rakudo-moar 773d2b9e7: OUTPUT: Â«[[IntStr.new(3, "3")], [IntStr.new(3, "3")]]â¤Â»

[13:26] <masak> hm :)

[13:27] <masak> m: my @result; my @part; for <begin 1 2 end begin 3 end> { when "begin" { @part := [] }; when "end" { @result.push(@part) }; default { @part.push(+$_) } }; say @result.perl

[13:27] <camelia> rakudo-moar 773d2b9e7: OUTPUT: Â«[[1, 2], [3]]â¤Â»

[13:28] <lelf> I'm itching for a Haskellâ€™s groupBy function (group elements by comparing adjacent ones). So like squish, but groupping, not uniquing.

[13:30] <jnthn> lelf: See categorize and classify

[13:30] <jnthn> Oh, but that doesn't require adjacency

[13:40] <masak> yeah, that's where the `fff` angle isn't all bad

[13:40] <masak> it just fails in other ways

[13:41] <masak> nothing stopping you from writing your own grouping function, though

[13:41] *** itaipu joined
[13:44] * [Coke] waves good morning over his bacon & coffee.

[13:48] *** perlpilot joined
[13:54] *** cdg joined
[13:55] *** vichib joined
[13:55] *** vichib left
[13:55] *** vichib joined
[13:56] *** cdg left
[13:56] *** cdg joined
[14:02] *** zakharyas joined
[14:09] <moritz> m: my @i = <begin 1 2 end begin 3 end>; say @i.grep(:k, 'begin') Z @i.grep(:k, 'end')

[14:09] <camelia> rakudo-moar 773d2b9e7: OUTPUT: Â«((0 3) (4 6))â¤Â»

[14:10] <moritz> m: my @i = <begin 1 2 end begin 3 end>; say @i.grep(:k, 'begin').map(*+1) Z @i.grep(:k, 'end').map(*-1)

[14:10] <camelia> rakudo-moar 773d2b9e7: OUTPUT: Â«((1 2) (5 5))â¤Â»

[14:11] <moritz> m: my @i = <begin 1 2 end begin 3 end>; say @i.grep(:k, 'begin').map(*+1) Z @i.grep(:k, 'end').map(*-1).map({@i[&infix<..>(|$_)})

[14:11] <camelia> rakudo-moar 8c5af9b97: OUTPUT: Â«5===SORRY!5=== Error while compiling <tmp>â¤Unable to parse expression in subscript; couldn't find final ']' (corresponding starter was at line 1)â¤at <tmp>:1â¤------> 3 'end').map(*-1).map({@i[&infix<..>(|$_)7â5})â¤    expecting any of:â€¦Â»

[14:12] <moritz> m: my @i = <begin 1 2 end begin 3 end>; say @i.grep(:k, 'begin').map(*+1) Z @i.grep(:k, 'end').map(*-1).map({@i[&infix<..>(|$_)]})

[14:12] <camelia> rakudo-moar 8c5af9b97: OUTPUT: Â«5===SORRY!5=== Error while compiling <tmp>â¤Undeclared routine:â¤    infix used at line 1. Did you mean 'indir', 'index'?â¤â¤Â»

[14:12] <moritz> m: my @i = <begin 1 2 end begin 3 end>; say @i.grep(:k, 'begin').map(*+1) Z @i.grep(:k, 'end').map(*-1).map({@i[&infix:<..>(|$_)]})

[14:12] <camelia> rakudo-moar 8c5af9b97: OUTPUT: Â«Too few positionals passed; expected 2 arguments but got 1â¤  in block <unit> at <tmp> line 1â¤â¤Â»

[14:12] <moritz> m: my @i = <begin 1 2 end begin 3 end>; say @i.grep(:k, 'begin').map(*+1) Z @i.grep(:k, 'end').map(*-1).map({@i[&infix:<..>(|$_.list)]})

[14:12] <camelia> rakudo-moar 8c5af9b97: OUTPUT: Â«Too few positionals passed; expected 2 arguments but got 1â¤  in block <unit> at <tmp> line 1â¤â¤Â»

[14:12] <moritz> m: my @i = <begin 1 2 end begin 3 end>; say @i.grep(:k, 'begin').map(*+1) Z @i.grep(:k, 'end').map(*-1).map({ say $_.perl })

[14:12] <camelia> rakudo-moar 8c5af9b97: OUTPUT: Â«2â¤5â¤((1 True) (5 True))â¤Â»

[14:12] <moritz> m: my @i = <begin 1 2 end begin 3 end>; say @i.grep(:k, 'begin').map(*+1) Z=> @i.grep(:k, 'end').map(*-1).map({ say $_.perl })

[14:12] <camelia> rakudo-moar 8c5af9b97: OUTPUT: Â«2â¤5â¤(1 => True 5 => True)â¤Â»

[14:13] *** jkramer joined
[14:13] <jkramer> p6: '11325992321982432123259' ~~ m:ex/[ (\d ** 2..*) \d* ] ** 2..*/

[14:13] <camelia> rakudo-moar 8c5af9b97: OUTPUT: Â«MoarVM panic: Memory allocation failed; could not allocate 100208 bytesâ¤Â»

[14:13] <moritz> m: my @i = <begin 1 2 end begin 3 end>; (say @i.grep(:k, 'begin').map(*+1) Z=> @i.grep(:k, 'end').map(*-1)).map({@i[&infix:<..>(|$_.list)]})

[14:13] <camelia> rakudo-moar 8c5af9b97: OUTPUT: Â«(1 => 2 5 => 5)â¤Too few positionals passed; expected 2 arguments but got 1â¤  in block <unit> at <tmp> line 1â¤â¤Â»

[14:13] <jkramer> Does this work for anyone? It uses 100% CPU for me and hangs forever

[14:13] *** atta joined
[14:13] <moritz> m: my @i = <begin 1 2 end begin 3 end>; (say @i.grep(:k, 'begin').map(*+1) Z=> @i.grep(:k, 'end').map(*-1)).map({say .perl })

[14:13] <camelia> rakudo-moar 8c5af9b97: OUTPUT: Â«(1 => 2 5 => 5)â¤Bool::Trueâ¤Â»

[14:14] <jkramer> Ah I guess it doesn't :)

[14:14] <moritz> jkramer: try it with fewer characters first?

[14:14] <moritz> m: my @i = <begin 1 2 end begin 3 end>; (say @i.grep(:k, 'begin').map(*+1) Z @i.grep(:k, 'end').map(*-1)).map({say .perl })

[14:14] <camelia> rakudo-moar 8c5af9b97: OUTPUT: Â«((1 2) (5 5))â¤Bool::Trueâ¤Â»

[14:14] <jkramer> p6: '112112' ~~ m:ex/[ (\d ** 2..*) \d* ] ** 2..*/

[14:14] <camelia> rakudo-moar 8c5af9b97: ( no output )

[14:14] <moritz> m: my @i = <begin 1 2 end begin 3 end>; (say @i.grep(:k, 'begin').map(*+1) Z @i.grep(:k, 'end').map(*-1)).map({@i[&infix:<..>(|$_.list)]})

[14:14] <camelia> rakudo-moar 8c5af9b97: OUTPUT: Â«((1 2) (5 5))â¤Too few positionals passed; expected 2 arguments but got 1â¤  in block <unit> at <tmp> line 1â¤â¤Â»

[14:15] <jkramer> Oh wait that regex is broken anyway :D

[14:15] <timotimo> "memory allocation failed" is often the result of infinite recursion of some kind

[14:15] <moritz> m: my @i = <begin 1 2 end begin 3 end>; (say @i.grep(:k, 'begin').map(*+1) Z @i.grep(:k, 'end').map(*-1)).map({@i[.[0] .. .[1]]})

[14:15] <camelia> rakudo-moar 8c5af9b97: OUTPUT: Â«((1 2) (5 5))â¤Index out of range. Is: 1, should be in 0..0â¤  in block <unit> at <tmp> line 1â¤â¤Â»

[14:15] <moritz> :(

[14:17] <timotimo> moritz: why not Z.. actually? and then index into @i directly with the result?

[14:17] <timotimo> m: my @i = <begin 1 2 end begin 3 end>; (say @i.grep(:k, 'begin').map(*+1) Z.. @i.grep(:k, 'end').map(*-1)).map({@i[@$_]})

[14:17] <camelia> rakudo-moar 8c5af9b97: OUTPUT: Â«(1..2 5..5)â¤Â»

[14:18] <timotimo> m: my @i = <begin 1 2 end begin 3 end>; say (say @i.grep(:k, 'begin').map(*+1) Z.. @i.grep(:k, 'end').map(*-1)).map({@i[@$_]})

[14:18] <camelia> rakudo-moar 8c5af9b97: OUTPUT: Â«(1..2 5..5)â¤((1))â¤Â»

[14:18] <timotimo> m: my @i = <begin 1 2 end begin 3 end>; say (say @i.grep(:k, 'begin').map(*+1) Z.. @i.grep(:k, 'end').map(*-1)).map({say $_; @i[@$_]})

[14:18] <camelia> rakudo-moar 8c5af9b97: OUTPUT: Â«(1..2 5..5)â¤Trueâ¤((1))â¤Â»

[14:18] <timotimo> oh, haha

[14:18] <timotimo> m: my @i = <begin 1 2 end begin 3 end>; say (@i.grep(:k, 'begin').map(*+1) Z.. @i.grep(:k, 'end').map(*-1)).map({say $_; @i[@$_]})

[14:18] <camelia> rakudo-moar 8c5af9b97: OUTPUT: Â«1..2â¤5..5â¤((1 2) (3))â¤Â»

[14:18] <buggable> New CPAN upload: List-Util-0.0.1.tar.gz by ELIZABETH https://cpan.metacpan.org/authors/id/E/EL/ELIZABETH/Perl6/List-Util-0.0.1.tar.gz

[14:18] <timotimo> m: my @i = <begin 1 2 end begin 3 end>; say (@i.grep(:k, 'begin').map(*+1) Z.. @i.grep(:k, 'end').map(*-1)).map({@i[@$_]})

[14:18] <camelia> rakudo-moar 8c5af9b97: OUTPUT: Â«((1 2) (3))â¤Â»

[14:19] *** committable6 left
[14:19] *** committable6 joined
[14:19] *** ChanServ sets mode: +v committable6

[14:20] <jkramer> p6: '112112' ~~ m:ex/(\d ** 2..*) [\d* ($0)]+/

[14:20] <camelia> rakudo-moar 8c5af9b97: ( no output )

[14:21] <timotimo> m: my @i = <begin 1 2 end begin 3 end>; @i.grep('begin'|'end') Zeq |('begin', 'end') xx * ?? (@i.grep(:k, 'begin').map(*+1) Z.. @i.grep(:k, 'end').map(*-1)).map({@i[@$_]}) !! fail "malformed begin/end pairins"

[14:21] <camelia> rakudo-moar 8c5af9b97: OUTPUT: Â«Potential difficulties:â¤    Useless use of Zeq in sink contextâ¤    at <tmp>:1â¤    ------> 3nd begin 3 end>; @i.grep('begin'|'end') 7â5Zeq |('begin', 'end') xx * ?? (@i.grep(:â¤Â»

[14:21] <timotimo> m: my @i = <begin 1 2 end begin 3 end>; ([&&] @i.grep('begin'|'end') Zeq |('begin', 'end') xx *) ?? (@i.grep(:k, 'begin').map(*+1) Z.. @i.grep(:k, 'end').map(*-1)).map({@i[@$_]}) !! fail "malformed begin/end pairins"

[14:21] <camelia> rakudo-moar 8c5af9b97: ( no output )

[14:21] <timotimo> m: my @i = <begin 1 2 end begin 3 end>; say ([&&] @i.grep('begin'|'end') Zeq |('begin', 'end') xx *) ?? (@i.grep(:k, 'begin').map(*+1) Z.. @i.grep(:k, 'end').map(*-1)).map({@i[@$_]}) !! fail "malformed begin/end pairins"

[14:21] <camelia> rakudo-moar 8c5af9b97: OUTPUT: Â«((1 2) (3))â¤Â»

[14:21] <timotimo> m: my @i = <begin 1 2 begin 3 end end>; say ([&&] @i.grep('begin'|'end') Zeq |('begin', 'end') xx *) ?? (@i.grep(:k, 'begin').map(*+1) Z.. @i.grep(:k, 'end').map(*-1)).map({@i[@$_]}) !! fail "malformed begin/end pairins"

[14:21] <camelia> rakudo-moar 8c5af9b97: OUTPUT: Â«malformed begin/end pairinsâ¤  in block <unit> at <tmp> line 1â¤â¤Â»

[14:21] <jkramer> Any ideas why this doesn't match?

[14:22] <jkramer> Shouldn't it return both 11 and 112 twice each?

[14:22] *** ggoebel left
[14:23] <timotimo> you want :ex and :ov maybe?

[14:23] <timotimo> p6: '112112' ~~ m:ex:ov/(\d ** 2..*) [\d* ($0)]+/

[14:23] <camelia> rakudo-moar 8c5af9b97: ( no output )

[14:23] <timotimo> p6: say '112112' ~~ m:ex:ov/(\d ** 2..*) [\d* ($0)]+/

[14:23] <camelia> rakudo-moar 8c5af9b97: OUTPUT: Â«()â¤Â»

[14:23] <timotimo> p6: say '112112' ~~ m:ex/(\d ** 2..*) [\d* ($0)]+/

[14:23] <camelia> rakudo-moar 8c5af9b97: OUTPUT: Â«()â¤Â»

[14:24] <jkramer> Doesn't ex imply ov?

[14:24] <jkramer> > To find all possible matches of a regex â€“ including overlapping ones â€“ and several ones that start at the same position, use the :exhaustive (short :ex) adverb.

[14:25] <timotimo> ah

[14:25] <timotimo> p6: say '112112' ~~ rx/(\d ** 2..*) [\d* ($0)]+/

[14:25] <camelia> rakudo-moar 8c5af9b97: OUTPUT: Â«Nilâ¤Â»

[14:26] <timotimo> p6: say '112112' ~~ rx/(\d ** 2..*)/

[14:26] <camelia> rakudo-moar 8c5af9b97: OUTPUT: Â«ï½¢112112ï½£â¤ 0 => ï½¢112112ï½£â¤Â»

[14:26] <timotimo> p6: say '11112' ~~ rx/(\d ** 2..*) [($0)]+/

[14:26] <camelia> rakudo-moar 8c5af9b97: OUTPUT: Â«Nilâ¤Â»

[14:26] <timotimo> p6: say '11112' ~~ rx/(\d ** 2..*) [($0)]/

[14:26] <camelia> rakudo-moar 8c5af9b97: OUTPUT: Â«Nilâ¤Â»

[14:26] <timotimo> hm?

[14:27] <timotimo> p6: say '11112' ~~ rx/(\d **? 2..*) [\d*? ($0)]/

[14:27] <camelia> rakudo-moar 8c5af9b97: OUTPUT: Â«Nilâ¤Â»

[14:27] <jkramer> p6: '112112' ~~ m:ex/(\d ** 2..*) \d* $0/

[14:27] <camelia> rakudo-moar 8c5af9b97: ( no output )

[14:27] <jkramer> Hmm weird the versionwith $0 without parens works for me locally, just not with ($0)

[14:27] <timotimo> you're not outputting anything

[14:27] <timotimo> p6: say '112112' ~~ m:ex/(\d ** 2..*) \d* $0/

[14:27] <camelia> rakudo-moar 8c5af9b97: OUTPUT: Â«(ï½¢112112ï½£â¤ 0 => ï½¢112ï½£ ï½¢11211ï½£â¤ 0 => ï½¢11ï½£ ï½¢12112ï½£â¤ 0 => ï½¢12ï½£)â¤Â»

[14:28] <jkramer> Oh

[14:28] <jkramer> p6: say '112112' ~~ m:ex/(\d ** 2..*) \d* ($0)/

[14:28] <camelia> rakudo-moar 8c5af9b97: OUTPUT: Â«()â¤Â»

[14:28] <timotimo> oh

[14:28] <jkramer> Why doesn't $0 work with parens?

[14:28] <timotimo> because nested parens, i bet

[14:28] <timotimo> m: say 'aabbcde' ~~ m/(\w) $0 ((\w) $0)/

[14:28] <camelia> rakudo-moar 8c5af9b97: OUTPUT: Â«ï½¢aabbï½£â¤ 0 => ï½¢aï½£â¤ 1 => ï½¢bbï½£â¤  0 => ï½¢bï½£â¤Â»

[14:29] <timotimo> i should get waked up or something

[14:29] <timotimo> m: say 'aabbaaba' ~~ m/(\w) $0 [(\w) $0]/

[14:29] <camelia> rakudo-moar 8c5af9b97: OUTPUT: Â«ï½¢aabaï½£â¤ 0 => ï½¢aï½£â¤ 1 => ï½¢bï½£â¤Â»

[14:29] <timotimo> there you can see the difference more clearly; but most clearly if it's printed with proper newlines

[14:33] <timotimo> p6: say '112112' ~~ m:P5:ex/(\d{2,}) \d* ($1)/

[14:33] <camelia> rakudo-moar 8c5af9b97: OUTPUT: Â«()â¤Â»

[14:33] <timotimo> p6: say '112112' ~~ m:P5:ex/(\d{2,}) \d* ($0)/

[14:33] <camelia> rakudo-moar 8c5af9b97: OUTPUT: Â«()â¤Â»

[14:33] <timotimo> i wonder how we compile that

[14:33] <timotimo> p6: say '112112' ~~ m:P5:ex/(\d{2,}) \d* $0/

[14:33] <camelia> rakudo-moar 8c5af9b97: OUTPUT: Â«()â¤Â»

[14:36] <timotimo> jkramer: does that help?

[14:36] <timotimo> not the last three lines, of course

[14:36] <timotimo> those are just noise

[14:36] *** vichib left
[14:37] *** rindolf joined
[14:38] *** ggoebel joined
[14:38] <jkramer> timotimo: Yeah thanks, I found some kind of workaround using another parens around the whole thing: '112112' ~~ m:ex/((\d ** 2..*) \d* $0)+/

[14:38] *** cdg left
[14:40] <moritz> if you're already using :ex, why use the + inside the regex at all?

[14:41] <timotimo> p6: say '112112' ~~ m:P5:ex/(\d{2,}) \d* \1/

[14:41] <camelia> rakudo-moar 8c5af9b97: OUTPUT: Â«()â¤Â»

[14:41] <timotimo> how does p5 regex do backreferences to numbered captured groups again ...

[14:41] <jkramer> \1 :)

[14:42] <jkramer> I think

[14:42] *** aquila-chrysaeto joined
[14:42] <timotimo> right. $0 turned into an INTERPOLATE call in the :P5 regex i had up there

[14:43] *** ckraniak left
[14:43] <jkramer> moritz: 'cause I want to count the repetitions of the number, but I haven't quite figured out how to do this with the Match object I'm getting

[14:45] <moritz> jkramer: what problem are you trying to solve?

[14:46] *** aquila-chrysaeto left
[14:46] *** scimon left
[14:47] <jkramer> moritz: I want to find all numbers of 2+ digits in a string made of digits and the number of their occurances :)

[14:47] <jkramer> It's not a real problem, just a random programming practice I found somewhere to get used to Perl 6 :)

[14:48] <moritz> m: say '11211' ~~ m:ex/\d ** 2..* /

[14:48] <camelia> rakudo-moar 8c5af9b97: OUTPUT: Â«(ï½¢11211ï½£ ï½¢1121ï½£ ï½¢112ï½£ ï½¢11ï½£ ï½¢1211ï½£ ï½¢121ï½£ ï½¢12ï½£ ï½¢211ï½£ ï½¢21ï½£ ï½¢11ï½£)â¤Â»

[14:49] <moritz> m: say ('11211' ~~ m:ex/\d ** 2..* /).map(*.Str).Bag

[14:49] <camelia> rakudo-moar 8c5af9b97: OUTPUT: Â«Bag(11(2), 112, 1121, 11211, 12, 121, 1211, 21, 211)â¤Â»

[14:49] <timotimo> m: say '11211'.comb.rotor(2=>-1).>>join("").Bag

[14:49] <camelia> rakudo-moar 8c5af9b97: OUTPUT: Â«5===SORRY!5=== Error while compiling <tmp>â¤Missing dot on method callâ¤at <tmp>:1â¤------> 3say '11211'.comb.rotor(2=>-1).>>7â5join("").Bagâ¤    expecting any of:â¤        postfixâ¤Â»

[14:49] <timotimo> m: say '11211'.comb.rotor(2=>-1)>>.join("").Bag

[14:49] <camelia> rakudo-moar 8c5af9b97: OUTPUT: Â«Bag(11(2), 12, 21)â¤Â»

[14:49] <timotimo> jkramer: how's that?

[14:50] <moritz> timotimo: that's only 2 digit numbers, not 2+ digit numbers

[14:50] <timotimo> oh, of course!

[14:50] *** ckraniak joined
[14:50] <timotimo> m: say ('11211' ~~ rx:ex/\d ** 2..*/).Bag

[14:50] <camelia> rakudo-moar 8c5af9b97: OUTPUT: Â«5===SORRY!5=== Error while compiling <tmp>â¤Adverb ex not allowed on rxâ¤at <tmp>:1â¤------> 3say ('11211' ~~ rx:ex/\d ** 2..*/7â5).Bagâ¤Â»

[14:50] <timotimo> m: say ('11211' ~~ m:ex/\d ** 2..*/).Bag

[14:50] <camelia> rakudo-moar 8c5af9b97: OUTPUT: Â«Bag(ï½¢11211ï½£, ï½¢1121ï½£, ï½¢112ï½£, ï½¢11ï½£, ï½¢11ï½£, ï½¢1211ï½£, ï½¢121ï½£, ï½¢12ï½£, ï½¢211ï½£, ï½¢21ï½£)â¤Â»

[14:51] <timotimo> m: say ('11211' ~~ m:ex/\d ** 2..*/)>>.Str.Bag

[14:51] <camelia> rakudo-moar 8c5af9b97: OUTPUT: Â«Bag(11(2), 112, 1121, 11211, 12, 121, 1211, 21, 211)â¤Â»

[14:51] <timotimo> with the original regex implementaiton you had you also have the problem that the second time some two-digit thing appears, it'll be the start of another attempt again

[14:51] <timotimo> so you'll count everything multiple times

[14:52] <moritz> m: say bag '11211' ~~ m:ex/\d\d+/ # golfing!

[14:52] <camelia> rakudo-moar 8c5af9b97: OUTPUT: Â«Bag(ï½¢11211ï½£, ï½¢1121ï½£, ï½¢112ï½£, ï½¢11ï½£, ï½¢11ï½£, ï½¢1211ï½£, ï½¢121ï½£, ï½¢12ï½£, ï½¢211ï½£, ï½¢21ï½£)â¤Â»

[14:52] <moritz> m: say bag ~<< '11211' ~~ m:ex/\d\d+/ # golfing!

[14:52] <camelia> rakudo-moar 8c5af9b97: OUTPUT: Â«Bag(False)â¤Â»

[14:52] <moritz> m: say bag ~<<('11211' ~~ m:ex/\d\d+/)

[14:52] <camelia> rakudo-moar 8c5af9b97: OUTPUT: Â«Bag(11(2), 112, 1121, 11211, 12, 121, 1211, 21, 211)â¤Â»

[14:53] <timotimo> that looks nicer

[14:54] *** jdoege joined
[14:58] <jdoege> Good (whatever time of day it is wherever you may be). I have a question and i am hoping someone here may have an answer. I have a large grammar that is finally working really well. The last task I have for it is to ignore comments. My plan is to redefine the ws token to include a comment regex. However, to get started, I began by simply redefining the ws token to what I believe it already is: token ws { \s+ | <|w> }

[15:00] <jdoege> When I test my parser with this redefined ws token, it quickly fails on test cases it previously passed on when I would expect (nearly) identical behavior.

[15:00] <jdoege> Did I redefine ws incorrectly?

[15:01] <raschipi> Did you use the non-capturing form? <.ws>

[15:01] <jdoege> Also, I notice that the parser now explicitly parses ws (as seen in Grammar::Trace output) whereas previously it was implicit and invisible. Is that expected?

[15:02] <jdoege> I never reference ws directly. This is just implicit rule usage.

[15:02] <perlpilot> that last bit is interesting

[15:03] <raschipi> So, after declaring it you lost the magic, is that it?

[15:03] <jdoege> Yup.

[15:06] *** Phlogistique left
[15:08] *** Actualeyes joined
[15:09] *** Grauwolf_ left
[15:10] *** Grauwolf joined
[15:16] *** lancew joined
[15:18] <jdoege> Interesting. Despite the documentation saying that ws matches \s+ or <|w>, there is an example of redefining ws to not match vertical whitespace that looks like this: token ws { <!ww> \h* } When I change my definition to token ws { <!ww> \s* } my parser resumes working. A bit of documentation clarification/correction may be in order. I am not sure I understand the distinction between these two definitions.

[15:19] *** FROGGS joined
[15:22] *** El_Che joined
[15:29] *** Actualey` joined
[15:29] *** lancew left
[15:31] *** Actualeyes left
[15:45] *** aquila-chrysaeto joined
[15:46] *** ckraniak left
[15:49] *** eliasr joined
[15:50] *** aquila-chrysaeto left
[15:51] <jkramer> timotimo: Nice, I didn't think of that, I focused too much on doing it all with a regex. :) I ended up with this one-liner (some formatting of the result included):

[15:51] <jkramer> .match(/(..+)/, :ex)>>.Str.Bag.pairs.grep(*.value > 1).map(*.kv.join(':')).join(' ').say for $*IN.lines;

[15:52] <lizmat> jkramer: I think you can leave out the .pairs there

[15:53] <jkramer> lizmat: True, thanks :)

[15:55] <jkramer> Saved a few more bytes by replacing .join(' ') with .Str :)

[15:55] <timotimo> m: my $b = bag <hi hi hi bye bye lo>; say $b >>->> 1

[15:55] <camelia> rakudo-moar a0486e548: OUTPUT: Â«Cannot modify an immutable Bag (Bag())â¤  in block <unit> at <tmp> line 1â¤â¤Â»

[15:55] <timotimo> m: my $b = bag <hi hi hi bye bye lo>

[15:55] <camelia> rakudo-moar a0486e548: ( no output )

[15:56] <timotimo> m: my $b = <hi hi hi bye bye lo>.BagHash; say $b; say $b >>->> 1; say $b

[15:56] <camelia> rakudo-moar a0486e548: OUTPUT: Â«BagHash(bye(2), hi(3), lo)â¤BagHash(bye, hi(2))â¤BagHash(bye(2), hi(3), lo)â¤Â»

[15:56] <timotimo> m: my $b = <hi hi hi bye bye lo>.BagHash; say $b; say ($b >>->> 1) >>+>> 1; say $b

[15:56] <camelia> rakudo-moar a0486e548: OUTPUT: Â«BagHash(bye(2), hi(3), lo)â¤BagHash(bye(2), hi(3))â¤BagHash(bye(2), hi(3), lo)â¤Â»

[15:56] <timotimo> a nice, round-about way to filter out things that only have one entry in the bag

[15:57] <lizmat> sometimes I think a dedicated method for Bags would help

[16:00] *** cdg joined
[16:01] <timotimo> dedicated what method?

[16:02] *** cdg left
[16:02] *** cdg joined
[16:03] *** cdg_ joined
[16:04] <lizmat> for grepping out items by frequency

[16:04] <lizmat> the .grep is general, so it goes out and creates Pairs, and take the value, etc. etc.

[16:04] <lizmat> while a dedicated method wouldn't need to do all of that

[16:05] <lizmat> Bag.frequency(1) would give all elements with a frequence of 1

[16:05] <lizmat> Bag.frequency(* > 1) would give all elements with a frequence > 1

[16:05] <lizmat> *frequency

[16:06] <Ulti> by elements do you mean just the keys or the pairs?

[16:07] <Ulti> this is a nice idea for if you're using bag models for stats

[16:07] *** cdg left
[16:07] <lizmat> just the keys

[16:12] *** squashable6 joined
[16:17] *** john51 left
[16:18] *** vichib joined
[16:18] *** vichib left
[16:18] *** vichib joined
[16:20] *** esh joined
[16:21] *** esh left
[16:23] *** wamba left
[16:23] *** john51 joined
[16:25] *** vichib left
[16:26] *** lelf` joined
[16:27] *** esh joined
[16:27] *** vichib joined
[16:28] *** vichib left
[16:28] * [Coke] had to rediscover Test::More in p5 today, whoops.

[16:28] *** lelf left
[16:29] *** vichib joined
[16:29] <[Coke]> "why aren't I getting test descriptions!?" /me's brain full

[16:34] *** domidumont joined
[16:34] <moritz> prove -v ?

[16:35] *** zakharyas left
[16:35] <[Coke]> moritz: no, because I was using Perl 5's "Test", not "Test::More"

[16:38] *** ckraniak joined
[16:38] <moritz> aaaarg

[16:40] <[Coke]> Wonder if it'd be worth trying to convert this to Inline::Perl5 (need WWW::Mechanize).

[16:44] *** esh left
[16:46] *** esh joined
[16:50] * lizmat notes WWW::Mechanize is really needed

[16:55] *** cdg joined
[16:55] *** abraxxa left
[16:57] *** cdg__ joined
[16:57] *** domidumont left
[16:58] *** cdg left
[16:58] *** cdg_ left
[16:58] *** hoelzro joined
[17:02] *** troys joined
[17:03] *** vichib left
[17:05] <El_Che> lizmat: or something minimalistic in the style of https://github.com/headzoo/surf

[17:09] *** khw joined
[17:22] *** coverable6 left
[17:22] *** benchable6 left
[17:23] *** coverable6 joined
[17:23] *** ChanServ sets mode: +v coverable6

[17:23] *** benchable6 joined
[17:23] *** ChanServ sets mode: +v benchable6

[17:26] *** domidumont joined
[17:30] *** dakkar left
[17:37] *** cdg joined
[17:38] *** cdg__ left
[17:39] *** bisectable6 left
[17:39] *** bisectable6 joined
[17:39] *** ChanServ sets mode: +v bisectable6

[17:44] *** wamba joined
[17:44] *** zakharyas joined
[17:52] *** raschipi_ joined
[17:53] *** itaipu left
[17:53] *** raschipi left
[17:54] *** ckraniak left
[18:06] *** leah2 left
[18:07] *** darutoko left
[18:13] *** leah2 joined
[18:32] *** st_elmo joined
[18:46] *** |oLa| joined
[18:49] *** bdmatatu joined
[18:49] *** Kaiepi left
[18:51] <bdmatatu> Hi folks, is there a p6 equivalent to Perl 5's 'do FILE'?

[18:52] *** Kaiepi joined
[18:53] <raschipi_> run?

[18:54] <DrForr> You probably want EVALFILE, according to the 5to6 docs.

[18:54] <bdmatatu> I think that runs it in another process...I'm thinking like 'use' but for something that's not *.pm or *.pm6

[18:54] <bdmatatu> oh, thanks DrForr

[18:55] *** Kaiepi left
[18:55] *** Kaiepi joined
[18:59] <lizmat> bdmatatu: EVAL slurp $file

[19:01] <bdmatatu> Great, that works too

[19:02] *** ggoebel left
[19:02] <lizmat> FWIW, EVALFILE is better, and doesn't run in another process

[19:02] *** itaipu joined
[19:02] <lizmat> in fact, it is basically implemented as EVAL slurp $fule

[19:02] <lizmat> $file

[19:04] <bdmatatu> I was kind of hoping it might also be possible to do that in the current lexical scope (e.g. any lexical vars in FILE would still be visible)

[19:05] *** |oLa| left
[19:07] <lizmat> they are, if you use EVALFILE

[19:07] <bdmatatu> oh!

[19:07] <El_Che> EVALFILE will be the title of the first security trolling talk about Perl 6 ;)

[19:08] <lizmat> bdmatatu: if you put a "say $a" in a file "foo", and then do "my $a = 42; EVALFILE 'foo', it *will* say "42"

[19:09] <bdmatatu> Okay, I was thinking about declaring 'my $a' in file foo and then trying to use it after doing an EVALFILE

[19:09] <bdmatatu> I could see how that would be bad securitywise

[19:10] <lizmat> you cannot change a pad once it is executing

[19:11] <El_Che> bdmatatu: isn't a yaml or json file an alternative for declaring variables?

[19:12] <[Coke]> lizmat: I had someone actually give me a hard time about using perl 5 on this (even though I am the only one who writes one offs in perl here. He was suprised to see me use 5 instead of 6)

[19:12] <lizmat> well, yes

[19:12] <[Coke]> (he was just teasing, but I still felt like I cheated. :)

[19:12] * lizmat looks sternly at [Coke] 

[19:13] <DrForr> bdmatatu: Look at one of the config modules, or even (like others say) a .json or .yaml file - Letting configuration files run arbitrary code can get ugly.

[19:13] <bdmatatu> Yeah I know it's ugly, but can be really handy for debugging and experimenting

[19:13] <timotimo> or use a programming language that's made for config files: Lua

[19:14] <El_Che> bdmatatu: It's not much effort to put the contents of a yaml or json file in an hash

[19:14] <lizmat> m: my $a = 42 but role { method foo { "foo" } }; say $a; say $a.foo  # perhaps another way to add debugging info to values ?

[19:14] <camelia> rakudo-moar d30e5b1e3: OUTPUT: Â«42â¤fooâ¤Â»

[19:15] *** troys is now known as troys_

[19:15] <bdmatatu> The idea is that I want to load a script from a repl session and look at all the variables that were declared

[19:15] <lizmat> m: role foo { has $.foo }; my $a = 42 but foo("bar"); say $a; say $a.foo  # another way

[19:15] <camelia> rakudo-moar d30e5b1e3: OUTPUT: Â«42â¤barâ¤Â»

[19:17] *** esh left
[19:17] <El_Che> lizmat, AlexDaniel` , jnthn: 2017.12 rakudo linux packages are being built. Thx for fixing the bug

[19:17] *** esh joined
[19:17] <lizmat> El_Che++  # perseverance!

[19:17] *** zakharyas left
[19:18] <El_Che> lizmat: people call other names referring to that :)

[19:18] <TEttinger> El_Che: tenacity?

[19:18] <El_Che> pain in the ass

[19:18] <El_Che> :)

[19:19] <TEttinger> force of will? Nietzche's usage of a similar term in German?

[19:20] <El_Che> don't go there :)

[19:20] *** ggoebel joined
[19:22] <TEttinger> persistence

[19:22] <TEttinger> :)

[19:26] *** ckraniak joined
[19:29] *** esh left
[19:30] *** esh joined
[19:31] *** esh left
[19:33] *** raschipi_ left
[19:33] *** esh joined
[19:35] *** esh left
[19:36] <tobs> I'd like to react whenever $*IO.lines but that code seems to want to slurp .lines. Iterating with 'for' works but I like Supply as a conceptual wrapper and also need multiple taps.

[19:36] *** esh joined
[19:36] <tobs> Can someone help? A Supply of a lazy Seq seems like something natural

[19:38] <jnthn> Try react whenever Supply.from-list($*IO.lines) { }

[19:39] *** greppable6 joined
[19:39] *** ChanServ sets mode: +v greppable6

[19:39] <tobs> That isn't interactive either. It waits until I Ctrl+D (Rakudo 2017-07 still, if that makes a difference)

[19:40] *** japhb joined
[19:41] <tobs> s/$*IO/$*IN/ specifically

[19:42] *** esh left
[19:43] *** esh joined
[19:46] <jnthn> Hm, curious, if I do perl6 -e 'react whenever Supply.from-list($*IN.lines) { .say }' then type foo and press enter, it immediately outputs foo

[19:47] <tobs> Not here, with the same line. Updating Rakudo can't hurt (I hope)

[19:47] <lizmat> STDIN isn't buffered, is it ?

[19:47] <jnthn> It's either fixed in a more recent version or it's platform sensitive; handy I have 2017.12 on Linux (works) and 2017.07 on Windows (doesn't)

[19:48] <tobs> 2017.07 on Linux here

[19:48] <jnthn> OK, then it's most probably a fix since then

[19:48] <El_Che> 2017.12 rpms/devs/apk should be out in some minutes

[19:48] <jnthn> oh, also maybe try: react whenever Supply.from-list($*IN.lines, :scheduler($*SCHEDULER)) { .say }

[19:50] <tobs> jnthn: that works

[19:51] <jnthn> OK, then I can guess what change(s) fixed it :)

[19:53] *** domidumont left
[20:00] *** dct left
[20:09] <tobs> (yes, 2017.12 works here too)

[20:10] *** st_elmo left
[20:24] *** dct joined
[20:27] <El_Che> https://github.com/nxadm/rakudo-pkg/releases/tag/v2017.12

[20:28] <El_Che> 2017.12 packages released

[20:29] *** itaipu left
[20:30] <moritz> El_Che++

[20:30] *** Zoffix joined
[20:30] <Zoffix> m: &postcircumfix:<[ ]>()

[20:30] <camelia> rakudo-moar d30e5b1e3: OUTPUT: Â«WARNINGS for <tmp>:â¤Useless use of constant value [ ] in sink context (lines 1, 1)â¤Cannot resolve caller postcircumfix:<[ ]>(...); none of these signatures match:â¤    (\SELF, Any:U $type, |c is raw)â¤    (\SELF, int $pos)â¤    (\SELF, int $posâ€¦Â»

[20:30] <Zoffix> m: &postcircumfix:<[ ]>(1, 0)

[20:30] <camelia> rakudo-moar d30e5b1e3: OUTPUT: Â«WARNINGS for <tmp>:â¤Useless use of constant value [ ] in sink context (lines 1, 1)â¤Â»

[20:31] <Zoffix> I'm debugging that warning.... Does this bit of QAST look like it should be there? https://gist.github.com/zoffixznet/549227cb7720ed2237369e33812dcac2#file-gistfile1-txt-L53-L57

[20:31] <Zoffix> Nothing is there for `infix:<+>` and I tried removing that bit, but now the code doesn't find the right routine name. Wondering if that bit is supposed to be there of if I'm removing it too soon

[20:33] *** comborico1611 joined
[20:33] <moritz> m: &circumfix:<[ ]>(1, 0)

[20:33] <camelia> rakudo-moar d30e5b1e3: OUTPUT: Â«WARNINGS for <tmp>:â¤Useless use of constant value [ ] in sink context (lines 1, 1)â¤Cannot resolve caller circumfix:<[ ]>(Int, Int); none of these signatures match:â¤    ()â¤    (Iterable:D \iterable)â¤    (Mu \x)â¤  in block <unit> at <tmp> liâ€¦Â»

[20:33] <moritz> Zoffix: ^^ do you mean that code?

[20:34] <moritz> 'cause I only found a circumfix, not a postcircumfix, in that QAST tree

[20:34] <moritz> or is that the point?

[20:34] <comborico1611> Looking for an emacs tip.  CHARACTER-HERE CURSOR-HERE.   How do I drop character-here to a new line and preserve its  indentation?

[20:34] <Zoffix> moritz: yeah, that code, with &circumfix

[20:34] <comborico1611> and preserve its*

[20:35] <Zoffix> moritz: no, the point is what appears two be two Stmts; one empty and one is just a `call &infix:<,>`, which I believe is causing the warning. They don't seem to be used for anything, are they?

[20:36] *** cdg left
[20:36] <moritz> Zoffix: I wonder if the two elements of the infix:<,> call correspond to the [ and the ] from the routine name

[20:36] <Zoffix> moritz: yeah. And it's made here: https://github.com/rakudo/rakudo/blob/master/src/Perl6/Actions.nqp#L2532

[20:37] <Zoffix> Well, s/yeah/I think so/;

[20:38] * Zoffix recompiles and dumps the values

[20:43] <Zoffix> damn, forgot .ast call; /me does recompiles again

[20:45] *** awwaiid joined
[20:47] <Zoffix> moritz: yeah, it's the circumfix: https://gist.github.com/zoffixznet/c4b90700bb43d660992f99bdfeb5336a

[20:47] <Zoffix> the [ and ] chars for it

[20:48] *** mempko left
[20:48] <Zoffix> My next best guess is something rips out ASTs for the colonpair with WVal(Str) for `infix:<+>`, but it forgets to handle the more complex colonpair for circimfix. Just need to find that rip-out bity

[20:48] <Zoffix> s/y$//

[20:49] * Zoffix relocates but will read replies, if any

[20:53] *** pilne joined
[20:54] <timotimo> DrForr: you may want to delete that comment on your blog, the one that advertises a lot of liposuction service related addresses?

[20:54] <timotimo> actually, every one of those links points at the same url

[20:57] *** itaipu joined
[20:58] *** dct left
[20:59] *** evalable6 left
[20:59] *** troys_ is now known as troys

[20:59] *** evalable6 joined
[21:01] *** rindolf left
[21:03] * masak .oO( those ads suck )

[21:03] *** Hotkeys joined
[21:05] *** dct joined
[21:11] *** bdmatatu left
[21:12] *** kerframil joined
[21:15] *** rindolf joined
[21:22] *** bwisti joined
[21:22] *** itaipu left
[21:24] *** perlpilot left
[21:24] *** itaipu joined
[21:32] *** comborico1611 left
[21:34] *** itaipu left
[21:43] *** dct left
[21:43] *** rindolf left
[21:45] *** dct joined
[21:48] *** japanoise left
[21:54] *** troys is now known as troys_

[21:55] *** itaipu joined
[21:58] *** cdg joined
[22:00] <timotimo> oooooh

[22:10] *** japanoise joined
[22:12] *** brrt joined
[22:12] *** syntaxman joined
[22:12] *** syntaxman is now known as Guest14653

[22:19] *** espadrine_ joined
[22:29] *** margeas is now known as markong

[22:32] *** statisfiable6 left
[22:32] *** releasable6 left
[22:32] *** releasable6 joined
[22:32] <timotimo> hmm. turning a for @plan { } with "when" statements inside into a while @plan with a $_ = @plan.shift in front makes when target the block outside of that

[22:32] *** statisfiable6 joined
[22:32] *** reportable6 left
[22:32] <timotimo> not surprising, but annoying in this case

[22:32] *** reportable6 joined
[22:37] *** dct left
[22:48] <buggable> New CPAN upload: List-Util-0.0.2.tar.gz by ELIZABETH https://cpan.metacpan.org/authors/id/E/EL/ELIZABETH/Perl6/List-Util-0.0.2.tar.gz

[22:49] * Zoffix is disappointed Perl 5's Util vs Utils confusion made it into Perl 6

[22:50] <Zoffix> huh... 

[22:50] <Zoffix> We have both List::Util and List::Utils? :S

[22:52] * Zoffix assumes the singular is the fruit of Project Camelia

[22:53] *** Zoffix left
[22:55] <lizmat> Zoffix: List::Util is a more or less straight port of Perl 5's List::Util

[22:55] <lizmat> colomon's List::Utils is a nice collection, but has no bearing on the Perl 5 version

[22:56] * lizmat goes to bed: enough porting for today

[22:58] <buggable> New CPAN upload: Sub-Name-0.0.4.tar.gz by ELIZABETH https://cpan.metacpan.org/authors/id/E/EL/ELIZABETH/Perl6/Sub-Name-0.0.4.tar.gz

[23:14] *** cdg left
[23:15] *** cdg joined
[23:19] *** cdg left
[23:22] *** daxim joined
[23:25] *** troys_ is now known as troys

[23:27] *** cdg joined
[23:32] *** cdg left
[23:46] *** brrt left
[23:53] <timotimo> m: my $foo; my $p1 = a => $foo; my $p2 = a => $foo => 1; $foo = 99; say $p1; say $p2;

[23:53] <timotimo> something wrong with camelia?

[23:53] <timotimo> c: HEAD my $foo; my $p1 = a => $foo; my $p2 = a => $foo => 1; $foo = 99; say $p1; say $p2;

[23:53] <timotimo> evalable6: say "hi"

[23:53] <timotimo> what's happening

[23:53] <camelia> rakudo-moar 0be9d5520: OUTPUT: Â«a => 99â¤a => (Any) => 1â¤Â»

[23:53] <committable6> timotimo, Â¦HEAD(0be9d55): Â«a => 99â¤a => (Any) => 1â¤Â»

[23:53] <evalable6> timotimo, rakudo-moar 0be9d5520: OUTPUT: Â«hiâ¤Â»

[23:53] <timotimo> OK

[23:53] <timotimo> so, is this by design?

