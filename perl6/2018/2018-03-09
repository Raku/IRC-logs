[00:11] *** Guest53986 left
[00:16] *** AlexDaniel left
[00:16] *** Alchemy joined
[00:16] *** Alchemy is now known as Guest50956

[00:18] *** rouking left
[00:25] *** rouking joined
[00:25] *** jimav joined
[00:27] *** daemon left
[00:27] <jimav> Hello World...   Is it possible to disallow undeclared named args to methods?  By default $obj.meth(misspelled=>42) succeeds silently.

[00:28] *** skids joined
[00:28] *** pharv left
[00:29] <rouking> When I try to install rakudo-star to target the jvm (and moarvm), `make install` tries to cd into modules/panda, which doesn't exist. Any clues? Is this referring to the deprecated module manager?

[00:29] *** Guest50956 left
[00:29] *** Guest50956 joined
[00:30] *** Guest50956 is now known as daemon

[00:30] <jimav> m: https://pastebin.com/raw/gPdbrNYU

[00:30] <camelia> rakudo-moar 3fb06bb05: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Confused␤at <tmp>:1␤------> 3https:7⏏5//pastebin.com/raw/gPdbrNYU␤    expecting any of:␤        colon pair␤»

[00:31] <jimav> Hmm I thought that would work...

[00:31] <buggable> New CPAN upload: Concurrent-Trie-1.0.tar.gz by JNTHN https://cpan.metacpan.org/authors/id/J/JN/JNTHN/Perl6/Concurrent-Trie-1.0.tar.gz

[00:32] *** Zoffix joined
[00:34] <Zoffix> Is there some sane way to in-place replace an attribute in a class to a native type during instantiation? class Foo { has $.foo } having foo a native int if `Foo.new: :42foo` is called or having it an Int if `Foo.new: :44000000000000000000000000000000000foo` is called? I don't want to have more than one attr in the class

[00:35] <Zoffix> (kinda clutching at straws with this idea, but figured I'd ask anyway)

[00:35] <MasterDuke> m: class A { method foo(*%n where !%n) { say "here" }; }; say A.foo(method=>42)

[00:35] <camelia> rakudo-moar 3fb06bb05: OUTPUT: «Constraint type check failed in binding to parameter '%n'; expected anonymous constraint to be met but got Hash (${:method(42)})␤  in method foo at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[00:36] <MasterDuke> jimav: ^^^ like that perhaps?

[00:37] <Kaiepi> how can i write the proto method for this to work? when i try calling Net::LibIDN::TLD.check_8z('com', $errpos, $code), it expects a Positional as the third argument https://hastebin.com/etuzeqonit.pl

[00:38] <jnthn> Zoffix: No; numerous things depend on an attribute's kind being stable.

[00:38] <Zoffix> rouking: presumably it's a bug you could report ( https://github.com/rakudo/star/issues ).

[00:38] <jnthn> Zoffix: for a given type, that is

[00:38] <Zoffix> jnthn: thanks.

[00:38] <Kaiepi> nm, proto method check_8z(Str, Int, | --> Bool) works

[00:39] <jnthn> Zoffix: Role and then two classes implementing it, perhaps?

[00:41] *** pharv joined
[00:42] <Zoffix> Yeah, that's what I'm gonna go with.

[00:43] <Zoffix> Well, draft at least. Go run by TimToady first to see how he feels about MidRat (and likely MidRatStr) for Rat/FatRat allomorph, 'cause I'm not really a fan of making RatStr doing that job.

[00:43] <Zoffix> s/Go/Gonna/;

[00:44] <Zoffix> trial impl appears to work, but I just can see people complaining about proliferation of Numeric/Rational types :}

[00:45] <Zoffix> (and I don't wanna lock Rat to full Int denominator for this purpose, 'cause then we miss out on any potential wins for native-type denominators)

[00:47] *** pharv left
[00:50] <Zoffix> rouking: submitted a potential fix: https://github.com/rakudo/star/pull/109

[00:54] *** kaare__ is now known as kaare_

[00:55] * jnthn wanders off to sleep

[00:56] *** pierre joined
[00:57] <Zoffix> m: sub is-empty { %^_ and die "Unknown named args: %_.keys().sort().map('"'~*~'"')"; }; class Foo { method xxx(:$argname) { is-empty %_; say "xxx called" } };Foo.xxx(misspelled => 42);

[00:57] <camelia> rakudo-moar 3fb06bb05: OUTPUT: «Unknown named args: "misspelled"␤  in sub is-empty at <tmp> line 1␤  in method xxx at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[00:58] *** pharv joined
[00:58] *** reportable6 left
[00:58] *** reportable6 joined
[00:58] <Zoffix> m: sub is-empty { %^_ and die "Unknown named args: %_.keys().sort().map('"'~*~'"')"; }; class Foo { method xxx(:$argname, *%_ where &is-empty) {say "xxx called" } };Foo.xxx(misspelled => 42);

[00:58] <camelia> rakudo-moar 3fb06bb05: OUTPUT: «Unknown named args: "misspelled"␤  in sub is-empty at <tmp> line 1␤  in method xxx at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[01:05] <Zoffix> m: sub trait_mod:<is> (Routine:D \r, :$locked!) {  r.wrap: -> *%_, | { %_{r.signature.params.grep(*.named).map: *.usage-name}:delete; %_ and die "Unknown named args: %_.keys().sort().map('"'~*~'"')"; }}; class Foo { method bar(:$meows) is locked {} }.bar: :42meows

[01:05] <camelia> rakudo-moar 3fb06bb05: ( no output )

[01:05] <Zoffix> m: sub trait_mod:<is> (Routine:D \r, :$locked!) {  r.wrap: -> *%_, | { %_{r.signature.params.grep(*.named).map: *.usage-name}:delete; %_ and die "Unknown named args: %_.keys().sort().map('"'~*~'"')"; }}; class Foo { method bar(:$meows) is locked {} }.bar: :42meowss

[01:05] <camelia> rakudo-moar 3fb06bb05: OUTPUT: «Unknown named args: "meowss"␤  in block  at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[01:05] <Zoffix> hehe, neat :)

[01:06] <Zoffix> oh, forgot to nextsame outta the wrap

[01:06] <Zoffix> m: m: sub trait_mod:<is> (Routine:D \r, :$locked!) {  r.wrap: sub (*%_, |) { %_{r.signature.params.grep(*.named).map: *.usage-name}:delete; %_ and die "Unknown named args: %_.keys().sort().map('"'~*~'"')"; nextsame }}; class Foo { method bar(:$meows) is locked {say "we're in!"} }.bar: :42meows

[01:06] <camelia> rakudo-moar 3fb06bb05: OUTPUT: «we're in!␤»

[01:06] <Zoffix> m: m: sub trait_mod:<is> (Routine:D \r, :$locked!) {  r.wrap: sub (*%_, |) { %_{r.signature.params.grep(*.named).map: *.usage-name}:delete; %_ and die "Unknown named args: %_.keys().sort().map('"'~*~'"')"; nextsame }}; class Foo { method bar(:$meows) is locked {say "we're in!"} }.bar: :42meowss

[01:06] <camelia> rakudo-moar 3fb06bb05: OUTPUT: «Unknown named args: "meowss"␤  in sub  at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[01:07] *** Zoffix left
[01:18] *** vike left
[01:21] *** pharv left
[01:22] *** pierre left
[01:22] *** vike joined
[01:22] *** pharv joined
[01:28] *** pharv left
[01:34] *** pierre joined
[01:40] *** trnh joined
[01:41] *** pierre left
[01:47] *** trnh left
[01:48] *** et09 joined
[01:48] <et09> there was some cool new technique perl 6 uses for inheritance, what was it again?

[01:50] *** pierre joined
[01:52] *** Zoffix joined
[01:53] <Zoffix> et09: no idea... do you mean roles (aka traits in some other languages). Far from new.

[01:53] <et09> i guess so, hm

[01:54] <et09> i thought there was something cooler

[01:54] <Zoffix> m: class A {}; class B {}; class C {}; class D {}; class E {}; class K1 is A is B is C {}; class K2 is D is B is E {}; class K3 is D is A {}; class Z is K1 is K2 is K3 {}; say Z.^mro;

[01:54] <camelia> rakudo-moar ec5edcaec: OUTPUT: «((Z) (K1) (K2) (K3) (D) (A) (B) (C) (E) (Any) (Mu))␤»

[01:54] <Zoffix> This is the standard inheritance we have; the C3 resolution

[01:54] <et09> what's the very last thing mean, ,say Z.^mro?

[01:54] *** pierre left
[01:55] <Zoffix> et09: `$foo.^bar($ber)` is short for `$foo.HOW.bar($foo, $ber)` which is a method call on the metaobject

[01:55] <Zoffix> m: say True but False

[01:55] <camelia> rakudo-moar ec5edcaec: OUTPUT: «False␤»

[01:55] <et09> what is HOW ?

[01:55] <Zoffix> ^ we also have that; mix-in-a-role-into-an-object thing; No idea what other "cool" things you could be talking about :)

[01:55] <et09> oh sorry

[01:56] <Zoffix> et09: .HOW gives the metaobject responsible for the object

[01:56] <et09> phew

[01:56] <Zoffix> m: put 42 but 'forty-two'

[01:56] <camelia> rakudo-moar ec5edcaec: OUTPUT: «forty-two␤»

[01:56] <et09> i hate how every language has its own terms for syntax

[01:56] <Zoffix> :)

[01:57] <Zoffix> "metaclass"? I think that's what Python uses too

[01:57] <et09> i guess that's vaguely like a haskell typeclass

[01:58] <et09> i don't know python that well

[02:03] <et09> what's the 10k foot view of perl6 outlook, what do you think

[02:03] <et09> it fascinates me a little but feel scared to use it at work

[02:06] <Zoffix> I'm too deep in to have a clear view, even from 10k foot, but I if performance gets better the outlook would be good. Currently we win in saving programmer's time; once we also start saving computer time, the choice to use the language would be more enticing.

[02:07] <Zoffix> Current state is A LOT better than in 2016. I recall being frustrated hitting compiler bugs any time I tried to write a program. Now, it's mostly smooth sailing.

[02:07] <et09> what's an example of really great elegant perl6 code

[02:07] <Zoffix> m: dd FatRat.new(1,2) + 0e0;

[02:07] <camelia> rakudo-moar ec5edcaec: OUTPUT: «0.5e0␤»

[02:08] <Zoffix> Hm, I thought FatRats were the most infectious of types and kinda expected above to give me a FatRat.

[02:08] <et09> wow

[02:08] *** pierre joined
[02:09] *** releasable6 left
[02:10] *** releasable6 joined
[02:10] <Zoffix> et09: hmm, that's a bit of a vague question. I think one of the programs I wrote that I was really impressed with the language was my Z-Script tool to assist with builds for a project. It has a ton of commads, but it was supper-fast to write them all thanks to automatic help USAGE message generation and multi-dispatch on sub MAIN: https://github.com/zoffixznet/z/blob/master/bin/z (and rest of code is in

[02:10] <Zoffix> https://github.com/zoffixznet/z/blob/master/lib/RDev.pm6 )

[02:10] <Zoffix> et09: if I had to pick the quintessential example of elegant piece of perl 6 code it'd be counting letters/chars in a sentence

[02:11] <Zoffix> m: say "This is some sentence".comb.Bag

[02:11] <camelia> rakudo-moar ec5edcaec: OUTPUT: «Bag( (3), T, c, e(4), h, i(2), m, n(2), o, s(4), t)␤»

[02:11] <Zoffix> .Bag is a "count this stuff" sort of type

[02:12] <et09> m: "foo bar bag".comb(/a-h/)

[02:12] <camelia> rakudo-moar ec5edcaec: OUTPUT: «5===SORRY!5===␤Unrecognized regex metacharacter - (must be quoted to match literally)␤at <tmp>:1␤------> 3"foo bar bag".comb(/a7⏏5-h/)␤Unable to parse regex; couldn't find final '/'␤at <tmp>:1␤------> 3"foo bar bag".comb(/a-7…»

[02:12] <et09> m: "foo bar bag".comb(/[a-h]/)

[02:12] <camelia> rakudo-moar ec5edcaec: OUTPUT: «5===SORRY!5===␤Unrecognized regex metacharacter - (must be quoted to match literally)␤at <tmp>:1␤------> 3"foo bar bag".comb(/[a7⏏5-h]/)␤Unable to parse expression in metachar:sym<[ ]>; couldn't find final ']' (corresponding starter …»

[02:13] *** pierre left
[02:13] <timotimo> perl6 regex syntax is different, you need to spell it <[a..h]>

[02:13] <et09> whaaat

[02:13] <Zoffix> et09: and for a larger piece that I consider elegant, but a tad dirty is ignore/admin feature for my bot. It creates a subset of a generic IRC::Client message that matches the host against hosts in a config file and multi-dispatch on methods for event handling just automagically receives the messages from right users:

[02:13] <Zoffix> https://github.com/zoffixznet/perl6-ZofBot/blob/master/lib/ZofBot/Plugin/IgnoreList.pm6#L6-L21

[02:13] <et09> m: "foo bar bag".comb(/[a..h]/)

[02:13] <camelia> rakudo-moar ec5edcaec: ( no output )

[02:13] <timotimo> m: "foo bar bag".comb(/<[a..h]>/).say

[02:13] <camelia> rakudo-moar ec5edcaec: OUTPUT: «(f b a b a g)␤»

[02:13] <timotimo> and you need to .say at the end or say in front so it'll output anything

[02:13] <et09> that's amazing

[02:13] <et09> m: "foo bar bag".comb(/[a..h]/).reverse

[02:13] <camelia> rakudo-moar ec5edcaec: ( no output )

[02:13] <et09> m: say "foo bar bag".comb(/[a..h]/).reverse

[02:13] <camelia> rakudo-moar ec5edcaec: OUTPUT: «()␤»

[02:14] <Zoffix> et09: we invented a new regex language. It's a lot more readable than the status quo PCRE stuff (e.g. (?<=foo) is spelled <after foo>)

[02:14] <timotimo> you forgot the < > around it

[02:14] <et09> m: say "foo bar bag".comb(</[a..h]/>).reverse

[02:14] <camelia> rakudo-moar ec5edcaec: OUTPUT: «()␤»

[02:14] <Zoffix> Though Perl 5 regexes are available too if you use the :P5 adverb

[02:14] <timotimo> https://perl6.org/archive/doc/design/apo/A05.html - this is a (very old) document explaining the ideas behind the regex syntax and semantics redesign

[02:14] <et09> that's mind boggling

[02:14] <Zoffix> m: dd "foo bar bag".comb(rx:P5/[a-h]/) 

[02:14] <camelia> rakudo-moar ec5edcaec: OUTPUT: «("f", "b", "a", "b", "a", "g").Seq␤»

[02:14] <timotimo> sorry, that's one layer too far outside :)

[02:14] *** maettu left
[02:14] <Zoffix> ZofBot: mind boggling is what we do!

[02:14] <ZofBot> Zoffix, Lots of people wrote to the magazine to say that Marilyn vos Savant was wrong, even when she explained very carefully why she was right

[02:15] <timotimo> ooh, is that from the "three doors and one goat" thing?

[02:15] <Zoffix> Nope: https://en.wikipedia.org/wiki/The_Curious_Incident_of_the_Dog_in_the_Night-Time

[02:15] <et09> "The Apocalypse on Pattern Matching" lol

[02:15] <Zoffix> Ahh

[02:15] <Zoffix> timotimo: but yes, the book mentions the three doors and one goat problem and how many people didn't get it :)

[02:15] <Zoffix> I totally forgot that it did :)

[02:16] <timotimo> i love that story

[02:16] <et09> also larry wall reminds me of the guy from back to the future

[02:16] <timotimo> not the dog incident one, i don't know that one

[02:16] <Zoffix> :)

[02:16] *** maettu joined
[02:19] <Zoffix> I guess I was mis-remembering (about FatRat infectiousness). Now that I think of it, it don't make much sense to have FatRat + Num produce a FatRat, as depending on values, a lot of the "extra precision" in that FatRat would be bogus

[02:19] <Zoffix> oh

[02:19] <Zoffix> m: say .1 + .2 == .3

[02:19] <camelia> rakudo-moar ec5edcaec: OUTPUT: «True␤»

[02:19] <tobs> et09: if you do numbers, the "... *" syntax for sequences is nice

[02:19] <Zoffix> et09: ^ another sample I'd add into "elegant" pile. The above gives False in many mainstream languages (they use floating points for such literals, but we use Rational types)

[02:20] <tobs> m: my @p = 2, 3, -> *@p { (@p[*-1]..*).first: none(@p) R%% * } ... *; @p[^25].say

[02:20] <camelia> rakudo-moar ec5edcaec: OUTPUT: «(2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97)␤»

[02:20] <tobs> one-line sieve of eratosthenes (ignoring Int.is-prime)

[02:20] <Zoffix> m: say (2, 6, 18 … ∞).head: 100

[02:20] <camelia> rakudo-moar ec5edcaec: OUTPUT: «(2 6 18 54 162 486 1458 4374 13122 39366 118098 354294 1062882 3188646 9565938 28697814 86093442 258280326 774840978 2324522934 6973568802 20920706406 62762119218 188286357654 564859072962 1694577218886 5083731656658 15251194969974 45753584909922 1372…»

[02:21] <et09> wow

[02:21] <Zoffix> m: say (1, 1, *+* … ∞).head: 100

[02:21] <camelia> rakudo-moar ec5edcaec: OUTPUT: «(1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765 10946 17711 28657 46368 75025 121393 196418 317811 514229 832040 1346269 2178309 3524578 5702887 9227465 14930352 24157817 39088169 63245986 102334155 165580141 267914296 433494437 70…»

[02:21] <Zoffix> Fibonacci numbers

[02:21] <Zoffix> (*+* is a closure that takes two args; the `*` are the arg placeholders, not multiplication)

[02:22] <timotimo> m: say (20, 35, *%* ... 0) # euclid's algorithm for greatest common denominator

[02:22] <camelia> rakudo-moar ec5edcaec: OUTPUT: «(20 35 20 15 5 0)␤»

[02:23] <tobs> haha, that's great

[02:23] <timotimo> grab the second-to-last number as the result

[02:24] <timotimo> m: say ([1], -> @a { [flat(0, @a) Z+ flat(@a, 0)] } ... *).head(4)

[02:24] <camelia> rakudo-moar ec5edcaec: OUTPUT: «([1] [1 1] [1 2 1] [1 3 3 1])␤»

[02:24] <timotimo> m: say ([1], -> @a { [flat(0, @a) Z+ flat(@a, 0)] } ... *).head(10)

[02:24] <camelia> rakudo-moar ec5edcaec: OUTPUT: «([1] [1 1] [1 2 1] [1 3 3 1] [1 4 6 4 1] [1 5 10 10 5 1] [1 6 15 20 15 6 1] [1 7 21 35 35 21 7 1] [1 8 28 56 70 56 28 8 1] [1 9 36 84 126 126 84 36 9 1])␤»

[02:24] <timotimo> pascal's triangle

[02:24] <timotimo> the sequence operator in general is just brilliant

[02:25] <timotimo> i need to go to bed %)

[02:45] *** ilbot3 left
[02:46] <Zoffix> ZofBot: big brother has quit! Let's get crazy

[02:46] <ZofBot> Zoffix, ” And she said, “Perhaps your father just doesn’t like Mr

[02:47] <TEttinger> ZofBot: once upon a time,

[02:48] <Zoffix> :)

[02:48] <Zoffix> ZofBot: good robot!

[02:48] <ZofBot> Zoffix, Your father is a much more pacient person

[02:48] <TEttinger> aw

[02:48] <TEttinger> pacient heh

[02:48] <TEttinger> it should be spelled like that, shouldn't it

[02:52] *** et09 left
[02:56] *** ilbot3 joined
[02:56] *** ChanServ sets mode: +v ilbot3

[03:00] *** pierre joined
[03:03] <Kaiepi> m: say (2419872,984522,*%*...0).tail(2)[0]

[03:03] <camelia> rakudo-moar ec5edcaec: OUTPUT: «42␤»

[03:03] <Kaiepi> is there a shorter way to get the second last element?

[03:04] <Zoffix> .tell TimToady I thought about it and kinda hate RatStr being the type for high-precision literals. `my Str $x = 1.1111111111111111111` is a typecheck error, but `my Str $x = 1.11111111111111111111 isn't` and it's hard to say what a numeric literal has to do with a `Str` object. I drafted the latest version of the proposal to implement a `MidRat` instead that's literally a `Rat`/`FatRat` allomorph (and its

[03:04] <yoleaux> Zoffix: I'll pass your message to TimToady.

[03:04] <Zoffix> `Str` allomorph `MidRatStr` is). I don't really like the overkill of introducing two new types to solve this, but I like all the other ideas even less. I updated the proposal doc and there's a crude trial impl in `ratlab-fattish-rat` branch ; what do you think on this? https://github.com/rakudo/rakudo/blob/master/docs/archive/2018-03-04--Polishing-Rationals.md

[03:05] <Zoffix> .tell TimToady `Str` allomorph `MidRatStr` is). I don't really like the overkill of introducing two new types to solve this, but I like all the other ideas even less. I updated the proposal doc and there's a crude trial impl in `ratlab-fattish-rat` branch ; what do you think on this? https://github.com/rakudo/rakudo/blob/master/docs/archive/2018-03-04--Polishing-Rationals.md

[03:05] <yoleaux> Zoffix: I'll pass your message to TimToady.

[03:05] <Zoffix> m: say (2419872,984522,*%*...^0).tail

[03:05] <camelia> rakudo-moar ec5edcaec: OUTPUT: «42␤»

[03:06] <Zoffix> "and its `Str` allomorph `MidRatStr` is"... Looks like sleep deprivation turned me into Yoda

[03:07] <Zoffix> m: say (2419872,984522,*%*...0)[*-2]

[03:07] <camelia> rakudo-moar ec5edcaec: OUTPUT: «42␤»

[03:07] <Zoffix> Kaiepi: ^ the first one is specifically for … op, the …^ version excludes endpoint and then you just do a `tail` on it. The second one is a generic one to get $nth element from the end

[03:08] <Zoffix> Though writing .tail(2).head can betterer as this doesn't cache, while the [...] thing caches

[03:10] <ZzZombo> Kaiepi, just using subscripts is shorter, `(...)[2]`.

[03:10] <ZzZombo> Kaiepi, just using subscripts is shorter, `(...)[*-2]`.

[03:10] <ZzZombo> I mean the latter.

[03:10] <Kaiepi> ah

[03:10] <Kaiepi> thanks

[03:17] *** Zoffix left
[03:37] *** maettu left
[03:38] *** maettu joined
[03:38] *** eliasr left
[03:40] *** sharksoft left
[04:01] *** Zoffix joined
[04:06] <Zoffix> .tell TimToady I slept on it and decided I hate MidRat. It's totally an overkill. Got a new idea tho: when making a Rat, if denomunator is too big, mix in a role with Int denominator. Basically this: `role ExtPrecisionRational { has Int $.denominator };  role Mouse does Rational[Int,Int] { method new(\nu, \de) { my \r := nqp::create(self); r does ExtPrecisionRational if reduced-de-is-over-64-bit;

[04:06] <yoleaux> Zoffix: I'll pass your message to TimToady.

[04:06] <Zoffix> p6bindattrinvres(...) }` Thinking it'd be a private role tho. Gonna try a trial impl on on Mar 10th weekend

[04:06] <Zoffix> .tell TimToady p6bindattrinvres(...) }` Thinking it'd be a private role tho. Gonna try a trial impl on on Mar 10th weekend

[04:06] <yoleaux> Zoffix: I'll pass your message to TimToady.

[04:06] * Zoffix re-beds

[04:06] *** Zoffix left
[04:07] *** xtreak joined
[04:21] *** kybr left
[04:22] *** kybr joined
[04:24] *** llfourn left
[04:26] *** llfourn joined
[04:31] *** pierre left
[04:32] *** pierre joined
[04:34] *** pierre left
[04:44] *** pierre joined
[04:48] *** pierre left
[04:51] *** wamba joined
[05:06] *** aindilis` left
[05:10] *** w_richard_w joined
[05:41] *** curan joined
[05:48] *** trnh joined
[05:49] *** pierre joined
[05:54] *** pierre left
[06:08] *** pierre joined
[06:10] *** trnh left
[06:12] *** pierre left
[06:18] *** pierre joined
[06:18] *** domidumont joined
[06:20] *** troys left
[06:23] *** xtreak left
[06:23] *** pierre left
[06:23] *** wamba left
[06:25] *** domidumont left
[06:25] *** domidumont joined
[06:26] *** pharv joined
[06:31] *** pharv left
[06:34] *** xtreak joined
[06:34] *** perlUser joined
[06:35] <perlUser> Hi can I use perl 5 modules in perl 6

[06:35] <perlUser> trying to learn perl6

[06:36] *** pierre_ joined
[06:37] <perlUser> exit

[06:37] *** perlUser left
[06:40] *** pierre_ left
[06:42] *** jimav left
[06:42] *** skids left
[06:42] *** jimav joined
[06:50] *** khw left
[06:50] <Geth> ¦ Pod-To-HTML: JJ++ created pull request #32: Tested with htmlify.p6

[06:50] <Geth> ¦ Pod-To-HTML: review: https://github.com/perl6/Pod-To-HTML/pull/32

[06:53] *** domidumont left
[06:54] *** pierre_ joined
[06:55] *** jimav left
[06:55] *** wamba joined
[06:57] *** tuoneta joined
[06:58] *** tuoneta left
[06:59] *** pierre_ left
[07:11] *** espadrine left
[07:13] *** pierre_ joined
[07:14] *** trnh joined
[07:15] *** pierre_ left
[07:16] *** pierre_ joined
[07:19] <Geth> ¦ doc/master: 5 commits pushed by (JJ Merelo)++

[07:19] <Geth> ¦ doc/master: 07e5b2282b | Fixes broken link refs #561 #1833

[07:19] <Geth> ¦ doc/master: 312c4dc16d | Eliminates 404 refs #561

[07:19] <Geth> ¦ doc/master: 544e20dbc3 | Weird caps refs #561

[07:19] <Geth> ¦ doc/master: 13f0bc2033 | Correcting links and names

[07:19] <Geth> ¦ doc/master: b74810cd6f | Merge branch 'master' of github.com:perl6/doc

[07:19] <Geth> ¦ doc/master: review: https://github.com/perl6/doc/compare/26e28eff8674...b74810cd6f1d

[07:22] *** robertle joined
[07:25] *** rindolf joined
[07:40] *** xtreak left
[07:43] *** xtreak joined
[07:45] *** darutoko joined
[07:57] *** Ven`` joined
[07:58] *** ufobat joined
[08:01] <ufobat> good morning :)

[08:02] *** abraxxa1 joined
[08:02] *** abraxxa left
[08:03] *** abraxxa1 is now known as abraxxa

[08:03] *** abraxxa left
[08:03] *** abraxxa joined
[08:06] *** xtreak left
[08:20] <moritz> \o ufobat 

[08:21] *** noganex left
[08:25] *** Ven`` left
[08:27] *** pharv joined
[08:31] *** Ven`` joined
[08:31] *** pharv left
[08:32] *** trnh left
[08:40] <masak> good antenoon, #perl6

[08:41] *** lowbro_ joined
[08:41] <moritz> \o masak

[08:41] <moritz> still morning here :-)

[08:46] *** Ven`` left
[08:51] *** vike left
[08:59] *** Ven`` joined
[08:59] <masak> you have a point

[09:00] * masak is reading about Go pseudo-assembly

[09:01] <masak> for some reason I've become very hungry for the low-level details of bytecode interpreters/runtimes/VMs recently

[09:01] <masak> maybe I should blog about this

[09:01] *** lookatme left
[09:05] <masak> most interesting thing I learned so far is that in Go, the _caller_ is responsible for managing the callee's stack frame

[09:05] <masak> not sure how common that is, but it seems to me that'd be problematic in the face of multimethod dispatch (which Go doesn't have AFAIK)

[09:07] *** xtreak joined
[09:09] <masak> does anyone know how close Go is to previous Rob Pike languages, such as Alef and Limbo?

[09:09] <masak> oh, Alef wasn't Pike's. but Newsqueak was.

[09:10] *** scimon joined
[09:11] *** xtreak left
[09:12] <masak> at Wikipedia, both the Limbo and the Newsqueak articles mention "first-class channels" and distributed programming. the Limbo article mentions strong typechecking, GC, and portable object code. so it sounds pretty similar

[09:13] *** zakharyas joined
[09:13] <masak> (I once heard it said, meant as a nasty criticism I'm sure, that Pike has been re-implementing the same antiquated language over and over for the past few decades)

[09:15] *** zakharyas left
[09:16] *** zakharyas joined
[09:18] *** zakharyas left
[09:19] *** zakharyas joined
[09:26] *** trnh joined
[09:30] *** xtreak joined
[09:30] *** pierre_ left
[09:34] *** xtreak left
[09:41] *** w_richard_w left
[09:42] *** pierre joined
[09:42] *** trnh left
[09:58] *** tt left
[10:01] *** tt joined
[10:01] <El_Che> masak: interesting take

[10:01] <El_Che> masak: it's true that go doesn't feel modern, but at the same type not archaic. 

[10:04] <stmuk> I really like Go although its pretty much at the opposite end of the "syntax complexity" spectrum to Perl 6

[10:05] <El_Che> also on speed :P

[10:06] *** vike joined
[10:06] <masak> I haven't programmed in Go. but I'm reluctantly attracted to the minimalist philosophy it expresses, where you're expressly given a "good parts" subset to work with, instead of All The Things

[10:06] <El_Che> I should register a p6p6 domain :)

[10:06] * masak enjoyed https://commandcenter.blogspot.se/2012/06/less-is-exponentially-more.html

[10:07] <masak> though "no generics" still feels like a very trivial hill to die on to me

[10:07] <El_Che> masak: in my opinion, the syntax doesn't offer much. What it does however is simplicity (e.g. reading other projects), safety, easy concurrency, speed and easy deployment

[10:07] <stmuk> Go "Interfaces" are nice

[10:08] <El_Che> masak: what's annoying in go is the repeat yourself part (partly to the lack of generics and compact standard lib)

[10:08] <stmuk> the Go team are asking for generic use cases for  Go 2.x

[10:09] <El_Che> and they are fixing the awful lib versioning

[10:09] <El_Che> (or better: the lack of)

[10:09] <stmuk> you can fudge generics but Go is probably a bit too "static" for it TBH

[10:10] <jast> I don't really like Go that much, but I guess that's because minimalism is the hardest thing and people prefer different ways of reducing things

[10:13] <stmuk> https://www.youtube.com/watch?v=rFejpH_tAHM dotGo 2015 - Rob Pike - Simplicity is Complicated

[10:14] <masak> cf "I didn't have time to write a shorter letter" ;)

[10:14] <stmuk> :)

[10:14] <jast> exactly

[10:15] <masak> it's funny -- I'm just back from teaching Git for the umpteenth time. I'm experimenting right now with focusing more on team workflows than on advanced Git commands. it's a big shift in how I teach Git.

[10:15] <jast> and reducing something is always a trade-off

[10:15] <masak> and every time I do it, I can feel how I get a little closer to the core of what I want to say, and how I get there quicker

[10:16] *** noganex joined
[10:16] <masak> it's amazing to me how much that kind of teaching also becomes an act of *discovery* for me, the teacher

[10:16] <jast> yeah, IMO team workflows are much more central to using git successfully

[10:16] <jast> for advanced commands you can always go ask in #git after all ;)

[10:16] <masak> it's like I'm amortizing the cost of finding out what I want to say over dozens of clients :P

[10:17] <masak> it's also my thesis lately that everyone wants continuous integration, whether they know it or not

[10:17] *** curan left
[10:17] <jast> absolutely... you're building up experience about what matters most, what the most common problems and gotchas are, and so on

[10:18] <jast> I've been running the #git gauntlet for like ten years now... I can do almost arbitrary git talks without any preparation now :)

[10:19] <masak> well, I know what I want to convey, I'm just not used to overcoming the Curse of Knowledge and explaining it well to people who need to hear it

[10:20] <jast> this is why I like very interactive workshops, makes it much easier to see where people are at and tailor-fit explanations

[10:21] <masak> yesterday I ended up building a shopping cart in ES6+, gradually migrating from committing directly on master via feature branches to PRs

[10:21] <masak> the culmination was when I reviewed my own PRs, fixed the problems, and then had the merge of one cause conflicts in another so it needed rebasing/model changes

[10:22] <masak> it came together quite nicely <3

[10:23] *** vike left
[10:24] *** Ven`` left
[10:24] <masak> biggest hurdle this time was that eslint was overconfigured and wouldn't shut up about complete inessentialities :P

[10:25] <masak> "hey, this function is empty!" -- I know. -- "you didn't use `this` in this method!" -- I know. -- "you didn't use that parameter!" -- I'm doing TFD, OK?

[10:25] *** vike joined
[10:27] <jast> linting is the worst :)

[10:27] <masak> I disagree :)

[10:27] <masak> but it makes a big difference if you opted in to rules or not

[10:27] <jast> well it depends

[10:27] <jast> if you take the time to set up the right ruleset for the linter, sure, why not

[10:28] <masak> also, it's not that those rules are bad or wrong, but they are just over-eager and don't make sense in the middle of the branch

[10:28] <masak> I'd like two modes: "lint before commit" and "lint before merge"

[10:28] <jnthn> Was gonna say, the things I want a linter to tell me in the middle of developing something aren't the ones I'd want at commit time

[10:29] <jast> I don't think I even have a commit-time linter, but my editor does linting in the background

[10:29] <masak> maybe even a third: "lint during authoring" -- mostly because JS is still JS. but that one can be swapped out for a decent modern IDE.

[10:29] <jnthn> The default sets of rules are often a bit over-eager, I find, though. Perhaps 'cus linter developers want to show off all their hard work. :-)

[10:31] <jnthn> And yeah, in JS, linters are more useful than in many other languages, because they tell you stuff the compiler does in other languages. :P

[10:31] <jast> some of them do style-related things, too, like warning about long lines... yeah, I know exactly how long my lines are, thank you very much

[10:31] *** xtreak joined
[10:33] <masak> some eslint rules simply make absolutely no sense, like https://eslint.org/docs/rules/no-param-reassign

[10:34] <masak> if you read the linked article that motivates that rule, there are some solid points about `arguments` aliasing

[10:34] <masak> but the rule also forbids you to change *properties* of arguments, which is completely fine

[10:34] <jnthn> wat?

[10:35] <jnthn> :)

[10:35] <masak> oh, that's opt-in... but still.

[10:35] <jnthn> I was about to write "Perl 6 actually enforces a rule like that" until you said the last part :-)

[10:36] <jast> the example in the linked article is a classic example of shooting yourself in the foot, anyway

[10:36] <El_Che> feet are overrated

[10:36] <jast> you'd only do this if you didn't know how arguments works in JS

[10:36] <jast> the 'arguments' keyword/fake variable, that is

[10:37] <masak> guess that's the point, yes

[10:37] <jast> IMO the goal of a linter shouldn't be to protect yourself against people who don't understand the language, it should be to catch things that might happen to someone who knows what they're doing

[10:38] <masak> +1

[10:39] *** Ven`` joined
[10:40] <masak> this explains why I hate linter rules about parentheses for clarity (instead of relying on precedence) and against using bit ops (because it could be a typo)

[10:42] <jast> one case where I like parentheses for clarity is 'if (foo = bar)' in C and friends

[10:44] <masak> if I get you right, I believe those are necessary...?

[10:45] <masak> or did you mean `if ((foo = bar))` ?

[10:45] <jast> the latter

[10:45] <jast> I suppose in some cases it's clear from the context that it's a deliberate assignment, though

[10:48] <masak> reminds me of https://github.com/masak/007/issues/279 which I'm mulling over right now

[10:49] <masak> (and I just learned that in Go, assignment is not an expression. figures.)

[10:54] <jast> I tend to be in the "everything is an expression" camp

[10:57] <masak> aye -- I understand that stance quite well. and note that 007 currently behaves like C and Perl there

[10:58] <masak> but as a language designer, I feel I have to argue the other side too ;)

[10:58] <masak> in a sense, for any "everything is an X" stance, you have to do a certain amount of violence to things which aren't _really_ an X

[11:00] <masak> "everything is an object" -- except for primitives, methos invocations, the call stack itself, properties, reprs, and object code

[11:00] <masak> method*

[11:01] <masak> "everything is a sexpr" -- except for... almost everything :P

[11:01] <Geth> ¦ Pod-To-HTML: 413a5f2cf4 | (Juan Julián Merelo Guervós)++ (committed by Zoffix Znet) | 2 files

[11:01] <Geth> ¦ Pod-To-HTML: Tested with htmlify.p6 (#32)

[11:01] <Geth> ¦ Pod-To-HTML: 

[11:01] <Geth> ¦ Pod-To-HTML: * Adds precomp everywhere

[11:01] <Geth> ¦ Pod-To-HTML: 

[11:01] <Geth> ¦ Pod-To-HTML: * Avoid errors in documentation

[11:01] <Geth> ¦ Pod-To-HTML: 

[11:01] <Geth> ¦ Pod-To-HTML: * Comment out debug

[11:01] <Geth> ¦ Pod-To-HTML: 

[11:01] <Geth> ¦ Pod-To-HTML: * Fix that works refs perl6/doc#561

[11:01] <synopsebot> DOC#561 [open]: https://github.com/perl6/doc/issues/561 [big][docs][site] Lots of broken links, invalid HTML and so on (checklink)

[11:01] <Geth> ¦ Pod-To-HTML: review: https://github.com/perl6/Pod-To-HTML/commit/413a5f2cf4

[11:02] <Geth> ¦ Pod-To-HTML: b8d03a0c75 | (Zoffix Znet)++ (committed using GitHub Web editor) | .gitignore

[11:02] <Geth> ¦ Pod-To-HTML: Simplify rule

[11:02] <Geth> ¦ Pod-To-HTML: review: https://github.com/perl6/Pod-To-HTML/commit/b8d03a0c75

[11:02] <masak> "everything is an associative array" -- so I can store a key "foo" in my integer-indexed array? gee, thanks.

[11:02] <Geth> ¦ Pod-To-HTML: 5864afc79c | (Zoffix Znet)++ (committed using GitHub Web editor) | META6.json

[11:02] <Geth> ¦ Pod-To-HTML: Bump version

[11:02] <Geth> ¦ Pod-To-HTML: review: https://github.com/perl6/Pod-To-HTML/commit/5864afc79c

[11:03] <jast> of course "everything is an X" isn't universally sensible

[11:03] <jast> but for expressions specifically I have yet to see any real problem

[11:04] <masak> Rakudo had performance problems for a while because loops spat out all their iterations somehow

[11:04] <masak> or, more generally, because routines returned things when that wasn't the intent

[11:04] <jast> well, if you went the expressionist route you'd have optimizations for expressions where the resulting value isn't used

[11:05] <jast> (ideally)

[11:05] <masak> "sufficiently smart compiler", aye

[11:06] <masak> for a brief while I had a fork of 007 called "george-lazenby" where I intended to make everything an expression just to try it out. never got the tuits, though

[11:06] <jast> if you account for this in the design up front it shouldn't actually be too hard

[11:07] <jast> very much an FP mindset: track which expressions have side effects and reduce the emitted code if you find pure elements that don't get used

[11:07] *** pierre left
[11:08] *** pierre joined
[11:08] *** pierre left
[11:09] *** pierre joined
[11:13] *** kaare_ left
[11:15] *** kaare_ joined
[11:16] *** pierre left
[11:16] *** pierre joined
[11:21] *** pierre left
[11:24] <masak> in general, a callee does not know about all its callers. at least not before "link time", let's say

[11:26] <masak> and in a setting with method dispatch, an optimizer might have to be pessimistic when optimizing

[11:28] *** xi- left
[11:28] <jast> yeah, this a whole-program optimization thing

[11:28] *** xi- joined
[11:30] <jast> or you can generate two versions of each dispatch: one that does yield a result and one that doesn't

[11:30] <jast> that bloats up the generated code something awful, of course, but depending on your target platform it might not matter that much ;)

[11:31] *** xtreak left
[11:32] <masak> yes, this is a good point

[11:32] <jast> many years ago I had this idea for a language/compiler that is extremely trigger-happy on generating many different versions of routines

[11:32] *** pmurias joined
[11:32] <jast> the idea being that you could write untyped code and it would generate a type-specific compiled version whenever one was needed

[11:33] <jast> probably terrible for CPU caching, but oh well :)

[11:33] <masak> sounds like a JIT to me :)

[11:33] <jast> yeah, except it would actually do this ahead-of-time

[11:34] <timotimo> rpython does something very much like this, actually

[11:34] <jast> basically an IR layer, and whenever you compile a full program, the correct native code would be generated from that for each type of invocation actually used

[11:34] *** zakharyas left
[11:34] <timotimo> it does whole-program type-inference

[11:34] <timotimo> it generates versions of all functions for all types that it could receive

[11:34] <masak> in the preface of my still-only-theoretical book on compilers, I point out how compilers prefer almost all of the things we dislike as humans: code duplication, massive inlining, feature envy, etc...

[11:34] <timotimo> it is also somewhat slow

[11:35] <jast> and the whole language was designed for this kind of approach, where the compiler would trace back and forth to determine which types were used in any given place

[11:35] <jast> but I never actually implemented it to see if it was possible :)

[11:36] <jast> oh, theoretical books... I have a bunch of those, too

[11:37] <jast> the kicker about my design (which I didn't fully figure out how to implement) is that it would do compile-time type checking, too, even without any type annotations whatsoever

[11:37] <jast> and unlike, say, OCaml, it wouldn't have type-specific operators

[11:37] <timotimo> rpython does this with assertions; partially explicit, partially implicit or transitive

[11:37] <jast> the only limitation this imposes is that you need to be clear about which types are coming in via I/O

[11:38] <jast> basically typed interface, inferred anything-else

[11:39] <jast> the extreme version would be that you could write methods that aren't actually tied to any class, and it becomes available automatically if an instance can deliver whatever the method needed. I was kind of thinking that might be a little too laissez-faire in general, though.

[11:41] <timotimo> hm, what difference between methods and subs is left if it just "becomes available" like that?

[11:42] <jast> just syntax

[11:52] <pmurias> Just having a "my $foo = new;" construct and infering the type of the object created based on what methods are called on it is an approach use in a code-completion oriented language by Sean McDirmid (would have too look more for the exact paper language)

[11:54] *** Grauwolf left
[11:57] <pmurias> (Escaping the Maze of Twisty Classes) https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/mcdirmid12.pdf

[11:57] *** xtreak joined
[12:01] <jast> that's likely to be ambiguous if you use a lot of inheritance and roles/mixins and such

[12:01] *** Ven`` left
[12:01] <timotimo> if you don't use many methods on the object, maybe it doesn't matter which class you get :)

[12:02] *** rindolf left
[12:02] <jast> maybe the siblings differ only in implementation of various methods

[12:03] <jast> e.g. ElementLookup has descendants CSSElementLookup and XPathElementLookup

[12:05] *** lichtkind joined
[12:05] *** rindolf joined
[12:13] *** wamba left
[12:19] *** Ven`` joined
[12:24] <jast> not to mention it might make code hard to read, because then *you* have to infer the type from the methods being used, too

[12:25] <jast> unless you start being extremely careful with variable names, and then maybe it's a better idea to have a shorthand construct in which variable name =~= class name

[12:28] *** pharv joined
[12:29] *** pharv left
[12:45] *** athenot left
[12:52] <pmurias> jast: re *you* have to infer, it's part of the live programming movement so it assumes you are using and IDE which does that for you rather then a dumb text editor

[12:52] <pmurias> jast: and it seems they allow you to specify the base class and infer traits

[12:53] <jast> if the IDE shows me the class without me having to hover over it or anything, it might as well add it to the code

[12:54] *** AlexDaniel joined
[12:57] <pmurias> the IDE editing code on it's seems like potentially super annoying 

[12:57] <jast> either way, I'd rather have these essential bits of information in my code

[12:58] <jast> I mean, I wouldn't want the type to magically change just because I implement a new method in some other class

[13:01] *** Ven`` left
[13:04] *** zakharyas joined
[13:05] *** Ven`` joined
[13:14] *** wamba joined
[13:14] <pmurias> jast: I'm not a (strong) proponent of that approach, I just think it's an interesting radical idea (and the paper likely does it justice better than me giving it mine impression over irc ;)

[13:17] *** Grauwolf joined
[13:17] <jast> pmurias: oh, I missed the link. I'll take a look later.

[13:25] *** obfusk_ left
[13:25] *** obfusk joined
[13:25] *** pharv joined
[13:28] *** lichtkind_ left
[13:30] *** pharv left
[13:38] *** pmurias left
[13:38] *** pierre joined
[13:40] *** Ven`` left
[13:41] *** Ven`` joined
[13:50] *** abraxxa left
[13:51] *** abraxxa joined
[13:54] *** wamba left
[13:58] *** athenot joined
[13:58] *** abraxxa left
[13:59] <Geth> ¦ doc: 5bd17409c5 | (Will "Coke" Coleda)++ | doc/Language/regexes.pod6

[13:59] <Geth> ¦ doc: avoid 'or so on', which doesn't read right to me.

[13:59] <Geth> ¦ doc: 

[13:59] <Geth> ¦ doc: ("and so on" which reads fine, didn't quite fit here)

[13:59] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/5bd17409c5

[13:59] <synopsebot> Link: https://doc.perl6.org/language/regexes

[13:59] *** Zoffix joined
[14:02] <masak> [Coke]: I'm always reminded of an early table in Korzybski's book

[14:03] <masak> the book is about how language can affect thought. he feels a need to introduce half a dozen new types of punctuation (!)

[14:03] <timotimo> interrobang?

[14:03] <masak> nonono, nothing as frivolous as that

[14:03] * masak digs it out to have a look

[14:04] *** zakharyas left
[14:04] <masak> I'm not sure if I find the whole idea of "non-Arestotelian" things incredibly fascinating or dangerous and corrosive

[14:05] <masak> ok, first off, he says "non-arestotelian" so much that he abbreviates it early on as "Ā"

[14:05] *** zakharyas joined
[14:06] <masak> (similarly for "non-euclidian" and "non-newtonian", both of which terms I have a much easier time grokking)

[14:07] *** cdg joined
[14:07] <masak> oh! here we go: ".," for "etc.,", ",." for ",etc.", ".;" for "etc.;", ".:" for "etc.:", ".?" for "etc.?", and ".!" for "etc.!"

[14:07] <masak> guy really wants to be able to say "etc." a lot

[14:07] <Zoffix> .tell TimToady never mind. I'm back on MidRat wagon (which is the latest work draft). Both fatty RatStr and mixing-in-a-role for boosted precision force us to use $.denominator instead of $!denominator in all Rational methods, which is 5.5x slower for native attributes and 4% slower for non-native.

[14:07] <yoleaux> Zoffix: I'll pass your message to TimToady.

[14:07] <masak> I wish this was more off-topic, but this is a Perl channel :P

[14:12] *** Kaiepi left
[14:13] *** Kaiepi joined
[14:16] <[Coke]> :)

[14:17] *** abraxxa joined
[14:20] <Zoffix> m: class Foo { has uint64 $.x = 42 }; with Foo.new -> \F { for ^1000_000 { F.x; Nil }; say now - ENTER now }

[14:20] <camelia> rakudo-moar 26522e8ac: OUTPUT: «0.34139625␤»

[14:20] <Zoffix> m: class Foo { has Int $.x = 42 }; with Foo.new -> \F { for ^1000_000 { F.x; Nil }; say now - ENTER now }

[14:20] <camelia> rakudo-moar 26522e8ac: OUTPUT: «0.10212501␤»

[14:20] *** xtreak left
[14:20] <Zoffix> Is it expected for native one to always be slower or is this just lack of things to make it fast?

[14:21] <jnthn> Zoffix: Lack of optimization

[14:21] <Zoffix> *phew* :)

[14:21] <jnthn> It's one of the things on my spesh hit list for the not too distant future

[14:21] <Zoffix> \o/

[14:23] *** eliasr joined
[14:23] <timotimo> is it about NativeRef not being turned into direct local/lexical access even after inlining?

[14:24] <Geth> ¦ perl6-most-wanted: 50f16f72d6 | (Curt Tilmes)++ (committed using GitHub Web editor) | most-wanted/bindings.md

[14:24] <Geth> ¦ perl6-most-wanted: Add link to LibGit2 WIP

[14:24] <Geth> ¦ perl6-most-wanted: review: https://github.com/perl6/perl6-most-wanted/commit/50f16f72d6

[14:27] *** abraxxa left
[14:29] *** zakharyas left
[14:31] *** zakharyas joined
[14:32] <jnthn> timotimo: Yes. At the moment we don't do anything in spesh like that

[14:32] <jnthn> timotimo: But post-inlining is exactly the time for it

[14:32] <timotimo> aye, i've dreamt about this moment for quite some time :)

[14:38] <masak> does the optimization require escape analysis?

[14:40] <lichtkind> greetings masak

[14:41] <lichtkind> Zoffix: do you mind some pull requests for math vector?

[14:43] * Zoffix has no idea what "math vector" is...

[14:43] <masak> lichtkind: ahoy, fellow grey one :>

[14:43] <Geth> ¦ doc: titsuki++ created pull request #1836: Fix link positions in the FAQ

[14:43] <Geth> ¦ doc: review: https://github.com/perl6/doc/pull/1836

[14:43] <Geth> ¦ doc: 0782b5a4f0 | (Itsuki Toyota)++ | doc/Language/faq.pod6

[14:43] <Geth> ¦ doc: Fix link positions in the FAQ

[14:43] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/0782b5a4f0

[14:43] <Geth> ¦ doc: e00a78f5dd | (Itsuki Toyota)++ (committed using GitHub Web editor) | doc/Language/faq.pod6

[14:43] <Geth> ¦ doc: Merge pull request #1836 from titsuki/fix-pos

[14:43] <synopsebot> Link: https://doc.perl6.org/language/faq

[14:43] <Geth> ¦ doc: 

[14:43] <Geth> ¦ doc: Fix link positions in the FAQ

[14:43] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/e00a78f5dd

[14:43] <masak> er, I mean. of course aliens are not among us. that's preposterous.

[14:44] * masak does jedi hand motion

[14:45] *** zakharyas left
[14:49] *** zakharyas joined
[14:49] <Zoffix> lichtkind: I think you're thinking of colomon

[14:49] <Zoffix> eco: Math::Vector

[14:49] <buggable> Zoffix, Math::Vector 'Vector math class': https://github.com/colomon/Math-Vector

[14:52] *** zakharyas left
[14:56] *** zakharyas joined
[14:59] *** zakharyas left
[15:00] *** zakharyas joined
[15:01] *** Zoffix left
[15:02] *** domidumont joined
[15:12] *** wamba joined
[15:18] *** pierre left
[15:20] *** comborico1611 joined
[15:23] *** skids joined
[15:24] *** Ven`` left
[15:31] *** evalable6 left
[15:31] *** Ven`` joined
[15:31] *** evalable6 joined
[15:31] *** ChanServ sets mode: +v evalable6

[15:34] *** khw joined
[15:45] *** aindilis joined
[15:47] *** Kaiepi left
[15:48] *** Kaiepi joined
[15:49] *** pierre joined
[15:53] *** pierre left
[16:07] *** jeromelanteri left
[16:08] *** scimon left
[16:15] *** scimon joined
[16:16] *** committable6 left
[16:16] *** committable6 joined
[16:16] *** ChanServ sets mode: +v committable6

[16:17] *** as_ joined
[16:18] *** scimon left
[16:19] *** scimon joined
[16:19] *** committable6 left
[16:19] *** committable6 joined
[16:20] *** as_ left
[16:20] *** araraloren joined
[16:22] *** troys joined
[16:23] <araraloren> HI

[16:26] <timotimo> ohai

[16:26] <araraloren> No appropriate parametric role variant available for 'NativeCall::Native'

[16:27] <araraloren> I download the module `Digest::SHA1::Native`

[16:27] *** lowbro_ left
[16:27] <araraloren> but installed failed with above error

[16:27] <araraloren> the test of the module all passed

[16:28] *** robertle left
[16:29] <araraloren> https://gist.github.com/araraloren/ae4faf6d72541345ea2c9330e064d155

[16:29] <araraloren> some log

[16:32] *** zakharyas left
[16:34] <araraloren> :) anyone can help me

[16:35] <timotimo> could you try running the file it's trying to compile with perl6 --ll-exception?

[16:35] <timotimo> sub compute_sha1(Blob, size_t, CArray[uint8]) is native( SHA1 ) { * }

[16:35] <timotimo> this is the line it's complaining about

[16:35] <timotimo> oh, it'll want to have a -I . so that it finds the META6.info so %?RESOURCES can work

[16:36] <araraloren> -I ?

[16:36] <timotimo> include folder, so that it looks for files in your current folder

[16:37] <araraloren> do you mean run like this ? perl6 -Ilib ./t/03-sha1.t 

[16:39] <timotimo> yes, but -I. instead of -Ilib

[16:40] <araraloren> not seen any error

[16:40] <araraloren> all test can run and passed

[16:40] <timotimo> huh, strange

[16:41] <timotimo> delete the .precomp folders and try again?

[16:41] <araraloren> hmm, I am on fedora 23

[16:41] <araraloren> but I am not found the prebuild binary package for it, so I am using the rpm of fedora25 

[16:41] <araraloren> is that cause this problem ?

[16:42] <timotimo> it's actually compiling its own sha1 library

[16:42] *** natrys joined
[16:42] <araraloren> yeah, I see

[16:43] <araraloren> ok, maybe I should do a fresh installation

[16:44] <araraloren> thanks

[16:44] <araraloren> I will try to install from source

[16:46] *** Ven`` left
[16:48] *** Ven`` joined
[16:48] *** Ven`` left
[16:51] <El_Che> araraloren: https://fedoraproject.org/wiki/Releases#Current_Supported_Releases

[16:53] <El_Che> (that reminds me that fedora 25 is out of support, next rakudo-pkg rpms will not include fedora 25 packages)

[16:55] <araraloren> :) thanks

[16:56] <araraloren> I was using fedora 26 on my notebook

[16:56] <araraloren> That fedora 23 is a virtual machine (dev env )

[16:57] <El_Che> I build package for a distro version on the exact same version

[16:57] <timotimo> my desktop is a 27, my laptop might be a 25

[16:57] <El_Che> no checking if it works with older of new releases

[16:58] <El_Che> (some people build on a very old os release and make sure it work on newer releases)

[16:59] *** cdg left
[17:00] *** Faster-Fanboi left
[17:00] *** cdg joined
[17:00] <El_Che> I know stmuk experimented with flatpack. That may be an option for out of support distro releases

[17:01] <timotimo> we also have a piece of infrastructure for appimages

[17:01] <timotimo> btw, anybody want to build something for dev-assistant?

[17:01] <timotimo> oh

[17:01] <timotimo> it's already obsolete

[17:01] <timotimo> okay

[17:02] <araraloren> :(

[17:03] <araraloren> I do a fresh installation, still report that error

[17:04] *** cdg left
[17:08] *** comborico1611 left
[17:15] *** scimon left
[17:15] <Geth> ¦ doc: bc72bc3c5b | (JJ Merelo)++ | 2 files

[17:15] <Geth> ¦ doc: Some broken fragments refs #561

[17:15] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/bc72bc3c5b

[17:17] *** pierre__ joined
[17:22] *** pierre__ left
[17:23] *** committable6 left
[17:23] *** bisectable6 left
[17:23] *** committable6 joined
[17:23] *** bisectable6 joined
[17:30] *** domidumont left
[17:31] <buggable> New CPAN upload: Munge-0.1.tar.gz by CTILMES https://cpan.metacpan.org/authors/id/C/CT/CTILMES/Perl6/Munge-0.1.tar.gz

[17:40] *** robertle joined
[17:58] *** araraloren left
[18:03] *** pharv joined
[18:04] *** aindilis left
[18:05] *** aindilis joined
[18:07] *** captain-adequate joined
[18:10] *** domidumont joined
[18:13] *** pharv left
[18:14] *** pharv joined
[18:26] *** sena_kun joined
[18:32] *** [particle]1 joined
[18:32] *** [particle] left
[18:37] *** wamba left
[18:40] *** Kaiepi left
[18:42] *** Kaiepi joined
[18:45] *** daemon left
[18:48] *** daemon joined
[18:48] *** Kaiepi left
[18:49] *** daemon is now known as Guest88621

[18:49] *** khisanth_ left
[18:49] *** Guest88621 left
[18:54] *** espadrine joined
[18:59] *** darutoko left
[19:02] *** khisanth_ joined
[19:10] *** Alchemy joined
[19:10] *** Alchemy left
[19:11] *** Alchemy joined
[19:12] *** Alchemy is now known as Guest80966

[19:12] *** Guest80966 left
[19:12] *** Guest80966 joined
[19:13] *** Guest80966 is now known as daemon

[19:18] *** cfa joined
[19:29] *** pharv left
[19:30] *** pharv joined
[19:31] *** pharv left
[19:31] *** pharv joined
[19:32] *** releasable6 left
[19:32] *** releasable6 joined
[19:34] *** pharv_ joined
[19:34] *** pharv left
[19:35] <Geth> ¦ doc: 63b6c5b781 | (Zoffix Znet)++ | doc/Type/Metamodel/ClassHOW.pod6

[19:35] <Geth> ¦ doc: Fix docs for value of failed .^lookup call

[19:35] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/63b6c5b781

[19:35] <Geth> ¦ doc: 07c4c7b3c6 | (Zoffix Znet)++ | 2 files

[19:35] <Geth> ¦ doc: Fix/clarify value for failed .^lookup/.^find_method

[19:35] <synopsebot> Link: https://doc.perl6.org/type/Metamodel::ClassHOW

[19:35] <Geth> ¦ doc: 

[19:35] <Geth> ¦ doc: And include examples to test for failed cases.

[19:35] <Geth> ¦ doc: 

[19:35] <Geth> ¦ doc: Fixes https://github.com/perl6/doc/issues/1837 D#1837

[19:35] <synopsebot> D#1837 [closed]: https://github.com/perl6/doc/issues/1837 `lookup` ClassHOW method description is wrong

[19:35] <Geth> ¦ doc: Propspec: https://github.com/perl6/roast/commit/931e8d0e17

[19:35] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/07c4c7b3c6

[19:36] <cfa> so, i dug into the whole package vs. module issue a little bit further (following on from a discussion with Zoffix a couple of days back). if the following is correct, i think it would be worth documenting on the modules page?

[19:36] <cfa> it seems that a .pm6 file that doesn't declare itself as a module compunit targets the GLOBAL package (as indicated by $?PACKAGE). since subs without declarators are implicitly `my`, non-exported subs are inaccessible outside of the file (i.e. lexical) scope while exported subs (is export) from these "non module" packages are added to the GLOBAL namespace table---this is all probably in line with user 

[19:37] <cfa> expectation.

[19:37] <cfa> the surprise comes with `our` subs (or vars): these are also added to GLOBAL since that's the current package. so, writing `our sub say { ... }` in your .pm6 file will clobber the existing builtin.

[19:37] <cfa> now, if we declare that the file is a module compunit, we're no longer targeting the GLOBAL package; `our` symbols work as expected as they don't bleed into GLOBAL and can be accessed via the module name.

[19:38] <cfa> is the above accurate and if so, do folks agree that we need to document this?

[19:40] <moritz> cfa: 'our sub say { }' also creates a lexical alias, which hides the builtin *inside* the module

[19:41] <moritz> cfa: but if you 'use' that module in your own code, that code's say() calls still use the builtin

[19:42] <cfa> oh, interseting

[19:42] <cfa> interesting*

[19:43] <cfa> ah yes, that won't clobber 'say' in the caller context

[19:44] <robertle> can anyone tell me where warn() is defined? I seem to be unable to find it in tghe

[19:44] <robertle> rakudo source

[19:44] <cfa> control.pm6

[19:44] <cfa> multi sub warn, i think?

[19:45] <moritz> yep

[19:45] <cfa> moritz: so, the modules page opens with a very muddled description of modules (usually a file or files, typically packages, etc.)

[19:46] <robertle> k, thanks!

[19:46] *** pierre joined
[19:46] <cfa> moritz: i'm thinking it would be better to open with a discussion of how one goes about encapsulating code and data, demonstrating the pitfalls of just wrapping things in a .pm6 and then introducing the module compunit and unit keyword

[19:46] <cfa> thoughts?

[19:47] <moritz> cfa: I think the modules page should start with a clear explanation of what a module is, and what it's for

[19:47] *** ufobat left
[19:47] <moritz> cfa: but modules aren't the only way to encapsulate code (hey, we have classes and roles), so I'm not sure that's the best approach

[19:48] <robertle> what I don't understand is why the exception lists the source location where I called warn(), rather than the location within warn() where nqp::throw is being called. magic?

[19:49] <moritz> robertle: basically the backtrace printer excludes locations from src/core/, because they tend to be not really useful for the user

[19:49] <moritz> robertle: and warn() just takes the first line of the "public" backtrace

[19:49] <cfa> moritz: agreed on all points

[19:50] <robertle> ah! so if I want to achieve something similar in my custom warning routine, I am out of luck (unless I put it in core)?

[19:50] <moritz> robertle: you can see the full backtrace of any excption with print $ex.backtrace.full

[19:50] <cfa> moritz: i guess i'm saying we need a clearer explanation of what a .pm6 file actually is, what can go in there, what different compunits do, etc.

[19:50] <moritz> robertle: I don't think so; you might have success with subclassing Backtrace, or some such

[19:50] *** pierre left
[19:51] <robertle> I'll play around a bit...

[19:51] <moritz> m: sub f() { die }; try f(); print $!.backtrace.full()

[19:51] <camelia> rakudo-moar 26522e8ac: OUTPUT: «  in method throw at SETTING::src/core/Exception.pm6 line 57␤  in sub die at SETTING::src/core/control.pm6 line 170␤  in sub f at <tmp> line 1␤  in code  at <tmp> line 1␤  in block <unit> at <tmp> line 1␤»

[19:51] <cfa> moritz: but in the case of just wanting to package up a few functions, there needs to be a warning against doing so without specifying unit, i think

[19:51] <moritz> cfa: I don't think so

[19:52] <moritz> it's not dangerous

[19:52] <cfa> perhaps not dangerous, but i'd argue surprising 

[19:52] <cfa> like, this stuff should be obvious

[19:53] <cfa> i guess that's all i'm saying

[19:53] <Geth> ¦ doc: 0726163793 | (Zoffix Znet)++ | doc/Type/Iterator.pod6

[19:53] <Geth> ¦ doc: Clarify .count-only/.bool-only…

[19:53] <Geth> ¦ doc: 

[19:53] <Geth> ¦ doc: …must adjust to account for already-pulled values.

[19:53] <Geth> ¦ doc: 

[19:53] <synopsebot> Link: https://doc.perl6.org/type/Iterator

[19:53] <Geth> ¦ doc: Spotted misinformation:

[19:53] <Geth> ¦ doc: https://www.reddit.com/r/perl6/comments/822b1i/adjective_noun_pick_and_choose_part_1/dv9hqgl/

[19:53] <Geth> ¦ doc: Propspec:

[19:53] <Geth> ¦ doc: https://github.com/perl6/roast/commit/88a12f6984f0b57e9d9540be64d2d793f2d99b97

[19:53] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/0726163793

[19:54] <cfa> i'm speaking from the perspective of having to try stuff out to understand what's going on with namespacing etc.; we just need something in place that obviates that

[19:54] <moritz> cfa: then please add those aspects to the page

[19:54] *** bisectable6 left
[19:54] *** bisectable6 joined
[19:54] *** ChanServ sets mode: +v bisectable6

[19:55] *** Zoffix joined
[19:55] <cfa> so long as you think i've got the important details correct above, i can give it a whirl

[19:55] <cfa> didn't want to add misleading or incorrect documentation

[19:56] <Zoffix> robertle: FWIW routines have .line and .file method that can tell you where they're defined. For Rakudo core, there's also CoreHacker::Sourcery module and our SourceBaby bot that wrap .line/.file inside helper routines

[19:56] <Zoffix> s: &warn

[19:56] <SourceBaby> Zoffix, Sauce is at https://github.com/rakudo/rakudo/blob/26522e8ac/src/core/control.pm6#L186

[19:56] <Zoffix> ^  like that

[19:56] <Zoffix> m: say [.line, .file] with &warn

[19:56] <camelia> rakudo-moar 26522e8ac: OUTPUT: «[186 SETTING::src/core/control.pm6]␤»

[19:57] <Zoffix> robertle: and "is from core" magic isn't too big: https://github.com/rakudo/rakudo/blob/master/src/core/Backtrace.pm6#L144-L161

[19:58] <Zoffix> for backtraces I mean. Tho it's really hackish

[20:00] <Zoffix> eco: CoreHackery::Sourcery

[20:00] <buggable> Zoffix, Nothing found

[20:00] <Zoffix> eco: Sourcery

[20:00] <buggable> Zoffix, CoreHackers::Sourcery 'Helper for showing actual source code locations of core subs and methods': https://github.com/zoffixznet/perl6-CoreHackers-Sourcery

[20:00] *** Zoffix left
[20:01] <cfa> moritz: re: 'clear explanation of what a module is', this isn't actually clear to me. it seems to refer to .pm6 contents and module { ... }

[20:02] <cfa> what else does the term cover?

[20:02] <robertle> tried a CONTROL phaser, but that

[20:02] <robertle>  seems to be fundamentally broken?

[20:02] <cfa> (that question's for everyone, not just moritz)

[20:03] <moritz> that's the real problem, isn't it? :-)

[20:03] <cfa> yes

[20:03] <cfa> compounded for me because i'm going by what the docs say :)

[20:03] <moritz> so, a module is a metaclass with certain capabilities

[20:04] <moritz> m: module A { }; say A.HOW

[20:04] <camelia> rakudo-moar 26522e8ac: OUTPUT: «Perl6::Metamodel::ModuleHOW.new␤»

[20:04] <cfa> yeah, so .HOW on a 'unit module' is Perl6::Metamodel::ModuleHOW.new

[20:04] *** pharv_ left
[20:04] <cfa> but a package Foo.pm6 without unit isn't even registered as symbol afaict

[20:04] <moritz> the "unit" is just syntactic sugar for putting module foo { ... } around the whole thing, without having to indent everything

[20:04] <cfa> yeah

[20:04] <cfa> that much i get

[20:05] <cfa> but we use 'module' to refer to a .pm6 too, or at least seem to in the documentation

[20:05] <moritz> yes, and that's where the confusion starts

[20:05] <cfa> yeah

[20:05] <cfa> so i'm calling that a package

[20:05] <cfa> but i'm not sure that's correct either

[20:05] <moritz> nah, a package is just something of metaclass PackageHOW

[20:06] <moritz> a compunit is closer

[20:06] *** pharv joined
[20:06] <cfa> so is Foo.pm6 just a file that use/require knows how to locate on disk?

[20:06] <moritz> and to make the confusion perfect, we also say things like "DBIish is a module", but we mean the whole distribution with that

[20:06] <cfa> where the contents (does it have module { ... }, class { ... } etc.) really determines its packageness, moduleness, etc?

[20:06] <moritz> so all .pm6 files, the META file etc.

[20:07] <cfa> aiee

[20:07] <moritz> cfa: sounds about right

[20:07] <cfa> okay

[20:07] *** ChoHag joined
[20:07] <cfa> i think this is a good starting point

[20:07] <japhb> .oO( We need sigils to differentiate these meanings! )

[20:07] <cfa> the bit in the docs about module meaning different things could probably be saved for later rather than used at the outset

[20:07] <cfa> define what a proper module is, refer to slang use later

[20:08] <cfa> and by slang i mean slang not slang

[20:08] <cfa> :/

[20:10] *** Zoffix joined
[20:10] <Zoffix> robertle: no, it should work fine. What part looks broken?

[20:10] <Zoffix> m: warn 'meows'; say 42; CONTROL { when CX::Warn { say "Thou shall not $_"; .resume } }

[20:10] <camelia> rakudo-moar 26522e8ac: OUTPUT: «Thou shall not meows␤42␤»

[20:12] <Zoffix> ain't got much docs for it tho it seems

[20:13] *** domidumont left
[20:13] *** pharv left
[20:14] *** pharv joined
[20:14] <robertle> m: CONTROL { }; warn "";

[20:14] <camelia> rakudo-moar 26522e8ac: OUTPUT: «Warning: something's wrong␤MoarVM panic: Trying to unwind over wrong handler␤»

[20:17] <Zoffix> Filed as R#1605

[20:17] <synopsebot> R#1605 [open]: https://github.com/rakudo/rakudo/issues/1605 `CONTROL { }; warn "";` says Trying to unwind over wrong handler

[20:18] <robertle> m: warn 'meows'; say 42; CONTROL { when CX::Warn { say "Thou shall not $_"; .rethrow } }

[20:18] <camelia> rakudo-moar 26522e8ac: OUTPUT: «Thou shall not meows␤meows␤MoarVM panic: Trying to unwind over wrong handler␤»

[20:18] <robertle> .resume works though...

[20:19] <Zoffix> Doesn't quite do the trick with CX::Take tho, 'cause .throw/.rethrow unwinds over wrong things

[20:21] <robertle> found another ticket about the same thing: R#572

[20:21] <synopsebot> R#572 [open]: https://github.com/rakudo/rakudo/pull/572 [has conflicts] Let NativeCall map `int` to `longlong`

[20:21] <robertle> no, one moarvm!

[20:22] <Geth> ¦ doc: 272850d224 | (Zoffix Znet)++ | doc/Language/phasers.pod6

[20:22] <Geth> ¦ doc: Include rudimentary example for CONTROL phaser

[20:22] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/272850d224

[20:22] <synopsebot> Link: https://doc.perl6.org/language/phasers

[20:22] <Zoffix> M#572

[20:22] <synopsebot> M#572 [open]: https://github.com/MoarVM/MoarVM/issues/572 MoarVM panic with CONTROL block

[20:23] <Zoffix> M => Moar, R => Rakudo S => Spec (roast) D => Docs

[20:23] <robertle> I was hoping I could modify the exception and then rethrow it..

[20:24] <Zoffix> Along with some variations: https://github.com/perl6/synopsebot/blob/master/lib/SB/Plugin/GitHub.pm6#L10-L21   + RT for RT tickets

[20:26] *** Zoffix left
[20:30] *** rindolf left
[20:32] *** pharv left
[20:34] *** pharv joined
[20:38] *** pharv left
[20:40] *** pierre joined
[20:41] *** pharv joined
[20:45] *** pierre left
[20:46] *** Kaiepi joined
[21:05] <Geth> ¦ doc: 3fcd5c8e88 | (Will "Coke" Coleda)++ | doc/Type/Iterator.pod6

[21:05] <Geth> ¦ doc: fix typo

[21:05] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/3fcd5c8e88

[21:05] <Geth> ¦ doc: 513c3e80b6 | (Will "Coke" Coleda)++ | xt/words.pws

[21:05] <Geth> ¦ doc: learn new word

[21:05] <synopsebot> Link: https://doc.perl6.org/type/Iterator

[21:05] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/513c3e80b6

[21:11] *** athenot left
[21:12] *** athenot joined
[21:14] *** athenot left
[21:15] *** committable6 left
[21:15] *** committable6 joined
[21:15] *** ChanServ sets mode: +v committable6

[21:18] *** comborico1611 joined
[21:25] *** khw left
[21:29] *** khw joined
[21:31] *** sena_kun left
[21:31] *** koto joined
[21:33] *** khw left
[21:34] *** koto left
[22:04] *** skids left
[22:04] *** committable6 left
[22:05] *** committable6 joined
[22:05] *** ChanServ sets mode: +v committable6

[22:06] *** khisanth_ left
[22:11] *** Kaiepi left
[22:11] *** Kaiepi joined
[22:11] *** khisanth_ joined
[22:14] *** bisectable6 left
[22:15] *** bisectable6 joined
[22:16] *** robertle left
[22:16] *** kaare__ joined
[22:17] *** kaare_ left
[22:27] *** tbrowder left
[22:27] *** tbrowder_ joined
[22:32] *** khw joined
[22:40] *** pierre joined
[22:41] *** pierre left
[22:42] *** pierre joined
[22:42] *** mniip left
[22:44] *** khisanth_ left
[22:45] *** mniip joined
[22:46] *** pierre left
[22:50] *** wamba joined
[22:54] *** khisanth_ joined
[22:56] <jdv79> timotimo: you think i could just take the Cancellation obj from $sched.cue() to kill a promise i don't need anymore?

[22:56] <jdv79> haven't tried it yet but noticed it the other day

[22:56] <jdv79> of course i'd have to make my own Promise code since Promise never returns that obj.

[22:57] <timotimo> i'm not actually sure how cancellations work in general. i know that for IO-related things they translate into a specific function being called from the async task ops table it has attached

[22:57] <timotimo> that's how i made signal handler unsubscribable

[22:57] <jdv79> uh ok

[22:58] <jdv79> i'll test it this weekend

[22:58] <timotimo> it definitely won't cause code that was passed to create the promise in question to stop execution

[22:58] <timotimo> that sentence was weird

[22:59] <jdv79> huh?

[23:00] <jdv79> so if i have a Promise.in().then() it won't cancel the timer and thus abort the then?

[23:00] <jdv79> same question regarding Promise.start(...await $chan...)?

[23:01] <jdv79> oh 6pm - time to bounce

[23:02] *** maettu left
[23:05] *** lichtkind left
[23:05] *** natrys left
[23:13] <jnthn> You can't "kill a Promise" because a Promise is just a data structure for conveying a result. start { } is a way of scheduling code to run and getting the result conveyed through a Promise. Any cancellation of code needs to be done explicitly and cooperatively.

[23:14] <jnthn> Ditto for Promise.start and .then

[23:15] <Geth> ¦ doc: gfldex++ created pull request #1839: tell that whenever reacts to a closed Channel

[23:15] <Geth> ¦ doc: review: https://github.com/perl6/doc/pull/1839

[23:17] <gfldex> /type/Channel could do with better examples too

[23:17] *** lichtkind joined
[23:28] *** Kaiepi left
[23:32] *** Kaiepi joined
[23:33] *** Kaiepi left
[23:34] *** Kaiepi joined
[23:38] *** Kaiepi left
[23:38] *** Kaiepi joined
[23:42] *** Kaiepi left
[23:42] *** Kaiepi joined
[23:45] *** comborico1611 left
[23:49] *** pierre joined
[23:52] *** lichtkind left
[23:57] *** skids joined
