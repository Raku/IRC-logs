[00:00] *** lizmat joined
[00:30] <dalek> rakudo/nom: 00e71c8 | lizmat++ | src/core/Version.pm:

[00:30] <dalek> rakudo/nom: Add another way of creating Version object

[00:30] <dalek> rakudo/nom:

[00:30] <dalek> rakudo/nom: This will basically allow alternate ways of parsing Version strings

[00:30] <dalek> rakudo/nom: that generate an array of parts to compare, and possibly an alternate

[00:30] <dalek> rakudo/nom: string representation.

[00:31] <dalek> rakudo/nom:

[00:31] <dalek> rakudo/nom:   class Version::Reverse is Version {

[00:31] <dalek> rakudo/nom:       method new(Str $s) {

[00:31] <dalek> rakudo/nom:           Version::Reverse.Version::new($s.split(".").reverse,$s)

[00:31] <dalek> rakudo/nom:       }

[00:31] <dalek> rakudo/nom:   }

[00:31] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/00e71c8181

[00:31] <stmuk> seen azawawi

[00:38] <lizmat> .seen azawawi

[00:41] <geekosaur> yoleaux isn't in here

[00:42] <lizmat> yeah, got that now  :-)

[00:48] <dalek> rakudo/nom: b952687 | lizmat++ | src/core/Version.pm:

[00:48] <dalek> rakudo/nom: Handle lazy lists correctly

[00:48] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/b9526875cb

[00:53] <lizmat> good night, #perl6!

[01:00] *** lizmat joined
[01:47] *** ilbot3 joined
[02:02] *** stmuk_ joined
[05:00] *** skids joined
[07:56] <tomboy64> any comments on the jvm backend for rakudo?

[07:57] <tomboy64> stuff asplodes badly when i try to build against the jvm

[08:00] <bartolin> there are a lot of issues with the jvm backend, but at least I was able to build it in the last few weeks. what version of rakudo do you try to build and how does it explode?

[08:12] *** RabidGravy joined
[08:21] <psch> tomboy64: nom HEAD should definitely build and install, details would be very interesting

[08:24] *** [TuxCM] joined
[08:25] *** lizmat_ joined
[08:30] <tomboy64> second

[08:36] <tomboy64> bartolin: psch: https://bpaste.net/show/487fbdbcd5be

[08:37] <tomboy64> hmm i wonder if the nqp jars are seen at all

[08:38] <psch> oh

[08:38] <psch> yeah, look it doesn't find them

[08:41] <psch> tomboy64: "warning: [options] bootstrap class path not set in conjunction with -source 1.7" surprises me a little

[08:41] <psch> because we *do* set -Xbootclasspath during build somewhere, i'm not sure it's in that spot though

[08:41] <tomboy64> yeah, i think i've seen that

[08:42] <tomboy64> it's probably gentoo's messing things up here, but i doubt it, since nothing java-mangling is being pulled in.

[08:42] <psch> i'll start a manual run, for reference

[08:44] <lizmat> jnthn: re http://irclog.perlgeek.de/p6dev/2016-04-23#i_12381803

[08:44] <lizmat> jnthn: looks like it needs to be done somewhere near src/Perl6/Metamodel/MultiMethodContainer.nqp, line 94

[08:44] <lizmat> jnthn: but I have no idea of the necessary incantation to tweak the package

[08:45] <[TuxCM]> This is Rakudo version 2016.04-22-gb952687 built on MoarVM version 2016.04

[08:45] <[TuxCM]> test            21.538

[08:45] <[TuxCM]> test-t          12.798

[08:45] <[TuxCM]> csv-parser      23.692

[08:55] <psch> tomboy64: just to verify, nqp is installed and e.g. < nqp-m -e'say("hi")' > works?

[08:56] <tomboy64> $ nqp-m -e'say("hi")'

[08:56] <tomboy64> hi

[08:56] <tomboy64> yup

[08:56] <psch> fwiw, i don't get the warning about the unset bootclasspath

[08:56] <tomboy64> moarvm is installed as well, works as well

[08:56] <psch> OpenJDK Runtime Environment (IcedTea 2.6.4) (7u95-2.6.4-1~deb8u1)

[08:57] <tomboy64> i am using 2016.03 - if that's worth anything?

[08:57] <psch> tomboy64: oh, my bad, nqp-j, not nqp-m...

[08:57] <psch> ah, 1.8

[08:57] <tomboy64> $ nqp-j -e'say("hi")'

[08:57] <tomboy64> hi

[08:57] <tomboy64> takes a little but works fine as well

[08:58] <psch> yeah, that's expected

[08:58] <tomboy64> is 2016.04 released?

[08:58] <tomboy64> should i try with that?

[08:58] <psch> */usr/usr/*share/nqp/runtime/ # <- that's your classpath..? :)

[08:58] <tomboy64> nope

[08:58] <psch> but that's in your paste

[08:59] <psch> well, minus the *, those were for emphasis :S

[09:00] <tomboy64> hah

[09:00] <tomboy64> that seems to have been it

[09:00] <tomboy64> good catch

[09:01] <tomboy64> i had --sysroot=/usr; making it / made it work

[09:03] <bartolin> psch++ # even without coffee

[09:04] <psch> 2016.03 probably won't install, fwiw

[09:04] <tomboy64> well, the moar backend installs just fine

[09:05] <tomboy64> was able to run perl repl from that last night

[09:05] <psch> yeah, but moars p6sort impl cheats somehow

[09:05] <[TuxCM]> perl6 -v does not show the nqp version. Should it?

[09:05] <psch> and deals fine with a Mu (or VMNull, not sure anymore) as first element, which gives an NPE on r-j

[09:06] <psch> tomboy64: 2016.04 is tagged though, that one should work

[09:06] <tomboy64> ^^ okay, gonna test soon

[09:07] <tomboy64> btw, what would you think about adding this to moarvm's Configure.pl? https://bpaste.net/show/e6d9849d7d77

[09:07] <psch> tomboy64: i'd bring that to #moarvm

[09:07] <tomboy64> i had problems including locally installed libffi.h

[09:07] <tomboy64> ah, alright. thought it was part of perl6

[09:07] <psch> i mean, people will probably see it here too, but it doesn't seem to directly relate to p6 itself

[09:08] <psch> well, moar is designed upon 6model, which is an object model that does what perl6 needs, but moar can probably be used for other things... :)

[09:09] <nine_> Oh boy. I got a "Cannot find method 'run_alt'" again

[09:10] <psch> nine_: that's QRegex, isn't it..?

[09:12] <nine_> I think so. The issue was first exposed when we started precompiling all modules but disappeared on it's own for unknown reasons. It was probably just hidden though.

[09:20] <moritz> psch: 6model isn't really an object model in the sense that language users think of an object model

[09:20] <moritz> it's more like a framework for separating object storage and object behavior

[09:21] <timotimo> yeah, 6model gives you very basic meta-programming stuff that you can build your own stuff upon

[09:21] <moritz> oh gosh, I think tht#s a terrible explanation I just gave

[09:21] <timotimo> that's what REPRs are, mostly

[09:22] <psch> moritz: yeah, i get that much.  6model is a bootstrapping object model for building a languages object model

[09:23] <timotimo> in order to figure out how powerful it is, we'd really need someone to implement every single object model out there on top of it :D

[09:23] <moritz> psch: that sounds like you'd stop using using it once your language object model is bootstrapped. Which isn't the case

[09:24] <moritz> psch: I guess we both have problems finding the right words here :-)

[09:27] <psch> moritz: yeah, seems like.  i'll readily admit my experience with 6model is also purely "what is this even and what i can do to {implement,fix} this..?" :)

[09:32] <dalek> roast: 34eda5f | usev6++ | S32-hash/adverbs.t:

[09:32] <dalek> roast: Only skip tests for rakudo-m

[09:32] <dalek> roast:

[09:32] <dalek> roast: add reference to RT #126823

[09:32] <dalek> roast: review: https://github.com/perl6/roast/commit/34eda5f06d

[09:32] <synopsebot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=126823

[09:43] *** [TuxCM] joined
[09:48] <dalek> roast: 4a8c7ea | usev6++ | S32-array/adverbs.t:

[09:48] <dalek> roast: Only skip tests for rakudo-m

[09:48] <dalek> roast:

[09:48] <dalek> roast: add reference to RT #126823

[09:48] <dalek> roast: review: https://github.com/perl6/roast/commit/4a8c7ea6ba

[09:48] <synopsebot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=126823

[09:55] <tadzik> https://github.com/tadzik/rakudobrew/issues/80 has an idea of tagging the latest stable release of rakudo as latest-stable, so rakudobrew and such can install the latest release rather than blead or whatnot. Yay or nay?

[09:55] <tadzik> (last comment is the most relevant)

[09:56] <psch> i thought retagging is a bad idea?

[09:58] <tadzik> I'unno

[09:58] <tadzik> it may also be interesting to see how perlbrew/plenv handles this

[09:58] <tadzik> where do they get the version listing from

[09:59] <psch> http://blog.iqandreas.com/git/how-to-move-tags/ says every clone has to manually delete the tag at the old location before pulling the tag at the new location

[09:59] <psch> which i personally would find somewhat annoying and at least a bit tedious... :)

[09:59] <psch> otoh, that blog post is 3 years old, no idea if anything changed in git wrt tags since then

[10:02] <psch> on an unrelated note, where do i test the fix for #127916?  my first idea is in S14-roles, probably mixin.t, but i'm really not confident about that

[10:02] <synopsebot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=127916

[10:08] <lizmat> m: say v1.2 eq v1.2.0   # I posit this is correct

[10:08] <camelia> rakudo-moar b95268: OUTPUT«True␤»

[10:09] <lizmat> m: say v1.2 eqv v1.2.0   # I posit that this is *also* correct, as these versions are *not* deeply equal

[10:09] <camelia> rakudo-moar b95268: OUTPUT«False␤»

[10:09] <lizmat> if we have consensus on this behaviour, I will need to fix a few tests

[10:10] <masak> lizmat: I tentatively agree

[10:11] <masak> m: say v1.2.3 ~~ v1.2; say v1.2.3 ~~ v1.2.0 # because of this

[10:11] <camelia> rakudo-moar b95268: OUTPUT«True␤False␤»

[10:11] <masak> I wouldn't expect two canonically equal things to smartmatch differently

[10:11] <psch> equivalent between a superset and one of its members seems to not work if the superset can have more than that one member, right?

[10:11] <psch> *equivalence

[10:11] <psch> ...although i'm not sure set theory applies that rigorously to version numbers

[10:11] <masak> I think it does

[10:12] <masak> psch: but I don't understand what your argument there is -- that sounds more like Russel's paradox, which we're not aiming for :P

[10:12] <masak> Russell's*

[10:12] <psch> that's the one with the teapot..? :)

[10:13] <masak> no, the one with the barber

[10:13] <masak> and sets

[10:13] <psch> but you're probably right, the argument doesn't really work, because eq doesn't really work by the same rules, does it

[10:13] <masak> eq is just string equivalence

[10:13] <masak> that's easy

[10:13] <lizmat> m: say v1.2.3 ~~ v1.2; say v1.2.3 ~~ v1.2.0 # masak: are you saying this is correct ?

[10:13] <camelia> rakudo-moar b95268: OUTPUT«True␤False␤»

[10:14] <masak> lizmat: oh yes

[10:14] <psch> exactly, but the string equivalence has to mean (elem) for my argument to work

[10:14] <masak> lizmat: in other words, v1.2 and v1.2.0 sort of denote "version ranges"

[10:14] <psch> and that's just don't right

[10:14] <masak> it's how I always understood the spec

[10:14] <psch> "member of" for a given patch-level version happens by comparing to a minor-version-level version, and not with eq

[10:15] <psch> in that sense, it works with the smartmatch above

[10:15] <psch> (where a "version range" is a set of versions)

[10:16] <masak> psch: I understand the smartmatch as being a containment check between two version ranges

[10:16] <psch> i'm not sure if shaving himself matters there for the barber, but maybe i'm overlooking something

[10:16] <lizmat> actually, thinking about this more, I think we're conflated Version and VersionRange into a single object  :-(

[10:16] <masak> psch: if the user chooses to picture the lhs version range as actually a point (and thus the check as membership instead of subsetship), then that's fine

[10:16] <masak> lizmat: but it works out

[10:17] <lizmat> not sure about that in the future

[10:17] <lizmat> I mean, v1.* is *not* a version, it's a version range

[10:17] <psch> masak: ohh, right.  now i see where the barber comes into play

[10:17] * masak re-reads S11

[10:18] <masak> psch: you were talking about comparing a set with its members

[10:19] <masak> lizmat: S11 seems pretty clear that Version fills *both* roles, depending on context

[10:19] <masak> lizmat: for example, in a `use` with :ver<1.2.1>, it's an exact match -- a point, not a range

[10:20] <lizmat> well I guess I'm saying is that a Version is acceptable as a VersionRange

[10:20] <masak> lizmat: to get a range, you'd use an actual range in :ver, or :ver<6.2.3+>

[10:20] <lizmat> whereas a VersionRange is *not* acceptable as a Version

[10:21] <masak> lizmat: ok, I can see that point.

[10:21] <lizmat> aka, you can say a module is at version v1.2

[10:21] <lizmat> not at v1.*

[10:21] <lizmat> but currently, there's no way to inhibit such a statement

[10:21] <masak> aha

[10:21] <lizmat> that's why I think we need to split the functionality

[10:21] <masak> I wouldn't go so far as needing to split it

[10:21] <lizmat> (an insight I got late last night)

[10:22] <masak> but it does sound like we need some checks in some places...

[10:23] <lizmat> well, if we're going to add an "is-range" method to Version, we're hacking a difference into it

[10:23] <psch> isn't it just ACCEPTS that needs to know this?

[10:24] <lizmat> how would you use smartmatch to check whether a META6.json spec of a version is in fact a version and not a range ?

[10:24] <psch> well, and any intended-as-point spot needs to fill the version to patch-level, so to answer my own question "no"...

[10:24] <lizmat> indeed  :-)

[10:25] <psch> m: say (v1.2).perl

[10:25] <camelia> rakudo-moar b95268: OUTPUT«v1.2␤»

[10:25] * tadzik considers opening a rakudobug just so he has a number to put near the roast test

[10:25] <psch> yeah, that seems a bit too contextually-overloaded from here

[10:27] <masak> psch: "needs to fill the version to patch-level" -- that's only true if the whole world runs on semantic versioning, isn't it?

[10:27] <masak> psch: as in, I should be allowed to call my *point* versions v1, v2, v3...

[10:29] <masak> (I hope)

[10:32] <lizmat> masak: yes, you are allowed :-)

[10:33] <masak> then a point version doesn't have to fill the version to patch level.

[10:33] <masak> and that's a sense in which point versions "are" ranges, because I'm intentionally grabbing a whole range and using that as a point

[10:33] <masak> also:

[10:33] <masak> m: say v1.2.3.4

[10:33] <camelia> rakudo-moar b95268: OUTPUT«v1.2.3.4␤»

[10:34] <masak> the rabbit hole goes deeper than patch

[10:34] <masak> so even patch versions are ranges

[10:35] <psch> masak: yeah, and that's where it turns from "with classes as major versions, sets as minor versions, points as patch-level version" stops working

[10:35] <psch> err

[10:35] <psch> s/" stops working/it works" turns into a barber/

[10:35] <psch> ...that's still butchered.

[10:36] <masak> psch: that's not my mental model of it at all

[10:36] <psch> masak: no, but it was mine :)

[10:36] <masak> psch: well, stop it :P

[10:36] <psch> *was*.  i said *was* :P

[10:36] <masak> to a first approximation, versions are ranges (though not on the real line)

[10:37] <masak> m: say v1.1938

[10:37] <camelia> rakudo-moar b95268: OUTPUT«v1.1938␤»

[10:37] <dalek> rakudo/nom: 15a0dca | lizmat++ | src/core/Version.pm:

[10:37] <dalek> rakudo/nom: Move "+" logic to general .new

[10:37] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/15a0dca2d1

[10:42] <psch> m: sub f(+@a) { say @a.perl }; sub g(*@a) { say @a.perl }; f [1, 2], 3; g [1,2], 3

[10:42] <camelia> rakudo-moar b95268: OUTPUT«[[1, 2], 3]␤[1, 2, 3]␤»

[10:42] <psch> ...my camelia query used to be win5, now that's p6dev :S

[10:50] <dalek> roast: 95a5c18 | peschwa++ | S14-roles/mixin.t:

[10:50] <dalek> roast: Add test for RT #127916

[10:50] <dalek> roast: review: https://github.com/perl6/roast/commit/95a5c18ee5

[10:50] <synopsebot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=127916

[10:56] <dalek> roast: 16338c5 | (Tadeusz “tadzik” Sośnierz)++ | S06-other/main-usage.t:

[10:56] <dalek> roast: Add a test for #127977

[10:56] <dalek> roast: review: https://github.com/perl6/roast/commit/16338c590b

[10:56] <synopsebot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=127977

[10:56] <tadzik> who is this Tadeusz “tadzik” Sośnierz stealing all my karma

[10:58] <dalek> rakudo/rt-127977: d548b23 | (Tadeusz “tadzik” Sośnierz)++ | src/core/Main.pm:

[10:58] <dalek> rakudo/rt-127977: Fix RT #127977

[10:58] <dalek> rakudo/rt-127977: review: https://github.com/rakudo/rakudo/commit/d548b23533

[10:58] <synopsebot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=127977

[10:58] <tadzik> any comments on that one, before I go forgiveness>permission and merge it? :)

[10:59] * psch looks

[10:59] * masak too

[11:00] <tadzik> lizmat++'s idea: use .startswith() instead of .index() == 0

[11:00] <masak> tadzik: s/and/&&/ both times

[11:00] * lizmat likes && in that case because it lines up better

[11:00] <tadzik> alright, I can agree to that. It lines up better with 'if' :P

[11:00] <masak> tadzik: the whole patch feels a bit like a band-aid, and there's a deeper underlying problem somewhere :/

[11:01] <psch> i'd also appreciate a comment that notes that we probably want a not-X::AdHoc eventually

[11:01] <psch> and i do agree with masak as well, but i often bandaid myself, soo... :)

[11:01] <masak> I'm just generally against mis-using `and` when `&&` works just as well. `and` is for loose, statement-ish-level precedence

[11:01] <tadzik> masak: it is :/ But it fixes the problem, and getting binder to throw out perl6 exceptions sounds like a good reason why it's adhoc in here

[11:01] <masak> I'd say the band-aid is fine if we also commit somehow to fixing the deeper problem

[11:02] <psch> tadzik: the binder has a mechanism in place for throwing typed exceptions

[11:02] <psch> it's just a bit fiddly, mostly

[11:02] <tadzik> oh

[11:02] <psch> grep for P6EX

[11:05] <psch> i'm not sure catching a e.g. X::Bind::Argument::Constraint instead of X::AdHoc completely removes the bandaid feeling, though...

[11:05] <psch> s/Bind/TypeCheck/

[11:06] <psch> it also reaffirms my wish for introspectable where constraints

[11:06] <psch> m: sub MAIN(Int $x where * > 5) { } # this usage is lacking

[11:06] <camelia> rakudo-moar 15a0dc: OUTPUT«Usage:␤  /tmp/vZHUYsPoqq <x> ␤»

[11:07] <dalek> rakudo/nom: 1034c62 | lizmat++ | src/core/Version.pm:

[11:07] <dalek> rakudo/nom: Allow setting of "+" functionality also

[11:07] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/1034c620fd

[11:08] <dalek> rakudo/rt-127977: 4543464 | (Tadeusz “tadzik” Sośnierz)++ | src/core/Main.pm:

[11:08] <dalek> rakudo/rt-127977: Style fixes for the #127977 fix

[11:08] <dalek> rakudo/rt-127977: review: https://github.com/rakudo/rakudo/commit/4543464987

[11:08] <synopsebot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=127977

[11:14] <lizmat> hmmm... so what *are* the semantic differences between cmp <=> and leg ?

[11:15] <lizmat> I'm starting to feel that https://github.com/rakudo/rakudo/commit/688ddee was a mistake

[11:15] <lizmat> should have been < instead of lt

[11:15] <lizmat> <= instead of le   etc etc

[11:19] <tadzik> so, who's fine with applying the band-aid but keeping the RT open until we get a more proper solution? o/

[11:22] * psch isn't sure what else but a narrower Exception would go into a proper solution

[11:22] <lizmat> tadzik: +1

[11:22] <psch> if that's all i can probably hack that in rather quickly

[11:23] <tadzik> that'd be nice, I don't know where to start on that

[11:27] <psch> well, for now subclassing TypeCheck::Argument doesn't help, 'cause we can't show the failed constraint

[11:27] <psch> someone once pointed me at a gist that shows how we could get the where constraint back during runtime, but i neither grokked nor saved it

[11:29] <psch> m: sub f(Int $x) { }; f "f" # this message ~~ s/declared signature/declared constraint $contraint/

[11:29] <camelia> rakudo-moar 1034c6: OUTPUT«===SORRY!=== Error while compiling /tmp/lJDpOvE90C␤Calling f(Str) will never work with declared signature (Int $x)␤at /tmp/lJDpOvE90C:1␤------> sub f(Int $x) { }; ⏏f "f" # this message ~~ s/declared signa␤»

[11:29] <psch> hm, and probably s/f(Str)/f($actual-argument)/

[11:30] <psch> well, i'll subclass but add a # TODO: ...

[11:30] <psch> and also note that in the ticket

[11:34] <psch> hm, maybe it should be X::TypeCheck::Binding::Constraint, actually..?

[11:34] <psch> 'cause ::Argument is about protoguilt and all that jazz

[11:47] <dalek> rakudo/rt-127977: d3c2254 | peschwa++ | src/ (3 files):

[11:47] <dalek> rakudo/rt-127977: Add and throw a typed Exception for where constraints.

[11:47] <dalek> rakudo/rt-127977: review: https://github.com/rakudo/rakudo/commit/d3c2254b4b

[11:47] <psch> tadzik: ^^^

[11:48] <psch> note that i actually realized that we do need to propagate the reason for the dispatch failure towards USAGE somehow

[11:49] <psch> as in, a < sub MAIN(Str $x where .chars > 5) { } > giving USAGE as-is when i supply "foo" doesn't help enough

[11:49] <psch> maybe having where constraints in USAGE is enough there, though

[11:49] <psch> oh duh

[11:49] <psch> that actually works for the wrong reasons it seems

[11:50] <psch> the patch i mean

[11:50] <tadzik> psch (IRC): I think the if chain can go now

[11:51] <psch> tadzik: maybe, i have to fix the lookup via P6EX first though... :)

[11:51] <psch> there was two copy-pastos :/

[11:51] * tadzik sits on the edge of his chair

[11:52] <dalek> rakudo/rt-127977: 3381d20 | peschwa++ | src/ (2 files):

[11:52] <dalek> rakudo/rt-127977: Correct copy-pastos.

[11:52] <dalek> rakudo/rt-127977: review: https://github.com/rakudo/rakudo/commit/3381d2098e

[11:52] <dalek> rakudo/rt-127977: 0ca6e3d | peschwa++ | src/core/Main.pm:

[11:52] <dalek> rakudo/rt-127977: Simplify, tadzik++

[11:52] <dalek> rakudo/rt-127977: review: https://github.com/rakudo/rakudo/commit/0ca6e3d102

[11:52] <psch> now, who was it that pointed me at code object introspection..? :/

[11:53] <psch> also, grr me

[11:53] <psch> the previous one didn't work, which i noticed because i tested *after* pushing

[11:53] <psch> and now i pushed again without testing :(

[11:53] <psch> ...we can squash before merging, right? :P

[11:53] <tadzik> I'll get that :)

[11:54] <tadzik> squashing seems like a sensible thing, yes

[11:54] <timotimo> wow, so much #p6dev chat today :)

[11:55] <psch> $ ./perl6-m -e'sub f($x where 5) { }; try f 2; $!.perl.say'

[11:55] <psch> X::TypeCheck::Binding::Constraint.new(symbol => "\$x", operation => Any, got => Any, expected => Any)

[11:55] <psch> that's rt-127977 HEAD, so i did good :P

[11:56] <timotimo> lizmat: i was also quite surprised when you used eq and friends for versions, because i'd expect lt, gt and friends to coerce things to strings

[11:57] <lizmat> timotimo: yeah, I had just come to the same conclusion

[11:57] <tadzik> psch: http://www.tf2sounds.com/495 :P

[11:57] <tadzik> yep, tests pass

[11:57] <tadzik> I'll squash and merge, alrigh?

[11:57] <psch> let me see if i can find that introspection gist

[11:58] <psch> 'cause if we can already have the code of the where constraint in the Exception that'd definitely be cooler :)

[11:58] <tadzik> okayo

[11:58] <psch> same for USAGE, too

[11:58] <tadzik> oh yes

[12:00] <psch> hmm, https://gist.github.com/niner/3be0c164d847ca794e18 was the gist

[12:00] <psch> i don't know if that actually helps, 'cause Backtrace just opens its $.file and looks for the surrounding lines...

[12:01] * psch wonders what a good solutions could look like there

[12:01] <psch> annotating every WhateverCode with its source seems kinda ehh

[12:03] <psch> otoh, doing what Backtrace does might not work with e.g. -e..?

[12:04] <psch> well, i suppose for Parameter constraints it makes me sense to stuff it into the Parameter anyway, e.g. < has str $!post_constraints_src > or something, maybe

[12:05] <psch> s/me/more/

[12:09] <psch> i'll have to ponder that a bit

[12:09] <psch> which probably mostly means accepting that i don't know a better solution than telling a Parameter what the source of its post_constraint looks like textually

[12:10] <psch> during parse that is

[12:14] <lizmat> lunch&

[12:53] <psch> oh shucks

[12:54] <psch> the parts of a stage parse Match object are BOOTStr, which i somehow can't figure out how to stuff into a str Attribute of Parameter..?

[12:56] *** astj joined
[12:56] *** hankache joined
[13:00] <psch> ...the only thing i can think of is unbox_s(box_s($str, find_symbol([Str]))... o.o

[13:00] <psch> and that's pretty terrible

[13:03] <psch> well, it still gives a BOOTStr anyway

[13:08] <psch> $ ./perl6 --ll-exception -e'sub f($ where * < 2) { }; say &f.signature.params[0].post_constraints_src'

[13:08] <psch> where * < 2

[13:09] <RabidGravy> anyway, all my modules pass with the 2016-04

[13:27] <psch> https://gist.github.com/peschwa/cf6314bd118f4b64edd60ce4ad855f25

[13:27] <psch> tadzik: ^^^

[13:27] <tadzik> psch (IRC): awesome :)

[13:27] <psch> well, and anyone else, really :)

[13:28] <psch> it could be more awesome i suppose

[13:29] <psch> like, the sub example could print "0 < <anon> < 2"

[13:29] <psch> but that's potentially really complicated

[13:29] <timotimo> i didn't know you can have multiple "where"s there

[13:29] <psch> timotimo: fwiw, what clued me in is that it's Parameter.post_constraints :)

[13:30] <timotimo> ah

[13:30] <timotimo> well, you could just write that as where 0 < * < 2

[13:30] <psch> yeah, in that case

[13:30] <timotimo> if it were <= each time, you could write 0..2

[13:31] <psch> well, the example is clearly best written as "sub f(1)" :P

[13:31] <psch> but that doesn't demonstrate the constraint Exception :)

[13:33] <dalek> rakudo/rt-127977: e0f12a4 | peschwa++ | src/ (6 files):

[13:33] <dalek> rakudo/rt-127977: Expand USAGE to include post constraints.

[13:33] <dalek> rakudo/rt-127977:

[13:33] <dalek> rakudo/rt-127977: Necessary condition for that was obviously adding a typed Exception and

[13:33] <dalek> rakudo/rt-127977: stuffing the post constraint source into Parameter, which we profit from in

[13:33] <dalek> rakudo/rt-127977: normal subroutine invocation as well.

[13:33] <dalek> rakudo/rt-127977: review: https://github.com/rakudo/rakudo/commit/e0f12a416f

[13:34] <tadzik> <3

[13:34] <lizmat> m: dd v6.*.2  # should this be a valid Version object??

[13:34] <camelia> rakudo-moar 1034c6: OUTPUT«v6.*.2␤»

[13:34] <psch> fwiw, it's a great solution for the USAGE case, but the implementation still feels band-aid-y to me

[13:34] <lizmat> and if so, what does it mean in a Range context ?

[13:35] <psch> but it's probably the best we can do there, as we can't find out the post constraint source later, so carrying it around from parse time is the only thing we can do (...i think)

[13:36] <psch> tadzik: can i ask you to write tests for the new typed Exception? :)

[13:37] <psch> hm, maybe that's pending a more general agreement with the patch anyway... vOv

[13:39] <tadzik> yeah, if we are to write spectests, we need some more speculation I'd say

[13:41] <tadzik> so we have --output, but --profile-filename. Would you oppose to changing it to --profile-output for consistency?

[13:42] * lizmat says +1

[13:42] <psch> no opposition here

[13:49] *** astj_ joined
[14:08] <dalek> rakudo/nom: 1512da2 | lizmat++ | src/core/Version.pm:

[14:08] <dalek> rakudo/nom: We should use numerical compares for Version

[14:08] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/1512da2ee8

[14:11] <vendethiel> lizmat: should Less/More/Same use ==/!=?

[14:13] <lizmat> vendethiel: not sure I understand the question

[14:13] <vendethiel> lizmat: you use == and != with "compare" objects,is that correct? is that not supposed to use eqv or whatever else form or equality there is? probably doesn't matter

[14:14] <lizmat> "compare" objects?  you mean Version objects ?

[14:30] <timotimo> tadzik: if you change that, either make both flags work for a while, or directly fix camelia to use --profile-output as well :)

[14:31] <tadzik> timotimo: both are probably sensible :)

[14:44] <vendethiel> lizmat: no, I mean Less/Same/.. - that's just an enum?

[14:44] <lizmat> m: dd Same, Less, More

[14:44] <camelia> rakudo-moar 1512da: OUTPUT«Order::Same␤Order::Less␤Order::More␤»

[14:44] <lizmat> vendethiel: yes :-)

[14:49] <psch> m: say so 1 <=> 1 # this consequence tripped me up once

[14:49] <camelia> rakudo-moar 1512da: OUTPUT«False␤»

[14:49] <psch> but then cmp and friends aren't for equality

[15:23] <lizmat> m: m: say so (1 <=> 1)

[15:23] <camelia> rakudo-moar 1512da: OUTPUT«False␤»

[15:23] <lizmat> m: m: say so Same

[15:23] <camelia> rakudo-moar 1512da: OUTPUT«False␤»

[15:23] <lizmat> m: say so Same

[15:23] <camelia> rakudo-moar 1512da: OUTPUT«False␤»

[15:24] <lizmat> duh  :-)

[15:24] <psch> m: say Same.value

[15:24] <camelia> rakudo-moar 1512da: OUTPUT«0␤»

[15:24] <timotimo> tadzik: but clearly ' and \ must be escaped inside there

[15:24] <timotimo> which you'd only notice if you have stuff like that in filenames or something silly like that

[15:25] <timotimo> and \ are probably doubled accidentally

[15:25] <tadzik> ww? :)

[15:25] <tadzik> well, they're not, somehow :P

[15:25] <timotimo> ww, yes

[15:26] <lizmat> PSA re v2.*.3 : I'm thinking about disallowing that

[15:26] <lizmat> too bad it has one spectest for that particular case

[15:26] <lizmat> comments / opinions / suggestions ?

[15:27] <tadzik> kill it, imho

[15:28] <timotimo> it's a strange thing to want

[15:28] <timotimo> but it may have a reason to exist

[15:33] <lizmat> fwiw, S11 only has examples of * at the end of a version

[15:33] <tadzik> does git-blame tell anything interesting?

[15:33] <lizmat> the wording is a bit ambiguous, but I don't think it shows intent of v2.*.3 meaning anything

[15:34] <lizmat> pmichaud, Nov 2008

[15:34] <ugexe> v2.*.1+ specifically could make sense, but in general i dunno

[15:34] <lizmat> ugexe: what would that mean ?

[15:35] <timotimo> anything starting in v2, with one part in the middle and ending in .1 or more than that

[15:35] <timotimo> but never ending in .0

[15:35] <ugexe> only use module whatever version after its first patch (you dont trust the first release). yes this is a stretch

[15:36] <lizmat> feels to me that could be served better with a "where" type clause

[15:36] <lizmat> specifically, is the * supposed to be slurpy?

[15:36] <ugexe> well, not if you are declaring dependencies in a meta file or something

[15:37] <lizmat> would v2.2.2.2.1 ~~ v2.*.1 be true or not ?

[15:38] <lizmat> the reason I'm asking, is that I think v2.4.* should really be a Range

[15:39] <lizmat> m: dd v.2.4..*

[15:39] <camelia> rakudo-moar 1512da: OUTPUT«===SORRY!=== Error while compiling /tmp/zLZsmB2JVR␤Malformed postfix call␤at /tmp/zLZsmB2JVR:1␤------> dd v.⏏2.4..*␤»

[15:39] <lizmat> m: dd v2.4..*

[15:39] <camelia> rakudo-moar 1512da: OUTPUT«Method 'succ' not found for invocant of class 'Version'␤  in block <unit> at /tmp/YV2nLFaV2T line 1␤␤»

[15:39] <lizmat> m: say v2.4..*

[15:39] <camelia> rakudo-moar 1512da: OUTPUT«v2.4..Inf␤»

[15:39] <tadzik> I would assume v2.*.1 means v2.[0-9]+.1

[15:39] <lizmat> so a Version object like that would return a Regex really ?

[15:41] *** mst joined
[15:41] <mst> libuv has a unix domain socket and/or win32 named pipe abstraction, is that exposed to perl6 space?

[15:42] <lizmat> mst: what is the name of that abstraction ?

[15:43] <lizmat> could grep MoarVM source for it maybe ?

[15:43] <mst> http://docs.libuv.org/en/v1.x/pipe.html

[15:45] <MadcapJake> lizmat: I am in favor of disallowing vX.*.X for the reason that the amount of work for a dependency manager to support it far outweighs the supposed gain

[15:45] <ugexe> s11 says `"use" searches for modules matching a version prefix`

[15:46] <MadcapJake> So far the use cases brought up here seem really trivial

[15:47] <MadcapJake> can you actually turn a version into a regex directly?

[15:47] <lizmat> mst: there appears to be an nqp::syncpipe

[15:48] <MadcapJake> Thinking on it some more, I suppose the work involved isn't monumental but still seems superfluous

[15:48] <mst> lizmat: ooh, so that might turn out to be it

[15:57] <MadcapJake> I feel like there should be a Version.absolute method to check if it's got whatevers or +'s in it

[15:57] <lizmat> MadcapJake: that feels like a hack

[15:58] <MadcapJake> why?

[15:58] <lizmat> what I'm working on is that v2.3+ is actually syntactic sugar for v2.3..*

[15:58] <lizmat> which would actually be a Range object which you could smartmatch

[15:58] <lizmat> m: say v2.4 ~~ v2.2..*

[15:58] <camelia> rakudo-moar 1512da: OUTPUT«True␤»

[15:58] <lizmat> m: say v2.4 ~~ v2.2+

[15:58] <camelia> rakudo-moar 1512da: OUTPUT«True␤»

[15:58] <lizmat> m: say v2.4 ~~ v2.2..*

[15:58] <camelia> rakudo-moar 1512da: OUTPUT«True␤»

[15:59] <lizmat> m: say (v2.2..*).WHAT

[15:59] <camelia> rakudo-moar 1512da: OUTPUT«(Range)␤»

[15:59] <lizmat> m: say (v2.2.*).WHAT

[15:59] <camelia> rakudo-moar 1512da: OUTPUT«(Version)␤»

[15:59] <lizmat> m: say (v2.2+).WHAT  # would say (Range)

[15:59] <camelia> rakudo-moar 1512da: OUTPUT«(Version)␤»

[16:00] <MadcapJake> so v2.2+ equiv to v2.2..* ?

[16:00] <lizmat> yes

[16:00] <MadcapJake> what about v2.2.* would that be a Range too?

[16:01] <lizmat> yes

[16:01] <lizmat> then checking version dependencies would just fall out of smartmatch

[16:01] <MadcapJake> so could I do $version !~~ Range to see if it's "absolute"?

[16:02] <ugexe> if its an actual range type wouldnt `for v1.0.0..* { say $_; }` be expected to work?

[16:02] <lizmat> well, there's no Version.succ at the moment

[16:02] <lizmat> but conceivably, that could be defined, yes

[16:03] <lizmat> m: .say for v2..*

[16:03] <camelia> rakudo-moar 1512da: OUTPUT«Method 'succ' not found for invocant of class 'Version'␤  in block <unit> at /tmp/k4GwHsybhO line 1␤␤»

[16:03] <MadcapJake> in gx-perl6, I will need to resolve dependency versions and I could shortcut that if I have an absolute version rather than one with +'s and *'s

[16:03] <lizmat> and checking for an absolute version would be ~~ Version

[16:03] <MadcapJake> oh so v2.2.* ~~ Version would return False?

[16:04] <lizmat> yes

[16:04] <lizmat> it would be a Range

[16:04] <MadcapJake> seems kind of magical though, don't ya think?

[16:04] <lizmat> so we can shout at people putting v2.* as the version of a module in the META6.JSON

[16:04] <lizmat> Version objects are highly magical already, I'm afraid

[16:05] *** skids joined
[16:05] <lizmat> m: say v2.abc cmp v2.ab

[16:05] <camelia> rakudo-moar 1512da: OUTPUT«More␤»

[16:05] <MadcapJake> well that could be solved by just having `method absolute { any(self.parts) ~~ Whatever && not self.plus }`

[16:05] <lizmat> m: say v2.abc cmp v2.b

[16:05] <camelia> rakudo-moar 1512da: OUTPUT«Less␤»

[16:05] <lizmat> m: say v2.a cmp v2.bcd

[16:05] <camelia> rakudo-moar 1512da: OUTPUT«Less␤»

[16:06] <lizmat> MadcapJake: yes, that would be one solution, yes...

[16:07] <lizmat> however, if we only allow * at the end, that would just be Version.plus

[16:07] <MadcapJake> yeah that sounds good to me

[16:07] <MadcapJake> I really don't see the point in a * anywhere else

[16:08] <tadzik> is 2.3 a valid Version.plus for 2.2.4?

[16:08] <tadzik> (I hope not :o)

[16:08] <lizmat> no, Version.plus just indicates whether you had a + at the end

[16:09] <lizmat> m: dd (v2.3+).plus

[16:09] <camelia> rakudo-moar 1512da: OUTPUT«Bool::True␤»

[16:09] <lizmat> m: dd (v2.3).plus

[16:09] <camelia> rakudo-moar 1512da: OUTPUT«Bool::False␤»

[16:09] <MadcapJake> m: v2.3+ ~~ v2.2.4

[16:09] <camelia> rakudo-moar 1512da: ( no output )

[16:09] <MadcapJake> m: say v2.3+ ~~ v2.2.4

[16:09] <camelia> rakudo-moar 1512da: OUTPUT«False␤»

[16:10] * skids suspects there will eventually be a need for an array of ranges of Version many places they are used, so this all would just be a convenience.

[16:10] <skids> e.g. to skip a buggy release.

[16:11] <MadcapJake> fwiw, I'm not aware of any semver model that allows for * equivalents anywhere but at the end of a version

[16:12] <ugexe> maybe Range should be a parameterized role so users can can `use v1.*.roll`

[16:12] <lizmat> that's why I want v2.3+ to be a Range, so you can use it like any other Range

[16:13] <MadcapJake> but I do have an affinity to how npm does it: ~1.0.4 means "I installed 1.0.4 but you can upgrade any patch release" and ^1.0.4 means "I installed 1.0.4 but you can upgrade to any minor release" and * or 'x' means "any major release is fine"

[16:14] <ugexe> that seems to rely on semantic versions

[16:15] <MadcapJake> so maybe allowing v1.2+.4 would be cool for that "any minor release" case.  This way you can be aware of what version you have *and* what's an acceptable upgrade path

[16:15] <MadcapJake> ugexe: yeah it does but I just mean for inspiration, specifically in terms of allowing a + after any element of a version literal

[16:15] <lizmat> well, that's a step further again from v1.2.*.4

[16:16] <MadcapJake> lizmat: maybe not further but a sidestep :)

[16:16] <lizmat> that would basically turn a version into a sequence of regexes

[16:16] <lizmat> Basically, my premise is that Version is now hacked into using for two functions:

[16:17] <MadcapJake> lizmat: it would translate to a version v1.2 but allow you to pull the actual version via Str

[16:17] <MadcapJake> correction: v1.2+ would be the actual version matcher

[16:17] <lizmat> 1. specification of a fixed version, like in META6.JSON a module claiming to be v.1.2

[16:17] <lizmat> 2. specification of an acceptable version, like in META6.JSON in a depends specification

[16:18] <lizmat> I think these functiionalitiies are currentlly conflated

[16:18] <MadcapJake> my $v = v1.2+.4; $v.Str #={'v1.2.4'}; $v ~~ v1.3 #={True}; # what I'm proposing

[16:20] <lizmat> so the Str representation would not visualize the range aspect ?

[16:21] <MadcapJake> In that idea, I would say no because you're looking for Str value, what would visualizing the range accomplish?  Having a Str value would allow you to create per-version anything (dir, files, hashes, etc)

[16:25] <lizmat> would v1.2.4 and v1.2+.4 be eqv ?

[16:25] <lizmat> because that is using .Str comparison atm

[16:26] <MadcapJake> I would say that ~~ should convert plus'd versions into ranges

[16:27] <lizmat> ~~ is not eqv

[16:28] <MadcapJake> hmm

[16:29] <MadcapJake> m: say v1.2+ eqv v1.2

[16:29] <camelia> rakudo-moar 1512da: OUTPUT«False␤»

[16:29] <MadcapJake> I'd say stick to that same semantics

[16:30] <stmuk_> lizmat: FYI I'm hoping to the R* release before you do the p6weekly

[16:30] <stmuk_> ^ to do the

[16:30] <lizmat> stmuk_: that would be great!

[16:31] <stmuk_> http://pl6anet.org/drop/rakudo-star-2016.04-RC2.tar.gz

[16:31] <stmuk_> but I'm on Pacific Time!

[16:31] <lizmat> I'll prepare the P6W later today, will be travelling most of tomorrow, and then either very late on Mon or early on Tue do the P6W

[16:31] <MadcapJake> although I *could* see eqv there being True but perhaps we don't want to change the semantics of `v1.2+ eqv v1.2` ?

[16:32] <lizmat> well... I'm still not convinced keeping the two uses of Version in the same object, is a good idea in the long run

[16:33] <MadcapJake> lizmat: I think the two uses are connected though, (1) validation and (2) comparison

[16:33] <lizmat> see S11:547

[16:33] <synopsebot6> Link: http://design.perl6.org/S11.html#line_547

[16:33] <stmuk_> later might be better for the R*

[16:34] <lizmat> "so :ver<6.2.3+> is short for :ver(v6.2.3 .. v6.2.*)"

[16:34] <lizmat> so that actually states that it is a Range

[16:36] <MadcapJake> lizmat: thanks for the Syn link, this is actually exactly what I was looking for yesterday :)

[16:37] <lizmat> stmuk_: noted  :-)

[16:38] <MadcapJake> interesting that :ver(v1.2.1 | v1.3.4) is allowed too :)

[16:38] <lizmat> it's all just smartmatching, really  :-)

[16:39] <MadcapJake> i'm starting to see that :)

[16:39] <lizmat> m: say "foo" if v2.3 ~~ v1.2.1 | v2.2 | v2.3

[16:39] <camelia> rakudo-moar 1512da: OUTPUT«foo␤»

[16:39] <skids> I think what this boils down to is that in a lot of cases where you need a group of versions, you also have one that is special -- e.g. the providing module's version or a preferred version.

[16:40] <ugexe> m: use Test:ver({ 1 * 3 });

[16:40] <camelia> rakudo-moar 1512da: ( no output )

[16:41] <MadcapJake> skids: that's true, that's the purpose behind my v1.2+.3 idea; it contains the installed version (v1.2.3) and the matcher (v1.2+)

[16:43] <MadcapJake> lizmat: I would say that case #1 is really just a string, right? I don't see the point in separating the two when the first case is so simple.

[16:44] <lizmat> MadcapJake: no, it's not just a string, unfortunately

[16:44] <MadcapJake> what's the difference between v1.2.4 and "1.2.4"

[16:45] <lizmat> m: say "1.20.1" cmp "1.2.1"

[16:45] <camelia> rakudo-moar 1512da: OUTPUT«More␤»

[16:45] <lizmat> m: say "1.10.1" cmp "1.2.1"

[16:45] <camelia> rakudo-moar 1512da: OUTPUT«Less␤»

[16:45] <lizmat> m: say v1.10.1 cmp v1.2.1

[16:45] <camelia> rakudo-moar 1512da: OUTPUT«More␤»

[16:45] <lizmat> each component of the Version string is checked separately

[16:46] <lizmat> m: say v1.10 cmp v1.10.abcd

[16:46] <camelia> rakudo-moar 1512da: OUTPUT«More␤»

[16:46] <lizmat> that's because missing components get replaced by Int() 0, and numerics always are More than Str

[16:51] <MadcapJake> ok, yeah. is that any different though from how you'd do cmp for a v1.2.*?

[16:52] <lizmat> actually, I think cmp for a version with a Whatever, is currently broken

[16:52] *** hankache joined
[16:52] <lizmat> and has been for a while afaics

[16:52] <MadcapJake> yeah seems so, does it just get turned into a 0?

[16:54] <lizmat> hmmm... maybe it works out anyway...  :-)

[16:55] * lizmat is getting tired

[16:55] <lizmat> too many short nights in a row

[16:58] * MadcapJake isn't sure what the intended semantics of cmp'ing versions with *'s

[16:59] <MadcapJake> are*

[17:00] <MadcapJake> m: say v1.2.4 cmp v1.2.* # I would think this would return Same

[17:00] <camelia> rakudo-moar 1512da: OUTPUT«More␤»

[17:02] <MadcapJake> lizmat: have a good night then! ping me if you make any headway with this version stuff, I'm interested in how it all ends up

[17:04] <lizmat> MadcapJake: no rest for the wicked...  ;-)

[17:04] <lizmat> just expressing lack of being able to think straight from tiredness  :-)

[17:04] <MadcapJake> ahh! I know the feeling xD

[17:05] * MadcapJake is off to lunch &

[17:26] <awwaiid> I'm trying to debug the REPL.pm lifting of code out of nqp and into rakudo on the jvm. I want to sprinkle some nqp::say type debugging into nqp and rakudo. The nqp/ bit make / make install'd ok, but when I pop back out to rakudo and make I keep getting "Missing or wrong version of dependency 'gen/jvm/stage2/QAST.nqp'" -- any pointers?

[17:28] <timotimo> awwaiid: at some point things in precompilation blew up hugely when you had says in the wrong places

[17:28] <timotimo> because the output ended up in files that weren't expecting to have debug stuff in them

[17:28] <timotimo> btw, you can use "note" in nqp code to output strings to stderr

[17:32] *** mst left
[17:34] <awwaiid> ok, yes I did run into that before. What is a good way to reset? I did 'make clean' in rakudo and then make still has issues. According to git diff all my current debugging output is to stderr

[17:34] <timotimo> you may have to make clean; make install inside nqp

[17:35] <awwaiid> ok, trying that

[17:35] <lizmat> rm -rf install

[17:35] <lizmat> might also help

[17:35] <awwaiid> ok, I'll try that after this :)

[17:35] <awwaiid> since it's complaining about stuff in gen/jvm, maybe I'll rm that stuff too

[17:36] <awwaiid> (again, if other things don't work. one var at a time)

[17:45] <psch> awwaiid: r-j is much more picky wrt left-over files, in my experience

[17:45] <psch> i usually git clean -xdf before every rebuild

[17:46] <psch> Pod.pm is one that i often get complaints about, too

[18:17] <dalek> rakudo/nom: c066434 | leont++ | tools/build/Makefile- (4 files):

[18:17] <dalek> rakudo/nom: Make perl 5 calls in Makefile more explicit

[18:17] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/c066434453

[18:17] <dalek> rakudo/nom: 8a5b0be | leont++ | / (3 files):

[18:17] <dalek> rakudo/nom: Try to avoid using perl5 in small commands

[18:17] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/8a5b0bef57

[18:17] <dalek> rakudo/nom: 531a044 | leont++ | / (3 files):

[18:17] <dalek> rakudo/nom: Convert create-moar-runner to perl 6

[18:17] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/531a044db1

[18:17] <dalek> rakudo/nom: 13ea1a1 | leont++ | / (8 files):

[18:17] <dalek> rakudo/nom: Use pure-perl6 harness

[18:17] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/13ea1a107b

[18:18] <timotimo> *neat*

[18:18] <dalek> rakudo/nom: 4232204 | lizmat++ | src/core/Any.pm:

[18:18] <dalek> rakudo/nom: Make dd for lazy list not look like valid .perl

[18:18] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/42322043ea

[18:29] <lizmat> drink!

[18:29] <lizmat> &

[19:03] *** cognominal joined
[19:40] <timotimo> do we even actually need @autovivs for bless and BUILDALL

[19:41] *** Skarsnik joined
[20:59] <moritz> timotimo: iirc there's an obscure feature for initializing the attributes from a parent class

[20:59] <timotimo> yeah

[20:59] <timotimo> but is that actually implemented?

[21:00] <moritz> Foo.new(x => 42, Bar{ x => 23 })

[21:00] <timotimo> or just a performance drain?

[21:00] <moritz> probably not

[21:00] <moritz> but pre-nom it was iplemented, iirc

[21:01] <timotimo> ugh

[21:08] * masak .oO( le prénom, il a été implémentée )

[21:52] <awwaiid> psch: thanks, git clean -xdf, while tedious, did the trick

[22:17] <dalek> rakudo/generate_buildallplan_2: e76d070 | timotimo++ | src/ (3 files):

[22:17] <dalek> rakudo/generate_buildallplan_2: get a tiny head-start on generating buildallplan code in CompilerServices

[22:17] <dalek> rakudo/generate_buildallplan_2: review: https://github.com/rakudo/rakudo/commit/e76d070a45

[22:17] <dalek> rakudo/generate_buildallplan_2: 8d1725d | timotimo++ | src/Perl6/ (2 files):

[22:17] <dalek> rakudo/generate_buildallplan_2: implement a lot more for code-genning BUILDALLPLAN.

[22:17] <dalek> rakudo/generate_buildallplan_2:

[22:17] <dalek> rakudo/generate_buildallplan_2: currently creates a setting that immediately crashes

[22:17] <dalek> rakudo/generate_buildallplan_2: when it gets loaded. not sure why.

[22:17] <dalek> rakudo/generate_buildallplan_2: review: https://github.com/rakudo/rakudo/commit/8d1725daf5

[22:41] <timotimo> jnthn: i think i need your help with this branch; i'm potentially using the MOP wrong or something like that, but i can't quite figure out what's going wrong

[22:41] <timotimo> https://github.com/rakudo/rakudo/commit/8d1725daf5  -  corresponding backtrace when trying to build the restricted setting
