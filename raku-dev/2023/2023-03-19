[00:00] *** reportable6 left
[00:01] *** reportable6 joined
[01:26] *** japhb left
[01:31] *** japhb joined
[01:36] *** japhb left
[01:48] *** japhb joined
[05:39] *** shareable6 left
[05:39] *** statisfiable6 left
[05:39] *** benchable6 left
[05:39] *** squashable6 left
[05:39] *** reportable6 left
[05:39] *** nativecallable6 left
[05:39] *** sourceable6 left
[05:39] *** unicodable6 left
[05:39] *** committable6 left
[05:39] *** tellable6 left
[05:39] *** bloatable6 left
[05:39] *** evalable6 left
[05:39] *** bisectable6 left
[05:39] *** greppable6 left
[05:39] *** quotable6 left
[05:39] *** releasable6 left
[05:39] *** coverable6 left
[05:39] *** notable6 left
[05:39] *** linkable6 left
[05:39] *** evalable6 joined
[05:40] *** benchable6 joined
[05:40] *** tellable6 joined
[05:40] *** squashable6 joined
[05:40] *** shareable6 joined
[05:40] *** sourceable6 joined
[05:40] *** greppable6 joined
[05:40] *** committable6 joined
[05:41] *** bloatable6 joined
[05:41] *** quotable6 joined
[05:41] *** coverable6 joined
[05:41] *** unicodable6 joined
[05:41] *** reportable6 joined
[05:41] *** linkable6 joined
[05:42] *** statisfiable6 joined
[05:42] *** nativecallable6 joined
[05:42] <SmokeMachine> \o/ I was missing that .do for a very long time!!!
[05:42] *** releasable6 joined
[05:42] *** notable6 joined
[05:42] *** bisectable6 joined
[05:50] *** initrd joined
[06:00] *** reportable6 left
[06:00] *** initrd left
[06:02] <SmokeMachine> .ask lizmat sorry for interrupting, but I was searching for some of my old messages on irclogs, and I can find people answering me, but not my own messages… any reason for that?
[06:02] <tellable6> SmokeMachine, I'll pass your message to lizmat
[06:03] *** reportable6 joined
[06:03] *** japhb left
[06:04] <SmokeMachine> Even this message ^^ I can see tellable’s answer, but not my message…
[06:04] *** japhb joined
[06:05] <SmokeMachine> .tell sorry! My mistake! I was filtering out my nick for some reason…
[06:05] <tellable6> SmokeMachine, I cannot recognize this command. See wiki for some examples: https://github.com/Raku/whateverable/wiki/Tellable
[06:08] *** initrd joined
[06:21] <SmokeMachine> Should we close this then? https://github.com/Raku/problem-solving/issues/122
[06:43] *** japhb left
[06:44] *** japhb left
[06:44] *** japhb joined
[09:19] *** initrd left
[10:06] <discord-raku-bot> <Nemokosch> Why is .&{} not enough?
[10:40] *** linkable6 left
[10:40] *** evalable6 left
[10:40] *** evalable6 joined
[10:43] *** linkable6 joined
[10:55] <lizmat> because .do returns the invocant always (something I missed initially)
[10:55] <tellable6> 2023-03-19T06:02:54Z #raku-dev <SmokeMachine> lizmat sorry for interrupting, but I was searching for some of my old messages on irclogs, and I can find people answering me, but not my own messages… any reason for that?
[10:57] *** codesections left
[10:57] *** codesections joined
[10:58] <discord-raku-bot> <Nemokosch> Is this worthy of huffmanisation?
[10:59] <lizmat> other languages seem to think so
[10:59] <discord-raku-bot> <Nemokosch> Other languages don't have .&{}
[10:59] <discord-raku-bot> <Nemokosch> Anyway, what other languages?
[11:04] *** Xliff joined
[12:00] *** reportable6 left
[12:03] *** reportable6 joined
[12:29] <Geth> ¦ rakudo/main: 18a5dab5e4 | (Elizabeth Mattijsen)++ | src/core.c/RakuAST/Raku.pm6
[12:29] <Geth> ¦ rakudo/main: RakuAST: convert large elsif into a dispatch table
[12:29] <Geth> ¦ rakudo/main: review: https://github.com/rakudo/rakudo/commit/18a5dab5e4
[12:31] <lizmat> Kotlin was the one mentioned to me: https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/apply.html
[12:31] <lizmat> but since we already have Supply.do with similar semantics, the name "do" was chosen
[12:36] *** Guest10 joined
[12:37] *** Guest10 left
[12:37] *** Guest10 joined
[12:37] *** Guest10 is now known as XliffMac
[13:14] <Geth> ¦ rakudo/main: b8488d24d3 | (Elizabeth Mattijsen)++ | 2 files
[13:14] <Geth> ¦ rakudo/main: RakuAST: add adverb handling to RakuAST::QuotedRegex .raku/deparsing
[13:14] <Geth> ¦ rakudo/main: review: https://github.com/rakudo/rakudo/commit/b8488d24d3
[13:26] *** XliffMac left
[13:44] <Geth> ¦ rakudo/main: 83ed64e96d | (Elizabeth Mattijsen)++ | 8 files
[13:44] <Geth> ¦ rakudo/main: RakuAST: make RakuAST::ColonPair::True|False take a positional
[13:44] <Geth> ¦ rakudo/main: 
[13:44] <Geth> ¦ rakudo/main: Rather than a named "key" parameter.  There is only one parameter to
[13:44] <Geth> ¦ rakudo/main: specify, so make it a positional.  Adapt actions, .raku, deparsing
[13:44] <Geth> ¦ rakudo/main: and testing accordingly.
[13:44] <Geth> ¦ rakudo/main: review: https://github.com/rakudo/rakudo/commit/83ed64e96d
[13:52] *** ab5tract joined
[13:52] *** ab5tract left
[13:59] *** Guest10 joined
[14:00] *** Guest10 left
[14:02] *** Guest10 joined
[14:02] *** Guest10 is now known as XliffMac
[14:14] *** XliffMac left
[14:34] *** jacob_c left
[14:36] *** Guest10 joined
[14:57] <Xliff> Raku-GLib suite timing statistics for Raku 2023.02.191.g.837.a.2.eb.87
[14:57] <Xliff> Total number of projects: 33 (503277 loc)
[14:57] <Xliff> Total non-parallel compile times: 9102.240 (275.825 avg)
[14:57] <Xliff> Total parallel compile times: 2279.930 (69.089 avg) 3.992x speedup
[14:57] <Xliff> These are the timing values from last week.
[14:58] *** jacob_c joined
[14:58] <Xliff> Note parallel time increase of over 900 seconds.
[14:58] <Xliff> from the 27th of last month, which was ~1400 seconds.
[14:59] *** Xliff left
[15:02] <lizmat> Xliff: fwiw, I don't see anything in the change log that immediately jumps out as a possible reason
[15:02] <tellable6> lizmat, I'll pass your message to Xliff
[15:03] *** Guest10 left
[15:05] *** Xliff joined
[15:07] <Xliff> lizmat: Are you tracking chages at both the NQP and the MoarVM level?
[15:07] <lizmat> I was just looking at the Rakudo log, true
[15:07] <Xliff> Ah.
[15:08] <lizmat> there was one bump  for https://github.com/MoarVM/MoarVM/commit/6adfc376cb8e288368620254bdd34d99244507d5
[15:08] <lizmat> perhaps that affected the JIT ?
[15:10] <Xliff> Anything is possible. A small change in something that affacts IO will greatly affect the timings.
[15:10] <Xliff> The reason why parallel is so up and down is that it uses file as opposed to dir locking.
[15:11] <Xliff> And as much as I try to stay off the machine when the parallel timings run, anything could jump up and create more chaos in the environment.
[15:11] <Xliff> Still...really weird to see a jump of 900 seconds in a week.
[15:11] <Xliff> I'll do this week's parallels in a minute.
[15:13] *** jacob_c left
[17:55] *** Xliff left
[18:00] *** reportable6 left
[18:00] *** reportable6 joined
[18:26] *** jacob_c joined
[18:33] *** jacob_c left
[19:28] *** codesections left
[19:46] *** guifa_ joined
[19:49] *** guifa left
[20:11] <SmokeMachine> Nemokosch: but .&{} is not equivalent to .do({}). .do returns the original value, so, 42.do: { $!next = $_ + 1 }; would return 42 and store 43 on $!next…
[20:11] <tellable6> SmokeMachine, I'll pass your message to Nemokosch
[20:13] <discord-raku-bot> <Nemokosch> But this is such a minor detail that I wouldn't introduce a language change for that. Where would this approach lead to?
[20:28] <ugexe> One thing that comes to mind is it’s odd that .do and .&do would be different 
[20:29] <ugexe> I dunno if there even is a .&do though and I can’t check at the moment 
[20:42] <vrurg> m: $v = 42; say $v.&do(* + 2);
[20:42] <camelia> rakudo-moar 83ed64e96: OUTPUT: «===SORRY!=== Error while compiling <tmp>␤Variable '$v' is not declared.  Perhaps you forgot a 'sub' if this was␤intended to be part of a signature?␤at <tmp>:1␤------> <BOL>⏏$v = 42; say $v.&do(* + 2);␤»
[20:46] <vrurg> I don't see what would be the real use for such q .do. Besides,
[20:47] <vrurg> Besides, `do {...}` has different semantics and that would be confusing.
[20:48] <vrurg> If there is use for such method then we'd better follow Seq and name it snitch. 
[20:56] <timo1> .o( like given but backwards )
[21:56] <discord-raku-bot> <Nemokosch> .&{}, andthen, given...
[22:02] <vrurg> andthen has 'with' semantics.
[22:02] <vrurg> I see why one would like to have something in a method call chain. So, it's rather a matter of naming the method.
[22:04] <vrurg> *something like that
[22:39] <discord-raku-bot> <Nemokosch> let's be honest. How often does anybody want to topicalize to something undefined?
[22:40] <discord-raku-bot> <Nemokosch> and if somebody does want that, is something that looks like a chained method call, really the best idea to express it
[22:42] <discord-raku-bot> <Nemokosch> anyway, if the only supposed difference to .&{} would be that the return value is always the object it's invoked upon, then please don't, for the social aspect. It's a very bad precedent of pushing extremely redundant interfaces into the core language.
[22:53] <vrurg> self.first(&condition).snitch({ die "oops!" if bad-value($_) }).then.some.more.methods
[22:53] <lizmat> I've closed the PR
[22:53] <lizmat> https://docs.raku.org/routine/snitch.html does all of this already  
[22:55] <vrurg> Oh, my... I missed the non-Seq candidate of it. Of course!
[22:56] <vrurg> BTW, I had a use for it not so long ago and felt pity of it being a Seq only. OK... :)
[22:59] <discord-raku-bot> <Nemokosch> > self.first(&condition).snitch({ die "oops!" if bad-value($) }).then.some.more.methods couldn't this be completely complemented by .&{ die "oops!" if bad-value($); $_ }.then.some.more.methods ?
[23:12] <vrurg> One would have to remember to add that $_ at the end. Besides, my personal opinion: it reduces code accuracy, adds extra noise to it.
[23:23] <discord-raku-bot> <Nemokosch> I think this is a very slippery position. At the end of the day, every time there isn't something built-in for what one wants to do exactly, one needs to remember the exact code composition that does just that. Back to case of .&{} - there is nothing obscure, unexpected or structurally inconvenient (e.g no new syntactical unit added to the code) about adding $_ there, if that's what the author meant. And this is actually the
[23:23] <discord-raku-bot> beauty of it: at the cost of setting the return value of a block (which is something people do all the time), different effects can be achieved using the same structure. It's only "noise" if we assume there is no choice to make.
