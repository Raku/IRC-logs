[00:00] *** reportable6 left
[00:01] *** reportable6 joined
[01:23] *** Xliff left
[02:02] *** squashable6 left
[02:02] *** squashable6 joined
[02:09] *** ab5tract left
[03:09] *** sourceable6 left
[03:09] *** reportable6 left
[03:09] *** quotable6 left
[03:09] *** committable6 left
[03:09] *** nativecallable6 left
[03:09] *** bloatable6 left
[03:09] *** coverable6 left
[03:09] *** benchable6 left
[03:09] *** shareable6 left
[03:09] *** releasable6 left
[03:09] *** squashable6 left
[03:09] *** unicodable6 left
[03:09] *** linkable6 left
[03:09] *** greppable6 left
[03:09] *** tellable6 left
[03:09] *** statisfiable6 left
[03:09] *** evalable6 left
[03:09] *** bisectable6 left
[03:09] *** notable6 left
[03:09] *** unicodable6 joined
[03:09] *** shareable6 joined
[03:09] *** evalable6 joined
[03:10] *** sourceable6 joined
[03:10] *** releasable6 joined
[03:10] *** linkable6 joined
[03:10] *** committable6 joined
[03:10] *** coverable6 joined
[03:10] *** greppable6 joined
[03:10] *** tellable6 joined
[03:11] *** bisectable6 joined
[03:11] *** bloatable6 joined
[03:11] *** nativecallable6 joined
[03:11] *** statisfiable6 joined
[03:11] *** squashable6 joined
[03:11] *** reportable6 joined
[03:11] *** quotable6 joined
[03:12] *** notable6 joined
[03:12] *** benchable6 joined
[04:42] *** Kaipei left
[05:42] *** squashable6 left
[05:42] *** notable6 left
[05:42] *** shareable6 left
[05:42] *** evalable6 left
[05:42] *** tellable6 left
[05:42] *** committable6 left
[05:42] *** coverable6 left
[05:42] *** linkable6 left
[05:42] *** quotable6 left
[05:42] *** unicodable6 left
[05:42] *** sourceable6 left
[05:42] *** statisfiable6 left
[05:42] *** bisectable6 left
[05:42] *** greppable6 left
[05:42] *** releasable6 left
[05:42] *** nativecallable6 left
[05:42] *** reportable6 left
[05:42] *** quotable6 joined
[05:43] *** coverable6 joined
[05:43] *** shareable6 joined
[05:43] *** statisfiable6 joined
[05:43] *** releasable6 joined
[05:43] *** nativecallable6 joined
[05:43] *** committable6 joined
[05:43] *** notable6 joined
[05:44] *** sourceable6 joined
[05:44] *** squashable6 joined
[05:44] *** bisectable6 joined
[05:44] *** evalable6 joined
[05:44] *** reportable6 joined
[05:45] *** greppable6 joined
[05:45] *** tellable6 joined
[05:45] *** linkable6 joined
[05:45] *** unicodable6 joined
[06:00] *** reportable6 left
[06:03] *** reportable6 joined
[07:26] *** bloatable6 left
[07:26] *** benchable6 left
[07:26] *** greppable6 left
[07:26] *** sourceable6 left
[07:26] *** releasable6 left
[07:26] *** reportable6 left
[07:26] *** shareable6 left
[07:26] *** squashable6 left
[07:26] *** coverable6 left
[07:26] *** unicodable6 left
[07:26] *** bisectable6 left
[07:26] *** statisfiable6 left
[07:26] *** quotable6 left
[07:26] *** nativecallable6 left
[07:26] *** evalable6 left
[07:27] *** coverable6 joined
[07:27] *** evalable6 joined
[07:28] *** nativecallable6 joined
[07:28] *** squashable6 joined
[07:28] *** bisectable6 joined
[07:28] *** benchable6 joined
[07:28] *** greppable6 joined
[07:28] *** bloatable6 joined
[07:28] *** sourceable6 joined
[07:28] *** statisfiable6 joined
[07:29] *** releasable6 joined
[07:29] *** reportable6 joined
[07:29] *** quotable6 joined
[07:29] *** unicodable6 joined
[07:30] *** shareable6 joined
[08:30] *** linkable6 left
[08:30] *** evalable6 left
[08:31] *** linkable6 joined
[08:33] *** evalable6 joined
[09:24] <Geth> ¦ rakudo/main: 5758c35172 | (Stefan Seifert)++ | src/Raku/ast/signature.rakumod

[09:24] <Geth> ¦ rakudo/main: RakuAST: fix variable $_ not resolved on parameters with where blocks

[09:24] <Geth> ¦ rakudo/main: 

[09:24] <Geth> ¦ rakudo/main: When PERFORM-BEGIN is called implicitly via IMPL-CHECK, it's not

[09:24] <Geth> ¦ rakudo/main: sufficient to ensure the newly generated nodes begin is performed as at

[09:24] <Geth> ¦ rakudo/main: that point resolution of names has already been performed. Intead we

[09:24] <Geth> ¦ rakudo/main: need to run the full IMPL-CHECK routine.

[09:24] <Geth> ¦ rakudo/main: review: https://github.com/rakudo/rakudo/commit/5758c35172

[09:44] <Geth> ¦ rakudo/main: c5c93a9281 | (Stefan Seifert)++ | src/Raku/ast/variable-declaration.rakumod

[09:44] <Geth> ¦ rakudo/main: RakuAST: Support binding to anonymous state variables

[09:44] <Geth> ¦ rakudo/main: review: https://github.com/rakudo/rakudo/commit/c5c93a9281

[09:44] <nine> And 90 make test files passing

[10:29] *** Kaipei joined
[10:35] *** sena_kun left
[10:46] *** sena_kun joined
[10:56] <Geth> ¦ rakudo/main: e9030098e9 | (Elizabeth Mattijsen)++ | 2 files

[10:56] <Geth> ¦ rakudo/main: Fix several issues with deparsing quoted strings

[10:56] <Geth> ¦ rakudo/main: 

[10:56] <Geth> ¦ rakudo/main: - added RakuAST::QuotedString.has-variable method, which returns

[10:56] <Geth> ¦ rakudo/main:   True if any of the segments is a variable

[10:56] <Geth> ¦ rakudo/main: - a single 'exec' processor without variables now deparses as

[10:56] <Geth> ¦ rakudo/main:   qx//, with variables as qqx//

[10:56] <Geth> ¦ rakudo/main: review: https://github.com/rakudo/rakudo/commit/e9030098e9

[10:56] <Geth> ¦ rakudo/main: 14958337e7 | (Elizabeth Mattijsen)++ | t/12-rakuast/strings.rakutest

[10:56] <Geth> ¦ rakudo/main: Add extensive deparsing tests for quoted strings

[10:56] <Geth> ¦ rakudo/main: review: https://github.com/rakudo/rakudo/commit/14958337e7

[10:56] <Geth> ¦ rakudo/main: d8854eb690 | (Elizabeth Mattijsen)++ | t/12-rakuast/heredocs.rakutest

[10:56] <Geth> ¦ rakudo/main: Make heredocs test TAP output more descriptive

[10:56] <Geth> ¦ rakudo/main: review: https://github.com/rakudo/rakudo/commit/d8854eb690

[11:08] <nine> lizmat: I'm curious. How do you make sure your commits don't cause any regressions?

[11:08] <lizmat> by running "make test" ?

[11:09] <nine> and spectest presumably

[11:09] <lizmat> and an occasional "make spectest", but not all of the time

[11:10] <lizmat> I mean, I'm only working on deparsing stuff

[11:10] <nine> But then you cannot be sure?

[11:10] <lizmat> spectest doesn't have any deparsing stuff

[11:10] <nine> Sure it does. Since there are now 2 places where RakuAST code itself uses deparse, all code has the potential to run deparse

[11:10] <lizmat> running a spectest takes 3.5 minutes for me

[11:11] <nine> I run `TEST_JOBS=20 RAKUDO_RAKUAST=1 make spectest | grep '\. ok' | sort | tee $(git describe).pure.tests` and then vimdiff with the previous results file to avoid getting a new test working but losing some other test

[11:13] <lizmat> well, if my work breaks anything, then there's a missing test in the deparsing part

[11:14] <lizmat> and the test should be added and the problem fixed

[11:37] <lizmat> nine: FWIW, t/spec/S02-names/is_cached.t hangs for me with RAKUAST=1

[11:37] <nine> I know, I'm currently investigating

[11:38] <lizmat> it parses ok

[11:38] <lizmat> I guess recursive calls are NYI ?

[11:40] <lizmat> nine: is this something I did?

[11:40] <nine> No, it golfs to sub fib() { }; BEGIN &fib.wrap(-> |c { callsame }); dd fib()

[11:41] <nine> The hang is not a regression. It's just that before one of my recent fixes it didn't compile at all

[11:41] <lizmat> *phew*

[11:41] <lizmat> aahhh  ok

[11:41] <lizmat> the joys of successful compilation :-)

[11:43] <nine> It's yet another BEGIN time execution issue. Probably a new code path that leads to a missing call to add-clone-for-cuid

[11:46] *** linkable6 left
[11:46] *** evalable6 left
[11:46] *** linkable6 joined
[11:46] *** evalable6 joined
[12:00] *** reportable6 left
[12:02] *** reportable6 joined
[12:15] <nine> This may topple the whole house of cards that is BEGIN time execution...

[12:20] <lizmat> oh dear

[12:21] <nine> The root of the problem is that we create QAST nodes much later than the old compiler frontend. The old compiler could create a stub for code objects and in the same process the QAST::Block object that generates the cuid. This cuid is important when tracking clones of the code object. When a code object gets compiled dynamically (i.e. at BEGIN time) we need to replace its $!do and the $!do of all clones.

[12:22] <nine> If a clone is not registered yet in the clone list, we miss it and then end up in an infinite loop as we dynamically compile, but replace only the $!do of the original and then try to call the stub again, which compiles...

[12:22] <lizmat> so we would need to create a to$!do list ?

[12:22] <lizmat> and then we don't even think of BEGIN blocks in BEGIN blocks, right ?

[12:23] <nine> We already have such a list. But that only gets filled if IMPL-LINK-META-OBJECT was called already and that's part of creating QAST, which in the above example happens after running that BEGIN block

[12:24] <nine> But I do see hope: the whole conundrum is because we rely on the cuid to find clones. Maybe we just have to manage them differently.

[12:35] <lizmat> sometimes I feel we're on the bleeding edge of compiler design / implementation  :-)

[12:50] <nine> It's not just a feeling. We certainly are.

[13:34] <nine> Weak references would be nice for this

[13:54] <Geth> ¦ rakudo/main: 034ed9ac09 | (Elizabeth Mattijsen)++ | src/core.c/RakuAST/Deparse.pm6

[13:54] <Geth> ¦ rakudo/main: Hopefully fix deparsing of ApplyPostfix

[13:54] <Geth> ¦ rakudo/main: 

[13:54] <Geth> ¦ rakudo/main: Looks like only Methodish things need the '.'

[13:54] <Geth> ¦ rakudo/main: Also make sure there's a space between the Term::Reduce infix op

[13:54] <Geth> ¦ rakudo/main: and the args: [+](1,2,3) would work, but [+]@foo not.

[13:54] <Geth> ¦ rakudo/main: review: https://github.com/rakudo/rakudo/commit/034ed9ac09

[13:54] <Geth> ¦ rakudo/main: d9c9837e91 | (Elizabeth Mattijsen)++ | src/core.c/RakuAST/Deparse.pm6

[13:54] <Geth> ¦ rakudo/main: Tweak deparsing of Term::Reduce

[13:54] <Geth> ¦ rakudo/main: 

[13:54] <Geth> ¦ rakudo/main: And simplify deparsing of ArgList

[13:54] <Geth> ¦ rakudo/main: review: https://github.com/rakudo/rakudo/commit/d9c9837e91

[13:54] <Geth> ¦ rakudo/main: ac5a00906c | (Elizabeth Mattijsen)++ | src/core.c/RakuAST/Deparse.pm6

[13:54] <Geth> ¦ rakudo/main: Give dotty infix call assign some whitespace

[13:54] <Geth> ¦ rakudo/main: 

[13:54] <Geth> ¦ rakudo/main: For better readability of deparsed ASTs

[13:54] <Geth> ¦ rakudo/main: review: https://github.com/rakudo/rakudo/commit/ac5a00906c

[14:22] <Geth> ¦ rakudo/main: 2fb1427ab1 | (Elizabeth Mattijsen)++ | src/core.c/RakuAST/Deparse.pm6

[14:22] <Geth> ¦ rakudo/main: Deparse ColonPair::Value with strings as :foo<bar>

[14:22] <Geth> ¦ rakudo/main: 

[14:22] <Geth> ¦ rakudo/main: as opposed to :foo('bar'), to make it more match common usage

[14:22] <Geth> ¦ rakudo/main: review: https://github.com/rakudo/rakudo/commit/2fb1427ab1

[14:39] <Geth> ¦ rakudo/main: 8a5e0f8c0a | (Elizabeth Mattijsen)++ | src/core.c/RakuAST/Deparse.pm6

[14:39] <Geth> ¦ rakudo/main: Correct deparsing for :foo<bar> vs :foo('bar')

[14:39] <Geth> ¦ rakudo/main: 

[14:39] <Geth> ¦ rakudo/main: The <bar> syntax is subject to word / val processing, and the

[14:39] <Geth> ¦ rakudo/main: 'bar' syntax is not.  Reflect that properly in deparsing

[14:39] <Geth> ¦ rakudo/main: review: https://github.com/rakudo/rakudo/commit/8a5e0f8c0a

[14:43] <Geth> ¦ rakudo/main: 93ea024a02 | (Elizabeth Mattijsen)++ | 4 files

[14:43] <Geth> ¦ rakudo/main: Add deparse tests and make TAP more informative

[14:43] <Geth> ¦ rakudo/main: review: https://github.com/rakudo/rakudo/commit/93ea024a02

[15:23] <Geth> ¦ nqp/main: 97b87b4fd5 | (Stefan Seifert)++ | src/QAST/Block.nqp

[15:23] <Geth> ¦ nqp/main: Provide access to QAST::Block's cuid counter for RakuAST

[15:23] <Geth> ¦ nqp/main: 

[15:23] <Geth> ¦ nqp/main: In RakuAST we need to determine a cuid in advance, i.e. before we create

[15:23] <Geth> ¦ nqp/main: the QAST::Block object that the cuid will be used for. So provide an API

[15:23] <Geth> ¦ nqp/main: for getting the next cuid as well as for setting a specific cuid on a

[15:23] <Geth> ¦ nqp/main: block.

[15:23] <Geth> ¦ nqp/main: review: https://github.com/Raku/nqp/commit/97b87b4fd5

[15:23] <Geth> ¦ rakudo/main: 58fbc27c02 | (Stefan Seifert)++ | 2 files

[15:23] <Geth> ¦ rakudo/main: RakuAST: Hopefully finally fix BEGIN time execution hangs for good

[15:23] <Geth> ¦ rakudo/main: 

[15:23] <Geth> ¦ rakudo/main: The root of the problem is that we create QAST nodes much later than the old

[15:23] <Geth> ¦ rakudo/main: compiler frontend. The old compiler could create a stub for code objects and

[15:23] <Geth> ¦ rakudo/main: in the same process the QAST::Block object that generates the cuid. This cuid

[15:23] <Geth> ¦ rakudo/main: is important when tracking clones of the code object. When a code object gets

[15:23] <Geth> ¦ rakudo/main: compiled dynamically (i.e. at BEGIN time) we need to replace its $!do and the

[15:23] <Geth> ¦ rakudo/main: <…commit message has 11 more lines…>

[15:23] <Geth> ¦ rakudo/main: review: https://github.com/rakudo/rakudo/commit/58fbc27c02

[15:49] <Geth> ¦ JSON-JWT: 2colours self-assigned JSON::JWT Fails to install on 2022-12 Raku via Zef https://github.com/raku-community-modules/JSON-JWT/issues/6

[18:00] *** reportable6 left
[18:02] *** reportable6 joined
[19:23] *** Kaipei left
[19:35] *** Kaipei joined
[20:27] *** ab5tract joined
[20:33] *** epony left
[20:50] *** ab5tract left
[21:03] *** ab5tract joined
[21:07] *** ab5tract left
[21:45] *** sena_kun left
[21:47] *** sena_kun joined
[22:32] *** epony joined
