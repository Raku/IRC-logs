[00:03] *** reportable6 left
[00:04] *** reportable6 joined
[00:43] *** frost joined
[02:10] *** linkable6 left
[02:10] *** evalable6 left
[02:12] *** evalable6 joined
[03:12] *** linkable6 joined
[05:38] *** unicodable6 left
[05:38] *** reportable6 left
[05:38] *** coverable6 left
[05:38] *** nativecallable6 left
[05:38] *** tellable6 left
[05:38] *** bloatable6 left
[05:38] *** evalable6 left
[05:39] *** unicodable6 joined
[05:40] *** coverable6 joined
[05:40] *** reportable6 joined
[05:41] *** evalable6 joined
[05:41] *** tellable6 joined
[06:02] *** reportable6 left
[06:04] *** reportable6 joined
[06:15] *** Xliff left
[06:15] *** Xliff joined
[07:41] *** nativecallable6 joined
[08:56] *** [Tux] left
[09:39] *** bloatable6 joined
[10:30] *** squashable6 left
[10:32] *** squashable6 joined
[10:39] *** sena_kun joined
[10:42] <Geth> ¦ nqp/new-disp: ec787abdf1 | Altai-man++ (committed using GitHub Web editor) | tools/templates/MOAR_REVISION

[10:42] <Geth> ¦ nqp/new-disp: Update MOAR_REVISION

[10:42] <Geth> ¦ nqp/new-disp: review: https://github.com/Raku/nqp/commit/ec787abdf1

[10:43] <Geth> ¦ rakudo/new-disp: ba0e77cae3 | Altai-man++ (committed using GitHub Web editor) | tools/templates/NQP_REVISION

[10:43] <Geth> ¦ rakudo/new-disp: Update NQP_REVISION

[10:43] <Geth> ¦ rakudo/new-disp: review: https://github.com/rakudo/rakudo/commit/ba0e77cae3

[10:48] <Geth> ¦ nqp/lift_generator_hash_lookups: 8ea45b6445 | (Timo Paulssen)++ | src/vm/moar/QAST/QASTOperationsMAST.nqp

[10:48] <Geth> ¦ nqp/lift_generator_hash_lookups: move lookups of op generators out of repeated code

[10:48] <Geth> ¦ nqp/lift_generator_hash_lookups: 

[10:48] <Geth> ¦ nqp/lift_generator_hash_lookups: in some cases that moves it from the body of a closure that generates

[10:48] <Geth> ¦ nqp/lift_generator_hash_lookups: an op to the sub that creates the closure (when we use the same

[10:48] <Geth> ¦ nqp/lift_generator_hash_lookups: closure for ops that are extremely similar), and in others it moves

[10:48] <Geth> ¦ nqp/lift_generator_hash_lookups: the lookup from the body of a loop to before the loop, or from two

[10:48] <Geth> ¦ nqp/lift_generator_hash_lookups: usages to before the usages.

[10:48] <Geth> ¦ nqp/lift_generator_hash_lookups: review: https://github.com/Raku/nqp/commit/8ea45b6445

[10:49] <Geth> ¦ nqp: timo++ created pull request #737: move lookups of op generators out of repeated code

[10:49] <Geth> ¦ nqp: review: https://github.com/Raku/nqp/pull/737

[10:57] <Geth> ¦ nqp/lift_generator_hash_lookups: 93ccf380b3 | (Timo Paulssen)++ | src/vm/moar/QAST/QASTOperationsMAST.nqp

[10:57] <Geth> ¦ nqp/lift_generator_hash_lookups: move lookups of op generators out of repeated code

[10:57] <Geth> ¦ nqp/lift_generator_hash_lookups: 

[10:57] <Geth> ¦ nqp/lift_generator_hash_lookups: in some cases that moves it from the body of a closure that generates

[10:57] <Geth> ¦ nqp/lift_generator_hash_lookups: an op to the sub that creates the closure (when we use the same

[10:57] <Geth> ¦ nqp/lift_generator_hash_lookups: closure for ops that are extremely similar), and in others it moves

[10:57] <Geth> ¦ nqp/lift_generator_hash_lookups: the lookup from the body of a loop to before the loop, or from two

[10:57] <Geth> ¦ nqp/lift_generator_hash_lookups: usages to before the usages.

[10:58] <Geth> ¦ nqp/lift_generator_hash_lookups: review: https://github.com/Raku/nqp/commit/93ccf380b3

[11:22] <Geth> ¦ nqp/lift_generator_hash_lookups: 4e6d9bca05 | (Timo Paulssen)++ | src/vm/moar/QAST/QASTOperationsMAST.nqp

[11:22] <Geth> ¦ nqp/lift_generator_hash_lookups: move lookups of op generators out of repeated code

[11:22] <Geth> ¦ nqp/lift_generator_hash_lookups: 

[11:22] <Geth> ¦ nqp/lift_generator_hash_lookups: in some cases that moves it from the body of a closure that generates

[11:22] <Geth> ¦ nqp/lift_generator_hash_lookups: an op to the sub that creates the closure (when we use the same

[11:22] <Geth> ¦ nqp/lift_generator_hash_lookups: closure for ops that are extremely similar), and in others it moves

[11:22] <Geth> ¦ nqp/lift_generator_hash_lookups: the lookup from the body of a loop to before the loop, or from two

[11:22] <Geth> ¦ nqp/lift_generator_hash_lookups: usages to before the usages.

[11:22] <Geth> ¦ nqp/lift_generator_hash_lookups: review: https://github.com/Raku/nqp/commit/4e6d9bca05

[11:22] <timo> sorry for the noise :)

[11:29] *** hankache joined
[11:36] *** hankache left
[12:02] *** reportable6 left
[12:04] *** reportable6 joined
[12:14] <Geth> ¦ nqp/new-disp: 77a76c4584 | (Timo Paulssen)++ | src/vm/moar/QAST/QASTOperationsMAST.nqp

[12:14] <Geth> ¦ nqp/new-disp: move lookups of op generators out of repeated code

[12:14] <Geth> ¦ nqp/new-disp: 

[12:14] <Geth> ¦ nqp/new-disp: in some cases that moves it from the body of a closure that generates

[12:14] <Geth> ¦ nqp/new-disp: an op to the sub that creates the closure (when we use the same

[12:14] <Geth> ¦ nqp/new-disp: closure for ops that are extremely similar), and in others it moves

[12:14] <Geth> ¦ nqp/new-disp: the lookup from the body of a loop to before the loop, or from two

[12:14] <Geth> ¦ nqp/new-disp: usages to before the usages.

[12:14] <Geth> ¦ nqp/new-disp: review: https://github.com/Raku/nqp/commit/77a76c4584

[12:21] *** [Tux] joined
[12:44] *** frost left
[14:35] <lizmat> sanity question: does it ever make sense with Lock, to have a $lock.protect {  ...; $lock.protect { } } ???

[14:36] <lizmat> aaah... ok, if it inside of a Promise.then: {   }  I guess

[15:02] <sena_kun> releasable6, status

[15:02] <releasable6> sena_kun, Next release in ≈8 days and ≈3 hours. There are no known blockers. Changelog for this release was not started yet

[15:02] <releasable6> sena_kun, Details: https://gist.github.com/60a070c1fea2fa03acbb898f50d8aaf7

[15:28] <ugexe> you can start new threads inside a protect block

[15:32] <lizmat> ugexe: that too

[15:32] <lizmat> I was glancing through the Cache::Async code, and was going whaaa  ?

[15:33] *** evalable6 left
[15:33] *** linkable6 left
[16:33] *** evalable6 joined
[16:34] *** linkable6 joined
[16:57] *** sena_kun left
[17:49] *** leont left
[17:50] *** leont joined
[18:02] *** reportable6 left
[18:04] *** reportable6 joined
[18:16] *** melezhik joined
[18:19] *** melezhik left
[18:24] <Geth> ¦ rakudo/new-disp: 63f2f310f0 | (Jonathan Worthington)++ | 2 files

[18:24] <Geth> ¦ rakudo/new-disp: Eliminate setting no inline marker for callsame

[18:24] <Geth> ¦ rakudo/new-disp: 

[18:24] <Geth> ¦ rakudo/new-disp: And other such functions. With the new dispatch mechanism, MoarVM

[18:25] <Geth> ¦ rakudo/new-disp: already has the knowledge to only go inlining what it can (at the time

[18:25] <Geth> ¦ rakudo/new-disp: of writing it can't do any such inlinings, but it knows not to try and

[18:25] <Geth> ¦ rakudo/new-disp: then get it wrong).

[18:25] <Geth> ¦ rakudo/new-disp: review: https://github.com/rakudo/rakudo/commit/63f2f310f0

[18:38] <Xliff> m: say +DateTime.now

[18:38] <camelia> rakudo-moar b451f89b6: OUTPUT: «Cannot resolve caller Numeric(DateTime:D: ); none of these signatures match:␤    (Mu:U \v: *%_)␤  in block <unit> at <tmp> line 1␤␤»

[18:38] <Xliff> m: say DateTime.now.Int

[18:38] <camelia> rakudo-moar b451f89b6: OUTPUT: «No such method 'Int' for invocant of type 'DateTime'␤  in block <unit> at <tmp> line 1␤␤»

[18:38] <Xliff> Why don't either of those use .posix behind the scenes?

[18:40] <lizmat> there's a PR for that, afaik

[18:45] <Xliff> lizmat: That returns an Instant.

[18:45] <lizmat> m: dd now.Int

[18:45] <camelia> rakudo-moar b451f89b6: OUTPUT: «1631299590␤»

[18:46] <lizmat> hmmm

[18:46] <Xliff> Indeed. Also consider:

[18:47] <Xliff> m: now.Int.say; DateTime.now.posix.say

[18:47] <camelia> rakudo-moar b451f89b6: OUTPUT: «1631299659␤1631299622␤»

[18:47] <Xliff> m: now.^name.say

[18:47] <camelia> rakudo-moar b451f89b6: OUTPUT: «Instant␤»

[18:48] <Xliff> So I get a difference of 37 from both camelia and my local machine. Odd.

[18:50] <Xliff> m: my $m = 42.^lookup('Int'); $m.file.say; $m.line.say

[18:50] <camelia> rakudo-moar b451f89b6: OUTPUT: «SETTING::src/core.c/Int.pm6␤52␤»

[20:04] <japhb> Xliff: TAI v. UTC seconds (leap second offset)

[20:10] <Xliff> japhb: Is that value always going to be 37?

[20:11] <Xliff> Ah.... or will it drift further over time?

[20:13] <Xliff> Would 37 be a safe value up to the lifetime of the Obama's grandkids?! :)

[20:14] <Xliff> Rather... how long will that value be accurate?

[20:27] <lizmat> well, everybody thought that value would only increase..

[20:28] <lizmat> but now there's talk of a negative leap second..  in which case that value would decrease

[20:29] <Xliff> Figures. :)

[21:16] <japhb> Yeah, what lizmat++ said.  Personally I think doing a negative leap second would be a horrible idea, but I'm not exactly the one with decision authority on that one.  :-)

[21:18] <Xliff> So ballpark... how long will that 37 value last?

[21:19] <japhb> Xliff: ~months

[21:19] <japhb> Sometimes a few years

[21:24] <japhb> Xliff: Come to think of it, you can see the frequency in the Rakudo source -- search for `BEGIN leap-second-dates` in src/core.c/Rakudo/Internals.pm6

[21:28] <ugexe> so apparently there is something really slow about the table generated by `zef update`, which i assume is something like unneccesary stringification or some such. however it is interesting that 3.3ghz i7 macbook takes ~20s whereas a m1 takes ~10s

[21:41] <Xliff> ugexe: m1? Instance type?

[21:42] <ugexe> apple silicon

[21:45] <ugexe> both macs are maxed out 13" but they also means the intel is only a dual core

[21:46] <ugexe> s/they/that/

[22:05] <Xliff> ugexe: OK, cool.

[22:05] <Xliff> Getting the last pieces to my Threadripper setup, today. Want me to run anything?

[22:12] <ugexe> sounds like fun. if i think of anything i'll let you know

[22:51] *** evalable6 left
[22:51] *** linkable6 left
[22:52] *** evalable6 joined
[22:54] *** linkable6 joined
[23:54] *** coverable6 left
[23:54] *** tellable6 left
[23:54] *** linkable6 left
[23:54] *** unicodable6 left
[23:54] *** benchable6 left
[23:54] *** releasable6 left
[23:54] *** nativecallable6 left
[23:54] *** sourceable6 left
[23:54] *** bloatable6 left
[23:54] *** statisfiable6 left
[23:54] *** bisectable6 left
[23:54] *** reportable6 left
[23:54] *** evalable6 left
[23:55] *** tellable6 joined
[23:55] *** benchable6 joined
[23:57] *** nativecallable6 joined
[23:57] *** coverable6 joined
