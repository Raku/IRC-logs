[00:08] *** reportable6 left
[01:09] *** reportable6 joined
[02:09] *** notable6 left
[02:09] *** squashable6 left
[02:09] *** statisfiable6 left
[02:09] *** greppable6 left
[02:09] *** evalable6 left
[02:09] *** releasable6 left
[02:09] *** linkable6 left
[02:09] *** tellable6 left
[02:09] *** bloatable6 left
[02:09] *** unicodable6 left
[02:09] *** shareable6 left
[02:09] *** reportable6 left
[02:09] *** sourceable6 left
[02:09] *** coverable6 left
[02:09] *** quotable6 left
[02:09] *** committable6 left
[02:09] *** benchable6 left
[02:09] *** bisectable6 left
[02:09] *** nativecallable6 left
[02:09] *** frost joined
[02:10] *** releasable6 joined
[02:10] *** benchable6 joined
[02:10] *** tellable6 joined
[02:11] *** statisfiable6 joined
[02:11] *** nativecallable6 joined
[02:11] *** quotable6 joined
[02:11] *** greppable6 joined
[02:11] *** committable6 joined
[02:12] *** evalable6 joined
[02:12] *** shareable6 joined
[02:56] *** squashable6 joined
[03:10] *** notable6 joined
[03:10] *** sourceable6 joined
[03:11] *** coverable6 joined
[03:11] *** linkable6 joined
[03:16] <Geth> ¦ rakudo: eb151d53bd | (Daniel Sockwell)++ | 2 files

[03:16] <Geth> ¦ rakudo: Improve error msg for traits passed invalid args

[03:16] <Geth> ¦ rakudo: 

[03:16] <Geth> ¦ rakudo: Previously, traits called with invalid arguments would throw an

[03:16] <Geth> ¦ rakudo: X::Trait::Unknown error, which was confusing when the trait _was_

[03:16] <Geth> ¦ rakudo: known.  With this commit, they'll now throw an X::Trait::Invalid

[03:16] <Geth> ¦ rakudo: instead.

[03:16] <Geth> ¦ rakudo: 

[03:16] <Geth> ¦ rakudo: <…commit message has 9 more lines…>

[03:16] <Geth> ¦ rakudo: review: https://github.com/rakudo/rakudo/commit/eb151d53bd

[03:16] <Geth> ¦ rakudo: a2cf0ea5fb | (Daniel Sockwell)++ | src/core.c/Exception.pm6

[03:16] <Geth> ¦ rakudo: Fix typo

[03:16] <Geth> ¦ rakudo: review: https://github.com/rakudo/rakudo/commit/a2cf0ea5fb

[03:16] <Geth> ¦ rakudo: 0e9b2b7c91 | (Daniel Sockwell)++ (committed using GitHub Web editor) | 2 files

[03:16] <Geth> ¦ rakudo: Merge pull request #4786 from codesections-forks/x-trait

[03:16] <Geth> ¦ rakudo: 

[03:16] <Geth> ¦ rakudo: Improve error message for traits passed invalid arguments

[03:16] <Geth> ¦ rakudo: review: https://github.com/rakudo/rakudo/commit/0e9b2b7c91

[03:17] <Geth> ¦ rakudo: 232a55b96d | (Daniel Sockwell)++ | src/core.c/traits.pm6

[03:17] <Geth> ¦ rakudo: Remove unneeded/confusing can('prec') checks

[03:17] <Geth> ¦ rakudo: 

[03:17] <Geth> ¦ rakudo: This builds on commits caba0d3 and a7ccfc6 (admittedly not that

[03:17] <Geth> ¦ rakudo: promptly!).  The prior commits moved the .prec method to Code with the

[03:17] <Geth> ¦ rakudo: to prevent the need of checking whether various functions can prec;

[03:17] <Geth> ¦ rakudo: this commit removes six such `can('prec')` checks in the `is equiv`,

[03:17] <Geth> ¦ rakudo: `is tighter` and `is looser` traits.

[03:17] <Geth> ¦ rakudo: <…commit message has 12 more lines…>

[03:17] <Geth> ¦ rakudo: review: https://github.com/rakudo/rakudo/commit/232a55b96d

[03:17] <Geth> ¦ rakudo: 6e6ef03c88 | (Daniel Sockwell)++ (committed using GitHub Web editor) | src/core.c/traits.pm6

[03:17] <Geth> ¦ rakudo: Merge pull request #4787 from codesections-forks/trait-checks

[03:17] <Geth> ¦ rakudo: 

[03:17] <Geth> ¦ rakudo: Remove unneeded/confusing can('prec') checks

[03:17] <Geth> ¦ rakudo: review: https://github.com/rakudo/rakudo/commit/6e6ef03c88

[04:10] *** bloatable6 joined
[04:12] *** reportable6 joined
[05:11] *** bisectable6 joined
[06:08] *** reportable6 left
[06:10] *** reportable6 joined
[07:10] *** unicodable6 joined
[07:43] <lizmat> Files=1351, Tests=117115, 300 wallclock secs (36.27 usr 10.20 sys + 4167.31 cusr 342.20 csys = 4555.98 CPU)

[08:33] *** evalable6 left
[08:33] *** linkable6 left
[08:50] <MasterDuke> weekly: https://blog.sunfishcode.online/bugs-in-hello-world/

[08:50] <notable6> MasterDuke, Noted! (weekly)

[09:02] <lizmat> MasterDuke: the odd thing is, that I think Raku *does* have the bug ?

[09:02] <MasterDuke> yeah, i was a little surprised, but haven't gotten around to doing any testing

[09:13] <lizmat> afaik, "say" always returns True

[09:14] <Geth> ¦ Terminal-Width: b8e637d143 | (JJ Merelo)++ | 3 files

[09:14] <Geth> ¦ Terminal-Width: :see_no_evil:

[09:14] <Geth> ¦ Terminal-Width: review: https://github.com/raku-community-modules/Terminal-Width/commit/b8e637d143

[09:14] <Geth> ¦ Terminal-Width: 2988276aa5 | (JJ Merelo)++ | .gitignore

[09:14] <Geth> ¦ Terminal-Width: :see_no_evil:

[09:14] <Geth> ¦ Terminal-Width: review: https://github.com/raku-community-modules/Terminal-Width/commit/2988276aa5

[09:22] <moon-child> it _returns_ true, but it throws an exception

[09:22] <moon-child> http://ix.io/3RQr

[09:32] <Geth> ¦ Terminal-Width: b2ad6e5646 | (JJ Merelo)++ | t/00-use.t

[09:32] <Geth> ¦ Terminal-Width: Debug Github action

[09:32] <Geth> ¦ Terminal-Width: review: https://github.com/raku-community-modules/Terminal-Width/commit/b2ad6e5646

[09:32] *** kjp left
[09:33] *** linkable6 joined
[09:34] *** evalable6 joined
[09:35] <MasterDuke> is there any `<foo>` where i can do `my Int $r = <some random Int>; $r == <foo>` and it will always be false, but without a warning? e.g., not Nil, because that warns `Use of Nil in numeric context`

[09:37] <gfldex> m: my $r = 42|0|Inf; say $r == NaN;

[09:37] <camelia> rakudo-moar 6e6ef03c8: OUTPUT: «any(False, False, False)␤»

[09:38] <Geth> ¦ Terminal-Width: 5397430c45 | (JJ Merelo)++ | .github/workflows/test.yaml

[09:38] <Geth> ¦ Terminal-Width: Adapt workflow to repo

[09:38] <Geth> ¦ Terminal-Width: review: https://github.com/raku-community-modules/Terminal-Width/commit/5397430c45

[09:38] <gfldex> MasterDuke: ^^^

[09:38] <moon-child> also the DIY route: class Special {}; multi infix:<==>(\x, Special \y) { False }

[09:38] <gfldex> You have to make sure not to produce any NaN ofc.

[09:38] <moon-child> gfldex: why?

[09:38] <moon-child> m: say NaN == NaN

[09:38] <camelia> rakudo-moar 6e6ef03c8: OUTPUT: «False␤»

[09:39] <gfldex> I forgot about that. :)

[09:39] <moon-child> :)

[09:39] <gfldex> But then, Raku is way smarter then me.

[09:39] <moon-child> (though, you still get a warning if you don't initialise $r)

[09:39] <moon-child> m: say Int == NaN

[09:39] <camelia> rakudo-moar 6e6ef03c8: OUTPUT: «Use of uninitialized value of type Int in numeric context␤  in block <unit> at <tmp> line 1␤␤»

[09:40] <Geth> ¦ Terminal-Width: 5a6dfdf406 | (JJ Merelo)++ | .github/workflows/test.yaml

[09:40] <Geth> ¦ Terminal-Width: No sudo :bug:

[09:40] <Geth> ¦ Terminal-Width: review: https://github.com/raku-community-modules/Terminal-Width/commit/5a6dfdf406

[09:40] <MasterDuke> m: my $a; $a = do given NaN { when NaN { "nan" }; default { "default" } } for ^10; say $a

[09:40] <camelia> rakudo-moar 6e6ef03c8: OUTPUT: «nan␤»

[09:41] <moon-child> gfldex: I don't know if that's Raku being smarter than you so much as ieee754 being stupider than you, and raku acquiescing :)

[09:41] <moon-child> m: say NaN == NaN; say NaN ~~ NaN; say NaN === Nan #MasterDuke

[09:41] <camelia> rakudo-moar 6e6ef03c8: OUTPUT: «===SORRY!=== Error while compiling <tmp>␤Undeclared name:␤    Nan used at line 1␤␤»

[09:41] <moon-child> agh

[09:41] <moon-child> m: say NaN == NaN; say NaN ~~ NaN; say NaN === NaN

[09:41] <camelia> rakudo-moar 6e6ef03c8: OUTPUT: «False␤True␤True␤»

[09:48] *** sena_kun left
[09:52] *** sena_kun joined
[10:10] <MasterDuke> looks like that may work

[10:26] *** Xliff joined
[10:26] <Xliff> \O

[10:26] <Xliff> Is there an example implementation of CALL-ME documented somewhere?

[10:29] <MasterDuke> m: class A { method CALL-ME($name) { say "Hi, $name" } }; my $a = A.new; $a("Bob")      # you mean something simple like this?

[10:29] <camelia> rakudo-moar 6e6ef03c8: OUTPUT: «Hi, Bob␤»

[10:30] <Xliff> Hmm... probably not. I thought CALL-ME was used for every method call.

[10:31] <Xliff> m: class A { method CALL-ME($name) { if name.lc eq 'bob' { say "Hi, $name" } }; }; my $a = A.new; $a.bob

[10:31] <camelia> rakudo-moar 6e6ef03c8: OUTPUT: «===SORRY!=== Error while compiling <tmp>␤Undeclared routine:␤    name used at line 1␤␤»

[10:31] <Xliff> m: class A { method CALL-ME($name) { if $name.lc eq 'bob' { say "Hi, $name" } }; }; my $a = A.new; $a.bob

[10:31] <camelia> rakudo-moar 6e6ef03c8: OUTPUT: «No such method 'bob' for invocant of type 'A'␤  in block <unit> at <tmp> line 1␤␤»

[10:31] <Xliff> And no, I don't mean FALLBACK, here.

[10:32] <Xliff> Basically, I want to be able to intercept all method calls made to an object or its children.

[10:34] <MasterDuke> hm. don't have any methods in the class and have FALLBACK instead call subs with the given name?

[10:41] *** ShaneC left
[10:42] <MasterDuke> m: class A { method !a($name) { say "hi, $name" }; method FALLBACK(|c) { my $method = c[0]; my \args = c.skip; say "sneakily intercepted a call to '$method'"; self!"$method"(|args) } }; A.new.a("Bob")

[10:42] <camelia> rakudo-moar 6e6ef03c8: OUTPUT: «sneakily intercepted a call to 'a'␤hi, Bob␤»

[10:44] <Xliff> LOL! I see whut you did, thar.

[10:44] <Xliff> That actually might work in the long run.

[10:44] <Xliff> Still, setup would be slow since FALLBACK is expensive, no?

[10:45] <MasterDuke> i think it got a bit faster with new-disp, but sure, it's probably somewhat slower

[10:47] <MasterDuke> m: class A { method !a($a) { $a + 1 }; method FALLBACK(|c) { my $method = c[0]; my \args = c.skip; self!"$method"(|args) } }; my $a = 0; my $A = A.new; $a = $A.a($a) for ^1_000_000; say now - INIT now; say $a

[10:47] <camelia> rakudo-moar 6e6ef03c8: OUTPUT: «3.626851472␤1000000␤»

[10:47] <MasterDuke> m: class A { method a($a) { $a + 1 }; method FALLBACK(|c) { my $method = c[0]; my \args = c.skip; self!"$method"(|args) } }; my $a = 0; my $A = A.new; $a = $A.a($a) for ^1_000_000; say now - INIT now; say $a

[10:47] <camelia> rakudo-moar 6e6ef03c8: OUTPUT: «0.041119068␤1000000␤»

[10:47] <MasterDuke> so ~100x slower

[10:50] <nine> Grammar::Tracer does what you seem to want: https://github.com/jnthn/grammar-debugger/blob/master/lib/Grammar/Tracer.pm6

[10:53] <Xliff> Yeah. 100x slower is not so good.

[10:54] <Xliff> nine: Huh! So it does. Thanks!

[10:54] <nine> The Grammar::Tracer method should avoid any slowdowns (except for the one imposed by your wrappers themselves)

[10:54] <Xliff> And I've looked at this code before. Kinda was hoping I didn't have to resort to messing with the HOW, but alas...

[10:56] <MasterDuke> i'm trying to do ^add_method in FALLBACK, but FALLBACK keeps getting called

[10:56] <Xliff> Hahaha!

[10:56] <Xliff> Was wondering about that.

[10:57] <MasterDuke> but then i do get the error `Package 'A' already has a method 'a' (did you mean to declare a multi method?)`, so it's getting installed, but not called

[11:07] <Xliff> And this doesn't work, either. Surprisingly, I'm surprised this is geting called on BUILDALL! 

[11:07] <Xliff> https://replit.com/@Xliff/PointlessDimgrayRay#main.raku

[12:08] *** reportable6 left
[12:23] <Geth> ¦ rakudo: MasterDuke17++ created pull request #4814: Restore optimization for given/when with Numeric cases

[12:23] <Geth> ¦ rakudo: review: https://github.com/rakudo/rakudo/pull/4814

[12:55] *** sena_kun left
[12:57] *** sena_kun joined
[13:11] *** reportable6 joined
[13:26] <Geth> ¦ Terminal-Width: 6ef432924a | (JJ Merelo)++ | .github/workflows/test.yaml

[13:26] <Geth> ¦ Terminal-Width: Use docker installation to check tput

[13:26] <Geth> ¦ Terminal-Width: review: https://github.com/raku-community-modules/Terminal-Width/commit/6ef432924a

[13:26] <Geth> ¦ Terminal-Width: 5d9ab442eb | (JJ Merelo)++ | 2 files

[13:26] <Geth> ¦ Terminal-Width: Check with new install

[13:26] <Geth> ¦ Terminal-Width: review: https://github.com/raku-community-modules/Terminal-Width/commit/5d9ab442eb

[13:26] <Geth> ¦ Terminal-Width: cb8dd700f1 | (JJ Merelo)++ | .github/workflows/test.yaml

[13:26] <Geth> ¦ Terminal-Width: Fix :poop:

[13:26] <Geth> ¦ Terminal-Width: review: https://github.com/raku-community-modules/Terminal-Width/commit/cb8dd700f1

[13:35] <Geth> ¦ Terminal-Width: 628aae98a6 | (JJ Merelo)++ | .github/workflows/test.yaml

[13:35] <Geth> ¦ Terminal-Width: Address 'not a TTY' :bug:

[13:35] <Geth> ¦ Terminal-Width: review: https://github.com/raku-community-modules/Terminal-Width/commit/628aae98a6

[14:05] <Geth> ¦ Terminal-Width: 84eb945b3c | (JJ Merelo)++ | META6.json

[14:05] <Geth> ¦ Terminal-Width: Almost ready to release, closes #3

[14:05] <Geth> ¦ Terminal-Width: review: https://github.com/raku-community-modules/Terminal-Width/commit/84eb945b3c

[14:05] <Geth> ¦ Terminal-Width: 58143c1443 | (JJ Merelo)++ | lib/Terminal/Width.pm6

[14:05] <Geth> ¦ Terminal-Width: Test for existence of tput, closes #2

[14:05] <Geth> ¦ Terminal-Width: review: https://github.com/raku-community-modules/Terminal-Width/commit/58143c1443

[14:11] <Geth> ¦ Terminal-Width: deedb0cb24 | (JJ Merelo)++ | META6.json

[14:11] <Geth> ¦ Terminal-Width: :arrow_up: for release

[14:11] <Geth> ¦ Terminal-Width: review: https://github.com/raku-community-modules/Terminal-Width/commit/deedb0cb24

[14:11] *** evalable6 left
[15:02] *** frost left
[15:23] *** squashable6 left
[15:24] *** squashable6 joined
[15:36] <MasterDuke> m: my $a; $a = do given "NaN" { when NaN { "nan" }; default { "default" } }; say $a       # is this correct?

[15:36] <camelia> rakudo-moar 6e6ef03c8: OUTPUT: «nan␤»

[15:37] <MasterDuke> bisectable6: old=2021.05 my $a; $a = do given "NaN" { when NaN { "nan" }; default { "default" } }; say $a

[15:37] <bisectable6> MasterDuke, Bisecting by output (old=2021.05 new=6e6ef03) because on both starting points the exit code is 0

[15:37] <bisectable6> MasterDuke, bisect log: https://gist.github.com/29342d490a151390944bc9e0aec84ce2

[15:37] <bisectable6> MasterDuke, (2021-12-27) https://github.com/rakudo/rakudo/commit/5855c1d55786adff02cc54d882167cfbdfaa6e43

[15:38] <MasterDuke> committable6: 2021.11 my $a; $a = do given "NaN" { when NaN { "nan" }; default { "default" } }; say $a

[15:38] <committable6> MasterDuke, ¦2021.11: «Cannot find this revision (did you mean “2021.12”?)»

[15:38] <MasterDuke> committable6: 2021.10 my $a; $a = do given "NaN" { when NaN { "nan" }; default { "default" } }; say $a

[15:38] <committable6> MasterDuke, ¦2021.10: «default␤»

[15:52] <[Coke]> doc test shows that we have Range.sum doc'd as returning Numeric, but the source doesn't have that restriction. Should it?

[15:55] <nine> lizmat: FWIW I would approve your PR on "Preparing the Raku Ecosystem for the Future", but I'm not a reviewer in the problem-solving repo :)

[15:56] *** cognominal joined
[15:58] <MasterDuke> [Coke]: can't think why not, though fwiw, none of the sum methods or subs have a return type

[15:58] <[Coke]> nine++ for making me check that apparently I was a requested reviewer.

[15:58] <[Coke]> Performance concerns?

[15:59] <[Coke]> Seems like being explicit is good, esp. these days?

[15:59] <nine> Python mantra says "explicit is better than implicit"

[16:00] <nine> Return type checks can be speshed away. That was one of the original goals for spesh plugins and later new-disp.

[16:00] <nine> They are what makes return "dispatchy"

[16:02] <[Coke]> I can put together a PR that makes all the sums Numeric and see if it breaks anything.

[16:13] *** evalable6 joined
[16:58] <lizmat> nine: wonder why Github allows me to select you as a reviewer, and not allowing you to review  :-(

[17:01] <lizmat> nine: could you try again?

[17:50] *** Kaipi left
[18:07] *** reportable6 left
[18:09] *** reportable6 joined
[18:29] *** Xliff left
[18:44] <nine> lizmat: oh, Github would allow me, but I've never signed up to be a reviewer in problem-solving

[18:45] *** Kaipi joined
[18:45] <nine> I was just happy to leave this pondering to others as I usually have no problem staying busy anyway :)

[18:49] <cognominal> It seems many people have no problem lizmat acting as benevolent dictator. Within the raku community. Outside, it seems to be different. Liz tried to drafted me too. I am not competent.

[18:49] <cognominal> * draft

[18:51] <cognominal> And I prefer not to talk about the fracture between the Perl and the raku community. I have been ousted in France from the former and I don't really feel worthy for the later :)

[18:57] *** ShaneC joined
[19:01] <lizmat> nine: ok, sorry for the misunderstanding

[19:01] <cognominal> lizmat++ for taking care

[20:22] *** notna joined
[20:32] <[Coke]> indeed.

[20:32] <[Coke]> so I tried changing all the sums to declare --> Numeric... and a spectest about junctions failed.

[20:33] <[Coke]> m: my @a = https://km-cd-webapp.ame.intela.deloitte.com/US/Restr/MTS/s/t/state-pass-through-entity-tax-matrix

[20:33] <camelia> rakudo-moar 6e6ef03c8: OUTPUT: «===SORRY!=== Error while compiling <tmp>␤Confused␤at <tmp>:1␤------> my @a = https:⏏//km-cd-webapp.ame.intela.deloitte.com/U␤    expecting any of:␤        colon pair␤»

[20:33] <[Coke]> carp

[20:35] <MasterDuke> HA

[20:36] <MasterDuke> s/HA/ha

[20:37] *** sena_kun left
[20:38] *** sena_kun joined
[20:38] <[Coke]> m: dd (2, 3|4, 5, 6|7).sum

[20:38] <camelia> rakudo-moar 6e6ef03c8: OUTPUT: «any(any(16, 17), any(17, 18))␤»

[20:38] <[Coke]> so the sum returns a Junction and the declared -->Numeric fails.

[20:43] *** notna left
[21:33] <gfldex> m: dd (True, True).sum;

[21:33] <camelia> rakudo-moar 6e6ef03c8: OUTPUT: «2␤»

[21:38] <gfldex> So to make return type constraints work (not just for sum), Junctions would need to become Nilish.

[21:39] <gfldex> What makes sense to me, as Junctions stand outside the ordinary type system.

[22:14] *** Xliff joined
