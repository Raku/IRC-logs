[00:10] *** reportable6 joined
[00:19] *** linkable6 joined
[00:44] <Geth> ¦ rakudo/ugexe-patch-3: f1999ef471 | (Nick Logan)++ (committed using GitHub Web editor) | src/core.c/CompUnit/PrecompilationStore/File.pm6

[00:44] <Geth> ¦ rakudo/ugexe-patch-3: Use unique path for temporary precomp files

[00:44] <Geth> ¦ rakudo/ugexe-patch-3: 

[00:44] <Geth> ¦ rakudo/ugexe-patch-3: Previously when two threads were trying to load the same module they could attempt to rename the same temporary file. This adds some uniquifying path extension parts to avoid the aforementioned scenario.

[00:44] <Geth> ¦ rakudo/ugexe-patch-3: review: https://github.com/rakudo/rakudo/commit/f1999ef471

[00:45] <Geth> ¦ rakudo: ugexe++ created pull request #4758: Fix precomp file rename race condition

[00:45] <Geth> ¦ rakudo: review: https://github.com/rakudo/rakudo/pull/4758

[01:51] <Geth> ¦ rakudo/ugexe-patch-3: f972c432ac | (Nick Logan)++ (committed using GitHub Web editor) | t/08-performance/05-processkeys.t

[01:51] <Geth> ¦ rakudo/ugexe-patch-3: Update test to account for $*THREAD

[01:51] <Geth> ¦ rakudo/ugexe-patch-3: review: https://github.com/rakudo/rakudo/commit/f972c432ac

[02:22] <Geth> ¦ rakudo/ugexe-patch-3: f3c1a2ecaa | (Nick Logan)++ | 2 files

[02:22] <Geth> ¦ rakudo/ugexe-patch-3: Use unique path for temporary precomp files

[02:22] <Geth> ¦ rakudo/ugexe-patch-3: 

[02:22] <Geth> ¦ rakudo/ugexe-patch-3: Previously when two threads were trying to load the same module

[02:22] <Geth> ¦ rakudo/ugexe-patch-3: they could attempt to rename the same temporary file. This adds

[02:22] <Geth> ¦ rakudo/ugexe-patch-3: some uniquifying path extension parts to avoid the aforementioned

[02:22] <Geth> ¦ rakudo/ugexe-patch-3: scenario.

[02:22] <Geth> ¦ rakudo/ugexe-patch-3: review: https://github.com/rakudo/rakudo/commit/f3c1a2ecaa

[02:39] *** frost joined
[02:50] <Geth> ¦ rakudo/ugexe-patch-4: 0f5e670b7e | (Nick Logan)++ | src/core.c/Rakudo/Internals.pm6

[02:50] <Geth> ¦ rakudo/ugexe-patch-4: Enable INITTHREAD on jvm

[02:50] <Geth> ¦ rakudo/ugexe-patch-4: review: https://github.com/rakudo/rakudo/commit/0f5e670b7e

[02:54] <Geth> ¦ rakudo/ugexe-patch-3: 25f30c17b1 | (Nick Logan)++ | src/core.c/Rakudo/Internals.pm6

[02:54] <Geth> ¦ rakudo/ugexe-patch-3: Enable INITTHREAD on jvm

[02:54] <Geth> ¦ rakudo/ugexe-patch-3: review: https://github.com/rakudo/rakudo/commit/25f30c17b1

[03:01] *** frost left
[04:01] *** linkable6 left
[04:01] *** reportable6 left
[04:01] *** sourceable6 left
[04:01] *** nativecallable6 left
[04:01] *** bisectable6 left
[04:01] *** greppable6 left
[04:01] *** releasable6 left
[04:01] *** tellable6 left
[04:01] *** evalable6 left
[04:01] *** squashable6 left
[04:01] *** unicodable6 left
[04:01] *** statisfiable6 left
[04:01] *** benchable6 left
[04:01] *** bloatable6 left
[04:01] *** shareable6 left
[04:02] *** tellable6 joined
[04:02] *** statisfiable6 joined
[04:03] *** benchable6 joined
[04:03] *** nativecallable6 joined
[04:04] *** greppable6 joined
[05:02] *** linkable6 joined
[05:04] *** committable6 joined
[05:04] *** releasable6 joined
[05:04] *** unicodable6 joined
[05:04] *** squashable6 joined
[05:05] *** shareable6 joined
[05:26] *** frost joined
[05:42] *** frost left
[06:02] *** sourceable6 joined
[06:02] *** quotable6 joined
[06:04] *** bloatable6 joined
[07:03] *** coverable6 joined
[07:03] *** evalable6 joined
[07:04] *** bisectable6 joined
[07:05] *** reportable6 joined
[07:25] *** camelia left
[07:25] *** zostay left
[07:25] *** vrurg left
[07:25] *** japhb left
[07:25] *** kjp left
[07:25] *** timo left
[07:25] *** maettu left
[07:25] *** ilogger2 left
[07:28] *** vrurg joined
[07:28] *** japhb joined
[07:28] *** kjp joined
[07:28] *** timo joined
[07:28] *** maettu joined
[07:28] *** ilogger2 joined
[07:28] *** camelia joined
[07:28] *** zostay joined
[08:10] <nine> I submitted a PR with the single characater fix to PDF.

[08:25] <nine> As long as UInt is a subset, we won't be able to forgoe those range checks for array indexes. But! Now that uint is fully recognized by multi dispatch, we could have a:

[08:25] <nine> multi sub postcircumfix:<[ ]>( array::uintarray:D \SELF, uint $pos) is raw {

[08:25] <nine>     nqp::atposref_u(nqp::decont(SELF), $pos)

[08:25] <nine> }

[08:27] <nine> Also a multi method AT-POS(List:D: uint $pos).

[08:31] *** [Coke] joined
[09:03] *** notable6 joined
[09:19] <lizmat> Files=1351, Tests=117097, 285 wallclock secs (34.95 usr  9.47 sys + 3981.39 cusr 329.78 csys = 4355.59 CPU)

[09:20] <lizmat> nine: want me to add those candidates ?

[09:22] <lizmat> m: multi a(Int:D) { dd }; multi a(UInt:D) { dd }; a 42   # so why not use UInt candidates

[09:22] <camelia> rakudo-moar ef4abcc78: OUTPUT: «sub a(UInt)␤»

[09:22] <lizmat> nine ^^

[09:23] <lizmat> or even get rid of all the Int:D candidates:

[09:23] <lizmat> m: multi a(uint) { dd }; multi a(UInt:D) { dd }; a -42

[09:23] <camelia> rakudo-moar ef4abcc78: OUTPUT: «Cannot resolve caller a(Int:D); none of these signatures match:␤    (uint)␤    (UInt)␤  in block <unit> at <tmp> line 1␤␤»

[09:24] <lizmat> m: multi a(uint) { dd }; multi a(UInt:D) { dd }; a my int $ = 42   # even the native int handling is sorta ok in that case

[09:24] <camelia> rakudo-moar ef4abcc78: OUTPUT: «sub a(UInt)␤»

[09:32] <moon-child> hmm that should be 'none of these signatures matches'

[09:33] <moon-child> because 'none' is singular

[09:51] <nine> lizmat: because I think that UInt:D is not actually cheaper. A type check for UInt:D is: * a type check for Int, * a concrete check, * running the subset where block

[09:51] <lizmat> yeah, but otherwise the check needs to be done inside the code

[09:51] <lizmat> increasing the size of the candidate, and thus prevent inlining in some cases

[09:51] <nine> That's the point: with uint, no check has to be done at all

[09:52] <lizmat> right, but even UInt:D would have a positive 

[09:52] <nine> But UInt still includes that runtime check

[09:52] <moon-child> nine: supposing the caller has a UInt already, though; then could the check not be skipped?

[09:52] <nine> It's just implicit, but the code is still there

[09:53] <lizmat> nine: yes, I'm not saying we shouldn't have a uint candidate

[09:53] <lizmat> I'm saying that we should drop the Int:D candidate for a UInt:D candidate

[09:53] <nine> moon-child: no, it cannot, because UInt is just a subset.

[09:53] <nine> m: my UInt $a = 1; say $a.^name

[09:53] <camelia> rakudo-moar ef4abcc78: OUTPUT: «Int␤»

[09:53] <nine> lizmat: that doesn't buy us anything

[09:54] <lizmat> not wrt to inlining ?

[09:55] <lizmat> in the case of AT-POS, we could have a *single* Int:D candidate that just throws

[09:55] <lizmat> and get rid of a lot of code

[10:11] <lizmat> otoh, it looks like something with a UInt:D doesn't even qualify for inlining

[10:13] <nine> The irony is that adding a uint candidate right now would make things even slower. There seems to be an issue with spesh. sub foo(Int $a, uint $b) speshes just fine. But sub foo(Int:D $a, uint $b) bails argument spesh because $b is suddenly a UIntLexRef instead of a uint

[10:14] <nine> I guess, the issue is somewhere in the dispatcher, but I haven't found anything so far

[10:16] <MasterDuke> is that unique to uints? or is it the same for `int $b`?

[10:19] <nine> same for int

[10:19] <lizmat> also: adding a uint candidate to List.AT-POS doesn't inline because of:

[10:19] <lizmat>     AT-POS BB(5668, 192 bytes) -> BB(1):

[10:19] <lizmat>       target has a :noinline instruction - ins: param_rp_o

[10:20] <nine> lizmat: see what I just wrote :D

[10:20] <MasterDuke> oh, so possible general optimization

[10:20] <lizmat> ok, glad it is another expression of the same issue

[10:47] *** [Tux] joined
[12:07] *** reportable6 left
[12:09] *** reportable6 joined
[12:09] <nine> Ooh, that weird spesh issue: it's the optimizer

[12:34] <MasterDuke> static optimizer or spesh optimizer?

[12:35] <nine> static

[12:36] <nine> The static optimizer is supposed to simplify native refs for non-rw arguments (can just pass the value for those). But for some reason the trial_bind to the signature ends with "not sure" as soon as a :D argument is in the signature

[12:41] <lizmat> nine: and that would always be true for an instance method, right?

[13:02] <MasterDuke> m: sub a(Int:D $b) {}; dd &a.signature.params[0].multi-invocant   # is this correct/expected?

[13:02] <camelia> rakudo-moar ef4abcc78: OUTPUT: «Bool::True␤»

[13:03] <lizmat> perhaps not

[13:03] <lizmat> looks like the default when building a Parameter object is set to True

[13:04] <lizmat> but the method doesn't actually check the attribute?

[13:04] <lizmat> ah, oops, the BUILD only sets a flag

[13:04] <lizmat> and that flag is checked

[13:05] <lizmat> so it feels like an error in building the Parameter object ?

[13:07] <MasterDuke> m: sub a(;;Int:D $b) {}; dd &a.signature.params[0].multi-invocant   # oh, this is what it's for

[13:07] <camelia> rakudo-moar ef4abcc78: OUTPUT: «Bool::False␤»

[13:09] *** linkable6 left
[13:09] *** evalable6 left
[13:11] <lizmat> naming of that feature feels...meh :-)

[13:12] <MasterDuke> yeah

[13:19] <MasterDuke> it's this case https://github.com/rakudo/rakudo/blob/master/src/Perl6/bootstrap.c/BOOTSTRAP.nqp#L1101-L1107

[13:20] <MasterDuke> i added a note in there and it hits for `sub a(Int:D $b, int $c) { say $c }; a(1, 3);` but not `sub a(Int $b, int $c) { say $c }; a(1, 3);`

[13:26] <MasterDuke> $flags = 131200 in the not sure case

[13:37] <nine> Adding $SIG_ELEM_DEFINED_ONLY there gets you further, but still not through with postcircumfix:sym([ ])

[13:43] <nine> That's because the proto sub postcircumfix:<[ ]>($, |) is nodal {*} has that $ in the signature which throws off trial_bind

[13:44] <nine> But even if that is out of the way, we still do not succeed, because then it finds 2 matching multi candidates and will not enter the branch where it simplifies the refs

[13:47] <lizmat> fwiw, having those signatures on protos in core, still feels like a ginormous hack

[13:55] <nine> What's it for?

[14:00] <lizmat> so that things like sort can introspect

[14:02] *** carlmasak joined
[14:10] *** linkable6 joined
[16:09] *** evalable6 joined
[16:36] <jdv> nine: still a bunch

[16:41] <nine> Well Data::ExampleDatasets – Fail, Bisected: 4e1a772 is certainly bogus. There's just no way that this commit could cause a free() error and they have been cropping up for a while (most likely mimalloc related(

[16:44] <nine> Archive::Libarchive – Fail, Bisected: c92833f is a bug in the module.

[16:46] <nine> Digest and PDF already have PRs for the bugs in the modules. Should I mark them as done?

[16:51] <nine> HarfBuzz::Font also buggy, also causes the failure in HTML::Canvas

[17:14] <jdv> yup. i think just marking them and maybe a comment is fine

[17:15] <nine> Yes, I started marking them, as I noticed that I was already losing track of the PRs I submitted :D

[17:37] *** carlmasak left
[18:08] *** reportable6 left
[18:08] *** reportable6 joined
[18:20] <Geth> ¦ rakudo: a35a779133 | (Stefan Seifert)++ | 2 files

[18:20] <Geth> ¦ rakudo: Allow for using uint and int as indexes in native array slice assignment

[18:20] <Geth> ¦ rakudo: 

[18:20] <Geth> ¦ rakudo: Fixes "This container does not reference a native integer" errors.

[18:20] <Geth> ¦ rakudo: review: https://github.com/rakudo/rakudo/commit/a35a779133

[18:35] <nine> Oh, so close: https://github.com/pdf-raku/Font-FreeType-raku/pull/7/commits/0be41c2c070b91bd9a90574113a782c0e3aa5fa7

[18:36] <nine> The test was already anticipating Rakudo getting fixed to no longer return -1 for an unsigned, but used the wrong alternative value

[20:08] <nine> 11/18 taken care of so far. I expect the remaining uint issues to be bugs in those modules as well. I'll be mostly afk tomorrow though.

[20:11] <japhb> nine++  # Excellent progress!

[21:03] *** Xliff joined
[21:04] <Xliff> Hello. Does anyone know if the RakuAST branch has the ability to introspect the AST of existing code?

[21:05] <Xliff> Ie if I have something like this: my $a = sub { 42 }; Then I can get the AST of the sub in $a by something like $a.ast?

[21:09] *** squashable6 left
[21:12] <[Tux]> Rakudo v2021.12-192-ga35a77913 (v6.d) on MoarVM 2021.12-120-g6ecb89383

[21:12] <[Tux]> csv-test-xs-20      0.411 -  0.412

[21:12] <[Tux]> csv-ip5xs           0.770 -  0.781

[21:12] <[Tux]> test-t --race       0.873 -  0.900

[21:12] <[Tux]> test-t              1.504 -  1.519

[21:12] <[Tux]> csv-parser          3.911 -  4.053

[21:12] <[Tux]> csv-ip5xs-20        4.902 -  5.174

[21:12] <[Tux]> test                6.760 -  6.790

[21:12] <[Tux]> test-t-20 --race    7.463 -  7.585

[21:12] <[Tux]> test-t-20          22.819 - 24.328

[21:18] <MasterDuke> Xliff: no idea. my only idea would be to look at new tests on that branch and see if any of them do anything like that

[21:31] <vrurg> Xliff: unlikely for run-time.

[21:44] <vrurg> nine: Can you also have a look at LibXML regression? The bisected commit doesn't look relevant. It throws in lib/LibXML/ErrorHandling.rakumod, line 281. There is nothing related to smartmatch and the error message is about native int.

[22:12] *** squashable6 joined
[23:54] <Geth> ¦ rakudo/ugexe-patch-3: 36c784ef33 | (Nick Logan)++ | src/core.c/CompUnit/PrecompilationStore/File.pm6

[23:54] <Geth> ¦ rakudo/ugexe-patch-3: Use non-clashing path for temporary precomp files

[23:54] <Geth> ¦ rakudo/ugexe-patch-3: 

[23:54] <Geth> ¦ rakudo/ugexe-patch-3: Previously when two threads were trying to load the same module

[23:54] <Geth> ¦ rakudo/ugexe-patch-3: they could attempt to rename the same temporary file. This adds

[23:54] <Geth> ¦ rakudo/ugexe-patch-3: a uniquish path extension part to avoid the aforementioned

[23:54] <Geth> ¦ rakudo/ugexe-patch-3: scenario.

[23:54] <Geth> ¦ rakudo/ugexe-patch-3: review: https://github.com/rakudo/rakudo/commit/36c784ef33

