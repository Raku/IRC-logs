[00:07] *** reportable6 left
[00:09] *** reportable6 joined
[01:09] *** evalable6 left
[01:09] *** linkable6 left
[01:11] *** evalable6 joined
[01:11] *** linkable6 joined
[01:55] *** frost joined
[03:04] *** frost left
[03:13] *** frost joined
[06:08] *** evalable6 left
[06:08] *** linkable6 left
[06:08] *** reportable6 left
[06:10] *** evalable6 joined
[06:10] *** linkable6 joined
[06:11] *** reportable6 joined
[06:30] <Geth> ¦ rakudo/lizmat-span: 9f44aca38b | (Elizabeth Mattijsen)++ | 8 files

[06:30] <Geth> ¦ rakudo/lizmat-span: Implement Haskell's "span" in 6.e

[06:30] <Geth> ¦ rakudo/lizmat-span: 

[06:30] <Geth> ¦ rakudo/lizmat-span: Inspired by https://stackoverflow.com/questions/72809469/in-raku-how-does-one-write-the-equivalent-of-haskells-span-function

[06:30] <Geth> ¦ rakudo/lizmat-span: 

[06:30] <Geth> ¦ rakudo/lizmat-span: This implements both the method as well as the sub version of "span".

[06:30] <Geth> ¦ rakudo/lizmat-span: 

[06:30] <Geth> ¦ rakudo/lizmat-span: For more flexibility, the condition can also be a List of conditions

[06:30] <Geth> ¦ rakudo/lizmat-span: <…commit message has 17 more lines…>

[06:30] <Geth> ¦ rakudo/lizmat-span: review: https://github.com/rakudo/rakudo/commit/9f44aca38b

[06:30] <Geth> ¦ rakudo: lizmat++ created pull request #4976: Implement Haskell's "span" in 6.e

[06:30] <Geth> ¦ rakudo: review: https://github.com/rakudo/rakudo/pull/4976

[09:21] *** sena_kun left
[10:01] *** sena_kun joined
[11:01] *** quotable6 left
[11:01] *** linkable6 left
[11:01] *** unicodable6 left
[11:01] *** notable6 left
[11:01] *** sourceable6 left
[11:01] *** evalable6 left
[11:01] *** coverable6 left
[11:01] *** shareable6 left
[11:01] *** greppable6 left
[11:01] *** bloatable6 left
[11:01] *** bisectable6 left
[11:01] *** benchable6 left
[11:01] *** committable6 left
[11:01] *** tellable6 left
[11:01] *** nativecallable6 left
[11:01] *** reportable6 left
[11:01] *** releasable6 left
[11:01] *** statisfiable6 left
[11:02] *** shareable6 joined
[11:02] *** releasable6 joined
[11:02] *** evalable6 joined
[11:02] *** nativecallable6 joined
[11:02] *** linkable6 joined
[11:02] *** coverable6 joined
[11:03] *** notable6 joined
[11:03] *** bisectable6 joined
[11:03] *** committable6 joined
[11:03] *** benchable6 joined
[11:03] *** statisfiable6 joined
[11:03] *** greppable6 joined
[11:04] *** reportable6 joined
[11:04] *** tellable6 joined
[11:04] *** bloatable6 joined
[11:04] *** quotable6 joined
[11:04] *** unicodable6 joined
[11:04] *** sourceable6 joined
[11:42] *** sena_kun left
[11:43] *** sena_kun joined
[12:07] *** reportable6 left
[12:08] *** reportable6 joined
[12:49] <Geth> ¦ rakudo/lizmat-span: 8a5a36bc7d | (Elizabeth Mattijsen)++ | 2 files

[12:49] <Geth> ¦ rakudo/lizmat-span: Generalize the matcher on span

[12:49] <Geth> ¦ rakudo/lizmat-span: 

[12:49] <Geth> ¦ rakudo/lizmat-span: Instead of just allowing a Callable, go for smart-matching instead.

[12:49] <Geth> ¦ rakudo/lizmat-span: 

[12:49] <Geth> ¦ rakudo/lizmat-span:     .say for (2, 2, 2, 5, 5, "a", "b", "c").span: Int;

[12:49] <Geth> ¦ rakudo/lizmat-span:     (2 2 2 5 5)

[12:49] <Geth> ¦ rakudo/lizmat-span:     (a b c)

[12:49] <Geth> ¦ rakudo/lizmat-span: 

[12:49] <Geth> ¦ rakudo/lizmat-span:     .say span Int, 2, 2, 2, 5, 5, "a", "b", "c");

[12:49] <Geth> ¦ rakudo/lizmat-span:     (2 2 2 5 5)

[12:49] <Geth> ¦ rakudo/lizmat-span:     (a b c)

[12:49] <Geth> ¦ rakudo/lizmat-span: review: https://github.com/rakudo/rakudo/commit/8a5a36bc7d

[13:13] <|Tux|> Rakudo v2022.06-33-g6dc2f92c9 (v6.d) on MoarVM 2022.06-6-gc315523ab

[13:13] <|Tux|> csv-test-xs-20      0.403 -  0.417

[13:13] <|Tux|> csv-ip5xs           0.782 -  0.921

[13:13] <|Tux|> test-t --race       0.843 -  0.920

[13:13] <|Tux|> test-t              1.393 -  1.737

[13:13] <|Tux|> csv-parser          3.616 -  4.037

[13:13] <|Tux|> csv-ip5xs-20        5.218 -  5.599

[13:13] <|Tux|> test-t-20 --race    6.586 -  6.691

[13:13] <|Tux|> test                6.867 -  6.868

[13:13] <|Tux|> test-t-20          20.438 - 20.729

[13:19] <discord-raku-bot> <locria> Hello, Raku devs

[13:19] <discord-raku-bot> <locria> Is there any plan to add full C FFI to NativeCall?

[13:19] <lizmat> I don't know of any concrete plans

[13:19] <discord-raku-bot> <locria> This was discussed over a year ago

[13:20] <discord-raku-bot> <locria> I want to help, but I don't know how to

[13:21] <lizmat> perhaps nine patrickb vrurg have ideas

[13:21] <discord-raku-bot> <locria> I know how to use libffi, but not the internals of moarvm

[13:22] <discord-raku-bot> <locria> Can IRC bot ping user on discord?

[13:23] <lizmat> not sure, don't think so

[13:23] <discord-raku-bot> <locria> How do I contact them

[13:26] <lizmat> hopefully they react to the ping on this channel.... or you could create a Rakudo issue ?

[13:28] <vrurg> An issue would be better. And I'm barely an expert with nativecall and moarvm. 

[13:31] <patrickb> locria: Thanks for your offer to help! I think nine is the one to ask. Creating an issue at github.com/rakudo/rakudo and pinging @niner there is a good start

[13:35] <discord-raku-bot> <locria> thanks

[13:49] *** crystalfrost[m] left
[13:49] *** crystalfrost[m] joined
[14:19] <nine> We already have a libffi based backend for NativeCall. Extending that wouldn't be a problem. I don't even see anything keeping us from switching the default over from dyncall. The two issues are really elsewhere.

[14:20] <nine> First, more libffi or dyncall is the wrong direction. We want less of those. We already compile many calls to x86 code directly making those native calls almost the same speed as well actual native calls.

[14:21] <nine> Second the real blocker is not even that, we have already JIT code passing structs to native functions, so we know what the ABI looks like. The real blocker is the API one. I simply haven't seen any good idea on what such native sub definitions would look like.

[14:23] <nine> Right now sub foo(MyStruct) is native { !!! } is a definition for a void foo(MyStruct*) { ... } function. It would have been easy if the NativeCall definition for that would be sub foo(Pointer[MyStruct]) { !!! } for foo(MyStruct*) and sub foo(MyStruct) for foo(MyStruct)

[14:26] *** frost left
[14:34] <vrurg> nine: sub foo(MyStruct $v is rw) { !!! }

[14:35] <nine> What would foo(MyStruct **) then be?

[14:36] <vrurg> sub foo(Pointer[MyStruct] $v is rw) { !!! }?

[14:36] <vrurg> Or we could use a dedicated trait for that. `is pointer`, `is ppointer` or alike.

[14:37] <vrurg> Pointer[MyStruct] semantics should be there too, though.

[14:38] <vrurg> Pointer[Pointer[MyStruct]] is just too cumbersome, hence the trait idea.

[15:14] *** dogbert17 left
[15:41] *** dogbert17 joined
[16:39] *** sena_kun left
[17:18] *** sena_kun joined
[18:04] *** Xliff joined
[18:07] *** reportable6 left
[18:09] *** reportable6 joined
[19:30] *** Xliff left
[19:36] *** sena_kun left
[19:37] *** sena_kun joined
[19:52] *** lizmat left
[19:55] *** lizmat joined
[20:55] *** linkable6 left
[20:55] *** bisectable6 left
[20:55] *** coverable6 left
[20:55] *** nativecallable6 left
[20:55] *** shareable6 left
[20:55] *** notable6 left
[20:55] *** evalable6 left
[20:55] *** greppable6 left
[20:55] *** quotable6 left
[20:55] *** committable6 left
[20:55] *** unicodable6 left
[20:55] *** reportable6 left
[20:55] *** bloatable6 left
[20:55] *** statisfiable6 left
[20:55] *** benchable6 left
[20:55] *** sourceable6 left
[20:55] *** tellable6 left
[20:55] *** releasable6 left
[20:56] *** bloatable6 joined
[20:56] *** greppable6 joined
[20:56] *** shareable6 joined
[20:56] *** unicodable6 joined
[20:57] *** bisectable6 joined
[20:57] *** notable6 joined
[20:57] *** evalable6 joined
[20:57] *** benchable6 joined
[20:57] *** quotable6 joined
[20:57] *** reportable6 joined
[20:57] *** releasable6 joined
[20:58] *** nativecallable6 joined
[20:58] *** linkable6 joined
[20:58] *** tellable6 joined
[20:58] *** coverable6 joined
[20:59] *** committable6 joined
[20:59] *** sourceable6 joined
[20:59] *** statisfiable6 joined
[22:17] *** sena_kun left
