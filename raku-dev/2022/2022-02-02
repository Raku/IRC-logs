[00:08] *** reportable6 left
[00:48] <ugexe> MasterDuke: I think your issue might be closer to https://github.com/rakudo/rakudo/issues/1920

[00:49] <ugexe> the first example isn't golfed much but its the same result with just one module

[01:03] *** [Coke]_ joined
[01:03] *** [Coke] left
[01:08] *** reportable6 joined
[02:03] *** squashable6 left
[02:17] *** frost joined
[02:52] *** [Coke] joined
[02:53] *** [Coke]_ left
[03:03] *** frost left
[03:06] *** squashable6 joined
[04:32] *** unicodable6 left
[04:32] *** statisfiable6 left
[04:32] *** greppable6 left
[04:32] *** benchable6 left
[04:32] *** nativecallable6 left
[04:32] *** tellable6 left
[04:32] *** quotable6 left
[04:32] *** shareable6 left
[04:32] *** coverable6 left
[04:32] *** notable6 left
[04:32] *** bisectable6 left
[04:32] *** bloatable6 left
[04:32] *** sourceable6 left
[04:32] *** releasable6 left
[04:32] *** committable6 left
[04:32] *** evalable6 left
[04:32] *** squashable6 left
[04:32] *** linkable6 left
[04:32] *** reportable6 left
[04:32] *** nativecallable6 joined
[04:33] *** reportable6 joined
[04:33] *** committable6 joined
[04:34] *** notable6 joined
[04:34] *** releasable6 joined
[04:34] *** sourceable6 joined
[04:34] *** squashable6 joined
[04:34] *** statisfiable6 joined
[04:34] *** greppable6 joined
[04:34] *** bisectable6 joined
[04:34] *** coverable6 joined
[05:38] *** AlexDaniel left
[05:39] *** nine left
[05:39] *** statisfiable6 left
[05:39] *** sourceable6 left
[05:39] *** ugexe left
[05:39] *** eof left
[05:39] *** [Coke] left
[05:39] *** djinni` left
[05:39] *** moon-child left
[05:39] *** sivoais left
[05:39] *** coverable6 left
[05:39] *** squashable6 left
[05:39] *** notable6 left
[05:39] *** committable6 left
[05:39] *** reportable6 left
[05:39] *** CIAvash left
[05:39] *** JRaspass left
[05:39] *** jdv left
[05:39] *** masak left
[05:39] *** Voldenet left
[05:39] *** samcv left
[05:39] *** tonyo left
[05:39] *** bartolin_ left
[05:39] *** gfldex left
[05:39] *** jjatria left
[05:39] *** rypervenche left
[05:39] *** Util left
[05:39] *** samebchase left
[05:39] *** qorg11 left
[05:39] *** lizmat left
[05:39] *** tbrowder left
[05:39] *** [Tux] left
[05:39] *** leont left
[05:39] *** kawaii_ left
[05:39] *** rba left
[05:39] *** codesections left
[05:42] *** andinus` left
[05:43] *** andinus joined
[05:47] *** andinus left
[05:50] *** Geth left
[05:50] *** MasterDuke left
[05:50] *** Altai-man left
[05:50] *** nebuchadnezzar left
[05:52] *** Kaiepi left
[05:52] *** vrurg left
[05:52] *** japhb left
[05:52] *** discord-raku-bot left
[05:52] *** kjp left
[05:52] *** timo left
[05:52] *** maettu left
[05:52] *** ilogger2 left
[05:52] *** camelia left
[05:52] *** zostay left
[05:53] *** nebuchadnezzar joined
[05:53] *** Altai-man joined
[05:53] *** MasterDuke joined
[05:53] *** Geth joined
[05:53] *** [Coke]_ joined
[05:53] *** quotable6 joined
[05:53] *** linkable6 joined
[05:53] *** bloatable6 joined
[05:53] *** unicodable6 joined
[05:53] *** coverable6 joined
[05:53] *** statisfiable6 joined
[05:53] *** squashable6 joined
[05:53] *** sourceable6 joined
[05:53] *** notable6 joined
[05:53] *** committable6 joined
[05:53] *** reportable6 joined
[05:53] *** qorg11 joined
[05:53] *** CIAvash joined
[05:53] *** AlexDaniel joined
[05:53] *** ugexe joined
[05:53] *** rypervenche joined
[05:53] *** nine joined
[05:53] *** [Tux] joined
[05:53] *** samcv joined
[05:53] *** Voldenet joined
[05:53] *** lizmat joined
[05:53] *** Util joined
[05:53] *** djinni` joined
[05:53] *** tonyo joined
[05:53] *** bartolin_ joined
[05:53] *** gfldex joined
[05:53] *** moon-child joined
[05:53] *** leont joined
[05:53] *** kawaii_ joined
[05:53] *** rba joined
[05:53] *** codesections joined
[05:53] *** sivoais joined
[05:53] *** eof joined
[05:53] *** masak joined
[05:53] *** jdv joined
[05:53] *** JRaspass joined
[05:53] *** samebchase joined
[05:53] *** jjatria joined
[05:53] *** tbrowder joined
[05:54] *** Kaiepi joined
[05:54] *** vrurg joined
[05:54] *** japhb joined
[05:54] *** discord-raku-bot joined
[05:54] *** kjp joined
[05:54] *** timo joined
[05:54] *** maettu joined
[05:54] *** ilogger2 joined
[05:54] *** camelia joined
[05:54] *** zostay joined
[06:07] *** reportable6 left
[06:08] *** reportable6 joined
[06:13] *** linkable6 left
[06:26] *** qorg11 left
[06:27] *** qorg11 joined
[06:33] *** evalable6 joined
[06:33] *** shareable6 joined
[06:34] *** tellable6 joined
[06:34] *** benchable6 joined
[07:32] *** squashable6 left
[07:33] *** squashable6 joined
[07:46] <Geth> ¦ nqp: 585e85b860 | (Stefan Seifert)++ | src/vm/moar/QAST/QASTCompilerMAST.nqp

[07:46] <Geth> ¦ nqp: Fix generated attribute accessors treating all native ints as signed

[07:46] <Geth> ¦ nqp: 

[07:46] <Geth> ¦ nqp: Now that bootstrapping issues are behind us, we can safely switch to the

[07:46] <Geth> ¦ nqp: correct behaviour.

[07:46] <Geth> ¦ nqp: review: https://github.com/Raku/nqp/commit/585e85b860

[07:47] <Geth> ¦ rakudo: 8bba2aec43 | (Stefan Seifert)++ | tools/templates/NQP_REVISION

[07:47] <Geth> ¦ rakudo: Bump NQP to get fix for accessors for unsigned native ints

[07:47] <Geth> ¦ rakudo: review: https://github.com/rakudo/rakudo/commit/8bba2aec43

[07:48] <nine> Seems to fix several TODOs :)

[08:07] *** frost joined
[08:22] <Geth> ¦ rakudo: 4e1a772147 | (Stefan Seifert)++ | src/Perl6/World.nqp

[08:22] <Geth> ¦ rakudo: Fix "No registered operation handler for 'iseq_u'"

[08:22] <Geth> ¦ rakudo: 

[08:22] <Geth> ¦ rakudo: Regression caused by a38bebecf8b1f125e8408c2a6d0a2e19d47545dd

[08:22] <Geth> ¦ rakudo: There is no iseq_u, so we have to use iseq_i instead. Whether that's correct

[08:22] <Geth> ¦ rakudo: depends on whether one expects iseq_i to compare abstract values

[08:22] <Geth> ¦ rakudo: (i.e. -1 != 255) or to implicitly coerce (-1 == 255).

[08:22] <Geth> ¦ rakudo: review: https://github.com/rakudo/rakudo/commit/4e1a772147

[08:55] <lizmat> Files=1351, Tests=117097, 288 wallclock secs (35.49 usr  9.87 sys + 4024.22 cusr 332.78 csys = 4402.36 CPU)

[08:55] <Geth> ¦ roast: b1349ef6eb | (Stefan Seifert)++ | 3 files

[08:55] <Geth> ¦ roast: Un-todo some now passing tests

[08:55] <Geth> ¦ roast: review: https://github.com/Raku/roast/commit/b1349ef6eb

[09:16] *** frost left
[09:23] *** [Tux] left
[09:24] *** [Tux] joined
[09:44] *** squashable6 left
[09:51] *** frost61 joined
[10:05] <Geth> ¦ nqp: f1bc85e708 | (Stefan Seifert)++ | tools/templates/MOAR_REVISION

[10:05] <Geth> ¦ nqp: Bump MoarVM to get an uint fix

[10:05] <Geth> ¦ nqp: review: https://github.com/Raku/nqp/commit/f1bc85e708

[10:06] <Geth> ¦ rakudo: d743ebfd02 | (Stefan Seifert)++ | tools/templates/NQP_REVISION

[10:06] <Geth> ¦ rakudo: Bump NQP to get an uint fix on MoarVM

[10:06] <Geth> ¦ rakudo: review: https://github.com/rakudo/rakudo/commit/d743ebfd02

[10:09] *** squashable6 joined
[10:13] *** linkable6 joined
[10:43] *** frost61 left
[10:43] <Geth> ¦ rakudo: c92833f350 | (Stefan Seifert)++ | 2 files

[10:43] <Geth> ¦ rakudo: Fix NativeCall wrongly expecting signed integer for size_t rw args

[10:43] <Geth> ¦ rakudo: review: https://github.com/rakudo/rakudo/commit/c92833f350

[11:00] <Geth> ¦ rakudo: 3445513858 | (Elizabeth Mattijsen)++ | src/core.c/Date.pm6

[11:00] <Geth> ¦ rakudo: Don't assume "year" as unit

[11:00] <Geth> ¦ rakudo: 

[11:00] <Geth> ¦ rakudo: In response to #4756.  Since we generally ignore any unexpected

[11:00] <Geth> ¦ rakudo: named arguments on method calls, this seems to be the most compatible

[11:00] <Geth> ¦ rakudo: solution.

[11:00] <Geth> ¦ rakudo: review: https://github.com/rakudo/rakudo/commit/3445513858

[11:00] <lizmat> .oO( it's been a while I did so many core setting compiles in a morning!  )

[11:01] *** linkable6 left
[11:43] *** sena_kun joined
[12:02] *** linkable6 joined
[12:07] *** reportable6 left
[12:12] *** frost joined
[12:14] <Geth> ¦ nqp: e4e3e9feed | (Stefan Seifert)++ | 3 files

[12:14] <Geth> ¦ nqp: New (at|bind)pos[23n]d_u and multidimref_u ops

[12:14] <Geth> ¦ nqp: review: https://github.com/Raku/nqp/commit/e4e3e9feed

[12:14] <lizmat> ooo!

[12:25] <Geth> ¦ rakudo: 8777e9237a | (Stefan Seifert)++ | 3 files

[12:25] <Geth> ¦ rakudo: Use proper unsigned ops for accessing multidim uint arrays

[12:25] <Geth> ¦ rakudo: review: https://github.com/rakudo/rakudo/commit/8777e9237a

[12:30] *** sena_kun left
[12:33] *** sena_kun joined
[12:45] *** frost left
[13:02] <nine> jdv: I'd appreciate a new Blin run. I think I've fixed all different failure modes, but testing every single failed module individually is kinda tedious. The list should now also be short enough to fit into a ticket.

[13:02] <nine> vrurg: PDF suffers from multiple issues. Among them "get_boxed_ref could not unbox for the representation 'P6bigint' of type Scalar" which can be fixed by:

[13:02] <nine>  my subset UInt of Int where {

[13:02] <nine> -    nqp::not_i(nqp::isconcrete($_)) || nqp::isge_I($_,0)

[13:02] <nine> +    nqp::not_i(nqp::isconcrete($_)) || nqp::isge_I(nqp::decont($_),0

[13:03] <nine> vrurg: IIRC you did some more work on subsets and smartmatch?

[13:07] <lizmat> nine: shouldn't the decont also apply to the isconcrete($_) ??

[13:11] <nine> lizmat: indeed. But I think the where block should be called with a deconted value in the first place. At least it seems to have been previously.

[13:11] <lizmat> ah, that would make sense...  :-)

[13:14] <Geth> ¦ rakudo: e4a4a92f1e | (Stefan Seifert)++ | src/core.c/array_multislice.pm6

[13:14] <Geth> ¦ rakudo: Fix "container does not reference a native integer" in multi slice

[13:14] <Geth> ¦ rakudo: 

[13:14] <Geth> ¦ rakudo: We can now get IntLexRef as well as UIntLexRef. The latter doesn't unbox

[13:14] <Geth> ¦ rakudo: directly to int, so we have to put the value into a Scalar first.

[13:14] <Geth> ¦ rakudo: review: https://github.com/rakudo/rakudo/commit/e4a4a92f1e

[13:26] *** [Coke]_ is now known as [Coke]

[13:56] *** discord-raku-bot left
[13:57] *** discord-raku-bot joined
[14:05] *** discord-raku-bot left
[14:05] *** discord-raku-bot joined
[14:24] *** sena_kun left
[14:24] <vrurg> nine: Sorry, don't really follow you. First of all, I don't know how exactly and where PDF fails.

[14:25] *** sena_kun joined
[14:36] <vrurg> nine: But you actually reminded me that we now have a new primspec. Does 4 stands for uint? 

[15:06] <[Coke]> is that different from the thing that just got changed to 400?

[15:09] *** reportable6 joined
[15:40] <vrurg> [Coke]: It's BUILDPLAN codes which got changed because of a new primspec.

[15:41] <vrurg> The codes now remind be about BASIC times... :)

[16:03] *** Kaipi joined
[16:06] *** Kaiepi left
[16:37] <nine> vrurg: uint is 10

[17:14] <Geth> ¦ rakudo: 7cb214671c | (Stefan Seifert)++ | 2 files

[17:14] <Geth> ¦ rakudo: Fix "container does not reference a native integer" with mixed int/uint multidim array indexes

[17:14] <Geth> ¦ rakudo: 

[17:14] <Geth> ¦ rakudo: Giving arguments their own scalar containers triggers a decont from any native

[17:14] <Geth> ¦ rakudo: reference containers passed for indexes. We can then unbox to a native int

[17:14] <Geth> ¦ rakudo: regardless of whether the original value was an int or uint.

[17:14] <Geth> ¦ rakudo: review: https://github.com/rakudo/rakudo/commit/7cb214671c

[17:16] <nine> vrurg: to reproduce run PDF's t/00-helloworld.t on current rakudo. You will get a test failure due to # P6opaque: get_boxed_ref could not unbox for the representation 'P6bigint' of type Scalar

[18:06] *** reportable6 left
[18:24] *** sena_kun left
[18:45] <vrurg> nine: I just thought that if it's as simple as you suggested you can do it on your own. :) 

[18:46] <vrurg> Ok, I'll check if it helps later today.

[19:03] <nine> vrurg: thing is, I don't think my fix is correct. Feels like a workaround for a missing decontainerization in the smartmatch dispatcher

[19:10] *** Merfont joined
[19:13] *** Kaipi left
[19:21] <jdv> nine: ok, cool.  but maybe i should wait a bit sounds like?

[19:35] <Geth> ¦ nqp/lizmat-race-on-QAST-Node: 54a0a27c0f | (Elizabeth Mattijsen)++ | src/QAST/Node.nqp

[19:35] <Geth> ¦ nqp/lizmat-race-on-QAST-Node: Fix race when checking for global uniques

[19:35] <Geth> ¦ nqp/lizmat-race-on-QAST-Node: 

[19:35] <Geth> ¦ nqp/lizmat-race-on-QAST-Node: As inferred from a stack trace from code that was doing EVAL inside

[19:35] <Geth> ¦ nqp/lizmat-race-on-QAST-Node: of a hyper:

[19:35] <Geth> ¦ nqp/lizmat-race-on-QAST-Node: 

[19:35] <Geth> ¦ nqp/lizmat-race-on-QAST-Node: MoarVM oops: MVM_str_hash_fetch_nocheck called with a stale hashtable pointer

[19:35] <Geth> ¦ nqp/lizmat-race-on-QAST-Node:    at gen/moar/stage2/QASTNode.nqp:249  (.../install/share/nqp/lib/QASTNode.moarvm:unique)

[19:35] <Geth> ¦ nqp/lizmat-race-on-QAST-Node: <…commit message has 6 more lines…>

[19:35] <Geth> ¦ nqp/lizmat-race-on-QAST-Node: review: https://github.com/Raku/nqp/commit/54a0a27c0f

[19:35] <Geth> ¦ nqp: lizmat++ created pull request #760: Fix race when checking for global uniques

[19:35] <Geth> ¦ nqp: review: https://github.com/Raku/nqp/pull/760

[19:56] <MasterDuke> nqp: my %h := nqp::hash("a", 1, "b", 3); my $a := "c"; my $b := ++%h{$a}; say($b); say(%h{$a})

[19:56] <camelia> nqp-moarvm: OUTPUT: «1␤1␤»

[19:57] <lizmat> indeed

[19:57] <lizmat> what I'm more worried about is what happens if one thread adds something to the %global-uniques hash, and the other thread updates over it and removes it

[20:00] <MasterDuke> well, it looks like that hash is never deleted from, if that's what you mean

[20:05] <lizmat> well, that's what I would expect

[20:05] <lizmat> I mean that thread A clones an empty hash and adds "foo" to it, while thread B also clones the empty hash and add "bar" to it

[20:06] <lizmat> the one who binds back the last, will lose the addition of the other thread

[20:07] <nine> If that's an issue, you really need a lock. Or go the full compare and swap in a loop route

[20:07] <lizmat> well, yes

[20:08] <lizmat>  but I'm totally unclear what the real meaning is of that hash

[20:08] <ugexe> i think the behavior your witnessed suggests that your concern is also possible though

[20:08] <lizmat> nine: but you agree there's a race condition there, when called as a class method, right ?

[20:09] <ugexe> like even if we don't know what its meaning is, we know multiple threads can enter the critical area

[20:09] <lizmat> I mean, perhaps some crashes can be explained by values being lost

[20:09] <lizmat> even without it crashing

[20:09] <nine> With my %uniques; absolutely

[20:09] <nine> Shared state is the bane of all threaded code

[20:10] <MasterDuke> it's for creating unique node names, e.g., https://github.com/Raku/nqp/blob/master/src/NQP/Optimizer.nqp#L103

[20:12] <lizmat> ahh, so lost updates *would* mess up things considerabley

[20:13] <nine> I'd just add a lock there

[20:13] <lizmat> feels that would be pretty bad for compilation performance

[20:14] <MasterDuke> we could also just switch to generating random names, e.g., `return $prefix ~ '_' ~ nqp::sha1($prefix ~ nqp::time)`

[20:14] <nine> No, no, no, no, no, no, no

[20:14] <nine> lizmat: feelings are one thing. Measurements are useful

[20:14] <lizmat> ok, so maybe we just need a separate method for each key

[20:15] <lizmat> and then use an atomic integer increment ?

[20:16] <lizmat> that would also safe on a few lookups

[20:16] <lizmat> hmmm.. looks like that would be quite a number of methods

[20:17] <nine> First, I'd just add that lock and have a look if that makes any measurable difference at all.

[20:19] *** evalable6 left
[20:19] *** linkable6 left
[20:19] <lizmat> nine: and how do you do that in NQP 

[20:19] <lizmat> ?

[20:19] <MasterDuke> there's an NQPLock

[20:19] <nine> https://github.com/Raku/nqp/blob/master/src/QAST/Block.nqp#L43

[20:20] <nine> And https://github.com/Raku/nqp/blob/master/src/QAST/Block.nqp#L51

[20:20] <lizmat> ok, will rewrite using lock

[20:22] <MasterDuke> in an entire rakudo build+install, that method is called 97.5k times. 41756 __lowered_lex, 25943 __lowered_param_, 16637 __lowered_param_decont_, 3557 assign_cont, 2294 buildall_tmp_, 859 how_invocant, ...

[20:23] <lizmat> MasterDuke: so is that a lot?  I have no feel for these numbers :-)

[20:24] <ugexe> i think the saying goes locks aren't slow, lock contention is slow

[20:24] <MasterDuke> dunno. but since we don't usually compile with multiple threads, the lock probably won't be contended for that much

[20:24] <lizmat> right, ok

[20:27] <vrurg> Wish we had atomics in NQP. They'd be of some advantage over locks in such simple cases.

[20:27] <Geth> ¦ nqp/lizmat-race-on-QAST-Node: 056961ad5c | (Elizabeth Mattijsen)++ | src/QAST/Node.nqp

[20:27] <Geth> ¦ nqp/lizmat-race-on-QAST-Node: Rework using locks, nine++, ugexe++ MasterDuke++

[20:27] <Geth> ¦ nqp/lizmat-race-on-QAST-Node: review: https://github.com/Raku/nqp/commit/056961ad5c

[20:27] <lizmat> nine like that ?

[20:31] <Geth> ¦ nqp/lizmat-race-on-QAST-Node: fd2aad4d4f | (Elizabeth Mattijsen)++ | src/QAST/Node.nqp

[20:31] <Geth> ¦ nqp/lizmat-race-on-QAST-Node: Make use of autovivification, MasterDuke++

[20:31] <Geth> ¦ nqp/lizmat-race-on-QAST-Node: review: https://github.com/Raku/nqp/commit/fd2aad4d4f

[20:31] <nine> lizmat: yep

[20:32] <lizmat> ok, I'll merge and bump for better bisectability

[20:33] <Geth> ¦ nqp: f23b6aca69 | (Elizabeth Mattijsen)++ (committed using GitHub Web editor) | src/QAST/Node.nqp

[20:33] <Geth> ¦ nqp: Fix race when checking for global uniques (#760)

[20:33] <Geth> ¦ nqp: 

[20:33] <Geth> ¦ nqp: As inferred from a stack trace from code that was doing EVAL inside

[20:33] <Geth> ¦ nqp: of a hyper:

[20:33] <Geth> ¦ nqp: 

[20:33] <Geth> ¦ nqp: MoarVM oops: MVM_str_hash_fetch_nocheck called with a stale hashtable pointer

[20:33] <Geth> ¦ nqp:    at gen/moar/stage2/QASTNode.nqp:249  

[20:33] <Geth> ¦ nqp: 

[20:33] <Geth> ¦ nqp: With pointers by ugexe++, MasterDuke++ and nine++

[20:33] <Geth> ¦ nqp: review: https://github.com/Raku/nqp/commit/f23b6aca69

[20:36] *** Altai-man left
[20:37] <MasterDuke> didn't notice a rakudo build taking any longer

[20:38] <lizmat> well, there's only ever 1 hash lookup now instead of 2

[20:38] <lizmat> that should be helpful :-)

[20:39] *** sena_kun joined
[20:43] <nine> lose some, gain some ;)

[20:43] <Geth> ¦ rakudo: 26215f20c1 | (Vadim Belman)++ | src/core.c/Int.pm6

[20:43] <Geth> ¦ rakudo: Fix UInt where block trying to unbox a Scalar

[20:43] <Geth> ¦ rakudo: 

[20:43] <Geth> ¦ rakudo: `nqp::isconcrete` doesn't need deconting, BTW.

[20:43] <Geth> ¦ rakudo: review: https://github.com/rakudo/rakudo/commit/26215f20c1

[20:44] <nine> vrurg: but why does that where block suddenly need the decont? It has never been necessary before

[20:46] <vrurg> nine: Hm, it's a good question. I thought something has changed about the unboxing op. Now I see your point.

[20:46] <MasterDuke> spectest seems about the same too

[20:46] <ugexe> https://github.com/rakudo/rakudo/blob/7cb214671c6d42c97f63d2cee27b7df19aaf5828/src/core.c/CompUnit/PrecompilationStore/File.pm6#L317 -- should this have a `try`? If multiple threads try to load the same module then they would be trying to rename the same file. only one would succeed at renaming, but technically that should be sufficient. however currently it throws an exception when the rename

[20:46] <ugexe> fails

[20:46] <lizmat> spectest feels a  bit slower to me

[20:47] <lizmat> but we'll now tomorrow

[20:48] <nine> ugexe: I wonder if it were better to pick a random file extension instead of .tmp, so those threads or processes wouldn't try to move the same file in the first place.

[20:48] <Geth> ¦ rakudo: f47d95e032 | (Elizabeth Mattijsen)++ | tools/templates/NQP_REVISION

[20:49] <Geth> ¦ rakudo: Bump NQP to get a compilation race fix

[20:49] <Geth> ¦ rakudo: review: https://github.com/rakudo/rakudo/commit/f47d95e032

[20:49] <lizmat> *know

[20:49] <vrurg> nine: I don't decont the topic in the smartmatch optimizations. If it's been done before it was rather accidental as it was never specced.

[20:50] <nine> lizmat: about those locks. IIRC you can estimate around a 100 CPU cycles for acquiring a lock. At 1 GHz taking 100k locks (like in the entire rakudo build+install) should therefor cost about 0.01s

[20:50] <vrurg> m: my $v = 4; say $v.VAR ~~ Scalar

[20:50] <camelia> rakudo-moar 26215f20c: OUTPUT: «True␤»

[20:50] <vrurg> m: my $v := 4; say $v.VAR ~~ Scalar

[20:50] <camelia> rakudo-moar 26215f20c: OUTPUT: «False␤»

[20:51] <nine> vrurg: from that issue I presume that smartmatch did decont before

[20:52] <vrurg> nine: So far, there is no fallout from this change. And I like that the matching against scalar works now. 

[20:52] <nine> vrurg: with this patch to PDF itself: https://gist.github.com/niner/2567d43baa26611b45464773f836df7c you should get down to the last remaining issue, which looks smartmatchy to me

[20:58] <lizmat> afk&

[20:59] <vrurg> nine: Going to look into it. BTW, even though ~~ was deconting, the `where` block was working until somebody would report UInt.ACCEPTS or UInt.^accepts_type failure.

[21:00] <vrurg> So, we'd end up with the same issue anyway.

[21:11] *** camelia left
[21:11] *** zostay left
[21:11] *** vrurg left
[21:11] *** japhb left
[21:11] *** kjp left
[21:11] *** timo left
[21:11] *** maettu left
[21:11] *** ilogger2 left
[21:11] *** sena_kun left
[21:11] *** Geth left
[21:11] *** MasterDuke left
[21:11] *** nebuchadnezzar left
[21:11] *** AlexDaniel left
[21:11] *** nine left
[21:11] *** Merfont left
[21:11] *** squashable6 left
[21:11] *** benchable6 left
[21:11] *** shareable6 left
[21:11] *** qorg11 left
[21:11] *** bloatable6 left
[21:11] *** unicodable6 left
[21:11] *** statisfiable6 left
[21:11] *** sourceable6 left
[21:11] *** ugexe left
[21:11] *** eof left
[21:11] *** discord-raku-bot left
[21:11] *** djinni` left
[21:11] *** moon-child left
[21:11] *** sivoais left
[21:11] *** [Tux] left
[21:11] *** coverable6 left
[21:11] *** notable6 left
[21:11] *** committable6 left
[21:11] *** CIAvash left
[21:11] *** JRaspass left
[21:11] *** jdv left
[21:11] *** masak left
[21:11] *** Voldenet left
[21:11] *** samcv left
[21:11] *** tonyo left
[21:11] *** bartolin_ left
[21:11] *** gfldex left
[21:11] *** jjatria left
[21:11] *** rypervenche left
[21:11] *** Util left
[21:11] *** samebchase left
[21:11] *** [Coke] left
[21:11] *** quotable6 left
[21:11] *** lizmat left
[21:11] *** tbrowder left
[21:11] *** leont left
[21:11] *** kawaii_ left
[21:11] *** rba left
[21:11] *** codesections left
[21:14] *** gfldex joined
[21:14] *** bartolin_ joined
[21:14] *** tonyo joined
[21:14] *** samcv joined
[21:14] *** ilogger2 joined
[21:14] *** maettu joined
[21:14] *** timo joined
[21:14] *** kjp joined
[21:14] *** japhb joined
[21:14] *** vrurg joined
[21:14] *** nine joined
[21:14] *** AlexDaniel joined
[21:14] *** codesections joined
[21:14] *** rba joined
[21:14] *** kawaii_ joined
[21:14] *** leont joined
[21:14] *** masak joined
[21:14] *** jdv joined
[21:14] *** moon-child joined
[21:14] *** djinni` joined
[21:14] *** discord-raku-bot joined
[21:14] *** discord-raku-bot left
[21:14] *** discord-raku-bot joined
[21:14] *** Merfont joined
[21:14] *** squashable6 joined
[21:14] *** benchable6 joined
[21:14] *** shareable6 joined
[21:14] *** qorg11 joined
[21:14] *** bloatable6 joined
[21:14] *** unicodable6 joined
[21:14] *** statisfiable6 joined
[21:14] *** sourceable6 joined
[21:14] *** ugexe joined
[21:14] *** eof joined
[21:15] *** jjatria joined
[21:15] *** camelia joined
[21:15] *** zostay joined
[21:15] *** AlexDaniel left
[21:15] *** rypervenche joined
[21:15] *** Util joined
[21:15] *** samebchase joined
[21:19] *** evalable6 joined
[21:27] <ugexe> Serialization Error: Unimplemented case of read_ref

[21:27] <ugexe> havent seen that one yet

[21:29] <ugexe> Invalid dependencies table index encountered (index 32)

[21:45] *** CIAvash joined
[22:16] <ugexe> I wonder if ".{now}.{$*PID}.{$*THREAD.id}.tmp" is sufficient

[22:19] <vrurg> ugexe: Thread ID I'd consider unreliable.

[22:19] <moon-child> sufficient for what?  (Sorry, may have missed context due to netsplit)

[22:19] <ugexe> for a given Instant

[22:20] <ugexe> for generating a unique temp file name 

[22:20] <moon-child> oh, make a random string and retry it until you succeed

[22:20] <vrurg> But nqp::objectid($*THREAD) could be better.

[22:20] <ugexe> that wont work in this case

[22:21] <ugexe> the random string and retry

[22:21] <ugexe> thats not thread safe

[22:21] <moon-child> why not?

[22:22] <vrurg> moon-child: the filesystem may change after the check.

[22:22] <moon-child> dynamic bindings are thread-local no?

[22:22] <vrurg> What could be miore reliable is open(:create-only) and retry on failure. 

[22:23] <ugexe> i'm not sure thats an option in the code

[22:23] <moon-child> vrurg: what's the difference between that and what I said?

[22:23] <vrurg> ugexe: open? why?

[22:24] <vrurg> moon-child: you just mentioned a string only. :)

[22:24] <ugexe> https://github.com/rakudo/rakudo/blob/7cb214671c6d42c97f63d2cee27b7df19aaf5828/src/core.c/CompUnit/PrecompilationStore/File.pm6#L311-L317

[22:25] <ugexe> self!file calls self!dir which involves a lock

[22:26] <moon-child> vrurg: ok, maybe not super clear :P that was what I meant though

[22:26] <ugexe> which is just to say its not as easy as just having the handle in that spot due to ^

[22:28] <vrurg> ugexe: then objectid of $*THREAD would work. Thread ID can be shared, but $*THREAD is always unique per-thread.

[22:29] <ugexe> right, in this specific case i don't think $*THREAD.id would change. but yeah objectid is better

[22:30] <vrurg> I don't think either, but a custom scheduler might have different opinion on this.

[22:32] <vrurg> Perhaps it worth to spec $*THREAD uniqueness to ensure correct behavior of any possible 3rd party scheduler.

[22:45] <Geth> ¦ rakudo: ef4abcc780 | (Vadim Belman)++ | src/vm/moar/dispatchers.nqp

[22:45] <Geth> ¦ rakudo: Use nqp::istype for nominalizable smartmatch

[22:45] <Geth> ¦ rakudo: 

[22:45] <Geth> ¦ rakudo: It is used to shortcut to `.^accepts_type`, but `nqp::istype` could do

[22:45] <Geth> ¦ rakudo: more than falling back to this method.

[22:45] <Geth> ¦ rakudo: review: https://github.com/rakudo/rakudo/commit/ef4abcc780

[22:52] *** AlexDaniel joined
[22:58] *** MasterDuke joined
