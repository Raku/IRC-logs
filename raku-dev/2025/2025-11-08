[05:25] <disbot1> <m_zero> Both PL/1 and ADA let you specifiy the lower and upper bounds of the index into an array. Both have a totally well defined meaning for an array with indexes -1 to 8.

[05:26] <disbot1> <m_zero> Oh - Pascal, too.

[05:30] *** melezhik joined
[05:32] <disbot1> <m_zero> Use case: a histogram of the outcomes of rolling two dice: Needs only indexes 2..12

[05:36] <disbot1> <m_zero> (Note that I'm endorsing such a feature: While I have programed in two of those languages, I don't think there are really many real world use cases that aren't better served by enums or other just a dict of some sort. Only pointing out that such ideas have been floating around programming languages for over 50 years.)

[05:36] <disbot1> <m_zero> ((Fun note: I just realized I started programming 50 years ago!))

[07:36] *** melezhik left
[07:52] *** melezhik joined
[08:16] <ab5tract> Nice milestone! I was thinking about APL when discussing 0-index vs 1-index

[08:18] <ab5tract> You presented a use case for 2-index. I still don’t understand what you could use a negative index for beyond saving yourself arithmetic on the pointer

[08:19] <ab5tract> Or an empty slot or two in an array

[08:30] <ab5tract> Anyway, and no offense to lizmat for suggesting this, I would really hate to see this in the language.

[08:32] <ab5tract> Considering the 270+ open tickets marked as “will be addressed in RakuAST” and the month I spent getting absolutely nowhere with just one of the tickets blocking 6.e, it would feel like a misapplication of our extremely limited resources

[08:50] *** [Coke]_ joined
[08:52] *** [Coke] left
[09:56] *** melezhik left
[10:29] <Geth> ¦ rakudo/lizmat-no-range-shape: bfb4f25c9a | (Elizabeth Mattijsen)++ | 2 files

[10:29] <Geth> ¦ rakudo/lizmat-no-range-shape: Don't allow a Range in an array shape specification

[10:29] <Geth> ¦ rakudo/lizmat-no-range-shape: 

[10:29] <Geth> ¦ rakudo/lizmat-no-range-shape: Because it probably does *not* do what you think it does.

[10:29] <Geth> ¦ rakudo/lizmat-no-range-shape: 

[10:29] <Geth> ¦ rakudo/lizmat-no-range-shape: Before this, my @a[1..4] would create a 4-dimensional array, with

[10:29] <Geth> ¦ rakudo/lizmat-no-range-shape: dimensions 1,2,3,4.  Instead of defining a 1-dimensional array

[10:29] <Geth> ¦ rakudo/lizmat-no-range-shape: with indices 1 through 4.

[10:29] <Geth> ¦ rakudo/lizmat-no-range-shape: review: https://github.com/rakudo/rakudo/commit/bfb4f25c9a

[10:29] <Geth> ¦ rakudo: lizmat++ created pull request #6013: Don't allow a Range in an array shape specification

[10:29] <Geth> ¦ rakudo: review: https://github.com/rakudo/rakudo/pull/6013

[10:29] <lizmat> ab5tract ugexe at least we should stop this potential trap for now ^^

[10:43] *** melezhik joined
[11:09] <ab5tract> How does one create a 4 dimensional array then?

[11:09] <lizmat> m: my @a{2,2,3,4]

[11:09] <camelia> rakudo-moar 690b7f07a: OUTPUT: «===SORRY!=== Error while compiling <tmp>␤Unable to parse expression in shape definition; couldn't find final '}' (corresponding starter was at line 1)␤at <tmp>:1␤------> my @a{2,2,3,4<HERE>]␤    expecting any of:␤        statement end␤    …»

[11:09] <lizmat> m: my @a[2,2,3,4]

[11:09] <camelia> rakudo-moar 690b7f07a: ( no output )

[11:09] <lizmat> m: my @a[2,2,3,4]; dd @a

[11:09] <camelia> rakudo-moar 690b7f07a: OUTPUT: «Array.new(:shape(2, 2, 3, 4), [[[Any, Any, Any, Any], [Any, Any, Any, Any], [Any, Any, Any, Any]], [[Any, Any, Any, Any], [Any, Any, Any, Any], [Any, Any, Any, Any]]], [[[Any, Any, Any, Any], [Any, Any, Any, Any], [Any, Any, Any, Any]], [[Any, Any, An…»

[11:10] <lizmat> you pass it a List rather than a Range

[11:22] <ab5tract> Gotcha

[11:28] <lizmat> with the PR we can think about 6.e or 6.f for possible other meaning of my @a[Range]

[12:34] *** librasteve_ joined
[12:41] <lizmat> m: class A { has str @.a = <a b c> }; dd A.new.a    # this feels like a bug

[12:41] <camelia> rakudo-moar 690b7f07a: OUTPUT: «str  = array[str].new()␤»

[12:41] <lizmat> m: class A { has Str @.a = <a b c> }; dd A.new.a    # this feels like a bug

[12:41] <camelia> rakudo-moar 690b7f07a: OUTPUT: «Str  = Array[Str].new("a", "b", "c")␤»

[12:41] <lizmat> m: class A { has Str @.a = <a b c> }; dd A.new.a    # not a bug  :)

[12:41] <camelia> rakudo-moar 690b7f07a: OUTPUT: «Str  = Array[Str].new("a", "b", "c")␤»

[12:43] <lizmat> m: class A { has str @.a = <a b c> }; use BUILDPLAN A

[12:43] <camelia> rakudo-moar 690b7f07a: OUTPUT: «class A BUILDPLAN:␤ 0 nqp::getattr(obj,A,'@!a') = :$a if possible␤ 1 nqp::getattr(obj,A,'@!a') = execute-code() if not set␤»

[12:43] <lizmat> BUILDPLAN appears ok

[12:44] <lizmat> Actually, with RAKUDO_RAKUAST=1 step 1 of the BUILDPLAN becomes:  1 nqp::getattr(obj,A,'@!a') = ("a", "b", "c") if not set

[12:45] <lizmat> however, it does not work either :-(

[12:58] <lizmat> m: class A { has @.a is readonly = <a b c> }; my $a = A.new; $a.a = <c d e>; dd $a.a    # also meh  :-(

[12:58] <camelia> rakudo-moar 690b7f07a: OUTPUT: «["c", "d", "e"]␤»

[13:51] *** melezhik_ joined
[13:51] <melezhik_> .

[14:01] *** melezhik_ left
[14:01] *** melezhik_ joined
[14:07] *** melezhik_ left
[14:07] *** melezhik_ joined
[14:12] *** melezhik_ left
[14:44] *** librasteve_ left
[14:46] *** melezhik left
[15:22] *** librasteve_ joined
[17:24] *** librasteve_ left
[19:19] *** melezhik joined
[19:23] <ab5tract> TIL about is readonly

[21:02] *** [Coke]_ is now known as [Coke]

[21:29] *** melezhik left
