[01:24] <Geth> ¦ rakudo/main: 211197cbc8 | (Will Coleda)++ | tools/create-release-announcement.raku

[01:24] <Geth> ¦ rakudo/main: Fix URL in release announcement tool

[01:24] <Geth> ¦ rakudo/main: review: https://github.com/rakudo/rakudo/commit/211197cbc8

[03:00] <releasable6> Next release in ≈1 day and ≈15 hours. There are no known blockers. Please log your changes in the ChangeLog: https://github.com/rakudo/rakudo/wiki/ChangeLog-Draft

[04:38] *** Pixi left
[05:28] *** melezhik joined
[06:38] *** Pixi joined
[06:40] *** melezhik_ joined
[06:48] *** melezhik_ left
[06:48] *** melezhik_ joined
[06:54] <melezhik_> ab5tract: I believe I fixed yesterday issue with wrong job counter , please as usually pull the latest commit and upgrade your agents 

[07:05] *** melezhik_ left
[07:05] *** melezhik_ joined
[07:18] *** melezhik_ left
[07:18] *** melezhik_ joined
[07:24] *** melezhik_ left
[07:24] *** melezhik_ joined
[07:37] *** melezhik_ left
[07:37] *** melezhik left
[07:37] *** melezhik_ joined
[07:42] *** melezhik_ left
[08:03] *** melezhik_ joined
[08:03] *** melezhik_ left
[08:03] *** melezhik_ joined
[08:03] <melezhik_> .

[08:56] *** melezhik_ left
[08:56] *** melezhik_ joined
[09:04] *** melezhik_ left
[09:04] *** melezhik_ joined
[09:09] *** melezhik_ left
[09:09] *** melezhik_ joined
[09:14] *** melezhik_ left
[09:15] *** melezhik_ joined
[09:20] *** melezhik_ left
[09:20] *** melezhik_ joined
[09:25] *** melezhik_ left
[09:26] *** melezhik_ joined
[09:34] *** melezhik_ left
[09:34] *** melezhik_ joined
[09:42] *** melezhik_ left
[09:42] *** melezhik_ joined
[09:50] *** melezhik_ left
[09:50] *** melezhik_ joined
[10:03] *** melezhik_ left
[10:04] *** melezhik_ joined
[10:09] *** melezhik_ left
[10:09] *** melezhik_ joined
[10:15] *** melezhik_ left
[10:15] *** melezhik_ joined
[10:25] *** melezhik_ left
[10:25] *** melezhik_ joined
[10:31] *** melezhik_ left
[10:31] *** melezhik_ joined
[10:43] *** melezhik_ left
[10:44] *** melezhik_ joined
[10:51] *** melezhik_ left
[10:54] *** melezhik_ joined
[10:56] *** melezhik_ left
[11:18] *** melezhik joined
[12:22] *** melezhik_ joined
[12:22] <melezhik_> .

[12:38] *** melezhik_ left
[12:41] *** melezhik_ joined
[12:46] *** melezhik_ left
[12:46] *** melezhik_ joined
[12:53] *** melezhik_ left
[12:53] *** melezhik_ joined
[13:19] *** melezhik_ left
[13:19] *** melezhik_ joined
[13:24] *** melezhik_ left
[13:24] *** melezhik_ joined
[13:37] *** melezhik left
[13:40] *** melezhik_ left
[13:42] *** melezhik_ joined
[14:02] *** librasteve_ joined
[14:18] *** melezhik_ left
[14:19] *** melezhik_ joined
[14:27] *** melezhik_ left
[14:27] *** melezhik_ joined
[14:42] *** melezhik_ left
[14:43] *** melezhik_ joined
[14:52] *** melezhik_ left
[14:52] *** melezhik_ joined
[15:05] *** melezhik_ left
[15:05] *** melezhik_ joined
[15:40] *** melezhik_ left
[15:40] *** melezhik_ joined
[15:41] *** melezhik_ left
[15:43] * lizmat just realized that $¢ in RakuAST only lives in QAST land

[15:43] <lizmat> which is probably why we have this subtle difference:

[15:43] <lizmat> m: Q|say $¢|.EVAL

[15:43] <camelia> rakudo-moar 211197cbc: OUTPUT: «Nil␤»

[15:43] <lizmat> m: Q|say $¢|.AST.EVAL

[15:43] <camelia> rakudo-moar 211197cbc: OUTPUT: «(Mu)␤»

[16:16] <lizmat> so I just found that:   role A { dd $?ROLE }; class B does A { }    very quickly recurses on itself somehow

[16:16] <lizmat> m: role A { say $?ROLE }; class B does A { }   # but "say" doesn't

[16:16] <camelia> rakudo-moar 211197cbc: OUTPUT: «(A)␤»

[16:20] <lizmat> I guess a DIHWIDT case

[16:21] <timo> did you already find the spot that recurses?

[16:24] <lizmat> https://gist.github.com/lizmat/b2e97ffa4e1f6584c335fd0504621512    # first 50 lines out of the 80K I captured  :-)

[16:25] <lizmat> m: role A { say $?ROLE.raku }; class B does A { }      # it's not .raku that's doing it

[16:25] <camelia> rakudo-moar 211197cbc: OUTPUT: «A␤»

[16:29] <timo> there's an "exit" in dd? :D

[16:29] <lizmat> no, I used own-up

[16:30] <timo> m: class A { method statement-list { self }; method statements { [ ] } }; my $*CU = A.new; dd; say "survived dd call";

[16:30] <camelia> rakudo-moar 211197cbc: OUTPUT: «Cannot pop from an empty Array␤  in block <unit> at <tmp> line 1␤␤»

[16:30] <timo> m: class A { method statement-list { self }; method statements { [ 1 ] } }; my $*CU = A.new; dd; say "survived dd call";

[16:30] <camelia> rakudo-moar 211197cbc: ( no output )

[16:30] <timo> m: class A { method statement-list { self }; method statements { [ 1 ] } }; dd; say "survived dd call";

[16:30] <camelia> rakudo-moar 211197cbc: OUTPUT: «block <unit>()␤survived dd call␤»

[16:32] <timo> it's recursing inside of sub prefix?

[16:33] <lizmat> not sure...  as it looked like a DIHWIDT, I didn't want to look much further right now

[16:34] <timo> might have been the call to .of there

[16:35] <timo> this also seems to infini-recurse: role A { say $?ROLE.of }; class B does A { }

[16:36] <lizmat> ah, that may be it, as dd is trying to do that

[16:37] <timo> ok, so

[16:38] <timo> trying to call .of on the role forces it to be punned

[16:38] <timo> that causes the body of the role to be run

[16:38] <timo> that calls into dd or say again

[16:38] <lizmat> ah.. and that causes it to be punned again, as it isn't punned yet

[16:44] <timo> that's probably also why there's an `-e:1` frame in there, that's the role body

[17:21] *** melezhik_ joined
[17:30] *** melezhik_ left
[17:34] *** melezhik_ joined
[17:48] *** melezhik_ left
[17:49] *** melezhik_ joined
[17:53] *** melezhik_ left
[18:22] *** melezhik joined
[19:03] <lizmat> rakkable: eco-provides $*EXECUTABLE-NAME

[19:03] <rakkable> lizmat, Running: eco-provides $*EXECUTABLE-NAME, please be patient!

[19:03] <rakkable> lizmat, Found 4 lines in 2 files (1 distributions):

[19:03] <rakkable> lizmat, https://gist.github.com/79cff38d3e97d00a291bdd0d278f6de6

[21:16] <ab5tract> This transitive role thing is really weird… the role appears to be composed when the type checking arrives

[21:16] <ab5tract> er, when it arrives at type checking

[21:16] <ab5tract> R#5317

[21:16] <linkable6> R#5317 [open]: https://github.com/rakudo/rakudo/issues/5317 [roles][Will be addressed in RakuAST] role-constrained variable does not accept derived role defined inline

[21:17] <ab5tract> That is, $value.HOW is a ClassHOW, but with the nominal archetype

[22:02] <[Coke]> anyone want access to the Snyk issues? patrickb? 

[22:02] *** melezhik left
[22:40] *** committable6 left
[22:40] *** quotable6 left
[22:40] *** releasable6 left
[22:40] *** sourceable6 left
[22:40] *** unicodable6 left
[22:40] *** lizmat left
[22:41] *** [Tux] left
[22:44] *** lizmat_ joined
[22:44] *** [Tux] joined
[22:59] <ab5tract> https://gist.github.com/ab5tract/468ffb02ca717bf520b6b566ce3e8682 <-- it looks like inline role's aren't composed

[23:02] *** melezhik joined
[23:24] *** lizmat_ left
[23:24] *** lizmat joined
