[01:30] *** librasteve_ left
[02:05] <[Coke]> the inline::perl5 failure is reproducible on rakudo HEAD on mac os, even.

[05:19] *** ShimmerFairy left
[05:30] *** ShimmerFairy joined
[07:00] *** sivoais_ left
[07:02] *** sivoais joined
[07:03] *** Pixi left
[07:03] *** ShimmerFairy left
[07:27] <patrickb> [Coke]: What are your exact steps for reproduction?

[07:27] <patrickb> (it doesn't show for me on MacOS)

[07:35] *** melezhik joined
[07:35] <melezhik> .

[09:44] *** melezhik left
[11:13] *** Pixi joined
[11:16] *** ShimmerFairy joined
[13:55] <[Coke]> rakubrew build head. rakubrew build-zef. zef install --verbose Inline::Perl5

[13:56] <[Coke]> "rakubrew build moar 6f557f1ec; rakubrew switch moar-6f557f1ec; rakubrew build-zef; zef install --verbose Inline::Perl5"

[13:56] <[Coke]> This is perl 5, version 40, subversion 2 (v5.40.2) built for darwin-thread-multi-2level

[13:57] <[Coke]> ProductVersion:		15.6

[13:57] <[Coke]> BuildVersion:		24G84

[14:06] <[Coke]> I'll see if I can find the exact failing test for you

[14:08] <[Coke]> hurm. doing it with zef look instead, everything dies with "cannot locate native library"

[14:13] <[Coke]> https://github.com/niner/Inline-Perl5/blob/master/t/v6.t but it looks like that will be a little challenging to try to golf that.

[14:29] <[Coke]> https://gist.github.com/coke/9efc8f083eb6aeb717d32b607d4b7731 is the full trace on the error, at least.

[14:30] <[Coke]> Let me know if folks think this is a release blocker.

[14:30] <[Coke]> I would vote yes since we've had it on two separate machines (despite the fact that those machines are both mine, they are very different. :)

[14:38] <[Coke]> I am OK with delaying the release to January to get this resolved and have us moving forward also - please raise any objects on that, also,

[14:41] <lizmat> confirmed error on MacOS

[14:41] *** librasteve_ joined
[14:41] <patrickb> [Coke]: rakubrew build moar-blead that is, correct?

[14:42] <lizmat> when doing zef install.  however, running the v6.t file separately in an Inline::Perl5 checkout passes all tests

[14:42] <[Coke]> I used the specific hash (see above)

[14:42] <[Coke]> lizmat: do we need an IP5 release?

[14:42] <lizmat> but it *does* happen if I first nuke .precomp

[14:42] <[Coke]> what if you use the last release tag instead of HEAD, i mean?

[14:44] <lizmat> [Coke]: added my stacktrace to your stack trace gist

[14:44] <timo> bisectable6: help

[14:44] <bisectable6> timo, Like this: bisectable6: old=2015.12 new=HEAD exit 1 if (^‚àû).grep({ last })[5] // 0 == 4 # See wiki for more examples: https://github.com/Raku/whateverable/wiki/Bisectable

[14:45] <timo> committable6: releases class Test { has str $.test; has str $.two }; say Test.new(:test("tada")).raku;

[14:46] <committable6> timo, https://gist.github.com/f6e63e0862a7ee94117e348e1344ca27

[14:48] <timo> bisectable6: good=2019.11 bad=2020.01 class Test { has str $.test; has str $.two }; say Test.new(:test("tada")).raku;

[14:48] <bisectable6> timo, Bisecting by exit code (old=2019.11 new=2020.01). Old exit code: 0

[14:49] <patrickb> I believe this is an issue with the var-args changes related to unions 

[14:49] <lizmat> note this only happens on precomp

[14:49] <lizmat> a second run without nuking precomp, passes

[14:51] <timo> [Coke]: if something fails in "zef look" but not outside, check the environment variables inside and outside; could be related to how zef spawns the shell

[14:52] *** bisectable6 left
[14:54] <[Coke]> yup, I assume especially on macos with strict "where are my libraries" rules. I'm not going to make it work to get the same failure INSIDE zef look though, when it fails from the normal command line.

[14:56] <lizmat> patrickb timo looks like the issue is spesh related: can't get it to fail with:  rm -rf .precomp; MVM_SPESH_DISABLE=1 raku -I. t/v6.t

[14:58] <timo> were we on the way to throwing out dyncall in favor of libffi?

[15:00] <releasable6> Next release in ‚âà4 days and ‚âà3 hours. There are no known blockers. Please log your changes in the ChangeLog: https://github.com/rakudo/rakudo/wiki/ChangeLog-Draft

[15:01] <lizmat> patrickb timo none of the other MVM_SPESH...DISABLE options let it passs

[15:02] <lizmat> only MVM_SPESH_DISABLE=1 allows the code to run without errors

[15:02] <lizmat> all others generate: Internal error: unhandled dyncall argument type 0  processing int argument 0 in MVM_nativecall_dispatch

[15:02] <lizmat> note that I'm running this on Apple silicon, so not JITting

[15:04] <timo> argument type 0 is "void"

[15:04] <timo> how does that get in there, i wonder

[15:05] *** bisectable6 joined
[15:06] <lizmat> another data point: if I "dd" all of the arguments before the p5_call_function, it also always passes

[15:06] <timo> does the spesh bisect tool still work?

[15:07] <lizmat> if I just put the arguments in an array, it does *not* pass

[15:08] <lizmat> if I create a sub foo(*@a) { }, and put all of the arguments as arguments to a call to "foo", it passes

[15:10] <lizmat> the plot thickens: if I specifically initialize the native int32 variables ($retvals, $err, $type), it passes

[15:10] <timo> spesh bisect lives in moarvm's tools folder

[15:10] <timo> though it probably will just point at the exact function we also see in the stack trace

[15:11] <lizmat> ok, it looks like "int $retvals" is the only one that needs initialization

[15:11] <lizmat>  method call-simple-args(Str $function, **@args) {

[15:11] <lizmat> -    my int32 $retvals;

[15:11] <lizmat> +    my int32 $retvals = 0;

[15:12] <lizmat> fixes all testing for Inline::Perl5

[15:13] <timo> does it still say "processing int argument 0"?

[15:14] <lizmat> no, all tests pass

[15:15] <lizmat> another fix is apparently moving the definition of "my int32 $retvals" **after**the definition of "my Int $j = 0"

[15:16] <lizmat> so it feels like a combination fg

[15:16] <lizmat> of allocation of native ints

[15:17] <timo> could also be related to how argument passing in dispatchers works

[15:18] <lizmat> with this change:

[15:18] <lizmat> -    my Int $j = 0;

[15:18] <lizmat> +    my Int $j is default(0);

[15:18] <lizmat> I get a flapper: 

[15:19] <lizmat> most of the time, the v6.t test file passes, when it doesn't:

[15:19] <[Coke]> Wonder why the PTY work would trigger this. :|

[15:19] <lizmat> MoarVM oops: Internal error: unhandled dyncall argument type for str 50

[15:19] <lizmat> Internal error: unhandled dyncall argument type 0  processing int argument 0 in MVM_nativecall_dispatch

[15:20] <lizmat> [Coke]: it's related to spesh, as the problem goes away if spesh is disabled

[15:20] <timo> could you set a breakpoint in a debugger for me, or alternatively put some debug output in your moarvm?

[15:20] <timo> src/core/nativecall.c:228

[15:21] <timo> it has the comment "should never be reached", but it's potentially where our 0 comes from

[15:21] <lizmat> [Coke]: could be that the PTY work changed some subtle timings, which uncovered a gremlin

[15:22] <[Coke]> (timings) ahhh

[15:22] <lizmat> timo: what would you like me to put there ?

[15:23] <timo> sorry, i think i looked wrong, that is actually unreachable code, right?

[15:25] <patrickb> determine type from arg should only be called in the var arg case.

[15:25] <patrickb> inline p5 doesn't do that.

[15:25] <timo> dyncall argument type 50 is not assigned to any meaning

[15:26] <lizmat> yeah, looks unreachable to me

[15:27] <patrickb> so this is memory corruption related?

[15:28] <[Coke]> it was type 42 when I saw it.

[15:29] <patrickb> we've seen 42, 50 and 0

[15:30] * lizmat repeats: it is spesh related

[15:30] <lizmat> perhaps spesh isn't sufficiently aware of the varargs changes ?

[15:30] <lizmat> or PTY changes ?

[15:30] <timo> these values come from inside the NativeCallBody

[15:31] * patrickb looks at the var-args PR again

[15:31] <timo> the serialize and deserialize code doesn't look wrong, but that could be one way how a wrong value could sneak in that would only show up if you first nuke precomp?

[15:31] <timo> actually, not sure if we go through serialize and deserialize if we freshly pre-comp to run it, vs if we just load stuff

[15:33] *** Pixi` joined
[15:34] <timo> liz, can you break on the oops or the MVM_exception_throw_adhoc and print out what the "body" from MVM_nativecall_dispatch has inside it? also the "args"

[15:35] *** Pixi left
[15:35] <patrickb> timo: yes there is intent to nuke dyncall. That currently blocks on getting libffi compilable on Windows (probably me who's gonna do that).

[15:36] <timo> patrickb: do you have any way to repro the issue liz and coke are seeing? you don't have a mac i assume?

[15:36] <patrickb> I reproed the issue on Linux.

[15:37] <lizmat> I'm in the middle of writing a advent post for tomorrow

[15:37] <patrickb> rakubrew build moar-blead;rakubrew switch moar-blead;rakubrew build-zef;zef install --verbose Inline::Perl5

[15:37] <patrickb> that's possibly golfable

[15:38] <patrickb> timo: There is the Mac stadium Mac that you also have access to iirc.

[15:39] <timo> right, I haven't tried that in a while

[15:40] <timo> Segmentation fault         (core dumped) rakudo -I . t/v6.t

[15:40] <timo> :D

[15:44] <timo> the segfault i had was inside a block guarded by "if (body->variadic)" when doing a native call dispatch inside call-simple-args

[15:45] <timo> oh, actually, that may have been using an older precomp

[15:45] <timo> patrickb: did you bump the serialization version when you added the variadic flag to nativecall body's serialization?

[15:45] <patrickb> no

[15:46] <lizmat> oooh... that could be an easy fix then?

[15:46] <patrickb> I didn't realize.

[15:46] <patrickb> Could that cause this behavior?

[15:46] <timo> it can only give us trouble if we accidentally load a serialized precomp belonging to a pre-variadic merge

[15:47] <timo> how would we have that, but not rebuild the precomps anyway because of a newer rakudo?

[15:47] <patrickb> Which is not the case in most of the tests I performed.

[15:47] <timo> in my case, it's probably from not running Configure.pl often enough to regenerate version information?

[15:47] <timo> yeah, you all built stuff completely fresh

[15:48] <timo> i couldn't get the segfault again, either

[15:48] <patrickb> Is there any point in bumping the version now (given that we've had unrelated commits in the meantime).

[15:50] <lizmat> perhaps would be wise to do anyway?   at least to eliminate a possible cause ?

[15:50] <timo> it feels cleaner to do the bump, and have the read and write of "variadic" be dependent on the version in use

[15:51] <timo> but i'm not sure if it's possible for us or anyone in the wild to actually run into that problem?

[15:51] <timo> anyway i have a segfault now that i can properly look at because this time i recorded it

[15:51] <timo> (and i'm using libffi)

[15:51] <patrickb> I'll have a look at the version bump thing. At least I'll learn what I missed last time.

[15:53] <timo> we have two versions, one for bytecode and one for serialization

[15:53] <timo> you'll want the serialization one, it's like in the 40s or so at the moment

[15:59] <timo> my tools are giving me a bit of trouble right now

[16:05] <disbot6> <melezhik.> FWIW we can build Rakudo head in brownie and run Inline::Perl5 tests on it

[16:06] <disbot6> <melezhik.> http://brw.sparrowhub.io/project/brw-orch

[16:06] <timo> it doesn't crash reliably on my end either

[16:08] <patrickb> timo: I'm interested, how do you try to approach this? dd?

[16:09] <timo> do you know rr?

[16:09] <patrickb> s/dd/rr/

[16:09] <patrickb> so, yeah

[16:09] <timo> hehe.

[16:09] <timo> there is also ddd

[16:09] <timo> but there is not rrr

[16:10] <timo> it's so annoying when i rebuild moar with -O1 and i still get boatloads of "<optimized out>" when trying to print stuff

[16:10] <patrickb> isn't ddd a pretty ancient graphical gdb frontend?

[16:10] <timo> yup

[16:10] <timo> i'm not sure any other program really tried to replicate its "make a navigatable graph of memory" feature

[16:15] <timo> ok, so, i'm ending up in a block with `if (body->variadic) { ... }` around it, but near the start of the function when get_nc_body runs i print *body and its variadic is actually 0

[16:16] *** finanalyst joined
[16:23] <patrickb> I have some time available in about 3 hours. I'll try to join the fun then.

[16:26] <patrickb> So there is some memory corruption going on. Is there any chance to rule out GC?

[16:30] <lizmat> patrickb: did you seem my workarounds for the issue ?

[16:33] <patrickb> lizmat: turning of spesh you mean?

[16:33] <lizmat> well, that's one way

[16:33] <lizmat> the others are:

[16:33] *** Pixi` left
[16:33] <lizmat> -    my Int $j = 0;

[16:33] <lizmat> +    my Int $j is default(0);

[16:34] <lizmat> in Inline::Perl5, "call-simple-args"

[16:34] <patrickb> what we know up to now: needs precomp, needs spesh, does corrupt nc body. Depends on how it's called.

[16:35] <lizmat> another fix is apparently moving the definition of "my int32 $retvals" **after**the definition of "my Int $j = 0"

[16:35] <lizmat> -    my int32 $retvals;

[16:35] <lizmat> +    my int32 $retvals = 0;

[16:35] <lizmat> and that was the final fix I found

[16:36] <lizmat> s/fix/workaround

[16:36] <patrickb> I think changing the code to hopefully not trigger this anymore is losing our chance to find and fix this (even though I'm unsure if we'll be able to pull this off.)

[16:36] <timo> that would surely shuffle some stuff around, which could potentially just mask the issue

[16:36] <lizmat> well, my point was that perhaps the way this shuffles could point at a cause

[16:36] <timo> to be fair, this is not the right thing to be doing when you have a bad headache already :)

[16:36] <patrickb> I'm afk for now, but I'll report back later.

[16:39] *** Pixi joined
[16:44] <timo> i'll plop my recording into pernosco

[16:47] <timo> it'll take a moment to ingest

[16:49] <timo> there it is

[16:53] <timo> ah

[16:53] <timo> we used to take all relevant information out of the nativecall body before calling anything of consequence

[16:54] <timo> so we didn't bother making sure we update the pointer after a GC run

[16:54] <timo> but that wasn't made clear in the code at all

[16:55] <timo> looks like there's another bug there too that we haven't hit yet

[16:56] <timo> well, at least in the libffi based code i'm looking at right now

[16:57] <timo> the MVM_NATIVECALL_ARG_CPPSTRUCT case of argument passing can call MVM_nativecall_make_cppstruct which allocates, and after that, "body" is potentially no longer valid

[16:58] <timo> and then if there's a MVM_NATIVECALL_ARG_CALLBACK after that, we read the body->arg_info array from there

[17:00] <patrickb> Whoop! Thank you so much for digging into this 

[17:01] <timo> this isn't the problem that coke and liz see though i think

[17:08] <timo> well, it is possible that it is

[17:14] <timo> https://github.com/MoarVM/MoarVM/pull/1976 is the pull request with what I assume is the fix

[17:17] <timo> i'm sorry i wasn't available to do a thorough code review of your branch for the merge, i might have spotted it back then

[17:21] <timo> lizmat, [Coke], can you build your moarvm with this pull request?

[17:25] <timo> i seem to recall i started building something to make the missing-root-finding gcc plugin usable again by grabbing an old-enough gcc in a container ... i wonder if it could have spotted that the body pointer goes into an object that can move

[17:33] <lizmat> timo: so, this PR would be a fix for other potential issues, right?

[17:35] <timo> yeah, i'm not sure exactly how it could be responsible for what you're seeing

[17:38] <timo> i can't reproduce the same issue on my end

[17:42] <timo> i also missed adding an MVMROOT around the case where we may create a struct object

[17:44] * lizmat just decided to restart a different advent blog post because not being able to find the right tone for the current approach

[17:51] <[Coke]> timo: testing on my mac...

[17:53] <[Coke]> ooh, can use rakubrew triple for this. neat

[17:53] <timo> useful

[18:11] <timo> patrickb: did you look at src/spesh/disp.c at all for the vararg changes? there's a function "translate_dispatch_program" that handles native calls that may need changes. could be as simple as detecting the unsupported new thing and bailing out, there's at least one example of that if you search for MVM_spesh_graph_add_comment

[18:11] <timo> it handles, among many other things, native calls, i should say

[18:15] <timo> could be at that point anything related to vararg support isn't relevant any more, or not yet

[18:20] <timo> > Label followed by a declaration is a C23 extensionclang(-Wc23-extensions)

[18:20] <timo> could this be related to the procops.c compilation failures?

[18:21] <timo> src/io/procops.c:1018:9: error: expected expression

[18:21] <timo>         MVMObject *msg_box = NULL;

[18:30] * [Coke] heh: rakubrew switch moar-HEAD-HEAD-nativecall_beware_the_moving_pointer

[18:45] <timo> t/09-moar/Line_Break__LineBreak.t is passing TODOs and t/04-nativecall/02-simple-args.t is failing its test number 14, that's not so good ...

[18:46] <timo> is that just because the rakudo we're using to CI moarvm is very latest, and so is the nqp? and we didn't update the tests yet to account for the bump we would do?

[18:46] <lizmat> is the reason why the test is TODOd clear ?

[18:47] <lizmat> some tests have been TODOed because they depend on the optimizer, and since RakUAST doesn't have one yet, they were failing there

[18:47] <[Coke]> timo: with your branch, I can now install Inline::Perl5 on my  mac

[18:49] <timo> huh, so it really was this? that's *weird* tho

[18:51] <lizmat> *phew*

[18:51] <timo> "# Many codepoints return XX instead of ID. These codepoints are undefined, but unicode spec has specified that they should regardless be ID" from t/09-moar/UnipropCheck.rakumod

[18:53] <timo> i don't get this test :)

[18:54] <timo> ah, my local rakudo was also rather out of date

[19:01] <timo> https://dev.azure.com/MoarVM/MoarVM/_build/results?buildId=1972&view=logs&j=f93ca9ca-039a-53b4-e82f-2e79ce75da29&t=335d2d98-9ead-510c-fd20-52aaaddd795d&l=4770 here's a link to the LineBreak property test failing in azure

[19:04] <timo> > ok 106 - postfix hyper primes properly # TODO ensure that hyper operators prime as expected

[19:04] <timo> not sure that's one of the tests that depended on the optimizer?

[19:06] <timo> it's "ok" with both rakudo_rakuast set to 0 and 1, but in one of the cases it's todo'd (wrongly)

[19:06] <lizmat> perhaps ShimmerFairy has an idea

[19:08] <timo> oh, unexpectedly passed TODO don't make the CI red

[19:08] <patrickb> the msg_box failure can be fixed by simply adding a ; to the label line

[19:08] <timo> is the change i made that moves the label in front of the "if" statement also correct?

[19:08] <timo> i looked and every place that goto's that label also sets the variable that the if checks

[19:09] * patrickb looks

[19:10] <timo> also, can you look at why the nativecall tests fail on some variants? for example https://dev.azure.com/MoarVM/MoarVM/_build/results?buildId=1972&view=logs&j=41df3ac0-0edd-50cb-472a-a040ecae8d09&t=20a8b084-395a-5811-0839-4acd1e8c4be7&l=2154 here

[19:11] <timo> .o( also, the real test will happen when I build debian packages of the latest )

[19:24] <timo> the failures are only on clang, not on gcc?

[19:25] <timo> only on clang and dyncall, not clang and libffi

[19:37] *** finanalyst left
[19:38] <timo> i think i see it

[19:38] <timo> well, i see *something*

[19:39] <timo> https://godbolt.org/z/EnajheTMW gcc compares the constant we're interested in with the contents of the dil register, aka the lowest 8 bits of edi, while clang compares the full edi register

[19:40] <lizmat> oof...  subtle!

[19:40] <timo> could be we're only setting the lowest 8 bits of the register from our side and leaving some trash in the upper bits?

[19:41] <timo> > ok 15 - # SKIP Cannot test TakeUint16(0xFFFE) with clang without -O0

[19:41] <timo> presumably this is similar?

[19:49] <timo> oh

[19:50] <timo> $dil and $edi both contain "-2", meaning $edi is 0xfffffffe and $dil is 0xfe

[19:51] <timo> so guess why in the clang compiled code `cmp edi, 254` doesn't work how we expect it

[19:57] <timo> https://gitlab.com/x86-psABIs/x86-64-ABI/-/commit/e1ce098331da5dbd66e1ffc74162380bcc213236 and https://github.com/llvm/llvm-project/issues/12579 seem related

[19:59] <timo> https://groups.google.com/g/x86-64-abi/c/h7FFh30oS3s/m/NDV4lCRQAQAJ

[20:00] <timo> i believe this is not just for 8 bit but also 16 bit values

[20:02] <timo> https://github.com/rakudo/rakudo/issues/1619#issuecomment-377443272 kaiepi already analyzed this long ago

[20:03] <lizmat> oO( kaiepi still being missed  :-(  )

[20:03] <timo> quite :(

[20:07] <timo> patrickb: in any case, feel free to not be bothered too much by this particular issue ... unless you have a good idea for how we should behave in light of this mess

[20:21] *** librasteve_ left
[20:23] <patrickb> I think I don't fully understand the issue yet. There are multiple registers referring to the same data, but with different sizes?

[20:24] <patrickb> And clang confuses the sizes?

[20:25] <patrickb> edi 32 bits, dil 8bits. but dil == lowest 8 bits of edi?

[20:29] <timo> yeah, you can refer to different-sized versions of the same register by different names

[20:29] <timo> actually, libffi has a uchar argument type, maybe that is exactly what we need

[20:30] <timo> explaining why it's broken on dyncall but works on libffi?

[20:30] <timo> presumably ffi_type_uchar causes the right kind of extension to give clang what it wants?

[20:32] <patrickb> Is this issue actually about call conventions?

[20:32] <timo> yes

[20:32] <timo> clang wishes that the calling convention is "the caller extends the register"

[20:32] <timo> the calling convention says "undefined. if you look at the bits outside of the defined type, you can keep the pieces"

[20:33] <patrickb> So edi is 32 bits. But we only write 8 bits.

[20:33] <patrickb> Understood. Okay. And clang typically works out, because it creates its own calls.

[20:34] <patrickb> But now that we're using a ffi lib we want to play in it's park.

[20:34] <patrickb> I guess we have to play by it's rules then.

[20:35] <patrickb> And libffi already does what's needed. That's also why most projects don't hit this issue.

[20:35] <timo> https://bugs.llvm.org/show_bug.cgi?id=44228#c4 - one word from LLVM about it, and the groups.google.com link above has a rebuttal or so

[20:36] <patrickb> I guess given we plan to move to libffi exclusively Soon‚Ñ¢Ô∏è, we can just punt on this issue?

[20:47] <timo> presumably values below 127 can be compared against fine, so we can pass two different values and if one of them gives the expected result, we can at least display a hint next to the failed test

[21:15] <patrickb> Could we just fix up dyncall by up casting manually?

[21:16] <patrickb> Actually I recall Tassilo (one of the dyncall devs) telling me, that it's part of the library contract, that the user up casts stuff. And that the documentation is lacking in that regard.

[21:29] *** lucs_ is now known as lucs

[21:35] <patrickb> I've looked it up again. That info was about varargs only.

[21:35] <timo> ah, yeah, varargs are special yet again

[21:36] <patrickb> Still, if full int width is passed in every case anyways, can't we just null out the full width by default when we are on clang?

[21:37] <timo> it isn't about whether we are on clang, since a moar compiled with gcc may encounter libraries compiled with clang and vice versa

[21:39] <ab5tract> patrickb: do you have an example for reproducing R#6038 ?

[21:39] <linkable6> R#6038 [open]: https://github.com/rakudo/rakudo/pull/6038 RakuAST: Default unnamed packages to `my` scope instead of `our`

[21:39] <ab5tract> If you have one handy, I wanted to try adding `anon` to `RakuAST::Package.allowed-scopes`

[21:39] <timo> if we just always pass a 32bit integer or bigger, we can run afoul of ABIs on other targets behaving differently

[21:43] <timo> also, i haven't checked but i assume when passing arguments via the stack once you run out of registers, it's different yet again

[21:45] <timo> and if we put a check "is it going to be in a register or on the stack" before choosing whether to use dcArgChar / dcArgShort or upgrade to dcArgInt, then we're re-inventing half of dyncall inside of the code where we use dyncall

[21:46] <timo> are we still on a very old fork of dyncall? does dyncall maybe have UChar vs Char now?

[21:48] <timo> ok, on the website i don't see an indication of signed/unsigned differences

[21:49] <patrickb> timo: Do you know whether the C standard dictates that the size passed is always an int? (But the higher bits may contain undefined garbage.) I might be naive, but if so, then it should be fine to always pass nulled out higher bits.

[21:50] <patrickb> ab5tract: It's the first error that shows up when you try to run zef

[21:54] <timo> AIUI the C standard doesn't cover that, the system "vendor" has to come up with the ABI that the compiler writers and others then have to adhere to

[21:55] <ab5tract> patrickb: ah of course

[21:57] <ab5tract> ... I'm pretty sure I just installed zef with `RAKUDO_RAKUAST=1`

[21:58] <ab5tract> patrickb: seems that adding `anon` to `RakuAST::Package.allowed-scopes` does indeed fix things

[21:59] <ab5tract> after checking out to your PR, I mean

[21:59] <timo> oh, that's nice

[21:59] <ab5tract> This actually unlocks blin/brownie :D

[22:02] <ab5tract> I'm not currently keeping great track of what fails for `main`RakuAST, so there might be some fallout for roast

[22:38] <patrickb> ab5tract: What?! You managed to install zef with RakuAST? I worked myself around three seemingly separate issues and no end in sight and you just managed to make it work with that one change? üòÆ That's pretty great and impressive!

[22:38] <patrickb> üéâ

[22:38] <ab5tract> patrickb: well I did it on the top of your PR branch :D

[22:38] <ab5tract> It's more the last missing piece of the puzzle, I would say

[22:39] <patrickb> That also unblocks me to continue working on #5060, which was my original goal.

[22:45] <ab5tract> A most pleasing turn of events :)

[22:46] <ab5tract> patrickb: do double check the roast tho, I think I only saw repeat offenders but I don't have a main spectest log to compare to right now

[22:47] * ab5tract disappears for the night

[22:47] <timo> gnite!

[22:55] * patrickb logs off as well

[22:56] <patrickb> Have a good night everyone! And thanks timo and ab5tract for your incredible work!

[22:56] <japhb> o/

[23:01] <timo> \o/

[23:15] <lizmat> unless someone tells me not to, I will merge https://github.com/MoarVM/MoarVM/pull/1976 tomorrow, to fix Inline::Perl5's test breakage

[23:15] <lizmat> [Coke] timo patrickb ab5tract  ^^

[23:16] <lizmat> but first some shuteye&

[23:28] * timo nibbles at some bytes

[23:30] <japhb> nybbles?

[23:30] <japhb> :-)

[23:32] <timo> that's right

[23:36] <timo> m: say "core c setting from 30016592 to 28888256. abs diff ", (30016592 - 28888256), " pct ", (28888256 * 100 / 30016592);

[23:36] <camelia> rakudo-moar 6b47541e2: OUTPUT: ¬´core c setting from 30016592 to 28888256. abs diff 1128336 pct 96.240959‚ê§¬ª

[23:37] <timo> found one field that's wasting a lot of space that's not so hard to reduce

[23:38] <timo> i think i can get another half megabyte but it's more stubborn than i thought

