[07:23] <ab5tract> use v6.*; %*ENV<RAKUDO_RAKUAST = 1; my class A { has $.a where { $_ > 0 } }

[07:23] <ab5tract> m: use v6.*; %*ENV<RAKUDO_RAKUAST = 1; my class A { has $.a where { $_ > 0 } }

[07:23] <camelia> rakudo-moar 47746a84e: OUTPUT: «===SORRY!=== Error while compiling <tmp>␤Two terms in a row␤at <tmp>:1␤------> T = 1; my class A { has $.a where { $_ ><HERE> 0 } }␤    expecting any of:␤        infix␤        infix stopper␤        statement end␤        statement modif…»

[07:23] <ab5tract> m: use v6.*; %*ENV<RAKUDO_RAKUAST> = 1; my class A { has $.a where { $_ > 0 } }

[07:23] <camelia> rakudo-moar 47746a84e: OUTPUT: «===SORRY!===␤Cannot resolve caller infix:«>»(Mu:U, Int:D); none of these signatures matches:␤    ( --> Bool::True)␤    ($ --> Bool::True)␤    (\a, \b)␤    (Real $a, Real $b)␤    (Int:D $a, Int:D $b --> Bool)␤    (int $a, int $b --> Boo…»

[07:24] <ab5tract> m: use v6.*; %*ENV<RAKUDO_RAKUAST> = 1; class A { has $.a where { $_ > 0 } }

[07:24] <camelia> rakudo-moar 47746a84e: OUTPUT: «===SORRY!===␤Cannot resolve caller infix:«>»(Mu:U, Int:D); none of these signatures matches:␤    ( --> Bool::True)␤    ($ --> Bool::True)␤    (\a, \b)␤    (Real $a, Real $b)␤    (Int:D $a, Int:D $b --> Bool)␤    (int $a, int $b --> Boo…»

[07:25] <ab5tract> Oh, sorry, thought I was still in a chat with camelia

[07:56] <ab5tract> Is there a roast test that is failing for this? Because it seems really wild that there aren’t at least a dozen test files that use where clauses to some degree

[08:07] <lizmat> there are more than 1000 matches for the word "where" in roast

[08:14] <ab5tract> Thanks (I am glad I didn’t bring my laptop on vacation but I do feel a bit helpless)

[08:15] <ab5tract> m: use v6.*; subset A where * > 0; my class C { has A $.a }; C.new: :a(7)

[08:15] <camelia> rakudo-moar 47746a84e: OUTPUT: «Use of uninitialized value of type Any in numeric context␤  in any multi_declarator:sym<null> at /home/camelia/rakudo-m-inst-2/share/perl6/lib/Perl6/Grammar.moarvm line 1␤===SORRY!=== Error while compiling <tmp>␤Attribute definition of type A (i…»

[08:15] <ab5tract> lizmat: I thought that use v6.* would use the new grammar, but this seems to go through the old one?

[08:17] <ab5tract> Oh, it mentions line 1 of the old grammar. If I check that I imagine it’s a conditional call into the new grammar

[08:17] <lizmat> use v6.* just activates the existence of the RakuAST classes

[08:18] <lizmat> the actual grammar is chosen in src/main.nqp

[08:24] <ab5tract> Gotcha, thanks

[08:24] <ab5tract> When we release it, though, it will use the new grammar, right?

[08:30] <ab5tract> m:  Q|subset A where * > 0; my class C { has A $.a }; C.new(:a(7))|.AST.EVAL

[08:30] <camelia> rakudo-moar 47746a84e: OUTPUT: «===SORRY!===␤Unknown compilation input 'qast'␤»

[08:30] <ab5tract> :(

[08:33] <ab5tract> So I’m not sure what is the point of testing with v6.* if the current semantics of it are not going to match the semantics we are going to ship

[09:00] <ab5tract> m:  use v6.d; subset A where * > 0; my class C { has A $.a }; dd C.new(:a(7))

[09:00] <camelia> rakudo-moar 47746a84e: OUTPUT: «C.new(a => 7)␤»

[09:03] <ab5tract> m:  use v6.e.PREVIEW; subset A where * > 0; my class C { has A $.a }; dd C.new(:a(7))

[09:03] <camelia> rakudo-moar 47746a84e: OUTPUT: «Use of uninitialized value of type Any in numeric context␤  in any multi_declarator:sym<null> at /home/camelia/rakudo-m-inst-2/share/perl6/lib/Perl6/Grammar.moarvm line 1␤===SORRY!=== Error while compiling <tmp>␤Attribute definition of type A (i…»

[09:03] <lizmat> yes

[09:04] <ab5tract> Does the code snippet fail with RAKUDO_RAKUST=1?

[09:05] <ab5tract> Probably it does, as the eval is barfing

[11:37] *** [Tux] left
[12:05] *** [Tux] joined
[15:19] *** coleman left
[15:21] *** coleman joined
[17:54] <librasteve_> https://rakudoweekly.blog/2025/09/29/2025-39-inversion-of-control/

[18:11] <ab5tract> librasteve_++

[18:16] <Geth> ¦ rakudo/presize-slurps: eefa17d3e5 | ab5tract++ (committed using GitHub Web editor) | src/core.c/IO/Path.rakumod

[18:16] <Geth> ¦ rakudo/presize-slurps: Migrate to infix max

[18:16] <Geth> ¦ rakudo/presize-slurps: 

[18:16] <Geth> ¦ rakudo/presize-slurps: The infix form is quite a bit faster than the prefix one.

[18:16] <Geth> ¦ rakudo/presize-slurps: review: https://github.com/rakudo/rakudo/commit/eefa17d3e5

[18:30] <ab5tract> lizmat

[18:31] <lizmat> librasteve_++

[18:31] <ab5tract> lizmat: so it turns out that those v6.* snippets *also* fail under RAKUDO_RAKUAST=1 .. but if the the use v6.* statement is removed entirely, things work as planned

[18:31] <ab5tract> https://github.com/rakudo/rakudo/issues/5910#issuecomment-3348463746

[18:33] <lizmat> ab5tract: but that's because they're in 6.d, no?

[18:35] <lizmat> so maybe it's because of the PseudoStash handling in 6.e being different?

[18:35] <ab5tract> huh, so there have been semantic changes on the way to 6.e that are un-related to RakuAST and are also versioned

[18:35] <ab5tract> that makes  a lot of sense actually

[18:35] <lizmat> vrurg did a lot of work on 6.e PseudoStashes 

[18:38] <ab5tract> I did notice that while working on that last ticket. The new stuff is much easier to read.

[19:22] <Geth> ¦ rakudo/main: 5147b67f7a | ab5tract++ | src/core.e/PseudoStash.rakumod

[19:22] <Geth> ¦ rakudo/main: 6.e - Fix overly permissive lookup into CALLER

[19:22] <Geth> ¦ rakudo/main: 

[19:22] <Geth> ¦ rakudo/main: The new PsuedoStash code was a joy to work with,

[19:22] <Geth> ¦ rakudo/main: even including a comment that easily led me to the

[19:22] <Geth> ¦ rakudo/main: solution: the modes can be combined.

[19:22] <Geth> ¦ rakudo/main: 

[19:22] <Geth> ¦ rakudo/main: This fixes R#5910 (#5910)

[19:22] <Geth> ¦ rakudo/main: review: https://github.com/rakudo/rakudo/commit/5147b67f7a

[19:22] <linkable6> R#5910 [open]: https://github.com/rakudo/rakudo/issues/5910 [6.e][RAKUDO_RAKUAST=1] `$CALLER::foo` allows access to caller's `my $foo` in 6.e

[19:31] <Geth> ¦ rakudo: ab5tract self-assigned `::('Exception').gist` throws in v6.e.PREVIEW https://github.com/rakudo/rakudo/issues/5911

[20:06] <ab5tract> That one appears to be finished :D

[20:07] <ab5tract> so it looks to be like the change in behavior in R#5915 is actually intentional

[20:07] <linkable6> R#5915 [open]: https://github.com/rakudo/rakudo/issues/5915 [6.e][RAKUDO_RAKUAST=1] `my class A { has $.a where * > 0 }` does not compile in 6.e

[21:23] <Geth> ¦ rakudo/presize-slurps: cd08d14644 | ab5tract++ (committed using GitHub Web editor) | src/core.c/IO/Path.rakumod

[21:23] <Geth> ¦ rakudo/presize-slurps: Actually migrate to infix max

[21:23] <Geth> ¦ rakudo/presize-slurps: 

[21:23] <Geth> ¦ rakudo/presize-slurps: Last attempt was not quite what we needed.

[21:23] <Geth> ¦ rakudo/presize-slurps: review: https://github.com/rakudo/rakudo/commit/cd08d14644

[21:51] <Geth> ¦ rakudo/r5915-attr-where: 1038788097 | ab5tract++ | src/Raku/ast/code.rakumod

[21:51] <Geth> ¦ rakudo/r5915-attr-where: v6.e - Attributes with where clause must have initializers

[21:51] <Geth> ¦ rakudo/r5915-attr-where: 

[21:51] <Geth> ¦ rakudo/r5915-attr-where: Issue #5915 shared this expression:

[21:51] <Geth> ¦ rakudo/r5915-attr-where: 

[21:51] <Geth> ¦ rakudo/r5915-attr-where: ```

[21:51] <Geth> ¦ rakudo/r5915-attr-where: use v6.*; my class A { has $.a where * > 0 }

[21:51] <Geth> ¦ rakudo/r5915-attr-where: ```

[21:51] <Geth> ¦ rakudo/r5915-attr-where: <…commit message has 10 more lines…>

[21:51] <Geth> ¦ rakudo/r5915-attr-where: review: https://github.com/rakudo/rakudo/commit/1038788097

[21:51] <Geth> ¦ rakudo: ab5tract++ created pull request #5964: v6.e - Attributes with where clause must have initializers

[21:51] <Geth> ¦ rakudo: review: https://github.com/rakudo/rakudo/pull/5964

