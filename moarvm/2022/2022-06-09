[00:07] *** reportable6 left
[00:09] *** reportable6 joined
[02:59] *** frost joined
[03:59] *** greppable6 left
[03:59] *** linkable6 left
[03:59] *** shareable6 left
[03:59] *** nativecallable6 left
[03:59] *** reportable6 left
[03:59] *** committable6 left
[03:59] *** quotable6 left
[03:59] *** unicodable6 left
[03:59] *** benchable6 left
[03:59] *** notable6 left
[03:59] *** coverable6 left
[03:59] *** releasable6 left
[03:59] *** statisfiable6 left
[03:59] *** tellable6 left
[03:59] *** bisectable6 left
[03:59] *** evalable6 left
[03:59] *** sourceable6 left
[03:59] *** bloatable6 left
[04:00] *** tellable6 joined
[04:00] *** coverable6 joined
[04:00] *** bloatable6 joined
[04:00] *** nativecallable6 joined
[04:00] *** reportable6 joined
[04:00] *** sourceable6 joined
[04:01] *** evalable6 joined
[04:01] *** shareable6 joined
[04:01] *** quotable6 joined
[04:01] *** linkable6 joined
[04:01] *** bisectable6 joined
[04:01] *** notable6 joined
[04:01] *** benchable6 joined
[04:01] *** unicodable6 joined
[04:01] *** greppable6 joined
[04:02] *** committable6 joined
[04:02] *** releasable6 joined
[04:02] *** statisfiable6 joined
[04:36] *** Kaiepi left
[05:36] *** shareable6 left
[05:36] *** evalable6 left
[05:36] *** tellable6 left
[05:36] *** greppable6 left
[05:36] *** unicodable6 left
[05:36] *** notable6 left
[05:36] *** linkable6 left
[05:36] *** committable6 left
[05:36] *** statisfiable6 left
[05:36] *** sourceable6 left
[05:36] *** bisectable6 left
[05:36] *** benchable6 left
[05:36] *** coverable6 left
[05:36] *** bloatable6 left
[05:36] *** releasable6 left
[05:36] *** reportable6 left
[05:36] *** nativecallable6 left
[05:36] *** quotable6 left
[05:36] *** reportable6 joined
[05:37] *** nativecallable6 joined
[05:37] *** shareable6 joined
[05:37] *** quotable6 joined
[05:37] *** tellable6 joined
[05:37] *** benchable6 joined
[05:37] *** bloatable6 joined
[05:38] *** statisfiable6 joined
[05:38] *** greppable6 joined
[05:38] *** bisectable6 joined
[05:38] *** releasable6 joined
[05:38] *** coverable6 joined
[05:38] *** linkable6 joined
[05:38] *** evalable6 joined
[05:38] *** unicodable6 joined
[05:39] *** sourceable6 joined
[05:39] *** committable6 joined
[05:39] *** notable6 joined
[06:06] *** reportable6 left
[06:06] <Nicholas> [* GOOD *]

[06:06] <Nicholas> (especially for ducks)

[06:07] *** reportable6 joined
[06:40] <Nicholas> https://blog.pyston.org/2022/06/08/announcing-pyston-lite-our-python-jit-as-an-extension-module/ -- not that I have an answer, but if you can install 80% of the benefits as a module, what's the business model?

[06:45] <moon-child> business model?  Afaik they made it mainly for their own use

[06:46] <nine> Looking at pyston.org, if they're trying to make money off this, they're not trying hard enough

[06:47] <Nicholas> IIRC.

[06:48] <Nicholas> (oops, I started too soon. I remembered a citation exists)

[06:49] <Nicholas> https://blog.pyston.org/2020/10/ -- Our plan is to open-source the code in the future, but since compiler projects are expensive and we no longer have benevolent corporate sponsorship, it is currently closed-source while we iron out our business model.

[06:49] <Nicholas> [time passes with no updates]

[06:49] <Nicholas> https://blog.pyston.org/2021/05/05/pyston-v2-2-faster-and-open-source/ -- what it says

[06:50] <Nicholas> (what it doesn't say is that Facebook revealed and open sourced Cinder about the same time.)

[06:50] <Nicholas> [time passes with no update]

[06:51] <Nicholas> https://blog.pyston.org/2021/08/30/pyston-team-joins-anaconda/ -- We talked to a couple of companies about a possible joint future for Pyston -- Now that we have Anacondaâ€™s sponsorship, we are planning out a short-term roadmap for the project.

[06:54] <Nicholas> I can't find the cittaion, but some cynic roughly defined "startup" as "a company in search of a business model"

[06:55] <Nicholas> anyway, the take away from the 3 blog posts (in sequence) is that the intent is to get paid to make python faster, which should pan out, because it saves enough money on hardware costs for some firms

[06:55] <Nicholas> s/some firms/sufficient firms/

[06:55] <Nicholas> to be viable

[06:56] <Nicholas> but trying to get enough of those firms to see it that way is much harder than actually the engineering task

[06:56] <Nicholas> (oops, grammar)

[06:57] <Nicholas> and similar funding problems seem to happen for all open source infrastructure projects

[07:03] <nine> The good news is that I got rid of almost all regressions caused by my BEGIN time execution work. The bad news is that I realized that my approach is flawed and cannot be the real solution.

[07:04] <Nicholas> but you still have coffee?

[07:07] <nine> I do. And an idea that might actually work.

[07:32] *** Kaiepi joined
[07:51] <lizmat> ++nine++

[08:18] *** linkable6 left
[08:20] *** linkable6 joined
[09:39] *** nativecallable6 left
[09:39] *** notable6 left
[09:39] *** tellable6 left
[09:39] *** releasable6 left
[09:39] *** benchable6 left
[09:39] *** linkable6 left
[09:39] *** unicodable6 left
[09:39] *** reportable6 left
[09:39] *** quotable6 left
[09:39] *** bisectable6 left
[09:39] *** committable6 left
[09:39] *** sourceable6 left
[09:39] *** shareable6 left
[09:39] *** evalable6 left
[09:39] *** bloatable6 left
[09:39] *** coverable6 left
[09:39] *** statisfiable6 left
[09:39] *** greppable6 left
[09:39] *** coverable6 joined
[09:39] *** sourceable6 joined
[09:40] *** nativecallable6 joined
[09:40] *** quotable6 joined
[09:40] *** linkable6 joined
[09:40] *** committable6 joined
[09:40] *** evalable6 joined
[09:40] *** greppable6 joined
[09:41] *** statisfiable6 joined
[09:41] *** reportable6 joined
[09:41] *** unicodable6 joined
[09:42] *** benchable6 joined
[09:42] *** shareable6 joined
[09:42] *** bloatable6 joined
[09:42] *** bisectable6 joined
[09:42] *** releasable6 joined
[09:42] *** notable6 joined
[09:42] *** tellable6 joined
[10:41] *** Geth__ joined
[10:41] *** lizmat_ joined
[10:42] *** Geth left
[10:43] *** lizmat left
[10:53] *** lizmat_ is now known as lizmat

[11:31] <timo> just replace your python code with starlark :P

[12:07] *** reportable6 left
[12:10] *** reportable6 joined
[12:12] <MasterDuke> wow. `my $OUT = $*OUT; $OUT.put("1") for ^1_000_000` takes ~0.34s, but `put("1") for ^1_000_000` takes ~1.30s, and `$*OUT.put("1") for ^1_000_000` takes ~1.26s

[12:19] <japhb> Yeah, dynamic variable lookup is still painfully slow.  I've gotten in the habit (where I need the performance) of doing I/O via objects that cache their intended IO::Handle's and use methods on those.

[12:21] <MasterDuke> all the dynamics lookups are the source of those stats i posted earlier. but i have no idea if there's an easy improvement

[12:29] <MasterDuke> i guess all the hash/cache misses are because they're dynamics being looked up, so i don't know what could be done

[12:49] <timo> can you trace back where these strings come from that don't have the string hash code cached?

[12:49] <timo> maybe they are for some reason created from concatenation or substringing over and over again

[12:50] <japhb> MasterDuke: The part I don't understand is how you got millions of cases of *both* hashed and not hashed.

[12:52] *** brrt joined
[12:52] <MasterDuke> japhb: to confuse things, i've both talked about the string having a hash code, and the existence of a hash used as a cache of lexical names. so not sure which exactly your question is about

[12:52] <japhb> The second one, sorry

[12:54] <MasterDuke> timo: 1000002 '$code' has no cached_hash_code, 1000005 'utf8' has no cached_hash_code, 1000006 '$*LIBPATH' has no cached_hash_code

[12:54] <MasterDuke> that's when running `put "1\n" for ^1_000_000`

[12:57] <MasterDuke> japhb: i guess it's because sometimes the variable is in a frame with enough lexicals to cause the hash/cache to be created?

[12:57] <MasterDuke> https://github.com/MoarVM/MoarVM/blob/master/src/core/bytecode.c#L647-L661

[13:00] <brrt> ohai #moarvm

[13:03] <Nicholas> good *, brrt

[13:03] <lizmat> brrt o/

[13:12] *** dogbert17 left
[13:19] <timo> inteesting, you wanna give changing that number to be lower a try and see how it impacts both run time and hashing details

[13:20] <timo> there's no reason not to calculate&cache hash codes for stuff we get from get_heap_string in that piece of code maybe

[13:21] <MasterDuke> you mean try fewer iterations of the loop?

[13:21] <timo> the "num_lexicals <= 5" number 

[13:21] <timo> just the one on line 656

[13:23] <timo> damn... what if there was an irc bot or something else where you could just say "apply s/foo/bar/ to moarvm file blah.c on line 1234, build a raku with it, then benchmark this snippet"

[13:23] <MasterDuke> ah, now just 1000005 'utf8' has no cached_hash_code (and the same other random much smaller cases)

[13:23] <timo> could you imagine

[13:23] <MasterDuke> didn't el_che show something like that?

[13:24] <timo> i dunno! maybe!

[13:24] <timo> was that long ago?

[13:24] <MasterDuke> year+ iirc

[13:25] <MasterDuke> fyi, i changed the 5 to 2

[13:26] <MasterDuke> with just that change, `put("1") for ^1_000_000` drops to ~1.24s

[13:31] <timo> i don't know what exact function you need to call if you want to ensure a string has a hash code

[13:32] <timo> but if you can find that, put the number back to 5, and then in an else branch to the piece that adds stuff into the hash, only create the hash code

[13:32] <timo> that may give the same improvement, perhaps even better

[13:33] <timo> also, maybe nicholas can tell us how good our new hash impl is when the hash has really few entries, and if there is perhaps an improvement to be had there

[13:33] <timo> and maybe even something for when you know the strings up front and that the hash shouldn't grow ever?

[13:34] * brrt is way out of date...

[13:35] <timo> now i have a very understanding of "got a job, can't do my favourite open source project any more"

[13:56] <MasterDuke> ah. i put the number back up to 5, but then added `if (!name->body.cached_hash_code) MVM_string_compute_hash_code(tc, name);` right after `MVMString *name = get_heap_string(tc, cu, NULL, pos, 6 * j + 2);` and now it's just `1000005 'utf8' has no cached_hash_code`

[13:57] <MasterDuke> `put("1") for ^1_000_000` looks to be just a tiny bit faster, maybe ~1.32s now

[14:08] *** brrt left
[14:16] *** brrt joined
[14:25] <brrt> timo: the thing is that open source projects don't start shouting at you, when you fail to make progress, whereas $dayjob-managers do

[14:33] *** frost left
[14:56] *** discord-raku-bot left
[14:56] *** discord-raku-bot joined
[15:06] *** brrt left
[15:14] *** discord-raku-bot left
[15:14] *** discord-raku-bot joined
[15:33] *** vrurg left
[15:55] *** vrurg joined
[17:04] *** Kaiepi left
[17:04] *** Kaiepi joined
[17:05] *** Kaiepi left
[17:05] *** Kaiepi joined
[18:08] *** reportable6 left
[18:10] *** reportable6 joined
[18:50] <nine> I can't imagine any company can afford to have even halfway decent software engineers get shouted at. Feels like the only thing one has to do to get a new and better job is to stop saying no to offers.

[18:52] *** dogbert17 joined
[18:57] <lizmat> agree

[18:59] <nine> Corollary is: realize how much power you actually have in your position and use it to stop any abuse right in its track, or just leave. There's just no reason to compromise there.

[19:34] *** Kaiepi left
[20:02] *** Kaiepi joined
[20:23] *** lizmat_ joined
[20:27] *** lizmat left
[20:39] *** linkable6 left
[20:42] *** linkable6 joined
[21:14] <nine> Finally! Got a working version of BEGIN time code execution without regressions, without totally messing up the compilation phases and with a code structure that I can live with. Passing 450 spec test files now

[21:15] <[Coke]> nine++

[21:16] <MasterDuke> nice

[21:29] *** MasterDuke left
[21:40] *** MasterDuke joined
[22:19] <japhb> Found a deadlock in my code that eventually boiled down to MVM_io_read_bytes and MVM_io_is_tty trying to lock the same (per-filehandle) mutex.  I can totally see *most* IO operations being mutexed per-filehandle for safety ... but does MVM_io_is_tty need that treatment?  Are there any OSen where checking whether an fd is a TTY is an operation that would mess with other IO?

[22:21] <japhb> (I introduced the deadlock by adding a debug assertion in my Raku code that wouldn't actually trigger during my test case, but included a .t on a filehandle already being .read in another thread -- so the assertion test itself triggered the deadlock.)

[22:27] *** Kaiepi left
[23:56] *** Kaiepi joined
