[00:03] *** Kaipei left
[00:03] *** Kaipei joined
[00:06] *** reportable6 left
[00:06] *** kjp left
[00:07] *** reportable6 joined
[01:11] *** frost joined
[02:12] *** greppable6 left
[02:12] *** nativecallable6 left
[02:12] *** sourceable6 left
[02:12] *** unicodable6 left
[02:12] *** notable6 left
[02:12] *** shareable6 left
[02:12] *** coverable6 left
[02:12] *** quotable6 left
[02:12] *** linkable6 left
[02:12] *** benchable6 left
[02:12] *** reportable6 left
[02:12] *** statisfiable6 left
[02:12] *** tellable6 left
[02:12] *** bloatable6 left
[02:12] *** evalable6 left
[02:12] *** committable6 left
[02:12] *** releasable6 left
[02:12] *** bisectable6 left
[02:12] *** evalable6 joined
[02:12] *** shareable6 joined
[02:12] *** reportable6 joined
[02:13] *** releasable6 joined
[02:13] *** bisectable6 joined
[02:13] *** benchable6 joined
[02:13] *** greppable6 joined
[02:13] *** linkable6 joined
[02:13] *** unicodable6 joined
[02:13] *** quotable6 joined
[02:14] *** nativecallable6 joined
[02:14] *** bloatable6 joined
[02:14] *** statisfiable6 joined
[02:14] *** sourceable6 joined
[02:14] *** committable6 joined
[02:15] *** coverable6 joined
[02:15] *** notable6 joined
[02:15] *** tellable6 joined
[03:15] *** linkable6 left
[03:15] *** evalable6 left
[03:15] *** linkable6 joined
[03:17] *** evalable6 joined
[04:32] *** kjp joined
[05:32] *** quotable6 left
[05:32] *** statisfiable6 left
[05:32] *** bisectable6 left
[05:32] *** unicodable6 left
[05:32] *** coverable6 left
[05:32] *** shareable6 left
[05:32] *** notable6 left
[05:32] *** linkable6 left
[05:32] *** releasable6 left
[05:32] *** evalable6 left
[05:32] *** sourceable6 left
[05:32] *** tellable6 left
[05:32] *** nativecallable6 left
[05:32] *** committable6 left
[05:32] *** greppable6 left
[05:32] *** reportable6 left
[05:32] *** bloatable6 left
[05:32] *** benchable6 left
[05:32] *** unicodable6 joined
[05:32] *** sourceable6 joined
[05:32] *** evalable6 joined
[05:33] *** coverable6 joined
[05:33] *** shareable6 joined
[05:33] *** quotable6 joined
[05:34] *** statisfiable6 joined
[05:34] *** greppable6 joined
[05:34] *** linkable6 joined
[05:34] *** bloatable6 joined
[05:34] *** nativecallable6 joined
[05:34] *** committable6 joined
[05:34] *** reportable6 joined
[05:34] *** bisectable6 joined
[05:34] *** releasable6 joined
[05:34] *** notable6 joined
[05:35] *** benchable6 joined
[05:35] *** tellable6 joined
[05:38] <Nicholas> [* GOOD *]

[05:40] <japhb> o/

[06:07] *** reportable6 left
[06:08] *** reportable6 joined
[06:22] <nine> \o

[08:02] *** unicodable6 left
[08:02] *** statisfiable6 left
[08:02] *** linkable6 left
[08:02] *** quotable6 left
[08:02] *** nativecallable6 left
[08:02] *** releasable6 left
[08:02] *** shareable6 left
[08:02] *** committable6 left
[08:02] *** bloatable6 left
[08:02] *** tellable6 left
[08:02] *** sourceable6 left
[08:02] *** notable6 left
[08:02] *** greppable6 left
[08:02] *** coverable6 left
[08:02] *** reportable6 left
[08:02] *** bisectable6 left
[08:02] *** evalable6 left
[08:02] *** benchable6 left
[08:03] *** benchable6 joined
[08:03] *** sourceable6 joined
[08:03] *** bloatable6 joined
[08:04] *** releasable6 joined
[08:04] *** greppable6 joined
[08:04] *** notable6 joined
[08:04] *** linkable6 joined
[08:04] *** statisfiable6 joined
[08:04] *** tellable6 joined
[08:04] *** committable6 joined
[08:04] *** nativecallable6 joined
[08:04] *** reportable6 joined
[08:04] *** quotable6 joined
[08:05] *** bisectable6 joined
[08:05] *** unicodable6 joined
[08:05] *** shareable6 joined
[08:05] *** coverable6 joined
[08:05] *** evalable6 joined
[10:01] *** frost left
[10:22] *** lizmat_ joined
[10:26] *** lizmat_ is now known as lizmat

[10:56] *** frost joined
[11:10] *** discord-raku-bot left
[11:10] *** discord-raku-bot joined
[11:58] *** discord-raku-bot left
[11:58] *** discord-raku-bot joined
[12:05] *** discord-raku-bot left
[12:05] *** dogbert17 left
[12:05] *** discord-raku-bot joined
[12:07] *** reportable6 left
[12:10] *** reportable6 joined
[12:11] <Geth> ¦ MoarVM/disp-bytecode-size: b1109f043b | (Elizabeth Mattijsen)++ | src/disp/syscall.c

[12:11] <Geth> ¦ MoarVM/disp-bytecode-size: Use MasterDuke's suggestion

[12:11] <Geth> ¦ MoarVM/disp-bytecode-size: review: https://github.com/MoarVM/MoarVM/commit/b1109f043b

[12:12] *** dogbert17 joined
[12:24] <Geth> ¦ MoarVM: cc49dcf935 | (Elizabeth Mattijsen)++ (committed using GitHub Web editor) | src/disp/syscall.c

[12:24] <Geth> ¦ MoarVM: Attempt at implementing a "bytecode-size" dispatch

[12:24] <Geth> ¦ MoarVM: 

[12:24] <Geth> ¦ MoarVM: As suggested by jnthn: https://irclogs.raku.org/moarvm/2022-06-12.html#11:30

[12:24] <Geth> ¦ MoarVM: review: https://github.com/MoarVM/MoarVM/commit/cc49dcf935

[12:57] <jnthn> lizmat++

[12:57] <lizmat> I was wondering if I should generalize that dispatch into a more general frame introspection mechanism?

[13:00] <nine> jnthn: I've come across a bit of an issue in RakuAST. my $native_trait := multi trait_mod:<is>(Routine $r, :$native!) { ... } will actually bind the proto instead of the multi candidate, because in https://github.com/rakudo/rakudo/blob/rakuast/src/Raku/ast/code.rakumod#L1037 we generate a lexical lookup instead of a closure clone. Why do we do that there? Apparently we can't decide that on the scope alone, 

[13:00] <lizmat> I was specifically thinking about cuuid name outer

[13:00] <nine> but how else?

[13:01] <lizmat> I wouldn't be surprised if that code was a first approximation to get things working?

[13:04] <jnthn> lizmat: I'd probably do individual calls for the different things rather than building up a data structure of multiple pieces, since it will be hard to EA away stuff created inside of syscalls

[13:05] <lizmat> jnthn: I was more thinking along an extra parameter indicating what stuff you'd want

[13:05] <jnthn> And syscalls in the MoarVM sense - unlike those in the OS sense - are cheap. Spesh can even lift the type/repr check out if there is a sequence of calls that validate that.

[13:05] <lizmat> ok, so multiple calls it is then

[13:05] <jnthn> lizmat: I think that's still harder opt wise

[13:05] <nine> Cheap to call and also cheap to implement

[13:06] <lizmat> okidoki, just more code, but I can live with that  :-)

[13:06] <jnthn> nine: Why is IMPL-EXPR-QAST involved in traits at all?

[13:07] <jnthn> Oh, sorry, misread

[13:07] <jnthn> I'm not sure why it's not just always self.IMPL-CLOSURE-QAST($context)

[13:09] <jnthn> Try it and see, I guess

[13:19] <nine> Ha! Indeed. Now that was easy :)

[13:25] *** lizmat_ joined
[13:27] *** lizmat left
[13:32] *** lizmat_ is now known as lizmat

[14:04] <lizmat> hmmm.. it appears bytecode-size is constant, even if stuff gets inlined into it?

[14:07] *** frost left
[14:11] <nine> Yes, you are reading the _static_ frame's bytecode size

[14:16] <lizmat> I guess the actual size is not kept anywhere ?

[14:16] <lizmat> also: why is cuuid a string, when it only has numeric values afaics

[14:16] <nine> The actual size of what exactly?

[14:17] <lizmat> of the bytecode after it has inlined stuff

[14:17] <lizmat> in it

[14:17] <lizmat> I mean, that's the purpose of inlining, isn't it ?

[14:17] <nine> The bytecode of what?

[14:18] <lizmat> of the frame

[14:18] <lizmat> m: sub a() { }; dd &a.bytecode-size

[14:18] <camelia> rakudo-moar d253dc79e: OUTPUT: «20␤»

[14:18] <nine> That would be the static frame

[14:19] <lizmat> ah... ok, I think it's starting to click...   optimizations only work on clones of the static frame ?

[14:19] <nine> Inlining happens during specialization, the result of which is specialized bytecode. For every static frame there can be an arbitrary number of specialized bytecodes which are picked at runtime.

[14:21] <nine> So the only question that makes sense to ask that would touch size after inlining is "what's the bytecode size of a given frame _on the callstack_?"

[14:22] <lizmat> ack...

[14:22] <lizmat> going to think about that over some cycling&

[14:31] <japhb> nine: I'm not sure that's the only useful question.  For example, you might want to get the collection of specialized bytecodes for a given static frame, and do some analysis across the set.  (The value of that of course increasing the more you can inspect about each bytecode)

[14:33] <nine> That's a "yes, but". I'm not sure, we'd want to expose so much about internals. Spesh is an implementation detail after all

[14:36] *** Kaipii joined
[14:37] <japhb> Well, fair enough.  And I certainly wouldn't make it a Raku feature ... or even Rakudo or NQP.  But it seems like the kind of thing that someone optimizing for MoarVM might reasonably want to know, so being able to introspect it on some debugging interface at least seems useful.  (Whether that be the literal debug server, or via syscalls that are explicitly for low-level work only.)

[14:39] *** Kaipei left
[14:41] *** Kaipii left
[14:41] *** Kaipii joined
[16:14] *** Kaipii left
[16:14] *** Kaipii joined
[16:33] *** vrurg_ joined
[16:33] *** vrurg left
[17:27] <nine> When invoking 37 'parameterize', provided outer frame 0x32c22b0 (1329 'IMPL-STUB-CODE') does not match expected static frame 0x3d6c160 (45 '')

[17:27] <nine> Ah, of course!

[17:56] <[Coke]> Glad we could help! ;)

[18:06] *** reportable6 left
[18:07] *** reportable6 joined
[20:06] <lizmat> so I'm thinking about how one would be able to find out the language level with which a given Callable (well, technically a Code) was compiled

[20:08] <lizmat> I've gotten as far as this: MVMString *language_level = ((MVMCode *)obj)->body.sf->body.cu->body.mainline_frame

[20:08] <lizmat> only thing needed is to look up CORE-SETTING-REV in that stash, right?

[20:10] <lizmat> I guess something like ...mainline_frame->body.lexical_names_list somehow?

[20:13] <nine> There's a lexical_names hashmap and a lexical_names_list array

[20:13] <nine> I do wonder though: what do you need this information for?

[20:17] <lizmat> well... I guess it can be very handy to know when you get a Callable at which language level it was compiled

[20:17] <lizmat> and decide on things to do after that ?

[20:17] <lizmat> and being able to dispatch on language level would also be very helpful, I think?

[20:18] <nine> But the VM doesn't care about such things? It rarely even distinguishes between NQP and Raku

[20:20] <lizmat> are you implying there would be an easier way to find out the language level of a given Callable / Code object ?

[20:21] <nine> No, I just don't understand why you'd need that inside MoarVM

[20:21] <lizmat> well, I would create a Code.language-level method that would do the correct nqp::dispatch

[20:22] <lizmat> agree we don't need it inside MoarVM...  but outside?

[20:23] <nine> That's a different question :) And one that doesn't involve the VM

[20:24] <lizmat> please enlighten me :-)

[20:26] <nine> "Language version" is a concept that the VM does not know at all. That's handled completely in high level code and it should be kept that way. Luckily dispatch is also done purely by high level code. So you don't have to change the VM in any way to achieve language version dependent dispatching.

[20:27] <lizmat> except for being able to find out the language version of a given Callable ?

[20:28] <lizmat> because until I grokked the syscall functionality, I didn't see a way for that

[20:29] *** linkable6 left
[20:29] *** evalable6 left
[20:31] *** evalable6 joined
[20:31] *** linkable6 joined
[20:32] <nine> Wouldn't that just require adding an attribute to Code and setting the appropriate value at compile time?

[20:33] <lizmat> wouldn't that add a lot of overhead?

[20:33] <lizmat> but an interesting idea

[20:34] <lizmat> or perhaps add it @!compstuff

[20:34] <lizmat> *to

[20:34] <nine> @!compstuff is cleared after compilation

[20:35] <lizmat> so is that a yes or no for adding it after compilation?

[20:35] <nine> Compared to how much data is in a Signature, which every Code object has, a single attribute doesn't sound like much

[20:35] <lizmat> ok, fair enough...  will sleep over it...   afk&

[20:35] <nine> You can't use @!compstuff

[21:24] *** Kaipii left
[21:46] <jnthn> Please don't use @!compstuff, it'll either be repurposed or hopefully tossed out by the RakuAST-based compiler frontend.

[21:47] <jnthn> If there's a $!flags field it may be possible to `+|` them onto that, but then it'd be a pain for guarding potentially

[21:55] <lizmat> I will not use @!compstuff

[21:55] <lizmat> :-)

[22:04] *** patrickb_ joined
[22:04] *** Techcable_ joined
[22:07] *** leedo_ joined
[22:07] *** patrickb left
[22:07] *** Techcable left
[22:07] *** leedo left
[22:07] *** patrickb_ is now known as patrickb

[22:07] *** Techcable_ is now known as Techcable

