[02:33] *** MasterDuke joined
[02:55] <MasterDuke> jnthn: i have no idea what fates actually are. but the size of the array of them created when running nfas during the rakudo build varies quite dramatically between the moar and jvm backends. the max for the moar backend was 6, but for the jvm backend it was over 100k

[02:56] <MasterDuke> i realize pmichaud would be the best person to answer this, but do you have any idea what could be causing that difference?

[02:58] *** MasterDuke left
[03:14] *** sena_kun left
[03:43] <japhb> MasterDuke: I very vaguely remember some NFA optimization work, but I can't remember by whom ... might have even been Larry

[03:43] <tellable6> japhb, I'll pass your message to MasterDuke

[05:59] <Woodi> look like fates are Unicode related and for Moar database and C code for that is generated by ucd2c.pl. maye Java part do it on their own ?

[10:34] *** sena_kun joined
[11:38] <jnthn> .tell MasterDuke fates are the thing that identify which proto regex candidate(s) or which alternation branch(es) should be taken. Essentially, if evaluating the NFA crosses a fate edge, that means that, per LTM rules, that candidate or branch is a valid option to try.

[11:38] <tellable6> jnthn, I'll pass your message to MasterDuke

[11:39] <jnthn> .tell MasterDuke I'm not clear if the array you're talking about is the static set of fates (end states) or the per-evaluation set of states that result from a given run of the NFA. Either way, that discrepancy is way out of bounds.

[11:39] <tellable6> jnthn, I'll pass your message to MasterDuke

[11:40] <jnthn> .tell MasterDuke the 6 sounds more like the latter, because e.g. the infix proto regex has many more than 6 possibilities. On MoarVM I think we have a per-thread shared array we clear each time. On JVM do we do that, and do we clear it?

[11:40] <tellable6> jnthn, I'll pass your message to MasterDuke

[13:01] *** Util left
[13:08] *** Util joined
