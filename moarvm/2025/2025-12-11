[00:27] *** librasteve_ left
[08:04] *** sourceable6 left
[08:04] *** sourceable6 joined
[08:04] *** Geth left
[08:04] *** notable6 left
[08:04] *** sourceable6 left
[08:04] *** sourceable6 joined
[08:04] *** linkable6 left
[08:04] *** greppable6 left
[08:05] *** greppable6 joined
[08:05] *** linkable6 joined
[08:05] *** notable6 joined
[10:36] <lizmat> m: sub b { Promise.kept.then({ return 42 }).result }; say b    # guess this is a DIHWIDT ?

[10:36] <camelia> rakudo-moar 6b47541e2: OUTPUT: «MoarVM panic: Did not find expected unwind target frame.␤»

[10:45] <timo> shouldn't cause a panic though

[10:49] <lizmat> I seem to recall this is the type of case that fixing would slow down MoarVM generally quite a bit, no ?

[10:54] <timo> not sure, it should be possible at the location of the error happening we could do a bit of extra work to figure out if it was a critical problem (internal bug or whatever) or if we can just throw an exception telling the user that they did an oopsie

[10:57] <Voldenet> it would be best if blocks could have conditional exception handlers

[10:57] <Voldenet> m: sub b { Promise.kept.then(sub { return 42 }).result }; say b # so the above would turn into something like this

[10:57] <camelia> rakudo-moar 6b47541e2: OUTPUT: «Tried to get the result of a broken Promise␤  in sub b at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤Original exception:␤    Too many positionals passed; expected 0 arguments but got 1␤      in sub  at <tmp> line 1␤␤»

[11:00] <timo> i think the code that runs a "then" may need to have a handler for "return" control exceptions that reacts in this kind of situation

[11:01] <Voldenet> m: sub b { 42.map({ $^a.return }) }; say b # I bet this may be a bit head-scratching

[11:01] <camelia> rakudo-moar 6b47541e2: OUTPUT: «Attempt to return outside of immediately-enclosing Routine (i.e. `return` execution is outside the dynamic scope of the Routine where `return` was used)␤  in block <unit> at <tmp> line 1␤␤»

[11:01] <Voldenet> otoh

[11:02] <Voldenet> hm, nah, I can't think of an example where this exception is useful

[11:03] <timo> the exception from the last execution you mean?

[11:03] <Voldenet> yes

[11:04] <timo> i'm not sure how you mean "useful"

[11:04] <Voldenet> I mean, I wonder if the situation where you throw return control exception in a block is useful

[11:05] <Voldenet> I know there is difference, but I can't think of any useful scenario

[11:05] <timo> recall that if also works with blocks

[11:06] <timo> and if you're factoring out some code from a sub and the code you're moving has a return in it, if you use blocks rather than subs for the factored out portion you can return from there instead of having to write `return $_ with mysub()` every time you call it

[11:06] <Voldenet> ah, right, of course

[11:06] <timo> if and for and other constructs

[11:07] <timo> that's i think the primary motivation for blocks being transparent to return control exceptions

[11:07] <timo> also, early return from a sub that uses map is something that can be useful

[11:08] <Voldenet> m: sub { 42.map({ return $^x }) }().say; # this doesn't work though

[11:08] <camelia> rakudo-moar 6b47541e2: OUTPUT: «Attempt to return outside of immediately-enclosing Routine (i.e. `return` execution is outside the dynamic scope of the Routine where `return` was used)␤  in block <unit> at <tmp> line 1␤␤»

[11:10] <Voldenet> iirc it works with CX::Last

[11:11] <timo> yeah, map is lazy

[11:11] <timo> last will make the iterator stop generating new values, which is completely fine to do after the enclosing sub has returned

[11:11] <Voldenet> m: v6.e.PREVIEW; sub { 42.map({ last $^x }) }().say; # …I don't remember, maybe this

[11:11] <camelia> rakudo-moar 6b47541e2: OUTPUT: «Cannot resolve caller last(Int:D); none of these signatures matches:␤    ( --> Nil)␤    (Label:D $x --> Nil)␤  in block <unit> at <tmp> line 1␤␤»

[11:11] <timo> m: sub { 42.map({ return $^x }); say "never reached"; }().say

[11:11] <camelia> rakudo-moar 6b47541e2: OUTPUT: «42␤»

[11:12] <Voldenet> (nah, it was for grep)

[11:12] <timo> m: sub { <a b c d e>.map({ last when "c"; $_ }) }().say

[11:12] <camelia> rakudo-moar 6b47541e2: OUTPUT: «(a b)␤»

[11:13] <timo> no last-with-value i guess

[11:13] <Voldenet> i mean the form with "last(Bool)" that tells grep whether to include the value or not

[11:13] <Voldenet> I confused it with map for some reason

[11:14] <Voldenet> I get the behavior with early return and it is somewhat understandable

[11:15] <timo> AFKBBL

[11:16] <Voldenet> m: sub { for 42 { return $^x } }().say; # this is something I fully expect in the context

[11:16] <camelia> rakudo-moar 6b47541e2: OUTPUT: «42␤»

[11:17] <Voldenet> m: sub { 42.map({ return $^x }); 1 }().say; # having to type in that another statement is a bit odd, still

[11:17] <camelia> rakudo-moar 6b47541e2: OUTPUT: «42␤»

[11:17] <Voldenet> m: sub { 42.map({ return $^x });   }().say; # otherwise this happen

[11:17] <camelia> rakudo-moar 6b47541e2: OUTPUT: «Attempt to return outside of immediately-enclosing Routine (i.e. `return` execution is outside the dynamic scope of the Routine where `return` was used)␤  in block <unit> at <tmp> line 1␤␤»

[11:18] <Voldenet> I'm not very strong in this opinion, but maybe "return inside block" should instead let you do this

[11:21] <Voldenet> m: sub { 42.map({ when 42 { .return }; return 1 }); 1; }().say; # the whole sub returns 42, there's no way to escape the block without additional sub…

[11:21] <camelia> rakudo-moar 6b47541e2: OUTPUT: «42␤»

[11:22] <Voldenet> m: sub { 42.map(sub { when 42 { .return }; return 1 }); 1; }().say; # so you need that extra handler

[11:22] <camelia> rakudo-moar 6b47541e2: OUTPUT: «Too many positionals passed; expected 0 arguments but got 1␤  in sub  at <tmp> line 1␤  in sub  at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[11:22] <Voldenet> m: sub { 42.map(sub($) { when 42 { .return }; return 1 }); 1; }().say; # so you need that extra handler

[11:22] <camelia> rakudo-moar 6b47541e2: OUTPUT: «===SORRY!=== Error while compiling <tmp>␤Unable to parse expression in argument list; couldn't find final ')' (corresponding starter was at line 1)␤at <tmp>:1␤------> sub { 42.map(sub($)<HERE> { when 42 { .return }; return 1 }); 1; ␤    expect…»

[11:22] <Voldenet> m: sub { 42.map(sub ($) { when 42 { .return }; return 1 }); 1; }().say; # so you need that extra handler

[11:22] <camelia> rakudo-moar 6b47541e2: OUTPUT: «1␤»

[11:24] <Voldenet> in such cases people use ternary op or pattern matching, but often guard statements are more readable, because they don't introduce additional blocks inside a block

[11:25] <Voldenet> e.g. `return Empty if …;`

[11:27] <lizmat> m: dd do if 0 { }

[11:27] <camelia> rakudo-moar 6b47541e2: OUTPUT: «Empty␤»

[11:27] <lizmat> a failed conditional already returns Empty

[11:28] <lizmat> m: dd (^10).map({ $_ if $_ %% 2 })    # which is why this works

[11:28] <camelia> rakudo-moar 6b47541e2: OUTPUT: «(0, 2, 4, 6, 8).Seq␤»

[11:31] <Voldenet> yes but I meant code like this `"{ y: 42 }".map({ return Empty unless my $x = .&json_parse; return Empty unless my $n = $x<y>; $n + 5 }`

[11:32] <Voldenet> I have no strong opinion, because one can simply add that "sub ($_)" inside a map(…) and it solves the problem

[11:35] <Voldenet> it's not the best example though… `sub { return 42.map({ .&json_parse andthen .<y> andthen * + 5 }) }().say;`

[11:36] <Voldenet> but still, guard statements are useful for handling exceptional cases in .map

[12:12] *** Geth joined
[14:25] <timo> sorry i'm not sure what you mean by "extra handler" there

[14:27] <timo> but the oddness happening with "map" is that when you put it as the last statement, it becomes the return value as a value, and if you don't sink or iterate or otherwise consume it, the code in the block you're mapping onto the sequence doesn't run yet

[14:29] <timo> it's also a footgun when you return a sequence from a block you are using Lock.protect in; the code lexically inside the lock's protection may actually run later

[14:32] <timo> a future hypothesized linter, or actually the jetbrains plugin, could point something like that out

[14:34] <timo> am i correctly picking up what you're putting down?

[16:07] <Voldenet> I just mentioned that as weird as an aside, but I understand the explanation

[16:07] <Voldenet> but by extra handler I mean that if you want to use map({ return … }) you need to use map(sub ($_) { return … })

[16:09] <timo> m: .say for <a b c d e f g>.map({ if $_ eq "c" { leave "leave test" }; $_ ~ "+"; })

[16:09] <camelia> rakudo-moar 6b47541e2: OUTPUT: «a+␤leave not yet implemented. Sorry.␤  in block <unit> at <tmp> line 1␤␤b+␤»

[16:09] <Voldenet> :>

[16:10] <Voldenet> Yes, it would make sense if leave worked, I guess it's specified well

[16:18] <Voldenet> not having return is a bit visible in Promise.then and in that case return doesn't even make much sense

[16:20] <Voldenet> unless it's awaited in the same sub where the block originates from

[16:22] <Voldenet> e.g. `sub x { await fetch("http://thing").then(sub ($_) { return 0 if .status ~~ Broken; .result })`

[16:26] <Voldenet> without `sub ($_)` x could return 0 directly without resolving the promise, but that'd be weird

[21:00] *** librasteve_ joined
