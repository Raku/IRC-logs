[00:00] *** vrurg joined
[01:35] *** librasteve_ left
[03:00] <ShimmerFairy> m: say "\x[1193F]A".chars # should be "1", since 2016

[03:00] <camelia> rakudo-moar 7a302e082: OUTPUT: ¬´2‚ê§¬ª

[03:01] <ShimmerFairy> It's suddenly become apparent to me that, if I manage the Unicode upgrade well enough, all of Moar's unicode support ought to get a once-over.

[06:58] <ShimmerFairy> It's kinda fun to work through the grapheme code and finding situations where it doesn't work right. For instance, "A\c[ZWJ]üßÄ" is misinterpreted as a single grapheme, because the implementation of rule GB11 is too broad.

[08:58] <lizmat> ++ShimmerFairy yete again  :-)

[09:04] <ShimmerFairy> I've decided that unfortunately the grapheme breaker function needs to be completely rewritten. It was written for a world where you only needed one codepoint behind and ahead of the possible break point, but nowadays we have a number of rules that depend on more context. The current function only just manages RI grapheme state, but bolting additional stateful checks on would be awkward.

[09:05] <ShimmerFairy> Perhaps the people who worked on the original function could work it in, but to me at least the design doesn't fit the current ruleset anymore.

[09:08] <lizmat> hmmm...  I hope that's not going to be too detrimental to decoding efficiency

[09:12] <ShimmerFairy> I think it should be fine, since the state machine approach I'm trying to write up right now would let you skip rule checks that can't possibly be true. For a first pass the "one ahead/behind only" rules are mostly handled in a single state, but I think it could be broken down further to skip more checks on each run.

[09:24] <lizmat> that sounds good: more power to ya!

[10:28] <ShimmerFairy> Out of curiosity, is there an established way of profiling NFG string handling? I figured keeping track of how long 'make stresstest' takes would be informative, but if there's a better method I'll use it instead.

[10:59] *** librasteve_ joined
[11:30] <lizmat> timo  might know

[17:24] <disbot6> <jubilatious1_98524> m: say "\x[1193F]".chars;

[17:24] <disbot6> <Raku eval>  1 

[17:30] <timo> it seemed to me like we already had something that can do more than one ahead and behind with some state kept, especially for the regional indicators handling that wants multiple-of-two codes

[17:33] <disbot6> <jubilatious1_98524> m: say "\x[1193F]";

[17:33] <disbot6> <Raku eval>  ë§ø 

[17:34] <timo> the "does a string need re-checking after concat" check may be more interesting?

[17:36] <disbot6> <jubilatious1_98524> I don't know if \x[1193F] is a free-standing character or not.

[17:43] <timo> trying to get something from unicode.org and it's taking ... a minute?

[17:47] <timo> looks like 1193F is InCB=None and Grapheme_Extend is No, but Grapheme_Cluster_Break is Prepend

[17:48] <timo> so with it being a Prepend that means we should never break after it (except of course at end-of-text)

[17:51] <disbot6> <jubilatious1_98524> Amazing!

[17:56] <disbot6> <jubilatious1_98524> m: say Unicode.version;

[17:56] <disbot6> <Raku eval>  v15.0 

[18:06] <disbot6> <jubilatious1_98524> m: say "A\c[ZWJ]üßÄ".chars

[18:06] <disbot6> <Raku eval>  1 

[18:16] <timo> you think that's not right?

[19:08] *** patrickb left
[19:08] *** patrickb joined
[19:25] *** vrurg_ joined
[19:25] *** linkable6 left
[19:25] *** notable6 left
[19:25] *** linkable6 joined
[19:25] *** sugarbeet left
[19:26] *** sugarbeet joined
[19:26] *** bloatable6 left
[19:26] *** benchable6 left
[19:26] *** tellable6 left
[19:27] *** vrurg left
[19:29] *** notable6 joined
