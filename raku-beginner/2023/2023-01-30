[02:29] <discord-raku-bot> <:(**@rest, *%rest)> m: my \x = 1; sub x { 2 }  say x; say x(); 

[02:30] <discord-raku-bot> <:(**@rest, *%rest)> sigiless vars take precedence over 0 arg calls not surprising

[02:30] <discord-raku-bot> <:(**@rest, *%rest)> m: sub x { 2 }  say x; say x(); 

[02:32] <discord-raku-bot> <:(**@rest, *%rest)> is this ambiguity resolved by keeping a symbol table

[02:33] <raschip> In Raku there's a symbol table for every scope, lexical or package

[02:37] <discord-raku-bot> <:(**@rest, *%rest)> can you delete a variable in raku

[02:41] <raschip> Never heard anything about it. The symbol tables are read-only for the program.

[02:43] <raschip> You access them directly, though.

[02:44] <raschip> For package tables: https://docs.raku.org/type/Stash

[02:44] <raschip> For lexical tables: https://docs.raku.org/type/PseudoStash

[03:06] <discord-raku-bot> <:(**@rest, *%rest)> m: # generic + lmao use MONKEY-TYPING; multi sub infix:<+>(Any \a, Any \b --> Any) {   a.ADD(b) }  augment class Str {   method ADD(\other) {     self ~ other   } }  say 'hello ' + 'world'; 

[03:07] <discord-raku-bot> <:(**@rest, *%rest)> how doesn't this work

[03:11] <raschip> Can you write it on glot.io and share? discord bot mangles the code, I can't even try it.

[03:13] <discord-raku-bot> <:(**@rest, *%rest)> oh wait thats because the old signature is (Any(Numeric) \a, Any(Numeric) \b)

[03:13] <discord-raku-bot> <:(**@rest, *%rest)> mine conflicts with it

[03:14] <discord-raku-bot> <:(**@rest, *%rest)> i think make a role named Addable

[03:25] <raschip> Sleep now, g'night.

[03:26] *** raschip left
[03:52] <discord-raku-bot> <:(**@rest, *%rest)> m: # generic + lmao use MONKEY-TYPING;  role Addable {   method ADD(\, \) { ... } } multi sub infix:<+>(Addable \a, Addable \b --> Any) {   a.ADD(b) }  augment class Str {   method ADD(\other) {     self ~ other   } }  say 'hello ' + 'world'; 

[03:53] <discord-raku-bot> <:(**@rest, *%rest)> m: # generic + lmao use MONKEY-TYPING;  role Addable {   method ADD(\, \) { ... } } multi sub infix:<+>(Addable \a, Addable \b --> Any) {   a.ADD(b) }  augment class Str does Addable {   method ADD(\other) {     self ~ other   } }  say 'hello ' + 'world'; 

[03:53] <discord-raku-bot> <:(**@rest, *%rest)> yes it worked

[04:38] <discord-raku-bot> <:(**@rest, *%rest)> does raku have protocols like interfaces but you don't have to does it explicitly like roles

[06:08] <discord-raku-bot> <jaguart> do you mean like virtual roles?

[06:10] <discord-raku-bot> <jaguart> hmm - but your example already shows that - so something else

[06:30] <discord-raku-bot> <:(**@rest, *%rest)> i still have to does it in that case

[07:18] *** guifa left
[07:19] *** guifa joined
[07:32] *** snonux joined
[07:42] *** snonux_ joined
[08:32] <discord-raku-bot> <:(**@rest, *%rest)> m: use monkey-typing;  supersede class Cool {}  say '-1'.abs 

[08:32] <discord-raku-bot> <:(**@rest, *%rest)> m: pragma monkey-typing;  supersede class Cool {}  say '-1'.abs 

[08:51] *** snonux_ left
[08:51] *** snonux left
[08:55] *** dakkar joined
[09:17] <discord-raku-bot> <:(**@rest, *%rest)> does raku have array like or hash like objects yk objects that can be safely put in @ and % vars respectively without coercing to Array

[09:20] <dakkar> IIRC, %vars take objects that do the Associative role, @vars take objects that do the Positional role

[09:25] <discord-raku-bot> <:(**@rest, *%rest)> and if they does those roles are they safely assigned or are they coerced to an Array

[09:27] <discord-raku-bot> <Nemokosch> what does that mean?

[09:27] <discord-raku-bot> <:(**@rest, *%rest)> safely assigned as in assigned without getting coerced to an Array or Hash

[09:28] <discord-raku-bot> <Nemokosch> https://docs.raku.org/type/Associative

[09:28] <discord-raku-bot> <Nemokosch> that's what an Associative needs to provide

[09:28] <discord-raku-bot> <Nemokosch> it clearly provides STORE so that it will be used, not to drop the whole thing and use a Hash instead...

[09:29] <discord-raku-bot> <:(**@rest, *%rest)> oh >>> Please note that we are using binding := here, since by default % assignments expect a Hash in the right-hand side, and thus assignment would try and convert it to a hash (also failing). However, with the Associative role:  class Whatever is Associative {}; my %whatever := Whatever.new; will be syntactically correct.

[09:30] <discord-raku-bot> <Nemokosch> it doesn't have to be like that

[09:30] <discord-raku-bot> <:(**@rest, *%rest)> = coerces to Hash := keep it

[09:30] <discord-raku-bot> <Nemokosch> you could specify %whatever to be a different type

[09:30] <discord-raku-bot> <Nemokosch> my %whatever is Whatever = Whatever.new

[09:31] <discord-raku-bot> <:(**@rest, *%rest)> hmm

[09:31] <discord-raku-bot> <Nemokosch> btw I think there is some discrepancy between your original question and the answer to it

[09:31] <discord-raku-bot> <Nemokosch> like, you don't need the % sigil to make something act like a Hash or something

[09:32] <discord-raku-bot> <Nemokosch> actually, you don't even need does Associative

[09:32] <discord-raku-bot> <Nemokosch> it could be duck typed, like in Python

[09:32] <discord-raku-bot> <Nemokosch> if you provide the magic, you are good to go

[09:32] <discord-raku-bot> <:(**@rest, *%rest)> m: my %num := 1;  say %num; 

[09:33] <discord-raku-bot> <:(**@rest, *%rest)> so i just need to specify the methods

[09:33] <discord-raku-bot> <Nemokosch> yes, simplest case

[09:34] <discord-raku-bot> <Nemokosch> but then of course % won't accept your stuff

[09:34] <discord-raku-bot> <Nemokosch> (without Associative)

[09:34] <discord-raku-bot> <Nemokosch> anyway, to provide STORE is pointless without a % var, mainly

[09:34] <discord-raku-bot> <:(**@rest, *%rest)> i imagine the same with Positional

[09:35] <discord-raku-bot> <Nemokosch> yes

[09:35] <discord-raku-bot> <Nemokosch> because a $ var will be wrapped into a Scalar and therefore the Scalar STORE will win

[09:36] <discord-raku-bot> <Nemokosch> but the BLABLABLA-KEY methods are fully sensible to provide, even without Associative

[11:53] *** raschip joined
[12:03] *** sivoais joined
[12:52] *** raschip left
[13:03] *** raschip joined
[13:37] <discord-raku-bot> <:(**@rest, *%rest)> are there common tokens that i can use in grammar in the stdlib?

[14:00] <discord-raku-bot> <:(**@rest, *%rest)> why does my grammar return Nil

[14:00] <discord-raku-bot> <:(**@rest, *%rest)> https://glot.io/snippets/ghroe4i139

[14:05] <discord-raku-bot> <Nemokosch> why can't you start with something simpler 😩

[14:07] <discord-raku-bot> <:(**@rest, *%rest)> what is simpler than that?

[14:08] <discord-raku-bot> <Nemokosch> something that uses 1 or 2 tokens, not like 8

[14:13] <discord-raku-bot> <Nemokosch> the STRING token itself doesn't work, that's for sure

[14:14] <discord-raku-bot> <:(**@rest, *%rest)> ok i updated it https://glot.io/snippets/ghroe4i139

[14:14] <discord-raku-bot> <Nemokosch> <[- " \\]> what would this do?

[14:15] <discord-raku-bot> <:(**@rest, *%rest)> seems like the problem is %

[14:15] <discord-raku-bot> <:(**@rest, *%rest)> match everything except " and \

[14:15] <discord-raku-bot> <Nemokosch> doesn't seem like that tbh

[14:15] <discord-raku-bot> <Nemokosch> and is it what it really does? 🤔

[14:15] <discord-raku-bot> <Nemokosch> looks kinda weird

[14:16] <discord-raku-bot> <:(**@rest, *%rest)> after i remove % it no longer has the problem

[14:16] <discord-raku-bot> <:(**@rest, *%rest)> and actually matched

[14:16] <discord-raku-bot> <Nemokosch> then it probably works for the wrong reason

[14:16] <discord-raku-bot> <Nemokosch> m: say 'a' ~~ / <[- " \]> /

[14:17] <discord-raku-bot> <Nemokosch> so you are saying that this would match

[14:17] <discord-raku-bot> <Nemokosch> not even a string worked with that grammar

[14:17] <discord-raku-bot> <Nemokosch> no % involved

[14:17] <discord-raku-bot> <:(**@rest, *%rest)> and after string was gone lmao

[14:18] <discord-raku-bot> <Nemokosch> it's not the fault of %, rather the loose use of whitespace

[14:18] <discord-raku-bot> <Zephyr> is there a simple way to make a CLI one-liner that processes an entire file rather than line-by-line?

[14:19] <discord-raku-bot> <Zephyr> what I've tried:

[14:19] <discord-raku-bot> <Zephyr> https://cdn.discordapp.com/attachments/768511641758466088/1069622908743327744/image.png

[14:19] <discord-raku-bot> <Zephyr> issue with -n is that it splits newlines

[14:19] <discord-raku-bot> <Zephyr> I want the whole string

[14:19] <discord-raku-bot> <Nemokosch> well just do it in code

[14:19] <discord-raku-bot> <Nemokosch> slurp()

[14:20] <discord-raku-bot> <Zephyr> hmm, true

[14:20] <discord-raku-bot> <Zephyr> raku -e '"package.json".IO.slurp.say' works fine

[14:20] <discord-raku-bot> <Zephyr> thanks

[14:21] <discord-raku-bot> <Nemokosch> probably slurp().say would also work

[14:21] <discord-raku-bot> <Nemokosch> and sending the file into it

[14:22] <discord-raku-bot> <:(**@rest, *%rest)> i introduced them back https://glot.io/snippets/ghroe4i139

[14:22] <discord-raku-bot> <:(**@rest, *%rest)> doesn't match

[14:22] <discord-raku-bot> <Nemokosch> @:(**@rest, *%rest) rule is sensitive to whitespace - that's why I don't like it actually

[14:23] <discord-raku-bot> <Nemokosch> your grammar kind of depends on the right amount of spaces here and there

[14:23] <discord-raku-bot> <:(**@rest, *%rest)> i have to rewrite all of them into tokens?

[14:24] <discord-raku-bot> <Nemokosch> you don't "have to" but I think it's a good idea to never rely on "implicit" whitespaces, I'd rather add \s* where it's appropriate

[14:25] <discord-raku-bot> <:(**@rest, *%rest)> aren't rule whitespace-ignoring? like isn't rule R {   'foo' 'bar' }equivalent to token R {   'foo' <.ws> 'bar' }

[14:27] <discord-raku-bot> <Nemokosch> that's not "whitespace-ignoring" in my lingo for sure

[14:27] <discord-raku-bot> <Nemokosch> anyway, the syntax was faulty

[14:27] <discord-raku-bot> <Nemokosch> <-[blabla]>

[14:27] <discord-raku-bot> <Nemokosch> not <[-blabla]>

[14:27] <discord-raku-bot> <Nemokosch> and this does fix your last snippet immediately

[14:28] <discord-raku-bot> <Zephyr> right, forgot, thanks

[14:29] <discord-raku-bot> <:(**@rest, *%rest)> oh nice

[14:31] <discord-raku-bot> <Nemokosch> tbh whitespace in regexes is a thing that I fear

[14:31] <discord-raku-bot> <Nemokosch> I'd say Raku regexes are more explicit by default and therefore feel safer

[14:32] <discord-raku-bot> <Nemokosch> as long as you follow a couple of simple rules of thumb, it's fairly straightforward

[14:32] <discord-raku-bot> <Nemokosch> for example, I quote everything I can, unless I mean the special syntactic meaning

[14:32] <discord-raku-bot> <Nemokosch> regardless if I have to or not

[14:33] <discord-raku-bot> <Nahita> is <.ws> equivalent to \s or \s* or not?

[14:33] <discord-raku-bot> <Nahita> didn't understand the documentation

[14:34] <discord-raku-bot> <:(**@rest, *%rest)> now its still Nil https://glot.io/snippets/ghroe4i139

[14:34] <discord-raku-bot> <Nahita> uuu JSON parser

[14:34] <discord-raku-bot> <:(**@rest, *%rest)> why doesn't it give good errors instead of Nil 😭

[14:35] <discord-raku-bot> <Nahita> there's Grammar::Debugger or something for that ig

[14:36] <discord-raku-bot> <:(**@rest, *%rest)> if i change [<pair>* % ','] to [<pair> [',' <pair>]*]? it will work

[14:36] <discord-raku-bot> <Nemokosch> because you have a whitespace inside I guess

[14:36] <discord-raku-bot> <Nemokosch> this was a rule

[14:36] <discord-raku-bot> <Nemokosch> it would turn the other way around if your input had not space there

[14:37] <discord-raku-bot> <:(**@rest, *%rest)> % operator is space-dependent ig

[14:38] <discord-raku-bot> <Nemokosch> like i don't even know how to read this inside a rule: [<pair>* % ',']

[14:38] <discord-raku-bot> <Nemokosch> where is the space?

[14:38] <discord-raku-bot> <Nemokosch> is there any?

[14:38] <discord-raku-bot> <Nemokosch> see, this is the kind of guessing game I hate

[14:39] <discord-raku-bot> <Nemokosch> [<pair> [',' <pair>]*] - this on the other hand is just incomprehensive

[14:39] <discord-raku-bot> <Nemokosch> it does assume the space, perhaps one space exactly

[14:40] <discord-raku-bot> <:(**@rest, *%rest)> ok if i span my input more than one line

[14:40] <discord-raku-bot> <:(**@rest, *%rest)> it doesn't match again

[14:40] <discord-raku-bot> <:(**@rest, *%rest)> i hate Grammars

[14:40] <discord-raku-bot> <Nemokosch> yeah it needs to be more solid with the whitespace

[14:41] <discord-raku-bot> <:(**@rest, *%rest)> quits 😤

[14:44] <discord-raku-bot> <:(**@rest, *%rest)> according to the regex page its <!ww>\s*

[14:44] <discord-raku-bot> <Nahita> thanks so it checks boundaries too then

[14:44] <discord-raku-bot> <:(**@rest, *%rest)> still

[14:47] <discord-raku-bot> <Zephyr> what's the difference between m/stuff/ and rx/stuff/?

[14:47] <discord-raku-bot> <Nemokosch> that m is evil and shouldn't be ever used with smartmatches

[14:47] <discord-raku-bot> <:(**@rest, *%rest)> m/stuff/ is like $_.match(rx/stuff/)

[14:48] <discord-raku-bot> <:(**@rest, *%rest)> or $_ ~~ /stuff/

[14:48] <discord-raku-bot> <Zephyr> so no m/ in smartmatches, thanks

[14:48] <discord-raku-bot> <Nemokosch> I mean, it works... but at what cost

[14:50] <discord-raku-bot> <Zephyr> wonder if the syntax highlighter of vscode is buggy or my code is wrong

[14:50] <discord-raku-bot> <Zephyr> https://cdn.discordapp.com/attachments/768511641758466088/1069630657707380806/image.png

[14:50] <discord-raku-bot> <:(**@rest, *%rest)> i think its buggy tbh

[14:50] <discord-raku-bot> <Nemokosch> m:   my $match1 = 'asdfgh' ~~ /df/; my $match2 = 'trololo' ~~ /lol/; say $match1 ~~ $match2; 

[14:50] <discord-raku-bot> <Nemokosch> every time I think of this, it makes me wanna cry

[14:51] <discord-raku-bot> <Nemokosch> smartmatching on two Match objects is implemented as "just take the right side, duh"

[14:51] <discord-raku-bot> <Nemokosch> very smart indeed 🥴

[14:51] <discord-raku-bot> <Nemokosch> and THIS is why something ~~ m// can work

[14:51] <discord-raku-bot> <Nemokosch> that's the sole reason for this hell

[14:51] <discord-raku-bot> <:(**@rest, *%rest)> imagine the pain of putting <.ws> everywhere on the grammar 😭

[14:52] <discord-raku-bot> <Nemokosch> I don't even know this <.ws> magic, I only know good old \s

[14:53] <discord-raku-bot> <:(**@rest, *%rest)> <.ws> is just like that

[14:53] <discord-raku-bot> <Nemokosch> then I don't see any problems

[14:54] <discord-raku-bot> <Nemokosch> yes, if you want to support whitespace between certain structures of the grammar, you're gonna indicate that

[14:54] <discord-raku-bot> <Nemokosch> quite normal if you ask me

[14:56] <discord-raku-bot> <:(**@rest, *%rest)> still explicitly writing \w* or <.WS> between grammar parts are tedious and considered bad form in parser generator grammars (in those you can just tell the lexer to not feed whitespace to the parser)

[14:56] <discord-raku-bot> <Zephyr> am I missing something obvious perl my regex pattern { ^^ \s* '- ' $<item> = ( \S+ ) }  my $old = slurp "zepsregex.md"; my @oldLines = $old.lines; my @oldItems = @oldLines.map({($_ ~~ &pattern)<item>.Str}); my $new = slurp "zepcat.md"; my @newLines = $new.lines; my @newItems = @newLines.map({($_ ~~ &pattern)<item>.Str});  for @newItems.kv -> $idx, $val {     if @oldLines[$idx] != $val {         say "$idx:

[14:56] <discord-raku-bot> $val";     } }

[14:56] <discord-raku-bot> <Zephyr> https://cdn.discordapp.com/attachments/768511641758466088/1069632176812994731/image.png

[14:56] <discord-raku-bot> <Nemokosch> I wouldn't call that tedious, it's a part of the design of the grammar

[14:56] <discord-raku-bot> <Nemokosch> like anything else

[14:56] <discord-raku-bot> <stevied> There is this: multi method new($, *@) in the Mu class. So what does this throw an error:  class A {}.new('blah');

[14:56] <discord-raku-bot> <Nemokosch> ^is this even valid syntax?

[14:56] <discord-raku-bot> <Zephyr> excuse the extra variables, I made them for using later

[14:57] <discord-raku-bot> <stevied> yes, it's valid syntax

[14:57] <discord-raku-bot> <stevied> error is: Default constructor for 'A' only takes named arguments

[14:57] <discord-raku-bot> <Nemokosch> I think the candidate you found is misleading

[14:57] <discord-raku-bot> <:(**@rest, *%rest)> thats obvious

[14:57] <discord-raku-bot> <:(**@rest, *%rest)> no pos args

[14:57] <discord-raku-bot> <Nemokosch> normally, you indeed cannot pass positional arguments to the default constructor

[14:58] <raschip> Can't use positional arguments by default.

[14:58] <discord-raku-bot> <stevied> I passed in 'blah' as an arg

[14:58] <discord-raku-bot> <Zephyr> oh wait, I typed oldLines instead of oldItems

[14:58] <discord-raku-bot> <Nemokosch> not sure what you found but tbh not sure if there is point in debugging a wrong assumption

[14:58] <discord-raku-bot> <Nemokosch> the error message is right here

[14:58] <discord-raku-bot> <stevied> I know you can't, but why not, given that Mu has a new contructor that looks like: multi method new($, *@)

[14:58] <discord-raku-bot> <Nemokosch> again, is there any point in trying to trace down this wrong assumption?

[14:59] <discord-raku-bot> <:(**@rest, *%rest)> you didn't declare it in A

[14:59] <discord-raku-bot> <:(**@rest, *%rest)> its just class A {}

[14:59] <discord-raku-bot> <Nemokosch> did that fix your problem?

[14:59] <discord-raku-bot> <stevied> but this is allowed: class A {}.new(blah => 1);

[14:59] <discord-raku-bot> <Zephyr> doesn't look like it unfortunately

[15:00] <discord-raku-bot> <Nemokosch> but like... it gave the right error

[15:00] <discord-raku-bot> <Nemokosch> "you cannot use positionals in the default constructor"

[15:00] <discord-raku-bot> <stevied> there is no error

[15:00] <discord-raku-bot> <Nemokosch> this is what we all learn and experience

[15:00] <discord-raku-bot> <Nemokosch> isn't this just enough?

[15:00] <discord-raku-bot> <:(**@rest, *%rest)> again, implicit *%_

[15:01] <discord-raku-bot> <:(**@rest, *%rest)> all named args is eaten by it

[15:01] <discord-raku-bot> <Nahita> "assumption"? wtf

[15:01] <discord-raku-bot> <stevied> i'll ask the question a different way. How do I use this method in Mu: multi method new($, *@)

[15:01] <discord-raku-bot> <Nahita> that's from the documentation

[15:01] <discord-raku-bot> <stevied> and if I can't, why bother putting it in the docs?

[15:01] <discord-raku-bot> <Nahita> fix the documentation, is the "point"

[15:01] <discord-raku-bot> <Nemokosch> I'm sure the documentation also says that the default constructor cannot use positionals...

[15:01] <discord-raku-bot> <Zephyr> oh, maybe it's because there isn't always a match

[15:02] <discord-raku-bot> <Nahita> it does, so what, so what

[15:02] <discord-raku-bot> <Nemokosch> the documentation doesn't say that the default constructor is some multi method new($, *@)

[15:02] <discord-raku-bot> <Nemokosch> so like there's nothing to see here

[15:02] <discord-raku-bot> <stevied> https://docs.raku.org/type/Mu#method_new

[15:02] <discord-raku-bot> <stevied> it does say it's multi

[15:02] <discord-raku-bot> <Nemokosch> >  This method expects only named arguments which are then used to initialize attributes with accessors of the same name.

[15:02] <discord-raku-bot> <:(**@rest, *%rest)> is there a way to get a specialization of a multi as a sub

[15:03] <discord-raku-bot> <stevied> right, so what the hell is the new($, *@) method for?

[15:03] <discord-raku-bot> <stevied> why is it there?

[15:03] <discord-raku-bot> <Nemokosch> I have no idea

[15:03] <discord-raku-bot> <:(**@rest, *%rest)> my or @stevied's question?

[15:04] <raschip> To give the correct error if try to use it.

[15:04] <discord-raku-bot> <Zephyr> is there an alternative to optional chaining in Raku?

[15:04] <discord-raku-bot> <Nemokosch> hm, raschip has a great point actually xD

[15:04] <discord-raku-bot> <Zephyr> sorry for all the dumb questions, just messing around a bit with it after a long time

[15:04] <discord-raku-bot> <:(**@rest, *%rest)> $a?.b?

[15:04] <discord-raku-bot> <Nemokosch> that can very well be a candidate dedicated to producing the error

[15:05] <discord-raku-bot> <Nemokosch> uh oh, no

[15:05] <discord-raku-bot> <Zephyr> didn't know that works in it, thanks

[15:05] <discord-raku-bot> <Zephyr> huh

[15:05] <discord-raku-bot> <Nemokosch> first, there is no ?., there is .?

[15:05] <discord-raku-bot> <Nemokosch> second, it doesn't quite do what ?. does in other languages

[15:05] <discord-raku-bot> <Zephyr> then?

[15:05] <discord-raku-bot> <Nemokosch> it says "call the method if you find it, return Nil otherwise`

[15:06] <discord-raku-bot> <Zephyr> perl sub cb($str) { ($str ~~ &pattern)<item>.Str }how'd you write this function to only return .Str if there's a match or return $str if there isn't

[15:06] <discord-raku-bot> <Nemokosch> andthen can be used for optional chaining, if you mean "execute it for defined lhs"

[15:06] <discord-raku-bot> <Zephyr> yup

[15:07] <discord-raku-bot> <stevied> hmm, maybe this is why there's a positional method: https://docs.raku.org/language/objects#Class_and_instance_methods

[15:07] <discord-raku-bot> <Nemokosch> andthen checks if the lhs is defined and if it does, it sets the topic variable to the lhs and executes the rhs with it, as a kind of block

[15:07] <discord-raku-bot> <Zephyr> perl sub cb($str) { ($str ~~ &pattern)<item> andthen .Str or $str }is that valid

[15:08] <discord-raku-bot> <:(**@rest, *%rest)> perl if $str ~~ &pattern -> $match {   $match<item>.Str } else {   $str } 

[15:08] <discord-raku-bot> <Nemokosch> yes, although I'd rather use orelse

[15:08] <discord-raku-bot> <Nemokosch> instead of or

[15:08] <discord-raku-bot> <stevied> so it seems tthe ($, *@) for is for passing objects to new()

[15:08] <discord-raku-bot> <Nahita> ($str ~~ &pattern)<item>.Str orelse $str

[15:08] <discord-raku-bot> <Nemokosch> as kind of the rightful counterpart of andthen

[15:08] <discord-raku-bot> <Zephyr> shouldn't that error trying to convert Nil to Str?

[15:08] <discord-raku-bot> <Nemokosch> it will throw a warning probably

[15:09] <discord-raku-bot> <Nahita> m: Nil.Str.say

[15:09] <discord-raku-bot> <:(**@rest, *%rest)> this should work too?perl if $str ~~ &pattern {   $/<item>.Str } else {   $str } 

[15:09] <raschip> It's a failure, only produces an exception if you don't check for definedness, which is happening in this case.

[15:09] <discord-raku-bot> <Zephyr> I was trying to go for a one-liner

[15:09] <discord-raku-bot> <Nemokosch> yes

[15:09] <discord-raku-bot> <Nemokosch> also, $<item> is enough

[15:09] <discord-raku-bot> <Zephyr> somehow my error remains

[15:09] <discord-raku-bot> <Zephyr> https://cdn.discordapp.com/attachments/768511641758466088/1069635555408744449/image.png

[15:10] <discord-raku-bot> <Nemokosch> (not sure if $<item> was a good idea from syntax pov but it does work this way)

[15:10] <discord-raku-bot> <Nemokosch> != on a string

[15:10] <discord-raku-bot> <Nemokosch> should be ne

[15:10] <discord-raku-bot> <Zephyr> oh

[15:10] <discord-raku-bot> <Zephyr> thanks, guess I should review the basics sometime

[15:14] <discord-raku-bot> <stevied> oh, wait, I think new($, *@) is so you can pass in pairs. each pair is a single value

[15:15] <discord-raku-bot> <Nemokosch> raschip already spoiled what it's for

[15:15] <discord-raku-bot> <Nemokosch> https://github.com/rakudo/rakudo/blob/2022.12/src/core.c/Mu.pm6#L121

[15:15] <discord-raku-bot> <Nemokosch> to produce the error 😆

[15:16] <raschip> There should be a way to hide it from appearing in the docs...

[15:16] <discord-raku-bot> <Nemokosch> yep, that's what I'm thinking about, too... can a candidate be marked as an implementation-detail?

[15:17] <discord-raku-bot> <stevied> ah, ok

[15:17] <discord-raku-bot> <Nemokosch> that would come kinda handy; after all, this really is a candidate for internal workings

[15:17] <discord-raku-bot> <stevied> thanks!

[15:23] *** Air4x joined
[15:23] <discord-raku-bot> <Zephyr> is a Hash guaranteed to keep insertion order?

[15:24] <discord-raku-bot> <Nemokosch> no

[15:24] <discord-raku-bot> <Zephyr> not nice

[15:24] <discord-raku-bot> <Zephyr> is there any ordered key-value pair?

[15:24] <discord-raku-bot> <Nemokosch> a Hash is actually a hash...

[15:25] <discord-raku-bot> <Nemokosch> well, what is your use case?

[15:26] <discord-raku-bot> <:(**@rest, *%rest)> to preserve order when converting from arrays of pairs i think

[15:27] <discord-raku-bot> <Nemokosch> there are two orthogonal things here imo

[15:27] <discord-raku-bot> <Nemokosch> a) hash-style lookup

[15:27] <discord-raku-bot> <Nemokosch> b) ordered pairs

[15:27] <discord-raku-bot> <Nemokosch> both are easy in themselves

[15:27] <discord-raku-bot> <Nemokosch> the combination needs a module I think

[15:27] <discord-raku-bot> <Zephyr> basically: I have 2 lists, one is a list of keys another is a list of values. now, I wanna be able to get the value from the key inside a loop without hurting the order

[15:28] <discord-raku-bot> <Zephyr> or idk if I made any sense

[15:28] <discord-raku-bot> <Zephyr> a picture speaks a thousand words so here's the code perl my regex pattern { ^^ \s* '- ' $<item> = ( \S+ ) }  sub cb($str) { ($str ~~ &pattern)<item> andthen .Str orelse $str }  my $old = slurp "zepsregex.md"; my @oldLines = $old.lines; my @oldItems = @oldLines.map(&cb); my $new = slurp "zepcat.md"; my @newLines = $new.lines; my @newItems = @newLines.map(&cb);  I'm trying to merge the 2 files together by the

[15:28] <discord-raku-bot> matched keys without hurting the order

[15:29] <discord-raku-bot> <:(**@rest, *%rest)> then im afraid you have to use pair lists

[15:29] <discord-raku-bot> <Zephyr> zepcat.md and zepsregex.md both have text that match that pattern

[15:29] <discord-raku-bot> <Zephyr> but zepcat.md has some lines missing here and there

[15:29] <discord-raku-bot> <Zephyr> and I need to insert them

[15:29] <discord-raku-bot> <Zephyr> however, the raw string in zepsregex.md is outdated

[15:30] <discord-raku-bot> <Zephyr> the key isn't the only data, so yeah

[15:30] <raschip> Hash is in fact guaranteed to give you a different order every time you run the program.

[15:30] <discord-raku-bot> <Zephyr> welp, quite the opposite of what I need here

[15:30] <raschip> The hash function has random order enforced, to guarantee peo0ple don't rely on it

[15:30] <discord-raku-bot> <:(**@rest, *%rest)> that causes problems with reproducibility hmm

[15:30] <discord-raku-bot> <Nemokosch> lol, now I didn't know that

[15:30] <discord-raku-bot> <:(**@rest, *%rest)> and make hash loops unpredictable

[15:30] <discord-raku-bot> <Nemokosch> checks raschip in the list of Rakudo contributors

[15:31] <discord-raku-bot> <Zephyr> trying to rephrase: merge 2 files, for each conflict, prefer the newer file's data. for lines that don't exist in the new file, insert the older file's data

[15:31] <discord-raku-bot> <Zephyr> conflict is determined by the regex match there

[15:31] <discord-raku-bot> <Zephyr> and must maintain the order

[15:32] <raschip> I would have a map from the key into lists of 2 elements, the contents and the order. After using the hash, it's easy to construct the original list in order

[15:32] <discord-raku-bot> <:(**@rest, *%rest)> i can do that without hash

[15:32] <discord-raku-bot> <stevied> should I file an issue about the new() method in the docs?

[15:33] <discord-raku-bot> <stevied> might as well

[15:33] <discord-raku-bot> <Zephyr> hmm, having the order as a value makes sense indeed, lemme try. thanks btw

[15:35] <discord-raku-bot> <Nemokosch> yep, you can - just please check if there are already issues of that sort

[15:35] <discord-raku-bot> <Nemokosch> sounds essential enough, related to how these signatures are collected

[15:37] *** NemokoschKiwi joined
[15:38] *** NemokoschKiwi left
[15:40] *** Air4x left
[15:47] <discord-raku-bot> <:(**@rest, *%rest)> are there a "callable with signature" type like Callable[(...), ...] in python or (...) => ... in typescript

[15:47] <discord-raku-bot> <Nemokosch> the pointy block?

[15:48] <discord-raku-bot> <Nemokosch> there are anonymous subs and pointy blocks

[15:48] <discord-raku-bot> <:(**@rest, *%rest)> a type that matches callables with specific signatures

[15:48] *** Air4x joined
[15:49] <discord-raku-bot> <Nemokosch> hmm

[15:50] <discord-raku-bot> <:(**@rest, *%rest)> it would be useful for callbacks

[15:51] <discord-raku-bot> <Nemokosch> the Callable role can have parameters, not sure if they can cover the signature as well

[16:00] <discord-raku-bot> <Nemokosch> I can only see the returns argument

[16:00] <discord-raku-bot> <Nemokosch> actually if I think about it, Callable in itself doesn't know signatures

[16:07] <discord-raku-bot> <:(**@rest, *%rest)> raku conveniently ignored specialized callback type 😭 while almost all langs with typing support it

[16:18] <discord-raku-bot> <Nemokosch> you know, sometimes I wonder what was first: the chicken or the egg

[16:19] <discord-raku-bot> <Nemokosch> power users/devs not really using types, or types being kind of lacky

[16:19] <discord-raku-bot> <Nemokosch> the thing is, Raku's type system is a bit different from Python's or especially Typescript's

[16:22] <discord-raku-bot> <Nemokosch> Typescript is basically a preprocessor language, nothing was expensive because at the end of the day, 95% of its code is going to get discarded in favor of plain old untyped Javascript

[16:23] <discord-raku-bot> <Nemokosch> iirc Python types are also for the linter, basically

[16:23] <discord-raku-bot> <Nemokosch> also, as far as I can remember, Python types are quite messy and inconvenient, both regarding how to obtain them and how the syntax needed to be adopted

[16:24] <discord-raku-bot> <Nemokosch> in Raku, types naturally evolve with the language

[16:24] <discord-raku-bot> <Nemokosch> just slower than the content or the syntax itself

[16:26] *** Air4x left
[16:35] <discord-raku-bot> <:(**@rest, *%rest)> yea but doesn't that say anything about the lack of specialized callback types

[16:38] <discord-raku-bot> <Nemokosch> In those languages, this is just a formality

[16:38] <discord-raku-bot> <Nemokosch> in Raku, it kind of needs to evolve with the actual data structures

[16:38] <discord-raku-bot> <Nemokosch> khm, khm, Hash

[16:39] <discord-raku-bot> <Nemokosch> did you know that the "typed" hash is in fact a different data structure from a banal default Hash?

[16:39] <discord-raku-bot> <Nemokosch> more accurately, it mixes in roles that add code to handle certain behavior

[16:39] <discord-raku-bot> <:(**@rest, *%rest)> raku's is more like php in terms of gradual typing or the other way around coincidentally php also doesn't support signatures on functions

[16:40] <discord-raku-bot> <:(**@rest, *%rest)> real

[16:40] <discord-raku-bot> <Nemokosch> iirc PHP also tries to do runtime checks and stuff

[16:40] <discord-raku-bot> <Nemokosch> rather than linting

[16:41] <discord-raku-bot> <:(**@rest, *%rest)> something like Hash[Str, Int]?

[16:41] *** jgaz joined
[16:56] <discord-raku-bot> <Nemokosch> yes

[16:58] <discord-raku-bot> <Nemokosch> https://github.com/rakudo/rakudo/blob/main/src/core.c/Hash/Object.pm6

[16:58] <discord-raku-bot> <Nemokosch> > my role Hash::Object[::TValue, ::TKey]

[16:58] <discord-raku-bot> <:(**@rest, *%rest)> Hash[Str, Int] is different from Hash hmm

[16:59] <discord-raku-bot> <Nemokosch> well, it's a Hash that has this role mixed in

[16:59] <discord-raku-bot> <Nemokosch> hence overriding certain behavior

[16:59] <discord-raku-bot> <:(**@rest, *%rest)> omg generic types

[16:59] <discord-raku-bot> <Nemokosch> "generic types"

[16:59] <discord-raku-bot> <Nemokosch> "weak typing"

[16:59] <discord-raku-bot> <Nemokosch> when do these terms ever end? 😭

[16:59] <discord-raku-bot> <Nemokosch> let's give them funny Raku-ish names instead

[17:00] <discord-raku-bot> <:(**@rest, *%rest)> type-capturing types 😳

[17:08] <discord-raku-bot> <:(**@rest, *%rest)> i hope signatured callbacks get added in next version tho

[17:09] <discord-raku-bot> <:(**@rest, *%rest)> though i don’t know how to represent it

[17:09] <discord-raku-bot> <:(**@rest, *%rest)> Callable[:(Int, Str, Bool)]?

[17:18] <discord-raku-bot> <:(**@rest, *%rest)> m: my ($first, **@rest) = 1, 2, 3, 4; say @rest; 

[17:19] <discord-raku-bot> <:(**@rest, *%rest)> destructuring uses a signature

[17:19] <discord-raku-bot> <:(**@rest, *%rest)> til

[17:20] <discord-raku-bot> <:(**@rest, *%rest)> m: my ($first, @rest) = 1, 2, 3, 4; say @rest; 

[17:22] <discord-raku-bot> <:(**@rest, *%rest)> why is this behavior 🤔

[17:22] <discord-raku-bot> <:(**@rest, *%rest)> weve talked about it before but it is not how it should work

[17:25] <discord-raku-bot> <:(**@rest, *%rest)> oh wait i found it out &c:(Int, Str, Bool)

[17:26] <discord-raku-bot> <Nemokosch> how to read this?

[17:27] <discord-raku-bot> <Nemokosch> the answer lies within the STORE methon of a List

[17:27] <discord-raku-bot> <Nemokosch> or you mean why this is useful/sensible?

[17:28] <discord-raku-bot> <:(**@rest, *%rest)> a callable &c with signature :(Int, Str, Bool)

[17:28] <discord-raku-bot> <:(**@rest, *%rest)> yeah why it doesn’t match a list of a scalar and an array

[17:30] <discord-raku-bot> <:(**@rest, *%rest)> actually both at the same time

[17:30] <discord-raku-bot> <:(**@rest, *%rest)> how is it done, and why is it desirable

[17:36] *** dakkar left
[17:38] <discord-raku-bot> <:(**@rest, *%rest)> why is WhateverCode not a subclass of blocks

[17:41] <discord-raku-bot> <Nemokosch> pff good question, one at a time

[17:44] <discord-raku-bot> <Nemokosch> for the latter: I think this has its roots in the Perl era where multiple things were arrays and single things were scalars. Most stuff would flatten either way. Then this simple quirk persisted, I think simply because 1. code out there 2. it basically came for free from list assignment, no new syntax required...

[17:44] <discord-raku-bot> <Nemokosch> which gets us to

[17:46] <discord-raku-bot> <Nemokosch> https://github.com/rakudo/rakudo/blob/d5a839672b7b3aeefc57a3fe1f2270e5fc6095d1/src/core.c/List.pm6#L761

[17:46] <discord-raku-bot> <Nemokosch> code that I hoped would be simpler, lol

[17:47] <discord-raku-bot> <Nemokosch> https://github.com/rakudo/rakudo/blob/d5a839672b7b3aeefc57a3fe1f2270e5fc6095d1/src/core.c/List.pm6#L812 look here

[17:48] <discord-raku-bot> <Nemokosch> "if we're pulling something on the left handside that has no containers: STORE all the rest into that

[17:49] <discord-raku-bot> <:(**@rest, *%rest)> how about this

[17:52] <discord-raku-bot> <Nemokosch> I suspect it doesn't really have a scope

[17:52] <discord-raku-bot> <Nemokosch> I've had issues with that kinda stuff

[17:52] <discord-raku-bot> <Nahita> should i do $str.indices($another).elems to count $another in $str both strings?

[17:52] <discord-raku-bot> <:(**@rest, *%rest)> it should have one? because how else are they gonna store their args

[17:53] <discord-raku-bot> <Nahita> or should i do comb & grep andthen elems

[17:53] <discord-raku-bot> <Nahita> idk why there is no .count

[17:53] <discord-raku-bot> <Nahita> or is there?

[17:55] <discord-raku-bot> <Nemokosch> doesn't seem like that, at least :c

[17:57] <discord-raku-bot> <Nemokosch> come to think of it

[17:57] <discord-raku-bot> <Nemokosch> there are barely any core routines that do counting of any sort

[18:03] <raschip> The idiomatic way to do it in Raku is to cast it into a Bag, then the answer will be evident

[18:03] <discord-raku-bot> <Nahita> m: sub t($inp, \n) { my $start = now; $inp.EVAL for ^n;  say "$inp ==> { (now - $start) / n }"; }  t q|("wow" x 1_000).comb.Bag<w>|, 100;  t q|("wow" x 1_000).comb.grep("w").elems|, 100;  t q|("wow" x 1_000).indices("w").elems|, 100; 

[18:04] <discord-raku-bot> <Nahita> m: sub t($inp, \n) { my $start = now; $inp.EVAL for ^n;  say "$inp ==> { (now - $start) / n }"; }  t q|("wow" x 1_000).indices("w").elems|, 100;  t q|("wow" x 1_000).comb.grep("w").elems|, 100;  t q|("wow" x 1_000).comb.Bag<w>|, 100; 

[18:05] <raschip> It's also possible to .grep and then .elems

[18:05] <discord-raku-bot> <Nahita> yeah tried the three

[18:06] <raschip> I like the way they do it i R, they map the list Any --> Bool and them sum it up.

[18:06] <discord-raku-bot> <Nahita> indices seems faster here and locally, but Bag reads better ig idk

[18:06] <discord-raku-bot> <Nemokosch> indices looks solid at least

[18:06] <discord-raku-bot> <Nahita> what is solid meaning

[18:06] <raschip> He doesn't like idiomatic Raku code.

[18:07] <discord-raku-bot> <Nemokosch> like idk if it's deterministically faster

[18:07] <discord-raku-bot> <Nahita> yeah not sure as well

[18:07] <discord-raku-bot> <Nemokosch> but it performed reliably well

[18:07] <discord-raku-bot> <Nahita> hence the 100 trials but

[18:07] <raschip> A Bag is implemented as a Hash, it's fast.

[18:07] <discord-raku-bot> <Nahita> well it was the slowest in my unstatistically backed timings

[18:08] <discord-raku-bot> <Nahita> 3_000 length string, 100 trials

[18:08] <discord-raku-bot> <Nahita> although not sure if optimizations are going on

[18:08] <raschip> Well, the question is: is it fast enough or not?

[18:08] <discord-raku-bot> <Nahita> yeah only curious

[18:09] <raschip> Better: is it fast enough for you?

[18:09] <discord-raku-bot> <Nahita> it is, was only curious

[18:09] <discord-raku-bot> <Nahita> a .count method would make it the most readable

[18:09] <raschip> Yep, it's always good to have benchmarks.

[18:10] <discord-raku-bot> <Nahita> but amongst the options, i'm between indices and Bag

[18:10] <discord-raku-bot> <Nahita> will select one and move on

[18:10] <raschip> I can't see the bot output, btw, discord bot doesn't forward it.

[18:10] <discord-raku-bot> <Nahita> oh sorry

[18:11] <raschip> No problem, just making sure you're aware.

[18:11] <raschip> Bag would make it clear, since that's what Bag is for. If you need to send it, then go for the more cryptic implementation, I would say.

[18:12] <discord-raku-bot> <Nemokosch> more cryptic implementation 😄 you're really making a point here

[18:12] <raschip> Don't go for premature optimization.

[18:14] <discord-raku-bot> <Nemokosch> I don't know the use case but indeed, there can be overlapping matches as well, in theory

[18:15] <raschip> Nahita, do you know the quote about premature optimization?

[18:15] <discord-raku-bot> <Nahita> if you need to send it send to where?

[18:15] <discord-raku-bot> <Nahita> yes yes

[18:15] <raschip> send it is an idiom about racing something, or about rockets

[18:16] <raschip> They talk about 'sending it' meaning racing or launching.

[18:16] <discord-raku-bot> <Nahita> i didn2t know that

[18:17] <discord-raku-bot> <Nahita> i'm actually counting a single character "

[18:20] <discord-raku-bot> <Nahita> i'm going to attempt to write a specific counting function for strings, and probably fail and see it's even slower than current alternatives

[18:21] <discord-raku-bot> <Nahita> actually i could copy the .indices code and count instead of gather indices 😒

[18:24] <discord-raku-bot> <Nemokosch> I wonder if there is a significant potential gain opportunity

[19:02] <discord-raku-bot> <Nahita> well memory-wise, there is, as expected

[19:02] <discord-raku-bot> <Nahita> time-wise... if you have thousands of characters large strings... maybe

[19:02] <raschip> What about programmer time?

[19:02] <discord-raku-bot> <Nahita> m: use nqp;  sub count(str $big, str $small, int $overlap) {     my int $len = $overlap ?? 1 !! nqp::chars($small) || 1;     my int ($pos, $count) = 0, 0;     my int $index;     nqp::while(         nqp::isne_i(($index = nqp::index($big, $small, $pos)), -1),         nqp::stmts(             ++$count,             ($pos = nqp::add_i($index, $len))         )     );     $count }  sub timid($inp, \n) {     my $start

[19:02] <discord-raku-bot> = now;     $inp.EVAL for ^n;     printf "%33s%.3f\n", "$inp ==> ", "{ (now - $start) / n }"; }  my $big = "wow" x 33_333; my $small = "w"; my \n = 10;  timid q|count $big, $small, 0|, n; timid q|$big.indices($small).elems|, n; timid q|$big.comb.Bag{$small}|, n; timid q|$big.comb.grep($small).elems|, n; 

[19:02] <raschip> And code clarity?

[19:03] <discord-raku-bot> <Nahita> a dedicatedly named .count function is the clearest, no?

[19:03] <raschip> right

[19:03] <discord-raku-bot> <Nahita> for IRC, if anyone cares, output is         count $big, $small, 0 ==> 0.025   $big.indices($small).elems ==> 0.032        $big.comb.Bag{$small} ==> 0.146 $big.comb.grep($small).elems ==> 0.112 

[19:16] <discord-raku-bot> <Nemokosch> oh, this code is fairly straightforward

[19:17] <discord-raku-bot> <Nemokosch> something like this could be added to a new language version tbh, no?

[19:20] <raschip> it could, but sometimes they do refuse these things just because there is a way to do it in the language already. If you do submit it as a method in Str depending on use v6.e, it's more likely to be accepted.

[19:22] <discord-raku-bot> <Nemokosch> yes... it seems there was a time around 6.d when some methods (like flatmap in particular) were labelled deprecated with the motive of "it's simple enough already" - but the core community has changed a bit again, and I'd say the language is more in an expanding phase again

[19:27] *** p6steve joined
[19:29] <p6steve> m: +("wow" x 6).indices: <w>

[19:29] <camelia> rakudo-moar d5a839672: OUTPUT: «WARNINGS for <tmp>:␤Useless use of "+" in expression "+(\"wow\" x 6).indices: <w>" in sink context (line 1)␤»

[19:30] <discord-raku-bot> <p6steve> hmmm - works in the repl ... anyway I'm just pointing out that using '+' to coerce the result to a Numeric is an idiomatic way to replace .elems

[19:31] <p6steve> m: my $big = "wow" x 6; say +$big.indices: <w>;

[19:31] <camelia> rakudo-moar d5a839672: OUTPUT: «12␤»

[19:33] <discord-raku-bot> <Nahita> hmm... that + is too "small" in some sense and might hurt readability maybe compared to elems

[19:33] <discord-raku-bot> <Nahita> like

[19:33] <discord-raku-bot> <Nahita>  +$code.substr($idx.succ).indices('"') versus  $code.substr($idx.succ).indices('"').elems 

[19:33] <discord-raku-bot> <Nahita> idk

[19:34] <discord-raku-bot> <Nahita> actually i'm already using it in numeric context with %% so i don't even need to do elems or + huehuehue

[19:34] <discord-raku-bot> <p6steve> yes - I notice that many rakoons prefer to use more 'word-like' approach

[19:36] <discord-raku-bot> <p6steve> ... personally I prefer a more maths-y style ... but I respect that choice and find it easy on the brain (so I would be happy with a count method too ;-)

[19:39] <discord-raku-bot> <p6steve> and conversely, you are saying 'q|$big.indices($small).elems|' which is putting the elems Int into a Str ;-)

[19:39] <discord-raku-bot> <Nahita> oh, that's for EVAL

[19:40] <discord-raku-bot> <Nahita> the %% stuff is in my actual code

[19:41] <discord-raku-bot> <p6steve> no critique intended ... just that raku is a very good mirror and helps us to see and to tune the context of our code

[19:45] <discord-raku-bot> <gfldex> @:(**@rest, *%rest) please note: https://github.com/rakudo/rakudo/issues/5175

[19:45] <discord-raku-bot> <gfldex> Looks like you where the first to ask for a type with a signature constraint.

[20:57] *** raschip left
[23:59] *** jgaz left
