[03:27] *** apogee_ntv left
[03:29] *** apogee_ntv joined
[07:24] *** swaggboi left
[07:48] *** bolangi left
[08:04] *** ACfromTX left
[08:15] *** dakkar joined
[08:18] *** ACfromTX joined
[09:34] <disbot1> <winfredraj> Hello all

[09:35] <disbot1> <winfredraj> If I have a regex match, will I be able to get back the regex from the match result?

[09:35] <disbot1> <librasteve> hi

[09:36] <disbot1> <librasteve> m: dd 'abc' ~~ /b/

[09:36] <disbot1> <Raku eval>  Match.new(:orig("abc"), :from(1), :pos(2)) 

[09:37] <disbot1> <librasteve> yep

[09:38] <disbot1> <winfredraj> m: my $regex = rx/\w+/; my $res = "dddd". match($regex)

[09:38] <disbot1> <Raku eval>  

[09:40] <disbot1> <librasteve> oh - sorry I thought you wanted the original string

[09:40] <disbot1> <librasteve> I dont think you can get the actual regex back from the result

[09:42] <disbot1> <winfredraj> It would be helpful when I use proto and not sure which proto regex matched it

[09:51] <disbot1> <winfredraj> If I have 10 regexes under 1 proto regex and if I want do some manipulation only in the Top regex, then it would be nice to know what regex matched it

[09:52] <disbot1> <winfredraj> If not I will have to maybe have to mark it in the action class method with some sort of an enum

[10:00] <disbot1> <librasteve> yeah I think the action class 'make' routine would be a good way to do that

[10:01] <disbot1> <librasteve> [make and made are really your friends with grammar since the matcher can evolve in complicated ways]

[10:04] <disbot1> <winfredraj> Will $match<multipleproto>.defined and $match<multipleproto:indiv<1>>.defined work??

[10:19] *** ACfromTX left
[10:23] *** ACfromTX joined
[10:27] <disbot1> <winfredraj> m: grammar test {regex TOP {<contact>}; proto regex  contact{}; regex contact:sym<NO> {(\h)}; regex contact:sym<NC> {(/)};}; for test.parse("( )(/)"),contact> -> $contact {say $contact}

[10:27] <disbot1> <Raku eval>  Exit code: 1 ===SORRY!=== Expression needs parens to avoid gobbling block at /home/glot/main.raku:1 ------> /)"),contact> -> $contact {say $contact}⏏<EOL> Missing block (apparently claimed by expression) at /home/glot/main.raku:1 ------> /)"),contact> -> $contact {say $contact}⏏<EOL>  

[10:28] <disbot1> <winfredraj> m: grammar test {regex TOP {<contact>}; proto regex  contact{}; regex contact:sym<NO> {(\h)}; regex contact:sym<NC> {(/)};}; for test.parse("( )(/)")<contact> -> $contact {say $contact}

[10:28] <disbot1> <Raku eval>  ｢( )｣ ｢(/)｣ 

[10:29] <disbot1> <winfredraj> m: grammar test {regex TOP {<contact>}; proto regex  contact{}; regex contact:sym<NO> {(\h)}; regex contact:sym<NC> {(/)};}; for test.parse("( )(/)")<contact> -> $contact {say $contact.defined}

[10:29] <disbot1> <Raku eval>  Exit code: 1 ===SORRY!=== Null regex not allowed.  Please use .comb if you wanted to produce a sequence of characters from a string. at /home/glot/main.raku:1 ------> x TOP {<contact>}; proto regex  contact{⏏}; regex contact:sym<NO> {(\h)}; regex c Proto regex body must be {*} (or <*> or <...>, which are deprecated) at /home/glot/main.raku:1 ------> st {regex TOP {<contact>}; proto regex  ⏏contact{}; regex

[10:29] <disbot1> contact:sym<NO> {(\h)};  

[10:30] <disbot1> <winfredraj> m: grammar test {regex TOP {<contact>}; proto regex  contact{}; regex contact:sym<NO> {(\h)}; regex contact:sym<NC> {(/)};}; for test.parse("( )(/)")<contact> -> $contact {say $contact}

[10:30] <disbot1> <Raku eval>  Exit code: 1 ===SORRY!=== Null regex not allowed.  Please use .comb if you wanted to produce a sequence of characters from a string. at /home/glot/main.raku:1 ------> x TOP {<contact>}; proto regex  contact{⏏}; regex contact:sym<NO> {(\h)}; regex c Proto regex body must be {*} (or <*> or <...>, which are deprecated) at /home/glot/main.raku:1 ------> st {regex TOP {<contact>}; proto regex  ⏏contact{}; regex

[10:30] <disbot1> contact:sym<NO> {(\h)};  

[10:31] <disbot1> <winfredraj> m: grammar test {regex TOP {<contact>}; proto regex  contact{}; regex contact:sym<NO> {(\h)}; regex contact:sym<NC> {(/)};}; for test.parse("( )(/)")<contact> -> $contact {say $contact}

[10:31] <disbot1> <Raku eval>  Exit code: 1 ===SORRY!=== Null regex not allowed.  Please use .comb if you wanted to produce a sequence of characters from a string. at /home/glot/main.raku:1 ------> x TOP {<contact>}; proto regex  contact{⏏}; regex contact:sym<NO> {(\h)}; regex c Proto regex body must be {*} (or <*> or <...>, which are deprecated) at /home/glot/main.raku:1 ------> st {regex TOP {<contact>}; proto regex  ⏏contact{}; regex

[10:31] <disbot1> contact:sym<NO> {(\h)};  

[10:32] <disbot1> <winfredraj> here, I just want to know whether the match was from contact:sym<NO> or contact:sym<NC>

[10:33] <disbot1> <winfredraj> m: grammar test {regex TOP {<contact>}; proto regex  contact{}; regex contact:sym<NO> {(\h)}; regex contact:sym<NC> {(/)};}; for test.parse("( )(/)")<contact> -> $contact {say $contact};

[10:33] <disbot1> <Raku eval>  Exit code: 1 ===SORRY!=== Null regex not allowed.  Please use .comb if you wanted to produce a sequence of characters from a string. at /home/glot/main.raku:1 ------> x TOP {<contact>}; proto regex  contact{⏏}; regex contact:sym<NO> {(\h)}; regex c Proto regex body must be {*} (or <*> or <...>, which are deprecated) at /home/glot/main.raku:1 ------> st {regex TOP {<contact>}; proto regex  ⏏contact{}; regex

[10:33] <disbot1> contact:sym<NO> {(\h)};  

[10:34] <disbot1> <winfredraj> m: grammar test {regex TOP {<contact>}; proto regex  contact{*}; regex contact:sym<NO> {(\h)}; regex contact:sym<NC> {(/)};}; for test.parse("( )(/)")<contact> -> $contact {say $contact}

[10:34] <disbot1> <Raku eval>  Exit code: 1 ===SORRY!=== Error while compiling /home/glot/main.raku Unrecognized regex metacharacter / (must be quoted to match literally) at /home/glot/main.raku:1 ------> sym<NO> {(\h)}; regex contact:sym<NC> {(⏏/)};}; for test.parse("( )(/)")<contact> 

[10:34] <disbot1> <winfredraj> m: grammar test {regex TOP {<contact>}; proto regex  contact{*}; regex contact:sym<NO> {(\h)}; regex contact:sym<NC> {(/)};}; for test.parse("( )(/)")<contact> -> $contact {say $contact}

[10:34] <disbot1> <Raku eval>  Exit code: 1 ===SORRY!=== Unrecognized regex metacharacter / (must be quoted to match literally) at /home/glot/main.raku:1 ------> <NO> {\(\h\)}; regex contact:sym<NC> {\(⏏/\)};}; for test.parse("( )(/)")<contact Malformed regex at /home/glot/main.raku:1 ------> NO> {\(\h\)}; regex contact:sym<NC> {\(/⏏\)};}; for test.parse("( )(/)")<contact>  

[10:35] <disbot1> <winfredraj> m: grammar test {regex TOP {<contact>}; proto regex  contact{*}; regex contact:sym<NO> {(\h)}; regex contact:sym<NC> {(/)};}; for test.parse("( )(/)")<contact> -> $contact {say $contact}

[10:35] <disbot1> <Raku eval>  Nil 

[10:35] <disbot1> <winfredraj> copying and pasting is giving me all sorts of problems

[10:36] <disbot1> <winfredraj> sorry about the mess above

[10:36] <disbot1> <winfredraj> m: grammar test {regex TOP {<contact>}; proto regex  contact{}; regex contact:sym<NO> {(\h)}; regex contact:sym<NC> {(/)};}; for test.parse("( )(/)")<contact> -> $contact {say $contact}

[10:36] <disbot1> <Raku eval>  ｢( )｣ ｢(/)｣ 

[10:37] <disbot1> <winfredraj> finally

[10:37] <disbot1> <winfredraj> m: grammar test {regex TOP {<contact>}; proto regex  contact{}; regex contact:sym<NO> {(\h)}; regex contact:sym<NC> {(/)};}; for test.parse("( )(/)")<contact> -> $contact {say $contact.defined}

[10:37] <disbot1> <Raku eval>  True True 

[10:38] <disbot1> <winfredraj> instead of $contact.defined, how can I use $contact:sym<NO>.defined or something similar

[10:40] <disbot1> <winfredraj> m: grammar test {regex TOP {<contact>}; proto regex  contact{}; regex contact:sym<NO> {(\h)}; regex contact:sym<NC> {(/)};}; for test.parse("( )(/)")<contact> -> $contact {say $contact<NO>}

[10:40] <disbot1> <Raku eval>  Nil Nil 

[10:41] <disbot1> <winfredraj> m: grammar test {regex TOP {<contact>}; proto regex  contact{}; regex contact:sym<NO> {(\h)}; regex contact:sym<NC> {(/)};}; for test.parse("( )(/)")<contact> -> $contact {say $contact:sym<NO>}

[10:41] <disbot1> <Raku eval>  Exit code: 1 ===SORRY!=== Error while compiling /home/glot/main.raku Variable '$contact:sym<NO>' is not declared.  Perhaps you forgot a 'sub' if this was intended to be part of a signature? at /home/glot/main.raku:1 ------> rse("( )(/)")<contact> -> $contact {say ⏏$contact:sym<NO>} 

[10:43] <disbot1> <winfredraj> if nothing, then as recommended by Steve I can try to make an object in the action class for the regex and let it bubble up using make

[10:46] <disbot1> <winfredraj> I was trying to think of the grammar as a class and the regex and the proto regex as a method and though maybe I could pass the :sym<NO> as a hash but it did not work

[10:47] <disbot1> <winfredraj> m: grammar test {regex TOP {<contact>}; proto regex  contact{}; regex contact:sym<NO> {(\h)}; regex contact:sym<NC> {(/)};}; for test.parse("( )(/)")<contact> -> $contact {say $contact(sym => "NO")}

[10:47] <disbot1> <Raku eval>  Exit code: 1 No such method 'CALL-ME' for invocant of type 'test'   in block <unit> at main.raku line 1  

[10:51] <disbot1> <librasteve> dihwidt

[11:05] <disbot1> <winfredraj> doctor, it hurts when I do that -> what does that mean here? am I trying to do something which was not meant to be done?

[11:06] <disbot1> <winfredraj> im not aware of the terms usage, I had to google it up

[12:20] *** ACfromTX left
[12:34] *** ACfromTX joined
[13:00] *** ACfromTX left
[13:02] <disbot1> <librasteve> I was just reflecting that, while grammar is a class and regex is a method, passing in :sym<NO> as a hash might be difficult since the composition of grammar and regex / token is very specialized --- my advice around grammars is limited to "follow the docs examples or it may not work out (ie hurt) if you don't"   [I am sure that there are raku meta coding experts who will happily show you a way since in raku most

[13:02] <disbot1> things are possible]

[13:09] <disbot1> <.landyacht.> I've been bitten by trying to group things together under a proto before when it's easier to just have separate rules like token contact { <NO> | <NC> } .... token NO { '(' \h ')' } ... token NC { '(/)' }

[13:10] <disbot1> <.landyacht.> then I think you could just do $contact<NO>.defined

[13:14] *** ACfromTX joined
[14:23] *** ACfromTX left
[14:37] *** ACfromTX joined
[14:46] *** ACfromTX left
[14:59] <disbot1> <winfredraj> m: grammar test {regex TOP {<contact>}; proto regex  contact{*}; regex contact:sym<NO> {(\h)}; regex contact:sym<NC> {(/)};}; for test.parse("( )(/)")<contact> -> $contact {say $contact.^methods()};

[14:59] <disbot1> <Raku eval>  (sink FALLBACK STORE AT-POS AT-KEY Numeric new iterator BIND-POS BIND-KEY ASSIGN-POS ASSIGN-KEY push append unshift prepend chars chomp chop codes comb contains ends-with flip indent index indices lc lines tc tclc rindex starts-with trans substr subst substr-eq substr-rw wordcase words uc Int gist Str raku Set SetHash Bag BagHash Mix MixHash BUILDALL ords chrs) 

[15:00] <disbot1> <winfredraj> strange I could see all the regexes from the grammar when I ran it directly from my application

[15:01] *** ACfromTX joined
[15:01] <disbot1> <winfredraj> just was trying to see what is possible to make the code cleaner and concise and to avoid boilerplate

[15:03] <disbot1> <winfredraj> I am trying to write a grammar for a ladder diagram programming language and so the options are a lot -> too many ors for my liking

[15:05] <disbot1> <winfredraj> im just going to "make" an object with all the data and will let it bubble up the regexes and see if it offers a clean way out

[16:35] *** dakkar left
[16:54] *** human-blip left
[16:56] *** human-blip joined
[17:35] *** ACfromTX left
[17:48] *** ACfromTX joined
[18:02] *** ACfromTX left
[18:13] *** ACfromTX joined
[18:43] *** habere-et-disper joined
[19:27] *** habere-et-disper left
[20:35] *** disbot1 left
[23:50] *** bolangi joined
