[02:33] *** arkiuat left
[02:46] *** arkiuat joined
[02:50] *** arkiuat left
[03:09] *** arkiuat joined
[03:13] *** arkiuat left
[03:17] *** arkiuat joined
[03:50] *** stanrifkin joined
[03:52] *** stanrifkin_ left
[04:51] <disbot8> <simon_sibl> maybe its because of perl, but I get confuse, the sigil use to tell me whats inside the variable,  $scalar, a @list, a @hash, but now with a for @2d_array -> $1d_array, I cannot tell whats inside anymore just by looking at it

[04:52] <disbot8> <simon_sibl> and perl can have "list" in a scalar but then thats a reference that needs to be dereference by @{} or ->@* which shows whats inside

[05:09] *** Guest81 joined
[05:10] *** Guest81 left
[05:42] *** arkiuat left
[05:45] *** arkiuat joined
[05:50] <disbot8> <jubilatious1_98524> > [Z] is the reduction metaoperator applied to the ordinary Z operator, which is an infix synonym of the zip routine.

[05:50] <disbot8> <jubilatious1_98524> Yeah, that I knew.

[05:50] *** arkiuat left
[06:19] *** arkiuat joined
[06:23] *** arkiuat left
[06:48] *** arkiuat joined
[06:53] *** arkiuat left
[07:05] <disbot8> <librasteve> @simon_sibl … good point … I think the best way to start with raku (esp from a perl background) is to use $scalar, @array and %hash in your code. I think that Larry (Wall) did a good job in maintaining the sigil idea at the “top” level. Then (as you have already seen) the idea of itemizing (aka containers) maps onto perl references … but raku automates that. To keep track of what an Array (or a Hash)

[07:05] <disbot8> contains, then raku types are your friend like my Int @levels;

[07:22] *** arkiuat joined
[07:28] *** librasteve_ joined
[07:28] *** arkiuat left
[07:37] <disbot8> <simon_sibl> oh for what an Array or Hash contains, I can manage, but its knowing what a $var contains xD as you said the reference thing is automated in Raku, so sometimes its "difficult" to know what structure is inside

[07:50] *** human-blip left
[07:52] *** human-blip joined
[07:57] *** arkiuat joined
[08:01] *** hudo_ joined
[08:01] *** arkiuat left
[08:03] *** kjp left
[08:03] *** hudo__ left
[08:06] *** kjp joined
[08:25] *** arkiuat joined
[08:30] *** arkiuat left
[08:43] *** arkiuat joined
[08:48] *** arkiuat left
[09:01] *** arkiuat joined
[09:05] *** arkiuat left
[09:19] *** arkiuat joined
[09:23] *** arkiuat left
[09:43] *** arkiuat joined
[09:48] *** arkiuat left
[10:03] *** cpli left
[10:03] *** cpli joined
[10:19] *** arkiuat joined
[10:24] *** arkiuat left
[10:43] *** arkiuat joined
[10:47] *** arkiuat left
[11:01] *** arkiuat joined
[11:07] *** arkiuat left
[11:19] *** arkiuat joined
[11:24] *** arkiuat left
[11:45] *** arkiuat joined
[11:53] *** arkiuat left
[12:08] *** arkiuat joined
[12:12] *** arkiuat left
[12:20] *** arkiuat joined
[12:25] *** arkiuat left
[12:44] *** arkiuat joined
[12:49] *** arkiuat left
[13:18] *** arkiuat joined
[13:22] *** arkiuat left
[13:47] *** arkiuat joined
[13:51] *** arkiuat left
[14:16] *** arkiuat joined
[14:20] *** arkiuat left
[14:48] *** arkiuat joined
[14:53] *** arkiuat left
[15:12] *** arkiuat joined
[17:01] <disbot8> <shalokshalom> I am looking for a way to perform exhaustive checks on proto, in the same sense that I can with closed sum types.

[17:08] <disbot8> <antononcube> Use outer product.

[17:22] *** librasteve_ left
[19:07] *** habere-et-disper joined
[21:35] *** habere-et-disper left
[22:29] *** arkiuat left
[22:30] *** arkiuat joined
[22:57] *** stanrifkin left
