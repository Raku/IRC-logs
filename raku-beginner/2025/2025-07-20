[04:14] *** librasteve_ left
[04:21] *** human-blip left
[05:17] *** SmokeMachine left
[05:18] *** kjp left
[05:19] *** kjp joined
[05:21] *** SmokeMachine joined
[05:34] *** avuserow left
[05:35] *** avuserow joined
[07:12] *** kjp left
[07:13] *** kjp joined
[07:14] *** kjp left
[07:15] *** kjp joined
[14:00] *** librasteve_ joined
[18:17] *** cliviafreak joined
[18:18] <cliviafreak> I'm trying to figure out how to implement value comparison in objects. Is the best way using WHICH and returning a string representation?

[18:25] <lizmat> if your objects are so-called value types, then the only you need is to have the WHICH method return an ValueObjAt object

[18:25] <lizmat> https://docs.raku.org/type/ValueObjAt

[18:26] <lizmat> method WHICH() { self.^name ~ "|" ~ .... }

[18:27] *** cliviafreak left
[18:40] *** cliviafreak joined
[18:40] <cliviafreak> thank you.

[18:48] <lizmat> cliviafreak:  actually:   method WHICH() { ValueObjAt.new(self.^name ~ "|" ~ ....) }      # forgot that part

[18:51] *** cliviafreak left
[18:59] *** cliviafreak joined
[18:59] <cliviafreak> If you return just a string is it treated differently?

[19:00] <lizmat> well, it actually might, but not always

[19:00] *** msiism joined
[19:02] <msiism> To keep myself on track in terms of learning Raku, I've written a little "hangman"-style word guessing game.

[19:02] <msiism> The code is at https://www.msiism.org/pb/haHM7E/lt.html.

[19:03] <msiism> I'd be very much interested in feedback of virtually any kind, but mostly concerning better use of Raku.

[19:04] <msiism> Prefering routines over methods is intentional, by the way.

[19:06] *** cliviafreak left
[19:19] <lizmat> msiism: clearly coming from Perl  :-)

[19:21] <lizmat> some remarks:  many superstitious parens in if / unless   in Raku they are not needed

[19:21] <lizmat> so: if ($a == $attempts) {    ->      if $a == $attempts {

[19:22] <lizmat> and what do you have against methods being called on objects?

[19:23] <msiism> Okay, right. I prefer the parentheses around the conditions, though, where possible because I find that more readable.

[19:23] <lizmat> also:  for 0 .. (chars($word) - 1) -> $i {    ->    for ^chars($word) -> $i

[19:24] <lizmat> for case insensitive comparison, you should use fc  instead of   lc     that's more unicode safe

[19:24] <msiism> Okay, will do.

[19:25] <lizmat> but again, what's against using methods?

[19:25] <lizmat> also   the "returns Str"  is a bit old-fashioned....     it's better to use -> Str inside the signature

[19:26] <lizmat> so: sub perforate($string) returns Str {    ->  sub perforate($string -> Str) {

[19:26] <msiism> Concerning methods called on objects, I don't have anything against that per se. I guess it's just that I don't think that way. Also, the other languages I use don't work that way.

[19:27] <lizmat> ok

[19:27] <msiism> Oh, right, if I define a type for the return value, it's a good idea to also define input types.

[19:27] <lizmat> also, if you want to make sure you get / return instances, you should add :D to the type

[19:27] <msiism> Okay, I'll read up on that.

[19:27] <lizmat> so: sub perforate($string) returns Str {    ->   sub perforate(Str:D $string --> Str:D) {

[19:28] <lizmat> correction on: "so: sub perforate($string) returns Str {    ->  sub perforate($string -> Str) {"    ->           sub perforate($string --> Str)  {   # must be 2 hyphens

[19:29] <msiism> Oh, I see.

[19:29] <msiism> I had to laugh out loud when you said this looks like coming from Perl, by the way. I've, maybe, written 10 lines of Perl in my life so far. :)

[19:29] <lizmat> also:  if ($success == True) {    ->  if $success

[19:29] <lizmat> ok, C then ?

[19:30] <msiism> Yeah, it probably looks like scripted C, I thought.

[19:30] <lizmat> also, no "return" is needed for the last expression in a block

[19:30] <msiism> Though, the languages I've spent the most time with so far are PHP (abandoned a while ago), sh/Bash, and Racket.

[19:30] <msiism> I see.

[19:31] <lizmat> so: return $result;   ->    $result

[19:31] <lizmat> ok, that's it regarding syntax

[19:32] <msiism> I'd probably prefer `return`, though, because that's less cryptic. I'm trying not to be too cryptic, generally.

[19:32] <msiism> For my own goodâ€¦

[19:33] <lizmat> sure...  at the moment there's a slight performance penalty on return, but that may well go away in the future

[19:33] <lizmat> just for your understanding: "return" in Raku is implemented as a subroutine, that just happens to mess with the stack

[19:34] <msiism> I see.

[19:34] <lizmat> also, for CLI scripts, you might want to have a look at https://docs.raku.org/routine/MAIN

[19:35] <lizmat> msiism: I'd say, it's a good start  :-)

[19:36] <msiism> Okay, thanks a lot! :) I'll go read and fix stuff now.

[21:37] <disbot3> <nahita3882> on &choose_word: instead of picking an appropriate random index and then indexing the list, you can directly pick from the list, i.e., @list.pick or the subroutine form

[21:38] <disbot3> <nahita3882> they made ^N for 0..N-1

[21:39] <disbot3> <nahita3882> instead of iterating over indexes and then indexing a String, you can iterate over its elements after .combing it, e.g., for $string.comb -> $char { ... }

[21:39] <disbot3> <nahita3882> if you also want the index, .kv is one way: for $string.comb.kv -> $idx, $char { ... }

[21:40] <disbot3> <nahita3882> instead of $var = $var OP $other, one can do $var OP= $other, e.g., $result ~= $letter

[21:41] <disbot3> <nahita3882> string interpolation allows say $a, " extra" to be say "$a extra"

[21:43] <msiism> Okay, thanks.

[21:49] <msiism> Yeah, I know about the compound assignment operators. But, as odd as it may sound, I tend to prefer writing out the formula. 

[21:51] <msiism> Kind of easier on the brain -- mine at least. 

[21:55] <msiism> I remember that Ada, for example, deliberately doesn't have those in order to keep code fool-proof. I get the sentiment.

[22:05] <msiism> I'll probably be less inclined to do it that way the more I get to know Raku.

[22:14] *** msiism left
[23:41] *** librasteve_ left
