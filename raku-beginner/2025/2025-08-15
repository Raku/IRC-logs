[00:09] *** stanrifkin left
[00:39] *** librasteve_ left
[00:45] <disbot5> <simon_sibl> Hahaha no worries üòÜ I‚Äôll try those different solution when I arrive at my desk  So far the ‚Äú[Z]  @arr‚Äù seems to be the easiest for me to understand,  I‚Äôll check @nahita3882 answers but I am less familiar with the >> operator for now

[01:14] *** kjp left
[01:15] *** kjp joined
[01:20] *** kjp left
[01:20] *** kjp joined
[01:23] <arkiuat> it's blowing my mind a little bit to realize that [Z] happens to be exactly the matrix-transpose operator (as well as reduced zip, which just happens to mean the same thing)

[01:47] <disbot5> <simon_sibl> > zip has an infix synonym, the Z operator. Shouldn‚Äôt they work the same way ? Why Z works to ‚Äúundo‚Äù zip but zip cannot be used to unzip itself ?

[02:40] <arkiuat> well, Z doesn't undo zip, [Z] undoes it, and the square brackets are the reduction metaoperator. So if you wanted to do all with routines like zip instead of operators like Z, you'd need to involve the reduce routine as well

[02:40] <arkiuat> I'm still trying to figure out the syntax of spelling out [Z] in terms of reduce and zip

[02:44] <disbot5> <simon_sibl> with [Z] @arr returning [(1, 2 ,3), (a, b, c)] is there a way I can assign it to 2 different array ? my (@a, @b) = [Z] @arr; ?

[02:50] <arkiuat> yes, but I don't know how to do without storing the two different arrays you're assigning to in scalar containers

[02:53] <arkiuat> my ($a, $b) = [Z] [Z] (1, 2, 3), <a b c>

[02:53] <arkiuat> you could then reassign, or bind, $a and $b to @-sigiled variables if you like. I don't know how to do it in a single step yet

[02:54] <arkiuat> but if you run that line, you'll find that $a is now (1 2 3) and $b is (a b c)

[02:55] <arkiuat> or as you had it

[02:55] <arkiuat> my @arr = [Z] (1, 2, 3), <a b c>; my ($a, $b) = [Z] @arr

[02:58] <disbot5> <simon_sibl> ah indeed ! okay nice !

[03:10] <lucs> How can I find the index of an element within an array?

[03:10] <lucs> Given for example ¬†my @A = <a b c d> , how can I obtain 2 when looking for 'c'?

[03:11] <lucs> (I've seen a few ways to do it, wondering what a nice idiomatic one would be.)

[03:13] <arkiuat> lucs: use the :k adverb

[03:14] <lucs> Yeah, this works:  @A.first: {$^a eq 'c'}, :k;

[03:15] <lucs> But Raku has spoiled me and I'm wondering if there's something simpler :)

[03:15] <arkiuat> my @A = <a b c d>; say @A.first: { $_ eq 'c' }, :k

[03:15] <arkiuat> hmm. Now I'm wondering too!

[03:15] <lucs> m: my @A = <a b c d>; say @A.first: { $_ eq 'c' }, :k

[03:15] <camelia> rakudo-moar f56482941: OUTPUT: ¬´2‚ê§¬ª

[03:16] <arkiuat> oh cool, last time I tried, camelia wasn't here but only on #raku

[03:19] <arkiuat> m: my @A = <a b c d>; say @A.first: * eq 'c', :k

[03:19] <camelia> rakudo-moar f56482941: OUTPUT: ¬´2‚ê§¬ª

[03:19] <arkiuat> we can save a few chars by using a Whatever and losing the curlies

[03:20] <lucs> It's a bit like golfing, but it remains remarkably readable.

[03:20] <lucs> I guess I'll use that, thanks.

[03:21] <arkiuat> I've been at this long enough that some of the old Perl 5 syntax that can't work in Raku looks alien to me when I run across it, but I'm still kind of in a transitional headspace

[03:22] <arkiuat> since I'm only hobby coding anymore, I had the luxury of being able to put Perl 5 down completely once I got serious about Raku

[03:23] <lucs> Same here.

[03:23] <arkiuat> Nice.

[03:24] <lucs> In a way, a lot of Raku is what Perl was trying to be, but it took many years of experimentation to get there.

[03:25] <arkiuat> I'm actually glad it took so long. I think the result is much better than what we would have gotten if they had rushed the process.

[03:25] <lucs> Absolutely.

[03:37] <disbot5> <simon_sibl> I have the luxury to switch to Raku and put down Perl completely since I have no language restriction at my job xD But I still need Perl since its almost ubiquitous

[03:49] <lucs> simon_sibl: Do you happen to have to maintain some Perl code or just that you need to be able to read it to use some tools written in it?

[03:49] *** arkiuat left
[04:01] <disbot5> <simon_sibl> I am the only one at my work using Perl so...I write and maintain my scripts

[04:02] *** arkiuat joined
[04:02] <disbot5> <simon_sibl> They all love Python but I just cant üòÜ

[04:06] *** arkiuat left
[04:16] *** arkiuat joined
[04:25] <disbot5> <scullucs> Interesting. So at your job, what counts is what your programs produce, not how, or in which language, they're written.

[04:25] <disbot5> <scullucs> As long as that remains the case, I believe you'll be happy to move over to Raku, since like I kinda said earlier, you'll find that Raku does in a much better way what it is you already like how Perl does it. üôÇ

[04:50] <disbot5> <simon_sibl> For next projects I‚Äôll for sure give a try with Raku

[04:57] <disbot5> <scullucs> Please note that it might be a bit overwhelming at first.

[04:58] <disbot5> <scullucs> Raku is a yuge language (in my opinion), but so satisfying to work with when you start getting comfortable with it.

[05:50] <disbot5> <rcmlz> a bit overwhelming, just because you have literally 100 operators to choose from when golfing? üòÄ   https://docs.raku.org/language/operators

[05:55] <disbot5> <rcmlz> I am somehow always expecting that there is that ‚Äûone build-in Raku thing‚Äú that solves my problem in one line.

[06:32] <disbot5> <antononcube> This seems relevant: https://pythonforprediction.wordpress.com/2022/09/18/breakdown-of-python-people-and-projects/

[06:34] <disbot5> <simon_sibl> I will read this xD

[07:32] *** arkiuat left
[07:56] *** arkiuat joined
[08:01] *** arkiuat left
[08:25] *** arkiuat joined
[08:30] *** arkiuat left
[08:37] <disbot5> <jubilatious1_98524> my @x = (1, 2, 3) Z <a b c>; say |@x; say |[Z] @x;

[08:38] <disbot5> <jubilatious1_98524> m: my @x = (1, 2, 3) Z <a b c>; say |@x; say |[Z] @x;

[08:38] <disbot5> <Raku eval>  (1 a)(2 b)(3 c) (1 2 3)(a b c) 

[08:44] <disbot5> <jubilatious1_98524> m: my @x = (1, 2, 3) Z <a b c>; put |@x; put |[Z] @x;

[08:44] <disbot5> <Raku eval>  1 a2 b3 c 1 2 3a b c 

[08:47] <disbot5> <jubilatious1_98524> m: my @x = (1, 2, 3) Z <a b c>; .join(",").put given @x; .join(",").put given [Z] @x;

[08:47] <disbot5> <Raku eval>  1 a,2 b,3 c 1 2 3,a b c 

[09:01] *** arkiuat joined
[09:02] <disbot5> <jubilatious1_98524> It's curious how I have to use say | ... to get a nice visual of the structure of the zip/unzipped arrays in the first example, but the best way to get a visual in the second example is .join(",").put given ....

[09:05] *** arkiuat left
[09:29] *** arkiuat joined
[09:34] *** arkiuat left
[09:41] <disbot5> <nahita3882> > we can save a few chars by using a Whatever and losing the curlies  you can save further by not using a closure, i.e., @a.first("d"):k

[10:03] *** arkiuat joined
[10:07] *** arkiuat left
[10:30] *** arkiuat joined
[10:35] *** arkiuat left
[11:05] *** arkiuat joined
[11:09] *** arkiuat left
[11:20] *** arkiuat joined
[11:25] *** arkiuat left
[11:54] *** arkiuat joined
[11:59] *** arkiuat left
[12:16] *** arkiuat joined
[12:24] *** arkiuat left
[12:37] <SmokeMachine> m: say <a b c d>.first: "c", :k

[12:37] <camelia> rakudo-moar f56482941: OUTPUT: ¬´2‚ê§¬ª

[12:40] <SmokeMachine> (You don‚Äôt need the `* eq `‚Ä¶

[12:55] *** arkiuat joined
[13:00] *** arkiuat left
[13:17] *** arkiuat joined
[13:22] *** arkiuat left
[13:51] *** arkiuat joined
[13:56] *** arkiuat left
[14:13] *** arkiuat joined
[14:15] *** swaggboi joined
[14:17] *** arkiuat left
[14:18] *** arkiuat joined
[14:23] *** arkiuat left
[14:49] *** arkiuat joined
[14:58] <arkiuat> yes, I clearly haven't fully absorbed smartmatch (both all of the contexts in which it is implied, and all of its capabilities)

[14:59] <arkiuat> Those last two examples from nahita3882 and SmokeMachine work because that parameter gets smartmatched

[14:59] <arkiuat> lucs, did you catch that?

[15:55] *** stanrifkin joined
[16:21] *** stanrifkin left
[17:13] <disbot5> <simon_sibl> It seems that currently Raku‚Äôs regex are much slower than Perl (for a basic task I did, Raku was around 20 times slower) I tired rx and // without adverbs Is there a way to speed it up ? (I really don‚Äôt need performance now, it‚Äôs pure curiosity)  That was the simple task, a coderbyte exercise (supposed to be in bash but their bash test env allow to use Perl, and after solving it in Perl I wondered how it would

[17:13] <disbot5> be in Raku) that I tried to see if I would include it in an interview   https://pastecode.dev/s/j2xq4z8k

[17:13] <lucs> arkiuat: Oh, nice, thanks.

[17:26] *** stanrifkin joined
[19:51] *** arkiuat left
[19:55] *** arkiuat joined
