[01:23] *** arkiuat left
[01:36] *** arkiuat joined
[01:41] *** arkiuat left
[02:10] *** arkiuat joined
[02:14] *** arkiuat left
[02:16] *** arkiuat joined
[04:30] *** arkiuat left
[04:42] *** arkiuat joined
[04:47] *** arkiuat left
[05:16] *** arkiuat joined
[05:21] *** arkiuat left
[05:39] *** arkiuat joined
[05:44] *** arkiuat left
[05:53] *** arkiuat joined
[08:23] *** arkiuat left
[08:35] *** arkiuat joined
[08:40] *** arkiuat left
[09:04] *** arkiuat joined
[09:09] *** arkiuat left
[09:37] *** arkiuat joined
[09:42] *** arkiuat left
[10:04] *** arkiuat joined
[10:08] *** arkiuat left
[10:37] *** arkiuat joined
[10:42] *** arkiuat left
[11:05] *** arkiuat joined
[11:09] *** arkiuat left
[11:36] *** arkiuat joined
[11:41] *** arkiuat left
[12:06] *** arkiuat joined
[12:11] *** arkiuat left
[12:30] *** arkiuat joined
[12:35] *** arkiuat left
[13:04] *** arkiuat joined
[13:08] <disbot4> <simon_sibl> I try to understand adverb  sub foo(:$bar = False) { say "=> $bar !" }  very simple sub when I call it foo:!bar it works but when I do foo:bar it doesnt work with: Undeclared routine: foo:bar am I missing something ? I would like to make a "custom" sub/operator like q which accepts adverb

[13:12] *** arkiuat left
[13:18] <lizmat> that's because foo:bar is valid syntax for an identifier

[13:18] <lizmat> whereas "foo:!bar" is not, and so that get's interpreted as foo :!bar

[13:19] <lizmat> it feels like a case of DIHWIDT: just don't say "foo:bar" but "foo :bar"

[13:27] <disbot4> <simon_sibl> How come q:to works then for example

[13:28] <lizmat> because q: is seen by the grammar as a quoting construct, so it never gets to the "possible identifier" part

[13:29] <disbot4> <simon_sibl> So it‚Äôs not possible to create a similar operator ? Or there is a special way to do it ?

[13:30] * lizmat is thinking...

[13:31] <lizmat> it feels you're getting into slang territory

[13:31] <lizmat> and quite deep into that as well

[13:31] <lizmat> could you give an actual code example you have in mind?

[13:32] <disbot4> <simon_sibl> So I am trying to make a very basic lisp interpreter with ‚Äúgrammar‚Äù to train myself  And I thought maybe that would be nice to create a ‚Äúq‚Äù like operator which can execute the lisp code with some adverbs modifier

[13:33] <lizmat> an interesting idea  :-)

[13:34] <disbot4> <simon_sibl> I just started learning Raku coming from Perl, it just seems that ‚Äúeverything‚Äù is possible in this language xD

[13:34] <lizmat> well...  I'd say that's generally true  :-)

[13:37] <disbot4> <librasteve> I have been wondering about making a Markdown slang --- but hearing this I realise that something like M/markdown-goes-here/ may work well --- I know I can make that with prefix: <M> or similar --- but most markdown will be longer multiline text so wonders if possible to make some like M:to/END/  for custom heredoc

[13:38] <lizmat> librasteve simon_sibl  in RakuAST that may actually be not so complicated, but one would have to get into the grammar and quote language handling

[13:39] *** arkiuat joined
[13:39] <disbot4> <librasteve> dang - saly no one has bothered to make a module (like Slangify) for idiots like me

[13:39] <lizmat> I've done a bit in that area, but I would need to re-acquaint myself with that area of the Raku grammar to be able to make sense of that

[13:39] <lizmat> so please make a Rakudo issue for this, so it doesn't fall through the cracks

[13:40] <disbot4> <librasteve> oh - the voice of an expert ;-)

[13:43] <disbot4> <librasteve> I have heard folks moot various low hanging slangs ... markdown, css, json ... to name but three ... but tbh (unless you want syntax highlighting) just a nicer way to grab a source code string and inject into Text::Markdown to return a Str to embed in some web content (of to pass to a LISP compiler) would be just fine

[13:44] *** arkiuat left
[13:58] <disbot4> <simon_sibl> Yeah I‚Äôll first try to make that basic interpreter üòÜ Btw silly question, is there an easy way other than ‚Äúso $var eq any(@array)‚Äù or ‚Äúso @array.grep {$_ eq $var}‚Äù to know if an element is in an array ? Later one is more less how I do it in Perl, maybe there is a clever way to do it in Raku ?

[13:59] <lizmat> @array.first(* eq $var)

[14:07] <disbot4> <simon_sibl> thank you, shorter already !

[14:07] <disbot4> <simon_sibl> similar to the grep one

[14:08] *** arkiuat joined
[14:13] *** arkiuat left
[14:34] *** stanrifkin joined
[14:40] *** arkiuat joined
[14:44] <disbot4> <nahita3882> $var (elem) @array or $var ‚àà @array

[14:46] *** arkiuat left
[14:46] <disbot4> <nahita3882> (elem) and ‚àà are aliases to one another; "is element of" operator of set theory

[14:46] <disbot4> <nahita3882> but RHS doesn't have to be Setty

[14:46] <disbot4> <librasteve> dang - if only I'd thought of that!

[14:47] <disbot4> <nahita3882> to be pedantic, .first is problematic if your $var is Nil because it returns Nil when not found, too

[14:47] <disbot4> <nahita3882> (yes your use of eq implies $var is Stringy but still)

[14:47] <disbot4> <librasteve> yeah - but the idea was to use so xxx and so Nil is False

[14:48] <disbot4> <nahita3882> but if $var is Nil, and the array does contain Nil, it should give True, no?

[14:48] <disbot4> <nahita3882>  >>> [Nil,].first(* eqv Nil).so False 

[14:49] <disbot4> <nahita3882> safe way to use first is with its :k adverb and check if the result is strictly Nil (can't do &so because of the result possibly being 0)

[14:49] <disbot4> <nahita3882> but why bother when they provide ‚àà

[14:50] <disbot4> <librasteve> i prefer  ‚àà

[14:55] <disbot4> <librasteve> fwiw I think that your Nil matches Nil point is debatable - eqv, eq and == are all possible tests depending on what you are working with - and you could make the case that undefined array elems and / or vars should propagate a failure (Nil)

[14:55] <disbot4> <nahita3882> i see

[14:56] <disbot4> <librasteve> (btw I am execting to lose this debate ;-) )

[15:07] <disbot4> <librasteve> m: my @a = 1,2,3, Nil; say Nil ‚àà @a

[15:07] <disbot4> <Raku eval>  False 

[15:07] <disbot4> <librasteve> m: my @a = 1,2,3, Nil; say @a

[15:07] <disbot4> <Raku eval>  [1 2 3 (Any)] 

[15:07] <disbot4> <librasteve> m: my @a = 1,2,3, Nil; say Any ‚àà @a

[15:07] <disbot4> <Raku eval>  True 

[15:09] <disbot4> <librasteve> Assigning Nil has the action of resetting the value of a container (ie the element of an Array) to its default and the default is the type object, in this case (Any)

[15:09] *** arkiuat joined
[15:10] <disbot4> <librasteve> m: my @a = 1,2,3, Nil; my $x; say $x ‚àà @a

[15:10] <disbot4> <Raku eval>  True 

[15:11] <disbot4> <nahita3882> yeah, though container can be stripped out, e.g.,

[15:11] <disbot4> <librasteve> I would say that ‚àà does pretty much what I would want for a non-tytped piece of code

[15:12] <disbot4> <nahita3882> m: my @a; @a[0] := Nil; say Nil ‚àà @a; say so @a.first(Nil); say @a.first(Nil, :k) !=== Nil;

[15:12] <disbot4> <Raku eval>  True False True 

[15:12] <disbot4> <librasteve> well there are other Positional types if you want to get fancy, but I prefere (in the beginner) context to use @ sigil and work with Array

[15:13] <disbot4> <nahita3882> second one is the edge case I was alluding to, which is very-rare-if-ever kind of thing

[15:13] <disbot4> <nahita3882> yeah but @a in my snippet is still an Array

[15:14] *** arkiuat left
[15:14] <disbot4> <librasteve> true, but you had to do some shenanigans to bypass the container

[15:14] <disbot4> <nahita3882> so Arrays having their elements in containers has been a lie?!

[15:14] <disbot4> <nahita3882> this is some interesting language, especially with this container stuff

[15:15] <disbot4> <nahita3882> S/interesting/slightly frustrating/ 30% of the time

[15:15] <disbot4> <librasteve> lol

[15:16] <disbot4> <librasteve> strangely consistent

[15:35] *** arkiuat joined
[15:40] *** arkiuat left
[15:44] <SmokeMachine> m: say so [1,2,3,Nil].first: { $_ === Nil }

[15:45] <disbot4> <simon_sibl> just discovered how to type unicode in Emacs, happiest man now üòÜ

[15:48] <SmokeMachine> Should first return a ‚Ä¶ but True?

[15:53] <SmokeMachine> I mean, if some adverb is passed‚Ä¶

[16:02] <disbot4> <simon_sibl> m: say 5 ‚àà <1 2 3 4 5>

[16:02] <disbot4> <Raku eval>  False 

[16:02] <disbot4> <simon_sibl> did I miss something ?

[16:03] *** arkiuat joined
[16:06] <disbot4> <simon_sibl> m: say 5 ‚àà (1,2,3,4,5)

[16:06] <disbot4> <Raku eval>  True 

[16:07] <disbot4> <simon_sibl> okok, the <> was not making Int obviously

[16:07] <disbot4> <librasteve> <1 2 3 4 5> means "make me a list of IntStr s"

[16:07] <disbot4> <librasteve> angle bracket literals are a bit special

[16:08] <disbot4> <librasteve> <a b c d e> means make me a list of Str s

[16:08] *** arkiuat left
[16:08] <disbot4> <librasteve> m: dd <1/2>

[16:08] <disbot4> <simon_sibl> oh IntStr, so it should still work no ? Since IntStr changes depending of context if I got it correctly

[16:08] <disbot4> <Raku eval>  0.5 

[16:08] <disbot4> <librasteve> and <1/2> is a fraction (aka Rat)

[16:09] <disbot4> <librasteve> normally you are correct, but Sets use WHICH semantics

[16:12] <disbot4> <librasteve> same as '===' operator

[16:13] <disbot4> <simon_sibl> m: dd <1/2 3/4 55>

[16:13] <disbot4> <Raku eval>  (RatStr.new(0.5, "1/2"), RatStr.new(0.75, "3/4"), IntStr.new(55, "55")) 

[16:13] <disbot4> <librasteve> dd is very good to see what you have got

[16:15] <disbot4> <simon_sibl> m: dd +<1 2 3>

[16:15] <disbot4> <Raku eval>  3 

[16:15] <disbot4> <simon_sibl> Hmm

[16:15] <disbot4> <librasteve> yes well + prefix is same as .elems

[16:15] <disbot4> <antononcube> Also, deduce-type from "Data::TypeSystem".

[16:15] <disbot4> <librasteve> (same as in perl iirc)

[16:17] <disbot4> <simon_sibl> m: say ~$_ for <55 104 4578>

[16:17] <disbot4> <Raku eval>  55 104 4578 

[16:18] *** arkiuat joined
[16:18] <disbot4> <simon_sibl> Ah ok with the example I thought it could have translated them to ‚Äúsentence number‚Äù like fifty-five but then would be another issue to choose the language xD

[16:19] <disbot4> <librasteve> yeah I can see why ...

[16:20] <disbot4> <simon_sibl> ‚Äú‚Äù‚Äù my $f = IntStr.new(42, "forty two"); say +$f; # OUTPUT: ¬´42‚ê§¬ª say ~$f; # OUTPUT: ¬´"forty two"‚ê§¬ª ‚Äú‚Äù‚Äù

[16:20] <disbot4> <librasteve> m: dd <55 104 4578>

[16:20] <disbot4> <Raku eval>  (IntStr.new(55, "55"), IntStr.new(104, "104"), IntStr.new(4578, "4578")) 

[16:20] <disbot4> <librasteve> m: dd <55 104 4578> >> .Str

[16:20] <disbot4> <Raku eval>  Exit code: 1 ===SORRY!=== Error while compiling /home/glot/main.raku Unsupported use of >> to do right shift.  In Raku please use: +> or ~>. at /home/glot/main.raku:1 ------> dd <55 104 4578> >>‚èè .Str 

[16:21] <disbot4> <simon_sibl> Oh yeah I need to understand the hyper operators  Seem very powerful also

[16:22] <disbot4> <simon_sibl> Wait it‚Äôs not hyper

[16:22] <disbot4> <librasteve> m: { dd $_.Str } for <55 104 4578> 

[16:22] <disbot4> <Raku eval>  "55" "104" "4578" 

[16:22] <disbot4> <librasteve> m: { dd $_.Str.WHAT } for <55 104 4578>

[16:22] <disbot4> <Raku eval>  Str Str Str 

[16:22] <disbot4> <simon_sibl> Yeah it‚Äôs hyper but there is also the hyper keywords for parallel

[16:23] <disbot4> <librasteve> yeah >> is short for hyper ... but its often a nice way to map a method over all the elems in a list (as i failed to demonstrate ;-))

[16:24] <disbot4> <simon_sibl> I mean it‚Äôs called hyper but there is also the hyper/race no ?

[16:25] <disbot4> <librasteve> correct ... it serves both as a handy alternative for map and it schedules the iterations across parallel cores

[16:26] <disbot4> <librasteve> m: <a b c d>>>.uc.say

[16:26] <disbot4> <Raku eval>  (A B C D) 

[16:27] <disbot4> <librasteve> looks a bit weird when you put immediately after another angle bracket

[16:27] <disbot4> <antononcube> Use ¬ª , then?

[16:28] <disbot4> <librasteve> m: <a b c d>‚â´.uc.say

[16:28] <disbot4> <Raku eval>  Exit code: 1 ===SORRY!=== Error while compiling /home/glot/main.raku Bogus postfix at /home/glot/main.raku:1 ------> <a b c d>‚èè‚â´.uc.say     expecting any of:         infix         infix stopper         statement end         statement modifier         statement modifier loop 

[16:29] <disbot4> <librasteve> good idea

[16:32] <disbot4> <simon_sibl> I thought >> and ¬ª were the same ?

[16:33] <disbot4> <librasteve> me too, I'm stumped on that one

[16:33] <disbot4> <librasteve> m: (<a b c d>)>>.uc.say

[16:33] <disbot4> <Raku eval>  (A B C D) 

[16:34] <disbot4> <librasteve> it works with parens to disambiguate, so my guess is that this is a bug in the raku parser

[16:34] <disbot4> <librasteve> i'll file an issue

[16:37] <disbot4> <librasteve> oh - that's a thinko - still filing

[16:39] <disbot4> <librasteve> https://github.com/rakudo/rakudo/issues/5939

[16:45] <disbot4> <simon_sibl> m: <<a b c d>>>>.uc.say

[16:45] <disbot4> <Raku eval>  (A B C D) 

[16:45] <disbot4> <simon_sibl> m: <a b c d> ‚â´.uc.say

[16:45] <disbot4> <Raku eval>  Exit code: 1 ===SORRY!=== Error while compiling /home/glot/main.raku Confused at /home/glot/main.raku:1 ------> <a b c d>‚èè ‚â´.uc.say     expecting any of:         infix         infix stopper         statement end         statement modifier         statement modifier loop 

[17:34] <disbot4> <librasteve> But, but ‚â´ is 226B MUCH GREATER-THAN, not ¬ª aka BB RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK ??

[17:35] <disbot4> <librasteve> m: <a b c d> ¬ª.uc.say

[17:35] <disbot4> <Raku eval>  Exit code: 1 ===SORRY!=== Error while compiling /home/glot/main.raku Missing ¬´ or ¬ª at /home/glot/main.raku:1 ------> <a b c d> ¬ª.‚èèuc.say 

[17:35] <disbot4> <librasteve> m: <a b c d>¬ª.uc.say

[17:35] <disbot4> <Raku eval>  (A B C D) 

[17:35] <disbot4> <librasteve> phew

[17:35] <disbot4> <librasteve> lizmat: thanks!

[22:00] *** stanrifkin left
[22:42] *** deoac joined
