[02:15] *** jgaz left
[02:45] *** topnep left
[02:46] *** topnep joined
[03:59] *** stanrifkin joined
[04:00] *** stanrifkin_ left
[05:07] <disbot8> <rcmlz> the â€oldâ€œ definition builds rakudo 2022 without problems?

[05:43] <disbot8> <simon_sibl> yeah the "old" definition worked good

[05:44] <disbot8> <simon_sibl> although they have a patch part where they disable some tests

[05:44] <disbot8> <simon_sibl> they say it works when ran manually

[06:56] *** topnep left
[06:58] *** topnep joined
[07:14] *** Guest85 joined
[07:15] *** Guest85 left
[09:06] <disbot8> <rcmlz> That is the advantage/challenge with Nix and Gnuix - they apparently reveal (m)any impurities and force developers to be crystal clear about any dependencies and versions of dependencies and sources for each and every dependency â€¦ and make incompatibilities appear that otherwise might have stay hidden (â€but it works on my system â€¦â€œ sort of mentality)  However, in the light of that â€Cyber Resilience Actâ€œ Liz was

[09:06] <disbot8> talking about in the weekly and all related efforts to make supply chain attacks less likely: being able to reproduce any binary software package bit-by-bit is the foundation - IMHO. If it is not easy to compile a software like Rakudo, how would you know (as a company or private person) you are not running the â€patchedâ€œ-version with some â€extra-featuresâ€œ supplied by your local or foreign Survilance Agency?

[09:11] <disbot8> <rcmlz> So one approach to have a BOM for Raku would be to create and constantly use a Nix or Guix definition (in Nix it is called â€flakeâ€œ these days) that works with the â€â€”pureâ€œ flag - basically assuming an empty system with nothing installed.  Just a thought â€¦ maybe I am misunderstanding things.

[09:21] <lizmat> I think that's roughly the direction we're going to, yes

[10:12] <disbot8> <rcmlz> @simon_sibl The good people maintainng Rakudo on Nix use  icu zlib gmp perl  as build inputs and removing some "dynext" links (L42). I have no idea what that is ... ;-)  https://github.com/NixOS/nixpkgs/blob/nixos-25.05/pkgs/development/interpreters/rakudo/default.nix

[10:49] *** librasteve_ joined
[11:07] *** topnep left
[11:09] *** topnep joined
[13:49] *** librasteve_ left
[13:49] <disbot8> <simon_sibl> with Guix they use channels and commits to get the exact same version

[13:49] <disbot8> <simon_sibl> I will take a look, I will try to help but I am really not used to make packages definition yet ğŸ˜†  I just modified some easy lines to get all to compile except rakudo

[13:53] <disbot8> <antononcube> related to the last comment by Simon ( @simon_sibl ):  1. Which packages from the Raku ecosystem help making new packages? 2. Which one is your favorite?

[13:57] <disbot8> <antononcube> I know that @tbrowder mentions (-ed) "App::Mi6". Also, CommaIDE -- or the corresponding plug-in -- have a wizard for creating a new Raku package. (Or Cro app, and others.)

[14:00] <disbot8> <simon_sibl> oh thats true I dont have experience making Raku packages but I meant Guix packages ğŸ˜† ğŸ™

[16:19] *** ntv left
[17:25] *** topnep left
[17:27] *** topnep joined
[18:42] <disbot8> <winfredraj> Hello all, When I use the character class <print> in a grammar,  it seems to think it is a method or sub and tries to resolve it

[18:42] <disbot8> <winfredraj> Anyway around it??

[18:44] <disbot8> <winfredraj> I get the error Cannot resolve caller print(ladder_actions:U: ladder:D)

[18:44] <disbot8> <winfredraj> Where ladder is the grammar and the ladder_actions is the action

[18:45] <disbot8> <winfredraj> <graph> doesn't through an error, but I need to match "=" so I need print

[18:46] <disbot8> <winfredraj> If I use <:S> I can match but would prefer <print> to include text as well

[19:02] <lizmat> winfredraj which version of Rakudo are you using ?

[19:54] *** habere-et-disper joined
[19:55] <habere-et-disper> Why are the following not equivalent...

[19:55] <habere-et-disper> m: map *.key, grep { .value == 2 }, ( 0 => 1, 1 => 2 )

[19:55] <camelia> rakudo-moar f56482941: ( no output )

[19:55] <habere-et-disper> m: say map *.key, grep { .value == 2 }, ( 0 => 1, 1 => 2 )

[19:55] <camelia> rakudo-moar f56482941: OUTPUT: Â«(1)â¤Â»

[19:55] <habere-et-disper> and:

[19:55] <habere-et-disper> m: say grep { .value == 2, :k }, ( 0 => 1, 1 => 2 )

[19:55] <camelia> rakudo-moar f56482941: OUTPUT: Â«(0 => 1 1 => 2)â¤Â»

[20:23] *** arkiuat joined
[20:24] <arkiuat> habere-et-disper, the :k adverb belongs outside the block in your second form

[20:24] <arkiuat> m: say grep { .value == 2 }, :k, ( 0 => 1, 1 => 2 )

[20:24] <camelia> rakudo-moar f56482941: OUTPUT: Â«(1)â¤Â»

[20:25] <arkiuat> inside the block, the :k is just ignored

[20:26] *** habere-et-disper left
[20:30] <disbot8> <wambash> m: say grep {$_ == 2}, (1, 2), :k

[20:30] <disbot8> <Raku eval>  (1) 

[20:43] *** DarthGandalf left
[20:43] *** DarthGandalf joined
[20:59] *** arkiuat left
[21:04] <disbot8> <nahita3882> it's ignored in the sense that it doesn't do what's desired, but what is happening is that the block always evaluates a 2-length List (Bool, Pair), which, since has length > 0, is considered truthful and &grep behaves like an all-pass filter, i.e., no item will ever be discarded

[21:10] *** arkiuat joined
[21:15] *** arkiuat left
[21:22] *** arkiuat joined
[21:51] *** arkiuat left
[22:04] *** arkiuat joined
[22:12] *** arkiuat left
[22:28] *** arkiuat joined
[22:33] *** arkiuat left
[22:47] *** arkiuat joined
[22:49] *** stanrifkin left
[22:51] *** stanrifkin joined
[22:51] *** stanrifkin left
[23:38] *** habere-et-disper joined
[23:54] *** habere-et-disper left
