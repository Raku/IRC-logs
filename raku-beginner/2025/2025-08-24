[02:15] *** jgaz left
[02:45] *** topnep left
[02:46] *** topnep joined
[03:59] *** stanrifkin joined
[04:00] *** stanrifkin_ left
[05:07] <disbot8> <rcmlz> the „old“ definition builds rakudo 2022 without problems?

[05:43] <disbot8> <simon_sibl> yeah the "old" definition worked good

[05:44] <disbot8> <simon_sibl> although they have a patch part where they disable some tests

[05:44] <disbot8> <simon_sibl> they say it works when ran manually

[06:56] *** topnep left
[06:58] *** topnep joined
[07:14] *** Guest85 joined
[07:15] *** Guest85 left
[09:06] <disbot8> <rcmlz> That is the advantage/challenge with Nix and Gnuix - they apparently reveal (m)any impurities and force developers to be crystal clear about any dependencies and versions of dependencies and sources for each and every dependency … and make incompatibilities appear that otherwise might have stay hidden („but it works on my system …“ sort of mentality)  However, in the light of that „Cyber Resilience Act“ Liz was

[09:06] <disbot8> talking about in the weekly and all related efforts to make supply chain attacks less likely: being able to reproduce any binary software package bit-by-bit is the foundation - IMHO. If it is not easy to compile a software like Rakudo, how would you know (as a company or private person) you are not running the „patched“-version with some „extra-features“ supplied by your local or foreign Survilance Agency?

[09:11] <disbot8> <rcmlz> So one approach to have a BOM for Raku would be to create and constantly use a Nix or Guix definition (in Nix it is called „flake“ these days) that works with the „—pure“ flag - basically assuming an empty system with nothing installed.  Just a thought … maybe I am misunderstanding things.

[09:21] <lizmat> I think that's roughly the direction we're going to, yes

[10:12] <disbot8> <rcmlz> @simon_sibl The good people maintainng Rakudo on Nix use  icu zlib gmp perl  as build inputs and removing some "dynext" links (L42). I have no idea what that is ... ;-)  https://github.com/NixOS/nixpkgs/blob/nixos-25.05/pkgs/development/interpreters/rakudo/default.nix

[10:49] *** librasteve_ joined
[11:07] *** topnep left
[11:09] *** topnep joined
[13:49] *** librasteve_ left
[13:49] <disbot8> <simon_sibl> with Guix they use channels and commits to get the exact same version

[13:49] <disbot8> <simon_sibl> I will take a look, I will try to help but I am really not used to make packages definition yet 😆  I just modified some easy lines to get all to compile except rakudo

[13:53] <disbot8> <antononcube> related to the last comment by Simon ( @simon_sibl ):  1. Which packages from the Raku ecosystem help making new packages? 2. Which one is your favorite?

[13:57] <disbot8> <antononcube> I know that @tbrowder mentions (-ed) "App::Mi6". Also, CommaIDE -- or the corresponding plug-in -- have a wizard for creating a new Raku package. (Or Cro app, and others.)

[14:00] <disbot8> <simon_sibl> oh thats true I dont have experience making Raku packages but I meant Guix packages 😆 🙏

[16:19] *** ntv left
[17:25] *** topnep left
[17:27] *** topnep joined
[18:42] <disbot8> <winfredraj> Hello all, When I use the character class <print> in a grammar,  it seems to think it is a method or sub and tries to resolve it

[18:42] <disbot8> <winfredraj> Anyway around it??

[18:44] <disbot8> <winfredraj> I get the error Cannot resolve caller print(ladder_actions:U: ladder:D)

[18:44] <disbot8> <winfredraj> Where ladder is the grammar and the ladder_actions is the action

[18:45] <disbot8> <winfredraj> <graph> doesn't through an error, but I need to match "=" so I need print

[18:46] <disbot8> <winfredraj> If I use <:S> I can match but would prefer <print> to include text as well

[19:02] <lizmat> winfredraj which version of Rakudo are you using ?

[19:54] *** habere-et-disper joined
[19:55] <habere-et-disper> Why are the following not equivalent...

[19:55] <habere-et-disper> m: map *.key, grep { .value == 2 }, ( 0 => 1, 1 => 2 )

[19:55] <camelia> rakudo-moar f56482941: ( no output )

[19:55] <habere-et-disper> m: say map *.key, grep { .value == 2 }, ( 0 => 1, 1 => 2 )

[19:55] <camelia> rakudo-moar f56482941: OUTPUT: «(1)␤»

[19:55] <habere-et-disper> and:

[19:55] <habere-et-disper> m: say grep { .value == 2, :k }, ( 0 => 1, 1 => 2 )

[19:55] <camelia> rakudo-moar f56482941: OUTPUT: «(0 => 1 1 => 2)␤»

[20:23] *** arkiuat joined
[20:24] <arkiuat> habere-et-disper, the :k adverb belongs outside the block in your second form

[20:24] <arkiuat> m: say grep { .value == 2 }, :k, ( 0 => 1, 1 => 2 )

[20:24] <camelia> rakudo-moar f56482941: OUTPUT: «(1)␤»

[20:25] <arkiuat> inside the block, the :k is just ignored

[20:26] *** habere-et-disper left
[20:30] <disbot8> <wambash> m: say grep {$_ == 2}, (1, 2), :k

[20:30] <disbot8> <Raku eval>  (1) 

[20:43] *** DarthGandalf left
[20:43] *** DarthGandalf joined
[20:59] *** arkiuat left
[21:04] <disbot8> <nahita3882> it's ignored in the sense that it doesn't do what's desired, but what is happening is that the block always evaluates a 2-length List (Bool, Pair), which, since has length > 0, is considered truthful and &grep behaves like an all-pass filter, i.e., no item will ever be discarded

[21:10] *** arkiuat joined
[21:15] *** arkiuat left
[21:22] *** arkiuat joined
[21:51] *** arkiuat left
[22:04] *** arkiuat joined
[22:12] *** arkiuat left
[22:28] *** arkiuat joined
[22:33] *** arkiuat left
[22:47] *** arkiuat joined
[22:49] *** stanrifkin left
[22:51] *** stanrifkin joined
[22:51] *** stanrifkin left
[23:38] *** habere-et-disper joined
[23:54] *** habere-et-disper left
