[03:51] *** stanrifkin_ joined
[03:53] *** stanrifkin left
[06:23] *** kjp left
[06:24] *** kjp joined
[06:28] *** kjp left
[06:28] *** kjp joined
[08:13] *** arkiuat left
[08:26] *** arkiuat joined
[08:34] *** arkiuat left
[08:38] <disbot8> <jubilatious1_98524> m: say <a b c> Z (1, 2, 3);

[08:38] <disbot8> <Raku eval>  ((a 1) (b 2) (c 3)) 

[08:38] <disbot8> <jubilatious1_98524> m: say <a b c> zip (1, 2, 3);

[08:38] <disbot8> <Raku eval>  Exit code: 1 ===SORRY!=== Error while compiling /home/glot/main.raku Two terms in a row at /home/glot/main.raku:1 ------> say <a b c>⏏ zip (1, 2, 3);     expecting any of:         infix         infix stopper         postfix         statement end         statement modifier         statement modifier loop 

[08:51] <disbot8> <jubilatious1_98524> First impression is that zip is a synonym for the [Z] metaoperator, but does not function equivalent to Z infix operator.  HTH.

[09:03] *** arkiuat joined
[09:09] *** arkiuat left
[09:39] *** arkiuat joined
[09:44] *** arkiuat left
[09:55] *** arkiuat joined
[10:00] *** arkiuat left
[10:12] *** arkiuat joined
[10:17] *** arkiuat left
[10:55] *** arkiuat joined
[11:00] *** arkiuat left
[11:13] *** arkiuat joined
[11:29] *** arkiuat left
[11:56] *** arkiuat joined
[12:01] *** arkiuat left
[12:20] *** arkiuat joined
[12:25] *** arkiuat left
[12:52] *** arkiuat joined
[12:56] *** arkiuat left
[13:01] *** librasteve_ joined
[13:15] *** arkiuat joined
[13:20] *** arkiuat left
[13:48] *** arkiuat joined
[13:53] *** arkiuat left
[14:16] *** arkiuat joined
[14:21] *** arkiuat left
[14:49] *** arkiuat joined
[14:53] *** arkiuat left
[15:16] *** arkiuat joined
[15:21] *** arkiuat left
[15:53] *** arkiuat joined
[15:58] *** arkiuat left
[16:07] *** arkiuat joined
[18:37] <arkiuat> [Z] is the reduction metaoperator applied to the ordinary Z operator, which is an infix synonym of the zip routine. The Z metaoperator is completely different, only found prefixed to other binary operators as in Z+ and Z~

[19:02] *** arkiuat left
[19:13] *** arkiuat joined
[19:18] *** arkiuat left
[19:23] *** arkiuat joined
[19:36] *** habere-et-disper joined
[19:47] *** habere-et-disper left
[20:07] *** habere-et-disper joined
[20:08] <habere-et-disper> Here's my confusion...

[20:08] <habere-et-disper> m: my @foo = (1,2,3),(4,5,6); say [Z] @foo;

[20:08] <camelia> rakudo-moar d370e0513: OUTPUT: «((1 4) (2 5) (3 6))␤»

[20:08] <habere-et-disper> m: my @foo = (1,2,3),(4,5,6); say zip @foo;

[20:08] <camelia> rakudo-moar d370e0513: OUTPUT: «(((1 2 3) (4 5 6)))␤»

[20:08] <habere-et-disper> m: my @foo = (1,2,3),(4,5,6); say zip @foo.List;

[20:08] <camelia> rakudo-moar d370e0513: OUTPUT: «((1 4) (2 5) (3 6))␤»

[20:09] <habere-et-disper> So it seems to be something about an array's structure that is less mutable than a list's structure.

[20:25] <arkiuat> It's a matter of item vs list context. The array form naturally provides item context because it has a container.

[20:26] <disbot8> <nahita3882> why &zip "respects" that and [Z] doesn't is a mystery though

[20:26] <disbot8> <nahita3882> and i think discussed before but not sure

[20:26] <arkiuat> Z is the synonym of zip, not [Z]. The latter applies the reduction metaoperator [] to Z

[20:28] <arkiuat> So of the three examples, only the latter two are directly comparable to one another. And the distinction there is list vs item context

[20:28] <arkiuat> Adding the call to .List decontainerizes @foo, exposing the elements.

[20:29] <disbot8> <nahita3882> i don't follow. why [Z] @foo.List and zip @foo.List give the exact same result then, if they are not the same

[20:30] <arkiuat> Because the reduction operator doesn't do much to a single list with an operator designed to take at least two lists

[20:30] <arkiuat> reduction metaoperator that is, sorry

[20:30] <disbot8> <nahita3882> but it does something, [Z], no?

[20:31] <arkiuat> if it's a 2D array though, [Z] will tranpose it

[20:31] <arkiuat> but it won't do anything other than zip or Z to a flat list

[20:31] <arkiuat> a single one, that is

[20:31] <disbot8> <nahita3882> m: my @arr = (1, 2, 3), (4, 5, 6); say ([Z] @arr.List).raku; say (zip @arr.List);

[20:31] <disbot8> <Raku eval>  ((1, 4), (2, 5), (3, 6)).Seq ((1 4) (2 5) (3 6)) 

[20:31] <disbot8> <nahita3882> m: my @arr = (1, 2, 3), (4, 5, 6); say ([Z] @arr.List).raku; say (zip @arr.List).raku;

[20:32] <disbot8> <Raku eval>  ((1, 4), (2, 5), (3, 6)).Seq ((1, 4), (2, 5), (3, 6)).Seq 

[20:32] <disbot8> <nahita3882> maybe I confused myself why the answers are exactly the same here? and not when we take off .List

[20:32] <disbot8> <nahita3882> confused myself but*

[20:33] <arkiuat> m: say [Z] [[1, 2], [3, 4], [5, 6]]

[20:33] <camelia> rakudo-moar d370e0513: OUTPUT: «((1 3 5) (2 4 6))␤»

[20:33] <arkiuat> m: say zip [[1, 2], [3, 4], [5, 6]]

[20:33] <camelia> rakudo-moar d370e0513: OUTPUT: «(([1 2] [3 4] [5 6]))␤»

[20:41] <arkiuat> m: say zip [[1, 2], [3, 4], [5, 6]].List

[20:41] <camelia> rakudo-moar d370e0513: OUTPUT: «((1 3 5) (2 4 6))␤»

[20:42] <arkiuat> so on the other hand, decontainerize the top level of the array, and plain old zip will transpose as well

[20:43] <disbot8> <nahita3882> why does &zip need decontainerization is my question

[20:45] <arkiuat> because zip has arity 2+ and doesn't really do anything to a single flat list but pass it through.

[20:46] <arkiuat> That's why applying the reduction metaoperator to it has no effect in that particular context (single argument, flat list)

[20:46] <arkiuat> m: say zip <a b c>

[20:46] <camelia> rakudo-moar d370e0513: OUTPUT: «((a b c))␤»

[20:47] <arkiuat> there's no activity for [] to reduce. nothing for it to work on.

[20:48] <disbot8> <nahita3882> i understand thanks

[20:48] <arkiuat> cool

[20:56] <disbot8> <nahita3882> or maybe not, sorry...

[20:57] <disbot8> <nahita3882> &zip has arity 2?  but i'm passing 1 thing here, no?:

[20:57] <disbot8> <nahita3882> m: say zip ((1, 2), (3, 4), (5, 6))

[20:57] <disbot8> <Raku eval>  ((1 3 5) (2 4 6)) 

[20:57] <disbot8> <nahita3882> a single List is passed, right?

[20:58] <arkiuat> well, technically it's not arity 2, but if you call it on a single argument, it's a passthru no-op. So *practically* it's arity 2+

[20:59] <disbot8> <nahita3882> but i called it on a single argument, it didn't pass it through, gave something else

[20:59] <disbot8> <nahita3882> is it because of +/*/** shenanigans in the signatures?

[21:02] <arkiuat> I believe the parens in that last example are interpreted as grouping the three arguments provided to zip

[21:04] <arkiuat> And yes, I believe the shenanigans involved may be https://docs.raku.org/language/signatures#Single_argument_rule_slurpy

[21:05] <arkiuat> the notorious single-argument-rule slurpy

[21:06] <arkiuat> notorious and beloved, I should say. I've kinda grown to love it.

[21:23] <disbot8> <nahita3882> i see, thanks again

[21:45] *** habere-et-disper left
[21:51] <disbot8> <cerumod> hi. i want to use the REPL to test out the functionality of a Raku script i'm working on. i'd like to be able to start a REPL, load the script, and then be able to access the variables defined in it, call the functions defined in it, etc. how should i do something like that in Raku? It seems like EVALFILE, use, EVAL, require etc are not what i'm looking for. use is for modules (my script is not a module), and require,

[21:51] <disbot8> (slurp $file).EVAL, EVALFILE, etc don't help; i still get "Undeclared routine" when I try to call a sub defined in the script. i'm guessing there's something i'm missing/misunderstanding here.

[22:01] <disbot8> <cerumod> nevermind, i'm just going to try to convert my script to a module

[22:15] <arkiuat> cerumod, what you want is perfectly reasonable, but the easiest way to get there is just to embed "repl;" inside your script at the breakpoint you want to examine

[22:15] <arkiuat> this method means only one breakpoint at a time, but you can run all the functions in their internal context, access all the variables, etc

[22:16] <arkiuat> I even do this with modules: execution halts when the script gets to the point in the module I want to examine, and then I'm in the REPL with access to all the internal state

[22:30] <disbot8> <cerumod> thanks. looks like i can just put a if (%*ENV<INSIDE_EMACS>) { repl; } in my code and then require seems to work how i was hoping... though then doing something like my $foo = 1; say $foo; gives a "Variable $foo is not declared" error

[22:31] <disbot8> <cerumod> Also seems to be the case even if I just have repl; as a top-level expression

[22:47] *** arkiuat left
[22:47] *** ilbelkyr joined
[22:47] *** nicole is now known as Guest4068

[22:47] *** Guest4068 left
[22:47] *** ilbelkyr is now known as nicole

[22:49] *** arkiuat joined
[22:53] *** arkiuat left
[22:59] *** arkiuat joined
[23:07] <arkiuat> at the top level, REPL won't have access to lexicals etc

[23:41] *** librasteve_ left
