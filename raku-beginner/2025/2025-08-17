[03:12] *** apogee_ntv left
[03:12] *** apogee_ntv joined
[04:09] *** stanrifkin joined
[04:37] *** kjp_ joined
[04:41] *** kjp left
[06:12] <disbot> <simon_sibl> [True, True, True, False].&{[==] @$_} this works

[06:12] <disbot> <simon_sibl>  [True, True, True, False].&[==] this doesnt work

[06:12] <disbot> <simon_sibl> but I dont understand why

[06:18] <disbot> <simon_sibl> trying to do Day2 of AOC 2024, came up with this which work

[06:18] <disbot> <simon_sibl> say "part1: ", $lines>>.words>>.Int.grep({ ([<] @$_ or [>] @$_) and @$_.rotor(2 => -1)>>.map(1 <= (* - *).abs <= 3).&{ [==] @$_.flat } }).elems

[06:18] <disbot> <simon_sibl> but still a bit confused sometimes how List/Array get passed between . and >>

[08:34] <disbot> <simon_sibl> for $lines { m:g/mul '(' (\d+) ',' (\d+) ')' {$part1 += $0*$1}/; .sink for $/[] }; why in this situation, if I dont go over $/[] it wont process all of the matches ?

[09:41] *** habere-et-disper joined
[09:42] <habere-et-disper> What does the adverb :o do ? It appears to be an undocumented quoting construct ?

[09:47] <lizmat> that's in the new Raku grammar, right ?

[09:48] <habere-et-disper> Attempting translation and noticed it in say https://github.com/Raku-L10N/NL/blob/main/NL.l10n

[09:48] <lizmat> aah,... ok

[09:48] <lizmat> well, it's in the new Raku grammar, and it's only active with "use v6.e.PREVIEW

[09:49] <habere-et-disper> Okay -- I was expecting to see it mentioned under quoting constructs at https://docs.raku.org/language/quoting

[09:49] <lizmat> what it does, is that a string like "q:o/%2s/" creates a Format object

[09:49] <lizmat> I guess it should be documented there

[09:50] <lizmat> https://docs.raku.org/type/Format

[09:50] <lizmat> it's a way to speedup printf

[09:51] <lizmat> which is slow, because every time you run a printf, ir runs a grammar and its actions

[09:51] <habere-et-disper> So the long form is :format ?

[09:51] <lizmat> indeed

[09:51] <habere-et-disper> =b

[10:34] *** habere-et-disper left
[11:56] <disbot> <simon_sibl> is it possible to make a block with is nodal ? or any trait actually

[11:59] <lizmat> looking at the candidates of &trait_mod:<is>   only Routine:D is acceptable as an argument for :nodal

[11:59] <lizmat> m: sub a($,$) { }; trait_mod:<is>(&a,:nodal); dd &a.nodal

[11:59] <camelia> rakudo-moar f56482941: OUTPUT: «Bool::True␤»

[12:00] <lizmat> m: my $a = * + *; trait_mod:<is>($a,:nodal)

[12:00] <camelia> rakudo-moar f56482941: OUTPUT: «Cannot resolve caller trait_mod:<is>(WhateverCode:D, :nodal); none of these signatures matches:␤    (Mu:U $child, Mu:U $parent)␤    (Mu:U \child, Mu:U \parent, @subtypes)␤    (Mu:U $child, :DEPRECATED($)!)␤    (Mu:U $type, :rw($)!)␤    (Mu:U…»

[12:00] <disbot> <nahita3882> $thing.&op is a sugar for &op($thing). Here, the operation is &[==], which is itself a sugar for &infix:<==>. So you are effectively invoking &infix:<==>([True, ...]). Although undocumented, and it's suspicious that an "infix" operator (i.e., a binary operator) can take 1 argument (or even 0 too actually), we see from the code that it's coded to return True for 0 and 1 argument cases, no matter the argument.

[12:01] <lizmat> nahita3882 that's to support:

[12:01] <lizmat> m: dd [+]

[12:01] <camelia> rakudo-moar f56482941: OUTPUT: «0␤»

[12:01] <lizmat> and:

[12:01] <lizmat> m: dd [+] 42

[12:01] <camelia> rakudo-moar f56482941: OUTPUT: «42␤»

[12:01] <disbot> <nahita3882> Here, on the other and, [==] is now the "reduction metaoperator" in action with it taking the &infix:<==> as its operator; so it will do the reduction as desired (although it has chain-precedence, so it might slurp all arguments, but i think it still shortcircuits)

[12:02] <disbot> <nahita3882> that's equivalent to [==] [True, ...]

[12:02] <lizmat> m: dd [==]; dd [==] 42

[12:02] <camelia> rakudo-moar f56482941: OUTPUT: «Bool::True␤Bool::True␤»

[12:02] <disbot> <nahita3882> SO, [==] is used in 2 different meanings in those cases, first one doing something not wanted

[12:03] <disbot> <nahita3882> second one i mean

[12:03] <disbot> <librasteve> doesn't every operator in raku have a "natural" value? (so + is 0, * is 1)

[12:04] <disbot> <nahita3882> not every

[12:04] <disbot> <nahita3882> m: [/]

[12:04] <disbot> <Raku eval>  Failed to create container: Failed while sending request: Failed read response: Resource temporarily unavailable (os error 11)

[12:04] <lizmat> m: dd [/]

[12:04] <camelia> rakudo-moar f56482941: OUTPUT: «Failure.new(exception => X::NoZeroArgMeaning.new(name => "infix:</>"))␤»

[12:06] <disbot> <nahita3882> m: say [+&]

[12:06] <disbot> <Raku eval>  Failed to create container: Failed while sending request: Failed read response: Resource temporarily unavailable (os error 11)

[12:06] <disbot> <nahita3882> it's -1

[13:30] *** stanrifkin left
[13:58] <disbot> <simon_sibl> I am not sure to understand, why does this exists ? why not making it behave like the [==] list...

[14:02] <lizmat> m: say [+&]

[14:02] <camelia> rakudo-moar f56482941: OUTPUT: «-1␤»

[14:03] <disbot> <antononcube> Reduction is not the same as function application.

[14:49] <disbot> <nahita3882> yeah there are two different concepts going on there

[14:50] <disbot> <nahita3882> as for why it exists, well personally i'm glad it exists because being able to write f(x) as x.&f makes it more "fluent" if you will

[14:51] <disbot> <nahita3882> you can chain, also depending on the names of functions, readability might increase too if you have more than 3+ applications in sequence

[14:51] <disbot> <nahita3882> f(g(h(x)) is harder to decipher than x.&h.&g.&f

[14:52] <disbot> <nahita3882> if you are fortunate, x => h() => g() => f() also sometimes works

[14:52] <disbot> <nahita3882> it's ==> not =>

[14:59] *** stanrifkin joined
[15:11] *** arkiuat joined
[15:56] *** arkiuat left
[16:17] *** arkiuat joined
[17:08] *** arkiuat left
[17:22] *** arkiuat joined
[17:27] *** arkiuat left
[17:54] *** arkiuat joined
[17:59] *** arkiuat left
[18:05] <disbot> <librasteve> yeah i use backticks in Discord for stuff like ==>

[18:08] *** librasteve_ joined
[18:12] *** arkiuat joined
[18:17] *** arkiuat left
[18:47] *** arkiuat joined
[18:55] *** arkiuat left
[19:23] *** arkiuat joined
[19:27] *** arkiuat left
[19:51] *** arkiuat joined
[19:56] *** arkiuat left
[20:21] *** arkiuat joined
[20:26] *** arkiuat left
[20:52] *** arkiuat joined
[20:57] *** arkiuat left
[21:26] *** arkiuat joined
[22:09] *** arkiuat left
[22:33] *** stanrifkin left
[22:37] *** arkiuat joined
[22:42] *** arkiuat left
[23:21] *** arkiuat joined
