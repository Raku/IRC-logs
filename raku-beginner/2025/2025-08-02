[01:09] *** stanrifkin left
[01:18] *** Manifest0 left
[01:36] *** librasteve_ left
[04:53] *** arkiuat left
[05:06] *** arkiuat joined
[05:11] *** arkiuat left
[05:18] *** kjp left
[05:18] *** kjp joined
[05:24] *** deoac left
[05:39] *** arkiuat joined
[05:44] *** arkiuat left
[05:56] *** arkiuat joined
[06:01] *** arkiuat left
[06:14] *** arkiuat joined
[06:18] *** arkiuat left
[06:30] *** arkiuat joined
[06:39] *** arkiuat left
[06:51] *** arkiuat joined
[06:55] *** arkiuat left
[07:09] *** arkiuat joined
[07:13] *** arkiuat left
[07:25] *** arkiuat joined
[08:29] *** arkiuat left
[08:35] *** arkiuat joined
[08:40] *** arkiuat left
[09:11] *** arkiuat joined
[09:16] *** arkiuat left
[09:16] *** jmcgnh left
[09:17] *** jmcgnh joined
[09:36] *** arkiuat joined
[09:40] *** arkiuat left
[10:09] *** arkiuat joined
[10:14] *** arkiuat left
[10:24] *** Manifest0 joined
[10:37] *** arkiuat joined
[10:41] *** arkiuat left
[11:09] *** arkiuat joined
[11:14] *** arkiuat left
[11:29] *** arkiuat joined
[11:42] *** arkiuat left
[11:54] *** arkiuat joined
[11:58] *** arkiuat left
[12:20] *** arkiuat joined
[12:24] *** arkiuat left
[12:56] *** arkiuat joined
[13:01] *** arkiuat left
[13:24] *** arkiuat joined
[15:33] *** arkiuat left
[15:45] *** arkiuat joined
[15:48] *** Manifest0 left
[15:50] *** arkiuat left
[15:55] *** arkiuat joined
[17:29] *** librasteve_ joined
[17:29] *** human_blip left
[17:32] *** human_blip joined
[19:40] *** arkiuat left
[19:53] *** arkiuat joined
[19:57] *** arkiuat left
[20:09] *** arkiuat joined
[20:31] <disbot4> <Welemtam> Hi! I'm learning OOP in Raku. I got confused by one thing. I defined :  class Human {   has $!name;   has $!age is required;   has $!nationality;      method new($name,$age,$nationality) {     self.bless(:$name,:$age,:$nationality);   }   method is-adult { $!age >= 18; } }  From the Raku guide, overriding the default new method like above allows to pass non-named args (why not). At first, is-adult was complaining that

[20:31] <disbot4> $!age did not always have a value, so I put "is required". But now, I have :   "The attribute '$!age' is required, but you did not provide a value for it.".   I guess it's because of my override of "new", but is there a way to get around that error ?  Thanks!

[20:36] <disbot4> <librasteve> please can you share the code you have to make a new instance?

[20:37] <disbot4> <Welemtam> Sure :   my $john = Human.new('John', 95, 'American');  It uses my new constructor , nothing comes undefined from the caller at least

[20:38] <disbot4> <librasteve> tx

[20:41] <disbot4> <librasteve> looks like a bug to me ... please can you file an issue?

[20:41] <disbot4> <librasteve> (maybe I will be corrected...)

[20:49] <lizmat> Welemtam not a bug: is there a reason you used the ! twigil on the attributes ?

[20:50] <lizmat> it will work if you specify the attributes as:   has $.name;  has $.age;  has $.nationality

[20:50] <disbot4> <Welemtam> To make them private (reading the raku guide at https://raku.guide/#_encapsulation)

[20:51] <lizmat> but you still want to be able to specify them in a .bless, right ?

[20:51] <lizmat> also: do you want to be able to do $john.age to find out the age of $john ?

[20:52] <disbot4> <Welemtam> Well the guide was suggesting to do that in order to define a constructor taking non-named parameters. But maybe that's already a weird idea.

[20:52] <lizmat> no, it's not... it's just that it also affects what .bless accepts

[20:53] <disbot4> <Welemtam> I could imagine that I may want $!age to stay private for encapsulation matters, and only give access to the is-adult method.

[20:53] <lizmat> where did you find the reference to make attributes private that way ?

[20:53] <disbot4> <librasteve> .oO bless args are constrained by the attr definitions ... sorry my bad

[20:53] <lizmat> librasteve  .new is reallly just thin shell around .bless  :-)

[20:54] <lizmat> Welemtam in that case:   has $!age is built

[20:54] <disbot4> <Welemtam> In the link above (raku guide), Â§9.2 defines a class Human, stating that "! is used to explicitly declare that the attribute is private"

[20:54] <lizmat> that will *not* create the accessor, but it *will* allow you to specify the age with .bless

[20:55] <lizmat> ok, we will need to fix that example

[20:55] <disbot4> <Welemtam> Thanks!

[20:56] <lizmat> yw

[20:56] <lizmat> &

[21:00] <disbot4> <Welemtam> Actually the example by itself in the guide is not using bless on private attributes. I did merge Â§9.2 and Â§9.3 samples when playing around "naively" ðŸ™‚

[21:08] *** deoac joined
[21:09] <disbot4> <nahita3882> yeah you cannot bless private attributes

[21:10] <disbot4> <nahita3882> therefore $!attr is required; can never work, I think

[21:10] <disbot4> <nahita3882> therefore the error message could be improved

[21:10] <disbot4> <nahita3882> also if I may rant, the methods taking whatever named args with no issue is annoying

[21:10] <disbot4> <nahita3882> here self.bless takes :name etc. but doesn't use them at all

[21:11] <disbot4> <nahita3882> can do self.bless(:asdasdasdasdas) and it's as okay as it stands now

[21:19] *** msiism joined
[21:24] <msiism> If I have a string of the form 'key: value', what would be an efficient way to extract just the value?

[21:25] <msiism> I mean something like split on ':', and giev me the right side, trimmed of leading and trailing whitespace.

[21:25] <disbot4> <librasteve> m: 'key: value'.split(': ')[1].say

[21:26] <disbot4> <Raku eval>  value 

[21:27] <msiism> Oh, okay.

[21:28] <disbot4> <librasteve> m: 'key: value'.split(':')[1].trim.say

[21:28] <disbot4> <Raku eval>  value 

[21:28] <disbot4> <librasteve> (does both leading and trailing)

[21:29] <msiism> So, I was just confused about Seqs then, it seems.

[21:29] <msiism> I tought you couldn't access individual elements of a Seq by index.

[21:30] *** arkiuat left
[21:31] <msiism> So, is the main difference between Seqs and arrays that Seqs can't be sparse then?

[21:31] <msiism> And are normally consumed during iterationâ€¦

[21:34] <disbot4> <librasteve> https://docs.raku.org/type/Iterable#typegraphrelations

[21:38] <disbot4> <librasteve> in a nutshell, Seq does Iterable, List also does Positional and Array is a mutable List

[21:39] <msiism> Interesting.

[21:41] <disbot4> <librasteve> in raku very many functions return a Seq (ie a lazy, iterate-once list) than can then be exhausted ... assigning to List and Array basically eagerly consumes the Seq

[21:42] <msiism> But, if Seq does not implement Positional, why can you access elements of a Seq by index?

[21:54] *** arkiuat joined
[21:56] <msiism> Okay, "the Seq class does provide some positional subscripting" (https://docs.raku.org/language/list).

[21:58] *** arkiuat left
[22:24] *** arkiuat joined
[22:27] <lizmat> Seq does the PositionalBindFailover role

[22:28] *** arkiuat left
[22:45] *** msiism left
[22:58] *** arkiuat joined
[23:05] *** arkiuat left
[23:27] *** arkiuat joined
[23:32] *** arkiuat left
[23:42] *** deoac left
[23:47] *** arkiuat joined
[23:55] *** arkiuat left
