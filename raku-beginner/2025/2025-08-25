[00:27] *** arkiuat left
[00:37] *** arkiuat joined
[00:42] *** arkiuat left
[01:00] *** arkiuat joined
[01:05] *** arkiuat left
[01:13] <disbot8> <jubilatious1_98524> m: grep({ .value == 2 }, ( 0 => 1, 1 => 2 ), :k).say

[01:13] <disbot8> <Raku eval>  (1) 

[01:13] <disbot8> <jubilatious1_98524> m: say grep({ .value == 2 }, ( 0 => 1, 1 => 2 )):k

[01:13] <disbot8> <Raku eval>  (1) 

[01:14] *** arkiuat joined
[01:23] *** arkiuat left
[01:50] *** arkiuat joined
[01:55] *** arkiuat left
[02:08] *** arkiuat joined
[02:12] *** arkiuat left
[02:18] *** arkiuat joined
[02:48] *** arkiuat left
[02:50] *** arkiuat joined
[03:56] *** topnep left
[03:57] *** topnep joined
[04:39] *** sivoais left
[04:39] *** avuserow left
[04:40] *** sivoais joined
[04:41] *** avuserow joined
[07:40] *** arkiuat left
[07:47] *** arkiuat joined
[07:53] *** arkiuat left
[08:07] *** arkiuat joined
[08:07] *** topnep left
[08:08] *** topnep joined
[08:12] *** arkiuat left
[08:39] *** arkiuat joined
[08:44] *** arkiuat left
[08:58] *** arkiuat joined
[09:02] *** arkiuat left
[09:10] *** arkiuat joined
[09:14] *** arkiuat left
[09:20] <disbot8> <simon_sibl> I dont understand why when making a class, we can use $.something to get setter/getter but inside methods we have to use $!something

[09:25] <lizmat> you don't have to do that: you can also use $.something inside methods (which is the same as self.something.item)

[09:26] <lizmat> and that would be recommended if you intend to make your class subclassable

[09:26] <disbot8> <simon_sibl> how come its allowed to mix between $. and $! ?

[09:26] <lizmat> because they have different semantics 

[09:27] <disbot8> <simon_sibl> has $.name and in a method using $!name, when would this be needed ?

[09:27] <disbot8> <simon_sibl> when I do $.length++ it doesnt change the value, when I do $!length++ it does

[09:28] <lizmat> m: class A { has $.name; method foo() { $.name } }; class B is A { method foo() { "bar" } }; say A.new(:name<foo>).foo

[09:28] <camelia> rakudo-moar f56482941: OUTPUT: «foo␤»

[09:28] <lizmat> m: class A { has $.name; method foo() { $.name } }; class B is A { method foo() { "bar" } }; say B.new(:name<foo>).foo

[09:28] <camelia> rakudo-moar f56482941: OUTPUT: «bar␤»

[09:29] <lizmat> the behaviour of $.lenght++ atm is actually a bug

[09:30] <lizmat> https://github.com/rakudo/rakudo/issues/5908

[09:32] <lizmat> which fix sadly had some ecosystem fallout, and got reverted  :-(

[09:33] <lizmat> https://github.com/rakudo/rakudo/commit/f95f85ac3eb7756159176b245a82ca296d7f9aa5  I mean

[09:36] <disbot8> <simon_sibl> hmmm I see, trying to write a simple linkedlist in Raku to train xD

[09:38] *** arkiuat joined
[09:43] *** arkiuat left
[10:12] *** topnep left
[10:12] *** arkiuat joined
[10:13] *** topnep joined
[10:16] *** arkiuat left
[10:33] *** arkiuat joined
[10:38] *** arkiuat left
[11:08] *** arkiuat joined
[11:13] *** arkiuat left
[11:40] *** arkiuat joined
[11:44] *** arkiuat left
[12:15] *** arkiuat joined
[12:17] *** topnep left
[12:20] *** arkiuat left
[12:21] *** topnep joined
[12:41] *** arkiuat joined
[12:45] *** arkiuat left
[13:13] *** arkiuat joined
[13:14] <disbot8> <winfredraj> Hello lizmat, I am using v2025. 05.

[13:16] <lizmat> hmmm.. I thought I'd fixed that particular wart  hmmm...

[13:16] <lizmat> could you golf the problem down and put it in a gist ?

[13:18] *** arkiuat left
[13:25] <disbot8> <winfredraj> I'll try to get it done today

[13:25] <lizmat> ++winfredraj

[13:25] <disbot8> <winfredraj> After I finish work

[13:43] *** arkiuat joined
[13:54] *** arkiuat left
[14:04] *** ab5tract left
[14:05] *** ab5tract joined
[14:07] *** arkiuat joined
[14:11] *** arkiuat left
[14:22] <disbot8> <librasteve> @simon_sibl ... I was also at this stage in my raku journey and when the pieces fell into place, I felt the need to write this https://rakujourney.wordpress.com/2020/05/07/raku-objects-confusing-or-what/ (mainly as a way to explain it to myself and to help retain the thought)

[14:27] *** arkiuat joined
[14:31] *** arkiuat left
[15:01] *** arkiuat joined
[15:06] *** arkiuat left
[15:14] *** librasteve_ joined
[15:28] *** arkiuat joined
[15:32] *** arkiuat left
[16:05] *** arkiuat joined
[16:10] *** arkiuat left
[16:23] *** arkiuat joined
[16:31] *** topnep left
[16:32] *** topnep joined
[17:47] *** topnep left
[17:49] *** topnep joined
[18:38] *** thowe left
[18:38] *** thowe joined
[19:10] <librasteve_> https://rakudoweekly.blog/2025/08/25/2025-34-computationally-irreducible/

[19:40] *** arkiuat left
[19:43] *** arkiuat joined
[19:48] *** arkiuat left
[19:53] *** topnep left
[19:54] *** topnep joined
[20:09] *** arkiuat joined
[22:21] *** librasteve_ left
[22:24] *** topnep_ joined
[22:27] <lucs> Given the following grammar:

[22:27] <lucs>     grammar Baz { token TOP { <D>+ }; token D { \d+ x+ }; }

[22:27] <lucs> doing:

[22:27] <lucs>     say Baz.parse("111xx2xxx33x")<D>;

[22:27] <lucs> gives:

[22:27] *** topnep left
[22:27] <lucs>     [｢111xx｣ ｢2xxx｣ ｢33x｣]

[22:28] <lucs> Is it possible to wrap that 'x+' so that it gets consumed but not captured, which would result in:

[22:28] <lucs>     [｢111｣ ｢2｣ ｢33｣]

[22:28] <lucs> ?

[23:09] *** arkiuat left
[23:37] *** arkiuat joined
[23:41] *** arkiuat left
[23:59] *** arkiuat joined
