[00:31] *** librasteve_ left
[01:22] *** arkiuat_ left
[01:29] *** arkiuat joined
[04:49] *** arkiuat left
[04:52] *** arkiuat joined
[04:57] *** arkiuat left
[05:06] *** arkiuat joined
[06:30] <disbot> <simon_sibl> is there a way to do a "last" or "return" in a tap block ? to just stop going further if a condition is met (but still execute next time a emit happens)

[07:00] <disbot> <rcmlz> I remember we discussed that here. But I forgot. Could you do a minimal example of your current aporoach in e.g. https://glot.io such that it is easy to ‚Äûrun and play‚Äú by people that want to help?

[07:02] <disbot> <rcmlz> Ideally that minimal code has a few tests attached - although I guess that testing async code is hard, even in Raku :-)

[07:07] <disbot> <rcmlz> @simon_sibl with regards to guix and recent Rakudo+zef. Perhaps you should ping the people that did the previous definition. I guess the intersection of people using Raku and Guix is not that big. Booth not mainstream (yet).

[07:08] <disbot> <simon_sibl> I just realized that last works but the issue is that in my code the condition happens within multiple layer of scope

[07:08] <disbot> <simon_sibl> basically I am not happy with how I deal with this part: https://github.com/4zv4l/rakubin/blob/2ebf44f1a8c8457f4d7dcd58c68a33e2b51929ec/rakubin.raku#L98

[07:09] <disbot> <simon_sibl> I wish I could simply do a "next client" if the data is too big, rather than setting data to "" and continue

[07:10] <disbot> <simon_sibl> I am currently in a pull request discussion to update Rakudo on Guix

[07:16] <disbot> <simon_sibl> nice website btw ! thanks for the info

[08:14] *** dakkar joined
[08:34] <disbot> <rcmlz> I beliefe that fostering ‚ÄûPlease show a minimal example illustrating your problem in a ‚Äûthe most easy runable way‚Äú and make you intentions crystal clear by using testcases‚Äú is a good way to get qualified feedback.

[08:46] *** arkiuat left
[08:58] <disbot> <simon_sibl> I will try to follow this, thanks !

[08:59] *** arkiuat joined
[09:03] *** arkiuat left
[09:32] *** arkiuat joined
[09:37] *** arkiuat left
[09:37] <disbot> <antononcube> Donnie Darko related?

[09:44] <disbot> <simon_sibl> Donnie Darko ?

[09:45] <disbot> <simon_sibl> If that‚Äôs about the movie, I haven‚Äôt watched it (yet?) üòÜ

[09:50] *** arkiuat joined
[09:55] *** arkiuat left
[10:26] *** arkiuat joined
[10:32] *** arkiuat left
[11:02] *** arkiuat joined
[11:06] *** arkiuat left
[11:29] *** arkiuat joined
[11:33] <disbot> <simon_sibl> for the IDs I've got a better idea but not sure how to implement this in good looking Raku basically I give a charset ('a'..'z','A'..'Z',0..9) and I would like a lazy list that do a, b, c ..., aa, ab, ac, ... etc. indefinitely

[11:33] *** arkiuat left
[11:41] <disbot> <simon_sibl> actually bad idea, then people could "guess" other's people paste

[11:42] <disbot> <simon_sibl> or if that works, is it possible to "pick" from an infinite lazy list ? so that it never takes twice the same

[11:44] <disbot> <simon_sibl> m: (0...Inf).pick(5)

[11:44] <disbot> <Raku eval>  Exit code: 1 Cannot .pick from a lazy list onto a List   in block <unit> at main.raku line 1  

[11:44] <disbot> <simon_sibl> oh well

[11:45] <lizmat> .pick already guarantees not picking the same value more than once

[11:45] <lizmat> as opposed to .roll

[11:48] *** arkiuat joined
[11:50] <disbot> <simon_sibl> yes but I would like to use it on a Lazy "unlimited" list

[11:50] <disbot> <simon_sibl> I am trying to find a way to generate random ID without collision

[11:50] <disbot> <simon_sibl> currently I use "roll" on a list and then I append the "time"

[11:50] <disbot> <simon_sibl> but its a bit long

[11:52] <lizmat> m: use v6.e; say (^99999999).roll ~ nano

[11:52] <camelia> rakudo-moar a988e79f9: OUTPUT: ¬´===SORRY!=== Error while compiling <tmp>‚ê§Raku v6.e requires PREVIEW modifier‚ê§at <tmp>:1‚ê§------> use v6.e<HERE>; say (^99999999).roll ~ nano‚ê§¬ª

[11:52] *** arkiuat left
[11:52] <lizmat> m: use v6.e.PREVIEW; say (^99999999).roll ~ nano

[11:52] <camelia> rakudo-moar a988e79f9: OUTPUT: ¬´831959741756986766055807101‚ê§¬ª

[11:52] <lizmat> m: use v6.e.PREVIEW; say (^99999999).roll ~ nano

[11:52] <camelia> rakudo-moar a988e79f9: OUTPUT: ¬´199170751756986769220511769‚ê§¬ª

[11:58] <disbot> <simon_sibl> yeah I thought about nano, but the ID is very long xD

[12:17] <lizmat> if you intend to pick random from 0 to infinity, that's still pretty small  :-

[12:17] <lizmat> )

[12:30] *** arkiuat joined
[12:35] *** arkiuat left
[12:54] <disbot> <simon_sibl> m: (^5000).pick(5)

[12:54] <disbot> <Raku eval>  

[12:54] <disbot> <simon_sibl> cool

[12:56] <disbot> <simon_sibl> if I do this in a loop, how could I maintain a state ?

[12:56] <disbot> <simon_sibl> oh I know

[12:57] <disbot> <simon_sibl> m: say (^5).pick(*)

[12:57] <disbot> <Raku eval>  (4 2 3 0 1) 

[12:57] <disbot> <simon_sibl> then I just gather take on this

[13:01] *** arkiuat joined
[13:05] *** arkiuat left
[13:24] <disbot> <simon_sibl> not great but

[13:24] <disbot> <simon_sibl> my @IDs       = ('a'..'z','A'..'Z',0..9).flat.combinations(4).pick(*); # paste IDs

[13:24] <disbot> <simon_sibl> I will make an array like this, and pop it until its not possible xD

[13:31] *** arkiuat joined
[13:35] *** arkiuat left
[14:05] *** arkiuat joined
[14:10] *** arkiuat left
[14:32] *** arkiuat joined
[14:36] *** arkiuat left
[15:05] *** arkiuat joined
[15:09] *** arkiuat left
[15:33] *** arkiuat joined
[15:37] *** arkiuat left
[15:54] *** arkiuat joined
[16:02] <disbot> <simon_sibl> alright, added a "garbage collector" and a alright ID system

[16:31] *** dakkar left
[21:22] *** arkiuat left
[21:35] *** arkiuat joined
[21:40] *** arkiuat left
[22:04] *** arkiuat joined
[22:10] *** arkiuat left
[22:14] *** arkiuat joined
[22:49] *** disbot left
[22:49] *** disbot joined
