[00:58] *** disbot5 left
[00:58] *** disbot6 joined
[01:52] *** arkiuat left
[02:05] *** arkiuat joined
[02:05] *** destroycomputers left
[02:05] *** destroycomputers joined
[02:09] *** arkiuat left
[02:39] *** arkiuat joined
[02:43] *** arkiuat left
[02:44] *** arkiuat joined
[02:49] *** arkiuat left
[03:00] *** arkiuat joined
[03:09] *** stanrifkin_ joined
[03:12] *** stanrifkin left
[03:21] <disbot6> <jubilatious1_98524> @simon_sibl This might have been mentioned already, but\S+ is probably better (faster?) than <-[\s]>+ . And since you are searching linewise you could do \H+ (for non-horizontal-whitespace characters) instead of \S+.

[03:28] *** stanrifkin_ left
[03:28] *** stanrifkin_ joined
[03:39] <disbot6> <jubilatious1_98524> @simon_sibl otherwise my guess is named-captures in Raku are slow. (for now).

[03:41] <disbot6> <jubilatious1_98524> @simon_sibl BTW, what happens if you try m{ ... } instead of rx{ ... } ?

[03:53] <disbot6> <simon_sibl> I tried with both rx and m, I replaced the <-[\s]>+ with <[\H]>+ and used "simple" group, not matching group (using $0 and $1 instead of the name) but the speed doesnt change much from before

[03:54] <disbot6> <simon_sibl> actually sometimes the one without named group is slower ü´§

[04:01] <disbot6> <jubilatious1_98524> My understanding is it's all due to start-up time. I tried having the code chew on a 6.7MB file and th difference was still ~17 fold.

[04:03] <disbot6> <jubilatious1_98524> Small file (weblog example):  real    0m0.161s user    0m0.199s sys    0m0.029s 

[04:05] <disbot6> <jubilatious1_98524> large txt file (6.7 MB):  real    0m0.265s user    0m0.306s sys    0m0.035s 

[04:05] <disbot6> <jubilatious1_98524> (above time are for your last Raku code example)

[04:36] <disbot6> <rcmlz> Putting code (e.g. a Grammar) in a module and enjoy pre-compilation is also not helping much?

[05:12] <disbot6> <simon_sibl> Perl is around 0m0.007s  How come the difference is so big

[05:36] <disbot6> <simon_sibl> ccccccuegdkcelhdngfhbkhkvbjnigttivicglbgjdtd

[05:36] <disbot6> <simon_sibl> ccccccuegdkcevrgjjvccjvhbhkjihuincbbrkfgvnft

[05:37] <disbot6> <simon_sibl> (wrong manip with yubikey)

[05:52] <disbot6> <simon_sibl> perl unit module Exo;  my regex r is export {     coderbyte \s heroku \/ router   # match coderbyte heroku/router     .+                              # anything until...     request_id \= (<[\S]>+)         # capture the request_id     \s                              # until a space is found     fwd \= \"(<-["]>+)\"            # capture fwd within "" }  would this be enough to get pre-compilation ?

[05:53] <disbot6> <simon_sibl> because it performs worse üòÜ  maybe because it requires extra efforts to import the module ? no idea

[05:55] <disbot6> <simon_sibl>  # with 32mb file (repeated the same content)  # perl /x real    0m0.188s user    0m0.188s sys     0m0.000s  # perl named group real    0m0.141s user    0m0.133s sys     0m0.008s  # raku numbered group real    0m1.943s user    0m2.005s sys     0m0.040s  # raku named group real    0m1.887s user    0m1.961s sys     0m0.028s  # raku using module real    0m1.985s user    0m2.075s sys     0m0.056s 

[05:56] *** arkiuat left
[05:56] <disbot6> <jubilatious1_98524> I just remember 200msec startup. Not sure if that problem has been solved yet. You can see from the numbers I've posted a 6.7 MB file only takes 100ms more time to process as compared to a tiny 3KB file.

[06:04] *** arkiuat joined
[06:05] <disbot6> <simon_sibl> would hyper helps to speed up ?

[06:05] <disbot6> <jubilatious1_98524> There are problems with hyper and regexes, lemme find the Github issue:

[06:08] *** arkiuat left
[06:11] <disbot6> <jubilatious1_98524> Not this one, but close: https://github.com/rakudo/rakudo/issues/5583

[06:17] <disbot6> <jubilatious1_98524> I found it in a comment here: https://github.com/rakudo/rakudo/issues/1235#issuecomment-2902236406

[06:27] <disbot6> <simon_sibl> hmmm indeed

[06:27] <disbot6> <simon_sibl> well so far really dont need performance, but worth noting the difference in speed with Perl

[06:31] <disbot6> <jubilatious1_98524> Yeah, it's something to consider.

[06:53] *** arkiuat joined
[06:58] *** arkiuat left
[07:04] <disbot6> <simon_sibl> I have two questions about this  my @fib = 0, 1, 1, *+* ... Inf 1. How come its so performant ? unlike the sub version which is recursive ? (didnt try with for loop) 2. How does it know with *+* that it should take the two last number from the list and not twice the last one ?

[07:13] <disbot6> <simon_sibl> I guess I could just use {$^a+$^a} for the second question

[07:22] <disbot6> <ng0177> https://discourse.nixos.org/t/development-environments-with-nix/68028/6 just in case s.o. finds this helpful

[07:26] *** arkiuat joined
[07:31] *** arkiuat left
[07:54] *** arkiuat joined
[07:58] *** arkiuat left
[08:39] *** arkiuat joined
[08:44] *** arkiuat left
[08:48] <disbot6> <simon_sibl> I am not sure to understand the str native type, and the difference with Str I wanted to do c_function_init("Name", 23); and the signature is str, uint8 but that one didnt work, I had to change to CArray[uint8] and pass the string as CArray[uint8].new("Name".encode.list, 0)

[08:48] <disbot6> <simon_sibl> if str which is supposed to be C's str isnt a null terminated string then I dont know what it is üòÜ

[08:50] <disbot6> <simon_sibl> and the whole need to use TWEAK when using CStruct I am not sure to understand as well

[08:56] <lizmat> native str is *NOT* a C string

[08:57] <lizmat> it's basically the string type that the VM understands, before it is getting wrapped in the Str class HLL construct

[08:57] <lizmat> which makes it a true object

[08:59] <disbot6> <simon_sibl> I see, so to instantiate a native class which needs a null terminated string, how can I do ? I only could make it work with CArray[uint8] but in the doc I often see Str, but not sure to understand the whole TWEAK and := thing

[09:00] <lizmat> := is binding, which at the lowest level is the only thing NQP and the VM understand

[09:00] <lizmat> when you say:

[09:00] <lizmat> my $a

[09:00] <lizmat> my$a = 42

[09:01] <lizmat> you're creating a Scalar object that binds to lexpad with name "$a", and binds the value 42 to its $!value attribute

[09:01] <lizmat> when you say:

[09:01] <lizmat> my $a := 42

[09:01] <lizmat> you're binding the value 42 to the lexpad with name "$a"

[09:04] <disbot6> <simon_sibl> okay...(still not sure xD)  why is it required for CStruct ?

[09:11] *** arkiuat joined
[09:12] <lizmat> because C doesn't understand Raku's objects, which what it would be if you assigned to it

[09:12] <lizmat> ?

[09:16] <disbot6> <simon_sibl> I mean let's say this happens in a Cstruct my Str $s = "foo" I would expect it to be a char* but here is asks me to do some magic with TWEAK or something, let me try to share a simple code I would expect to work but somehow it doesnt

[09:16] *** arkiuat left
[09:18] <disbot6> <simon_sibl> https://pastecode.dev/s/x6mq4ty5

[09:18] <disbot6> <simon_sibl> I added some comments trying to explain my mind

[09:19] <disbot6> <simon_sibl> no issue with the age field of the string, but the name is a big issue

[09:21] <lizmat> I'm not NativeCall expert, but what happens if you change Str to str in "has Str $.name"

[09:21] <lizmat> perhaps the "is repr" logic takes care of that, but maybe not

[09:22] <lizmat> but really, someone more knowledgeable about NativeCall should give you an answer

[09:22] <lizmat> nine or patrickb on #raku might be of help

[09:24] <disbot6> <simon_sibl> this one compiles: https://pastecode.dev/s/95zdcaeh, but the result is messed up  Hello ! Hi Simon ! R: Hiii Simon, you are 22 ! Z: Hiii , you are 22 ! Z: Hiii Tb, you are 23 ! 

[09:58] *** arkiuat joined
[10:02] <disbot6> <nahita3882> can you share the C code also

[10:03] *** arkiuat left
[10:09] <disbot6> <simon_sibl> its Zig but sure ! (does the IRC bot handles well all the newines ?) zig const std = @import("std"); const print = std.debug.print; const ally = std.heap.page_allocator;  const Human = extern struct {     name: [*:0]const u8,     age: u8, };  export fn zhuman_init(name: [*:0]const u8, age: u8) callconv(.C) *Human {     const h = ally.create(Human) catch @panic("init");     h.* = .{.name = name, .age = age};     return

[10:09] <disbot6> h; }  export fn zhuman_deinit(h: *const Human) callconv(.C) void {     ally.destroy(h); }  export fn zhuman_greet(h: *const Human) callconv(.C) void {     print("Z: Hiii {s}, you are {d} !\n", .{h.name, h.age}); }  export fn greet(name: [*:0]const u8) callconv(.C) void {     print("Hi {s} !\n", .{name}); }  export fn zhuman_test() void {     const h = zhuman_init("Jean", 43);     zhuman_greet(h);     zhuman_deinit(h); } 

[10:10] <disbot6> <nahita3882> Zig I don't know then sorry

[10:10] <disbot6> <nahita3882> no IRC side doesn't handle newlines well

[10:10] <disbot6> <nahita3882> and also when they said the #raku channel they meant on the IRC side, i.e., #raku-irc of here

[10:10] <disbot6> <simon_sibl> ooooh okok xD thanks ! üôè

[10:10] <disbot6> <nahita3882> #raku here serves i don't know what purpose

[10:12] <lizmat> well, for beginners...  but simon_sibl 's questions clearly are no longer beginner questions  :-)

[10:20] <disbot6> <simon_sibl> I found the first issue

[10:21] <disbot6> <simon_sibl> is it possible that explicitly-manage isnt doing its job ?

[10:21] <disbot6> <simon_sibl> instead I simply dupethe string in the Zig code and now it works

[10:21] <disbot6> <simon_sibl> so I guess Raku was freeing even tho I told it not to with explicitly-manage

[10:32] *** arkiuat joined
[10:37] *** arkiuat left
[10:38] <disbot6> <simon_sibl> I sent in #raku-irc , hopefully I will understand xD

[10:57] *** arkiuat joined
[11:01] *** gfldex joined
[11:02] *** arkiuat left
[11:20] *** arkiuat joined
[11:24] *** arkiuat left
[11:58] *** arkiuat joined
[12:03] *** arkiuat left
[14:18] <disbot6> <jubilatious1_98524> {$^a+$^b}?

[14:21] <disbot6> <simon_sibl> oh I means {$^a+$^a} because I was wondering why *+* would take the last 2 elements to calculate the next one (why the * doesnt refer to the same element)

[14:43] <SmokeMachine> Each * you use mean a different argument‚Ä¶

[14:44] <SmokeMachine> m: my &a = * + *; say a 1, 2

[14:44] <camelia> rakudo-moar f56482941: OUTPUT: ¬´3‚ê§¬ª

[14:45] <SmokeMachine> m: my &a = *+*+*; say a 1, 2, 3

[14:45] <camelia> rakudo-moar f56482941: OUTPUT: ¬´6‚ê§¬ª

[14:46] <SmokeMachine> m: my &a = *+*; say &a.signature

[14:46] <camelia> rakudo-moar f56482941: OUTPUT: ¬´(;; $whatevercode_arg_1 is raw, $whatevercode_arg_2 is raw)‚ê§¬ª

[14:47] <SmokeMachine> simon_sibl: üëÜ

[14:49] <disbot6> <simon_sibl> I see thank you üôè

[14:49] <disbot6> <simon_sibl> I am a bit confused with the Array/Seq/List

[14:50] <disbot6> <antononcube> many are...

[14:50] <lizmat> Array and List *can* be lazy, Seq is always lazy

[14:51] <disbot6> <simon_sibl> first one work, but why second one I need to use .List when I use dd the diff is the first one is ((...) (...)) while second is [(...) (...)] and for some reason when its the second one, the .&zip is messed up  say "part1: ", lines>>.words.&zip.map(&sort).&[Z-]>>.abs.sum; say "part1: ", @lines.List>>.words.&zip.map(&sort).&[Z-]>>.abs.sum;

[14:52] <lizmat> .oO( I wonder how this looks on the Discord side )

[14:52] <disbot6> <antononcube> looks great.

[14:53] <lizmat> not so much on the IRC side: very hard to read

[14:53] <disbot6> <antononcube> figured...

[14:57] <disbot6> <simon_sibl> https://pastes.io/foo-62804

[14:57] <disbot6> <simon_sibl> better ? xD

[14:58] <lizmat> yes

[14:58] <lizmat> so how does @lines get filled ?

[15:00] <disbot6> <simon_sibl> from stdin, from advent of code 2024, day 1

[15:02] <lizmat> ?

[15:15] *** disbot6 is now known as disbot

[15:27] <disbot> <simon_sibl> lines contains each line of the input, reading the file line by line

[15:27] <disbot> <simon_sibl> @lines*

[15:28] <disbot> <simon_sibl> my @lines = lines

[15:31] <disbot> <simon_sibl> my main question is why [(3, 4), (4, 3), (6 ,8)].&zip different than ((3, 4), (4, 3), (6 ,8)).&zip

[15:31] <disbot> <simon_sibl> m: ((3, 4), (4, 3), (6 ,8)).&zip.say

[15:31] <disbot> <Raku eval>  ((3 4 6) (4 3 8)) 

[15:31] <disbot> <simon_sibl> m: [(3, 4), (4, 3), (6 ,8)].&zip.say

[15:31] <disbot> <Raku eval>  (((3 4) (4 3) (6 8))) 

[16:04] <disbot> <nahita3882> because Array puts its elements into containers, they are itemized, they are Scalars, single things; so when iterated, they yield 1 thing instead of N things they truly are composed of

[16:04] <disbot> <nahita3882> m: [(3, 4), (4, 3), (6 ,8)].[0].raku.say

[16:04] <disbot> <Raku eval>  $(3, 4) 

[16:04] <disbot> <nahita3882> m: ((3, 4), (4, 3), (6 ,8)).[0].raku.say

[16:04] <disbot> <Raku eval>  (3, 4) 

[16:04] <disbot> <nahita3882> see the $?

[16:05] <disbot> <nahita3882> m: .say for $(3, 4)

[16:05] <disbot> <Raku eval>  (3 4) 

[16:05] <disbot> <nahita3882> m: .say for (3, 4)

[16:05] <disbot> <Raku eval>  3 4 

[16:06] <disbot> <nahita3882> there are some ways to decontainerize the elements, that's what I was rambling about the other day

[16:06] <disbot> <nahita3882> e.g.,

[16:07] <disbot> <nahita3882> m: [(3, 4), (4, 3), (6 ,8)].map(*.self).&zip.say

[16:07] <disbot> <Raku eval>  ((3 4 6) (4 3 8)) 

[16:07] <disbot> <nahita3882> this distinction between arrays and lists this way is bad I think but what do i know

[16:13] <disbot> <simon_sibl> aaah okay I see I see, I get it know üôè

[16:13] <disbot> <simon_sibl> thank you so much

[16:32] <disbot> <librasteve> m: say <a b c d>.grep: 'c', :k 

[16:32] <disbot> <Raku eval>  (2) 

[16:45] *** human_blip left
[16:46] *** human_blip joined
[17:13] <disbot> <simon_sibl> the more I use it, the more I prefer it over Perl on my side, except Perl being (more) ubiquitous, no reason not to use Raku for my job (other downside would be performance, but so far I never had a project that required to squeeze seconds of runtime)

[17:37] <disbot> <antononcube> Performance of Raku is the major impairment in my machine learning applications of it.

[17:37] <disbot> <antononcube> Still, it can be used..

[22:22] <disbot> <librasteve> crag-of-the-day ?^<TNT energy in J/kg> 

[22:24] <disbot> <librasteve> 4184000J/kg

[22:33] <disbot> <librasteve> sure, on performance, raku is not as fast as eg Python numpy since we do not have these optimized libraries (yet) - I have not yet found a situtation where raku compile or execution speed is an issue (usually speed of writing / fixing code is my bottleneck)

[23:50] *** stanrifkin_ left
