[00:00] *** kjp left
[00:01] *** kjp joined
[00:11] *** kjp left
[00:11] *** kjp joined
[02:05] <avuserow> bisect: my %votes = :ak[{"id" => 1}]; my %v = %votes.deepmap(-> $c is copy {$c}); dd %v; say shift %v<ak>

[02:14] <avuserow> that ^ seems to have changed between 2024.09 and 2025.03

[02:15] <avuserow> 2024.09: {:ak($[:id(1)])} \n id => 1

[02:15] <avuserow> 2025.03: {:ak(:id(1))} \n Cannot resolve caller shift(Pair:D); none of these signatures matches: (@a)

[02:18] <avuserow> my comments claimed I needed to copy it so I could mutate it, but it seems to work without it. not sure how true that ever was :shrug:

[02:22] *** arkiuat left
[02:30] *** arkiuat joined
[02:34] *** arkiuat left
[02:57] *** arkiuat joined
[03:01] *** arkiuat left
[03:05] <avuserow> since my data isn't actually nested, a deepmap is not actually needed so I can use map instead: my %v = %votes.map(-> \c is copy {c})

[03:08] *** arkiuat joined
[05:15] *** arkiuat left
[05:23] *** arkiuat joined
[06:44] <disbot4> <simon_sibl> if I have a hash and want to store another hash in it, do I have to use %hash{$key} = {...=>...} or %hash{$key} = (...=>...) ? I tried using %hash{$key} = ...=>... but it doesnt seem to work as it does to declare a new hash;

[06:44] <disbot4> <simon_sibl> m: dd my %h = foo => bar;

[06:44] <disbot4> <Raku eval>  Exit code: 1 ===SORRY!=== Error while compiling /home/glot/main.raku Undeclared routine:     bar used at line 1. Did you mean 'bag', 'VAR'?  

[06:45] <disbot4> <simon_sibl> m: dd my %h = foo => 'bar';

[06:45] <disbot4> <Raku eval>  Mu %h = {:foo("bar")} 

[06:45] <disbot4> <simon_sibl> m: dd my %h = {foo => 'bar'};

[06:45] <disbot4> <Raku eval>  Potential difficulties:     Useless use of hash composer on right side of hash assignment; did you mean := instead?     at /home/glot/main.raku:1     ------> dd my %h = {foo => 'bar'}⏏; Mu %h = {:foo("bar")} 

[06:51] <disbot4> <simon_sibl> m: dd my %h = foo => {bar => 'toto'};

[06:51] <disbot4> <Raku eval>  Mu %h = {:foo(${:bar("toto")})} 

[06:59] <disbot4> <simon_sibl> what does the ${} or $() means here ?

[08:22] <disbot4> <simon_sibl> I am a bit confused

[08:23] <disbot4> <simon_sibl> m: say zip <1 2 3>, <a b c>

[08:23] <disbot4> <Raku eval>  ((1 a) (2 b) (3 c)) 

[08:23] <disbot4> <simon_sibl> m: my @arr = zip <1 2 3>, <a b c>; say zip |@arr

[08:23] <disbot4> <Raku eval>  (((1 a) (2 b) (3 c))) 

[08:24] <disbot4> <simon_sibl> why this doesnt return ((1 2 3) (a b c))

[08:28] <disbot4> <librasteve> @simon_sibl i would say unless you want IntStr, then bear in mind that the comma is the list operator in raku

[08:29] <disbot4> <librasteve> m: say zip <1 2 3>, <a b c>

[08:29] <disbot4> <Raku eval>  ((1 a) (2 b) (3 c)) 

[08:30] <disbot4> <librasteve> just reproding your question..

[08:31] <disbot4> <librasteve> m: my @a = zip <1 2 3>, <a b c>; say |@a

[08:31] <disbot4> <Raku eval>  (1 a)(2 b)(3 c) 

[08:31] *** RakuIRCLogger left
[08:33] <disbot4> <librasteve> when you go zip |@a then zip is just getting a single list as its first argument, there is no second argument - so it a no op

[08:38] *** librasteve_ joined
[08:46] <disbot4> <simon_sibl> but I thought |@ was to use a list as multiple arguments and since the array contains multiple list it would give those as arguments to zip

[08:49] <disbot4> <simon_sibl> what would be the way to unzip a list of list then ?

[09:08] <disbot4> <simon_sibl> my @a = zip <1 2 3>, <a b c>; dd(|@a)

[09:09] <disbot4> <simon_sibl> m: my @a = zip <1 2 3>, <a b c>; dd(|@a)

[09:09] <disbot4> <Raku eval>  Mu @a = $(IntStr.new(1, "1"), "a") Mu @a = $(IntStr.new(2, "2"), "b") Mu @a = $(IntStr.new(3, "3"), "c") 

[09:09] <disbot4> <simon_sibl> here it seems to give the different list as multiple arguments, but for zip it doesnt seem to be the case ?

[09:09] <disbot4> <simon_sibl> m: my @a = zip (1, 2, 3), <a b c>; dd(|@a) # without IntStr

[09:09] <disbot4> <Raku eval>  Mu @a = $(1, "a") Mu @a = $(2, "b") Mu @a = $(3, "c") 

[09:30] *** arkiuat left
[09:53] *** camelia joined
[10:00] *** arkiuat joined
[10:05] *** arkiuat left
[10:19] *** arkiuat joined
[10:27] *** arkiuat left
[10:38] *** arkiuat joined
[10:41] <disbot4> <librasteve> sorry $day-job

[10:41] <disbot4> <librasteve> intervened

[10:43] *** arkiuat left
[10:47] <disbot4> <librasteve> zip iterates through each of the input lists synchronously, 'Zipping' them together, so that elements are grouped according to their input list index, in the order that the lists are provided.

[10:49] <disbot4> <librasteve> A Slip is a List that automatically flattens into an outer List (or other list-like container or iterable).

[10:50] <disbot4> <librasteve> tbh, though dd is generally very good, I think it is getting in the way of understanding here

[11:03] <disbot4> <librasteve> i think the best way to illustrate what the '|' Slip is doing is this:

[11:04] <disbot4> <librasteve> m: my @x = 1,2,3;my @y = <a b c>;say @x, @y;

[11:04] <disbot4> <Raku eval>  [1 2 3][a b c] 

[11:04] <disbot4> <librasteve> m: my @x = 1,2,3;my @y = <a b c>;say (|@x, |@y);

[11:04] <disbot4> <Raku eval>  (1 2 3 a b c) 

[11:06] <disbot4> <librasteve> afaiui '|' expands an inner list into an outer one, it does not have the power to make multiple lists

[11:06] <disbot4> <librasteve> [usually this is the point when a proper expert tells me I am wrong ;-) ]

[11:10] *** arkiuat joined
[11:12] <disbot4> <simon_sibl> I think I get it a bit "sad' xD the first thing I get when googling how to unzip a list is this code (python) python list(zip(*l))  I thought translating this to Raku would work but it seems the * and | behave slightly different

[11:15] *** arkiuat left
[11:29] <disbot4> <librasteve> oh I guess I see you are trying to reverse the action of zip - I think that there is a raku idiom for this but cant find it at the moment

[11:33] <lizmat> rotor ?

[11:37] *** arkiuat joined
[11:47] *** arkiuat left
[11:47] *** lizmat left
[11:48] *** lizmat joined
[11:59] *** arkiuat joined
[12:00] <disbot4> <simon_sibl> how would you unzip a list using rotot ?

[12:00] <lizmat> m: dd (1..12).rotor(3)

[12:00] <camelia> rakudo-moar f56482941: OUTPUT: «((1, 2, 3), (4, 5, 6), (7, 8, 9), (10, 11, 12)).Seq␤»

[12:01] <lizmat> maybe I'm misunderstanding the problem?

[12:04] *** arkiuat left
[12:20] *** arkiuat joined
[12:25] *** arkiuat left
[12:55] *** arkiuat joined
[13:00] *** arkiuat left
[13:03] <disbot4> <simon_sibl> if I have a  list like this ( (1 ,a), (2, b), (3, c)) that I got using zip (1, 2, 3), <a b c>, how can I undo this operation

[13:21] <lizmat> m: say gather ( (1 ,"a"), (2, "b"), (3, "c")).map( { state @left; state @right; @left.push(.[0]); @right.push(.[1]); LAST { take @left.List; take @right.List } } )    # a very convoluted way, probably better to wrap this in a sub

[13:21] <camelia> rakudo-moar f56482941: OUTPUT: «((1 2 3) (a b c))␤»

[13:29] *** arkiuat joined
[13:34] *** arkiuat left
[13:44] *** swaggboi left
[14:03] *** arkiuat joined
[14:08] *** arkiuat left
[14:30] *** arkiuat joined
[14:34] *** arkiuat left
[14:37] <disbot4> <librasteve> lol - looks like Python wins that one!

[14:38] <disbot4> <librasteve> (there must be a better way)

[14:39] <lizmat> so what would we call such a functionality ?

[15:00] <disbot4> <librasteve> unzip I guess

[15:01] <disbot4> <librasteve> m: my @z = zip <1 2 3>, <a b c>; put @z.map(*[$_]) for ^2 ;

[15:01] <disbot4> <Raku eval>  1 2 3 a b c 

[15:02] <disbot4> <librasteve> ^ this is the best I can come up with

[15:03] *** arkiuat joined
[15:07] <disbot4> <librasteve> oh wait

[15:07] <disbot4> <librasteve> m: my @z = zip <1 2 3>, <a b c>; say [Z] @z;

[15:07] <disbot4> <Raku eval>  ((1 2 3) (a b c)) 

[15:08] *** arkiuat left
[15:08] <disbot4> <librasteve> m: my @z = <1 2 3> Z <a b c>; say [Z] @z;

[15:08] <disbot4> <Raku eval>  ((1 2 3) (a b c)) 

[15:09] <disbot4> <librasteve> looks cooler if we use the Z meta operator to do the zip in the first place

[15:10] <disbot4> <librasteve> idioms by idiots™

[15:12] <disbot4> <rcmlz> https://andrewshitov.com/2019/09/09/how-to-transpose-a-matrix-in-perl-6/

[15:12] <disbot4> <librasteve> note - helps to think of this as a 2D array, then I realised its the same idiom as transpose and voilà

[15:13] <disbot4> <rcmlz> https://glot.io/snippets/ha5skvux15

[15:13] <disbot4> <librasteve> now you tell us!

[15:14] <disbot4> <librasteve> (actually I thought lizmat has already written an operator called 'unzip')

[15:14] <lizmat> heh

[15:15] <disbot4> <librasteve> (I mean when she asked us what the obvious name is)

[15:15] <disbot4> <librasteve> btw I really like these glot.io snippets

[15:17] <disbot4> <rcmlz> Just for reference, how would I make the test pass?

[15:17] <disbot4> <rcmlz> In my glot.io snippet, I mean.

[15:24] <disbot4> <librasteve> use is not is-deeply

[15:31] *** arkiuat joined
[15:33] <disbot4> <rcmlz> "is" converts to string and is not recommended for "deep" data structures. https://docs.raku.org/type/Test#sub_is - the doc recommends "is-deeply".

[15:33] <disbot4> <rcmlz> I solved it now by adding >>.List to the expected output.

[15:34] <disbot4> <rcmlz> Anyhow, thanks fo the Raku fun and the short procrastination-break it allowed me ;-)

[15:35] *** arkiuat left
[15:37] <disbot4> <rcmlz> Me too. github gist is lacking the "play" button ;-)

[15:50] <disbot4> <nahita3882> you are right; the problem is the elements are in containers (since they are elements of an Array), so they are "itemized"

[15:51] <disbot4> <nahita3882> i.e., treated as a Single Item ($ = S + I)

[15:51] <disbot4> <nahita3882> hence the $ stuff you see in dd's outputs sometimes; it is to make that distinction

[15:52] <disbot4> <nahita3882> when Single Items (also known as Scalars btw) are tried to be iterated, they yield 1 thing, not N things their true self is really composed of

[15:52] <disbot4> <nahita3882> SO

[15:53] <disbot4> <nahita3882> to make your zip-zip work, you need to get to those true selfs

[15:53] <disbot4> <nahita3882> there are a lot of ways to do it:

[15:55] <librasteve_> https://www.irccloud.com/pastebin/UQlobysz

[15:58] <disbot4> <librasteve> is-deeply is equivalent to using === in a nested way so it will check the types of everything ... in this case where we are checking List vs Array it does the job (via stringifying ... which I suspect is why it does that in the first place)

[15:59] <disbot4> <nahita3882> perl zip |@arr>>.[];         # No copy zip |@arr>>.{};         # No copy, but a little weird to use {} for an Array zip |@arr>>.[*];        # Yes copy zip |@arr.map(*.self);  # No copy, but >>.self doesn't work because >> descends too much (nodemap style), so a little bit longer to type zip |@arr.map(*.<>);    # Same as above; notably, `<>` is the most common "decontainerization/deitemization" operator; it's actually

[15:59] <disbot4> an alias to {} :p zip |@arr.map({@$_});   # `@` accesses the Array self here, and no copy 

[16:03] <disbot4> <nahita3882> to reiterate the zip indeed taking 2 arguments, but not doing what we want:

[16:04] <disbot4> <nahita3882> m: dd zip [1, 2], [3, 4]

[16:04] <disbot4> <Raku eval>  ((1, 3), (2, 4)).Seq 

[16:04] <disbot4> <nahita3882> m: dd zip $[1, 2], $[3, 4];  # note the "$"s please; they are the itemizers

[16:04] <disbot4> <Raku eval>  (($[1, 2], $[3, 4]),).Seq 

[16:04] *** arkiuat joined
[16:04] <disbot4> <nahita3882> second case is happening with zip |@arr

[16:09] *** arkiuat left
[16:14] *** arkiuat joined
[16:22] *** arkiuat left
[16:49] *** arkiuat joined
[16:54] *** arkiuat left
[17:05] *** arkiuat joined
[17:12] *** arkiuat left
[17:19] *** arkiuat joined
[17:28] *** arkiuat left
[17:32] *** arkiuat joined
[17:37] *** arkiuat left
[17:50] *** arkiuat joined
[17:55] *** arkiuat left
[18:03] <SmokeMachine> m: my @x = (1, 2, 3) Z <a b c>; say @x; say [[[],[]], |@x].reduce: -> [@a, @b], [$a, $b] { [|@a, $a], [|@b, $b] }

[18:03] <camelia> rakudo-moar f56482941: OUTPUT: «[(1 a) (2 b) (3 c)]␤([1 2 3] [a b c])␤»

[18:13] *** arkiuat joined
[18:25] *** arkiuat left
[18:42] *** arkiuat joined
[18:47] *** arkiuat left
[19:01] *** arkiuat joined
[20:05] *** samebchase left
[20:05] *** gfldex left
[20:05] *** disbot4 left
[20:05] *** SmokeMachine left
[20:05] *** sjn left
[20:05] *** cpli left
[20:05] *** destroycomputers left
[20:09] *** cpli joined
[20:09] *** destroycomputers joined
[20:09] *** disbot5 joined
[20:24] *** stanrifkin joined
[21:25] <disbot5> <librasteve> 🙄

[21:28] <disbot5> <librasteve> hey folks - we seem to have a bit of a "pile on" dynamic going here in our beginner channel - so someone asks a good question, gets an answer - and then it's like "spew out all the different ways to do it" ... I hope @simon_sibl doesn't walk away - but many would

[21:30] <disbot5> <librasteve> [and yes - i'm as bad as the next guy]

[21:41] *** arkiuat left
[21:53] *** arkiuat joined
[21:58] *** arkiuat left
[22:15] *** arkiuat joined
