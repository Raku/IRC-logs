[00:53] *** kjp left
[00:54] *** kjp joined
[00:55] *** kjp left
[00:56] *** kjp joined
[03:49] *** librasteve_ left
[05:08] *** deoac left
[08:13] *** dakkar joined
[14:55] *** librasteve_ joined
[15:36] *** lizmat left
[15:37] *** lizmat joined
[16:43] *** dakkar left
[17:18] *** deoac joined
[19:12] *** human_blip left
[19:16] *** human_blip joined
[19:19] *** apogee_ntv left
[20:00] *** msiism joined
[20:04] <msiism> I used ` lines(IO('wordlist'))` to get a Seq of lines from a file. And, surprisingly, that worked just fine. So, is `IO` also just a routine, after all?

[20:07] <msiism> I'm a bit confused because other languages I've tried would require me to import some IO module first. Then I'd have `stdio::lines` or some such available, which I could alias to `lines`.

[20:08] <msiism> So, using, e.g., `stdio` itself like a routine would not make any sense.

[20:18] <disbot4> <nahita3882> you are technically performing a coercion: https://web.archive.org/web/20221216070143/https://docs.raku.org/language/typesystem#Coercion

[20:18] <disbot4> <nahita3882> m: class A { has $.val; }; say A(12)

[20:18] <disbot4> <Raku eval>  Exit code: 1 Impossible coercion from 'Int' into 'A': no acceptable coercion method found   in block <unit> at main.raku line 1  

[20:18] <disbot4> <nahita3882> m: class A { has $.val; method COERCE($n) { self.new: :val($n × 2) } }; say A(12)

[20:19] <disbot4> <Raku eval>  A.new(val => 24) 

[20:19] <disbot4> <nahita3882> the special method in charge is COERCE

[20:20] <disbot4> <nahita3882> re lack of need for importing stuff: as far as I know, Raku has everything built-in

[20:20] <disbot4> <nahita3882> you don't import anything to use anything language offers

[20:22] <disbot4> <nahita3882> e.g., even the Test module is not technically part of the language, so it doesn't count (to need for use'ing things)

[20:23] <disbot4> <shalokshalom> When you distribute (compile-time evaluated) multiple dispatch, and a third party later wants to add an additional overload in their own code without modifying or recompiling your library, compile-time multiple dispatch cannot support this; only a runtime registry can?

[20:23] <disbot4> <shalokshalom> And Rakus multiple dispatch is implemented via type reflection, and not runtime evaluation, yes?

[20:27] <msiism> Hm… okay, I get what type coercion is, but it stops there, unfortunately.

[20:28] <msiism> The reason probably is that I don't understand, what a class in Raku is.

[20:52] <lizmat> the most common way to read lines out of a file is:

[20:52] <lizmat> for "filename".IO.lines { .say }

[21:41] *** human_blip left
[21:43] *** human_blip joined
[21:50] *** apogee_ntv joined
[21:58] <disbot4> <librasteve> @shalokshalom most of raku is runtime oriented … i’m pretty sure you can layer on multis to pre compiled modules

[21:58] <disbot4> <shalokshalom> I am a bit confused over this. Isnt multiple dispatch in Raku implemented via type reflection, at compile time?

[22:02] <disbot4> <librasteve> oh … my superficial check is that you are right … sorry

[22:04] <disbot4> <librasteve> i guess mainly with “zef install” and  “use” your are recompiling

[22:19] *** msiism left
[22:29] *** deoac left
[22:33] <disbot4> <shalokshalom> yeah, but is that enough?

[22:33] <disbot4> <shalokshalom> like, simply recompiling the original source, and you are done?

[22:33] <disbot4> <shalokshalom> with no changes on the source code?

[23:05] *** librasteve_ left
