[00:43] <babydrop> m: use nqp; class Z { method z (Mu \SELF:) { dd [ nqp::iscont(SELF), nqp::iscont(self) ] } }; my $z = Z.new; $z.z

[00:43] <camelia> rakudo-moar 0c75e5: OUTPUT«[1, 0]␤»

[00:43] <babydrop> Is there any case where self would be nqp::iscont()? I see nqp::decont(self) in Mu.clone which I think isn't needed, based on the above

[01:36] <dalek> rakudo/nom: 9a161fa | (Zoffix Znet)++ | src/core/Mu.pm:

[01:36] <dalek> rakudo/nom: Prevent Mu.clone from incorrectly marking all attrs as inited

[01:36] <dalek> rakudo/nom:

[01:36] <dalek> rakudo/nom: Fixes RT#130271: https://rt.perl.org/Ticket/Display.html?id=130271

[01:36] <dalek> rakudo/nom:

[01:36] <synopsebot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=130271

[01:36] <dalek> rakudo/nom: Using nqp::getattr() or nqp::bindattr() on an attribute makes

[01:36] <dalek> rakudo/nom: nqp::attrinited return true. This made cloned Baggies lose their

[01:36] <dalek> rakudo/nom: .WHICH value, since its method uses nqp::attrinted to decide whether

[01:36] <dalek> rakudo/nom: to give its $!WHICH attribute. And in the ticket we have a cloned

[01:36] <dalek> rakudo/nom: Baggy, since the infix:<but> operator clones under the hood. And

[01:36] <dalek> rakudo/nom: this is the reason for the error in the ticket, since the .WHICH value

[01:36] <dalek> rakudo/nom: is unboxed into a native str at one point.

[01:36] <dalek> rakudo/nom:

[01:36] <dalek> rakudo/nom: Fix by checking whether an attribute is nqp::attrinted before to

[01:37] <babydrop> rakudo/nom: decide whether to call getattr/bindattr.

[01:37] <babydrop> review: https://github.com/rakudo/rakudo/commit/9a161fa0c92ea72721f060c10333c1d97ba81a50

[01:38] <dalek> roast: ebfab26 | (Zoffix Znet)++ | S02-types/WHICH.t:

[01:38] <dalek> roast: Test cloned Baggies have defined WHICH

[01:38] <dalek> roast:

[01:38] <dalek> roast: RT#130271: https://rt.perl.org/Ticket/Display.html?id=130271

[01:38] <dalek> roast: Rakudo fix: https://github.com/rakudo/rakudo/commit/9a161fa0c92ea7

[01:38] <dalek> roast: review: https://github.com/perl6/roast/commit/ebfab26314

[01:38] <synopsebot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=130271

[01:57] <babydrop> samcv: BTW, to get a commit bit for rakudo, one has to sign the CLA and (e)mail it to The Perl Foundation: http://www.perlfoundation.org/contributor_license_agreement

[01:57] <babydrop> samcv: just mentioning it, 'cause it took me months to find out that was a requirement :P

[01:57] <samcv> ah

[01:58] <samcv> but why don't other pull requests make you agree?

[01:59] <babydrop> No idea.

[02:04] <dalek> rakudo/nom: f9d34a9 | (Fernando Correa de Oliveira)++ | src/core/Int.pm:

[02:04] <dalek> rakudo/nom: Fix UInt not smartmatching undefined Int

[02:04] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/f9d34a9e83

[02:04] <dalek> rakudo/nom: d21d8ab | (Zoffix Znet)++ | src/core/Int.pm:

[02:04] <dalek> rakudo/nom: Merge pull request #947 from FCO/uint-match-unsigned-int

[02:04] <dalek> rakudo/nom:

[02:04] <dalek> rakudo/nom: Fix UInt not smartmatching undefined Int

[02:04] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/d21d8abbd2

[02:04] <dalek> roast: c506ea5 | (Fernando Correa de Oliveira)++ | S32-num/int.t:

[02:04] <dalek> roast: Add test for smatmatch UInt with undefined Int (#194)

[02:04] <dalek> roast: review: https://github.com/perl6/roast/commit/c506ea5f4a

[02:10] <samcv> babydrop, the Linguist repo makes you do such a thing

[02:10] <samcv> for people who have not gotten a pull accepted before

[02:10] <samcv> it's one of the checks

[02:11] <samcv> wait did you actually have to mail it there

[02:12] <babydrop> samcv: I'm pretty sure email is fine. When I mailed mine, I somehow managed to mail it to the wrong address and it got returned to me and then lizmat hooked me up with a contact whom I just emailed a digital version

[02:13] <samcv> ah

[02:13] <samcv> would we want to have somebody look at the CLA ( could be on our project they read it) and click accept?

[02:13] <babydrop> Just for PRs?

[02:14] <samcv> yeah. or nobody cares? lol

[02:14] <babydrop> I rather not add barriers to contribution.

[02:14] <samcv> yeah. i thought that too

[02:14] <samcv> it wasn't the easiest. it just said "1 check failed" or whatever when you hadn't signed it

[02:15] <samcv> though courts have said that if you contribute source code, and they have a license it implies that you are submitting the code under that license unless you specify otherwise.

[02:16] <babydrop> Makes sense.

[02:21] <geekosaur> ...courts where though?

[02:41] <samcv> oh USA i think?

[02:41] <samcv> maybe others. not sure

[04:06] <kalkin-> who do I have to please to get https://github.com/rakudo/rakudo/pull/948 merged? (It passed all checks)

[04:07] <kalkin-> :)

[05:51] <samcv> kalkin-, readline is initialized here already https://github.com/kalkin/rakudo/blob/9043f5897a75203f08cfc31e1487e8d544f320a9/src/core/REPL.pm#L58

[05:52] <samcv> does it work if you remove that line?

[05:52] <samcv> actually hold on. just don't initialize readline inside that method

[05:52] <samcv> > my $read = $Readline.new; that will make it lexical

[05:53] <samcv> will be a nice feature to have

[05:53] <samcv> kalkin-, also see how it loads https://github.com/kalkin/rakudo/blob/9043f5897a75203f08cfc31e1487e8d544f320a9/src/core/REPL.pm#L60 files here

[05:54] <samcv> make sure it doesn't read the history until after this

[07:58] <nine> samcv: I emailed my CLA, too. If you don't get a reply in a reasonable time, Coke++ can help.

[07:59] <samcv> oh i didn't fill out a CLA yet ;P

[07:59] <samcv> but will remember for in the future

[07:59] <brrt> btw, nine, i've resolved the issue with rakudo building on even-moar-jit

[08:00] <brrt> thanks for pointing it out :-)

[08:03] <nine> brrt++

[08:16] <dalek> rakudo/nom: e9ce28a | samcv++ | src/core/io_operators.pm:

[08:16] <dalek> rakudo/nom: Make routines say, note and put 25% faster to stdout

[08:16] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/e9ce28a610

[08:16] <dalek> rakudo/nom: 99f04e0 | niner++ | src/core/io_operators.pm:

[08:16] <dalek> rakudo/nom: Merge pull request #949 from samcv/say

[08:16] <dalek> rakudo/nom:

[08:16] <dalek> rakudo/nom: Make routines say, note and put 25% faster to stdout.

[08:16] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/99f04e092a

[08:21] <nine> lizmat: this ^^^ looks like something our static optimizer may be able to do automatically

[08:26] <[Tux]> This is Rakudo version 2016.11-194-gd21d8abbd built on MoarVM version 2016.11-44-g8e24145d

[08:26] <[Tux]> csv-ip5xs        3.205

[08:26] <[Tux]> test            14.206

[08:26] <[Tux]> test-t           6.335

[08:26] <[Tux]> csv-parser      14.092

[09:02] <dalek> nqp: 7fed81d | samcv++ | src/HLL/Grammar.nqp:

[09:02] <dalek> nqp: Add four new pairs of matched delimiters brackets/parens (#330)

[09:02] <dalek> nqp:

[09:02] <dalek> nqp: These are the only four pairs in Unicode that we don't have

[09:02] <dalek> nqp: added.

[10:06] <lizmat> samcv++  # good catch on say and friends!

[10:08] * jnthn is a bit surprised it makes such a difference

[10:08] <jnthn> The static optimizer should be able to lower such a lexical to a local at some point, though

[10:10] <jnthn> Oh, I bet I can guess why it was costly... It probably created a nativeref 'cus it can't prove statically that .print doesn't want an "is rw" thing

[10:10] <jnthn> And spesh can't strip them out in that case yet either

[10:12] <timotimo> yup, native refs are a big reason our code isn't optimal

[10:12] <timotimo> ... IMHO

[10:14] <jnthn> Yes, I need to spend a good chunk of time on spesh at some point

[10:15] <jnthn> But I'm so burried in concurrency stuff it's hard to find the itme.

[10:15] <jnthn> *time

[10:16] <dalek> rakudo/nom: 64b5c2f | samcv++ | src/core/Cool.pm:

[10:16] <dalek> rakudo/nom: Make uniprop return Bool or Str, also make it 15% faster and fix…

[10:16] <dalek> rakudo/nom:

[10:16] <dalek> rakudo/nom: a bug in MoarVM where canonical Unicode shortnames return

[10:16] <dalek> rakudo/nom: the incorrect property.

[10:16] <dalek> rakudo/nom: It is 15% faster now, and adds these two fixes as well.

[10:16] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/64b5c2fae6

[10:16] <dalek> rakudo/nom: 71821dd | samcv++ | / (2 files):

[10:16] <dalek> rakudo/nom: Add the script used to generate the uniprop code.

[10:16] <dalek> rakudo/nom:

[10:16] <dalek> rakudo/nom: Also make a comment saying the code was generated and where

[10:16] <dalek> rakudo/nom: to find the file that generated it.

[10:16] <dalek> rakudo/nom: 9043f58 | (Bahtiar `kalkin-` Gadimov)++ | src/core/REPL.pm:

[10:16] <dalek> rakudo/nom: Add Historyfile support for Readline

[10:16] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/9043f5897a

[10:16] <dalek> rakudo/nom: 1582e93 | lizmat++ | src/core/REPL.pm:

[10:16] <dalek> rakudo/nom: Merge pull request #948 from kalkin/readline-history

[10:16] <dalek> rakudo/nom:

[10:16] <dalek> rakudo/nom: Add Historyfile support for Readline

[10:16] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/1582e93750

[10:16] <dalek> rakudo/nom: 8965145 | samcv++ | tools/build/NQP_REVISION:

[10:16] <dalek> rakudo/nom: Bump nqp: Add 4 new sets of matching brackets

[10:16] <dalek> rakudo/nom:

[10:16] <dalek> rakudo/nom: For use in q [], #`[ and other things such as this.

[10:16] <dalek> rakudo/nom:

[10:18] <timotimo> to be honest, it'd probably be worth more in the medium term to fix that nativeref problem in our static optimizer

[10:18] <jnthn> We can't.

[10:19] <jnthn> Methods are late bound.

[10:20] <jnthn> We can handle more cases than we do today of course, but the general case needs handling in spesh

[10:20] <timotimo> oh

[10:20] <timotimo> of course

[10:20] <arnsholt> And statically proving anything about $*ERR doesn't sound too plausible to me

[10:20] <timotimo> we do have the same problem with operators, though

[10:20] <timotimo> makes native ints and such not very fun to use

[10:20] <jnthn> True. Question is if we really want to maintain such an opt twice :)

[10:20] <jnthn> Well, we static inline a bunch of operators

[10:21] <jnthn> And get away with it on those

[10:22] <timotimo> are we going to turn rakudo into javac? ;)

[10:23] <jnthn> What, does very few opts and leaves them to the VM?

[10:24] <timotimo> right

[10:24] <jnthn> It's an interesting question. For very short-lived scripts, it's usually a waste of time.

[10:24] <samcv> thanks lizmat

[10:24] <timotimo> so only turn on the optimizer for the core setting, then ;)

[10:25] <jnthn> Well, we have levels too. "We're pre-compiling this" could push it up a level.

[10:25] <jnthn> Though that only really helps if you get to skip analyses too

[10:26] <timotimo> aye. we'll likely want to put a few more level checks into the optimizer

[10:36] <dalek> roast: 425011c | lizmat++ | S15-unicode-information/uniprop.t:

[10:36] <dalek> roast: Unfudge now passing test, samcv++

[10:36] <dalek> roast: review: https://github.com/perl6/roast/commit/425011c0e4

[11:06] <babydrop> say was 25% slower just 'cause it saved into a variable? 0.o

[11:09] <dalek> rakudo/nom: f4479d2 | dogbert17++ | CREDITS:

[11:09] <dalek> rakudo/nom: Added myself

[11:09] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/f4479d2fd3

[11:09] <dalek> rakudo/nom: e25a708 | (Zoffix Znet)++ | CREDITS:

[11:09] <dalek> rakudo/nom: Merge pull request #946 from dogbert17/update-credits

[11:09] <dalek> rakudo/nom:

[11:09] <dalek> rakudo/nom: Added myself

[11:09] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/e25a708d28

[11:11] <nine> So, hands up please! Merge lexical_module_load before the release, i.e. ~ today?

[11:11] <nine> o/

[11:11] <babydrop> +1

[11:13] <jnthn> Umm

[11:13] <jnthn> Surely immediately *after* a release is more sensible?

[11:14] <lizmat> I think we already skipped 2 releases where we could have done that

[11:15] <lizmat> if we say now: immediately merge after the next release, I can live with that also

[11:15] <jnthn> Yes, but this time we've got (a) data showing the impact, and (b) it's documented

[11:15] <lizmat> but please let's not skip another one  :-)

[11:15] <jnthn> Yes, I can very easily agree with "merge right after next release"

[11:16] <lizmat> 👍

[11:16] <jnthn> Full +1 on that. I'm just a tad more wary on sneaking it in 4-5 days beforehand.

[11:17] <nine> I'd be fine with right after the release, too. The "before release" plan certainly provoked responses faster though ;)

[11:18] <nine> Also now that emmentaler is up and running again, we should use it more extensively. Thinking about jnthn++'s release plan from January.

[11:19] <jnthn> Yes, we really should take advantage of that better to catch ecosystem-breaking changes sooner.

[11:19] <jnthn> And perhaps even start doing the automatic release branch thing I proposed.

[11:20] <jnthn> (Where we use an automated process of spectest + selected module smoke pass = fast-foward branch we relesae from)

[11:33] <babydrop> Is that proposal written down somewhere I could read the details?

[11:35] <babydrop> .oO( we need a place for RFCs.... )

[11:36] <jnthn> babydrop: https://github.com/rakudo/rakudo/blob/nom/docs/language_versions.md

[11:36] <babydrop> .oO( we have a place for RFCs.... )

[11:36] <babydrop> thanks

[11:39] <babydrop> Well, with that naming scheme I just can see myself doing a checkout for a quick fix and accidentally forgetting to switch branches and ending up pushing to master :/

[11:41] <dalek> rakudo/nom: e1d92e5 | (Zoffix Znet)++ | docs/language_versions.md:

[11:41] <dalek> rakudo/nom: Fix typo

[11:41] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/e1d92e5fd5

[11:43] <babydrop> And I guess most PRs will be made off master and not nom and requested to be merged to master and not nom?

[11:43] * babydrop isn't sure how that's works outs

[11:43] <jnthn> Hm

[11:44] <jnthn> I think github may have some branch-level protection at these days?

[11:44] <jnthn> https://help.github.com/articles/about-branch-restrictions/

[11:44] <timotimo> we can make an orphaned master branch with only a single commit that says "this isn't the branch you're looking for"

[11:45] <jnthn> We could leave nom as the default

[11:45] <timotimo> then pushing will basically always tell you it's not a fast-forward

[11:45] <timotimo> oh, wait

[11:45] <timotimo> we're talking about making master only pushable by the automated thing

[11:45] <jnthn> Right

[11:45] <babydrop> But if I'm a random dude walking through decided to submit a fix, I'll just do it off master 'cause that's what everyone uses and I never heard of this `nom`

[11:45] <jnthn> Right

[11:45] <jnthn> Yeah, we should probably then stick with not having a master.

[11:46] <jnthn> To avoid such confusion

[11:46] <jnthn> And call the release target one something else

[11:46] <babydrop> +1

[11:46] <timotimo> release-target-one

[11:47] <jnthn> At the time the doc was written, people using rakudobrew to obtain a Rakudo build was a more important use-case than it is now; now it seems we discourage that.

[11:47] <nine> But we already have a massively outdated master and there hasn't been a PR for master ever?

[11:47] <jnthn> And people who want stability are pushed towards releases, packages, etc. Which is a good thing.

[11:47] <jnthn> nine: We don't have a master afaik

[11:49] <jnthn> Anyway, if there are users who want to be sort-of-bleeding-edge but not-so-rare-you-see-it-bleeds then I guess they can choose to track the release branch.

[11:49] <nine> Oh, indeed.

[11:49] <jnthn> I figure that will be an increasingly small group however.

[11:49] <timotimo> we might have a master that's been created by accident

[11:49] <timotimo> i think i've done that once?

[11:51] <nine> Seems like I have a master in my fork

[11:57] * jnthn goes to put a fork in his lunch :)

[11:58] <arnsholt> jnthn: Is lunch return of revenge of the son of pulao mountain, or are you done with that now? =)

[11:59] <kalkin-> samcv: ohh i see, double initialization of my read

[11:59] <kalkin-> why did you guys merged it? should i make another pr fixing this?

[12:00] <babydrop> kalkin-: if something's broken, yeah, please submit another PR fixing the issue.

[12:01] <kalkin-> babydrop: ok

[12:06] <nine> kalkin-: we usually operate in a "when in doubt, merge it" mode

[12:07] <kalkin-> i see

[12:11] <masak> we do? exactly how much doubt to we allow? :P

[12:11] * masak .oO( "I'm really not sure about this PR! let's merge it!" )

[12:13] <nine> "Wait, why would rakudo need to open an IRC connection and fork into background? And I have never read this account name. But the commit message explains that the patches just fix some indentation, so let's merge it!"

[12:27] <babydrop> Ummm... no, we don't?

[12:27] * babydrop doesn't want to start rumours that Perl 6 core devs will merge just any old thing

[12:30] <lucasb> github.com/rakudo-acceptanything

[12:30] <babydrop> heh

[12:33] <lizmat> m: my $a <== join(",") <== <a b c>; dd $a  # this seems wrong ?

[12:33] <camelia> rakudo-moar e1d92e: OUTPUT«Array $a = $["a,b,c"]␤»

[12:33] <lizmat> sorta expected to see "a,b,c" there ?

[12:33] <psch> m: my $x <== 1; say $x

[12:33] <camelia> rakudo-moar e1d92e: OUTPUT«[1]␤»

[12:34] <psch> i always assumed feed operators to implictly always leave arrays behind

[12:34] <psch> potentially lazy i wanna say, but i'm not sure about that

[12:34] <kalkin-> Am I right that only rakudo/rakudo uses the nom branch as the current development branch while MoarVM/MoarVM and perl6/nqp use master branch?

[12:35] <lizmat> kalkin-: yes

[12:35] <nine> kalkin-: correct

[12:36] <lucasb> on nom nom

[12:36] <kalkin-> thanks

[12:37] <pmurias> masak: isn't Angular 2 supposed to be faster? I have used only Angular 1 (and had performance problems with it)

[12:38] * pmurias meant to say that in #perl6 :(

[12:38] <masak> pmurias: you switch channels for the Angular 2 discussion?

[12:38] <masak> ah :)

[12:38] <masak> please do.

[12:41] <Woodi> m: my @a = |<| / - \ | / - \ > xx *; say @a[0]; say @a[0];

[12:41] <camelia> rakudo-moar e1d92e: OUTPUT«|␤|␤»

[12:41] <Woodi> @a[0] do not shift Slip ?

[12:44] <babydrop> What does that mean?

[12:45] <babydrop> Why not use .rotate instead of that?

[12:45] <Woodi> babydrop: it's another way, not circular but infinite! ;)

[12:46] <babydrop> ummmmm

[12:46] <babydrop> Well, don't let me stop you..

[12:46] <psch> that just wastes RAM, and you still need to either $++ or shift

[12:46] <psch> ...if we can shift from lazy lists?

[12:46] <Woodi> babydrop: and I should stil have that blogpost open, for closer reread :)

[12:47] <psch> well, or overwrite AT-POS(0) of course vOv

[12:47] <psch> that's probably gonna be perfectly fine and usable

[12:47] <babydrop> I've no idea what blog post you mean :/

[12:47] <Woodi> psch: it is just short example, just put lazy there ?

[12:47] <psch> Woodi: sure

[12:48] <Woodi> m: my @b = |<| / - \ | / - \ > xx *; say shift @b; say shift @b; # shift shifts ?

[12:48] <camelia> rakudo-moar e1d92e: OUTPUT«|␤/␤»

[12:48] <Woodi> but it is Slip, not Array...

[12:49] <psch> m: my @b = |<| / - \ | / - \ > xx *; say @a.WHAT

[12:49] <camelia> rakudo-moar e1d92e: OUTPUT«===SORRY!=== Error while compiling <tmp>␤Variable '@a' is not declared␤at <tmp>:1␤------> my @b = |<| / - \ | / - \ > xx *; say ⏏@a.WHAT␤»

[12:49] <psch> m: my @b = |<| / - \ | / - \ > xx *; say @b.WHAT

[12:49] <camelia> rakudo-moar e1d92e: OUTPUT«(Array)␤»

[12:49] <psch> yeah

[12:50] * Woodi is afk; Perl6 is hard. let's deliver some cakes for kids ;)

[13:01] <jnthn> arnsholt: Thankfully, I finished that up by the end of last week. :-)

[13:02] <kalkin-> samcv: i fixed the double initialization of Readline you mentioned https://github.com/rakudo/rakudo/pull/951/commits/0c6d14298a95e118c61f9c4b374887679435cf6b

[13:05] <MasterDuke_> hopefully nobody minds if i ask about this again. i'm trying to get -n to codegen 'while ($_ := get()).DEFINITE { $code }' instead of 'for lines() { $code }'

[13:05] <dalek> rakudo/nom: 0c6d142 | kalkin++ | src/core/REPL.pm:

[13:05] <dalek> rakudo/nom: REPL fix readline double initialization

[13:05] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/0c6d14298a

[13:05] <dalek> rakudo/nom: e296a14 | kalkin++ | CREDITS:

[13:05] <dalek> rakudo/nom: Add myself to CREADITS file

[13:05] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/e296a141b0

[13:05] <dalek> rakudo/nom: af2ff23 | niner++ | / (2 files):

[13:05] <dalek> rakudo/nom: Merge pull request #951 from kalkin/readline-history

[13:05] <dalek> rakudo/nom:

[13:05] <dalek> rakudo/nom: REPL fix readline double initialization

[13:05] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/af2ff23a00

[13:05] * babydrop doesn't mind but doesn't know the answer either :(

[13:05] <MasterDuke_> the AST i get looks reasonable, but depending on different tweaks to it, i get no output, or the error "Cannot call method 'sink' on a null object   in block <unit> at -e line 1"

[13:05] <MasterDuke_> here's a gist with some diffs https://gist.github.com/MasterDuke17/6e09ebc32dce5f703a178a2a0348ef7b

[13:07] <kalkin-> ups typo

[13:07] <kalkin-> too late :)

[13:14] * lizmat thinks it's creative  :-)_

[13:18] <lizmat> m: my @a = ^10; say -« @a   # works fine

[13:18] <camelia> rakudo-moar af2ff2: OUTPUT«[0 -1 -2 -3 -4 -5 -6 -7 -8 -9]␤»

[13:18] <lizmat> m: my @a = ^10; say -<< @a   # doesn't parse

[13:18] <camelia> rakudo-moar af2ff2: OUTPUT«[0 -1 -2 -3 -4 -5 -6 -7 -8 -9]␤»

[13:18] <lizmat> huh?

[13:18] <lizmat> oops, seen the error of my ways  :-)

[13:41] <babydrop> m: my @a = 0e0..9e0; say -« @a

[13:41] <camelia> rakudo-moar af2ff2: OUTPUT«[-0 -1 -2 -3 -4 -5 -6 -7 -8 -9]␤»

[13:41] <babydrop> m: my @a = 0e0..9e0; dd -« @a

[13:41] <camelia> rakudo-moar af2ff2: OUTPUT«[-0e0, -1e0, -2e0, -3e0, -4e0, -5e0, -6e0, -7e0, -8e0, -9e0]␤»

[13:41] <babydrop> (good, negative zero works)

[13:44] <babydrop> A ton of failures in make j-test on nqp.... I guess I'm learning Java today.

[13:46] <psch> babydrop: https://irclog.perlgeek.de/perl6-dev/2016-12-09#i_13713553 and the next two or so pages will probably be helpful

[13:47] <psch> babydrop: i'm assuming the contextual.t additions suffer from a similar problem, which is completely-different-codegen-architecture

[13:47] <psch> babydrop: so, yes, you probably have to learn some Java, but most of it is like in src/vm/jvm/QAST/Compiler.nqp

[13:47] <psch> *likely

[13:48] <travis-ci> Rakudo build passed. Bahtiar `kalkin-` Gadimov 'Add Historyfile support for Readline'

[13:48] <travis-ci> https://travis-ci.org/kalkin/rakudo/builds/183241465 https://github.com/kalkin/rakudo/compare/1369de949c98...9043f5897a75

[13:48] <babydrop> ummm

[13:49] <babydrop> I don't undertstand any of it.

[13:49] <babydrop> I guess I'm too optimistic about my ability to fix those tests :)

[13:50] <babydrop> I just didn't want to fudge anything 3rd release in a row...

[13:50] <psch> understandable, and maybe sufficient grounds to park r-j

[13:51] <psch> i mean, considering it's probably mostly new tests that test previously-assumed-correct behavior...

[13:52] <babydrop> So would I release nqp with those failing tests unfudged or should I fudge them?

[13:52] <babydrop> where by "fudge" I mean skipping them for both moarvm and jvm

[13:53] <psch> i don't have a strong opinion on that, but it seems justifiable to not release nqp-j or r-j is what i wanted to say before

[13:53] <babydrop> OK.

[13:54] <psch> like, it's new tests, but we should've been passing them all along

[13:54] <psch> if people really want an nqp-j that we cannot confidently say fits notably relevant semantics -- like closure cloning and lexical references -- they probably can build it themselves

[13:55] <psch> and in turn take note of the failing tests

[13:55] <psch> but afaik releases should pass all the fudged tests, and it feels a bit weird to me at least to fudge tests that at time of release are only a few days old but pass on the other backend

[13:55] <psch> especially in nqp

[13:55] <psch> on the other hand that's previously been policy, so you could also fudge and release both

[13:56] <psch> as i said, i don't really have a strong opinion either way, and i'm sadly not capable of fixing anything in the lexrel and closure cloning area quickly

[13:58] <babydrop> I think I'll fudge them just so if someone's packaging this downstream they don't stop and think there's some new breakage

[13:59] * pmurias suspects he should run make j-test more often to avoid failing tests on nqp-j

[14:00] <psch> pmurias: honestly, i'm not sure.  if they're passing on moar and nobody notices bad semantics it's better to have failing tests than no tests

[14:00] <psch> pmurias: if you're fixing nqp-j in the process... well great, i've troubles getting into some of the deeper parts of the compiler

[14:01] <pmurias> wouldn't fudging my having a list of tests that nqp-j fails rather then modifing tests on release and reverting that be saner?

[14:02] <pmurias> s/my/by/

[14:02] <psch> well, sure, we can bring the fudger into nqp tests too

[14:02] <psch> but currently we're just straight running them through -exec nqp ...

[14:03] <pmurias> I just meant having a list of whole test files that we fail

[14:09] <Woodi> hmm, Slip is just "kind of List that automatically flattens into an outer container" so what was that kind of list that do not keep used values ? Seq ?

[14:13] <babydrop> Woodi: FWIW, there are more users in #perl6 channel

[14:15] <Woodi> damn, wrong channel... sorry

[14:17] <pmurias> psch: 104-method-cache, 01-qast and serialization/01-basic fail?

[14:17] <pmurias> lunch&

[14:19] <babydrop> yeah, those look like the ones that fail to me: https://gist.github.com/zoffixznet/f4e1e1c063bdf29b0f244f8defd3eb38

[14:19] <psch> right

[14:19] <psch> 01-qast is the one affected by the closure model differences

[14:20] <babydrop> But I'm unsure what you mean by "make a list" of files that fail. To what end? To just keep them in a directory that's not tested on j-test?

[14:23] <psch> ah, 01-qast also has the bit where we don't look for the right boxing type for some reason

[14:23] <psch> i don't remember offhand what's going on with the other two

[14:23] <dogbert17_> babydrop: I'm getting quite a few fails when running 'make spectest' normally. Is something up?

[14:24] <babydrop> dogbert17_: what are the failures?

[14:25] <dogbert17_> bizarre to say the least, I even nuked my rakuda install and started from scratch. Let me pu up a gist.

[14:26] <dogbert17_> babydrop: https://gist.github.com/dogbert17/5916d833a33ce1cfd1b9c006ac49e278

[14:27] <babydrop> Just one file fails?

[14:36] <dogbert17_> babydrop: sry, was afk, no several failures

[14:38] <dogbert17_> five or six files: t/spec/S17-promise/basic.t, t/spec/S17-supply/syntax.t, t/spec/S29-context/sleep.t, t/spec/S05-substitution/subst.rakudo.moar, t/spec/S16-io/handles-between-threads.rakudo.moar, t/spec/S17-promise/basic.t

[14:40] <babydrop> No idea. Doesn't look like anything I could've broken :}

[14:43] <jnthn> dogbert17_: Still got extra debug checks turned on, perhaps?

[14:48] <pmurias> I'll look into those nqp-j failures

[14:49] <babydrop> pmurias++

[14:51] <dalek> rakudo/nom: e5e81e4 | (Zoffix Znet)++ | src/core/Rakudo/Internals/VMBackedDecoder.pm:

[14:51] <dalek> rakudo/nom: Re-instate comment about why the `with` is in the code

[14:51] <dalek> rakudo/nom:

[14:51] <dalek> rakudo/nom: And expand on why it was removed/re-added

[14:51] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/e5e81e4051

[14:52] <dalek> nqp: 069d9ea | (Pawel Murias)++ | t/qast/01-qast.t:

[14:52] <dalek> nqp: [jvm] Add a takeclosure op needed for JVM's old closure handling.

[14:52] <dalek> nqp: review: https://github.com/perl6/nqp/commit/069d9ea3b6

[14:59] <pmurias> when is nqp-j release planned?

[15:01] <babydrop> This Saturday.

[15:01] <babydrop> NeuralAnomaly: status

[15:01] <NeuralAnomaly> babydrop, [✘] Next release will be in 4 days and 14 hours. Since last release, there are 48 new still-open tickets (2 unreviewed and 0 blockers) and 28 unreviewed commits. See http://perl6.fail/release/stats for details

[15:02] <dogbert17_> jnthn: no, I started from scratch

[15:03] * dogbert17_ hopes he's made some stupid mistake

[15:05] <MasterDuke_> dogbert17_: pretty sure i've seen some failures in some of those files also

[15:05] <dogbert17_> MasterDuke to the rescue :)

[15:06] <dogbert17_> bizarre: # Failed test 'huge values to sleep() work'

[15:06] <dogbert17_> # at /home/dogbert/repos/rakudo/t/spec/packages/Test/Util.pm (Test::Util) line 76

[15:06] <dogbert17_> #      got err: "Thread 3 bound to a hash key of an object (BOOTHash) allocated by thread 1\n   at <unknown>:1  (./CORE.setting.moarvm:BIND-KEY)\n from SETTING::src/core/hash_slice.pm:12

[15:11] <babydrop> I'm not getting any failures in the entire stresstest. In fact the opposite:

[15:11] <babydrop> t/spec/S17-procasync/kill.rakudo.moar                           (Wstat: 0 Tests: 9 Failed: 0)

[15:11] <babydrop> TODO passed:   9

[15:11] <babydrop> Files=1204, Tests=130277, 139 wallclock secs (21.52 usr  3.56 sys + 2945.33 cusr 287.87 csys = 3258.28 CPU)

[15:11] <babydrop> Result: PASS

[15:13] <dalek> rakudo/nom: aa27d5c | (Zoffix Znet)++ | src/core/Date.pm:

[15:13] <dalek> rakudo/nom: Make all Date constructors check validity of dates

[15:13] <dalek> rakudo/nom:

[15:13] <dalek> rakudo/nom: Fixes RT#130313: https://rt.perl.org/Ticket/Display.html?id=130313

[15:13] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/aa27d5ce94

[15:13] <synopsebot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=130313

[15:13] <dalek> roast: fecfa65 | (Zoffix Znet)++ | S32-temporal/Date.t:

[15:13] <dalek> roast: Test all Date contructors check validity of dates

[15:13] <dalek> roast:

[15:13] <dalek> roast: RT#130313: https://rt.perl.org/Ticket/Display.html?id=130313

[15:13] <dalek> roast: Rakudo fix: https://github.com/rakudo/rakudo/commit/aa27d5ce94

[15:13] <synopsebot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=130313

[15:13] <dalek> roast: review: https://github.com/perl6/roast/commit/fecfa6518b

[15:18] <pmurias> babydrop: I'll try fixing the failures later today/tommorow, the don't look like they require a closure handling refactor or anything that serious

[15:18] <babydrop> cool

[15:18] <lizmat> babydrop: are you sure you didn't break the subclassability of Date ?

[15:19] <lizmat> ah, read the commit wrong

[15:19] <dogbert17_> babydrop: it's very strange, for me the following code spits out lots of strange output: await ^30 .map: { start { S/.+/{$/.chars.print}/ given "abc"; } }

[15:19] <dogbert17_> m: await ^30 .map: { start { S/.+/{$/.chars.print}/ given "abc"; } }

[15:19] <camelia> rakudo-moar e5e81e: OUTPUT«333333333333333333333333333333»

[15:19] <dogbert17_> odd

[15:20] <lizmat> babydrop: but I do think you've severely slowed down Date.new(y,m,d) creation :-(

[15:21] <dogbert17_> babydrop: if it's no to much trouble, are you close to your 32-bit dev machine?

[15:21] <ilmari> s: Range, 'in-range', \(Int, Str)

[15:21] <SourceBaby> ilmari, Something's wrong: ␤ERR: Unhandled exception: Missing or wrong version of dependency 'src/Perl6/Grammar.nqp' (from 'gen/moar/main.nqp')␤   at <unknown>:1  (/home/zoffix/services/sourceable/building-perl6/perl6.moarvm:<dependencies+deserialize>)␤

[15:21] <lizmat> since that now has to go through the (much slower) named variant  :-(

[15:22] <babydrop> dogbert17_: it's kinda of "trouble" tho, beucase I don't use it to dev Perl 6. So any time you ask me for something I have to rebuild Perl 6 which takes ages.

[15:22] * ilmari resorts to ag

[15:23] <dogbert17_> babydrop: that's cool just wanted to check. will try with slightly older releases

[15:24] <babydrop> lizmat: it's slower just due to named args?

[15:24] <babydrop> I see it's now 3 times slower :o

[15:24] <lizmat> oh, yes

[15:24] * babydrop makes changes

[15:24] <lizmat> named parameters are *way* slower than positionals

[15:25] <lizmat> that's the whole point of not using BUILD in the core setting, but custom SET-SELF methods instead

[15:28] <babydrop> s: Range, 'in-range', \(Int, Str)

[15:28] <SourceBaby> babydrop, Sauce is at https://github.com/rakudo/rakudo/blob/aa27d5c/src/core/Range.pm#L629

[15:28] <babydrop> ilmari: you just caught it in the middle of building a new commit

[15:28] <ilmari> ah

[15:30] <jnthn> m: class C { method m($a, $b) { } }; C.m(1, 2) for ^100000; say now - INIT now

[15:30] <camelia> rakudo-moar e5e81e: OUTPUT«0.21150674␤»

[15:30] <jnthn> m: class C { method m($a, $b) { } }; C.m(1, 2) for ^1000000; say now - INIT now

[15:30] <camelia> rakudo-moar e5e81e: OUTPUT«2.0623987␤»

[15:31] <jnthn> m: class C { method m(:$a!, :$b!) { } }; C.m(:1a, :2b) for ^1000000; say now - INIT now

[15:31] <camelia> rakudo-moar aa27d5: OUTPUT«2.0579070␤»

[15:31] <jnthn> lizmat: Really? :)

[15:31] <babydrop> m: class C { method m(:$a, :$b) { } }; C.m(:1a, :2b) for ^1000000; say now - INIT now

[15:31] <camelia> rakudo-moar aa27d5: OUTPUT«2.22023755␤»

[15:31] <lizmat> well, :$a!  is essentially the same as a positional

[15:32] <jnthn> Uh

[15:32] <jnthn> No, it's passed as a named :)

[15:32] <jnthn> Spesh rewrites it into a positional

[15:32] <jnthn> But it does that in the optinal case too

[15:32] <lizmat> well, as babydrop showed, it's clearly slower

[15:32] <lizmat> if you don't use !

[15:32] <jnthn> m: class C { method m($a?, $b?) { } }; C.m(1, 2) for ^1000000; say now - INIT now

[15:32] <camelia> rakudo-moar aa27d5: OUTPUT«1.8460138␤»

[15:33] <jnthn> huh, how come that one is a bunch faster...

[15:33] <jnthn> m: class C { method m($a?, $b?) { } }; C.m(1, 2) for ^1000000; say now - INIT now

[15:33] <camelia> rakudo-moar aa27d5: OUTPUT«2.10225324␤»

[15:33] <jnthn> Oh, just noise :)

[15:33] <ilmari> .oO( dumbbench? )

[15:33] <jnthn> I suspect that if it boils down to "if you don't use !" then it's not too much to do with nameds and much more to do with optional, anyways.

[15:34] <jnthn> m: say 100 * (2.05 / 2.22)

[15:34] <camelia> rakudo-moar aa27d5: OUTPUT«92.342342␤»

[15:34] <dalek> rakudo/nom: 5556b3c | (Zoffix Znet)++ | src/core/Date.pm:

[15:34] <dalek> rakudo/nom: Redo Date validation differently for performance

[15:34] <dalek> rakudo/nom:

[15:34] <dalek> rakudo/nom: The method implemented in aa27d5c made Date.new($y, $m, $d) run

[15:34] <dalek> rakudo/nom: 3x slower.

[15:34] <dalek> rakudo/nom:

[15:34] <dalek> rakudo/nom: lizmat++ for noticing

[15:34] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/5556b3c79b

[15:34] <MasterDuke_> jnthn: have you seen my AST question?

[15:35] <jnthn> And even then we're talking 10% if those numbers are to believed. So I suspect there's a little more to the story (multi dispatch maybe?) than just nameds

[15:35] <jnthn> MasterDuke_: No; link?

[15:35] <MasterDuke_> jnthn: https://gist.github.com/MasterDuke17/6e09ebc32dce5f703a178a2a0348ef7b

[15:36] <MasterDuke_> i'm trying to get -n to codegen 'while ($_ := get()).DEFINITE { $code }' instead of 'for lines() { $code }'

[15:36] <babydrop> m: class C { multi method m(Str $x) { }; multi method m($a, :$b) { }; multi method m(:$a, :$b) { } }; C.m(:1a, :2b) for ^1000000; say now - INIT now

[15:36] <camelia> rakudo-moar aa27d5: OUTPUT«2.20618128␤»

[15:36] <babydrop> weird

[15:36] <babydrop> oh

[15:36] <babydrop> m: class C { multi method m(Str $x) { }; multi method m($a, $b) { self.m(:$a, :$b) }; multi method m(:$a, :$b) { } }; C.m(1, 2) for ^1000000; say now - INIT now

[15:37] <camelia> rakudo-moar aa27d5: OUTPUT«2.5596973␤»

[15:37] <babydrop> vOv

[15:37] <babydrop> perl6 -e 'Date.new(2015, 12, 25) for ^10_000; say now - INIT now runs in 0.13 and change and with the first patch that turned into 0.6

[15:39] <jnthn> MasterDuke_: The immediate cause is that a QAST while node doesn't evaluate to anything, but you're sinking it

[15:39] <jnthn> Thus it produces a null to sink leading to the error

[15:39] <jnthn> But it's nowhere near that easy to do this

[15:40] <jnthn> Since the change breaks FIRST/NEXT/LAST phasers

[15:41] <MasterDuke_> interesting, how does it break them?

[15:41] <jnthn> The code-gen for while inserts stuff to make them work

[15:42] <MasterDuke_> ha, turtles all the way down? code-gen a code-gen for while?

[15:42] <jnthn> Well, maybe take a look at how while is implemented :)

[15:42] <jnthn> I think the needed bits may well just be facotred out into a sub you can call, thinking about it

[15:42] <MasterDuke_> tweak_loop?

[15:43] <jnthn> Sounds plausible, yeah :)

[15:44] <MasterDuke_> so that would unbreak the phasers, but then would it work to not sink the while?

[15:45] <MasterDuke_> just QAST::Want the while directly?

[15:45] <jnthn> You don't even need the QAST::Want either

[15:48] <MasterDuke_> i can't test right now, but i believe that without the Want i didn't get the sink null error, but nothing got printed (for '-ne '.say' <file>)

[15:48] <jnthn> That'd be...odd

[15:49] <jnthn> (The QAST op 'while' doesn't do anything lazy)

[15:50] <MasterDuke_> i believe it took a while to run with a large file (as if it was actually reading it), but even a "say 'hi'" didn't do anything

[15:50] * dogbert17_ notices that the strange errors he's getting comes from MVM_cross_thread_write_check

[15:53] <MasterDuke_> jnthn: i'll play around with tweak_loop this evening, thanks for the help

[15:59] <jnthn> dogbert17_: Do you have MVM_CROSS_THREAD_WRITE_LOG in your environment somehow?

[16:00] <dogbert17_> jnthn?+++ I have

[16:01] <dogbert17_> so maybe my nonsense might be something after all then

[16:02] <dogbert17_> or is it a known fact that some tests suffer from cross thread writes?

[16:04] <dogbert17_> this code reliably reproduces it for me (stolen from a test file): await ^30 .map: { start { S/.+/{$/.chars.print}/ given "abc"; } }

[16:06] <jnthn> dogbert17_: There are a number of totally benign ones

[16:06] <lizmat> m: my @a := 0 ... 200   # shouldn't / didn't this work before ?

[16:06] <camelia> rakudo-moar 5556b3: OUTPUT«Type check failed in binding; expected Positional but got Seq ((0, 1, 2, 3, 4, 5, 6,...)␤  in block <unit> at <tmp> line 1␤␤»

[16:07] <jnthn> lizmat: Before the GLR

[16:07] <jnthn> And no, shouldn't.

[16:07] <lizmat> ok

[16:07] <jnthn> Use assignment or .list or .cache or @(...)

[16:08] <jnthn> Or don't stick it in an @ thing :)

[16:08] <jnthn> Depending on what you're aiming at

[16:08] <lizmat> m: my @a := 0, 1, { say $^a; $^a + 1 } ... 10   # correct this iterates on assignment ?

[16:08] <camelia> rakudo-moar 5556b3: OUTPUT«1␤2␤3␤4␤5␤6␤7␤8␤9␤Type check failed in binding; expected Positional but got Seq ((0, 1, 2, 3, 4, 5, 6,...)␤  in block <unit> at <tmp> line 1␤␤»

[16:08] <lizmat> m: my @a = 0, 1, { say $^a; $^a + 1 } ... 10   # correct this iterates on assignment ?

[16:08] <camelia> rakudo-moar 5556b3: OUTPUT«1␤2␤3␤4␤5␤6␤7␤8␤9␤»

[16:08] <jnthn> Yes, becauae assignment is eager unless the thing being assigned is marked lazy

[16:09] <jnthn> And we discovered that sequences being lazy by default caused surprises.

[16:09] <dalek> rakudo/nom: 5558710 | (Zoffix Znet)++ | src/core/List.pm:

[16:09] <dalek> rakudo/nom: Make .rotor on empty list return empty Seq

[16:09] <dalek> rakudo/nom:

[16:09] <dalek> rakudo/nom: The current version returns Rakudo::Internals.EmptyIterator, which

[16:09] <dalek> rakudo/nom: appears to be something that's meant to be returned via .iterator

[16:09] <dalek> rakudo/nom: method.

[16:09] <dalek> rakudo/nom:

[16:09] <lizmat> aha, so my @a = "file".IO.lines *will* read the whole file nowadays

[16:09] <dalek> rakudo/nom: Fix by returning ().Seq instead.

[16:09] <dalek> rakudo/nom:

[16:09] <dalek> rakudo/nom: Fixes RT#130283: https://rt.perl.org/Ticket/Display.html?id=130283

[16:09] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/5558710da6

[16:09] <synopsebot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=130283

[16:09] <dalek> roast: 891568b | (Zoffix Znet)++ | S32-list/rotor.t:

[16:09] <dalek> roast: Test .rotor on empty list returns empty Seq

[16:09] <dalek> roast:

[16:09] <dalek> roast: RT#130283: https://rt.perl.org/Ticket/Display.html?id=130283

[16:09] <dalek> roast: Rakudo fix: https://github.com/rakudo/rakudo/commit/5558710da6

[16:09] <dalek> roast: review: https://github.com/perl6/roast/commit/891568b1fa

[16:09] <synopsebot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=130283

[16:09] <lizmat> babydrop: good catch

[16:09] <jnthn> lizmat: Unless it's being marked lazy :)

[16:09] <babydrop> tsk tsk, AlexDaniel. Very unprofessional ticket :)

[16:10] <lizmat> I have been confused about the naming / use of EmptyIterator before

[16:10] <lizmat> jnthn: yeah, got that now

[16:10] <jnthn> You can force it with my @lines = lazy "foo".IO.lines;

[16:10] <lizmat> yup

[16:11] <lizmat> I guess I still assumed per-GLR behaviour in that context

[16:11] <lizmat> *pre

[16:11] <AlexDaniel> babydrop: and I'm not a proffesional bug reporter :) But I'll try better next time

[16:11] <babydrop> :D

[16:15] <dogbert17_> jnthn: thx, you have saved me from early insanity :)

[16:17] <AlexDaniel> bisect: old=2015.11 class MyInt is Any is Int { }

[16:17] <bisectable6> AlexDaniel, Bisecting by output (old=2015.11 new=5558710) because on both starting points the exit code is 1

[16:17] <bisectable6> AlexDaniel, bisect log: https://gist.github.com/3f4ef010db484d5171555ca55adf91fd

[16:17] <bisectable6> AlexDaniel, (2015-12-18) https://github.com/rakudo/rakudo/commit/c31190e8ea204691d1fdc67f53ef770403c8d6e7

[16:20] <AlexDaniel> bisect: say 255.base(16, -100)

[16:20] <bisectable6> AlexDaniel, On both starting points (old=2015.12 new=5558710) the exit code is 1 and the output is identical as well

[16:20] <bisectable6> AlexDaniel, Output on both points: digits argument to base out of range. Is: -100, should be in 0..*␤  in block <unit> at /tmp/zx8nYA_biq line 1␤␤Actually thrown at:␤  in block <unit> at /tmp/zx8nYA_biq line 1␤

[16:20] <AlexDaniel> oh really

[16:21] <AlexDaniel> bisect: old=2015.07 say 255.base(16, -100)

[16:21] <bisectable6> AlexDaniel, Bisecting by exit code (old=2015.07 new=5558710). Old exit code: 0

[16:21] <bisectable6> AlexDaniel, bisect log: https://gist.github.com/360db0e86f4c338f5aa9c09bf3fea7cf

[16:22] <bisectable6> AlexDaniel, (2015-09-08) https://github.com/rakudo/rakudo/commit/5746df26c1663f265f6b12e503f12e1f03d6b549

[16:22] <AlexDaniel> m: say 255.base(16, 9999999999999999999999999999999999999999999999999);

[16:22] <camelia> rakudo-moar 5556b3: OUTPUT«Cannot unbox 163 bit wide bigint into native integer␤  in block <unit> at <tmp> line 1␤␤»

[16:22] <AlexDaniel> say 255.base(16, 9999999999999999999999999999999999999999999999999999999999999999999999999);

[16:22] <AlexDaniel> m: say 255.base(16, 9999999999999999999999999999999999999999999999999999999999999999999999999);

[16:22] <camelia> rakudo-moar 5556b3: OUTPUT«Cannot unbox 243 bit wide bigint into native integer␤  in block <unit> at <tmp> line 1␤␤»

[16:22] <AlexDaniel> yet another resolved ticket

[16:34] <MasterDuke_> resolved?

[16:37] <MasterDuke_> ah, used to go negative

[16:47] <lizmat> m: my $odds = (3, 5 ... 15); dd $odds

[16:47] <camelia> rakudo-moar 555871: OUTPUT«Seq $odds = (3, 5, 7, 9, 11, 13, 15).Seq␤»

[16:47] <lizmat> m: my $odds = 3, 5 ... 15; dd $odds   # sorta expected that to be the same ??

[16:47] <camelia> rakudo-moar 555871: OUTPUT«Int $odds = 3␤»

[16:47] <lizmat> I guess the parens here aren't superstitious ?

[16:48] <lizmat> m: my ($odds) = 3, 5 ... 15; dd $odds   # this I can understand

[16:48] <camelia> rakudo-moar 555871: OUTPUT«Int $odds = 3␤»

[16:50] <jnthn> Item and list assignment have different precedence

[16:50] * jnthn away for a bit

[16:52] * lizmat also steps away for s bit

[16:53] <babydrop> /me wonders what are these bits and whether he wants one too....

[16:53] <babydrop> Phillips?

[16:54] <ilmari> a _tiny_ snack? even less than a nybble

[16:56] <TimToady> 2 bits'll get you a few sticks of gum anyway...

[16:57] <TimToady> Pieces of eight! Pieces of eight! Rawk!

[16:57] * TimToady hopes it's Talk like a Parrot Day...

[16:59] * TimToady wonders why the thing at :47 doesn't give a 'Useless use of ...' error

[17:00] <TimToady> something for the uu file...

[17:05] <TimToady> I guess it's vaguely possible that ... could have side effects, but usually it is used as if it were pure

[17:09] <b2gills> Is there a good reason ｢^5e0｣ is not the same as ｢0e0 ..^ 5e0｣ ( there are only 2 spec tests that fail with that change, and they  are for ｢^5e0 .perl｣ and ｢^(5/1) .perl｣ )

[17:12] <babydrop> m: dd eager ^5e0

[17:12] <camelia> rakudo-moar 555871: OUTPUT«(0, 1, 2, 3, 4)␤»

[17:13] <babydrop> m: dd eager 0e0 ..^ 5e0

[17:13] <camelia> rakudo-moar 555871: OUTPUT«(0e0, 1e0, 2e0, 3e0, 4e0)␤»

[17:13] <babydrop> s: &prefix:<^>, \(5e0)

[17:13] <SourceBaby> babydrop, Sauce is at https://github.com/rakudo/rakudo/blob/5558710/src/core/Range.pm#L655

[17:14] <babydrop> heh

[17:14] <babydrop> b2gills: are those tests in 6.c-errata or just in master?

[17:15] <babydrop> m: 5e0.Numeric.^name.say

[17:15] <camelia> rakudo-moar 555871: OUTPUT«Num␤»

[17:18] <b2gills> The relevant parts of the  test looks the same to me https://github.com/perl6/roast/blob/6.c-errata/S03-operators/range-basic.t

[17:18] <b2gills> specifically lines 43,44 combined with line 18

[17:19] <babydrop> Then unfortunatelly we can't change this in 6.c language.

[17:19] <b2gills> I did also find two errors, on lines 12,13 where they hard-code 2 and 6

[17:19] <babydrop> hehe

[17:20] <b2gills> ... only in the description though

[17:20] <babydrop> m: dd eager ^5.5

[17:20] <camelia> rakudo-moar 555871: OUTPUT«(0, 1, 2, 3, 4, 5)␤»

[17:21] <babydrop> m: dd eager 0.0..^5.5

[17:21] <camelia> rakudo-moar 555871: OUTPUT«(0.0, 1.0, 2.0, 3.0, 4.0, 5.0)␤»

[17:24] <babydrop> huggable: 6.d

[17:24] <huggable> babydrop, nothing found

[17:24] <babydrop> huggable: 6d

[17:24] <huggable> babydrop, nothing found

[17:24] <babydrop> huggable: 6.d :is: Proposals for 6.d language: https://github.com/perl6/specs/blob/master/v6d.pod

[17:24] <huggable> babydrop, Added 6.d as Proposals for 6.d language: https://github.com/perl6/specs/blob/master/v6d.pod

[17:25] <babydrop> b2gills: ^ that's the doc we have for 6.d changes. Add yourself, if you feel this is important enough :)

[17:26] <b2gills> Actually the only reason I looked into it was someone talking about ranges with two different types of bounds being slow

[17:30] <babydrop> b2gills: oh, I fixed that a few days ago

[17:30] <babydrop> m: eager 1..1e5; say now - INIT now

[17:30] <camelia> rakudo-moar 555871: OUTPUT«0.5589974␤»

[17:30] <babydrop> star: eager 1..1e5; say now - INIT now

[17:30] <camelia> star-m 2016.10: OUTPUT«6.7768728␤»

[17:30] <babydrop> m: say 6.7768728 / 0.5589974

[17:30] <camelia> rakudo-moar 555871: OUTPUT«12.12326354␤»

[17:31] <b2gills> m: eager 1e0..1e5; say now - INIT now

[17:31] <camelia> rakudo-moar 555871: OUTPUT«0.27743616␤»

[17:32] <babydrop> hm, yeah, there's still that, I suppose.

[17:33] <b2gills> m: eager 1..100000; say now - INIT now # wow so much faster yet

[17:33] <camelia> rakudo-moar 555871: OUTPUT«0.0446517␤»

[17:41] <b2gills> Which reminds me, I think that Range should be split up a bit. I think even just splitting off Str Range into its own subtype would simplify a bunch of code.

[17:53] <dalek> rakudo/nom: 55cf6fa | (Zoffix Znet)++ | src/core/Complex.pm:

[17:53] <dalek> rakudo/nom: Fix &infix:<===> on Complex failing to distinguish signed zeros

[17:53] <dalek> rakudo/nom:

[17:53] <dalek> rakudo/nom: Fixes RT#128999: https://rt.perl.org/Ticket/Display.html?id=128999

[17:53] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/55cf6fa9e1

[17:53] <synopsebot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=128999

[17:54] <dalek> roast: 15c0978 | (Zoffix Znet)++ | S32-num/negative-zero.t:

[17:54] <dalek> roast: Test &infix:<===> on Complex distinguishes signed zeros

[17:54] <dalek> roast:

[17:54] <dalek> roast: RT#128999: https://rt.perl.org/Ticket/Display.html?id=128999

[17:54] <dalek> roast: Rakudo fix: https://github.com/rakudo/rakudo/commit/55cf6fa9e1

[17:54] <synopsebot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=128999

[17:54] <dalek> roast: review: https://github.com/perl6/roast/commit/15c0978fed

[18:01] <babydrop> Is there a reason for that nqp::abs_n in there? https://github.com/rakudo/rakudo/blob/5558710/src/core/Complex.pm#L53

[18:21] <psch> m: say 2 + -1; say 2 ~ "-" ~ -1

[18:21] <camelia> rakudo-moar 55cf6f: OUTPUT«1␤2--1␤»

[18:22] <babydrop> I'll take it as "no" then :)

[18:22] <psch> well, the explicit concat of '-' is the reason vOv

[18:24] <babydrop> Thanks.

[18:25] <psch> i mean, of course i don't know the intent of the original author, and maybe $negative-number.Str is a slower code path

[18:28] <babydrop> that op is kinda broken BTW

[18:28] <babydrop> m: use nqp; say nqp::abs_n(-0e0)

[18:28] <camelia> rakudo-moar 55cf6f: OUTPUT«-0␤»

[18:28] <psch> m: use nqp; say nqp::abs_n(-1e0)

[18:28] <camelia> rakudo-moar 55cf6f: OUTPUT«1␤»

[18:29] <babydrop> j: use nqp; say nqp::abs_n(-0e0)

[18:29] <camelia> rakudo-jvm 8ca367: OUTPUT«0␤»

[18:29] <babydrop> hm, then maybe something I could fix then

[18:29] <psch> well, if -0e0 is distinct from 0e0 and ieee754 has strong opinions about that..?

[18:29] <psch> m: use nqp; say nqp::abs_i(-0)

[18:29] <camelia> rakudo-moar 55cf6f: OUTPUT«0␤»

[18:30] <babydrop> ints don't got negative zeros

[18:30] <psch> right, which is why it maybe makes sense for abs_n to not turn -0e0 into 0e0

[18:31] <babydrop> "In mathematics, the absolute value or modulus |x| of a real number x is the non-negative value of x without regard to its sign" per https://en.wikipedia.org/wiki/Absolute_value

[18:31] <babydrop> So to me that sounds like it shouldn't have a sign

[18:31] * babydrop pops up ieee

[18:31] <psch> yeah, if anything the rfc should answer abs on -0e0

[18:32] <psch> or, "published standard" actually i guess

[18:32] <babydrop> "abs(x) copies a floating-point operand x to a destination in the same format, setting the sign bit to 0 (positive)."

[18:33] <babydrop> That's the only mention of abs() I see other than a blurb about NaNs

[18:33] <psch> right, then moar seems wrong

[18:33] * babydrop will try to fix

[18:34] <babydrop> m: -0e0.abs

[18:34] <camelia> rakudo-moar 55cf6f: OUTPUT«WARNINGS for <tmp>:␤Useless use of "-" in expression "-0e0.abs" in sink context (line 1)␤»

[18:34] <babydrop> m: -0e0.abs.say

[18:34] <camelia> rakudo-moar 55cf6f: OUTPUT«WARNINGS for <tmp>:␤Useless use of "-" in expression "-0e0.abs.say" in sink context (line 1)␤0␤»

[18:34] <babydrop> m: -0e0 .abs.say

[18:34] <camelia> rakudo-moar 55cf6f: OUTPUT«-0␤»

[18:34] <babydrop> :D

[19:26] <lizmat> .tell babydrop with 15c0978f on roast, is there a reason to use is-deeply foo, True instead of ok foo ??

[19:26] <yoleaux2> lizmat: I'll pass your message to babydrop.

[19:26] <dalek> rakudo/nom: a3735af | (Zoffix Znet)++ | src/core/Complex.pm:

[19:26] <dalek> rakudo/nom: Fix stringif. of Complex failing on negative zero in img. part

[19:26] <dalek> rakudo/nom:

[19:26] <dalek> rakudo/nom: A negative zero goes through <0e0 conditional, at which point it

[19:26] <dalek> rakudo/nom: ends up as -0 via p6box_s, concatenated with a '+'.

[19:26] <dalek> rakudo/nom:

[19:26] <dalek> rakudo/nom: 1/-0e0 == -Inf, so use that knowledge to figure out the sign of the

[19:26] <dalek> rakudo/nom: zero. The nqp::abs_n() op seemed to have no point in there to me

[19:26] <dalek> rakudo/nom: (and is slower), so I removed it.

[19:26] <dalek> rakudo/nom:

[19:26] <dalek> rakudo/nom: Fixes RT#130329: https://rt.perl.org/Ticket/Display.html?id=130329

[19:26] <synopsebot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=130329

[19:26] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/a3735af278

[19:28] <dalek> roast: 967a64b | (Zoffix Znet)++ | S32-num/negative-zero.t:

[19:28] <dalek> roast: Test stringification of negative zeros in Complex

[19:28] <dalek> roast:

[19:28] <dalek> roast: RT#130329: https://rt.perl.org/Ticket/Display.html?id=130329

[19:28] <dalek> roast: Rakudo fix: https://github.com/rakudo/rakudo/commit/a3735af278

[19:28] <synopsebot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=130329

[19:28] <dalek> roast: review: https://github.com/perl6/roast/commit/967a64b8bb

[19:32] <phatbot> lizmat: well, it kinda goes back to my rant that `is` is not precise enough. And the same applies in this case too. If that op will start to return 1/0 all of a sudden, the `ok` test won't catch it, while is-deeply will.

[19:33] <phatbot> And moritz disagreed with me, back when I mentioned that, but two days ago a regression slipped through the `is` test, but it would've been caught by an is-deeply: https://github.com/perl6/roast/commit/99a9bd8774a5af8d089f59616ea55c86b00da63e

[19:33] <phatbot> Why is is-deeply a lot slower than ok?

[19:33] <lizmat> ok, I left a comment to the commit

[19:33] <lizmat> do with it what you will  :-)

[19:34] <phatbot> lizmat: so we were fixing the same ticket?

[19:34] <lizmat> yeah, no biggie  :-)

[19:34] <lizmat> wanted some distraction between proofreading and writing P6W  :-)

[19:35] <phatbot> I was actually thinking of that today.... that sooner or later we'll have that happen when I saw sena_kun hacking on a ticket

[19:37] <lizmat> as to the question why is-deeply is slowe?  well, I think it's the difference between x eqv y and x.Bool

[19:37] * lizmat starts on the P6W

[19:40] <dogbert17> oops, Program received signal SIGSEGV, Segmentation fault. [Switching to Thread 0xb5bffb40 (LWP 3985)] 0xb7ce9312 in MVM_gc_write_barrier (tc=0xa0a8420, update_root=0x0, referenced=0xb5caf910) at src/gc/wb.h:8

[19:41] * dogbert17 is once again tinkering with small nursery sizes

[19:51] <dalek> rakudo/nom: fa98875 | (Zoffix Znet)++ | src/core/Complex.pm:

[19:51] <dalek> rakudo/nom: Use lizmat++'s Complex stringification algo

[19:51] <dalek> rakudo/nom:

[19:51] <dalek> rakudo/nom: Replaces previous fix[^1] for

[19:51] <dalek> rakudo/nom: RT#130329: https://rt.perl.org/Ticket/Display.html?id=130329

[19:51] <dalek> rakudo/nom:

[19:51] <dalek> rakudo/nom: Not only liztmat's version is much easier to read, it's

[19:51] <synopsebot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=130329

[19:51] <dalek> rakudo/nom: also 1.5x times faster.

[19:51] <dalek> rakudo/nom:

[19:51] <dalek> rakudo/nom: [1] https://github.com/rakudo/rakudo/commit/a3735af278

[19:51] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/fa98875638

[19:52] <phatbot> lizmat++

[19:52] <phatbot> lizmat: as for test failing, those are for the commit I pushed an hour or so ago, so I'm guessing you just didn't have that fix in your local checkout?

[19:53] <lizmat> phatbot: lemme check that again

[19:53] <phatbot> it's 55cf6fa "2 hours ago" according to github

[19:54] <lizmat> phatbot: I didn't have 55cf6fa9e154d4e7 yet, so that's probably the reason

[19:54] <phatbot> \o/

[19:54] <lizmat> yup

[20:03] <pmurias> an eval-server for nqp-j would be awesome to speed up make j-test

[20:12] <dalek> nqp: 49d6beb | (Pawel Murias)++ | src/vm/jvm/runtime/org/perl6/nqp/ (4 files):

[20:12] <dalek> nqp: [jvm] Make nqp::findmethod throw an exception if it can't find the method.

[20:12] <dalek> nqp: review: https://github.com/perl6/nqp/commit/49d6beb34a

[20:28] <dalek> roast: f30510e | (Zoffix Znet)++ | integration/error-reporting.t:

[20:28] <dalek> roast: Test we do not refer to curly quotes as smart

[20:28] <dalek> roast:

[20:28] <dalek> roast: RT#130260: https://rt.perl.org/Ticket/Display.html?id=130260

[20:28] <dalek> roast: review: https://github.com/perl6/roast/commit/f30510e79c

[20:28] <synopsebot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=130260

[20:36] <dalek> roast: 862c53b | samcv++ | S15-unicode-information/unimatch-general.t:

[20:36] <dalek> roast: Add test to check unimatch checks short/alternate canonical Unicode

[20:36] <dalek> roast:

[20:36] <dalek> roast: property names properly.

[20:36] <dalek> roast: https://github.com/MoarVM/MoarVM/issues/448

[20:36] <dalek> roast: review: https://github.com/perl6/roast/commit/862c53b78b

[21:05] <dalek> nqp: 9ab1467 | (Pawel Murias)++ | src/vm/jvm/ (2 files):

[21:05] <dalek> nqp: [jvm] Make boxing int/num/str respect the HLL int_box/num_box/str_box setting.

[21:05] <dalek> nqp: review: https://github.com/perl6/nqp/commit/9ab146750a

[21:29] <dalek> nqp: 3ebba28 | (Pawel Murias)++ | t/serialization/01-basic.t:

[21:29] <dalek> nqp: [jvm] Fix serialization context name collisions.

[21:29] <dalek> nqp: review: https://github.com/perl6/nqp/commit/3ebba28873

[21:30] <pmurias> that shouldn't have been [jvm] tagged :/

[21:30] <phatbot> samcv: do you run make spectest to ensure no breakage happens?

[21:30] <samcv> yes

[21:31] <phatbot> ok.

[21:32] <phatbot> I'm on my phone, but 952 looks like the new multi would cause ambiguity with the one below it, no?

[21:32] * phatbot squints

[21:32] <samcv> well it only gets called when there is not a third term

[21:32] <samcv> err. wait. if there IS a third term

[21:32] <samcv> it checks the one above first

[21:34] <phatbot> m: multi foo($,$,$) {say "here"}; muti foo ($,$,$ = 42) {say "there"}; foo 1, 1, 1

[21:34] <camelia> rakudo-moar fa9887: OUTPUT«===SORRY!=== Error while compiling <tmp>␤Unexpected block in infix position (missing statement control word before the expression?)␤at <tmp>:1␤------> $,$) {say "here"}; muti foo ($,$,$ = 42)⏏ {say "there"}; foo 1, 1, 1␤    expecting…»

[21:35] <phatbot> m: multi foo($,$,$) {say "here"}; multi foo ($,$,$ = 42) {say "there"}; foo 1, 1, 1

[21:35] <camelia> rakudo-moar fa9887: OUTPUT«here␤»

[21:35] <phatbot> TIL

[21:37] <lizmat> samcv: re ab10dc42dfd2a198, in the commit message there are 5 pairs of matching brackets??

[21:37] <samcv> oh maybe i added 5 then..

[21:37] <lizmat> :-)

[21:37] <samcv> uhm

[21:37] <lizmat> you *list* five in the commit message

[21:38] <samcv> bisectable6, say q⟮test⟯

[21:38] <bisectable6> samcv, Bisecting by exit code (old=2015.12 new=fa98875). Old exit code: 1

[21:38] <bisectable6> samcv, bisect log: https://gist.github.com/af192e0c4c29b944a94cfb7e395c1946

[21:38] <bisectable6> samcv, (2016-12-12) https://github.com/rakudo/rakudo/commit/896514584e0b5b9836de6c3c73de674deeea53c4

[21:38] <samcv> bisectable6, say ⸤test⸥

[21:38] <bisectable6> samcv, On both starting points (old=2015.12 new=fa98875) the exit code is 1 and the output is identical as well

[21:38] <bisectable6> samcv, https://gist.github.com/28354b0c87cbbf7f4db9a2bcaf12de8f

[21:38] <samcv> bisectable6, say q⸤test⸥

[21:38] <bisectable6> samcv, Bisecting by exit code (old=2015.12 new=fa98875). Old exit code: 1

[21:39] <bisectable6> samcv, bisect log: https://gist.github.com/a178b948e7675ffb0aff3a4885bd86fc

[21:39] <bisectable6> samcv, (2016-12-12) https://github.com/rakudo/rakudo/commit/896514584e0b5b9836de6c3c73de674deeea53c4

[21:39] <samcv> yeah i think i added 5 then?

[21:39] <samcv> regardless all the ones we didn't have are now there :P

[21:39] <samcv> but it is 5

[22:00] <lizmat> samcv: ok, it will be so in the weekly  :-)

[22:02] <dalek> nqp: f79d66f | (Pawel Murias)++ | t/serialization/01-basic.t:

[22:02] <dalek> nqp: Skip tests on the JVM that depend on getting a null from an accessor (this is broken on the JVM).

[22:02] <dalek> nqp: review: https://github.com/perl6/nqp/commit/f79d66f453

[22:02] <samcv> :-)

[22:03] <pmurias> make j-test should now pass in nqp-j (with 2 new skipped tests)

[22:07] <phatbot> woooo

[22:07] <phatbot> pmurias++

[22:23] <dalek> rakudo/nom: b456471 | samcv++ | src/core/Cool.pm:

[22:23] <dalek> rakudo/nom: Fix unimatch so it checks canonical short/alternate unicode props

[22:23] <dalek> rakudo/nom:

[22:23] <dalek> rakudo/nom: If we don't specify a property name to check against unimatch

[22:23] <dalek> rakudo/nom: will still work the same, but if we do supply a property

[22:23] <dalek> rakudo/nom: to check against, call uniprop where the issue is fixed

[22:23] <dalek> rakudo/nom: to resolve the name.

[22:23] <dalek> rakudo/nom:

[22:23] <dalek> rakudo/nom: Passes S15-unicode-information/unimatch-general.t

[22:23] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/b45647130a

[22:23] <dalek> rakudo/nom: f8cbcac | lizmat++ | src/core/Cool.pm:

[22:23] <dalek> rakudo/nom: Merge pull request #952 from samcv/unimatch

[22:23] <dalek> rakudo/nom:

[22:23] <dalek> rakudo/nom: Fix unimatch so it checks canonical short/alternate unicode properties

[22:23] <phatbot> heh

[22:23] * phatbot got "Could not merge... refresh page" or something :)

[22:23] <lizmat> :-)

[22:23] <lizmat> and another Perl 6 Weekly hits the Net: https://p6weekly.wordpress.com/2016/12/12/2016-50-highlighting-profilesql/

[22:24] <phatbot> \o/

[22:25] <phatbot> eh, my article was posted on hacker news

[22:25] * phatbot reads first commit....

[22:25] <phatbot> Yeah, ain't reading the rest :}

[22:25] <phatbot> *comment

[22:29] <jnthn> lizmat++ # weekly

[22:30] <jnthn> phatbot: Reading comments is usually a bad idea. :)

[22:30] <phatbot> lizmat++ great weekly \o/

[22:33] <pmurias> jnthn: nqp-j has uninitialized P6opaque attributes set to null?

[22:35] <jnthn> nqp-j: class A { has $!a; method m() { say($!a.HOW.name($!a)) } }; A.new.m

[22:35] <jnthn> hmm...is there a bot here for that?

[22:35] <jnthn> nqp: class A { has $!a; method m() { say($!a.HOW.name($!a)) } }; A.new.m

[22:35] <camelia> nqp-moarvm: OUTPUT«NQPMu␤»

[22:36] <jnthn> I'd expect that to be NQPMu on all the backends, though...pretty sure it's set as part of the attribute composition protocol

[22:40] <phatbot> j: class A { has $!a; method m() { say($!a.HOW.name($!a)) } }; A.new.m

[22:40] <camelia> rakudo-jvm 8ca367: OUTPUT«Any␤»

[22:40] <phatbot> (that's not nqp, just rakudo-j)

[22:41] <[Coke]> some gold from a ycombinator thread we should appreciate:

[22:41] <[Coke]> [2] And, amazingly, Rakudo is a pretty compact executable compared to most other langs.

[22:44] <jnthn> :)

[22:45] <jnthn> 'night, #perl6-dev

[22:48] <timotimo> gnite jnthn

[22:55] <dalek> roast: a248d15 | lizmat++ | S15-unicode-information/unimatch-general.t:

[22:55] <dalek> roast: Unfudge now passing test, samcv++

[22:55] <dalek> roast: review: https://github.com/perl6/roast/commit/a248d15e5b

[23:16] <dalek> rakudo/nom: 29b228c | lizmat++ | src/core/List.pm:

[23:16] <dalek> rakudo/nom: Use Seq.new(R:I:EmptyIterator) instead of ().Seq

[23:16] <dalek> rakudo/nom:

[23:16] <dalek> rakudo/nom: Because it is about 1.5x faster and doesn't need to allocate a new

[23:16] <dalek> rakudo/nom: empty List first.

[23:16] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/29b228c4da

[23:16] <timotimo> nice

[23:16] <phatbot> TIL

[23:17] <lizmat> timotimo: oddly enough, creating a R:I:EmptySeq method that does a Seq.new(R:I:EmptyIterator) is significantly slower :-(

[23:17] <lizmat> probably not getting inlined or so

[23:18] <timotimo> huh, weird

[23:18] <timotimo> but yeah, could perhaps be

[23:20] <dalek> roast: e1a8098 | samcv++ | S15-unicode-information/uniprop.t:

[23:20] <dalek> roast: Add uniprop todo tests for 'tc', 'lc' and 'uc'

[23:20] <dalek> roast:

[23:20] <dalek> roast: Titlecase_Mapping, Lowercase_Mapping and Uppercase_Mapping

[23:20] <dalek> roast: review: https://github.com/perl6/roast/commit/e1a8098681
