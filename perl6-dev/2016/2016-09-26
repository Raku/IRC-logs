[00:14] <dalek> roast: cb31fae | (Zoffix Znet)++ | S06-signature/types.t:

[00:14] <dalek> roast: [coverage] Code.of()

[00:14] <dalek> roast: review: https://github.com/perl6/roast/commit/cb31fae884

[00:59] <Zoffix> I need help.

[00:59] <Zoffix> m: say Any ^^ sub { say "hi" }

[00:59] <camelia> rakudo-moar 922afd: OUTPUT«sub () { #`(Sub|67444872) ... }␤»

[00:59] <Zoffix> s: &infix:<^^>, \(Any, sub {})

[00:59] <SourceBaby> Zoffix, Sauce is at https://github.com/rakudo/rakudo/blob/922afd3/src/core/Bool.pm#L114

[00:59] <timotimo> mhm?

[01:00] <Zoffix> Now, here it's calling the wrong multi. I fixed it (by removing Mu from the &sub multi):

[01:00] <Zoffix> m: multi foo (Mu \a, &b) { say 'wanted' }; multi foo (Mu \a, Mu \b) { say 'wrong' }; foo 42, Code

[01:00] <camelia> rakudo-moar 922afd: OUTPUT«===SORRY!=== Error while compiling <tmp>␤Bogus postfix␤at <tmp>:1␤------> \a, Mu \b) { say 'wrong' }; foo 42, Code⏏␤    expecting any of:␤        infix␤        infix stopper␤        postfix␤        statement end␤        st…»

[01:00] <Zoffix> wat

[01:00] <Zoffix> m: multi foo (Mu \a, &b) { say 'wanted' }; multi foo (Mu \a, Mu \b) { say 'wrong' }; foo 42, Code

[01:00] <camelia> rakudo-moar 922afd: OUTPUT«wanted␤»

[01:01] <Zoffix> ^ so there. The multi works. BUT, I'm still getting the sub () { #`(Sub|67444872) ... } in the local build after that fix, instead of the evaluated value :/

[01:01] <Zoffix> m: https://gist.github.com/zoffixznet/baadcb4ac4c2b2543a1377714b019c3f

[01:01] <camelia> rakudo-moar 922afd: OUTPUT«42␤»

[01:01] <Zoffix> ^ and it even works if I copy all of the ^^ multies and rename it to something else.

[01:02] <timotimo> can you try using Callable $b instead of &b?

[01:02] <TimToady> you do realize that ^^ is a short-circuiting operator?

[01:02] <yoleaux2> 24 Sep 2016 13:43Z <dogbert17> TimToady: trying to do something about RT #129321. What should duckmap do/return if 'expression' returns undef and the element in question doesn't contain subelements? E.g. what should the following code return if anything? my @a = [1, "a"]; dd duckmap({ $_ ~~ Int ?? $_ !! Any }, @a);

[01:03] <Zoffix> TimToady, yes, but the docs say it short curcuits when "two true arguments are found": https://docs.perl6.org/routine/%5E%5E

[01:03] <TimToady> just saying the parser might be rewriting it to sumpn else

[01:04] <TimToady> much as && turns into nqp::if and such

[01:04] <Zoffix> hm

[01:05] <Zoffix> There's this in the Grammar: token infix:sym<^^>   { <sym>  <O(|%tight_or, :iffy(1), :pasttype<xor>, :thunky<..t>)> }

[01:05] <TimToady> :pasttype<xor>

[01:06] * Zoffix has no idea what that is

[01:06] <TimToady> means that it probably turns into nqp::xor

[01:06] <timotimo> so &infix:<^^> only exists for the benefit of things like [^^] or passing &infix:<^^> around in other places?

[01:06] <TimToady> just guessing, don't recall exactly

[01:06] <TimToady> yes

[01:06] <Zoffix> m: say 42 && sub { 72 }

[01:06] <camelia> rakudo-moar 922afd: OUTPUT«sub () { #`(Sub|75952216) ... }␤»

[01:06] <TimToady> prolly

[01:07] <Zoffix> Ah. Right, cause the && also has such a candidate, but I see it's not called either

[01:07] <TimToady> that's really say (sub { 72 } if 42)

[01:07] <Zoffix> s: &infix:<&&>, \(42, sub { 72 })

[01:07] <SourceBaby> Zoffix, Sauce is at https://github.com/rakudo/rakudo/blob/922afd3/src/core/Bool.pm#L103

[01:08] <TimToady> the parser feels it has the right to turn thunky ops into control flow :)

[01:08] <Zoffix> m: say [&&], 42,  sub { 72 }

[01:08] <camelia> rakudo-moar 922afd: OUTPUT«True42sub () { #`(Sub|75382592) ... }␤»

[01:08] <Zoffix> m: say [&&] 42,  sub { 72 }

[01:08] <camelia> rakudo-moar 922afd: OUTPUT«sub () { #`(Sub|64206880) ... }␤»

[01:08] <Zoffix> OK. Thanks. I'll just fix the signature and be done with it :)

[01:08] <TimToady> m: say [&&] 42, die "oops"

[01:08] <camelia> rakudo-moar 922afd: OUTPUT«oops␤  in block <unit> at <tmp> line 1␤␤»

[01:09] <TimToady> m: say [||] 42, die "oops"

[01:09] <camelia> rakudo-moar 922afd: OUTPUT«42␤»

[01:09] <TimToady> m: say [&&] 0, die "oops"

[01:09] <camelia> rakudo-moar 922afd: OUTPUT«0␤»

[01:09] <TimToady> so you see it's playing mind games with you, even as metaops

[01:11] <Zoffix> c: &infix:<&&>, \(42, {;})

[01:11] <Undercover> Zoffix, The code is hit during stresstest See http://perl6.WTF/src_core_Bool.pm.coverage.html#L103 for details

[01:12] <Zoffix> Interestingly, the candidate shows up as covered ^ so seems there are cases where it gets called

[01:12] <Zoffix> timotimo, using Callable instead of & still has the same behaviour

[01:13] <timotimo> OK

[01:14] <MasterDuke> m: say :Ⅷ2<ab>

[01:14] <camelia> rakudo-moar 922afd: OUTPUT«===SORRY!=== Error while compiling <tmp>␤Only 'Nd' digits are allowed, not 'No' or 'Nl' numbers␤at <tmp>:1␤------> say :Ⅷ⏏2<ab>␤    expecting any of:␤        colon pair␤        radix base␤»

[01:14] <MasterDuke> m: say :2Ⅷ<ab>

[01:14] <camelia> rakudo-moar 922afd: OUTPUT«===SORRY!=== Error while compiling <tmp>␤Malformed radix number␤at <tmp>:1␤------> say :2⏏Ⅷ<ab>␤    expecting any of:␤        number in radix notation␤»

[01:15] <MasterDuke> i recently made a change to "token rad_number" in Grammar.nqp to give that first error

[01:15] <MasterDuke> but i'd like to see the same error in that second case

[01:16] <MasterDuke> and i can't seem to figure it out

[01:16] <MasterDuke> anybody have an idea? source is here: https://github.com/rakudo/rakudo/blob/nom/src/Perl6/Grammar.nqp#L3412

[01:17] <TimToady> look for || <.malformed: 'radix number'>

[01:17] <timotimo> yeah

[01:17] <timotimo> was about to say

[01:20] <MasterDuke> hmm, thought i'd tried adding another case, but now not sure, giving it a shot...

[01:21] <TimToady> possibly it should just be more specific, malformed radix number; expected opening bracket

[01:22] <TimToady> the chance that anyone would actually write :2Ⅷ<ab> is so minimal I'm not sure it's worth the extra code

[01:23] <MasterDuke> ah ha! that sounds like an answer to a question i asked earlier: http://irclog.perlgeek.de/perl6-dev/2016-09-25#i_13276587

[01:24] <dalek> rakudo/nom: 3d2a919 | (Zoffix Znet)++ | src/core/Bool.pm:

[01:24] <TimToady> usually, if someone does something weird, they know they've done something weird, and if it fails with a general message, they know what to try next :)

[01:24] <dalek> rakudo/nom: Fix infix:<^^>(Mu, Callable) candidate

[01:24] <dalek> rakudo/nom:

[01:24] <dalek> rakudo/nom: Relevant conversation: http://irclog.perlgeek.de/perl6-dev/2016-09-26#i_13280363

[01:24] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/3d2a919f51

[01:25] <MasterDuke> which was inspired by RT #129319

[01:26] <MasterDuke> i'm also basing it off of personal experience/thinking. when i found out Perl 6 supported Unicode i also tried a number somewhere, not realizing there was a difference between digits and numbers

[01:26] <MasterDuke> https://rt.perl.org/Ticket/Display.html?id=129319

[01:27] <TimToady> yes, it's an important distinction to teach these days

[01:28] <TimToady> not sure this is the most likely teachable moment though :)

[01:28] <MasterDuke> (btw, who runs synopsebot6?)

[01:28] * TimToady dunnos

[01:29] * TimToady dunnoes even

[01:29] <Zoffix> I think timotimo has access to the box where it runs

[01:29] <MasterDuke> TimToady: so you would vote *against* checks/specific errors about Nl+No vs Nd in more places?

[01:31] <TimToady> that would be my inclination, in the absence of more data on the behavior of naïve users who aren't just fuzzing

[01:31] <geekosaur> logs suggest it's timotimo's

[01:32] <MasterDuke> and if so, should my earlier commit to add that error in a particular case be reverted (i don't mind)?

[01:32] <TimToady> we do feebly try to fight bloat from time to time, and error messages need to carry their weight

[01:33] <timotimo> i installed synopsebot6 on hack

[01:33] <TimToady> most users don't even know how to type Ⅷ

[01:34] <MasterDuke> i have been thinking that erroring at a lower level would perhaps be even better

[01:34] <MasterDuke> in that more cases could be covered by fewer changes

[01:34] <timotimo> there it is

[01:36] <Zoffix> m: say 5 xor 0

[01:36] <camelia> rakudo-moar 3d2a91: OUTPUT«5␤»

[01:36] <Zoffix> m: say 0 xor 0

[01:36] <camelia> rakudo-moar 3d2a91: OUTPUT«0␤»

[01:36] <TimToady> well, you can't just check for No after Nd

[01:36] <Zoffix> m: say 0 xor 1

[01:36] <camelia> rakudo-moar 3d2a91: OUTPUT«0␤»

[01:36] <TimToady> m: say 2²

[01:36] <camelia> rakudo-moar 3d2a91: OUTPUT«4␤»

[01:36] <TimToady> or that will fail

[01:36] <Zoffix> Is `xor` lazy and does it ever actually touch the second arg?

[01:37] <TimToady> xor always has to look at the 2nd arg, but maybe not the 3rd

[01:37] <Zoffix> m: say 5 xor die

[01:37] <camelia> rakudo-moar 3d2a91: OUTPUT«5␤Died␤  in block <unit> at <tmp> line 1␤␤»

[01:37] <Zoffix> aha

[01:37] <TimToady> m: say 5 xor 5 xor die

[01:37] <camelia> rakudo-moar 3d2a91: OUTPUT«5␤»

[01:37] <TimToady> hmm

[01:37] <TimToady> that's kinda wrong

[01:37] <TimToady> oh wait

[01:37] <TimToady> m: say 5 ^^ 5 ^^ die

[01:37] <camelia> rakudo-moar 3d2a91: OUTPUT«Nil␤»

[01:37] <TimToady> prec

[01:39] <MasterDuke> what about adding a check in nqp::radix?

[01:42] <dalek> roast: aec5f6e | (Zoffix Znet)++ | S02-types/bool.t:

[01:46] <dalek> roast: [coverage] Cover all uncovered operators in Bool.pm

[01:46] <dalek> roast: review: https://github.com/perl6/roast/commit/aec5f6ee55

[01:46] <TimToady> prolly won't even get there unless it parses the <>

[01:51] <MasterDuke> of course, most of the places where nqp::radix are used pass it the capture of \d+

[01:52] <TimToady> what I said

[01:52] <TimToady> only more so :)

[01:53] <MasterDuke> i'm going submit a revert request for my earlier commit and suggest the ticket should be closed, linking this conversation for both

[01:54] <MasterDuke> and if a lot more similar tickets show up we can revisit

[01:56] <TimToady> .oO(Expected an opening bracket, but you gave me an emoji, and I'm just a computer, so I don't know how to respond to that...)

[03:30] <dalek> rakudo/nom: 3aa7254 | (Cuong Manh Le)++ | src/core/ (2 files):

[03:30] <dalek> rakudo/nom: Fix IO.l throws exception for broken symlink

[03:30] <dalek> rakudo/nom:

[03:30] <dalek> rakudo/nom: Fixes RT#129162

[03:30] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/3aa725429e

[03:30] <dalek> rakudo/nom: 59e3e0e | (Zoffix Znet)++ | src/core/ (2 files):

[03:30] <dalek> rakudo/nom: Merge pull request #885 from Gnouc/nom

[03:30] <synopsebot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=129162

[03:30] <dalek> rakudo/nom:

[03:30] <dalek> rakudo/nom: Fix IO.l throws exception for broken symlink

[03:30] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/59e3e0e6e0

[03:30] <dalek> roast: 01a6909 | (Cuong Manh Le)++ | S16-filehandles/filetest.t:

[03:30] <dalek> roast: Add test for broken symlink (#160)

[03:30] <dalek> roast: review: https://github.com/perl6/roast/commit/01a69094d1

[03:30] <dalek> rakudo/nom: 3182d89 | MasterDuke17++ | src/Perl6/Grammar.nqp:

[03:30] <dalek> rakudo/nom: Revert "Error if No/Nl chars are used in colon pairs/radix"

[03:30] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/3182d897ec

[03:30] <dalek> rakudo/nom: f0b3b59 | (Zoffix Znet)++ | src/Perl6/Grammar.nqp:

[03:30] <dalek> rakudo/nom: Merge pull request #884 from MasterDuke17/revert-883-RT129319

[03:30] <dalek> rakudo/nom:

[03:30] <dalek> rakudo/nom: Revert "Error if No/Nl chars are used in colon pairs/radix"

[03:30] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/f0b3b59ec0

[04:07] <MasterDuke> m: say ⒗ + 5

[04:07] <camelia> rakudo-moar f0b3b5: OUTPUT«21␤»

[04:07] <MasterDuke> TimToady: why is ^^^ allowed

[04:08] <MasterDuke> m: say :⒗<5>

[04:08] <camelia> rakudo-moar f0b3b5: OUTPUT«===SORRY!===␤Argument to "say" seems to be malformed␤at <tmp>:1␤------> say⏏ :⒗<5>␤Confused␤at <tmp>:1␤------> say :⏏⒗<5>␤    expecting any of:␤        colon pair␤Other potential difficulties:␤    Unsupported…»

[04:08] <MasterDuke> but ^^^ isn't?

[04:21] <ShimmerFairy> m: say "⒗".uniprop

[04:21] <camelia> rakudo-moar f0b3b5: OUTPUT«No␤»

[04:21] <ShimmerFairy> probably because it's in the "Other Number" category, which I'd argue means it maaaaybe shouldn't work in the first case either.

[04:22] <MasterDuke> m: say 2²

[04:22] <camelia> rakudo-moar f0b3b5: OUTPUT«4␤»

[04:23] <MasterDuke> another case where an No works

[04:23] <MasterDuke> not exactly the same situation, but similar

[04:24] <ShimmerFairy> in that case though, the superscript is specifically an operator :)

[04:26] <MasterDuke> yep, its .unival isn't even being used

[04:28] <MasterDuke> m: say "⒗".unival; say "⒗⒗".unival

[04:28] <camelia> rakudo-moar f0b3b5: OUTPUT«16␤16␤»

[04:29] <MasterDuke> m: say "2".unival; say "22".unival

[04:29] <camelia> rakudo-moar f0b3b5: OUTPUT«2␤2␤»

[04:29] <TimToady> m: say "2".unival; say "22".univals

[04:29] <camelia> rakudo-moar f0b3b5: OUTPUT«2␤(2 2)␤»

[04:30] <TimToady> just because we allow unival numbers in general as a useful feature for ancient Sumerian programmers, doesn't mean we have to allow it in specialized spots like a radix

[04:32] <TimToady> especially in spots limited to Nd

[04:32] <MasterDuke> sure, we don't *have* to do anything, but i'm trying to figure out if there is a rule for when/where they are allowed

[04:32] <TimToady> I foresee virtually no demand for :⒗<5> to work

[04:34] <TimToady> and if there ever is, there will be slangs :)

[04:34] <MasterDuke> very likely true, i suspect i'll hardly ever use any of the unicode digits/numbers, but it just seems inconsistent

[04:35] <TimToady> sure, I love inconsistency, consistently :)

[04:36] <MasterDuke> who was it who said "consistency is the hobgoblin of little minds"?

[04:36] <MasterDuke> if i'm remembering the quote correctly

[04:37] <TimToady> Emerson

[04:38] <MasterDuke> ah ha, and it turns out i left out an important word

[04:38] <TimToady> how foolish :P

[04:38] <MasterDuke> <slow clap>

[04:38] <TimToady> though the full quote sounds like a plug for Trump...

[04:38] <AlexDaniel> “no demand”? What do you mean?? I need :⅞<0> ! I NEED IT!!! ;)

[04:39] * TimToady wonders what's on the other side of his virtuality glasses

[04:40] <AlexDaniel> ok well perhaps my previous example does not make sense. But this one definitely does: :༯<234>

[04:41] <MasterDuke> those crazy monks

[04:48] <AlexDaniel> m: .uniname.say for (0..0x1FFFF).grep({.chr.unival < 0})

[04:48] <camelia> rakudo-moar f0b3b5: OUTPUT«TIBETAN DIGIT HALF ZERO␤»

[04:48] <AlexDaniel> yeah. The only negative No in unicode

[04:49] <TimToady> that would be like a positive Yes, right?

[04:51] <AlexDaniel> committable6: HEAD say “$_ → {.uniname}” for (0..0x1FFFF).grep({.uniname ~~ /«NO»/})».chr

[04:52] <committable6> AlexDaniel, https://gist.github.com/193235d7c87d705c835117b714cda5de

[04:52] <TimToady> pre Christmas

[04:52] <AlexDaniel> 🕲 → NO PIRACY ??

[04:53] <AlexDaniel> m: say “$_ → {.uniname}” for (0..0x1FFFF).grep({.uniname ~~ /«YES»/})».chr

[04:53] <camelia> rakudo-moar f0b3b5: ( no output )

[05:01] <TimToady> m: say “$_ → {.uniname}” for (0..0x1FFFF).grep({.uniname ~~ /«YES/})».chr

[05:01] <camelia> rakudo-moar f0b3b5: OUTPUT«ᅌ → HANGUL CHOSEONG YESIEUNG␤ᇰ → HANGUL JONGSEONG YESIEUNG␤ᇱ → HANGUL JONGSEONG YESIEUNG-SIOS␤ᇲ → HANGUL JONGSEONG YESIEUNG-PANSIOS␤Ⰵ → GLAGOLITIC CAPITAL LETTER YESTU␤ⰵ → GLAGOLITIC SMALL LETTER YESTU␤ㆁ → HANGUL LET…»

[05:02] <TimToady> m: say “$_ → {.uniname}” for (0..0x1FFFF).grep({.uniname ~~ /YES»/})».chr

[05:02] <camelia> rakudo-moar f0b3b5: OUTPUT«𝨔 → SIGNWRITING EYES OPEN␤𝨕 → SIGNWRITING EYES SQUEEZED␤𝨖 → SIGNWRITING EYES CLOSED␤𝨙 → SIGNWRITING EYES HALF OPEN␤𝨚 → SIGNWRITING EYES WIDE OPEN␤𝨛 → SIGNWRITING EYES HALF CLOSED␤𝨜 → SIGNWRITING EYES WIDENING …»

[05:04] <AlexDaniel> e…yes!

[05:18] <AlexDaniel> oh no not again

[10:14] <psch> o/

[10:14] <psch> the problem with the failing NC function pointer test seems to be that we don't know everything we need to build the function that the pointer points to

[10:17] <psch> https://gist.github.com/anonymous/13aa8546fac1294601bbb54fa44f5fb6

[10:17] <psch> at least that's how i interpret that

[10:18] <psch> i mean, the test file (t/04-nativecall/19-function-pointers.t) has only one explicit 'is native' sub

[10:18] <psch> and we're dying before we reach the nativecast call

[10:19] <psch> target is a Sub+{NativeCall::Native[Sub,Str]}, anyway

[10:22] <psch> ooh, actually it's the invocation that doesn't work

[10:22] <psch> because we're actually dying in the last line of the test file

[10:23] <psch> hm, is that right that we only build the perl6 sub for an already-cast function pointer when we invoke it the first time..?

[11:44] <psch> geez i really don't know enough C for all this stuff /o\

[11:44] <pmurias> jnthn: ping

[11:44] <psch> like, does the returned function pointer even know what symbol it points at?

[11:44] <psch> or does it just point at the adress?

[12:00] <psch> ...and why does the NativeLibrary called <process> have literally *no* functions..?

[12:21] <jnthn> pmurias: pong

[12:21] <psch> yeah, i guess that's my angle right now

[12:21] <psch> figure out a way to link the returned function pointer to the lib it comes from

[12:22] <psch> i'm still really confused that it doesn't seem to be a Pointer when it's assigned from the native call that returns it though

[12:24] <psch> m: use NativeCall; sub free(int32 $) is native { * }; say &free.perl; say &free.WHAT

[12:24] <camelia> rakudo-moar f0b3b5: OUTPUT«sub free (int32 $) { #`(Sub+{NativeCall::Native[Sub,Str]}|82911560) ... }␤(Sub+{})␤»

[12:24] <psch> ^^^ that also seems wrong.  shouldn't .WHAT have the same stuff in the braces?

[12:26] <hackedNODE> m: say WHAT sub {} but role {}

[12:26] <camelia> rakudo-moar f0b3b5: OUTPUT«(Sub+{<anon|70050944>})␤»

[12:26] <hackedNODE> Yeah, I'd say so

[12:27] <psch> right

[12:28] <psch> oh, i looked wrong.  it *is* a Pointer

[12:28] <hackedNODE> s: {use NativeCall; sub free(int32 $) is native { * }; (&WHAT, \(&free))}()

[12:28] <SourceBaby> hackedNODE, Ehhh... I'm too scared to run that code.

[12:29] <psch> hah

[12:30] <psch> hum, a pointer knowing which lib it belongs to is a bogus idea, isn't it

[12:31] <jnthn> psch: Yes

[12:31] <jnthn> psch: A function pointer in C is just a memory address

[12:31] <jnthn> We've no idea what's there

[12:31] <jnthn> Hopefully it's code but really, who knows :)

[12:31] <psch> yeah, that's about as far as i understand it

[12:33] <psch> so we get an adress

[12:33] <psch> that probably points at something that we can treat as a function

[12:34] <psch> but we *don't* get a symbol name or library name

[12:34] <jnthn> Nope

[12:35] <jnthn> In some cases there isn't a symbol/library name. A function pointer may point to machien code spat out by a JIT compiler, for example. :)

[12:35] <psch> right, so we're doing the wrong thing anyway, because we're trying to look for a symbol?

[12:35] <jnthn> .oO( The code whose bark is worse than its bite )

[12:36] <psch> and instead should just... do That Other Thing That Works™..?

[12:37] <jnthn> Doing the wrong thing where?

[12:37] <psch> in t/04-nativecall/19-function-pointers.t on r-j

[12:37] <psch> it returns the pointer correctly, casts it to a sub, and on CALL-ME runs off into NativeCallOps.build()

[12:37] <jnthn> Ah, you don't know where in r-j things go wrong?

[12:37] <psch> pretty much, yeah

[12:38] <jnthn> The rest looks legit, though

[12:38] <psch> i know now we end up in the wrong spot

[12:38] <jnthn> uh, the *test*

[12:38] <jnthn> You don't need a symbol etc. to suggessfully call a function pointer

[12:38] <jnthn> Just the signature that says what arguments it expects

[12:38] <cuonglm> Hi, this ticket seems to be fixed in latest rakudo version https://rt.perl.org/Public/Bug/Display.html?id=123838

[12:38] <psch> https://gist.github.com/anonymous/13aa8546fac1294601bbb54fa44f5fb6 is some of what i'm seeing

[12:39] <jnthn> :(--> int32) for example (which means "if we call it, it returns an int32")

[12:39] <psch> yeah, i get that

[12:39] <psch> i tried setting $!setup in nativecast to get around the call into NCO.build, but that died differently

[12:39] <psch> i think something about BOOTCode maybe..?

[12:39] <psch> i don't remember exactly

[12:39] <hackedNODE> cuonglm: thanks. It's now marked as testsneeded.

[12:40] <hackedNODE> (and attachment from Paul Marquess might be it; just needs to be added to roast)

[12:41] <psch> oh, actually i think i couldn't bind to $!setup in the first place and that's what died

[12:49] <jnthn> The code in Moar is just a tad confusing, but here is the important bit:

[12:49] <jnthn> https://github.com/MoarVM/MoarVM/blob/master/src/core/nativecall.c#L398

[12:49] <jnthn> Notice how it doesn't try to even use the symbol if it's already got an entrypoint set

[12:49] <psch> yeah, we're not doing that on r-j

[12:50] <jnthn> It does pointlessly try to resolve the library

[12:50] <psch> so we do need the build() call in the backend, but can stop caring about libname and all that if we got an entry point

[12:50] <jnthn> But since it's the empty string it resolves to NULL which means "curent process", but that resolution is never used anyway

[12:50] <psch> yeah, and then it looks with an empty symbol name and dies

[12:51] <jnthn> Ah

[12:51] <jnthn> Yeah, in the Moar code it just copes :)

[12:51] <jnthn> But you don't need to look up a library at all

[12:52] <psch> right

[12:53] <hackedNODE> m: Blob.new but role {}

[12:53] <camelia> rakudo-moar f0b3b5: OUTPUT«This REPR cannot change type␤  in any mixin at gen/moar/m-Metamodel.nqp line 1318␤  in block <unit> at <tmp> line 1␤␤»

[12:59] <jnthn> Blobs are native buffers, so you dn't mix in to them

[12:59] <jnthn> *can't

[13:00] <hackedNODE> s: Hash, "new", \( )

[13:00] <SourceBaby> hackedNODE, Sauce is at https://github.com/rakudo/rakudo/blob/f0b3b59/src/core/Map.pm#L12

[13:00] <hackedNODE> s: Blob, "new", \( )

[13:00] <SourceBaby> hackedNODE, Something's wrong: ␤ERR: Too many positionals passed; expected 2 arguments but got 3␤  in sub sourcery at /home/zoffix/services/lib/CoreHackers-Sourcery/lib/CoreHackers/Sourcery.pm6 (CoreHackers::Sourcery) line 25␤  in block <unit> at -e line 6␤␤

[13:01] <hackedNODE> weird

[13:03] <hackedNODE> jnthn: I'm just looking at this line that uses a sha for .WHICH and trying to think of cases where two different objects would end up being True for === due to this: https://github.com/rakudo/rakudo/blob/nom/src/core/Buf.pm#L16

[13:05] <jnthn> It'll happen when you have a sha-1 collision. That's relatively rare (consider that Git uses sha-1s)

[13:07] <awwaiid> Rare relative to what? Winning all the world's lotteries on the same day?

[13:07] <hackedNODE> m: my $one = Blob.new(<42>); my $two = class Blob is Blob { method decode ($) {"*"} }.new; dd $one === $two

[13:07] <camelia> rakudo-moar f0b3b5: OUTPUT«Bool::False␤»

[13:07] <jnthn> Something like :)

[13:08] <hackedNODE> I was thinking more of that ^, as .WHICH returns the same value for both, but I see there's no issue there.

[13:08] <jnthn> It's somethin glike a 1 in 10^45 chance

[13:09] <jnthn> m: say 10 ** 45

[13:09] <camelia> rakudo-moar f0b3b5: OUTPUT«1000000000000000000000000000000000000000000000␤»

[13:09] <awwaiid> ok, so I guess not ALL the lotteries :)

[13:10] <jnthn> That said, I doubt we'll do it that way forevermore :)

[13:11] <hackedNODE> (as for the sourcery issue above, it's just due to it attempting to call .^can on an unpunned role)

[13:12] <hackedNODE> m: Blob.^can("new")

[13:12] <camelia> rakudo-moar f0b3b5: OUTPUT«Too many positionals passed; expected 2 arguments but got 3␤  in block <unit> at <tmp> line 1␤␤»

[13:21] <hackedNODE> m: class :: does Blob {}

[13:21] <camelia> rakudo-moar f0b3b5: OUTPUT«===SORRY!=== Error while compiling <tmp>␤P6opaque: missing attribute protocol in compose␤at <tmp>:1␤»

[13:22] <hackedNODE> Same reason as infix:<but> I guess

[13:23] <psch> oh grr

[13:23] <psch> the only javadoc i can find online for jna is for version 3.2.7 or somesuch

[13:23] <psch> and we're using 4.0.0

[13:24] <psch> ...i don't wanna clone their github repo and browse the javadoc locally :|

[13:25] <psch> oh, that doesn't even seem to be right either anyway

[13:28] <psch> 'cause the constructor they say i should be able to use doesn't exist

[13:32] <nine_> awwaiid: a SHA-1 hash is a large enough number that all the computers in the world could not brute force the number space before the universe ends. You'd need a targeted attack to have even a chance and even then no collision has been found so far.

[13:33] <nine_> Human imagination simply doesn't work anymore for such large numbers.

[13:42] <psch> aha, Function has "getter" functions for Functions, the constructors are all protected

[13:42] <psch> err, methods

[13:43] <hackedNODE> How come Blob:U is 1 .elems?

[13:43] <hackedNODE> m: dd Blob.elems; dd Blob.new.elems

[13:43] <camelia> rakudo-moar f0b3b5: OUTPUT«1␤0␤»

[13:44] <hackedNODE> m: dd 42.elems; # is that for this type of "anything can be 1 item list"

[13:44] <camelia> rakudo-moar f0b3b5: OUTPUT«1␤»

[13:45] <timotimo> i think so

[13:45] <hackedNODE> k

[13:45] <psch> multi method elems(Blob:U:)   { 1 }

[13:45] <psch> it *is* hardcoded, in any case

[13:45] <psch> so, yeah, it's probably for that kind of consistency

[13:53] <ilmari> m: dd Mu.elems

[13:53] <camelia> rakudo-moar f0b3b5: OUTPUT«Method 'elems' not found for invocant of class 'Mu'␤  in block <unit> at <tmp> line 1␤␤»

[13:56] <psch> m: use nqp; say nqp::elems(Mu)

[13:56] <camelia> rakudo-moar f0b3b5: OUTPUT«This type (Mu) does not support elems␤  in block <unit> at <tmp> line 1␤␤»

[13:57] <psch> m: say Any.elems

[13:57] <camelia> rakudo-moar f0b3b5: OUTPUT«1␤»

[13:57] <psch> m: use nqp; say nqp::elems(Any)

[13:57] <camelia> rakudo-moar f0b3b5: OUTPUT«This type (Any) does not support elems␤  in block <unit> at <tmp> line 1␤␤»

[13:58] <ilmari> m: dd Any.elems

[13:58] <camelia> rakudo-moar f0b3b5: OUTPUT«1␤»

[13:59] <hackedNODE> m: (|^10000).gist.comb(/\d+/).elems.say

[13:59] <camelia> rakudo-moar f0b3b5: OUTPUT«100␤»

[14:00] <hackedNODE> m: [|^10000].gist.comb(/\d+/).elems.say

[14:00] <camelia> rakudo-moar f0b3b5: OUTPUT«10000␤»

[14:01] <hackedNODE> m: Blob.new(|^10000).gist.comb(/\d+/).elems.say

[14:01] <camelia> rakudo-moar f0b3b5: OUTPUT«8597␤»

[14:01] <hackedNODE> mm... okay

[14:01] <timotimo> because letters

[14:03] <hackedNODE> I was more wondering about arbitrary choice to limit List to 100 els, but not other choices, but I don't think I care abou this enough to follow it further :)

[14:05] <timotimo> oh, you mean the gist thing

[14:06] <hackedNODE> yeah

[14:06] <Woodi_> for me this thing with keeping using SHA1 is just strange: https://en.wikipedia.org/wiki/SHA-1#Attacks  and git do that too. do SHA1 kids are worse becouse they are all backdoored ? :)  anyway, would be nice if using SHA1 and others was just configuration option...

[14:08] <hackedNODE> :/ but look at those numbers. 2^80, 2^60. It'll be awhile before your computer will be able to work with that many Blobs  :)

[14:10] <Woodi_> hackedNODE: I prefer "As such, the authors recommend that SHA-1 be deprecated as quickly as possible." number :)

[14:10] <nine_> Woodi_: what problem would that solve?

[14:11] <psch> "One attack against SHA-1 is Marc Stevens[39] with an estimated cost of $2.77M to break a single hash value by renting CPU power from cloud servers."

[14:11] <Woodi_> nine_: eg. someone switch precompiled module using sha ? I don't know. why not have something better ?

[14:12] <awwaiid> There is no point in "better" unless there is a problem being solved

[14:12] <Woodi_> psch: that's pure&funny marketing :)

[14:12] <nine_> Woodi_: context matters. The authors recommend deprecation of SHA-1 _as part of a cryptographic security device_.

[14:12] <psch> Woodi_: but *all* attacks in your link are either that expensive or really slow

[14:13] <psch> ah, no there's one that's only $75K - $120K

[14:14] <psch> still, consider the vector

[14:14] <Woodi_> psch: and wikipedia is place where state of the art cryptography is announced ;)

[14:14] <nine_> The attacks are that - attacks. Someone trying to find a collision on purpose. This is not something that matters in any way for our use cases.

[14:14] <psch> right

[14:14] <hackedNODE> Woodi_: replace... with what? The attacks in your link are about making a hash that will match some content. You don't need that for modules, since you already know the original value it was computer from.

[14:15] <mst> Woodi_: sha1 is fine for uniquely identifying something

[14:15] <psch> the applicable vector here is "someone writes a malicous module that replaces a different module with the same sha-1"

[14:15] <timotimo> well, you want to have a module that computes to the same hash, but has malicious code in it

[14:15] <mst> Woodi_: if you're trying to -protect- something, like a password, bcrypt is better

[14:15] <mst> Woodi_: replacing sha1 in CUR would *not* be better. it would only be *slower*

[14:15] <awwaiid> well I think people could mistakenly use .WHICH for some other comparison?

[14:15] <nine_> psch: if it has the same sha-1, rakudo will tell you that the module is already installed

[14:15] <mst> Woodi_: I fail to see why we should give you a configuration option to make perl6 slower for no good reason :)

[14:15] <psch> nine_: right, and the :auth and all also have to be same anyway first, don't they

[14:15] <mst> Woodi_: if you want a slower perl6 and no help, look at 'man nice'

[14:16] <nine_> Even having the configuration option will make Perl 6 slower

[14:16] <mst> yes

[14:16] <mst> hence my proposing Woodi_ consults 'man nice' if he wants a slower perl6

[14:16] <Woodi_> mst: slower hash is better in eg. passwd

[14:16] <mst> Woodi_: and none of the things we're discussing are passwords

[14:16] <dalek> nqp: a840081 | peschwa++ | src/vm/jvm/runtime/org/perl6/nqp/runtime/NativeCallOps.java:

[14:16] <dalek> nqp: Fix building of native functions pointers for the JVM.

[14:16] <dalek> nqp: review: https://github.com/perl6/nqp/commit/a840081627

[14:17] <mst> Woodi_: I already said bcrypt is better for passwords

[14:17] <mst> Woodi_: please read what I actually said. all of it.

[14:17] <nine_> psch: the attacker would have to chose a short-name, version and auth combination that produces the same sha-1 as the module to be replaced. And then we'd refuse to install because it's already there :)

[14:17] <Woodi_> but if you all say not to worry then I trust you it's good for me :)

[14:17] <mst> Woodi_: this is nothing like passwords.

[14:17] <dalek> rakudo/nom: 5d909c9 | peschwa++ | tools/build/NQP_REVISION:

[14:17] <dalek> rakudo/nom: Bump NQP_REVISION for R-J NativeCall fix

[14:17] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/5d909c9da9

[14:17] <mst> nine_: anyway, if the attacker can write into the CUR, we've already lost

[14:18] <psch> nine_: well, unless they replace it locally, but then i'm wondering why they're not doing a useful attack... :)

[14:18] <nine_> mst: I'm quite sure there's lots and lots and lots of ways to attack our infrastructure :)

[14:18] <timotimo> normally, multiple "not so terrible" vulnerabilities are chained together for a useful exploit

[14:18] <timotimo> but i can't see a sha1 collision in CUR as being part of such a chain

[14:18] <timotimo> (famous last words)

[14:18] <psch> anyway, down to one failure in r-j 'make test'

[14:19] <psch> anyone want to fix that one?  i fixed like, maybe 20 or so in the last few days :P

[14:19] * hackedNODE thinks http://perl6.party/post/Exploiting-Perl-6-Code-From-Down-The-Dependency-Chain would be way easier and cheaper to do than a SHA1 collision :)

[14:20] <mst> timotimo: right, as Raymond Chen would put it, you're already on the other side of the air-tight hatchway

[14:20] <Woodi_> btw. for the future, I propose to not worry about governments and agencies, etc. :)  but make things as much secure for business and anti-hacking purposes

[14:21] <hackedNODE> m: my $b = Buf.new<1 2 3>; dd $b.shift; dd $b

[14:21] <camelia> rakudo-moar f0b3b5: OUTPUT«Cannot call 'shift' on an immutable 'List'␤  in block <unit> at <tmp> line 1␤␤»

[14:21] <hackedNODE> Oh, never mind me. Missing colon :)

[14:22] <timotimo> hackedNODE: you can use invisible characters for mixing stuff into the code to make it look benign and still change the sha1 hash

[14:22] <timotimo> but really you want to have malicious code in there, and "use Anguish" seems suspicious :)

[14:23] <hackedNODE> Nah, that article is about augmenting core stuff from deep in the deps, not Anguish :)

[14:23] <timotimo> oh, right

[14:49] <pmurias> jnthn: 'static' QAST::Vars are meant to be immutable?

[14:50] <pmurias> jnthn: rakudo emits code that binds to them for role Foo[::T] {...}

[15:27] <dalek> roast: e4a190d | (Zoffix Znet)++ | S (2 files):

[15:27] <dalek> roast: [coverage] cover all* nudity in Buf.pm

[15:27] <dalek> roast:

[15:27] <dalek> roast: Except for some .splice candidates that need polishing[^1][^2]

[15:27] <dalek> roast:

[15:27] <dalek> roast: [1] https://rt.perl.org/Ticket/Display.html?id=129359

[15:27] <dalek> roast: [2] https://rt.perl.org/Ticket/Display.html?id=129358

[15:27] <dalek> roast: review: https://github.com/perl6/roast/commit/e4a190daf0

[15:28] <dalek> rakudo/nom: 74b5d7f | (Zoffix Znet)++ | t/spectest.data:

[15:28] <dalek> rakudo/nom: Add S32-container/buf.t test file

[15:28] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/74b5d7f647

[15:34] <lizmat> Zoffix: are you looking at adding those extra splice candidates, or shall I ?

[15:34] <hackedNODE> lizmat: I can do it tonight.

[15:35] <jnthn> pmurias: No, it just means they're initialized with a default value that is a wval

[15:36] <hackedNODE> Not exactly sure what's a good way to address the second ticket, though

[15:36] <jnthn> pmurias: Constrasted with contvar that does similar but clones

[15:36] <hackedNODE> m: my $b = Buf.new: <1 2 3>; $b.splice: 10

[15:36] <camelia> rakudo-moar 5d909c: OUTPUT«Len element to subbuf out of range. Is: -7, should be in 0..3␤  in block <unit> at <tmp> line 1␤␤Actually thrown at:␤  in block <unit> at <tmp> line 1␤␤»

[15:39] <lizmat> hackedNODE: will refrain from looking at it then :-)

[15:47] <RabidGravy> every once in a while I hit up against some kind of deadlock between IO::Socket::Async and sockets that aren't managed by Perl 6

[15:48] <RabidGravy> but it's a real pain to golf down to something RTable as it requires some NC thing or an external program

[15:48] <timotimo> hackedNODE: would you tell me if the coverage report parsing is any faster with my latest moarvm commit on that branch?

[15:51] <hackedNODE> timotimo: I'd be surprised if it wouldn't be :) I'll give you the numbers for how much faster the new version is when I get home tonight

[15:52] <timotimo> cool

[15:53] <timotimo> of course if you send the output of --moar through "grep annotation:" it'd be as fast as it can be

[15:53] <timotimo> maybe it'd be faster to send the whole file through a .comb, but that'd load the whole file's contents into ram at once

[15:54] <timotimo> it's 32 megabytes big and moar'll probably blow that up to 4x size because MVMCodepoint32

[15:54] <hackedNODE> that doesn't sound terrible :)

[15:54] <timotimo> it sounds bad to me, honestly

[15:55] <timotimo> i'd rather do it line-by-line

[15:55] <hackedNODE> m: 32*4

[15:55] <camelia> rakudo-moar 74b5d7: OUTPUT«WARNINGS for <tmp>:␤Useless use of "*" in expression "32*4" in sink context (line 1)␤»

[15:55] <hackedNODE> m: say 32*4

[15:55] <camelia> rakudo-moar 74b5d7: OUTPUT«128␤»

[15:55] <timotimo> do you have that much ram? :)

[15:55] <hackedNODE> 128MB?

[15:56] <hackedNODE> I think so: http://tpm2016-2.zoffix.com/gce-cpus.png

[15:56] <hackedNODE> But on a serious note...yeah, even on my weakest server I currently have 1GB free

[15:58] <timotimo> well, you said you wanted to do a coverage report parse for every single .t file in the spec test repo

[15:58] <timotimo> ideally multiple in parallel

[15:58] <timotimo> m: say 128 * 32

[15:58] <camelia> rakudo-moar 74b5d7: OUTPUT«4096␤»

[15:58] <timotimo> that'd be 4 gigabytes for *just* that bit

[15:59] <hackedNODE> :)

[16:00] <hackedNODE> I was thinking more of loading the file (and setting) once and then looping over individual test file *results* and generating results for them

[16:00] <timotimo> ah

[16:00] <timotimo> well, that'd be fine, too

[16:09] <pmurias> jnthn: docs/qast.markdown:333, "No attempt is made to ensure you do not re-bind such a symbol, but do not do this; runtimes are free to turn lookups of static lexical symbols into direct references to the symbol.

[16:09] <pmurias> "

[16:09] <jnthn> pmurias: Hmm

[16:09] <jnthn> If we actually make that happen then we need another name for it :)

[16:10] <jnthn> Because the current semantics as implemented are too useful not to have :)

[16:10] <jnthn> (We rely on them heavily.)

[16:28] <pmurias> jnthn: should I update the docs?

[16:29] <jnthn> pmurias: Yes, please :)

[16:51] <dalek> nqp: 65ed052 | (Pawel Murias)++ | src/vm/js/nqp-runtime/core.js:

[16:51] <dalek> nqp: [js] Print out code containing PRINTME for debugging purposes.

[16:51] <dalek> nqp: review: https://github.com/perl6/nqp/commit/65ed052cd3

[16:51] <dalek> nqp: 2f55a75 | (Pawel Murias)++ | nqp-js-on-js/.gitignore:

[16:51] <dalek> nqp: [js] Ignore some build products.

[17:01] <dalek> rakudo/nom: 6974b8b | (Zoffix Znet)++ | src/core/Proc (2 files):

[17:01] <dalek> rakudo/nom: Propagate Proc::Async's command to Proc.command

[17:01] <dalek> rakudo/nom:

[17:01] <dalek> rakudo/nom: Fixes RT#129362: https://rt.perl.org/Ticket/Display.html?id=129362

[17:01] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/6974b8bf5c

[17:01] <synopsebot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=129362

[17:02] <dalek> roast: 8e1a1cc | (Zoffix Znet)++ | S17-procasync/basic.t:

[17:02] <dalek> roast: Proc::Async's Proc has correct .command

[17:02] <dalek> roast:

[17:02] <dalek> roast: RT#129362: https://rt.perl.org/Ticket/Display.html?id=129362

[17:02] <dalek> roast: review: https://github.com/perl6/roast/commit/8e1a1cc7d9

[17:02] <synopsebot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=129362

[17:15] <dalek> rakudo/nom: 38ec2e2 | (Zoffix Znet)++ | src/core/Proc/Async.pm:

[17:15] <dalek> rakudo/nom: Do not avail Mu.new candidates for Proc::Async.new

[17:15] <dalek> rakudo/nom:

[17:15] <dalek> rakudo/nom: Otherwise, we get LTA errors when incorrect args are used:

[17:15] <dalek> rakudo/nom: $ ./perl6 -e 'my @some-args; await Proc::Async.new(|@some-args).start'

[17:15] <dalek> rakudo/nom: Use of uninitialized value <element> of type Any in string context.

[17:15] <dalek> rakudo/nom: Methods .^name, .perl, .gist, or .say can be used to stringify it to something meaningful.

[17:15] <dalek> rakudo/nom:   in block <unit> at -e line 1

[17:15] <dalek> rakudo/nom: no such file or directory

[17:15] <dalek> rakudo/nom:   in block <unit> at -e line 1

[17:15] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/38ec2e28fd

[17:16] <dalek> roast: 34b31b2 | (Zoffix Znet)++ | S17-procasync/basic.t:

[17:16] <dalek> roast: attempting to create Proc::Async with wrong arguments throws

[17:16] <dalek> roast: review: https://github.com/perl6/roast/commit/34b31b2fb3

[18:35] <dalek> roast: 64e0b53 | (Zoffix Znet)++ | S02-types/capture.t:

[18:35] <dalek> roast: [coverage] Cover Capture.antipairs

[18:35] <dalek> roast: review: https://github.com/perl6/roast/commit/64e0b53ace

[18:41] <dalek> roast: e4139ff | (Zoffix Znet)++ | S17-channel/basic.t:

[18:41] <dalek> roast: [coverage] Cover Channel.elems

[18:41] <dalek> roast: review: https://github.com/perl6/roast/commit/e4139ff208

[18:59] <dalek> roast: 3362fb7 | (Zoffix Znet)++ | S04-blocks-and-statements/pointy.t:

[18:59] <dalek> roast: [coverage] Cover Code.[line|file]

[18:59] <dalek> roast: review: https://github.com/perl6/roast/commit/3362fb762b

[19:01] <dalek> roast: c6efce6 | (Zoffix Znet)++ | S04-blocks-and-statements/pointy.t:

[19:01] <dalek> roast: Fix typo in comment

[19:01] <dalek> roast: review: https://github.com/perl6/roast/commit/c6efce62bc

[19:09] <masak> Zoffix: "avail"? :)

[19:12] <hackedNODE> masak: "make available".

[19:12] * hackedNODE invokes the Second Language amendment

[19:13] <masak> is that the one written by Humpty Dumpty? :)

[19:14] <dogbert17> hackedNODE: I think we (I can do a PR) should apply TimToadys fix RT #129321 and then submit a new bug for the fact that duckmap doesn't retain structure. What's your opinion?

[19:14] <synopsebot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=129321

[19:14] <dogbert17> *fix for RT ...

[19:14] <hackedNODE> dogbert17: sounds good

[19:14] <dogbert17> ok, I'll fix the PR

[19:33] * dogbert17 spectesting zzz...

[19:50] <dalek> roast: ad9f949 | (Zoffix Znet)++ | S32-num/complex.t:

[19:50] <dalek> roast: [coverage] Complex.[reals|floor]

[19:50] <dalek> roast: review: https://github.com/perl6/roast/commit/ad9f949e2b

[19:51] <RabidGravy> still quite shocked at the halving of the time it took to test 57 modules since the last time

[19:51] <RabidGravy> (less than a month ago,)

[20:10] <dogbert17> hackedNODE: PR finally sent

[20:43] <dalek> rakudo/nom: ca93ac9 | (Jan-Olof Hendig)++ | src/core/metaops.pm:

[20:43] <dalek> rakudo/nom: Fix for RT #129321

[20:43] <dalek> rakudo/nom:

[20:43] <dalek> rakudo/nom: Under some circumstances duckmap could recurse indefinitely. The problem

[20:43] <dalek> rakudo/nom: was that if the expression returned undef for an argument the code would

[20:43] <synopsebot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=129321

[20:43] <dalek> rakudo/nom: gladly take the same argument, which caused the problem, and call

[20:43] <dalek> rakudo/nom: duckmap again leading to a hang or OOM condition. After a discussion with

[20:43] <dalek> rakudo/nom: with TimToady++ in #perl6 he came up with a solution to the problem which

[20:43] <dalek> rakudo/nom: is what this commit contains.

[20:43] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/ca93ac9084

[20:43] <dalek> rakudo/nom: 447d592 | lizmat++ | src/core/metaops.pm:

[20:43] <dalek> rakudo/nom: Merge pull request #886 from dogbert17/nom

[20:43] <dalek> rakudo/nom:

[20:44] <dogbert17> oO

[20:46] * dogbert17 time to report the other duckmap bug which TimToady spotted

[20:51] <geekosaur> with with

[20:57] <dogbert17> :(

[20:58] <dogbert17> should it be fixed?

[20:58] <Zoffix> No

[20:59] <dogbert17> Zoffix: https://rt.perl.org/Public/Bug/Display.html?id=129363

[21:00] <Zoffix> Genius... my building sent everyone 24-notice of entry: "Other instructions: kindly leave the front door open between 9AM and 5PM." Anyone wanna go rob about 150 apartments?

[21:02] <dogbert17> craftsmen visit?

[21:04] <Zoffix> "Painting the front door".... humans and their silly aesthetics ~_~

[21:06] <dogbert17> m: my @a = [1, "a"]; dd duckmap(-> Int $x { $x ~~ Int ?? $x !! Any }, @a)

[21:06] <camelia> rakudo-moar 447d59: OUTPUT«(1, "a")␤»

[21:06] <lizmat> and another Perl 6 Weekly hits the Net: https://p6weekly.wordpress.com/2016/09/26/2016-39-keys-to-cover-moar-tests/

[21:06] <dogbert17> looks as if we can close RT #129321

[21:06] <synopsebot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=129321

[21:08] <Zoffix> lizmat++ good weekly

[21:09] <Zoffix> dogbert17, it still needs tests

[21:09] <dogbert17> uh oh

[21:09] <[Coke]> lizmat++ # weekly etc.

[21:17] <arnsholt> Zoffix: Actually, repainting every once in a while is an important part of maintenance as well =)

[21:17] <arnsholt> Otherwise the door will rot more easily (or rust, if it's metal)

[21:20] <Zoffix> fine :)

[21:50] <lizmat> good night, #perl6-dev!

[21:53] <Zoffix> night

[21:57] <timotimo> no mention of inline::perl5 performance improvements in the weekly :S

[22:24] <Zoffix> It was in the previous one, I think

[22:26] <timotimo> OK

[22:54] <Zoffix> Also, I won't have time to test your coverage changes today, so if not tomorrow, then Friday :)

[22:55] <timotimo> understood

[23:09] <timotimo> Zoffix: i measured it myself; it goes from 1:08m down to 18.81s (in total)
