[00:02] <dalek> roast: 1458b47 | (Zoffix Znet)++ | S12-introspection/attributes.t:

[00:02] <dalek> roast: [coverage] cover .gist of Attribute:D

[00:02] <dalek> roast: review: https://github.com/perl6/roast/commit/1458b47cfc

[00:43] <travis-ci> Rakudo build passed. Elizabeth Mattijsen 'Make spurt a multi

[00:43] <travis-ci> https://travis-ci.org/rakudo/rakudo/builds/161743252 https://github.com/rakudo/rakudo/compare/77a2ff13d282...3789a076355c

[02:36] <dalek> roast: 6cc1a85 | MasterDuke17++ | S17-procasync/stress.t:

[02:36] <dalek> roast: Test passing :out of one proc to :in of another

[02:36] <dalek> roast:

[02:36] <dalek> roast: Tests the fix for RT #129291. Add as a stresstest because while the

[02:36] <dalek> roast: segfault before the fix was repeatable, it sometimes took a while to

[02:36] <synopsebot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=129291

[02:36] <dalek> roast: happen.

[02:36] <dalek> roast: review: https://github.com/perl6/roast/commit/6cc1a85cf4

[08:12] <dalek> rakudo/nom: e9409cc | lizmat++ | src/Perl6/Metamodel/EnumHOW.nqp:

[08:12] <dalek> rakudo/nom: Give enums a .^elems method

[08:12] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/e9409ccbec

[09:03] <llfourn_> [Coke]: I just noticed you labeled RT #128846 an RFC. But I think it's a bug tbh.

[09:03] <llfourn_> m: my $a = "foo"; (with $a { $a }) = "bar";

[09:03] <llfourn_> m: my $a = "foo"; ($a with $a) = "bar";

[09:03] <llfourn_> oh is camelia not here?

[09:03] <synopsebot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=128846

[09:03] <camelia> rakudo-moar e9409c: ( no output )

[09:03] <camelia> rakudo-moar e9409c: OUTPUT«Cannot modify an immutable Str␤  in block <unit> at <tmp> line 1␤␤»

[09:04] <llfourn_> oh there we go

[09:04] <llfourn_> m: my $a = "foo"; ($a if $a) = "bar";

[09:04] <camelia> rakudo-moar e9409c: ( no output )

[09:05] <llfourn_> if "if" statement mod works and "with" in non-statement mod form works then "with" in statement mod should work :)

[09:07] <travis-ci> Rakudo build failed. Elizabeth Mattijsen 'Give enums a .^elems method'

[09:07] <travis-ci> https://travis-ci.org/rakudo/rakudo/builds/161847102 https://github.com/rakudo/rakudo/compare/3789a076355c...e9409ccbec46

[09:07] <buggable> [travis build above] ☠ Did not recognize some failures. Check results manually

[10:09] <Zoffix> 13-union

[10:15] <Zoffix> llfourn_, isn't that to do with `with` aliasing to $_?

[10:15] <Zoffix> m: my $a = 1; (if $a -> $z { $z }) = 42;

[10:15] <camelia> rakudo-moar e9409c: OUTPUT«Cannot assign to a readonly variable or a value␤  in block <unit> at <tmp> line 1␤␤»

[10:15] <Zoffix> m: my $a = 1; (if $a -> $z is rw { $z }) = 42;

[10:15] <camelia> rakudo-moar e9409c: ( no output )

[10:15] <Zoffix> m: my $a = 1; (with $a -> $z is rw { $z }) = 42;

[10:15] <camelia> rakudo-moar e9409c: ( no output )

[10:15] <Zoffix> m: my $a = 1; (with $a -> $z  { $z }) = 42;

[10:15] <camelia> rakudo-moar e9409c: OUTPUT«Cannot assign to a readonly variable or a value␤  in block <unit> at <tmp> line 1␤␤»

[10:17] <psch> m: my $a = 1; (with $a <-> $z { $z }) = 42;

[10:17] <camelia> rakudo-moar e9409c: ( no output )

[10:17] <llfourn_> Zoffix: $_ should be := to the value so it should work

[10:18] <llfourn_> := to the container rather

[10:18] <psch> m: say $_.VAR with my $a = 1

[10:18] <camelia> rakudo-moar e9409c: OUTPUT«1␤»

[10:18] <psch> m: say $_.VAR if my $a = 1

[10:18] <camelia> rakudo-moar e9409c: OUTPUT«Any␤»

[10:18] <llfourn_> my point is that it works with everything except with in statement mod form

[10:18] * psch reads up what "it" actually is

[10:19] <Zoffix> what's "everything"? I see only an if statement

[10:19] <llfourn_> err yeah I guess that is everything

[10:19] <psch> m: my $a = "foo"; ($_ given $a) = "bar"

[10:19] <camelia> rakudo-moar e9409c: ( no output )

[10:19] <psch> m: my $a = "foo"; ($_ given $a) = "bar"; say $a

[10:19] <camelia> rakudo-moar e9409c: OUTPUT«bar␤»

[10:19] <llfourn_> (and given) :P

[10:20] <Zoffix> :)

[10:20] <psch> m: my $a = "foo"; { $_ }($a) = "bar"; say $a

[10:20] <camelia> rakudo-moar e9409c: OUTPUT«bar␤»

[10:20] <llfourn_> 'with' with block form works also

[10:20] <Zoffix> m: my $a = "foo"; with $a { $_ = "bar" }

[10:20] <camelia> rakudo-moar e9409c: ( no output )

[10:20] * Zoffix nods

[10:20] <psch> yeah, that seems inconsistent

[10:21] <psch> so my C that is RF would be "this is actually at least an inconsistency, if not straight up bug"

[10:21] <llfourn_> m: my $a = "foo"; ($a andthen $_) = "bar"; say $a

[10:21] <camelia> rakudo-moar e9409c: OUTPUT«Cannot modify an immutable Str␤  in block <unit> at <tmp> line 1␤␤»

[10:21] <llfourn_> well andthen also doesn't work :\

[10:22] <psch> m: say ("a" andthen $_)

[10:22] <camelia> rakudo-moar e9409c: OUTPUT«a␤»

[10:22] <Zoffix> I changed it to LTA

[10:22] <psch> andthen does topicalization?

[10:22] <llfourn_> psch: yep :)

[10:22] <Zoffix> .oO( BUGSORTA )

[10:22] <psch> geez all these features :P

[10:23] <llfourn_> Zoffix: ok. I think $_ should always be := to the topic's container. I'll leave classification up to you :)

[10:24] <psch> yeah, implicit topicalization should always be <->

[10:25] <llfourn_> psch: does <-> mean "is rw" or "is raw"

[10:25] <llfourn_> and what is the diff between those two :o

[10:25] <llfourn_> m: say {;};

[10:25] <camelia> rakudo-moar e9409c: OUTPUT«-> ;; $_? is raw { #`(Block|62246696) ... }␤»

[10:25] <llfourn_> m: say <-> $a { };

[10:25] <camelia> rakudo-moar e9409c: OUTPUT«-> $a is rw { #`(Block|64168488) ... }␤»

[10:26] <psch> i think there's still some fuzziness wrt the difference

[10:26] <psch> but maybe that's just in my head

[10:28] <psch> S04:583 is what i remembered

[10:28] <synopsebot6> Link: http://design.perl6.org/S04.html#583_is_what_i_remembered

[10:28] <psch> oh ffs

[10:28] <psch> S04:583

[10:28] <synopsebot6> Link: http://design.perl6.org/S04.html#line_583

[10:29] <psch> well, a bit higher up, like 575 or something

[10:30] <psch> and, well, <-> is apparently 'is rw', so topicalization should always be rw, if we take 'for' as reference

[10:30] <llfourn_> m: { say $_ } for 1,2,3 # hih this works?

[10:30] <camelia> rakudo-moar e9409c: OUTPUT«1␤2␤3␤»

[10:30] <llfourn_> didn't know if you statement mod a block it runs it

[10:30] <Zoffix> "for and given privately temporize the current value of $_ for the left side of the statement and restore the original value at loop exit:"

[10:31] <Zoffix> Maybe that's why the `given` worked above but `with` and `andthen` didn't ¯\_(ツ)_/¯

[10:31] <llfourn_> ('if' works too)

[10:31] <psch> doesn't that just concern the value of $_ outside of the statement mod?

[10:32] <psch> m: $_ = "foo"; $a = "bar"; ($a if $a) = "baz"; say $a; say $_

[10:32] <camelia> rakudo-moar e9409c: OUTPUT«===SORRY!=== Error while compiling <tmp>␤Variable '$a' is not declared␤at <tmp>:1␤------> $_ = "foo"; ⏏$a = "bar"; ($a if $a) = "baz"; say $a; ␤»

[10:32] <psch> m: $_ = "foo"; my $a = "bar"; ($a if $a) = "baz"; say $a; say $_

[10:32] <camelia> rakudo-moar e9409c: OUTPUT«baz␤foo␤»

[10:32] <psch> m: $_ = "foo"; my $a = "bar"; (with $a <-> $_ { $_ }) = "baz"; say $a; say $_

[10:32] <camelia> rakudo-moar e9409c: OUTPUT«baz␤foo␤»

[10:34] <Zoffix> m: $_ = "foo"; my $a = "bar"; ($a unless $a) = "baz"; say $a; say $_

[10:34] <camelia> rakudo-moar e9409c: OUTPUT«bar␤foo␤»

[10:34] <llfourn_> ($a unless $a) will be a slip in this case

[10:35] <llfourn_> m: $_ = "foo"; my $a = "bar"; ($a unless not $a) = "baz"; say $a; say $_

[10:35] <camelia> rakudo-moar e9409c: OUTPUT«baz␤foo␤»

[10:36] <llfourn_> m: my $a = "foo"; (<-> $_ { $_ } with $a) = "bar"; say $a' # even this doesn't work :S

[10:36] <camelia> rakudo-moar e9409c: OUTPUT«===SORRY!=== Error while compiling <tmp>␤Two terms in a row␤at <tmp>:1␤------>  (<-> $_ { $_ } with $a) = "bar"; say $a⏏' # even this doesn't work :S␤    expecting any of:␤        infix␤        infix stopper␤        postfix␤ …»

[10:36] <llfourn_> m: my $a = "foo"; (<-> $_ { $_ } with $a) = "bar"; say $a # oops

[10:36] <camelia> rakudo-moar e9409c: OUTPUT«Cannot modify an immutable Str␤  in block <unit> at <tmp> line 1␤␤»

[10:36] <psch> well, yes

[10:37] <llfourn_> ?

[10:37] <psch> because you're passing a decont $a into the block

[10:37] <llfourn_> why is it decont?

[10:37] <psch> because that's the problem with statement mod with?

[10:37] <psch> m: say $_.VAR with $ = 10

[10:37] <camelia> rakudo-moar e9409c: OUTPUT«10␤»

[10:37] <psch> m: say $_.VAR if $ = 10

[10:37] <camelia> rakudo-moar e9409c: OUTPUT«Any␤»

[10:37] <psch> m: say $_.VAR given $ = 10

[10:37] <camelia> rakudo-moar e9409c: OUTPUT«10␤»

[10:37] <psch> okay, no

[10:37] <llfourn_> oh so the with is decont the value that makes sense :)

[10:38] <psch> it's just rwness

[10:38] <psch> i think :/

[10:38] <psch> ...i'm actually trying about how to map our built-in types sensibly to java types right now :S

[10:38] <psch> *trying to think

[10:43] <psch> just to explain some confusion, maybe vOv

[10:46] <psch> it's really annoying, honestly

[10:46] <psch> considering we can have any kind of type as array or parameterized List on the Java side as parameter

[10:47] <psch> i mean, it's not hard to imagine that [1,2,3] doesn't dispatch to int[], because we already don't do that on the Perl 6 side

[10:47] <psch> but does 'my Int @a = 1,2,3' dispatch to 'List<Integer>' and int[]?

[10:47] <psch> or only one of them..?

[10:48] <psch> otoh, our Int is more Long, and doesn't that mean only 'my int32 @a' should dispatch to int[]..? >_>

[10:54] <Zoffix> s: &circumfix:<[ ]>, \(1, 2, 3)

[10:54] <SourceBaby> Zoffix, Something's wrong: ␤ERR: Could not find candidate that can do \(1, 2, 3)␤  in sub sourcery at /home/zoffix/services/lib/CoreHackers-Sourcery/lib/CoreHackers/Sourcery.pm6 (CoreHackers::Sourcery) line 37␤  in block <unit> at -e line 6␤␤

[10:54] <Zoffix> aww

[10:54] <Zoffix> s: &circumfix:<[ ]>, \(1)

[10:54] <SourceBaby> Zoffix, Sauce is at https://github.com/rakudo/rakudo/blob/e9409cc/src/core/Array.pm#L1379

[10:55] <Zoffix> s: &circumfix:<[ ]>, \([1, 2, 3])

[10:55] <SourceBaby> Zoffix, Sauce is at https://github.com/rakudo/rakudo/blob/e9409cc/src/core/Array.pm#L1342

[11:28] <MasterDuke> lizmat: do you have any thoughts on RT #129248?

[11:28] <synopsebot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=129248

[11:31] <lizmat> feels to me they should be consistent, but how I'm not sure  :-)

[11:31] <yoleaux2> 21 Sep 2016 22:01Z <gfldex> lizmat: if enums would implement the role Enumeration (as the spec asked) the where-clause would not be needed

[11:34] <MasterDuke> ha, same here

[11:35] <MasterDuke> should i stick [@LARRY] on it?

[11:35] <nine> Is there any way at all to override stringification or string interpolation in a dynamic scope? I don't care how hacky.

[11:36] <timotimo> in a *dynamic* scope, oh boy

[11:36] <lizmat> MasterDuke: sounds like a plan

[11:36] <timotimo> interpolation is just turned into a series of strings and ~ operators by the compiler

[11:36] <dogbert17> o/ any ideas about RT #129321

[11:36] <synopsebot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=129321

[11:37] <timotimo> so you can't differentiate "foo $bar baz" from "foo " ~ $bar ~ " baz" any more when the compiler is done

[11:37] <nine> So if I could somehow override ~, I'd have a chance?

[11:37] <lizmat> nine: dynamically ???

[11:38] <nine> What I actually want to try is just for a lightning talk hack together a little SQL parser that eats "where foo = $foo" and can turn it into something like {foo => $foo} to feed it into DBIX::Class

[11:38] <nine> Just for show

[11:40] <gfldex> nine: overloading ~ works if you introduce a new type (SQLString or somesuch)

[11:40] <timotimo> you can wrap infix:<~>

[11:41] <dalek> roast: 9a85073 | (Aleks-Daniel Jakimenko-Aleksejev)++ | S17-procasync/stress.t:

[11:41] <dalek> roast: Fix RT ticket number after 0a49fcbe0

[11:41] <dalek> roast:

[11:41] <dalek> roast: Dear Sir/Madam. We are X, the state-owned oil and gas company

[11:41] <dalek> roast: of the Kingdom of Saudi Arabia.

[11:41] <dalek> roast:

[11:41] <dalek> roast: ??? … Ah, wrong ticket id.

[11:41] <dalek> roast: review: https://github.com/perl6/roast/commit/9a85073745

[11:42] <AlexDaniel> dammit

[11:42] <AlexDaniel> wrong commit id

[11:42] <AlexDaniel> *facepalm*

[11:42] <gfldex> nine: you may be able to steal from https://github.com/gfldex/perl6-typesafe-html

[11:44] <nine> So like:

[11:44] <nine> m: class SQLString { has $.str }; sub prefix:<sql>($str) { SQLString.new(:$str) }; multi infix:<~>(SQLString $a, Str:D $b) { "SQL: $a, Value: $b" }; my $bar = "bar"; say sql"foo" ~ $bar

[11:44] <camelia> rakudo-moar e9409c: OUTPUT«SQL: SQLString<80893016>, Value: bar␤»

[11:45] <nine> But it doesn't seem to work for interpolation:

[11:45] <nine> m: class SQLString { has $.str }; sub prefix:<sql>($str) { SQLString.new(:$str) }; multi infix:<~>(SQLString $a, Str:D $b) { "SQL: $a, Value: $b" }; my $bar = "bar"; say sql"foo=$bar"

[11:45] <camelia> rakudo-moar e9409c: OUTPUT«SQLString.new(str => "foo=bar")␤»

[11:46] <psch> m: class SQLString { has $.str; method Str { "sql " ~ self.WHICH ~ " value: " ~ $.str } }; sub prefix:<sql>($str) { SQLString.new(:$str) }; multi infix:<~>(SQLString $a, Str:D $b) { "SQL: $a, Value: $b" }; my $bar = "bar"; say sql"foo=$bar"

[11:46] <camelia> rakudo-moar e9409c: OUTPUT«SQLString.new(str => "foo=bar")␤»

[11:46] <psch> qq calls .Str apparently

[11:47] <gfldex> you may want to overload .perl as-well to unconfuse yourself

[11:47] <nine> Ah, it calls infix ~ before the prefix sql

[11:48] <nine> Can I make prefix:<sql> tighter?

[11:48] <dalek> roast: 5651b5e | (Aleks-Daniel Jakimenko-Aleksejev)++ | S17-procasync/stress.t:

[11:48] <dalek> roast: Better test description for test added in 6cc1a85cf

[11:48] <dalek> roast:

[11:48] <dalek> roast: I am also referring to the right commit hash this time.

[11:48] <dalek> roast: review: https://github.com/perl6/roast/commit/5651b5edfc

[11:49] <nine> Oh wait, it's not just a precedence thing as "foo=$bar" is just one thing

[11:49] <gfldex> m: sub prefix:<sql>(Str) is thighter(&infix:<~>) {}

[11:49] <camelia> rakudo-moar e9409c: OUTPUT«===SORRY!=== Error while compiling <tmp>␤Can't use unknown trait 'is thighter' in a sub+{precedence} declaration.␤at <tmp>:1␤    expecting any of:␤        rw raw hidden-from-backtrace hidden-from-USAGE␤        pure default DEPRECATED inlina…»

[11:49] <gfldex> m: sub prefix:<sql>(Str) is tighter(&infix:<~>) {}

[11:49] <camelia> rakudo-moar e9409c: ( no output )

[11:50] <gfldex> nine: it's not going to hurt to make it tighter

[11:51] <nine> m: class SQLString { has $.str }; sub prefix:<sql> ($str) is tighter(&infix:<~>) { SQLString.new(:$str) }; multi infix:<~>(SQLString $a, Str:D $b) { "SQL: $a, Value: $b" }; my $bar = "bar"; say sql"foo=$bar"

[11:51] <camelia> rakudo-moar e9409c: OUTPUT«SQLString.new(str => "foo=bar")␤»

[11:51] <psch> still not quite right though i suppose

[11:59] <dalek> rakudo/nom: 73ae93a | lizmat++ | src/core/Array.pm:

[11:59] <dalek> rakudo/nom: Abstract shape-setting logic on arrays

[11:59] <dalek> rakudo/nom:

[11:59] <dalek> rakudo/nom: So we don't need to change it later in several places.

[11:59] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/73ae93af81

[12:05] <lizmat> jnthn: fwiw, perl6 t/spec/S17-procasync/stress.t consistently fails for me (on OSX) with:

[12:05] <lizmat> moar(44327,0x7fff79521300) malloc

[12:05] <lizmat> : *** error for object 0x7fff533206c0: pointer being freed was not allocated

[12:18] <MasterDuke> since we just had a release, i thought now would be a good time to ask for more comments on https://github.com/rakudo/rakudo/pull/871 (Disable grammar errors when running under -e) and https://github.com/rakudo/rakudo/pull/876 (Add Nil return constraints where possible)

[12:20] <lizmat> MasterDuke: the problem with 876 is that we're pretty sure we will not want all of them

[12:21] <lizmat> but which ones we *do* want, we can't make up our minds about, apparently

[12:21] <lizmat> :-(

[12:23] <MasterDuke> it could just serve as a reference for a different PR that just does the ones that are wanted?

[12:23] <MasterDuke> or i could revert/reset/something some of the commits?

[12:25] <lizmat> considering it a meta-PR could work, I guess

[12:30] <nine> m: class SQLValue { has $.str; method Str() { "quoted(" ~ $.str.Str ~ ")" } }; multi sub infix:<~> (Str:D $str, SQLValue:D $val) { $str ~ $val.Str }; sub prefix:<sql> (&block) { my $stringy = Str.^find_method("Stringy"); my $handler = $stringy.wrap(sub ($self) { SQLValue.new(:str($self)) }); my $result = &block(); $stringy.unwrap($handler); $result }; my $foo = "bar"; say sql{"foo=$foo"}

[12:30] <camelia> rakudo-moar 73ae93: OUTPUT«foo=quoted(bar)␤»

[12:30] <nine> Yes, it's fugly :)

[12:36] <lizmat> $ 6 'enum A (<a b c>); my @a[A]; dd @a'

[12:36] <lizmat> Array.new(:shape(3,), [Any, Any, Any])

[12:36] * lizmat is pleased

[12:53] <travis-ci> Rakudo build failed. Elizabeth Mattijsen 'Abstract shape-setting logic on arrays

[12:53] <travis-ci> https://travis-ci.org/rakudo/rakudo/builds/161891642 https://github.com/rakudo/rakudo/compare/e9409ccbec46...73ae93af81b0

[12:53] <buggable> [travis build above] ☠ Did not recognize some failures. Check results manually

[12:59] <lizmat> ^^^  appears to be a flapper in "make test"

[13:05] <dalek> rakudo/nom: c4390ff | lizmat++ | src/core/Array.pm:

[13:05] <dalek> rakudo/nom: Get rid of allocate-shaped-storage

[13:05] <dalek> rakudo/nom:

[13:05] <dalek> rakudo/nom: It appears the call to allocate-shaped-storage in STORE is superfluous,

[13:05] <dalek> rakudo/nom: because it was either just called in set-shape, or the .STORE is done

[13:05] <dalek> rakudo/nom: on an array that already had its shape allocated.

[13:05] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/c4390ff107

[13:05] <dalek> rakudo/nom: fef3655 | lizmat++ | src/core/Array.pm:

[13:05] <dalek> rakudo/nom: Allow an Enum in an array shape declaration

[13:05] <dalek> rakudo/nom:

[13:05] <dalek> rakudo/nom: As suggested in https://gfldex.wordpress.com/2016/09/22/keys-are-optional/

[13:05] <dalek> rakudo/nom:

[13:05] <lizmat> review: https://github.com/rakudo/rakudo/commit/fef3655

[13:06] <lizmat> gfldex++  :-)

[13:11] <|Tux|> This is Rakudo version 2016.09-25-g73ae93a built on MoarVM version 2016.09

[13:11] <|Tux|> csv-ip5xs        8.968

[13:11] <|Tux|> test            15.648

[13:11] <|Tux|> test-t           6.874

[13:11] <|Tux|> csv-parser      16.948

[13:13] <gfldex> lizmat++ # for fixing my bug that I didn't even report

[13:13] <lizmat> eh?  the @a[Enum] one ?

[13:14] <gfldex> yes

[13:14] <lizmat> you're welcome  :-)

[13:19] <lizmat> gfldex: now, I'm not sure whether my %h{Enum} really shouldn't be an array underneath

[13:20] <lizmat> the hash is really only needed should you specify by Str and you need to look up the associated numeric value

[13:20] <gfldex> there needs to be a type check on they key but underneath it could very well be an array of fixed size

[13:20] <gfldex> but then, the spec wanted to have Hash with fixed keys (fixed at compile time)

[13:45] <MetaZoffix> It's weird that when I build Rakudo with --optimize=off a ton of stresstests fail....

[13:47] <jnthn> m: my Bool @arr = (True, False).roll(20)

[13:47] <camelia> rakudo-moar fef365: ( no output )

[13:47] <jnthn> oh, in the *shape* declaration

[13:47] <jnthn> OK, that's more sensible :P

[13:48] * jnthn misread and worried for a moment :D

[13:48] <lizmat> m: my @a[Bool]; dd @a

[13:48] <camelia> rakudo-moar fef365: OUTPUT«Array.new(:shape(2,), [Any, Any])␤»

[13:49] <jnthn> commitable: 2016.08 my @a[Bool]; dd @a

[13:49] <jnthn> commitable6: 2016.08 my @a[Bool]; dd @a

[13:49] <jnthn> committable6: help?

[13:49] <committable6> jnthn, Like this: committable6: f583f22,HEAD say ‘hello’; say ‘world’

[13:50] <jnthn> I have to compare?

[13:50] <MetaZoffix> committable6: 2016.08 my @a[Bool]; dd @a

[13:50] <committable6> MetaZoffix, ¦«2016.08»: []

[13:50] <travis-ci> Rakudo build passed. Elizabeth Mattijsen 'Allow an Enum in an array shape declaration

[13:50] <travis-ci> https://travis-ci.org/rakudo/rakudo/builds/161905742 https://github.com/rakudo/rakudo/compare/73ae93af81b0...fef3655c0fb4

[13:50] <MetaZoffix> jnthn: you don't, but you have to spell bot's name right :P

[13:50] <jnthn> MetaZoffix: Huh, how wsa what you typed different from what I typed?

[13:50] <jnthn> Oh :P

[13:51] <[Coke]> jnthn: heh.

[13:51] <ilmari> the bot is clearly called com<tab>

[13:51] <jnthn> Dunno why I didn't tab-complete the first time :)

[13:56] <ugexe> m: say reduce { $^a + $^b }, (1, 2); say reduce { $^a + $^b }, (1); say reduce { $^a + $^b }, (); # should reduce work on empty lists like `say [+] ();`?

[13:56] <camelia> rakudo-moar fef365: OUTPUT«3␤1␤Too few positionals passed; expected 2 arguments but got 0␤  in block <unit> at <tmp> line 1␤␤»

[13:56] <ugexe> m: say [+] ();

[13:56] <camelia> rakudo-moar fef365: OUTPUT«0␤»

[13:57] <[Coke]> ugexe: what would the default value be?

[13:57] <[Coke]> for an operator, we can define a multi with the right answer, aye?

[13:57] <ugexe> [Coke]: the same as `[whatever] ()` gives

[13:57] <jnthn> ugexe: I suspect it will if you pass it a multi or something that accepts arity 0/1

[13:57] <jnthn> m: say reduce &infix:<+>, ()

[13:57] <camelia> rakudo-moar fef365: OUTPUT«0␤»

[13:57] <[Coke]> ugexe: but that gives different things.

[13:57] <[Coke]> m: say [*] ();

[13:57] <camelia> rakudo-moar fef365: OUTPUT«1␤»

[13:58] <ugexe> to rephrease: should those two styles of reduce give the same thing

[13:58] <ugexe> rephrase

[13:58] <jnthn> Do you have an example where they don't?

[13:59] <jnthn> m: say [&({ $^a + $^b })] ()

[13:59] <camelia> rakudo-moar fef365: OUTPUT«===SORRY!=== Error while compiling <tmp>␤Two terms in a row␤at <tmp>:1␤------> say [&({ $^a + $^b })]⏏ ()␤    expecting any of:␤        infix␤        infix stopper␤        postfix␤        statement end␤        statement mod…»

[13:59] <MetaZoffix> m: say reduce -> $a?, $b? { $a + $b }, ()

[13:59] <camelia> rakudo-moar fef365: OUTPUT«Cannot resolve caller infix:<+>(Mu, Mu); none of these signatures match:␤    ($x = 0)␤    (\a, \b)␤    (Real \a, Real \b)␤    (Int:D \a, Int:D \b --> Int:D)␤    (int $a, int $b --> int)␤    (Num:D \a, Num:D \b)␤    (num $a, num $b)␤    (Ran…»

[13:59] <jnthn> m: my &op = { $^a + $^b }; say [&op] ()

[13:59] <camelia> rakudo-moar fef365: OUTPUT«===SORRY!=== Error while compiling <tmp>␤Two terms in a row␤at <tmp>:1␤------> my &op = { $^a + $^b }; say [&op]⏏ ()␤    expecting any of:␤        infix␤        infix stopper␤        postfix␤        statement end␤        st…»

[13:59] <jnthn> m: my &op = { $^a + $^b }; say [[&op]] ()

[13:59] <camelia> rakudo-moar fef365: OUTPUT«Too few positionals passed; expected 2 arguments but got 0␤  in block <unit> at <tmp> line 1␤␤»

[13:59] <jnthn> Same behavior as reduce

[13:59] <MetaZoffix> m: say reduce -> $a?, $b? { say 'whatever' }, ()

[13:59] <camelia> rakudo-moar fef365: OUTPUT«whatever␤True␤»

[14:00] <ugexe> m: say reduce { $^a + $^b }, 1; # "expected 2 arguments"?

[14:00] <camelia> rakudo-moar fef365: OUTPUT«1␤»

[14:01] <lizmat> jnthn: would you have anything against splitting out the 1 dimension case of array shapes into a separate role?

[14:01] <[Coke]> m: multi sub a($a,$b) {$a+$b};multi sub a() {0}; say reduce &a, ();

[14:01] <camelia> rakudo-moar fef365: OUTPUT«0␤»

[14:01] <jnthn> lizmat: Do 2 and 3 while you're add it because they also have special-cased ops that we don't use yet ;)

[14:01] <jnthn> *you're at it

[14:01] <jnthn> I just didn't get around to putting them to use yet

[14:02] <jnthn> I suspect we can share most stuff except atpos/bindpos

[14:02] <lizmat> (accessing a @a[Bool] is now 20x slower than an @a array)

[14:02] <jnthn> But yeah, special cases for 1/2/3 was The Idea, so no objects.

[14:02] <lizmat> which ops should I be looking at ?

[14:03] <jnthn> There's some 2d and 3d ops

[14:03] <jnthn> I'm pretty sure they are covered by tests in the NQP repo

[14:03] <lizmat> no special 1d ops?

[14:03] <lizmat> ok, will look

[14:03] <timotimo> https://github.com/MoarVM/MoarVM/blob/master/src/core/oplist#L706

[14:03] <jnthn> The 1d ops are just called atpos and bindpos ;)

[14:03] <timotimo> 2d, 3d, and nd

[14:03] <jnthn> (e.g. they're the exact same ops you'd use on an unshaped array)

[14:03] <lizmat> jnthn: yes, but upper bounds would need to be checked "manually" right ?

[14:04] <jnthn> No

[14:04] <lizmat> ah ?

[14:04] <jnthn> The upper bound checking is enforced by the REPR

[14:04] <jnthn> The atpos ops are polymorphic

[14:04] <jnthn> So on a VMArray they'll have resize semantics

[14:05] <jnthn> And on a MultiDimArray will throw on out-of-bounds

[14:05] <lizmat> so on array can be multidim even with 1 dim  :-)

[14:05] <jnthn> Yes

[14:05] <jnthn> MultiDim really means FixedDim I guess :)

[14:05] <lizmat> and it will get bounds checking thrown in

[14:05] <lizmat> ok

[14:06] <jnthn> Apparently the person naming it was a bit dim ;)

[14:06] <timotimo> and we'll be able to kick out bounds checking in some cases when we reach spesh and jit stages

[14:07] <lizmat> ok, lemme see if I can hack that in :-)

[14:08] <lizmat> jnthn: fwiw, not sure if you've seen It but t/spec/S17-procasync/stress.t consistently fails for me

[14:08] <lizmat> moar(63216,0x7fff79521300) malloc: *** error for object 0x7fff572ca6c0: pointer being freed was not allocated

[14:08] <jnthn> shit

[14:08] * jnthn blames OSX

[14:09] <jnthn> Maybe somebody with OSX can look into it :)

[14:09] <jnthn> Will see what it does on Windows too, maybe it also busts there

[14:10] <lizmat> who knows  :-)

[14:10] <jnthn> Though I'm hugely tempted to just concentrate on fixing Proc::Async up well and then re-impelenting the Proc class using Proc::Async :P

[14:10] <lizmat> sounds like a plan, fwiw  :-)

[14:11] <ugexe> fwiw `reduce { $a + $b } ()` in perl5 returns undef, which is more useful than an exception because you can chain together grep/map/reduce without worrying about the number of elements before the reduce

[14:11] <jnthn> Since we actually use the very same libuv APIs in both

[14:11] <lizmat> as long as we don't lose the JVM completely  :-)

[14:11] <jnthn> I think the JVM supports Proc::Async?

[14:11] <MetaZoffix> .oO( but Proc::Async.start returns a Proc... )

[14:11] <jnthn> Will have to check...

[14:11] <MetaZoffix> Procseption

[14:12] <ugexe> jvm doesnt have proc async

[14:12] <MetaZoffix> well, its Promise does :)

[14:12] <jnthn> ugexe: Yes, but in Perl 5 there's no option to design it to take advantage of multi-dispatch to specify what the base value will be

[14:12] <jnthn> And you can still write it as -> $a?, $b? { DTRT here }

[14:15] * jnthn returns to $day-off :-)

[14:18] <MetaZoffix> New blog post: "Perl 6 Core Hacking: Can Has Moar Cover?": http://perl6.party/post/Perl-6-Core-Hacking-Can-Has-Moar-Cover

[14:21] <timotimo> "bring your butterfly to work day" is the perfect opportunity to have her tested!

[14:24] <mst> ugexe: I would write that as 'reduce { $a + $b } 0, ...' in perl5 tbh

[14:24] <yoleaux2> 21 Sep 2016 21:19Z <ZoffixMobile> mst: exactly 1 year ago you told me in magnet #perl to poke you in a year about binary package installer for CPAN :)

[14:24] <mst> MetaZoffix: and, indeed, my work is grinding slowly along

[14:24] <mst> but it wasn't going to be ready for YAPC::EU this year so I shaved the alien6 yak instead

[14:26] <timotimo> MetaZoffix: maybe i didn't read carefully enough, but it says nowhere that the coverage report is far from infallible

[14:26] <MetaZoffix> mst++

[14:27] <MetaZoffix> timotimo: I mention it in the first sentence here: http://ds3:3000/post/Perl-6-Core-Hacking-Can-Has-Moar-Cover#parti:weneedtotalkaboutyourtpsreports and here mention they need improvement: http://ds3:3000/post/Perl-6-Core-Hacking-Can-Has-Moar-Cover#bettercover

[14:27] <timotimo> oh!

[14:27] <MetaZoffix> oops, wrong domain. But you get the idea :)

[14:27] <timotimo> ah

[14:27] <timotimo> yes, of course

[14:27] <timotimo> man, i'm not feeling awake at all

[14:28] <MetaZoffix> Coffee!

[14:32] <ugexe> mst: but if you want to chain map/grep/reduce would you still do `reduce { $a + $b } 0, grep { $_ > 10 } (1..9)`

[14:34] <mst> ugexe: probably not, but I fatalize undef warnings so I'd have to end up with that code before it actually passed its tests

[14:34] <mst> i.e. "I wouldn't, to begin with, but that would be a bug"

[14:36] <lizmat> afk&

[15:29] <ggoebel> How likely is it that the JVM GLR won't have happened by the time the next Google Summer of Code rolls around?

[15:29] <nine> The results of my SQL experimentation: http://niner.name/talks/DBIC%20in%20Perl%206%20revisited/

[15:29] <nine> t/test.pl6 probably demonstrates what it's about :)

[15:31] <ggoebel> If not, how likely that the JVM GLR would be a viable/submitted/accepted SoC project?

[15:55] <Kolin_> ggoebel: so when is the next SoC?

[15:56] <TimToady> um, next S

[15:56] <stmuk> northern hemisphere

[15:57] <Kolin_> committable6: 2015.07 say (<a b c>, (<a b c>))

[15:57] <committable6> Kolin_, ¦«2015.07»: a b c a b c

[15:57] <Kolin_> r: say (<a b c>, (<a b c>))

[15:57] <camelia> rakudo-jvm cd19db, rakudo-moar fef365: OUTPUT«((a b c) (a b c))␤»

[15:57] <TimToady> I'm not sure JVM GLR is quite a thing, since most of the GLR work was at the rakudo and nqp levels, what remains might just be a smattering of bugs

[15:57] <Kolin_> Yeah

[15:58] <nine> And a lot of it is probably just looking at the workarounds that were done and figure out what the real fix would be like

[16:09] <Kolin_> What are some good programming books to read? To become better at Rakudo/NQP/MoarVM hacking?

[16:11] <ggoebel> Kolin_: The Google SoC timeline for 2016: https://developers.google.com/open-source/gsoc/timeline

[16:13] <ggoebel> SoC is announced in October. Organizations begin submitting applications in February. Applicants apply in March. Accepted Proposals/Students announced in April. Work runs from May to August with various checkpoints and deadlines. Results of SoC Projects are reported at the end of August

[16:13] <Kolin_> ggoebel: right, but see what others said about. JVM GLR isn't really a thing

[16:13] <stmuk> Kolin_: its more online resources (perl6.party blog etc.)  and just trying it

[16:14] <Kolin_> Surely there's more to it.

[16:15] <ggoebel> TimToady: Perhaps I'm mistaking, but I've had the impression that Rakudo on JVM hasn't been a first class citizen since the GLR...

[16:15] <ggoebel> s/mistaking/mistaken/

[16:15] <Kolin_> ggoebel: right, but I don't think it's GLR itself that's the issue. It's just after GLR it hasn't kept up

[16:15] <Kolin_> ggoebel: you can run the stresstest and see what tests are failing to see its current state. Rakudo on MoarVM passes all of them

[16:16] <Kolin_> ggoebel: git clone https://github.com/rakudo/rakudo/; cd rakudo; perl Configure.pl --gen-nqp --backends=jvm; make; make test; make install; TEST_JOBS=8 make stresstest;

[16:16] <ggoebel> Kolin_: I got the impression that JVM not being kept up coincided with the GLR

[16:17] <Kolin_> ggoebel: it also coinsided with frantic efforts to make something releasable for Christmas

[16:18] <Kolin_> (if you also want to run Perl5 tests, install Inline::Perl5 per step 12 on https://github.com/rakudo/rakudo/blob/nom/docs/release_guide.pod )

[16:18] <nine> Kolin_: TimToady already stated that a 6.c release without JVM is ok back at his FOSDEM talk in February 2015

[16:18] <nine> ggoebel: ^^^

[16:19] <TimToady> it would be nice if we could catchup the JVM by 6.d, which is hopefully before next summer

[16:22] <ggoebel> TimToady: okay. One of my offspring is a CS Major who might be interested in a Perl6 JVM SoC project if "it would be nice" doesn't turn out to be practical by next Summer.

[16:27] <ggoebel> phenny: seen colomon?

[16:27] <ggoebel> hmm

[16:27] <Kolin_> .seen colomon

[16:27] <yoleaux2> I haven't seen colomon around.

[16:30] <ggoebel> where is the nice webpage which shows what is implemented in red, yellow, and green?

[16:31] <timotimo> http://perl6.org/compilers/features - ggoebel

[16:31] <Kolin_> It's outdated tho

[16:31] <Ven`> It's been some time :-).

[16:31] <timotimo> yeah

[16:32] <Kolin_> r: Proc::Async.new

[16:32] <camelia> rakudo-jvm cd19db: ( no output )

[16:32] <camelia> ..rakudo-moar fef365: OUTPUT«Proc::Async is disallowed in restricted setting␤  in sub restricted at src/RESTRICTED.setting line 1␤  in method new at src/RESTRICTED.setting line 32␤  in block <unit> at <tmp> line 1␤␤»

[16:33] <Kolin_> j: say shell 'ls *'

[16:33] <camelia> rakudo-jvm cd19db: OUTPUT«Proc.new(in => IO::Pipe, out => IO::Pipe, err => IO::Pipe, exitcode => 0, pid => Any, signal => 0)␤»

[16:33] <Kolin_> j: shell(:out 'ls *').out.slurp-rest.say

[16:33] <camelia> rakudo-jvm cd19db: OUTPUT«===SORRY!=== Error while compiling <tmp>␤Unable to parse expression in argument list; couldn't find final ')' ␤at <tmp>:1␤------> shell(:out⏏ 'ls *').out.slurp-rest.say␤    expecting any of:␤        infix␤        infix stopper␤»

[16:33] <ggoebel> So the way to figure out the roadmap to bring JVM up to snuff would be to run the stress test, pick a bug, lather, rinse, and repeat?

[16:34] <Kolin_> ggoebel: yeah. And in particular, you can grep the roast for #?rakudo.jvm fudge

[16:34] <Kolin_> All of stuff involving Proc::Async is fudged; I think there's unicode stuff too

[16:34] <Kolin_> j: shell(:out, 'ls *').out.slurp-rest.say

[16:34] <camelia> rakudo-jvm cd19db: OUTPUT«dalek-queue␤evalbot.log␤foo␤mbox␤p6eval-token␤rakudo-star-2016.01.tar.gz␤rakudo-star-2016.04.tar.gz␤test␤␤Perlito:␤ChangeLog␤LICENSE.md␤Makefile␤README-howto-release.md␤README-perlito5-Java.md␤README-perlito5-JavaScript.md␤RE…»

[16:35] <timotimo> oooh, the dancercon is already going on

[16:35] <Kolin_> Apparently, it isn't using the restricted setting :)

[16:36] <ggoebel> :(

[16:36] <Kolin_> ggoebel: here's one example of the fudge I was talking about: https://github.com/perl6/roast/blob/master/S15-string-types/Str.t#L12

[16:37] <Kolin_> r: "ẛ̣".chars

[16:37] <camelia> rakudo-jvm cd19db, rakudo-moar fef365: ( no output )

[16:37] <Kolin_> r: "ẛ̣".chars.say

[16:37] <camelia> rakudo-jvm cd19db: OUTPUT«3␤»

[16:37] <camelia> ..rakudo-moar fef365: OUTPUT«1␤»

[16:48] <AlexDaniel> haha

[16:48] <AlexDaniel> was looking at this query

[16:48] <AlexDaniel> committable6: 2015.07 say (<a b c>, (<a b c>))

[16:48] <committable6> AlexDaniel, ¦«2015.07»: a b c a b c

[16:48] <AlexDaniel> and wondering what the hell

[16:48] <AlexDaniel> took me a while to realize that it is 2015.07, not 2016.07

[17:24] <dalek> roast: b9264ae | usev6++ | S (2 files):

[17:24] <dalek> roast: Fudge newly added tests for JVM

[17:24] <dalek> roast: review: https://github.com/perl6/roast/commit/b9264ae26b

[19:08] <[Coke]> t/spec/S10-packages/precompilation.t is failing here.

[19:19] <TimToady> seems to work here

[19:19] <TimToady> (I'm running with bleadmoar though)

[19:21] <TimToady> so I've got the recent syncpipe fix, which could be operative in a test running subprocesses

[19:22] <[Coke]> I'm also running with bleadmoar

[19:22] <[Coke]> and nqp

[19:22] <[Coke]> opt/local/bin/perl5.22 Configure.pl "--gen-moar=master" "--gen-nqp=master" $*

[19:22] <TimToady> (btw, the syncpipe fix didn't change the hang of my unit lexical scope patch)

[19:25] <timotimo> damn

[19:37] <TimToady> I did, however, get a non-reproducible fail with t/spec/S02-literals/allomorphic.t

[20:08] <nine> [Coke]: is the precompilation.t failure reproducible?

[20:19] <dalek> rakudo/nom: 4bcd7e0 | niner++ | src/core/CompUnit/Repository/ (2 files):

[20:19] <dalek> rakudo/nom: Fix GLOBAL symbol clash re-compiling due to a repo change

[20:19] <dalek> rakudo/nom:

[20:19] <dalek> rakudo/nom: After we detected that we need to re-compile a module because one of its

[20:19] <dalek> rakudo/nom: dependencies changed, we sometimes turned out to try loading the old

[20:19] <dalek> rakudo/nom: version again due to a stale precomp unit cache. However the module

[20:19] <dalek> rakudo/nom: would load just fine on the next try.

[20:19] <dalek> rakudo/nom:

[20:19] <dalek> rakudo/nom: The reason was that we invalidated the cache of a different precomp

[20:19] <dalek> rakudo/nom: store object than what we used for loading precomp files as the

[20:19] <dalek> rakudo/nom: repository implementations created different objects for the precomp

[20:19] <dalek> rakudo/nom: store list (used for loading) and the accessors of their own store (used

[20:19] <dalek> rakudo/nom: for storing).

[20:19] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/4bcd7e07b6

[20:20] <nine> Zoffix: that ^^^ is the fix for the bug you reported on Tuesday

[20:31] <dalek> rakudo/nom: e51cc33 | lizmat++ | t/spectest.data:

[20:31] <dalek> rakudo/nom: Mark S17-procasync/stress.t as a stress test

[20:31] <dalek> rakudo/nom:

[20:31] <dalek> rakudo/nom: The name sorta gives it away, no?

[20:31] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/e51cc333dc

[20:32] <nine> lizmat: is it actually a stress test though? It takes about 3 seconds here

[20:32] <lizmat> well, not sure...

[20:32] <lizmat> why would it be called stress.t ?

[20:33] <ZoffixMobile> nine++ thanks

[20:33] <ZoffixMobile> the stress.t hung for me today, or at least appeared to

[21:09] <dalek> rakudo/nom: 553cedb | lizmat++ | src/core/native_array.pm:

[21:09] <dalek> rakudo/nom: We can also use Enums for native array shapes

[21:09] <dalek> rakudo/nom:

[21:09] <dalek> rakudo/nom: So that 'my int @a[Bool]' will create a 2-element native array

[21:09] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/553cedb679

[21:09] <timotimo> neato.

[21:11] <lizmat> will look at the 2d/3d cases the coming days

[21:11] <lizmat> this was LHF  :-)

[21:12] <lizmat> m: Bool.^elems.say  # the new ^elems makes things a lot easier

[21:12] <camelia> rakudo-moar e51cc3: OUTPUT«2␤»

[21:24] <masak> yay

[21:28] <lizmat> m: my int $a = True; say $a   # expected

[21:28] <camelia> rakudo-moar e51cc3: OUTPUT«1␤»

[21:29] <lizmat> m: my str $a = True; say $a   # NOT expected

[21:29] <camelia> rakudo-moar e51cc3: OUTPUT«This type cannot unbox to a native string: P6opaque, Bool␤  in block <unit> at <tmp> line 1␤␤»

[21:29] <lizmat> this feels like a bug / oversight to me

[21:29] <lizmat> m: my %h = True => 42; dd %h{True}  # as this works

[21:29] <camelia> rakudo-moar e51cc3: OUTPUT«Int %h = 42␤»

[21:30] <lizmat> anyways, going to sleep on that

[21:30] <lizmat> good night, #perl6-dev!

[21:31] <timotimo> huh

[21:31] <timotimo> well, Enum is Int, but not Str

[21:35] <TimToady> the default key type of a hash is not really Str, but Str()

[21:36] <timotimo> very true

[21:56] <dalek> roast: 3c3b8c6 | usev6++ | S32-io/socket-recv-vs-read.t:

[21:56] <dalek> roast: Use different ports for IO::Socket::Async servers

[21:56] <dalek> roast:

[21:56] <dalek> roast: We already use port 5000 in S32-io/IO-Socket-Async.t

[21:56] <dalek> roast: review: https://github.com/perl6/roast/commit/3c3b8c63e7

[23:54] <Zoffix> Found a piece of code that, form what I gather can't be accessed: http://perl6.wtf/src_core_Backtrace.pm.coverage.html#L282

[23:54] <Zoffix> c: Backtrace.new, 'map', \({...})

[23:54] <Undercover> Zoffix, The code is hit during stresstest See http://perl6.WTF/src_core_Any-iterable-methods.pm.coverage.html#L19 for details

[23:54] <Zoffix> ^ that's not the right multi

[23:54] <Zoffix> m: Backtrace.new.map: {...}

[23:54] <camelia> rakudo-moar 553ced: OUTPUT«Ambiguous call to 'map'; these signatures all match:␤:(\SELF: &block;; :$label, :$item, *%_)␤:(Backtrace:D $: $block, *%_)␤  in block <unit> at <tmp> line 1␤␤»

[23:55] <Zoffix> What do we do?

[23:56] <Zoffix> c: Backtrace.new, 'map', \(42)

[23:56] <Undercover> Zoffix, The code is NOT hit during stresstest See http://perl6.WTF/src_core_Backtrace.pm.coverage.html#L282 for details

[23:57] * Zoffix giggles at &block; being interpreted as an HTML entity in the reports
