[00:00] <Zoffix> m: dd % .classify-list: sub ($x) { $x eq 'a' ?? 'z' !! <x y> }, <a b c>

[00:00] <camelia> rakudo-moar e8a61d: OUTPUT«Hash % = {:x(${:y($["b", "c"])}), :z($["a"])}␤»

[00:00] <Zoffix> m: dd % .classify-list: sub ($x) { $x eq 'a' ?? 'a' !! <a b> }, <a b c>

[00:00] <camelia> rakudo-moar e8a61d: OUTPUT«Type Array does not support associative indexing.␤  in block <unit> at <tmp> line 1␤␤Actually thrown at:␤  in block <unit> at <tmp> line 1␤␤»

[00:00] <Zoffix> heh. piece of crap :)

[00:01] <Zoffix> And I guess that might answer my question as to why mapper needs to return same-level items

[00:01] * Zoffix will fix this tomorrow

[00:02] <Zoffix> committable6, 2016.09 dd % .classify-list: sub ($x) { $x eq 'a' ?? 'a' !! <a b> }, <a b c>

[00:02] <committable6> Zoffix, ¦«2016.09»: No build for this commit

[00:02] <Zoffix> :/

[00:02] <Zoffix> committable6, 2016.08 dd % .classify-list: sub ($x) { $x eq 'a' ?? 'a' !! <a b> }, <a b c>

[00:02] <committable6> Zoffix, ¦«2016.08»: Hash % = {:a($["a"])}

[00:03] <Zoffix> committable6, 2016.08 dd % .classify-list: sub ($x) { $x ne 'a' ?? 'a' !! <a b> }, <a b c>

[00:03] <committable6> Zoffix, ¦«2016.08»: P6opaque: no such attribute '$!reified' in type List when trying to get a value␤  in block <unit> at /tmp/5vB89pKlip line 1␤ «exit code = 1»

[00:20] <japhb> Zoffix: Thanks for posting the workaround, I should have thought of the mixed-in-role approach, duh.  (I still find myself stuck in C thinking when it comes to attaching extra data to something generated by a library.)

[00:20] <yoleaux2> 24 Sep 2016 20:55Z <Zoffix> japhb: Here's one way of doing it: https://gist.github.com/zoffixznet/c47f02fc7772147eafdb72e0be1f6dcd  Feel free to open an Issue in the repo and I'll take a look at it. Will probably be just another subclass of IRC::Client::Message

[00:20] <japhb> I created an issue as requested.

[00:30] <Zoffix> thanks

[00:37] <MasterDuke> m: say :36<Ⅷ>

[00:37] <camelia> rakudo-moar e8a61d: OUTPUT«===SORRY!=== Error while compiling <tmp>␤Malformed radix number␤at <tmp>:1␤------> say :36<⏏Ⅷ>␤    expecting any of:␤        number in radix notation␤»

[00:38] <MasterDuke> i have a patch to src/Perl/Grammar.nqp that changes the error message to "Only 'Nd' digits are allowed here, not 'No' or 'Nl' numbers at -e:1 ------> say :36<Ⅷ⏏>    expecting any of:         number in radix notation"

[00:40] <MasterDuke> however, it breaks a couple radix literal tests, but only because it changes the type of the Exception they're expecting

[00:41] <MasterDuke> i could probably work the patch so the Exception type doesn't change, but it (probably) won't be quite as clean

[00:42] <MasterDuke> does anybody have an opinion?

[00:43] <MasterDuke> and relatedly, should i go ahead and try to do something similar to the (probably lots of) other places where only Nd's are allowed?

[01:40] <dalek> rakudo/nom: 74ca01d | (Zoffix Znet)++ | src/core/Hash.pm:

[01:40] <dalek> rakudo/nom: Revert "Fix Hash.classify-list for mixed-level classifications"

[01:40] <dalek> rakudo/nom:

[01:40] <dalek> rakudo/nom: This reverts commit b4a4b604945772a828e9edb0fa8b1cb295e8bf7a.

[01:40] <dalek> rakudo/nom:

[01:40] <dalek> rakudo/nom: Mixed-level classifications cause issues when values at one level

[01:40] <dalek> rakudo/nom: are same as keys for deeper levels and speculation explicitly says

[01:40] <dalek> rakudo/nom: all lists returned from mappers for multi-level classifications must

[01:40] <dalek> rakudo/nom: be of same length.

[01:40] <dalek> rakudo/nom:

[01:40] <dalek> rakudo/nom: Instead, logic needs to be added to check that all levels are the same,

[01:40] <dalek> rakudo/nom: so we do not produce confusing error messages when they aren't the same.

[01:40] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/74ca01d94e

[01:41] <dalek> roast: 9f1d349 | (Zoffix Znet)++ | S32-list/classify-list.t:

[01:41] <dalek> roast: Remove mixed-level classify tests

[01:41] <dalek> roast:

[01:41] <dalek> roast: Mixed level functionality was added to Rakudo *today* in [^1] and removed

[01:41] <dalek> roast: same day in [^2], because it can't work perfectly due to key clashes (and

[01:41] <dalek> roast: speculation advises for same-level multi-level classifications only). The

[01:41] <dalek> roast: multi-level classify tests were added at the same time the feature was

[01:41] <dalek> roast: added to Rakudo, so it's fine to remove them as they were not part of 6.c

[01:41] <dalek> roast: and exited for less than 24 hours.

[01:41] <dalek> roast:

[01:41] <dalek> roast: [1] https://github.com/rakudo/rakudo/commit/b4a4b604945772a828e9edb0fa8b1

[01:41] <dalek> roast: [2] https://github.com/rakudo/rakudo/commit/74ca01d94ef8d7c25f776e6adbc27

[01:41] <dalek> roast: review: https://github.com/perl6/roast/commit/9f1d349a61

[01:41] <Zoffix> s/exited/existed/;

[01:56] <dalek> rakudo/nom: 690d4a8 | (Zoffix Znet)++ | src/core/Exception.pm:

[01:56] <dalek> rakudo/nom: Do not add quotes around $.value on X::Invalid::ComputedValue

[01:56] <dalek> rakudo/nom:

[01:56] <dalek> rakudo/nom: to make it more flexible

[01:56] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/690d4a87d7

[02:10] <Zoffix> I'm trying to throw X::Invalid::ComputedValue in Hash.pm, but it's telling me ``Could not find symbol '&ComputedValue'``. How do I get around that?

[02:11] * Zoffix notices exception stubs in Array.pm

[02:11] <Zoffix> I guess that's the normal way.

[02:37] <dalek> rakudo/nom: 9dcde75 | (Zoffix Znet)++ | src/core/Hash.pm:

[02:37] <dalek> rakudo/nom: Throw helpful error when attempting to use mixed-level classify

[02:37] <dalek> rakudo/nom:

[02:37] <dalek> rakudo/nom: It looks a bit messy, but without it, the range of errors received

[02:37] <dalek> rakudo/nom: when attempting mixed-level classify reference guts and are very confusing.

[02:37] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/9dcde75137

[02:37] <dalek> roast: e82a9f1 | (Zoffix Znet)++ | S32-list/classify-list.t:

[02:37] <dalek> roast: Mixed-level classify on Hashes throws

[02:37] <dalek> roast: review: https://github.com/perl6/roast/commit/e82a9f1a84

[03:00] <ShimmerFairy> Weird, I'm finding myself in a place where a  role Foo[::T = DefType] { has T @.stuff; ... }  works when I use the module in a perl6 -e test line, but not within a script.

[03:03] <ShimmerFairy> even weirder, it doesn't work at all if I try to use the role directly, but the above-mentioned behavior _does_ happen in trying to use a class that does the role.

[07:51] <[Tux]> This is Rakudo version 2016.09-48-g9dcde75 built on MoarVM version 2016.09-1-gdebb859

[07:51] <[Tux]> csv-ip5xs        9.282

[07:51] <[Tux]> test            16.120

[07:51] <[Tux]> test-t           7.013

[07:51] <[Tux]> csv-parser      19.308

[07:54] <nine_> Zoffix: indeed, S17-procasync/stress.t (with 400 iterations) runs in 6 seconds when there's no concurrent backup. The 10000 iteration version takes 118 seconds.

[07:54] <nine_> Zoffix: the funny part is that I could run FlightGear without noticing any performance issue during the backup but this test was slowed down 40x.

[08:02] <psch> i'm guessing bisectable6 is moar only, right?

[08:02] <psch> 'cause NC on r-j used to work at least better than it does now, and it'd be great if i didn't have to bisect something with a 15+ min build process... :)

[08:03] <nine_> psch: I think so. Well at least bisecting r-j should be easier, since it's only 2 moving layers of the stack

[08:07] <psch> nine_: yeah, it's pretty straight foward wrt commands, but the build time... :)

[08:07] <psch> the issue is kind of a funny one, anyway

[08:07] <psch> like, 01-argless.t for example fails because it gets a null where it apparently didn't use to get a null

[08:07] <psch> because the test file hasn't been touched in over a year

[08:14] <nine_> Being straight forward should mean that it can run automatically over night?

[08:16] <timotimo> sadly git bisect doesn't allow you to speculatively find out which commits would be next if the currently suggested commit is good or bad

[08:16] <timotimo> so you can't just build two rakudos in parallel :\

[08:16] <timotimo> hack has like 5 cores, right?

[08:17] <psch> humm, i think bisect is out as a tool anyway

[08:17] <psch> considering the one revision i thought should *definitely* be good isn't

[08:17] <timotimo> oh fuck

[08:18] <psch> honestly though, that's kind of what i thought when looking at the code in question just now

[08:18] <psch> as in, i have no idea if i misremember it having worked correctly

[08:18] <timotimo> right :|

[08:18] <psch> because it kinda shouldn't

[08:18] <psch> it's about the first test in 01-argless.t, which does absolutely nothing on the C side

[08:19] <psch> which means we rightly get null from the C interop layer

[08:19] <psch> i guess we somewhen got a wrapper type that wraps null..?

[08:19] <timotimo> we turn null into Any or whatever type was annotated

[08:20] <psch> right, which means we kind of want Nil

[08:20] <psch> buuut we're going through getattr, which, being nqp, doesn't know gcx

[08:20] <timotimo> not really, we don't have scalars that would be assigned into for the Nil mechanism to happen

[08:20] <timotimo> what is gcx?

[08:20] <psch> GlobalExt, the extension to the GlobalContext

[08:21] <timotimo> oh?

[08:21] <timotimo> i don't know what that is :S

[08:21] <psch> well, the GlobalContext knows things like KnowHOW and BOOTHash

[08:21] <timotimo> oh,ok

[08:21] <psch> and GlobalExt knows things like Array, Nil, Positional

[08:21] <timotimo> we stash that off of a pointer in MVMInstance on moar

[08:22] <timotimo> i think Array lives in the HLL maybe?

[08:23] <psch> well, HLL handling is a purely nqp thing

[08:24] <timotimo> oh?

[08:24] <timotimo> well, you have to install stuff there from nqp-level code

[08:24] <psch> as in, nothing in rakudo/src/vm/jvm deals with HLLConfig

[08:25] <timotimo> maybe through the ops we hvae for that

[08:25] <timotimo> curhllsym or what it's called

[08:25] <psch> hm, HLLConfig has nullValue

[08:26] <psch> points to Mu in perl6

[08:26] <psch> i guess i'll try returning that when we getattr and attr that's null on the java side

[08:26] <psch> s/and /an /

[08:27] <timotimo> hmm. on moar we have VMNull, which is a non-explodey null value to replace having null in object registers and attributes and such

[08:27] <timotimo> though we also use c-level null to signify "this slot has to be initialized when it's accessed"

[08:28] <psch> right, i don't think we have a VMNull equivalent on nqp-j

[08:28] <psch> i think i tried implementing it once

[08:28] <timotimo> that's how we get around allocating Scalar objects for $_, $/, and $! in every single block even if they don't use it

[08:34] <psch> hm, i'll try the stupid simple thing first

[08:34] <psch> which is "just check if it's null too, and assign null if it is"

[08:34] <psch> s/too,/first/ # maybe

[08:35] <timotimo> OK :)

[08:35] <psch> -                            if (field.getType().isAssignableFrom(tc.native_j.getClass())) {

[08:35] <psch> +                            if (tc.native_j == null || field.getType().isAssignableFrom(tc.native_j.getClass())) {

[08:35] <psch> (yay *really* long lines with lots of indentation)

[08:36] <psch> i mean, any class is assignable from null so it should be fine haha..ha

[08:37] <nine_> Are COMPOSE phasers actually implemented?

[08:40] <nine_> Ah, I can get by with a mainline in the role anyway

[08:49] <psch> well

[08:49] <psch> "Use of uninitialized value %CONFIG of type Any in string context." says NC

[08:50] <psch> in sub compile_test_lib at /home/psch/rakudo/rakudo/t/04-nativecall/CompileTestLib.pm (CompileTestLib) line 9

[08:50] <psch> r: say $*VM.platform-library-name("01-argless.c")

[08:50] <camelia> rakudo-moar 9dcde7: OUTPUT«Type check failed in binding to $library; expected IO::Path but got Str ("01-argless.c")␤  in block <unit> at <tmp> line 1␤␤»

[08:50] <camelia> ..rakudo-jvm cd19db: OUTPUT«Type check failed in binding $library; expected IO::Path but got Str ("01-argless.c")␤  in block <unit> at <tmp> line 1␤␤»

[08:50] <psch> oh meh

[08:51] <psch> but it passes the test so i guess that's fine? :P

[08:58] <psch> ya, except for that warning the "pass null through without complaints" patch brings me down to 5 failed tests in t/04-nativecall/

[08:58] <psch> note, that's really *tests*, not test files \o/

[09:02] <psch> oh geez

[09:02] <psch> # at t/04-nativecall/15-rw-args.t line 56

[09:02] <psch> # expected: '12.12'

[09:02] <psch> #      got: '12.119999885559082'

[09:02] <psch> m: say 1212e-2

[09:02] <camelia> rakudo-moar 9dcde7: OUTPUT«12.12␤»

[09:02] <psch> j: say 1212e-2

[09:02] <camelia> rakudo-jvm cd19db: OUTPUT«12.120000000000001␤»

[09:02] <lizmat> Files=1139, Tests=53042, 239 wallclock secs (13.58 usr  3.99 sys + 1471.23 cusr 138.09 csys = 1626.89 CPU)

[09:03] <psch> m: printf "%.12f", 12e12

[09:03] <camelia> rakudo-moar 9dcde7: OUTPUT«12000000000000.000000000000»

[09:03] <psch> m: printf "%.12f", 1212e-2

[09:03] <camelia> rakudo-moar 9dcde7: OUTPUT«12.120000000000»

[09:03] <psch> m: printf "%.16f", 1212e-2

[09:03] <camelia> rakudo-moar 9dcde7: OUTPUT«12.1200000000000000»

[09:03] <psch> okay someone is cheating there

[09:08] <psch> j: use java::lang::Double:from<JavaRuntime>; my $dbl = Double.new("12.12"); say $dbl

[09:08] <camelia> rakudo-jvm cd19db: OUTPUT«12.12␤»

[09:08] <psch> help :P

[09:08] <psch> j: use java::lang::Double:from<JavaRuntime>; my $dbl = Float.new("12.12"); say $dbl

[09:08] <camelia> rakudo-jvm cd19db: OUTPUT«===SORRY!=== Error while compiling <tmp>␤Undeclared name:␤    Float used at line 1␤␤»

[09:09] <psch> j: use java::lang::Float:from<JavaRuntime>; my $dbl = Float.new("12.12"); say $dbl

[09:09] <camelia> rakudo-jvm cd19db: OUTPUT«12.119999885559082␤»

[09:09] <psch> okay, so we accidentally single precision, apparently

[09:09] <psch> that explains the NC failure mode, but not the perl6 num failure mode..?

[09:17] <psch> j: my num64 $x = 1212e-2; printf "%2.16f", $x

[09:17] <camelia> rakudo-jvm cd19db: OUTPUT«12.1200000000000010»

[09:18] <psch> the other two failures in 14-rw-args.t are also some kind of type confusion

[09:18] <psch> probably signed instead of unsigned

[09:18] <psch> ...or something

[09:18] <psch> # expected: '387'

[09:18] <psch> #      got: '65411'

[09:18] <psch> or hm, is that endianess..?

[09:20] <psch> m: printf "%16b", 387

[09:20] <camelia> rakudo-moar 9dcde7: OUTPUT«       110000011»

[09:20] <psch> m: printf "%016b", 387

[09:20] <camelia> rakudo-moar 9dcde7: OUTPUT«0000000110000011»

[09:23] <psch> m: my $a = join "", reverse ((sprintf "%016b", 387).comb: /\d ** 8/); say :2($a) + 2**15 # probably not..?

[09:23] <camelia> rakudo-moar 9dcde7: OUTPUT«66305␤»

[09:24] <psch> m: printf "%8b", 153; say(); printf "%8b", -103

[09:24] <camelia> rakudo-moar 9dcde7: OUTPUT«10011001␤-1100111»

[09:29] <psch> r: my int8 $x = -64; my uint8 $y = $x; say $y

[09:29] <camelia> rakudo-moar 9dcde7: OUTPUT«192␤»

[09:29] <camelia> ..rakudo-jvm cd19db: OUTPUT«-64␤»

[09:35] <dalek> rakudo/nom: ac0c831 | (Zoffix Znet)++ | lib/Test.pm6:

[09:35] <dalek> rakudo/nom: Fix PERL6_TEST_DIE_ON_FAIL not exiting on failed subtests

[09:35] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/ac0c831a82

[09:35] <dalek> roast: db94d84 | (Zoffix Znet)++ | S24-testing/8-die_on_fail.t:

[09:35] <dalek> roast: PERL6_TEST_DIE_ON_FAIL exits even when failures are inside subtests

[09:35] <dalek> roast: review: https://github.com/perl6/roast/commit/db94d84685

[09:44] <psch> okay this is weird

[09:44] <psch> i mean, i debug-steps through NativeCallOps.java

[09:44] <psch> and it hits the UCHAR case, so it adds 0x100

[09:44] <psch> and then it returns a BigInteger that has the value that we expect

[09:45] <psch> but it fails the test

[09:46] <psch> hm, well, there's a BigInteger with the right value in Ops.result_o(tc.curFrame) at least...

[09:46] <psch> maybe i should check what's in result_I

[09:46] <psch> *i

[09:53] <psch> aha, reducing the test file to the one test that fails doesn't hit the breakpoint i set

[09:53] <psch> so i've been looking in the wrong spot anyway, and confirmed via the debugger that something that works, actually works

[10:09] <dalek> rakudo/nom: 3448c71 | lizmat++ | src/core/Junction.pm:

[10:09] <dalek> rakudo/nom: Fix for RT #129349

[10:09] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/3448c71030

[10:21] <dalek> roast: bc3cf5e | (Zoffix Znet)++ | S03-junctions/misc.t:

[10:21] <dalek> roast: Remove trailing whitespace

[10:21] <dalek> roast: review: https://github.com/perl6/roast/commit/bc3cf5e557

[10:22] <dalek> roast: 510a916 | (Zoffix Znet)++ | S03-junctions/misc.t:

[10:22] <dalek> roast: Junctions with autovivification work

[10:22] <dalek> roast:

[10:22] <dalek> roast: RT#129349: https://rt.perl.org/Ticket/Display.html?id=129349

[10:22] <dalek> roast: review: https://github.com/perl6/roast/commit/510a916971

[10:27] <dalek> rakudo/nom: 448f826 | (Zoffix Znet)++ | src/core/Hash.pm:

[10:27] <dalek> rakudo/nom: Remove needless //= [] check

[10:27] <dalek> rakudo/nom:

[10:27] <dalek> rakudo/nom: Autovivification takes care of it for us.

[10:27] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/448f8263c0

[11:41] <MasterDuke> psch: https://github.com/perl6/whateverable/issues/41, it doesn't do r-j yet, but we're thinking about adding it

[11:45] <psch> MasterDuke: ah, neat, thanks for the info :)

[11:52] <nebuchadnezzar> hello, it looks like rakudo “make test” returns 0 even when some tests failed (https://lists.alioth.debian.org/pipermail/pkg-rakudo-devel/2016-September/000937.html), do you have any idea why?

[11:54] * psch dimly recalls a recent patch fixing subtest failure propagation

[11:59] <travis-ci> Rakudo build failed. Zoffix Znet 'Remove needless //= [] check

[11:59] <travis-ci> https://travis-ci.org/rakudo/rakudo/builds/162551181 https://github.com/rakudo/rakudo/compare/3448c71030ca...448f8263c093

[11:59] <buggable> [travis build above] ☠ Did not recognize some failures. Check results manually

[11:59] <Zoffix> nebuchadnezzar, harness was broken. Fixed recently.

[11:59] <Zoffix> s/harness/script that runs the harness/;

[12:00] <Zoffix> nebuchadnezzar, here's the commit that fixed it. 12 days ago: https://github.com/rakudo/rakudo/commit/626a2220e719547f242286cfaea74977a91b8d38

[12:01] * Zoffix wishes someone with OSX would fix flapping in t/04-nativecall/13-union.t

[12:01] <Zoffix> Can't reproduce it on Linux :/

[12:06] <nebuchadnezzar> Zoffix: thanks

[12:21] <psch> well, i fixed one of the two USHORT problem with NativeCall...

[12:21] <psch> err, UCHAR actually

[12:22] <psch> USHORT still has a problem, which seems quite a bit less obvious

[12:22] <psch> r: my int8 $x = -103; my uint8 $y = $x; say $x; say $y

[12:22] <camelia> rakudo-moar 448f82: OUTPUT«-103␤153␤»

[12:22] <camelia> ..rakudo-jvm cd19db: ( no output )

[12:22] <psch> j: my int8 $x = -103; my uint8 $y = $x; say $x; say $y

[12:23] <camelia> rakudo-jvm cd19db: OUTPUT«-103␤-103␤»

[12:23] <psch> that's fixed now when we go via NC

[12:23] <psch> the other one is weird though

[12:23] <psch> # expected: '387'

[12:23] <psch> #      got: '65411'

[12:23] <psch> it's about *returning* an USHORT, and the difference between the values just seems completely arbitrary

[12:23] <psch> m: say 65411 - 387

[12:23] <camelia> rakudo-moar 448f82: OUTPUT«65024␤»

[12:23] <psch> because what kind of value is that even

[12:25] <psch> m: say 65535 +^ 387

[12:25] <camelia> rakudo-moar 448f82: OUTPUT«65148␤»

[12:26] <psch> m: say 387.base(2); say 65411.base(2)

[12:26] <camelia> rakudo-moar 448f82: OUTPUT«110000011␤1111111110000011␤»

[12:26] <psch> ohhh

[12:26] <psch> m: say 65536 +^ 2**15

[12:26] <camelia> rakudo-moar 448f82: OUTPUT«98304␤»

[12:27] <psch> m: say 65535 +^ 2**15

[12:27] <camelia> rakudo-moar 448f82: OUTPUT«32767␤»

[12:27] <psch> m: say 65535 +^ 2**7

[12:27] <camelia> rakudo-moar 448f82: OUTPUT«65407␤»

[12:27] <psch> m: say 65535 +^ (2**7 + 1)

[12:27] <camelia> rakudo-moar 448f82: OUTPUT«65406␤»

[12:27] <psch> anyway, that seems to be it

[12:27] <psch> so the USHORT that we return for some reason has the high byte completely set

[12:28] <psch> oh wow

[12:28] <psch> we're using .byteValue() for USHORT and UINT

[12:28] <psch> that's clearly bogus

[12:29] <psch> ah, and that's *also* why the double test fails, because we're using .floatValue() there

[12:37] <masak> the plot thinnens

[12:37] <psch> yes.  should be down to 2 failed tests after this build

[12:37] <FROGGS> psch++

[12:37] <yoleaux2> 21 Sep 2016 11:00Z <jnthn> FROGGS: I *think* you worked on process code long ago. I just fixed https://rt.perl.org/Ticket/Display.html?id=129291 by doing https://github.com/MoarVM/MoarVM/commit/debb859d8df52f9a44c94dc7760b2fe30170e8d3 which I *think* makes sense, but if you have a moment to glance it and comment it'd be great. Thanks! :-)

[12:38] <psch> and then we should have a clean 'make test' on r-j again, which means we probably want travis to pay attention to r-j again

[12:55] <psch> r: use NativeCall; class C is repr('CStruct') { method foo { say "foo" } }; C.new.foo

[12:55] <camelia> rakudo-moar 448f82: OUTPUT«foo␤»

[12:55] <camelia> ..rakudo-jvm cd19db: OUTPUT«␤(timeout)␤»

[12:55] <psch> r: use NativeCall; class C is repr('CStruct') { method foo { say "foo" } }; C.new.foo

[12:55] <camelia> rakudo-moar 448f82: OUTPUT«foo␤»

[12:55] <camelia> ..rakudo-jvm cd19db: OUTPUT«===SORRY!===␤java.nio.channels.OverlappingFileLockException␤»

[12:57] <psch> that's gonna be a fun one i think

[12:57] <psch> java.lang.IllegalArgumentException: Structure class __CStruct__0 has unknown or zero size (ensure all fields are public)

[12:57] <psch> is the actual error message in the test

[12:58] <psch> and some google usage suggests that structs with size zero are not supported with JNA (or C, for that matter)

[13:00] <psch> dunno, that might be have false

[13:00] <psch> we do have a comment in reprs/CStruct.java that says we want to implement a given interface, but the object.asm visit call doesn't seem to implement it

[13:08] <geekosaur> isn't that complaining about the method? or are you stripping that when building the repr?

[13:08] <psch> main[1] where [1] com.sun.jna.Structure.deriveLayout (Structure.java:1,183)

[13:09] <psch> geekosaur: it's failing with that Exception inside of jna.Structure

[13:09] <psch> geekosaur: so it's really JNA complaining that it can't derive the layout of a zero-size struct

[14:02] <AlexDaniel> MasterDuke: actually, to be able to build r-j we should at least fix r-m :'(

[14:05] <dalek> nqp: 720d052 | peschwa++ | src/vm/jvm/runtime/org/perl6/nqp/runtime/ (2 files):

[14:05] <dalek> nqp: Fix some NativeCall type confusion.

[14:05] <dalek> nqp: review: https://github.com/perl6/nqp/commit/720d05222b

[14:05] <dalek> rakudo/nom: 99e98c3 | peschwa++ | src/core/VM.pm:

[14:05] <dalek> rakudo/nom: Fix unitialized warning for VM.platform-library-name

[14:05] <dalek> rakudo/nom:

[14:05] <dalek> rakudo/nom: We might want a different solution WRT VM in general though,

[14:05] <dalek> rakudo/nom: as the .config/.properties split on R-J seems confusing.

[14:05] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/99e98c3fa1

[14:05] <dalek> rakudo/nom: bb52f81 | peschwa++ | tools/build/NQP_REVISION:

[14:05] <dalek> rakudo/nom: Bump NQP_REVISION for JVM NativeCall fixes

[14:05] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/bb52f81e71

[14:06] <psch> two remaining failures in 'make test'

[14:06] <psch> and both too opaque for me to make sense of right now :S

[14:07] <psch> there's still potential problems in jvm NC with unsigned types

[14:07] <timotimo> oh unsigned types ... ;(

[14:07] <psch> but i have no idea how we'd fix those anyway, because the jvm doesn't do unsigned primitives...

[14:08] <psch> and, well, i don't think we want to wrap a BigInteger around what's supposed to be native types... :l

[14:08] <timotimo> hm, right

[14:09] <psch> but we really can't do anything else, cause half of ulong doesn't fit in long

[14:09] <psch> and long is our native_i type

[14:09] <psch> so, yeah, it's probably forever weird vOv

[14:21] <nine_> Cool! I've now got a v6::inline implementation that's more transparent, more correct, less leaky and simple enough so even I can understand it :)

[14:23] <timotimo> yeah!

[14:28] <psch> \o/

[14:28] <psch> i wish i actually understood the bits i'm fixing here :P

[14:31] <psch> well, the type confusion stuff was straight forward enough, actually

[14:32] <psch> i mean, i have no idea about the JNA layer, which means the remaining to failures are gonna be pretty hard

[14:32] <psch> one's the struct thing i talked about earlier, the other is about function pointers...

[14:37] <timotimo> oh, function pointers

[14:37] <timotimo> that's already fun on moarvm ... not :)

[14:46] <psch> oh god, what have i done

[14:46] <psch> java.lang.invoke.WrongMethodTypeException: expected (ThreadContext,CodeRef,CallSiteDescriptor,SixModelObject)void but found (ThreadContext,CodeRef,CallSiteDescriptor,SixModelObject)void

[14:46] <psch> ..that's nom/HEAD, too

[14:46] <psch> and why, anyway

[14:46] <psch> i mean, the method types are identical..?

[14:49] <timotimo> not to java they aren't!

[14:49] <timotimo> java stares deep into your soul

[14:55] <psch> ooohkay

[14:55] <psch> it's past the point where it failed like thatn ow

[14:55] <psch> *now

[14:55] <psch> i am confused

[14:55] <psch> like, it was the exact same command

[14:56] <timotimo> :(

[14:56] <timotimo> stale caches? nondeterministic failure? :(

[14:57] <psch> i'm going with gamma rays i think vOv

[14:58] <timotimo> subspace interference

[14:58] <travis-ci> Rakudo build passed. Pepe Schwarz 'Bump NQP_REVISION for JVM NativeCall fixes'

[14:58] <travis-ci> https://travis-ci.org/rakudo/rakudo/builds/162574306 https://github.com/rakudo/rakudo/compare/448f8263c093...bb52f81e710b

[14:59] <timotimo> passed \o/

[14:59] <timotimo> but it doesn't yet make sure jvm survives tests?

[14:59] <psch> crazy

[14:59] <psch> nah, it doesn't

[14:59] <psch> 'make test' still has two failures anyway

[14:59] <timotimo> oh, all of them failed :)

[15:00] <psch> so, yeah, you'd have to check where and how they failed

[15:00] <timotimo> and the reason why travis-ci comes in here like we have a revolving door is that one flappy nativecall test on moar, i think

[15:01] <psch> well, none of the travis jvm runs failed with WrongMethodTypeException

[15:01] <psch> so that's pretty good, 'cause that was kinda scary, honestly

[15:02] <timotimo> i agree

[15:02] <timotimo> BBIAB

[17:04] <dalek> roast: 96f6b08 | (Zoffix Znet)++ | S32-list/classify-list.t:

[17:04] <dalek> roast: .classify-list; Callable mapper is executed only once per each item

[17:04] <dalek> roast: review: https://github.com/perl6/roast/commit/96f6b08655

[17:26] <FROGGS> .tell jnthn that patch to not set ->process again looks totally valid

[17:26] <yoleaux2> FROGGS: I'll pass your message to jnthn.

[17:56] <gfldex> m: sub f($x where { fail X::AdHoc.new(msg=>'bad') }){}; f(1)

[17:56] <camelia> rakudo-moar bb52f8: OUTPUT«Unexplained error␤  in any  at /home/camelia/rakudo-m-inst-2/share/perl6/runtime/CORE.setting.moarvm line 1␤  in sub f at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[17:57] <gfldex> m: sub f($x where { fail X::AdHoc.new(payload=>'bad') }){}; f(1)

[17:57] <camelia> rakudo-moar bb52f8: OUTPUT«bad␤  in any  at /home/camelia/rakudo-m-inst-2/share/perl6/runtime/CORE.setting.moarvm line 1␤  in sub f at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[18:00] <gfldex> m: sub f($x where { fail X::AdHoc.new(payload=>'bad') }){}; class X::Custom is Exception { method message { "also bad" } }; sub g($x where { fail X::Custom.new } ) {}; g

[18:00] <camelia> rakudo-moar bb52f8: OUTPUT«Too few positionals passed; expected 1 argument but got 0␤  in sub g at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[18:01] <gfldex> m: class X::Custom is Exception { method message { "also bad" } };

[18:01] <camelia> rakudo-moar bb52f8: ( no output )

[18:01] <gfldex> m: class X::Custom is Exception { method message { "also bad" } }; sub g($x where { X::Custom.new }; g

[18:01] <camelia> rakudo-moar bb52f8: OUTPUT«===SORRY!=== Error while compiling <tmp>␤Invalid typename 'g' in parameter declaration.␤at <tmp>:1␤------> } }; sub g($x where { X::Custom.new }; g⏏<EOL>␤»

[18:01] <gfldex> m: class X::Custom is Exception { method message { "also bad" } }; sub g($x where { X::Custom.new }); g

[18:01] <camelia> rakudo-moar bb52f8: OUTPUT«===SORRY!=== Error while compiling <tmp>␤A unit-scoped sub definition is not allowed except on a MAIN sub;␤Please use the block form.␤at <tmp>:1␤------>  } }; sub g($x where { X::Custom.new });⏏ g␤»

[18:02] <gfldex> m: class X::Custom is Exception { method message { "also bad" } }; sub g($x where { X::Custom.new }) {}; g

[18:02] <camelia> rakudo-moar bb52f8: OUTPUT«Too few positionals passed; expected 1 argument but got 0␤  in sub g at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[18:02] <gfldex> m: class X::Custom is Exception { method message { "also bad" } }; sub g($x where { X::Custom.new(1) }) {}; g

[18:02] <camelia> rakudo-moar bb52f8: OUTPUT«Too few positionals passed; expected 1 argument but got 0␤  in sub g at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[18:02] <geekosaur> it's the "g" at the end that is your error

[18:02] <gfldex> m: class X::Custom is Exception { method message { "also bad" } }; sub g($x where { X::Custom.new }) {}; g(1)

[18:02] <camelia> rakudo-moar bb52f8: ( no output )

[18:03] <gfldex> sub g($x where { X::AdHoc.new(msg=>'bad') }) {}; g(1)

[18:03] <gfldex> m: sub g($x where { X::AdHoc.new(msg=>'bad') }) {}; g(1)

[18:03] <camelia> rakudo-moar bb52f8: ( no output )

[18:03] <gfldex> m: sub g($x where { fail X::AdHoc.new(msg=>'bad') }) {}; g(1)

[18:03] <camelia> rakudo-moar bb52f8: OUTPUT«Unexplained error␤  in any  at /home/camelia/rakudo-m-inst-2/share/perl6/runtime/CORE.setting.moarvm line 1␤  in sub g at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[18:03] <gfldex> m: sub g($x where { fail X::AdHoc.new(payload=>'bad') }) {}; g(1)

[18:03] <camelia> rakudo-moar bb52f8: OUTPUT«bad␤  in any  at /home/camelia/rakudo-m-inst-2/share/perl6/runtime/CORE.setting.moarvm line 1␤  in sub g at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[18:03] <gfldex> m: class X::Custom is Exception { method message { "also bad" } }; sub g($x where { fail X::Custom.new }) {}; g(1)

[18:03] <camelia> rakudo-moar bb52f8: OUTPUT«also bad␤  in any  at /home/camelia/rakudo-m-inst-2/share/perl6/runtime/CORE.setting.moarvm line 1␤  in sub g at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[18:39] <gfldex> m: class X::Custom is Exception { method message { "also bad" } }; sub g($x where { fail X::Custom.new }) {}; g(1)

[18:39] <camelia> rakudo-moar bb52f8: OUTPUT«also bad␤  in any  at /home/camelia/rakudo-m-inst-2/share/perl6/runtime/CORE.setting.moarvm line 1␤  in sub g at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[18:40] <gfldex> it would be nice to get the argument name into the where clause somehow

[18:40] <gfldex> and sorry for the spam

[18:42] <psch> m: sub g($x where -> $x { fail X::AdHoc.new(payload=>'bad ' ~ $x.VAR.name) }) {}; g(1)

[18:42] <camelia> rakudo-moar bb52f8: OUTPUT«bad $x␤  in any  at /home/camelia/rakudo-m-inst-2/share/perl6/runtime/CORE.setting.moarvm line 1␤  in sub g at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[18:42] <psch> gfldex: note that actually the name of the param of the pointy block, so you have to take care to keep the orig param and the block param the same

[18:42] <psch> +is

[18:50] <timotimo> hmm

[18:51] <Zoffix> m: dd {'cat2',}(); dd {['cat2']}()

[18:51] <camelia> rakudo-moar bb52f8: OUTPUT«("cat2",)␤["cat2"]␤»

[18:51] <Zoffix> Is the first one a list of lists?

[18:52] <psch> m: my $a := 'cat2',; say $a.WHAT; say $a[0].WHAT

[18:52] <camelia> rakudo-moar bb52f8: OUTPUT«(List)␤(Str)␤»

[18:53] <Zoffix> m: my $a := ['cat2']; say $a.WHAT; say $a[0].WHAT

[18:53] <camelia> rakudo-moar bb52f8: OUTPUT«(Array)␤(Str)␤»

[18:53] <Zoffix> hm

[19:37] <dalek> rakudo/nom: c2455ca | (Zoffix Znet)++ | src/core/Hash.pm:

[19:37] <dalek> rakudo/nom: Fix and improve Hash.categorize-list

[19:37] <dalek> rakudo/nom:

[19:37] <dalek> rakudo/nom: - Fix incorrect multi-level nesting with % and @ mappers

[19:37] <dalek> rakudo/nom: - Do not crash on degenerate case of 0-item multi-level iterables

[19:38] <dalek> rakudo/nom: - Throw on lazy (infinite) lists instead of hanging

[19:38] <dalek> rakudo/nom: - Do not execute mapper more than once per item being categorized

[19:38] <dalek> rakudo/nom: - Detect when attempt to use mixed-level categorization is made and throw

[19:38] <dalek> rakudo/nom:     useful error instead of spilling guts on conflicts

[19:38] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/c2455cadf0

[20:52] <dalek> rakudo/nom: 4a80126 | (Zoffix Znet)++ | src/core/Baggy.pm:

[20:52] <dalek> rakudo/nom: Fix incorrect name of type in error message

[20:52] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/4a80126531

[20:52] <dalek> rakudo/nom: 04f4b76 | (Zoffix Znet)++ | src/core/ (3 files):

[20:52] <dalek> rakudo/nom: Fix and improve Baggy.categorize-list

[20:52] <dalek> rakudo/nom:

[20:52] <dalek> rakudo/nom: - Fix incorrect multi-level category behaviour with % and @ mappers

[20:52] <dalek> rakudo/nom: - Throw on attempts to use multi-level categorization instead of spilling guts

[20:52] <dalek> rakudo/nom: - Throw on lazy (infinite) lists instead of hanging

[20:52] <dalek> rakudo/nom: - Do not execute mapper more than once per item being categorized

[20:52] <dalek> rakudo/nom: - Detect all Iterables and not just List

[20:52] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/04f4b76ef3

[20:53] <dalek> roast: 635d5d4 | (Zoffix Znet)++ | S32-list/classify-list.t:

[20:53] <dalek> roast: Add vim comment at end

[20:53] <dalek> roast: review: https://github.com/perl6/roast/commit/635d5d4fe2

[20:54] <dalek> roast: 29366a2 | (Zoffix Znet)++ | S32-list/categorize-list.t:

[20:54] <dalek> roast: Add tests for [Hash|Baggy].categorize-list

[20:54] <dalek> roast: review: https://github.com/perl6/roast/commit/29366a201f

[20:55] <dalek> rakudo/nom: 922afd3 | (Zoffix Znet)++ | t/spectest.data:

[20:55] <dalek> rakudo/nom: Add S32-list/categorize-list.t test file

[20:55] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/922afd3366

[20:55] <dalek> roast: 2727a1b | (Zoffix Znet)++ | S32-list/categorize-list.t:

[20:55] <dalek> roast: Add vim comment at end

[20:55] <dalek> roast: review: https://github.com/perl6/roast/commit/2727a1b429

[21:48] <Zoffix> Huh. TIL. constant get frozen with precompiled modules: https://github.com/zoffixznet/perl6-CoreHackers-Sourcery/pull/3

[21:48] <Zoffix> During their installation :/

[22:20] <ugexe> constant is compile time isnt it?

[22:20] <timotimo> yup

[22:25] <Zoffix> Yeah. That's why they get frozen.

[22:25] <timotimo> yup

[22:30] <MasterDuke> does Python have constants and do they work the same way with its .pyc files as Perl 6?

[22:32] <timotimo> no, python doesn't have constants
