[06:02] <[Tux]> This is Rakudo version 2016.09-123-gd8309d0 built on MoarVM version 2016.09-15-gc8b4228

[06:02] <[Tux]> csv-ip5xs        3.373

[06:02] <[Tux]> test            17.007

[06:02] <[Tux]> test-t           7.497

[06:02] <[Tux]> csv-parser      18.107

[06:03] <nine> [Tux]: did I see correctly that you are working on NativeCall bindings for Text::CSV_XS's parsing code?

[06:04] <nine> That would be very interesting to comprae ip5xs' performance against, as it's a kinda optimal case that I probably cannot beat

[06:04] <[Tux]> I made a commit on the work I did in trying to use NativeCall to bind to libcsv3

[06:04] <[Tux]> but I horribly failed in making the double callback to work. Feel free to make it work

[06:05] <nine> Ah. Ok. Though I guess it probably wouldn't matter which CSV parser you use since they'll all take just a miniscule part of the runtime.

[06:06] <[Tux]> As I was researching NC, I thought it might get a lot closer to the C-timing than all other timings

[06:14] <nine> It's hard to say how far down we could get with that. NativeCall does have considerable overhead. Eventually we will be able to spesh and JIT it though :)

[08:47] <jnthn> nine: Quite a long way down, I'd expect. brrt++'s exprjit work should help a good bunch, but the way we link native callsites will also need some tweaks.

[09:08] <cygx> o/

[09:08] <cygx> m: my $a; sub foo(--> Nil) { $a = do { 42 } }

[09:08] <camelia> rakudo-moar d8309d: OUTPUT«WARNINGS for <tmp>:␤Useless use of constant integer 42 in sink context (line 1)␤»

[09:08] <cygx> ^ known?

[09:16] <cygx> m: role Foo { method foo { say "ok" } }; enum Bar does Foo <A B>; A.foo; say A ~~ Foo

[09:16] <camelia> rakudo-moar d8309d: OUTPUT«ok␤False␤»

[09:16] <cygx> ^ bug?

[09:18] <psch> that's interesting

[09:20] <psch> m: role Foo { method foo { say "ok" } }; enum Bar does Foo <A B>; say A.^methods.map(*.name)

[09:20] <camelia> rakudo-moar d8309d: OUTPUT«(pair enums foo CALL-ME pick perl ACCEPTS gist Int Numeric Str roll kv key value perl Bridge sqrt sign ACCEPTS sin tan cotan acosech Numeric Str abs base narrow conj atan2 cosec new is-prime pred WHICH asec acotan cosh ceiling acos acosec sech unpolar log1…»

[09:20] <psch> m: role Foo { method foo { say "ok" } }; enum Bar does Foo <A B>; say A.HOW.^name

[09:20] <camelia> rakudo-moar d8309d: OUTPUT«Perl6::Metamodel::EnumHOW␤»

[09:20] <psch> m: role Foo { method foo { say "ok" } }; enum Bar does Foo <A B>; say A.HOW.^name.can('mixin')

[09:20] <camelia> rakudo-moar d8309d: OUTPUT«()␤»

[09:20] <psch> uh, actually, that's .can on a Str isn't it

[09:20] <psch> m: role Foo { method foo { say "ok" } }; enum Bar does Foo <A B>; say A.HOW.^name.WHAT

[09:20] <camelia> rakudo-moar d8309d: OUTPUT«(Str)␤»

[09:21] <psch> m: role Foo { method foo { say "ok" } }; enum Bar does Foo <A B>; say A.HOW.can('mixin')

[09:21] <camelia> rakudo-moar d8309d: OUTPUT«Too few positionals passed; expected 3 arguments but got 2␤  in any can at gen/moar/m-Metamodel.nqp line 1128␤  in block <unit> at <tmp> line 1␤␤»

[09:21] <psch> m: role Foo { method foo { say "ok" } }; enum Bar does Foo <A B>; say A.HOW.^can('mixin')

[09:21] <camelia> rakudo-moar d8309d: OUTPUT«No such method 'gist' for invocant of type 'NQPRoutine'␤  in block <unit> at <tmp> line 1␤␤»

[09:21] <psch> m: role Foo { method foo { say "ok" } }; enum Bar does Foo <A B>; say A.HOW.^can('mixin').name

[09:21] <camelia> rakudo-moar d8309d: OUTPUT«mixin␤»

[09:21] <psch> m: role Foo { method foo { say "ok" } }; enum Bar does Foo <A B>; say A.HOW.^roles

[09:21] <camelia> rakudo-moar d8309d: OUTPUT«Required named parameter 'local' not passed␤  in any roles at gen/moar/stage2/nqpmo.nqp line 1195␤  in block <unit> at <tmp> line 1␤␤»

[09:22] <psch> m: role Foo { method foo { say "ok" } }; enum Bar does Foo <A B>; say A.HOW.^roles(:local)

[09:22] <camelia> rakudo-moar d8309d: OUTPUT«No such method 'gist' for invocant of type 'Perl6::Metamodel::Naming'␤  in block <unit> at <tmp> line 1␤␤»

[09:22] <psch> m: role Foo { method foo { say "ok" } }; enum Bar does Foo <A B>; say A.HOW.^roles(:local)>>.name

[09:22] <camelia> rakudo-moar d8309d: OUTPUT«No such method 'name' for invocant of type 'Perl6::Metamodel::Naming'␤  in block <unit> at <tmp> line 1␤␤»

[09:22] <psch> well, yeah, EnumHOW does P6::MM::Mixin, but apparently it doesn't remember the roles it mixes in..?

[09:23] <psch> m: role Foo { method foo { say "ok" } }; enum Bar does Foo <A B>; try say A.^roles; try say Foo.^roles

[09:23] <camelia> rakudo-moar d8309d: OUTPUT«()␤»

[09:23] <psch> m: role Foo { method foo { say "ok" } }; enum Bar does Foo <A B>; say A.^is_composed

[09:23] <camelia> rakudo-moar d8309d: OUTPUT«1␤»

[09:23] <psch> m: role Foo { method foo { say "ok" } }; enum Bar does Foo <A B>; say A.^is_composed; say Foo.^is_composed

[09:23] <camelia> rakudo-moar d8309d: OUTPUT«1␤No such method 'is_composed' for invocant of type 'Perl6::Metamodel::ParametricRoleGroupHOW'␤  in block <unit> at <tmp> line 1␤␤»

[09:24] <psch> m: role Foo { method foo { say "ok" } }; enum Bar <A B>; A does Foo; say A.foo

[09:24] <camelia> rakudo-moar d8309d: OUTPUT«ok␤True␤»

[09:24] <psch> m: role Foo { method foo { say "ok" } }; enum Bar <A B>; A does Foo; say A.^roles

[09:24] <camelia> rakudo-moar d8309d: OUTPUT«No such method 'roles' for invocant of type 'Perl6::Metamodel::EnumHOW'␤  in block <unit> at <tmp> line 1␤␤»

[09:30] <cygx> if I read the code correctly, role_typecheck_list is missing from EnumHOW

[09:32] <cygx> jnthn: ^^^

[09:32] <jnthn> cygx: Probably just never got implemented, and wasn't really missed

[09:32] <jnthn> Until nowish :)

[09:33] <cygx> glad to be of service ;)

[09:33] <jnthn> Can't think of any reason why it shouldn't be there, so just an oversight, I'd say. :)

[09:34] <jnthn> Please patch it or RT it.

[09:37] <cygx> will do (later)

[09:38] <jnthn> Thanks. Maybe I'll even have a little time to look at it later :)

[09:38] <jnthn> Got family visiting this week, though, so mostly taking it easy :)

[09:39] <psch> r: my $a = < 1i >; say $a.re

[09:39] <camelia> rakudo-jvm 2a1605: OUTPUT«Attribute '$!re' is not a native num␤  in block <unit> at <tmp> line 1␤␤»

[09:39] <camelia> ..rakudo-moar d8309d: OUTPUT«0␤»

[09:40] <psch> ^^^ that's bad getattr hints.  how/where do we set those and can i tell allomorphs to recheck them (or ignore them)..?

[09:41] <psch> i mean, i suppose we could try and fallback on getattr without a hint in case the hint looks wrong

[09:41] <psch> but that's one try/catch at least, which is kind of a not-so-performant solution

[09:42] <timotimo> hm

[09:42] <timotimo> in the case of the error occuring, we could try to recompute and try agai

[09:42] <timotimo> again*

[09:43] <psch> i think 'is box_target' plays a notable role there

[09:43] <timotimo> well, if you derive from a class, the box_target slot ought to stay correct :(

[09:43] <psch> timotimo: well, that's kinda what i'm asking.  where do we attach hints for attributes to a class (if we do something like that)

[09:43] <timotimo> i think we set the hints in code-gen

[09:44] <timotimo> liken, when a $!foo gets compiled, we look at the containing class and try_get_slot for the hint value

[09:45] <psch> no hits for 'try_get_slot' here

[09:45] <timotimo> it might be called something else on jvm

[09:45] <cygx> jnthn: ClassHOW.compose looks strange to me - roles seem to get added to @!role_typecheck_list repeatedly

[09:45] <cygx> m: role Foo {}; class Bar does Foo {}; say Bar.HOW.role_typecheck_list(Bar).map(*.^name)

[09:45] <camelia> rakudo-moar d8309d: OUTPUT«(Foo Foo Foo Foo)␤»

[09:46] <psch> timotimo: i'm grepping through {nqp,}/src

[09:46] <psch> timotimo: well, rakudo/src and nqp/src, actually :S

[09:47] <jnthn> cygx: That's because roles actually exist in multiple forms

[09:47] <jnthn> cygx: All of which you could typecheck against

[09:47] <timotimo> it should be in nqp, i believe

[09:48] <jnthn> m: m: role Foo {}; class Bar does Foo {}; say Bar.HOW.role_typecheck_list(Bar).map({ .HOW.^name })

[09:48] <camelia> rakudo-moar d8309d: OUTPUT«(Perl6::Metamodel::ParametricRoleGroupHOW Perl6::Metamodel::ConcreteRoleHOW Perl6::Metamodel::ParametricRoleHOW Perl6::Metamodel::ParametricRoleGroupHOW)␤»

[09:48] <jnthn> Hm, the group is maybe in there twice...

[09:51] <psch> this is actually kinda weird.  the ComplexStr has Str!value in field_0, $!re in field_1 and $!im in field_2

[09:52] <psch> oh, wait, we don't have hints for $!re and $!im do we

[09:52] <psch> like, in REPRData at least

[09:52] <psch> cause those aren't box targets

[09:52] <timotimo> hints are for any slot

[09:52] <timotimo> if i saw correctly the error came from get_attribute

[09:53] <cygx> m: role Foo {}; class Bar does Foo {}; say Bar.HOW.role_typecheck_list(Bar).map({ use nqp; nqp::objectid($_) })

[09:53] <camelia> rakudo-moar d8309d: OUTPUT«(67452360 67452384 67452408 67452360)␤»

[09:53] <psch> timotimo: right, i was looking in the wrong spot.  the unbox hints aren't the getattr hints

[09:53] <timotimo> huh? they really ought to match, no? :\

[09:54] <psch> timotimo: but what's the unbox hint for $!re?

[09:54] <timotimo> "the unbox hint"?

[09:54] <timotimo> i ... think i'm confused

[09:54] <psch> s/hint/slot/

[09:54] <timotimo> ah

[09:54] <psch> timotimo: the point being that we don't have complex, only Complex

[09:54] <psch> so we don't have unbox slots for Complex parts

[09:54] <timotimo> well, if Complex has $!re is box_target, then the hint should point at that attribute

[09:54] <timotimo> even in the derived class

[09:54] <psch> but Complex doesn't have any box_targets

[09:55] <timotimo> i thought you were implying that a Complex boxes its real part and ignores the imaginary part for that purpose

[09:55] <timotimo> in that case, fine :)

[09:55] <timotimo> but the .re getting a bogus slot is definitely still wrong

[09:57] <psch> timotimo: well, we have the right hints in nameToHintMap, but because we nqp::getattr(..., Complex, '$!im) we use the (presumably cached) hint for Complex, which isn't the same as for ComplexStr

[09:57] <timotimo> ah, that's bad

[09:58] <timotimo> in moarvm you have the ability to get a wrong hint compiled

[09:58] <timotimo> all we have to protect against it is a bounds check

[09:58] <psch> i don't know if it happens on moar.  it does happen on jvm

[10:01] <timotimo> p6: class Test { has int $.a; has int $.b; method test { Proxy.new( FETCH => method ohno(|) { say $!a }, STORE => method ohcrap(|) { } } }; Test.new.test = 10

[10:01] <camelia> rakudo-moar d8309d: OUTPUT«===SORRY!=== Error while compiling <tmp>␤Unable to parse expression in argument list; couldn't find final ')' ␤at <tmp>:1␤------> ay $!a }, STORE => method ohcrap(|) { } ⏏} }; Test.new.test = 10␤    expecting any of:␤        postfi…»

[10:01] <timotimo> p6: class Test { has int $.a; has int $.b; method test { Proxy.new( FETCH => method ohno(|) { say $!a }, STORE => method ohcrap(|) { }) } }; Test.new.test = 10

[10:01] <timotimo> hm

[10:01] <camelia> rakudo-moar d8309d: OUTPUT«Memory allocation failed; could not allocate 7936296 bytes␤»

[10:02] <timotimo> oh, i didn't mean to STORE, i had to FETCH

[10:02] <timotimo> p6: class Test { has int $.a; has int $.b; method test { Proxy.new( FETCH => method ohno(|) { say $!a }, STORE => method ohcrap(|) { }) } }; say Test.new.test

[10:02] <camelia> rakudo-moar d8309d: OUTPUT«Memory allocation failed; could not allocate 7936216 bytes␤»

[10:02] <timotimo> also, i meant to use r: instead of p6:

[10:02] <timotimo> p6: class Test { has int $.a; has int $.b; method test { Proxy.new( FETCH => method ohno(|) { $!b }, STORE => method ohcrap(|) { }) } }; say Test.new.test

[10:03] <camelia> rakudo-moar d8309d: OUTPUT«Memory allocation failed; could not allocate 7970328 bytes␤»

[10:03] <timotimo> so anyway. since method ohno gets compiled from inside Test, it'll generate a hint for Test, but it'll be called as a method on Proxy

[10:03] <timotimo> and thus the hint we get for it doesn't point at $!a in Test, it points at whatever-who-knows-what inside Proxy

[10:04] <cygx> jnthn: it might actually be a case of bit rot - EnumHOW has @!does_list, ut it's not properly populated nor used anywhere as far as ack can tell

[10:04] <cygx> *but

[10:06] <lizmat> Files=1145, Tests=53213, 239 wallclock secs (13.80 usr  3.81 sys + 1483.46 cusr 131.70 csys = 1632.77 CPU)

[10:06] <psch> oh geez

[10:07] <psch> getattr hints belong to a JastField afaict

[10:07] <psch> r: use nqp; my $i = <1i>; say nqp::getattr(nqp::decont($i), ComplexStr, '$!im')

[10:07] <camelia> rakudo-moar d8309d: OUTPUT«P6opaque: no such attribute '$!im' in type ComplexStr when trying to get a value␤  in block <unit> at <tmp> line 1␤␤»

[10:07] <camelia> ..rakudo-jvm 2a1605: OUTPUT«java.lang.RuntimeException: No such attribute '$!im' for this object␤  in block <unit> at <tmp> line 1␤␤»

[10:08] <psch> right

[10:08] <psch> so yeah, no choice but to either always ignore hints on jvm and always check the nameToHintMap of the *actual* REPRData

[10:08] <psch> ...actually that's the only choice

[10:09] <psch> r: use nqp; my $i = <1i>; say nqp::getattr(nqp::decont($i), ComplexStr, '$!re')

[10:09] <camelia> rakudo-moar d8309d: OUTPUT«P6opaque: no such attribute '$!re' in type ComplexStr when trying to get a value␤  in block <unit> at <tmp> line 1␤␤»

[10:09] <camelia> ..rakudo-jvm 2a1605: OUTPUT«java.lang.RuntimeException: No such attribute '$!re' for this object␤  in block <unit> at <tmp> line 1␤␤»

[10:09] <psch> ugh

[10:09] <psch> r: use nqp; my $i = <1i>; say nqp::getattr(nqp::decont($i), Complex, '$!re')

[10:09] <camelia> rakudo-jvm 2a1605: OUTPUT«0␤»

[10:09] <camelia> ..rakudo-moar d8309d: OUTPUT«0e0␤»

[10:09] <psch> r: use nqp; my $i = <1i>; say nqp::getattr(nqp::decont($i), Complex, '$!im')

[10:09] <camelia> rakudo-moar d8309d: OUTPUT«1e0␤»

[10:09] <camelia> ..rakudo-jvm 2a1605: OUTPUT«1␤»

[10:09] <psch> oh, right, getattr doesn't go hinted

[10:09] <psch> r: use nqp; my $i = <1i>; say $i.im

[10:09] <camelia> rakudo-moar d8309d: OUTPUT«1␤»

[10:09] <camelia> ..rakudo-jvm 2a1605: OUTPUT«0␤»

[10:10] <timotimo> yikes

[10:10] <timotimo> oh, that's also a ComplexStr

[10:10] <timotimo> and thus that's teh original bug

[10:10] <psch> right, it's the same bug

[10:10] <timotimo> r: my $i = 1i; say $i.im

[10:10] <camelia> rakudo-jvm 2a1605, rakudo-moar d8309d: OUTPUT«1␤»

[10:10] <timotimo> OK

[10:10] <psch> because the hints for $!im and $!re all both shifted up by one

[10:10] <psch> on jvm

[10:10] <psch> well, not shifted, incremented

[10:10] <psch> but yeah, that case means we cannot ever rely on hints on jvm if we have a MI class

[10:10] <timotimo> do we somehow do multiple inheritance the other way around on JVM?

[10:11] <timotimo> oh!

[10:11] <timotimo> that's the solution

[10:11] <timotimo> hints are thrown out completely on moarvm if multiple inheritance is involved

[10:11] <psch> neat, so i'm kinda smart apparently :3

[10:12] <timotimo> https://github.com/MoarVM/MoarVM/blob/master/src/6model/reprs/P6opaque.c#L232

[10:12] <timotimo> check it

[10:12] <psch> nice

[10:12] <psch> yeah, i can do that

[10:13] <timotimo> i love it when a plan comes togethe

[10:13] <timotimo> what is it with the typing today

[10:13] <timotimo> the bounds check for num_attributes may also want to get ported

[10:14] <timotimo> otherwise we could be accessing things out of bounds

[10:19] <lizmat> Files=1145, Tests=53213, 234 wallclock secs (13.50 usr  3.85 sys + 1425.29 cusr 130.16 csys = 1572.80 CPU)    # better

[10:25] <cygx> jnthn: https://github.com/rakudo/rakudo/pull/896

[10:25] <timotimo> cygx: doesn't RoleContainer already implement @!role_typecheck_list?

[10:26] <timotimo> as well as the accessor method?

[10:27] <cygx> timotimo: no, RoleContainer only provides roles_to_compose

[10:27] <timotimo> oh, ok

[10:27] <timotimo> from a cursory glance, your code looks good

[10:28] <cygx> RoleContainer does look rather underpowered

[10:28] <cygx> it might be a good idea to do some refactoring...

[10:29] <jnthn> RoleContainer shouldn't do much more than exactly that

[10:29] <jnthn> Just like MethodContainer isn't interested in method resolution, but only storage of methods

[10:29] <jnthn> And dispatchy stuff is in a separate role

[10:30] <jnthn> If there's copy-paste between ClassHOW and EnumHOW on role-based things than pulling them out to a role is sensible. Just a different one. :)

[10:31] <cygx> good to know

[10:31] <cygx> I speculated about inhertance in the commit message, but not sure if that's a good or bad idea...

[10:32] <cygx> are there things a class can do that an enum  shouldn't be able to?

[10:33] <jnthn> Inheritance feels a bit off to me

[10:34] <jnthn> We do it for GrammarHOW but a grammar really is just a class with a different default parent class

[10:35] <cygx> and an enum could potentially be just a class with a bunch of default instances

[10:35] <jnthn> It's pretty close to that already I think

[10:35] <jnthn> But there's a bunch of extra meta-methods

[10:36] <jnthn> I guess look through the roles that EnumHOW and ClassHOW compose and see what the differences are :)

[10:36] * jnthn is generally not that fond of inheritance

[10:36] <jnthn> But it might just turn out simpler in this case

[10:37] <Zoffix> m: class Foo {}; my $foo = Foo.new; enum Bar <foo>; say Foo ~~ $foo; say Bar ~~ foo # something an enum can do that a class can't

[10:37] <camelia> rakudo-moar d8309d: OUTPUT«False␤True␤»

[10:39] <cygx> that looks wrong to me

[10:39] <Zoffix> heh

[10:39] <cygx> that aside, the other way around (things a class can do but an enum shouldn't be able to) would be the problem

[10:41] <dalek> nqp: 19877e5 | peschwa++ | src/vm/jvm/runtime/org/perl6/nqp/runtime/Ops.java:

[10:41] <dalek> nqp: Adjust getattr_{i,n,s} on JVM to mirror MoarVM.

[10:41] <dalek> nqp:

[10:41] <dalek> nqp: That is, ignore given hints when we have a class with

[10:41] <dalek> nqp: multiple inheritance.

[10:41] <dalek> nqp: review: https://github.com/perl6/nqp/commit/19877e5042

[10:41] <dalek> rakudo/nom: e64214d | peschwa++ | tools/build/NQP_REVISION:

[10:41] <dalek> rakudo/nom: Bump NQP_REVISION for getattr_{i,n,s} fix.

[10:41] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/e64214dd57

[10:42] <dalek> roast: e27975f | peschwa++ | S02-literals/allomorphic.t:

[10:42] <dalek> roast: Unfudge now passing tests

[10:42] <dalek> roast: review: https://github.com/perl6/roast/commit/e27975ffcd

[12:33] <dalek> rakudo/nom: 7a50c30 | lizmat++ | src/core/IO/Path.pm:

[12:33] <dalek> rakudo/nom: Make dir() about 20% faster

[12:33] <dalek> rakudo/nom:

[12:33] <dalek> rakudo/nom: Rewrite the gather loop using nqp and being smarter about checks

[12:33] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/7a50c30823

[12:35] <lizmat> this brings down use lib "."; say $*REPO.id in the rakudo checkout dir down from 1.9 seconds to 1.5

[12:55] <dalek> rakudo/nom: 7a33c2c | cygx++ | src/Perl6/Metamodel/EnumHOW.nqp:

[12:55] <dalek> rakudo/nom: Make enums typecheck against the roles they do, ie

[12:55] <dalek> rakudo/nom:

[12:55] <dalek> rakudo/nom:     role Foo {}

[12:55] <dalek> rakudo/nom:     enum Bar does Foo <A B>;

[12:55] <dalek> rakudo/nom:     say A ~~ Foo;

[12:55] <dalek> rakudo/nom:

[12:55] <dalek> rakudo/nom: will now be True.

[12:55] <dalek> rakudo/nom:

[12:55] <dalek> rakudo/nom: Note that there are possibly other goodies in ClassHOW that should

[12:55] <dalek> rakudo/nom: also live in EnumHOW. It might or might not be a good idea to just

[12:55] <dalek> rakudo/nom: have EnumHOW inherit from ClassHOW...

[12:58] <lizmat> https://github.com/rakudo/rakudo/commit/7a33c2c

[13:19] <travis-ci> Rakudo build failed. Elizabeth Mattijsen 'Make dir() about 20% faster

[13:19] <travis-ci> https://travis-ci.org/rakudo/rakudo/builds/165220286 https://github.com/rakudo/rakudo/compare/e64214dd57c0...7a50c308239f

[13:19] <buggable> [travis build above] ☠ Did not recognize some failures. Check results manually

[13:20] <hackedNODE> Lots of failures in nativecall tests

[13:20] <hackedNODE> (on jvm only)

[13:20] <psch> i wonder if that's the getattr change, and if so *why*

[13:21] <psch> cause apparently i forgot to run 'make test'

[13:25] <psch> ah, it *is* that

[13:26] <psch> because, obviously, we don't have only P6Opaque as REPR for getattr

[13:26] <psch> or rather, don't only throw P6Opaques into getattr...

[13:27] <psch> oh, but CStruct doesn't do MI anyway, so i can just instanceof i guess

[13:27] <psch> still, kinda fragile i suppose, depending on whether we have other REPRs that do MI

[13:27] <psch> and somewhat inelegant to boot /o\

[13:30] <dalek> roast: bd1b067 | (Zoffix Znet)++ | S32-temporal/DateTime-Instant-Duration.t:

[13:30] <dalek> roast: [coverage] Cover Instant.Date

[13:30] <dalek> roast: review: https://github.com/perl6/roast/commit/bd1b0674e8

[13:34] <lizmat> psch: should I revert your PR ?

[13:35] <psch> lizmat: nah, i'm fixing it right now

[13:35] <lizmat> okidoki, psch++

[13:37] <psch> it is somewhat of a provisionary solution, i guess i'd have to look closer at how moar does it...

[13:41] <psch> hm, the way moar does mean i'd have to put the REPRData checks into gen'd code, from the looks of it

[13:42] <psch> instead of in the getattr op in Ops.java

[13:43] <psch> i guess i'll bandaid and try and implement it properly over the next few days

[13:43] <dalek> roast: 60008ed | (Zoffix Znet)++ | S32-num/int.t:

[13:43] <dalek> roast: [coverage] Add basic cover for UInt

[13:43] <dalek> roast: review: https://github.com/perl6/roast/commit/60008ed544

[13:43] <jnthn> psch: You may be able to do it simply by not generating code

[13:43] <jnthn> psch: iirc there's a switch on hint and a default

[13:44] <jnthn> So for MI could just do the default

[13:44] <psch> jnthn: right, yeah, not generate the check for MI but only generate hinted calls without MI, that sounds a bit saner, thanks :)

[13:45] <jnthn> Laziness wins again :)

[13:47] <hackedNODE> m: dd Int.new: :2('1' x 64).Int

[13:47] <camelia> rakudo-moar 4e12d1: OUTPUT«-1␤»

[13:48] <hackedNODE> m: dd Int.new: 2**63

[13:48] <camelia> rakudo-moar 4e12d1: OUTPUT«-9223372036854775808␤»

[13:52] <psch> well, we apparently only *have* the boolean mi for P6Opaque in the first place

[13:52] <psch> so, actually, until we get more reprs that do MI i'd go with my bandaid

[13:52] <psch> i'll leave a comment in the getattr impls

[13:55] <dalek> nqp: 1344f28 | peschwa++ | src/vm/jvm/runtime/org/perl6/nqp/runtime/Ops.java:

[13:55] <dalek> nqp: Correct oversight in hinted getattr_{i,n,s}

[13:55] <dalek> nqp: review: https://github.com/perl6/nqp/commit/1344f28130

[13:56] <dalek> rakudo/nom: 832764b | peschwa++ | tools/build/NQP_REVISION:

[13:56] <dalek> rakudo/nom: Bump NQP_REVISION for JVM getattr_{i,n,s}

[13:56] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/832764bb44

[13:58] <travis-ci> Rakudo build failed. lizmat 'Merge pull request #896 from cygx/role-typed-enums

[13:58] <travis-ci> https://travis-ci.org/rakudo/rakudo/builds/165225924 https://github.com/rakudo/rakudo/compare/7a50c308239f...4e12d17ddf8c

[13:59] <buggable> [travis build above] ☠ Did not recognize some failures. Check results manually

[14:06] <hackedNODE> Int.new is kinda an odd duck. What is it supposed to be doing? Considering ints just get "new" all by themselves?

[14:07] <cygx> m: use nqp; say nqp::objectid($_) for 42, 42, Int.new(42)

[14:07] <camelia> rakudo-moar 4e12d1: OUTPUT«50103272␤50103272␤50103352␤»

[14:08] <hackedNODE> And you can't use 64+ bit things with it.

[14:08] <hackedNODE> And according to coverage report, it ain't in roast

[14:08] <cygx> m: use nqp; say nqp::objectid($_) for 42, 42, (42 but False);

[14:08] <camelia> rakudo-moar 4e12d1: OUTPUT«57259040␤57259040␤57259120␤»

[14:09] <hackedNODE> m: use nqp; say nqp::objectid($_) for 4200, 4200, Int.new(4200)

[14:09] <camelia> rakudo-moar 4e12d1: OUTPUT«68748296␤68748296␤68748376␤»

[14:09] <hackedNODE> m: use nqp; say nqp::objectid($_) for 42, 42, (42 does False);

[14:09] <camelia> rakudo-moar 4e12d1: OUTPUT«70329512␤70329512␤70329512␤»

[14:09] <hackedNODE> m: use nqp; say nqp::objectid($_) for 42, 42, Int.new(42) does False;

[14:09] <camelia> rakudo-moar 4e12d1: OUTPUT«67151048␤67151048␤67151128␤»

[14:09] <hackedNODE> So that's one use

[14:10] <cygx> m: say .so for 42,42,42 does False

[14:10] <camelia> rakudo-moar 4e12d1: OUTPUT«False␤False␤False␤»

[14:10] <cygx> m: say .so for 42,42,42 but False

[14:10] <camelia> rakudo-moar 4e12d1: OUTPUT«True␤True␤False␤»

[14:12] <lucasb_> hackedNODE: I think it's good to be able to say something like this:

[14:12] <lucasb_> m: say (Int.new, Num.new, Rat.new, Str.new, Bool.new).perl

[14:12] <camelia> rakudo-moar 832764: OUTPUT«(0, 0e0, 0.0, "", Bool::False)␤»

[14:12] <lucasb_> m: Complex.new  # can someone make this work, please? :)

[14:12] <camelia> rakudo-moar 832764: OUTPUT«Cannot resolve caller new(Complex: ); none of these signatures match:␤    (Complex $: Real \re, Real \im, *%_)␤  in block <unit> at <tmp> line 1␤␤»

[14:12] <hackedNODE> lucasb_: and why is it good?

[14:12] <hackedNODE> lucasb_: 'cause right now Int.new is broken

[14:13] <lucasb_> hackedNODE: idk, it's just my feeling. I don't have a concrete answer

[14:13] <lucasb_> why Int.new is broken?

[14:13] <hackedNODE> .oO( programming by feeling... )

[14:14] <hackedNODE> lucasb_: it gives incorrect results in range of 2**63-2**64 and then fails to accept any higher values, even though an Int can hold them

[14:14] <lucasb_> I used Ruby a little, and I can say SomeClass.new for most core classes, and they have a reasonable default value

[14:14] <hackedNODE> You can say 0 instead of Int.new

[14:17] <lucasb_> m: say (.new for Int, Str, Rat, Num, Bool).perl  # here's one use case, when you don't know what you want to instantiate

[14:17] <camelia> rakudo-moar 832764: OUTPUT«(0, "", 0.0, 0e0, Bool::False)␤»

[14:18] <lucasb_> m: say Range.new   # on the other hand, I find this UNreasonable. it shouldn't work, IMO :)

[14:18] <camelia> rakudo-moar 832764: OUTPUT«Any..Any␤»

[14:18] <hackedNODE> lucasb_: I'm not following that usecase. What's the endgoal of that program?

[14:21] <lucasb_> hackedNODE: idk. something like, when you receive a type object in a variable, and you don't know what it is. but you expect to be able to just call .new on it without any arguments and get a default value

[14:21] <hackedNODE> You can call .?new :)

[14:22] <hackedNODE> But anyway, I think I'm testing a fix right now

[14:22] <perlpilot> lucasb_: ITYM "... get a useful default value"  :-)  But what if there is no useful default? (See Range :)

[14:23] <hackedNODE> or not :( bigint isn't avaiable in src/core/Int

[14:24] <lucasb_> perlpilot: when the class has a *clear* default value, like 0, 0.0, "", etc. then it's ok

[14:24] <lucasb_> perlpilot: in the Range case, I think it should be an error

[14:25] <lucasb_> I think the *clear* default value for complex is 0+0i

[14:25] <hackedNODE> Why? :)

[14:25] <lucasb_> why not? :D

[14:26] <hackedNODE> Because you appear to have arbitrary picked a number for no specific reason.

[14:26] <hackedNODE> m: say so 0+0i

[14:26] <camelia> rakudo-moar 832764: OUTPUT«False␤»

[14:26] <hackedNODE> And simply called it "clear" default :)

[14:26] <hackedNODE> m: my Complex $z; say +$z

[14:26] <camelia> rakudo-moar 832764: OUTPUT«Use of uninitialized value of type Complex in numeric context␤  in block <unit> at <tmp> line 1␤0␤»

[14:27] <lucasb_> I don't think zero is arbitrary. But ok, it can be controversial :)

[14:27] <perlpilot> lucasb_: I think it's clear that a default Range should go from -Inf..+Inf

[14:27] <hackedNODE> 0..0, clearly :)

[14:28] <perlpilot> no, no,   0..Inf

[14:28] <lucasb_> remember when Date.new returned xmas date?

[14:28] <tadzik> I do :)

[14:29] <hackedNODE> It clearly should've been my birthdate

[14:29] <hackedNODE> The world did not exist before then :P

[14:29] <perlpilot> no, it should have been Perl's birthdate!

[14:29] <perlpilot> or perhaps TimToady's

[14:35] <dalek> rakudo/nom: f72cc62 | (Zoffix Znet)++ | src/core/Complex.pm:

[14:35] <dalek> rakudo/nom: Make Complex.new() return 0+0i

[14:35] <dalek> rakudo/nom:

[14:35] <dalek> rakudo/nom: Reasoning:

[14:35] <dalek> rakudo/nom: - Other numerics initialize to 0

[14:35] <dalek> rakudo/nom: - Complex:U in numeric operations evalutes to 0+0i

[14:35] <dalek> rakudo/nom:

[14:35] <dalek> rakudo/nom: lucasb_++ for noticing

[14:35] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/f72cc623be

[14:36] <lucasb_> OMG, thanks hackedNODE++ :)

[14:36] <hackedNODE> :)

[14:36] <lucasb_> now, make Range.new illegal :) lol

[14:37] <hackedNODE> nah :}

[14:38] <dalek> roast: 3518585 | (Zoffix Znet)++ | S32-num/complex.t:

[14:38] <dalek> roast: Test Complex.new() gives 0+0i

[14:38] <dalek> roast: review: https://github.com/perl6/roast/commit/3518585640

[14:52] <lizmat> dalek ?

[14:53] <hackedNODE> dalek is netsplat

[14:55] <hackedNODE> m: use MONKEY; augment class Int { method realnew ($v) { $v.clone.Int } }; say [ $_, nqp::objectid($_) ] for 2**65, Int.realnew(2**65), (my int $x = 42), Int.realnew($x), Int.realnew("foo")

[14:55] <camelia> rakudo-moar f72cc6: OUTPUT«[36893488147419103232 59743592]␤[36893488147419103232 59743872]␤[42 59743912]␤[42 59743952]␤Cannot convert string to number: base-10 number must begin with valid digits or '.' in '⏏foo' (indicated by ⏏)␤  in method realnew at <tmp> line …»

[14:55] <lizmat> https://github.com/rakudo/rakudo/commit/a48e7a7dd379c8c2150   # Re-imagine DIR-RECURSE

[14:55] <hackedNODE> I think that fix for Int.new can work.

[14:55] <lizmat> nine: wonders what that brings for the perl6/mu checkout

[14:55] <hackedNODE> It uses .clone to get new object (so we decouple it from any cached constants) and we use .Int to coerce non-intish things to Int

[14:56] <lizmat> nine: fwiw, I know think any delay is really caused by slurping fiiles and doing the sha1 on them

[15:15] <hackedNODE> enodalek

[15:15] <hackedNODE> Int.new fix: https://github.com/rakudo/rakudo/commit/798c2e2dca34e5cf93da99d1f401eb161efca854

[15:16] * hackedNODE rakes hack's bash history to find out how to restart the bot :)

[15:19] <hackedNODE> no idea... don't wanna break anything

[15:28] <hackedNODE> m: use nqp; say nqp::istype(role {}, Cool)

[15:28] <camelia> rakudo-moar a48e7a: OUTPUT«1␤»

[15:28] <hackedNODE> How come this is true?

[15:32] <lizmat> hackedNODE: beats me

[15:37] <travis-ci> Rakudo build passed. Zoffix Znet 'Make Complex.new() return 0+0i

[15:37] <travis-ci> https://travis-ci.org/rakudo/rakudo/builds/165253239 https://github.com/rakudo/rakudo/compare/832764bb442b...f72cc623be6e

[15:41] <lizmat> https://github.com/rakudo/rakudo/commit/ff50cef62d5f71eeb   # Re-imagine DIR-RECURSE further

[15:56] <nine> lizmat: will still not help the mu repo case as long as we don't detect the symlink loop

[15:57] <lizmat> is it really a loop ?

[15:57] <lizmat> or just a lot of symlinks causing duplication of files?

[15:57] <geekosaur> it was really a loop

[15:58] <geekosaur> some interior symlink that pointed to the top of the repo

[15:58] <geekosaur> [04 16:26:20] <nine> /home/nine/install/mu/misc/kp6_misc/kp6_ast/root_pugs/misc/kp6_misc/kp6_ast/root_pugs/misc/kp6_misc/kp6_ast/root_pugs/misc/kp6_misc/kp6_ast/root_pugs/misc/kp6_misc/kp6_ast/root_pugs/misc/kp6_misc/kp6_ast/root_pugs/misc/kp6_misc/kp6_ast/root_pugs/misc/kp6_misc/kp6_ast/root_pugs/misc/kp6_misc/kp6_ast/root_pugs/misc/kp6_misc/kp6_ast/root_pugs/misc/kp6_misc/kp6_ast/root_pugs/misc/kp6_misc/kp6_ast/root_pugs/misc/kp6_misc/kp6_a

[15:58] <geekosaur> st/root_pugs/misc/kp6_misc/kp6_ast/root

[15:59] <psch> m: say role {}.^mro

[15:59] <camelia> rakudo-moar ff50ce: OUTPUT«((<anon|50771696>))␤»

[15:59] <psch> m: say role {}.new.^mro

[15:59] <camelia> rakudo-moar ff50ce: OUTPUT«((<anon|55203600>) (Any) (Mu))␤»

[15:59] <lizmat> geekosaur: so how can it then not infiniloop ?

[15:59] <geekosaur> by tracking already-seen nodes, as nine pointed out right after that

[16:00] <geekosaur> you need that anyway as symlinks are not the only way for it to happen: windows reparse points, AFS volume mount points, and Linux bind mounts being several alternatives

[16:00] <geekosaur> (and loopback NFS mounts, and ...)

[16:01] <timotimo> how do you actually recognize an already-seen node?

[16:02] <lizmat> ok, but this only applies to symlinks to dirs, no ?

[16:02] <lizmat> I mean, if we symlink to a file, we probably want to include the file, because it can get unsymlinked and get another content

[16:04] <geekosaur> timotimo, presumably every OS has something conceptually similar to unix's stat()/lstat() which gives you some kind of file ID

[16:04] <geekosaur> (dev/inum on unix)

[16:04] <geekosaur> because that (some kind of unique id) is needed or not even the OS can detect such loops

[16:04] <cygx> nqp::stat($_, nqp::const::STAT_PLATFORM_DEV) ~ '.' ~ nqp::stat($_, nqp::const::STAT_PLATFORM_INODE)

[16:06] <timotimo> OK

[16:09] <hackedNODE> m: &infix:<**>((my int $a = 2**62), (my int $b = 2**62))

[16:09] <camelia> rakudo-moar ff50ce: OUTPUT«This type cannot unbox to a native integer: P6opaque, Failure␤  in block <unit> at <tmp> line 1␤␤»

[16:10] * hackedNODE has trouble figuring out where it's getting that from :/

[16:10] <hackedNODE> s: &infix:<**>, \((my int $a = 2**62), (my int $b = 2**62))

[16:10] <SourceBaby> hackedNODE, Sauce is at https://github.com/rakudo/rakudo/blob/798c2e2/src/core/Int.pm#L286

[16:10] <timotimo> m: my int $b = 2 ** 62

[16:10] <camelia> rakudo-moar ff50ce: ( no output )

[16:10] <timotimo> it looks very much like it comes from inside moarvm

[16:11] <hackedNODE> Weird. 'cause if I run ^ that candidate or the int int candidate in camelia, they work fine

[16:11] <hackedNODE> Just not in core. And I tried with optimize=off, still no love

[16:11] <hackedNODE> j: &infix:<**>((my int $a = 2**62), (my int $b = 2**62))

[16:11] <camelia> rakudo-jvm 2a1605: ( no output )

[16:11] <hackedNODE> aha

[16:11] <psch> j: my int $x = 2 ** 64

[16:11] <camelia> rakudo-jvm 2a1605: ( no output )

[16:12] <psch> don't trust natives on jvm :P

[16:12] <hackedNODE> Oh lol

[16:12] <hackedNODE> m: use nqp; sub foo (Int:D \a, Int:D \b) {  b >= 0 ?? nqp::pow_I(nqp::decont(a), nqp::decont(b), Num, Int) !! 1 / nqp::pow_I(nqp::decont(a), nqp::decont(-b), Num, Int) or a == 0 ?? 0 !! Failure.new(X::Numeric::Overflow.new) }; say foo (my int $a = 2**62), (my int $b = 2**62)

[16:12] <camelia> rakudo-moar ff50ce: OUTPUT«Numeric overflow␤  in block <unit> at <tmp> line 1␤␤Actually thrown at:␤  in block <unit> at <tmp> line 1␤␤»

[16:12] <hackedNODE> m: use nqp; my int $a = 2**62; my int $b = 2**62; say (nqp::pow_i($a, $b) or $a == 0 ?? 0 !! Failure.new(X::Numeric::Overflow.new))

[16:12] <camelia> rakudo-moar ff50ce: OUTPUT«Numeric overflow␤␤Actually thrown at:␤  in block <unit> at <tmp> line 1␤␤»

[16:12] <hackedNODE> ^ here both candidates work. Weird

[16:16] <gfldex> lizmat: look for ELOOP, you may be able to offload the work to the OS http://man7.org/linux/man-pages/man7/path_resolution.7.html

[16:16] <lizmat> that's pretty OS gnostic, fon't you think ?  :-)

[16:16] <gfldex> windows must have a max recursion thing too

[16:17] <geekosaur> gfldex, the OS is already catching it currently. there is a delay before it kicks in though

[16:17] <geekosaur> because at least on linux the loop limit is high enough that it actually hits PATH_MAX first

[16:19] <gfldex> if you walk the dir recursively yourself it wont hit until you acutally are 40 elements deep. So by finding a syscall that follows by itself, you may get ELOOP or hit PATH_MAX right away

[16:19] <geekosaur> and the actual loop happens deep enough that you will take a while to hit it in a dense subtree

[16:23] <geekosaur> and the point here is to detect and avoid the loop *before* the OS finally gets around to it, after several minutes and lots of duplicate files processed

[16:24] <geekosaur> also no, there is no syscall that will immediately detect that foo/bar/baz/quux is a symlink to foo that will loop *if you do a full traversal of foo*

[16:24] <gfldex> whenever I google tricky filesystem stuff and windows I end up on the cygwin mailing list :)

[16:25] <travis-ci> Rakudo build failed. Elizabeth Mattijsen 'Re-imagine DIR-RECURSE

[16:25] <travis-ci> https://travis-ci.org/rakudo/rakudo/builds/165258075 https://github.com/rakudo/rakudo/compare/f72cc623be6e...a48e7a7dd379

[16:26] <buggable> [travis build above] ☠ Did not recognize some failures. Check results manually

[16:28] <lizmat> afk for a bit&

[16:29] <geekosaur> ...and if there were you'd probably still be vulnerable to a race

[16:37] <hackedNODE> s/weird//;

[16:37] <hackedNODE> I'm really blind. Not sure where I was looking when I looked for it, but there is a `returns int` on my broken subs that I failed to notice :/

[16:44] <japhb> hackedNODE: That's one of the reasons I prefer '--> int)' rather than ') returns int' -- the former stands out for me much better when skimming or debugging code.

[16:44] <japhb> Also, the piece of Haskell that most infected my brain is that return type is part of a function's signature.  :-)

[16:44] <hackedNODE> I think I was just looking at wrong code :)

[16:46] <hackedNODE> m: sub (--> Int) { Failure.new }().Bool

[16:46] <camelia> rakudo-moar ff50ce: ( no output )

[16:46] <hackedNODE> m: sub (--> int) { Failure.new }().Bool

[16:46] <camelia> rakudo-moar ff50ce: OUTPUT«This type cannot unbox to a native integer: P6opaque, Failure␤  in sub  at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[16:46] <hackedNODE> m: sub (--> int) { fail }().Bool

[16:46] <camelia> rakudo-moar ff50ce: ( no output )

[16:46] <hackedNODE> Any tips on where the code that handles this stuff is at?

[16:48] <timotimo> there's an op that does the return type checking

[16:48] <timotimo> but clearly when we're supposed to return a native, we can't just stick an object where the native once was

[16:48] <timotimo> so there's probably not even a typecheck op inserted there

[16:49] <hackedNODE> m: ->-->int { Failure.new }()

[16:49] <camelia> rakudo-moar ff50ce: OUTPUT«Failed␤  in block <unit> at <tmp> line 1␤␤Actually thrown at:␤  in block <unit> at <tmp> line 1␤␤»

[17:00] <gfldex> lizmat: stat does not return $dev or $ino for danglink symlinks, so they can be undefined

[17:04] <geekosaur> right, you need to use lstat for that

[17:05] <geekosaur> although for a dangling symlink you should just treat that the same as any missing file and report a warning or error as appropriate (usually for a dangling symlink a warning is what you want)

[17:06] <travis-ci> Rakudo build failed. Zoffix Znet 'Fix Int.new for large values

[17:06] <travis-ci> https://travis-ci.org/rakudo/rakudo/builds/165265560 https://github.com/rakudo/rakudo/compare/a48e7a7dd379...798c2e2dca34

[17:07] <buggable> [travis build above] ☠ Did not recognize some failures. Check results manually

[17:08] <dalek> roast: f9950fa | RabidGravy++ | S32-list/cross.t:

[17:08] <dalek> roast: Simple test for the sub form of 'X'

[17:08] <dalek> roast:

[17:08] <dalek> roast: Closes #165

[17:08] <dalek> roast: review: https://github.com/perl6/roast/commit/f9950fa290

[17:08] <hackedNODE> How come p6typecheckrv op doesn't show up when I grep nqp or MoarVM repos? I see it generated here: https://github.com/rakudo/rakudo/blob/nom/src/Perl6/Actions.nqp#L8988

[17:08] <timotimo> it's a rakudo extensionop

[17:09] <hackedNODE> Ah, OK. Found it: https://github.com/rakudo/rakudo/blob/nom/src/vm/moar/Perl6/Ops.nqp#L585

[17:10] <timotimo> oh, it's not actually an extop

[17:10] <timotimo> sorry

[17:19] <dalek> rakudo/nom: 6f7e4bd | RabidGravy++ | t/spectest.data:

[17:19] <dalek> rakudo/nom: Add the S32-list/cross.t to the spectest.data

[17:19] <dalek> rakudo/nom:

[17:19] <dalek> rakudo/nom: Re https://github.com/perl6/roast/issues/165

[17:19] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/6f7e4bdce8

[17:19] <dalek> rakudo/nom: 9ea23c9 | (Zoffix Znet)++ | t/spectest.data:

[17:19] <dalek> rakudo/nom: Merge pull request #897 from jonathanstowe/nom

[17:19] <dalek> rakudo/nom:

[17:19] <dalek> rakudo/nom: Add the S32-list/cross.t to the spectest.data

[17:19] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/9ea23c9c47

[17:41] <gfldex> lizmat: perl5 version of loop detection https://gist.github.com/gfldex/865852d35e17760ace55c19178cf79bf

[17:46] <gfldex> lizmat: works for symlinks and mount -o bind. No idea about hardlinks on directories. I don't got a OS/fs that would allow me this kind of madness.

[17:46] <gfldex> writing perl5 code is really unpleasant now :)

[17:48] <travis-ci> Rakudo build errored. Elizabeth Mattijsen 'Squeeze another 20% out of DIR-RECURSE

[17:48] <travis-ci> https://travis-ci.org/rakudo/rakudo/builds/165273068 https://github.com/rakudo/rakudo/compare/798c2e2dca34...ff50cef62d5f

[17:50] <geekosaur> that should work, unless the fs itself is broken and cannot unambiguously identify its own files

[17:50] <hackedNODE> 13union again

[17:50] <buggable> [travis build above] ☠ Did not recognize some failures. Check results manually

[17:51] <geekosaur> (or other corner cases that basically mean there's no way for any program to do so, e.g. accessing it over some network filesystem that loses the original id)

[18:03] <gfldex> techically there is the danger of reused inode numbers but that would require to start a script while the module installer is running. I don't think we support that case right now.

[18:44] <dalek> roast: fa7da3d | RabidGravy++ | S32-list/cross.t:

[18:44] <dalek> roast: Use is-deeply rather than `is`  for the tests

[18:44] <dalek> roast:

[18:44] <dalek> roast: As per comments on

[18:44] <dalek> roast: https://github.com/perl6/roast/commit/f9950fa290b0a16d75d9e4a0473f50ed1e506224

[18:44] <dalek> roast:

[18:44] <dalek> roast: See also #167

[18:44] <dalek> roast: review: https://github.com/perl6/roast/commit/fa7da3df02

[18:48] <hackedNODE> This would be the code that runs any time p6typecheckrv op is run, right? https://github.com/rakudo/rakudo/blob/nom/src/vm/moar/Perl6/Ops.nqp#L585

[18:48] <hackedNODE> 'cause I stuck a bunch of nqp::say() statements inside of it and one right before this line: https://github.com/rakudo/rakudo/blob/nom/src/Perl6/Actions.nqp#L8989

[18:48] <hackedNODE> and the one in Actions printed, but the one in Ops.nqp didn't.

[18:49] * hackedNODE is still trying to find why one Failure works but other doesn't

[18:49] <hackedNODE> m: sub (-->int) { return Failure.new }()

[18:49] <camelia> rakudo-moar 9ea23c: OUTPUT«Failed␤  in block <unit> at <tmp> line 1␤␤Actually thrown at:␤  in block <unit> at <tmp> line 1␤␤»

[18:49] <hackedNODE> m: sub (-->int) { Failure.new }()

[18:49] <camelia> rakudo-moar 9ea23c: OUTPUT«This type cannot unbox to a native integer: P6opaque, Failure␤  in sub  at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[18:51] <psch> hackedNODE: well, the code in Ops.nqp is codegen code

[18:51] <psch> hackedNODE: so your says should happen during CORE.setting compilation

[18:51] <hackedNODE> Yeah, they did

[19:09] <nine> For those interested, this was my day today :) http://niner.name/pictures/2016-10-05%20Innsbruck/

[19:09] <nine> And no, I didn't take the bus in the first picture. It was just too crazy not to take a picture of...

[19:09] <travis-ci> Rakudo build failed. Zoffix Znet 'Merge pull request #897 from jonathanstowe/nom

[19:09] <travis-ci> https://travis-ci.org/rakudo/rakudo/builds/165301003 https://github.com/rakudo/rakudo/compare/ff50cef62d5f...9ea23c9c4745

[19:11] <gfldex> nine: a reasonable move to take pictures of yourself if the landscape is invisible. :)

[19:12] <gfldex> really nice weather you got there :)

[19:12] <hackedNODE> "Pale Moon can't find the server at www.niner.name." :(=

[19:13] <buggable> [travis build above] ☠ Did not recognize some failures. Check results manually

[19:13] <nine> gfldex: the weather report from this morning  was "mostly sunny"  btw

[19:13] <psch> hah

[19:13] <psch> rindfleischreisen made me think of "Beef Traveler", with their hit single "Hook" :l

[19:14] <hackedNODE> :( buggable ate all my RAM

[19:14] <psch> except that's just a (kinda horrible) pun

[19:14] <nine> hackedNODE: does http://seifert.website/pictures/2016-10-05%20Innsbruck/ work by any chance?

[19:14] <hackedNODE> yup

[19:14] <psch> okay, the sixth picture in the folder is enough for me

[19:14] <lucasb_> mostly snowy

[19:14] <hackedNODE> And I can get to niner.name with lynx on the box I'm proxying Pale Moon through, so I think Pale Moon is just dumb :)

[19:15] <psch> i'll eat and then sleep

[19:16] <nine> hackedNODE: some people do have trouble accessing niner.name due to some DNS weirdness. Something about inconsistent glue that I seem to be unable to fix. The irony is that seifert.website is configured identically and registered through the same registrar.

[19:16] <nine> So I slowly start to believe that nic.name is to blame...

[19:36] <moritz> nine: I believe ns1.niner.name is to blame

[19:37] <moritz> nine: http://perlpunks.de/paste/show/57f55681.7717.354

[19:38] <moritz> nine: going for the IPv6 address also gives a timeout

[19:40] <moritz> nine: http://perlpunks.de/paste/show/57f5573f.1c13.20e that#s the traceroute

[19:44] <nine> ns1.niner.name hasn't had 188.40.80.22 for more than a year

[19:45] <moritz> then the .name nic is to blame

[19:45] <nine> which is Verisign

[19:46] <moritz> complain loudly

[19:48] <moritz> all .name nameserver give a glue record ns1.niner.name. IN A 188.40.80.22

[19:51] <nine> moritz: thanks! Just wrote Verisign an Email. Maybe it even helps.

[19:52] <nine> I will give them a day or two. Then I'll try changing the DNS servers to other host names with DirectNIC. I've updated my records there a couple of times already but never tried different names, so maybe they were being too smart detecting no change.

[20:01] <nine> It seems like I had the exact same problems the last time I moved to a new server back in 2014. Just found an email by DirectNIC support

[20:09] <gfldex> lizmat: please backlog if you did not do so already

[20:12] <dalek> rakudo/nom: 62d8382 | lizmat++ | src/core/ (2 files):

[20:12] <dalek> rakudo/nom: Make DIR-RECURSE handle symlinks

[20:12] <dalek> rakudo/nom:

[20:12] <dalek> rakudo/nom: - only for directories

[20:12] <dalek> rakudo/nom: - keep a hash of directories seen

[20:12] <dalek> rakudo/nom: - move stubbing of IO / IO::Path up from Cool to Rakudo::Internals

[20:12] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/62d8382fa8

[20:12] <lizmat> gfldex: I'm not sure how https://gist.github.com/gfldex/865852d35e17760ace55c19178cf79bf helps in our situation

[20:13] <lizmat> gfldex: please tell me what is wrong with the approach I just took ^^^

[20:14] <lizmat> in the mu repo, I now get:

[20:14] <lizmat> $ 6 'use lib "."; say $*REPO.id'

[20:14] <lizmat> F69C667842D222649E295BFFF370D6AE68003A97

[20:14] <lizmat> real	0m0.685s

[20:21] <gfldex> lizmat: as I understand this code, it resolves anything into abspath, what would turn a symlink into an abspath as well and then use a seen-hash to keep track of them. That wont work for loops because in a loop the path name changes with each iteration of that loop. If the objective is to speed up what we have already this is fine.

[20:22] <gfldex> if there is a loop however it depends on the OS to crap out.

[20:23] <lizmat> hmmm... I've created a loop here, and it works fine

[20:24] <gfldex> is it fast?

[20:24] <lizmat> no noticeable difference with no loop

[20:25] <lizmat> $ pwd

[20:25] <lizmat> /Users/liz/Github/rakudo.moar/foo

[20:25] <lizmat> $ ls -ls bar

[20:25] <lizmat> 8 lrwxr-xr-x  1 liz  macports  2 Oct  5 21:48 bar -> ..

[20:26] <gfldex> is this on Windows?

[20:26] <lizmat> OS X

[20:26] <gfldex> no idea what is PATH_MAX on osx, on windows it can go up to 32767

[20:27] <lizmat> the thing is is doesn't grow..  IO::Path.resolve will take it to the underlying dir

[20:27] <lizmat> so a. the path never grows, and b. is found to be a duplicate

[20:27] <gfldex> isn't .. skiped by dir()?

[20:28] <lizmat> this isn't using dir() at all

[20:29] <lizmat> so, first it sees "bar", finds out it is a dir, *then* finds out it is a symlink, then resolves it, and then ignores if duplicate

[20:31] <gfldex> ls /tmp/dir1/dir5/ # ls: cannot access '/tmp/dir1/dir5/': Too many levels of symbolic links

[20:31] <gfldex> lizmat: do you get this error message form bash?

[20:32] <lizmat> ENODIR ?

[20:32] <gfldex> i think that would be ELOOP

[20:33] <lizmat> well, I don't have a /tmp/dir1 to begin with

[20:33] <gfldex> i created the link inside `cd /tmp/dir1/; ln -s dir5 /tmp/dir1/`

[20:34] <gfldex> so you would need `bar -> /Users/liz/Github/rakudo.moar/foo/` inside foo

[20:34] <gfldex> (i think, my brain is not good with recursion)

[20:37] <lizmat> the thing is, that if you have a circular symlink like that, it isn't a dir

[20:38] <lizmat> do the infinlooping cannot happen

[20:38] <lizmat> also, it's not a regular file either, so it is also ignored

[20:38] <lizmat> at least in DIR-RECURSE

[20:39] <gfldex> that deals with symlinks then but not with the cases of loops that come from other stuff. I would ignore that tho. If you build a loop with mount -o bind you deserve the pain :)

[20:40] <lizmat> and I think it will even handle that correctly

[20:41] <gfldex> does nqp::stat do a lstat before a stat?

[20:41] <lizmat> not as far as I know

[20:42] <lizmat> nqp::stat is oblivious to symlinks afaik

[20:42] <gfldex> then it should do all tests on it's target. That means a test for directory should succeed on a symlink pointing at a directory

[20:42] <lizmat> yup

[20:43] <lizmat> that was the idea, afaiac

[20:43] <gfldex> ohh, there is nqp::fileislink

[20:43] <lizmat> yup

[20:44] <lizmat> so, as far as I underatand it, the loading of a module in mu should now be around 1 second

[20:45] <gfldex> how do I test that?

[20:46] <gfldex> or better, in what directory do I have to place symlinks/junctions/meanies?

[20:50] <lizmat> at any location in or below the dir you specify with "use lib"

[21:13] <gfldex> stat("/tmp/dir1/dir5", 0x7fffa93283d0)  = -1 ELOOP (Too many levels of symbolic links)

[21:14] <gfldex> lizmat: so it craps out on a stat and the error code is simply ignored and a False returned (or somesuch)

[21:16] <lizmat> not sure if I follow you

[21:16] <geekosaur> only works for explicit loops, again, not for delayed loops that are only triggered by traversals

[21:16] <lizmat> the logic in DIR-RECURSE is:

[21:16] <lizmat> 1. do we accept the filename

[21:17] <lizmat> 2. if so, does the file exist and is it a regular file (using stat, oblivious to symlinks)

[21:17] <lizmat> 3. then we found a file

[21:17] <lizmat> 4. if not, do we accept it as a dirname

[21:18] <lizmat> 5. if so, does the dir exist and is it a dir (again, oblivious to symlinks)

[21:18] <gfldex> step 2 fails with ELOOP, so your code thinks the file doesn't exist. Since such infinite loops don't work anyway that's find.

[21:18] <lizmat> 6. then if it is a symlink, resolve it and use that as the path name

[21:18] <lizmat> 7. did we see the directory before, then ignore

[21:18] <lizmat> 8. schedule dir for later processing

[21:19] <lizmat> gfldex: yup

[21:20] <gfldex> but I don't understand what you need the seen hash for. It should get slower, not faster.

[21:20] <lizmat> if the symlink resolves to a dir that we've seen before, we don't want to do that dir again

[21:21] <gfldex> ok, got it

[21:25] <gfldex> would it make sense to doc the recursive nature of `use Foo;`? The only nasty case I can think of are plenty of btrfs snapshots somewhere in the module search path.

[21:26] <gfldex> or better doc it for `use Lib '/foo/'` and -I

[21:26] <lizmat> gfldex: that's only the case if you have a "use lib" active

[21:26] <lizmat> yup, well

[21:26] <gfldex> do we ignore .git already?

[21:26] <lizmat> we ignore every dir that starts with "."

[21:27] <gfldex> that needs docing for sure

[21:27] <lizmat> technically, we should probably ignore all dirs that have a name that is not allowed to be part of a class name

[21:27] <lizmat> since Foo::.git is illegal as name, that works fine

[21:28] <lizmat> but I'm not sure what would be a fast way to check for identifier legality

[21:31] <gfldex> can you guess what we don't doc yet? :->

[21:32] <lizmat> plenty ?  :-)

[21:33] <gfldex> not really, I'm quite confident that we got pretty much all language features. There may be some hole in grammars left and a few methods that are not doced yet.

[21:33] <gfldex> but use lib 'foo' is not doced

[21:37] <lizmat> but -I is ?

[21:38] <gfldex> yes

[21:39] <lizmat> m: my token foo { <.ident> [ <[ ' \- ]> <.ident> ]* }; say "bar" ~~ / ^ <foo> $ /   # works fine

[21:39] <camelia> rakudo-moar 62d838: OUTPUT«｢bar｣␤ foo => ｢bar｣␤»

[21:39] <lizmat> m: my token foo { <.ident> [ <[ ' \- ]> <.ident> ]* }; say "bar" ~~ / ^ <.foo> $ /   # is this a bug ?

[21:39] <camelia> rakudo-moar 62d838: OUTPUT«No such method 'foo' for invocant of type 'Cursor'␤  in block <unit> at <tmp> line 1␤␤»

[21:39] <lizmat> gfldex: then at least document 'use lib' there ?

[21:51] <Zoffix> m: say (my int $ = 2**62) div (my int $ = 0); CATCH { default { .^name.say; } }

[21:51] <camelia> rakudo-moar 62d838: OUTPUT«X::AdHoc␤»

[21:51] <Zoffix> m: say 0/0; CATCH { default { .^name.say; } }

[21:51] <camelia> rakudo-moar 62d838: OUTPUT«X::Numeric::DivideByZero␤»

[21:51] <Zoffix> Comment says "# relies on opcode or hardware to detect division by 0". Imma change it to a CATCH that throws right exception, unless anyone has objections.   https://github.com/rakudo/rakudo/blob/nom/src/core/Int.pm#L271

[21:52] <Zoffix> or try $b for zero....

[21:53] <lizmat> Zoffix: having a CATCH block in a block prevents inlining, so there may be performance issues ?

[21:53] <Zoffix> OK, what about checking $b == 0?

[21:54] <Zoffix> m: constant Int $i = 0;

[21:54] <camelia> rakudo-moar 62d838: OUTPUT«===SORRY!=== Error while compiling <tmp>␤Missing initializer on constant declaration␤at <tmp>:1␤------> constant Int⏏ $i = 0;␤»

[21:54] <Zoffix> That blows

[21:56] <gfldex> that's just LTA, you can't have a runtime type check on a bound container that is bound at compile time

[21:57] <Zoffix> My original usecase is I wanted some `constant` native ints

[21:57] <gfldex> that may be NYI

[21:57] <gfldex> m: constant int $i = 0;

[21:57] <camelia> rakudo-moar 62d838: OUTPUT«===SORRY!=== Error while compiling <tmp>␤Missing initializer on constant declaration␤at <tmp>:1␤------> constant int⏏ $i = 0;␤»

[21:58] <gfldex> also LTA

[21:59] <gfldex> it's a good question if a native int type constaint on a constant makes sense. They can't be undefined.

[22:00] <dalek> rakudo/nom: 8023dfb | (Zoffix Znet)++ | src/core/Int.pm:

[22:00] <dalek> rakudo/nom: Throw on overflow in infix:<*>(int, int)

[22:00] <dalek> rakudo/nom:

[22:00] <dalek> rakudo/nom: Detect overflow and return a Failure. Currently won't work entirely

[22:00] <dalek> rakudo/nom: right due to RT#129811 ( https://rt.perl.org/Ticket/Display.html?id=129811 ),

[22:00] <synopsebot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=129811

[22:00] <dalek> rakudo/nom: but will automatically do the right thing once that is fixed.

[22:00] <dalek> rakudo/nom:

[22:00] <dalek> rakudo/nom: Fixes RT#129813: https://rt.perl.org/Ticket/Display.html?id=129813

[22:00] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/8023dfbc6f

[22:00] <synopsebot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=129813

[22:00] <Zoffix> gfldex, I guess it's more of a question of *how* to get an immutable native int, rather than constraining anything

[22:01] <Zoffix> m: int.new.say

[22:01] <camelia> rakudo-moar 62d838: OUTPUT«No such method 'BUILDALLPLAN' for invocant of type 'Perl6::Metamodel::NativeHOW'␤  in block <unit> at <tmp> line 1␤␤»

[22:03] <dalek> roast: 2240859 | (Zoffix Znet)++ | S32-num/int.t:

[22:03] <dalek> roast: [coverage] Cover parts of Int.pm

[22:03] <dalek> roast: review: https://github.com/perl6/roast/commit/22408595d6

[22:03] <Zoffix> Int.pm has a nest of bugs :) (not all related to Ints)

[22:05] <Zoffix> Though some can be avoided by removing type constraints on subs.

[22:06] <Zoffix> I think someone mentioned they make things slower unless they're Nil? Maybe they should be removed from things we "know" always return the right thing, like ** and * on native ints.

[22:07] <AlexDaniel> 🌬

[22:08] <Zoffix> m: '🌬'.uniname.say

[22:08] <camelia> rakudo-moar 62d838: OUTPUT«WIND BLOWING FACE␤»

[22:08] <jnthn> Whatever you do, don't remove them on things that "returns int" otherwies you'll mess up static inlining of native operators

[22:08] <jnthn> (same for "returns num")

[22:08] <Zoffix> noted :)

[22:08] <jnthn> int.new makes on sense, you can't make an instance of a native type...it should blow up more helpfully though :)

[22:09] <jnthn> *no sense

[22:11] * jnthn should get some rest...'night o/

[22:12] <Zoffix> night

[22:26] * lizmat just tried to point out you can do:

[22:26] <lizmat> $out.put($_) for $file.IO.lines.grep( *.starts-with('>').head($n);

[22:26] <lizmat> in http://blogs.perl.org/users/ken_youens-clark/2016/10/yet-another-fasta-something.html

[22:27] <lizmat> but the site doesn't seem to like me anymore, as it is refusing me from logging in :-(

[22:27] * lizmat gives up

[22:35] <dalek> rakudo/nom: 338a70a | lizmat++ | src/core/CompUnit/Repository/FileSystem.pm:

[22:35] <dalek> rakudo/nom: Only allow directories that are valid identifiers

[22:35] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/338a70a236

[22:36] <lizmat> and on that note: good night, #perl6-dev!

[22:37] <Zoffix> night

[23:13] <travis-ci> Rakudo build failed. Zoffix Znet 'Throw on overflow in infix:<*>(int, int)

[23:13] <travis-ci> https://travis-ci.org/rakudo/rakudo/builds/165373282 https://github.com/rakudo/rakudo/compare/62d8382fa89a...8023dfbc6ff1

[23:13] <buggable> [travis build above] ☠ Did not recognize some failures. Check results manually

[23:57] <travis-ci> Rakudo build passed. Elizabeth Mattijsen 'Only allow directories that are valid identifiers'

[23:57] <travis-ci> https://travis-ci.org/rakudo/rakudo/builds/165380944 https://github.com/rakudo/rakudo/compare/8023dfbc6ff1...338a70a236a3
