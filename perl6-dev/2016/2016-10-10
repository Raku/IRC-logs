[00:32] <MasterDuke> Zoffix: nqp::dd()++

[00:58] <MasterDuke> m: say Hash.^attributes[0].perl

[00:58] <camelia> rakudo-moar 13f479: OUTPUT«No such method 'perl' for invocant of type 'BOOTSTRAPATTR'␤  in block <unit> at <tmp> line 1␤␤»

[00:58] <MasterDuke> m: say Hash.^attributes[1].perl

[00:58] <camelia> rakudo-moar 13f479: OUTPUT«Attribute.new␤»

[00:59] <MasterDuke> what would be a good value for the .perl of a BOOTSTRAPATTR?

[01:02] <timotimo> we don't necessarily want to give bootstrapattr new methods

[01:02] <timotimo> m: say Hash.^attributes>>.name

[01:02] <camelia> rakudo-moar 13f479: OUTPUT«($!descriptor $!storage)␤»

[01:02] <timotimo> and you can always get that ^

[01:02] <MasterDuke> why not?

[01:03] <timotimo> not really sure; i believe we had this discussion before (also, before #perl6-dev came to be)

[01:04] <MasterDuke> i'm looking at RT #77070

[01:04] <synopsebot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=77070

[01:05] <MasterDuke> i've added a perl() and gist() locally, pretty sure it didn't break any spectests

[01:05] <timotimo> wow, that original one is from 2010 :)

[01:07] <MasterDuke> yeah, behavior changed a couple different times

[01:08] <MasterDuke> but it does seem LTA that you can .gist/.perl some attributes, but not all

[01:09] <MasterDuke> m: .perl.say for Hash.^attributes.reverse

[01:09] <camelia> rakudo-moar 13f479: OUTPUT«Attribute.new␤No such method 'perl' for invocant of type 'BOOTSTRAPATTR'␤  in block <unit> at <tmp> line 1␤␤»

[01:10] <timotimo> ideally, bootstrapattr would be derived from Any, but bootstrapping issues prevent that

[01:11] <timotimo> you can not only not .gist or .perl BootstrapAttr, you can also not .Str, .say, .print, .note, .elems, .Int, .Bool, ... them

[01:12] <Zoffix> m: multi foo (Int $x, int $y) {say "Int + native" }; foo  2, 2;

[01:12] <camelia> rakudo-moar 13f479: OUTPUT«Cannot resolve caller foo(Int, Int); none of these signatures match:␤    (Int $x, int $y)␤  in block <unit> at <tmp> line 1␤␤»

[01:12] <Zoffix> m: sub foo (Int $x, int $y) {say "Int + native" }; foo  2, 2;

[01:12] <camelia> rakudo-moar 13f479: OUTPUT«Int + native␤»

[01:13] <Zoffix> I wrote down the rules for how multies with natives will be figured out. https://gist.github.com/zoffixznet/4a63358a87d7c28bbd129782730c6486

[01:13] <timotimo> anyway, i'm now going to bed

[01:14] <Zoffix> This is needed to fix RT#128655 in Routine.analyze_dispatch that messes things up during optimization, but it looks like just regular multi dispatch is LTA too, so I'll try to fix that too

[01:14] <synopsebot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=128655

[01:20] <MasterDuke> .tell jnthn do you have any thoughts on adding missing methods to BOOTSTRAPATTR? https://irclog.perlgeek.de/perl6-dev/2016-10-10#i_13368379 for reference

[01:20] <yoleaux2> MasterDuke: I'll pass your message to jnthn.

[01:29] <Zoffix> m: say :⒗<a>

[01:29] <camelia> rakudo-moar 13f479: OUTPUT«===SORRY!===␤Argument to "say" seems to be malformed␤at <tmp>:1␤------> say⏏ :⒗<a>␤Confused␤at <tmp>:1␤------> say :⏏⒗<a>␤    expecting any of:␤        colon pair␤Other potential difficulties:␤    Unsupported…»

[01:31] <MasterDuke> https://rt.perl.org/Ticket/Display.html?id=129319

[01:59] <dalek> rakudo/nom: 2d3ff66 | (Zoffix Znet)++ | src/core/Exception.pm:

[01:59] <dalek> rakudo/nom: Stringify objects in Exceptions::JSON

[01:59] <dalek> rakudo/nom:

[01:59] <dalek> rakudo/nom: Some exceptions (like X::CompUnit::UnsatisfiedDependency) have attributes

[01:59] <dalek> rakudo/nom: with objects and not just strings. When we give that to the JSON encoder,

[01:59] <dalek> rakudo/nom: it chokes when trying to serialize those objects.

[01:59] <dalek> rakudo/nom:

[01:59] <dalek> rakudo/nom: Change those to Str, to avoid the issue.

[01:59] <dalek> rakudo/nom:

[01:59] <dalek> rakudo/nom: Fixes RT#129810: https://rt.perl.org/Public/Bug/Display.html?id=129810

[01:59] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/2d3ff665f9

[01:59] <synopsebot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=129810

[02:01] <Zoffix> hmmm

[02:11] <Zoffix> dafuq

[02:11] <Zoffix> m: say now.Date, Date.today

[02:11] <camelia> rakudo-moar 2d3ff6: OUTPUT«2016-10-102016-10-10␤»

[02:12] <Zoffix> Gives me 2016-10-102016-10-09 in a local build :/

[02:13] <geekosaur> timezone fun?

[02:13] <Zoffix> prolly

[02:18] <Zoffix> Yup

[02:18] <Zoffix> Date.today uses local TZ and now uses UTC

[02:22] <dalek> roast: 8a2147f | (Zoffix Znet)++ | S32-temporal/DateTime-Instant-Duration.t:

[02:22] <dalek> roast: Fix broken coverage test

[02:22] <dalek> roast:

[02:22] <dalek> roast: The test incorrectly assumes Date.today uses the same timezone as

[02:22] <dalek> roast: `now`. However, `now` uses UTC, while `Date.today` uses system timezone,

[02:22] <dalek> roast: leading to this test breaking when the difference in timezones causes

[02:22] <dalek> roast: days to be different.

[02:22] <dalek> roast: review: https://github.com/perl6/roast/commit/8a2147fbc9

[02:23] <dalek> rakudo/nom: e39229d | (Zoffix Znet)++ | t/spectest.data:

[02:23] <dalek> rakudo/nom: Add S04-exceptions/exceptions-json.t to list of tests to run

[02:23] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/e39229dc28

[02:26] <dalek> rakudo/nom: c57a26e | (Zoffix Znet)++ | src/core/Exception.pm:

[02:26] <dalek> rakudo/nom: Do not stringify values that JSON can handle

[02:26] <dalek> rakudo/nom:

[02:26] <dalek> rakudo/nom: Preserve null, boolean, and numerics, since those can be represented

[02:26] <dalek> rakudo/nom: in JSON. Stringify all else.

[02:27] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/c57a26e6d7

[02:37] <Zoffix> m:  %*ENV<RAKUDO_EXCEPTIONS_HANDLER>="JSON"; "dasdsad".EVAL

[02:37] <camelia> rakudo-moar c57a26: OUTPUT«Unhandled exception: This representation (P6int) cannot unbox to a native string (for type BOOTInt)␤   at gen/moar/m-CORE.setting:17361  (/home/camelia/rakudo-m-inst-2/share/perl6/runtime/CORE.setting.moarvm:)␤ from gen/moar/m-CORE.setting:17356  (/hom…»

[02:37] <Zoffix> tsk tsk. I suck.

[02:40] <dalek> rakudo/nom: 565b528 | (Zoffix Znet)++ | src/core/Exception.pm:

[02:40] <dalek> rakudo/nom: Do not crash when handling exceptions with no `message` method

[02:40] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/565b528da2

[02:57] <dalek> roast: ff86ab8 | (Zoffix Znet)++ | S04-exceptions/exceptions-json.t:

[02:57] <dalek> roast: Test Exceptions::JSON can handle exceptions with no `message`

[02:57] <dalek> roast: review: https://github.com/perl6/roast/commit/ff86ab88e9

[02:57] <Zoffix> >_<

[03:02] <dalek> rakudo/nom: 3b5ef07 | (Zoffix Znet)++ | src/core/Exception.pm:

[03:02] <dalek> rakudo/nom: Fix stringification with Exceptions::JSON

[03:02] <dalek> rakudo/nom:

[03:02] <dalek> rakudo/nom: Old method still crashed on certain exceptions. Watch for things

[03:02] <dalek> rakudo/nom: Rakudo::Internals.to-json can handle and pass them as is, the

[03:02] <dalek> rakudo/nom: rest, stringify.

[03:02] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/3b5ef07cee

[03:02] <dalek> roast: 412539a | (Zoffix Znet)++ | S04-exceptions/exceptions-json.t:

[03:02] <dalek> roast: Add more Exceptions::JSON tests

[03:02] <dalek> roast: review: https://github.com/perl6/roast/commit/412539ab80

[03:06] <Zoffix> Oh.. how did I get this distracted. I was going through commits and new tickets to prep for release next week :P

[03:43] <Zoffix> MasterDuke, so the https://rt.perl.org/Ticket/Display.html?id=129319 can be closed? I recall there was some sort of conversation with TimToady that it wasn't worth it trying to detect such usages to give better errors.

[03:52] <Zoffix> This being a revert for it, it seems https://github.com/rakudo/rakudo/commit/3182d897ecf32b62328a9d48220649efdcc31c9b

[04:18] <Zoffix> NeuralAnomaly, stats

[04:18] <NeuralAnomaly> Zoffix, [✔] Next release will be in 5 days. Since last release, there are 39 new still-open tickets (0 unreviewed and 0 blockers) and 0 unreviewed commits. See http://perl6.fail/release/stats for details

[04:18] <Zoffix> \o/

[04:18] <dalek> rakudo/nom: d034599 | (Zoffix Znet)++ | docs/ChangeLog:

[04:18] <dalek> rakudo/nom: Add all changes to date

[04:18] <dalek> rakudo/nom:

[04:18] <dalek> rakudo/nom: Documents commits:

[04:18] <dalek> rakudo/nom: c4fd9f5 8fb9ec9 dad57b0 9b6f2eb c78f5dc 08ead04 7e35062 4b1864b 96df2d7

[04:19] <dalek> rakudo/nom: 77a2ff1 3789a07 e9409cc fef3655 4bcd7e0 553cedb e12ebb9 b3c92ba 539a7d1

[04:19] <dalek> rakudo/nom: 3623490 b4a4b60 e4e8238 8f2279b 9dcde75 3448c71 c2455ca 04f4b76 3d2a919

[04:19] <dalek> rakudo/nom: 3aa7254 ca93ac9 6ef4cdf ff12748 2cad3d2 f6524e6 5f91031 2673ca8 84b7ebd

[04:19] <dalek> rakudo/nom: 28bf874 2dd6230 b77d2b7 4abc28c 6aab641 6c07321 1e6c465 2a2f26c 7a33c2c

[04:19] <dalek> rakudo/nom: 7a50c30 f72cc62 798c2e2 8f14219 2d3ff66

[04:19] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/d034599b53

[04:20] <Zoffix> 🎺🎺🎺🎺🎺🎺🎺🎺🎺🎺🎺🎺🎺🎺🎺🎺🎺🎺🎺🎺🎺🎺🎺🎺🎺🎺🎺🎺🎺🎺🎺🎺🎺🎺🎺🎺

[04:20] <Zoffix> REMINDER: Rakudo 2016.10 will be released next Saturday (Oct. 15). Please review the Changelog, to ensure your work has been correctly entered.

[04:20] <Zoffix> 🎺🎺🎺🎺🎺🎺🎺🎺🎺🎺🎺🎺🎺🎺🎺🎺🎺🎺🎺🎺🎺🎺🎺🎺🎺🎺🎺🎺🎺🎺🎺🎺🎺🎺🎺🎺

[04:21] <Zoffix> psch, bartolin I added JVM stuff as "Many fixes and additions improving JVM backend support". If you feel more detailed log is needed, please add it.

[06:12] <[Tux]> This is Rakudo version 2016.09-158-gd034599 built on MoarVM version 2016.09-39-g688796b

[06:12] <[Tux]> csv-ip5xs        3.252

[06:12] <[Tux]> test            17.304

[06:12] <[Tux]> test-t           7.908

[06:12] <[Tux]> csv-parser      18.530

[06:16] <[Tux]> This is Rakudo version 2016.09-158-gd034599 built on MoarVM version 2016.09-39-g688796b

[06:16] <[Tux]> csv-ip5xs        3.481

[06:16] <[Tux]> test            17.581

[06:16] <[Tux]> test-t           7.441

[06:16] <[Tux]> csv-parser      19.776

[06:16] <[Tux]> as I thought 7.9 to be too high

[06:16] <[Tux]> just ran it another two times

[06:34] <[Tux]> And after restarting some very memory-eager windows

[06:34] <[Tux]> This is Rakudo version 2016.09-158-gd034599 built on MoarVM version 2016.09-39-g688796b

[06:34] <[Tux]> csv-ip5xs        3.439

[06:34] <[Tux]> test            16.893

[06:34] <[Tux]> test-t           7.090

[06:34] <[Tux]> csv-parser      17.944

[06:35] <[Tux]> which is kinda interesting: IP5 is less influenced than pure-perl6

[06:41] <[Tux]> Zoffix++

[10:47] <RabidGravy> FROGGS++ nice one on fixing the native call for the RPi

[11:10] <lizmat> Files=1146, Tests=53276, 213 wallclock secs (12.97 usr  4.13 sys + 1306.76 cusr 122.25 csys = 1446.11 CPU)

[11:11] <lizmat> loks like a few % less then yesterday

[11:11] <lizmat> *looks

[11:11] <lizmat> :-)

[11:12] <lizmat> [Tux]: pure perl 6 needs more memory, most likely, and thus is more affected by other applications that use memory?

[11:13] <|Tux|> sounds legit

[12:06] <psch> r: my \x := gather do for ^3 { .take; LAST { .say } }; say +(x)

[12:06] <camelia> rakudo-jvm 2a1605, rakudo-moar d03459: OUTPUT«2␤2␤3␤»

[12:06] <psch> all of that gather/phasers/CX stuff feels really weirdly broken?

[12:06] <psch> m: my \x := gather do for ^3 { .take; LAST { .say }; last }; say +(x)

[12:06] <camelia> rakudo-moar d03459: OUTPUT«0␤1␤»

[12:07] <psch> explicit &last only fires the phasers once, but a phaser without a &last call fires twice..?

[12:09] <DrForr> [Tux]: Where can I find the latest benchmarks?

[13:16] <cygx> o/

[13:17] <Zoffix> \o

[13:26] <cygx> jnthn: not sure if you've seen it, but as a result of yesterday's discussion with cowens, I wrote up another one of my Possibly Bad Ideas, cf https://gist.github.com/cygx/b545c206a0f7ccc6d796ba4b26afccf6

[13:29] <jnthn> Feels odd that strict would die on completely valid utf-8 that just happens to not be in NFC. And warning on input that ain't NFC is noisy too.

[13:29] <yoleaux2> 01:20Z <MasterDuke> jnthn: do you have any thoughts on adding missing methods to BOOTSTRAPATTR? https://irclog.perlgeek.de/perl6-dev/2016-10-10#i_13368379 for reference

[13:29] <jnthn> I'm not sure sticking the burden on every encoding is a good way to go

[13:29] <cowens> I think I like that, but the big question (and the unresolved one from S15) is what to do when these different string types mix via operators

[13:29] <cygx> jnthn: it would not warn on denormal input, just input that

[13:30] <jnthn> If the user wants to work with codepoints instead of graphemes they should declare that.

[13:30] <cygx> ... is invalid accordint to a strict UTF-8 decoder

[13:30] <dalek> rakudo/js: 3cc214b | (Pawel Murias)++ | src/vm/js/ (2 files):

[13:30] <dalek> rakudo/js: [js] Implement nqp::p6bindassert.

[13:30] <dalek> rakudo/js: review: https://github.com/rakudo/rakudo/commit/3cc214bd34

[13:30] <dalek> rakudo/js: 9bbab73 | (Pawel Murias)++ | src/core/Failure.pm:

[13:30] <dalek> rakudo/js: Update JVM workaround to take into account there is an other backend besides moar and jvm.

[13:30] <dalek> rakudo/js: review: https://github.com/rakudo/rakudo/commit/9bbab73330

[13:30] <dalek> rakudo/nom: 6283124 | lizmat++ | src/core/Str.pm:

[13:30] <dalek> rakudo/nom: Scrape off about 3% off Str.match

[13:30] <dalek> rakudo/nom:

[13:30] <dalek> rakudo/nom: It's not a lot, but Str.match appears high in basically all profiles

[13:30] <dalek> rakudo/nom: that have any regexen in them

[13:30] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/62831240fe

[13:30] <jnthn> Ah, that meaning :)

[13:30] <cygx> eg we would warn for CESU-8 and modified UTF-8

[13:32] <dalek> nqp: 88892b0 | (Pawel Murias)++ | src/vm/js/Operations.nqp:

[13:32] <dalek> nqp: [js] Make unbox_s decont it's argument.

[13:32] <dalek> nqp: review: https://github.com/perl6/nqp/commit/88892b0987

[13:32] <dalek> nqp: 8a74d75 | (Pawel Murias)++ | t/nqp/067-container.t:

[13:32] <dalek> nqp: Test that nqp::unbox_s works on containers.

[13:32] <dalek> nqp: review: https://github.com/perl6/nqp/commit/8a74d75d03

[13:37] <travis-ci> NQP build failed. Pawel Murias 'Test that nqp::unbox_s works on containers.'

[13:37] <travis-ci> https://travis-ci.org/perl6/nqp/builds/166427877 https://github.com/perl6/nqp/compare/af751d39ee99...8a74d75d03c2

[13:40] <cygx> I've been working on a toy model of the decoder, https://github.com/cygx/p6-newio/blob/master/decoder.p6

[13:40] <cygx> I'll have to do some thinking how to incorporate the new proposal...

[13:45] <jnthn> Well, in reality for the most common decodings we'll just want to use the existing VM-backed decoders for speed.

[13:47] <jnthn> Though I guess this is more prototyping/API exploration?

[13:47] <cygx> yes

[13:48] <cygx> I've some vague ideas on how I want it to look, I'm trying to figure out if that's feasible

[13:48] <jnthn> *nod*

[13:52] <cygx> turns out my idea about having streams where you can freely intermix reading bytes, codes and graphs would work out, with a 2 slight caveats:

[13:53] <cygx> 1. reading a fixed number of graphs is sub-optimal (it will decode more codes than necessary and needs to count graphemes in a separate step)

[13:54] <cygx> 2. ...

[13:54] <cygx> ah, I remember: line separators with ambiguous representation would be problematic

[13:56] <cygx> cf https://github.com/cygx/p6-newio/blob/c4dcc24/Encoding.pm#L46

[14:00] <dalek> rakudo/nom: 831f437 | MasterDuke17++ | src/Perl6/Grammar.nqp:

[14:00] <dalek> rakudo/nom: Simplify rad_number token a bit

[14:00] <dalek> rakudo/nom:

[14:00] <dalek> rakudo/nom: Pull out some copied code into their own tokens.

[14:00] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/831f437fbe

[14:00] <dalek> rakudo/nom: 6531ef7 | lizmat++ | src/Perl6/Grammar.nqp:

[14:00] <dalek> rakudo/nom: Merge pull request #900 from MasterDuke17/rad_number_cleanup

[14:00] <dalek> rakudo/nom:

[14:00] <dalek> rakudo/nom: Simplify rad_number token a bit

[14:00] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/6531ef7f55

[14:01] <lizmat> jnthn: is method !cursor_more  in nqp/src/QRegex/Cursor.nqp only intended for external usage, or also internal?

[14:01] <lizmat> looks like it's only external, but maybe I'm not looking well enough ?

[14:02] <jnthn> Well, on 1, by definition you need to read one more code in order to know whether you've reached a grapheme boundary.

[14:04] <jnthn> lizmat: iirc it's only used by things implementing :g and similar

[14:04] <jnthn> lizmat: Pretty sure it's never called by code-gen

[14:04] <lizmat> ok, so I could change the interface if need be ?

[14:04] <jnthn> I'd think so

[14:04] <lizmat> oki

[14:04] <jnthn> I guess NQP has code that calls it too

[14:04] <jnthn> In it's subst impl

[14:06] <cygx> jnthn: to clarify, as it stands now, it would decode all available codes and would need to re-calculate boundaries the next time you request more graphemes

[14:07] <jnthn> "all available"?

[14:08] <jnthn> And I guess you mean all available bytes into codes?

[14:08] <cygx> yes

[14:09] <jnthn> Note that problem 2 goes away if handles function at a particular level (you can mandate, for example, that the separators are unambiguous if the normalization mode is Uni; in all other cases you know how to interpret them)

[14:10] * cygx is afk for a bit

[14:10] <jnthn> (where Uni means "leave it just as it is")

[14:26] <MasterDuke> is there any reason the :package isn't Stash here? https://github.com/rakudo/rakudo/blob/nom/src/Perl6/Metamodel/BOOTSTRAP.nqp#L2817

[14:36] <jnthn> MasterDuke: No, that looks like a thinko

[14:37] <MasterDuke> i thoughto

[14:51] <Zoffix> MasterDuke, [23:44:16] <Zoffix> MasterDuke, so the https://rt.perl.org/Ticket/Display.html?id=129319 can be closed? I recall there was some sort of conversation with TimToady that it wasn't worth it trying to detect such usages to give better errors.

[14:53] <MasterDuke> right, i was just looking for the last conversation i with TimToady about it to add as a comment before i close

[14:55] <MasterDuke> close as reject i assume?

[14:56] <Zoffix> Yeah

[14:59] <MasterDuke> done

[15:02] <Zoffix> Thanks.

[15:12] <dalek> rakudo/nom: a15fe9c | lizmat++ | src/core/Cursor.pm:

[15:12] <dalek> rakudo/nom: Port !cursor_more and !cursor_next from nqp

[15:12] <dalek> rakudo/nom:

[15:12] <dalek> rakudo/nom: Wanted to change the interface to !cursor_more specifically in nqp

[15:12] <dalek> rakudo/nom: so that it wouldn't need to take a hash and do lookups.  Especially

[15:12] <dalek> rakudo/nom: since it only checked for <ex> to call !cursor_next and <ov> to see

[15:12] <dalek> rakudo/nom: whether an overlap needed to be handled.  The new Cursor.CURSOR_MORE

[15:12] <dalek> rakudo/nom: now only checks for overlap: it is expected that the new .CURSOR_NEXT

[15:12] <dalek> rakudo/nom: is called directly if exhaustive is set.

[15:12] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/a15fe9c895

[15:12] <dalek> rakudo/nom: 92c0921 | lizmat++ | src/core/Str.pm:

[15:12] <dalek> rakudo/nom: Use the new .CURSOR_MORE/CURSOR_NEXT in Str.match

[15:12] <lizmat> This seems to improve "foofoofoofoofoo".match(/foo/,:g) with 10% .

[15:12] <lizmat> Again, not a lot but in a very hot path generally.

[15:13] <lizmat> review: https://github.com/rakudo/rakudo/commit/92c0921d948583dad95f

[15:13] <lizmat> afk&

[15:23] <|Tux|> DrForr, http://tux.nl/Talks/CSV6/speed4.html - sorry for the delay

[15:24] <|Tux|> top frame has a link to the timing log

[15:29] * pmurias checks out travis failure

[15:30] <dalek> nqp: 16e2df7 | (Pawel Murias)++ | src/vm/js/nqp-runtime/ (2 files):

[15:30] <dalek> nqp: [js] Start evaling more specialized accessors to speed things up a bit.

[15:30] <dalek> nqp: review: https://github.com/perl6/nqp/commit/16e2df7010

[15:30] <dalek> nqp: 875d088 | (Pawel Murias)++ | t/nqp/067-container.t:

[15:30] <dalek> nqp: Fix test count.

[15:30] <dalek> nqp: review: https://github.com/perl6/nqp/commit/875d0888ab

[15:34] <travis-ci> NQP build passed. Pawel Murias 'Fix test count.'

[15:34] <travis-ci> https://travis-ci.org/perl6/nqp/builds/166461998 https://github.com/perl6/nqp/compare/8a74d75d03c2...875d0888ab0f

[15:47] <cygx> jnthn: the problems I mentioned are specific to the modeless design because I want to keep zero-cost for the lower levels as well as manageable complexity

[15:48] <cygx> what I envision are line separators defined in terms of bytes (it's not implemented in the toy model nor in my API mockup)

[15:49] <cygx> so any of lines(:bin), .lines(:uni) and lines can reuse the same implementation without overhead

[15:49] <pmurias> jnthn: accessing/binding native attributes does no autovivication and other sideeffects (besides storing the native value if binding)

[15:50] <cygx> jnthn: I'll keep experimenting, and will give an update once I get to more conclusive results...

[15:51] <cygx> (assuming you do not want to tackle the issue yourself Right Now)

[15:54] <jnthn> pmurias: Correct (if you were looking for confimration? :))

[15:54] <pmurias> yes, forgot the ?

[15:57] <pmurias> I want to compile them to 'foo.attr$7' instead of foo.$$getattr$7() and foo.$$bindattr$7(value)

[16:08] <cygx> jnthn: could you update the comment at the top of MoarVM's src/6model/reprs/MVMString.h if it is indeed out of date?

[16:08] <cygx> I'm assuming that at the very least, the someday-NFG buffer nowadays is NFG

[16:08] <jnthn> cygx: Will take a look soon; bit tied up with $dayjob-task for the next 10-15 mins

[16:10] <cygx> no worries, it can wait

[16:11] <cygx> it's just that the comment was apparently written pre-NFG and also references things that are supposded to happen 'later'

[16:21] <dalek> rakudo/nom: e250a84 | MasterDuke17++ | src/Perl6/Metamodel/BOOTSTRAP.nqp:

[16:21] <dalek> rakudo/nom: Correct a thinko

[16:21] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/e250a8498f

[16:21] <dalek> rakudo/nom: e8c8af6 | MasterDuke17++ | src/Perl6/Metamodel/BOOTSTRAP.nqp:

[16:21] <dalek> rakudo/nom: Convert some BOOTSTRAPATTRs to Attributes

[16:21] <dalek> rakudo/nom:

[16:21] <dalek> rakudo/nom: This is a first pass through BOOTSTRAP.nqp only changing attributes where

[16:21] <dalek> rakudo/nom: all the attributes explicitly added to a class can be converted (i.e.,

[16:21] <dalek> rakudo/nom: it may still have some BOOTSTRAPATTRs from a parent class). This allows

[16:21] <dalek> rakudo/nom: more attributes to be more easily worked with a the Perl 6 level.

[16:21] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/e8c8af60c4

[16:21] <dalek> rakudo/nom: f117a61 | (Zoffix Znet)++ | src/Perl6/Metamodel/BOOTSTRAP.nqp:

[16:25] <timotimo> i'm a bit surprised we'll have overflow detection for infix:<*>(int, int)

[16:26] <Zoffix> Why?

[16:26] <timotimo> there has been arguments against that in the past, if i remember correctly

[16:27] <Zoffix> Well, without the fix I made, it was returning 0 on overflow.

[16:27] <timotimo> mhm

[16:27] <timotimo> i hope it'll still inline everywhere

[16:32] <Zoffix> Ah. That's why :|

[16:33] <timotimo> also, our sub can now return not only an int, but also an object

[16:34] <Zoffix> Yeah, and there's a bug with it too: https://rt.perl.org/Ticket/Display.html?id=129811#ticket-history

[16:34] <Zoffix> m: sub (--> int) { Failure.new }()

[16:34] <camelia> rakudo-moar f117a6: OUTPUT«This type cannot unbox to a native integer: P6opaque, Failure␤  in sub  at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[16:34] <Zoffix> m: sub (--> int) { return Failure.new }()

[16:34] <camelia> rakudo-moar f117a6: OUTPUT«Failed␤  in block <unit> at <tmp> line 1␤␤Actually thrown at:␤  in block <unit> at <tmp> line 1␤␤»

[16:34] <timotimo> mhm

[16:39] <jnthn> infix:<*>(int, int) is not meant to upgrade to Int ever

[16:39] <jnthn> And thus may overflow

[16:39] <jnthn> Note it can only ever be called if at lesat one of the arguments is *declared* as an int

[16:39] <jnthn> (Either both must be, or one must be a sufficiently small literal)

[16:40] <Zoffix> jnthn, how is that overflow signaled

[16:40] <jnthn> It isn't

[16:40] <jnthn> int is *native*

[16:40] <jnthn> And unchecked

[16:41] <Zoffix> jnthn, so 0 is correct answer on overflow?

[16:41] <jnthn> Could easily happen, yes

[16:41] <jnthn> If you wrote the same program in C with int (or long) you could see the same kind of behavior

[16:41] <Zoffix> OK, then I'll revert my "fix" and undo another one that I stole it from.

[16:42] <jnthn> (And a bunch of other languages)

[16:43] <Zoffix> The other one is infix:<**>(int $a, int $b) https://github.com/rakudo/rakudo/blob/nom/src/core/Int.pm#L293

[16:46] <jnthn> cygx: Updated that comment; didn't spot anything else out of date in the vicinity of it

[16:50] <jnthn> cygx: On "stuff I was going to work on" - I've certainly made a start on encoding stuff, by exposing the decode stream API and using it to fix up IO::Socket::Async

[16:51] <jnthn> cygx: My plan from there was to do similar with Proc::Async

[16:51] <jnthn> cygx: Followed by dropping the char-level async I/O ops

[16:51] <jnthn> cygx: (At the VM level)

[16:52] <jnthn> Thus fixing some robustness problems and allowing the use of different encodings (the ones we already support) for Proc::Async and IO::Socket::Async

[16:53] <jnthn> Beyond that I hadn't really been planning to do other I/O refactors Really Soon because there's just so many other problems competing for my time

[16:53] <jnthn> But solving the ones I just mentioned would elimiante some of the most nasty things

[16:54] <FROGGS> o/

[16:55] <jnthn> I don't think that especially conflicts with much that you're doing

[16:55] <jnthn> I'm relatively happy with the encoder/decoder API that I proposed, but was planning to keep any code implementing that under Rakudo::Internals for the moment

[16:55] <jnthn> So we'll still have the freedom to tweak it further

[17:03] <cygx> jnthn: so not much change of unnecessary or duplicated work if we eventually do go with a more extensive refactor

[17:04] <cygx> somewhat related, grapheme boundary detection does not seem to be exposed right now

[17:04] <cygx> it might be nice to have an op for that...

[17:05] <jnthn> Well, synthetics are never meant to leak out to user-space

[17:06] <jnthn> Both codepoints -> grapheme string and vice versa are exposed.

[17:06] <jnthn> (Otherwise we shouldn't Str.Uni or Uni.Str)

[17:06] <jnthn> I guess there maybe are other uses for the op

[17:07] <cygx> well, some people (read: me ;) ) might want to do their own chunking of codepoints into grapheme clusters

[17:08] <jnthn> All the data needed to do the calculation is exposed

[17:08] <jnthn> At least, I can't think of anything that isn't

[17:08] <DrForr> |Tux|: No worries, I was just curious.

[17:08] <jnthn> If you're doing this for prototyping purposes, though, I'd just implement one or two of the rules

[17:10] <jnthn> Also note that .comb>>.NFD for example would get you a list of list of codepoints that make up each grapheme

[17:11] <jnthn> So you can piggy-back on the existing impl that way

[17:12] <jnthn> On separators, I'm a bit hesitant to try and deal with them at byte level

[17:12] <jnthn> It's possible that a given grapheme might expode to a whole range of possible codepoint forms

[17:12] <jnthn> *explode

[17:14] <jnthn> e.g. something with 3 combiners on could easily be represented in 6 differnet ways

[17:15] <cygx> .oO(or just expose should_break from normalize.c as an op)

[17:15] <cygx> I just thought that would be easier, but if you're opposed to providing that, I can deal

[17:16] <MasterDuke> jnthn: i'm now trying some of the attributes that didn't work with just s/BOOTSTRAPATTR/Attribute/. if i change Hash's Mu $!descriptor, rakudo compiles, but attempting to use moar to run even -e '' gives: X::TypeCheck::Assignment exception produced no message

[17:17] <jnthn> cygx: Well, trying to keep the number of ops from getting too huge, is all...

[17:19] <jnthn> cygx: I'm also somewhat concerned about exposing should_break because as of Unicode 9 it seems you perhaps cannot determine it just by looking at the two codepoints on either side :/

[17:20] <travis-ci> Rakudo build failed. Zoffix Znet 'Merge pull request #901 from MasterDuke17/remove_BOOTSTRAPATTR_where_possible

[17:20] <travis-ci> https://travis-ci.org/rakudo/rakudo/builds/166476243 https://github.com/rakudo/rakudo/compare/92c0921d9485...f117a61595fa

[17:20] <buggable> [travis build above] ☠ Did not recognize some failures. Check results manually

[17:21] <Zoffix> oh shit

[17:21] <Zoffix> Seems that busted JVM

[17:21] <MasterDuke> oops, my bad

[17:21] <Zoffix> :)

[17:21] <jnthn> See http://www.unicode.org/reports/tr29/#Grapheme_Cluster_Boundary_Rules for details. Note how it has rules like "That is, do not break between regional indicator (RI) symbols if there is an odd number of RI characters before the break point."

[17:22] <jnthn> But if you've just got two codepoints, you can't know if there's more than one RI before :/

[17:22] <jnthn> Despite that the note below says "Grapheme cluster boundaries can be easily tested by looking at immediately adjacent characters."

[17:23] <jnthn> Which I'd really like to believe but can't see how is true with the RI rules

[17:24] <timotimo> right :|

[17:29] <cygx> I'm not quite sure if I even understand the intention

[17:29] <cygx> the regex version just has it as Regional_Indicator+

[17:30] <cygx> but according to the abstract description, I think you'd at the very least have to remember if there's a break right before our pair of codes

[17:32] <cygx> from looking at wikipedia, the idea is apparently that regional indicators always should come in pairs

[17:38] <cygx> the simplified rules: at the beginning of a new grapheme cluster, do not break between a pair of regional indicators; otherwise, do

[17:38] <timotimo> but how do you tell if you're inside a pair of regional indicators or between two pairs?

[17:40] <timotimo> well, if you carry a little flag that tells you if you're %% 2 away from the start marker of a regional indicator perhaps? is there such a "start of RI" thing?

[17:45] <jnthn> dinner time, bbl

[17:45] <cygx> yeah, I thought that was unnecessary - but the problem with that are prepend characters...

[17:46] <timotimo> the what now?

[17:50] <cygx> Prepend: Indic_Syllabic_Category = Consonant_Preceding_Repha, or Indic_Syllabic_Category = Consonant_Prefixed, or Prepended_Concatenation_Mark = Yes

[17:51] <timotimo> i don't know anything about those :|

[17:51] <cygx> the point is, the first regional indicator always starts a new cluster unless it follows a prepend character

[17:52] <cygx> (or another regional indicator, of course)

[17:53] <timotimo> so it's really legal to have a prepend character in front of a regional indicator?

[17:53] <cygx> I don't see why it should not be

[17:54] <cygx> Prepended_Concatenation_Mark: A small class of visible format controls, which precede and then span a sequence of other characters, usually digits. These have also been known as "subtending marks", because most of them take a form which visually extends underneath the sequence of following digits.

[17:54] <timotimo> hmm

[17:54] <timotimo> and is it allowed to have combined marks on regional indicator letters, too?

[17:55] <timotimo> like a regional indicator ÄÄ

[17:55] <cygx> no, that would break between the combinator and the 2nd indicator

[17:56] <timotimo> hmm

[17:58] <cygx> you can have stuff like [prepend indicator indicator extend] and [prepend indicator indicator extend] as single clusters, but no extend between indicators

[17:58] <cygx> up... the second one should only have one indicator within

[17:58] <dalek> rakudo/worry_broken_heredoc_stopper: d184fcd | timotimo++ | src/Perl6/Grammar.nqp:

[17:58] <dalek> rakudo/worry_broken_heredoc_stopper: warn when a heredoc stopper has rubbish after it

[17:58] <dalek> rakudo/worry_broken_heredoc_stopper:

[17:58] <dalek> rakudo/worry_broken_heredoc_stopper: like accidentally included semicolon or something

[17:58] <dalek> rakudo/worry_broken_heredoc_stopper: review: https://github.com/rakudo/rakudo/commit/d184fcd2f4

[17:59] <timotimo> cygx: can i put combining marks at the end of a pair of regional indicators?

[17:59] <timotimo> like a germany flag with heavy metal umlauts on top of it?

[17:59] <cygx> yes

[18:00] <timotimo> tremendous

[18:00] <cygx> or after a single one, but it will no longer be combined with a following second indicator

[18:01] <timotimo> .u strikethrough

[18:01] <yoleaux2> U+1D7A LATIN SMALL LETTER TH WITH STRIKETHROUGH [Ll] (ᵺ)

[18:01] <timotimo> .u strike

[18:01] <yoleaux2> U+1D7A LATIN SMALL LETTER TH WITH STRIKETHROUGH [Ll] (ᵺ)

[18:01] <timotimo> ...

[18:02] <timotimo> ̸

[18:02] <timotimo> that's the one i want, though it doesn't show

[18:06] <MasterDuke> i was just thinking about the stack trace that gets generated with --ll-exception (or in the profile)

[18:06] <MasterDuke> it mentions the lines in m-CORE.settings, which is good, but then i have to open up the settings and find the line, and then if i want to change something i have to find out what file it came from

[18:06] <MasterDuke> i remember lizmat did some stuff to get better correspondence between settings and the original source file (for Zoffix's Sourcery module i think, or maybe the coverage reports)

[18:07] <timotimo> https://twitter.com/loltimo/status/785542004100988928

[18:07] <MasterDuke> how difficult would it be to get the error message to also report the original source file? the line there would be even better, but just the file would be a start

[18:11] <cygx> timotimo: lol, timo ;)

[18:12] * Zoffix already had that conversation.

[18:12] <Zoffix> My opinion is it's fine the way it is. Because returning the line of the original source file doesn't give you the actual location of anything, whereas the line in the setting file does.

[18:13] <Zoffix> Sourcery has an additional critical piece of information: the commit sha. Without it, you can't actually locate anything correctly. And that sha is obtained from $*PERL.compiler.version, and *it's actually too short*.

[18:14] <Zoffix> I doubt I'll find it now, but I did encounter a case where there were the sha was too short and there was more than one commit with it in them.

[18:14] <Zoffix> So even the Sourcery doesn't give you 100% accurate location of the source code, but the core location is 100% accurate.

[18:15] <Zoffix> s/core/CORE-setting/

[18:17] <MasterDuke> don't know what you mean by "the line of the original source file doesn't give you the actual location of anything"?

[18:18] <Zoffix> MasterDuke, what code is at src/core/Int.pm at line 142?

[18:19] <MasterDuke> "return Nil if self == 0;", but i assume you're making some sort of point, i'm just not getting it

[18:21] <Zoffix> MasterDuke, no, you're wrong. The correct answer is "when int16  { Range.new(              -32768, 32767              ) }"

[18:21] <Zoffix> MasterDuke, I can prove it: https://github.com/rakudo/rakudo/blob/ec386e5ff54a6e8028e74092d1a41cfccdc531d2/src/core/Int.pm#L142

[18:21] <Zoffix> MasterDuke, but my point was is there's no answer to that question, because it requires the third component to locate the actual code: the commit sha

[18:22] <Zoffix> So if you run your code in 2015.12, you get `when int16...` at that line, but if you run today's HEAD you get the `return Nil...`

[18:22] <MasterDuke> but that isn't that hard to get

[18:22] <Zoffix> How would you get it?

[18:22] <MasterDuke> somebody with a monthly release, we know the sha

[18:23] <MasterDuke> somebody who's building from source, they should know enough to be able to get it themselves

[18:24] <MasterDuke> and even if $*PERL.compiler.version had a conflict, i don't think there are so many we couldn't easily figure out which one was correct

[18:24] <Zoffix> And that's my argument against: the current system gives you exact location you can look at immediately. Your proposal has "they should know enough" in it.

[18:25] <Zoffix> And the current system can be used by a machine. Yours isn't accurate enough to do so.

[18:25] <MasterDuke> well, i did say just giving the file would be good

[18:26] <Zoffix> A simple wrapper script around perl 6 executable can figure out the right location.

[18:26] <Zoffix> I think I even mentioned something like that in sourcery article

[18:26] <MasterDuke> and no reason we couldn't continue to give the CORE line # also

[18:26] <Zoffix> http://perl6.party/post/Perl-6-Core-Hacking-Wheres-Da-Sauce-Boss#doitforme

[18:27] <Zoffix> I dunno. To me, this is a case of merging development tools useful for development of the compiler only together with our final product.

[18:28] <Zoffix> m: sub foo {}; dd &foo.line # like this logic would have to watch for whether the thing is a core location or not, for example.

[18:28] <camelia> rakudo-moar f117a6: OUTPUT«1␤»

[18:29] <Zoffix> And, yes, I realize we have RAKUDO_MODULE_DEBUG and RAKUDO_OPTIMIZER_DEBUG, but in those cases there aren't any simple alternatives.

[18:32] <MasterDuke> well, you could argue that descending into *any* non-user files in an error message is merging compiler development information

[18:32] <MasterDuke> (not saying it's a strong argument though)

[18:34] <MasterDuke> i mean look at this

[18:34] <MasterDuke> m: say oh no!

[18:34] <camelia> rakudo-moar f117a6: OUTPUT«===SORRY!=== Error while compiling <tmp>␤Bogus postfix␤at <tmp>:1␤------> say oh no⏏!␤    expecting any of:␤        infix␤        infix stopper␤        postfix␤        statement end␤        statement modifier␤        stat…»

[18:34] <MasterDuke> compared with the same thing and --ll-exception

[18:36] <MasterDuke> where there's a mix of original and generated source files listed

[18:37] <MasterDuke> but anyway, i'm not trying to propose a fundamental restructuring of error messages

[18:38] <MasterDuke> but something that yes, is probably of most usefulness to a developer working on Perl 6 itself

[18:38] <MasterDuke> maybe a rakudo environment variable?

[18:41] <Zoffix> Right, but why can't it be a dozen-line wrapper script and we have exactly zero performance impact on production code and much smaller maintenance burden?

[18:41] <Zoffix> Personally, I don't think I'd find that addition useful. I do use sourcery bot to find where to look for, but can't say I'm dying to have exceptions give me locations of actual code, TBH.

[18:43] <MasterDuke> ok, how about adding the wrapper script to the repo? doesn't have to be made available in os packages

[18:44] <Zoffix> I'm perfectly fine with that.

[18:45] <MasterDuke> (and i'm not just making up use cases, i do actually do run something, get a CORE line, open up CORE, page up until i find what original file very frequently

[18:45] <MasterDuke> )

[18:46] <MasterDuke> but hey, maybe there's a simpler way to improve my workflow

[18:48] <MasterDuke> and not just errors, i do it a lot when looking at profiles

[18:49] <MasterDuke> pull-one (gen/moar/m-CORE.settings:###)

[18:50] <MasterDuke> there are a lot of pull-one's (just as an example), i have to go look to see exactly which one it is

[19:21] <lizmat> MasterDuke: pull-one is the workhorse of any iterator

[20:04] <MasterDuke> lizmat: i just meant that there are a lot of them, so i don't know exactly which source file to look in. a counter-example is something like chomp, i have a much better chance of guessing that correctly

[20:10] <lizmat> m: say "abcdefg".match(/./,:2nd)   # works as expected

[20:10] <camelia> rakudo-moar f117a6: OUTPUT«｢b｣␤»

[20:10] <lizmat> m: say "abcdefg".match(/./,:3x)   # works as expected

[20:10] <camelia> rakudo-moar f117a6: OUTPUT«(｢a｣ ｢b｣ ｢c｣)␤»

[20:10] <lizmat> m: say "abcdefg".match(/./,:2nd, :3x)   # expected b d e

[20:10] <camelia> rakudo-moar f117a6: OUTPUT«()␤»

[20:11] <lizmat> is this a bug?  ^^^

[20:13] <Zoffix> I would think :2nd and :3x are mutually exclusive.

[20:13] <jnthn> m: say "ab".match(/./,:3x)

[20:13] <camelia> rakudo-moar f117a6: OUTPUT«()␤»

[20:13] <jnthn> So :3x appears to mean "only return if you can match 3 times"

[20:14] <jnthn> m: say "abcdefg".match(/./,:2nd, :1x)

[20:14] <camelia> rakudo-moar f117a6: OUTPUT«(｢b｣)␤»

[20:14] <Zoffix> m: say "1234567890".match(/./,:3x)

[20:14] <camelia> rakudo-moar f117a6: OUTPUT«(｢1｣ ｢2｣ ｢3｣)␤»

[20:14] <jnthn> Seems consistent at least :)

[20:15] <lizmat> jnthn Zoffix: suppose we want the second match but 3 x (aka match 2, 4,6 )

[20:15] <jnthn> That's not the 2nd match, that's every 2nd match

[20:15] <lizmat> m: say "abcdefg".match(/./,:2nd, :g)

[20:15] <camelia> rakudo-moar f117a6: OUTPUT«｢b｣␤»

[20:15] <jnthn> m: say "1234567890".match(/./,:x(1, 3, ... *))

[20:15] <camelia> rakudo-moar f117a6: OUTPUT«Potential difficulties:␤    Comma found before apparent sequence operator; please remove comma (or put parens around the ... call, or use 'fail' instead of ...)␤    at <tmp>:1␤    ------> say "1234567890".match(/./,:x(1, 3,⏏ ... *))␤*␤  …»

[20:16] <jnthn> m: say "1234567890".match(/./,:x(1, 3 ... *))

[20:16] <camelia> rakudo-moar f117a6: OUTPUT«in Str.match, got invalid value of type Seq for :x, must be Int or Range␤  in block <unit> at <tmp> line 1␤␤Actually thrown at:␤  in block <unit> at <tmp> line 1␤␤»

[20:16] <jnthn> Hm, I thought you could do something like that :)

[20:16] <lizmat> jnthn: yeah, I guess I could do something like that

[20:16] <jnthn> oh wait

[20:16] <jnthn> I did it wrong

[20:16] <lizmat> I'm overhauling Str.match completely atm

[20:16] <jnthn> m: say "1234567890".match(/./,:nd(1, 3 ... *))

[20:16] <camelia> rakudo-moar f117a6: OUTPUT«｢1｣␤»

[20:16] <Zoffix> m: say "1234567890".match(/./,:nd(1, 3 ... *), :g)

[20:16] <camelia> rakudo-moar f117a6: OUTPUT«｢1｣␤»

[20:17] <Zoffix> ¯\_(ツ)_/¯

[20:17] <jnthn> m: say "1234567890".match(/./,:nd(1, 3, 5))

[20:17] <camelia> rakudo-moar f117a6: OUTPUT«(｢1｣ ｢3｣ ｢5｣)␤»

[20:17] <jnthn> m: say "1234567890".match(/./,:nd(eager 1, 3 ... *))

[20:17] <jnthn> oh heh ;)

[20:17] <Zoffix> :D

[20:17] <Zoffix> m: say "1234567890".match(/./,:nd(eager 1, 3 ... * > 10))

[20:17] <camelia> rakudo-moar f117a6: OUTPUT«(timeout)»

[20:17] <camelia> rakudo-moar f117a6: OUTPUT«()␤»

[20:18] <lizmat> m: m: say "1234567890".match(/./,:st(1, 3, 5))

[20:18] <camelia> rakudo-moar f117a6: OUTPUT«(｢1｣ ｢3｣ ｢5｣)␤»

[20:18] <jnthn> m: say "1234567890".match(/./,:nd(list 1, 3 ... *))

[20:18] <camelia> rakudo-moar f117a6: OUTPUT«｢1｣␤»

[20:18] <jnthn> Curious

[20:18] <lizmat> well, fwiw, I can fix that probably

[20:18] <jnthn> m: say "1234567890".match(/./,:nd(list(1, 3 ... *)))

[20:18] <camelia> rakudo-moar f117a6: OUTPUT«｢1｣␤»

[20:18] <jnthn> Anyway, I think :3x, :2nd not working is reasonable

[20:19] <jnthn> But if :nd(1,3,5) works then it's bothersome that :nd(1, 3 ... 7) doesn't

[20:19] <jnthn> m: say "1234567890".match(/./,:nd(list 1, 3 ... 7))

[20:19] <camelia> rakudo-moar f117a6: OUTPUT«｢1｣␤»

[20:19] <lizmat> yeah, ok, noted

[20:19] <jnthn> m: say "1234567890".match(/./,:nd(list 1, 3, 5, 7))

[20:19] <camelia> rakudo-moar f117a6: OUTPUT«(｢1｣ ｢3｣ ｢5｣ ｢7｣)␤»

[20:19] <lizmat> will look into that

[20:19] <cygx_> jnthn, timotimo: p6 implementation of the clustering algorithm, potentially buggy: https://github.com/cygx/p6-newio/blob/master/cluster.p6

[20:19] <jnthn> Yeah, that way should work, I think

[20:21] <jnthn> Hm, table is a neat way to do it

[20:21] <lizmat> jnthn: so :$x is incompatbile with :nd (and friends) and should also not silently be ignored

[20:23] <jnthn> Well, :nd(2) and :x(1) was fine...not sure if raising an error is too harsh

[20:46] <MasterDuke> still playing around with BOOTSTRAP. if i change Array's $!descriptor to an Attribute, rakudo compiles, but won't install and a bunch of things give this message: X::TypeCheck::Assignment exception produced no message

[20:46] <MasterDuke> m: my Int @a; @a[1] = "a"

[20:46] <camelia> rakudo-moar f117a6: OUTPUT«Type check failed in assignment to @a; expected Int but got Str ("a")␤  in block <unit> at <tmp> line 1␤␤»

[20:47] <MasterDuke> m: my Int @a; @a[1] = $*ERR

[20:47] <camelia> rakudo-moar f117a6: OUTPUT«Type check failed in assignment to @a; expected Int but got IO::Handle (IO::Handle.new(:path(...)␤  in block <unit> at <tmp> line 1␤␤»

[20:47] <MasterDuke> locally, the first one works fine, but for the second i get: Type check failed in assignment to @a; expected Int but got IO::Handle (?)

[20:47] <jnthn> If you make that an Attribute, it may set up some vivification on it

[20:48] <jnthn> In a case where $!descriptor is meant to be null

[20:49] <MasterDuke> it looks like that's what scalar_attr() does, but just a plain Attribute.new will also?

[20:54] <jnthn> Think so

[20:54] <jnthn> That may be one of the cases where we need BOOTSTRAPATTR

[20:55] <jnthn> Or we need to configure Attribute differently (and maybe make it support that)

[20:55] <jnthn> The important bit is what happens at repr_compose time

[20:59] <MasterDuke> in Attribute.new: my $scalar := nqp::create(Scalar); ...; nqp::bindattr($attr, Attribute, '$!auto_viv_container', $scalar);

[21:01] <jnthn> Yup

[21:01] <jnthn> That's the bit. I guess a version of scalar_attr that doesn't set $!auto_viv_container would do it.

[21:02] <MasterDuke> scalar_attr or a new Attribute.new?

[21:04] <jnthn> No, leave Attribute.new alone

[21:04] <jnthn> That's user-facing

[21:05] <jnthn> We want something internal

[21:15] <MasterDuke> oh hey, my scalar_attr2 is working so far

[21:20] <jnthn> :)

[21:21] <MasterDuke> spectest passed. now a somewhat cleaner implementation than just adding a scalar_attr2

[21:21] <jnthn> MasterDuke++

[21:26] <MasterDuke> oh, while you're here. changing to Attribute.new for Int/Num/Str all give: "This type cannot unbox to a native integer: P6opaque, Int/Num/Str"

[21:27] <MasterDuke> i haven't started looking at those yet, but any quick suggestions?

[21:29] <jnthn> Probably setting the wrong type

[21:29] <jnthn> These all have native attributes within them (or a P6bigint in the case of Int)

[21:45] <lizmat> and another Perl 6 Weekly hits the Net: https://p6weekly.wordpress.com/2016/10/10/2016-41-the-answer-is-near/

[22:07] <AlexDaniel> ah yeah, and bisectable has fully recovered from all of the problems :)

[22:08] <AlexDaniel> MasterDuke++

[22:14] <lizmat> MasterDuke++ indeed

[22:14] <lizmat> good night, #perl6-dev!

[23:05] <Zoffix> lizmat++ good weekly

[23:52] <cognominal> lizmat++
