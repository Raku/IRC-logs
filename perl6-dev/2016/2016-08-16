[00:13] <Zoffix> I'm agreeing with your thoughts ¯\_(ツ)_/¯

[00:20] <timotimo> ah

[00:21] <timotimo> maybe timtoady will bless me with a bit of his wisdom once he's finished and recovered from the flight :)

[00:29] <timotimo> super annoyed that i only now see the discussion about your blog post in /r/programming

[00:32] <Zoffix> Why annoyed?

[00:32] <timotimo> because i'm late to the party

[00:32] <Zoffix> Heh

[00:33] <timotimo> anyway, i want to get a bedtime

[00:33] <Zoffix> There weren't really a discussion. Primarily just one person spewing bullshit, trying to convince the world they're better than everyone else :)

[00:33] <timotimo> fair enough

[00:34] <timotimo> "don't you dare say gobble to MY compiler!"

[00:34] <timotimo> a programmer would NEVER write something like

[00:34] <timotimo> if (foo bar)

[00:34] <timotimo> goto fail;

[00:34] <timotimo> goto fail;

[02:20] <MasterDuke> .tell lizmat it's not pretty, but it does work. should i submit a PR, or do you want something with Mu.possible-phasers for this RT? https://gist.github.com/MasterDuke17/eb8e42371424528d6ca8d8312ad0692b

[02:20] <yoleaux2> MasterDuke: I'll pass your message to lizmat.

[02:31] <jdv79> you have to admit its an odd if not unfortunate phrasing

[08:18] <[Tux]> Drat, new failur on CSV and no time to dig

[08:19] <[Tux]> # Failed test 'Undefined in Numeric context type'

[08:19] <[Tux]> # at t/30_field.t line 12

[08:19] <[Tux]> # expected: 'Num'

[08:19] <[Tux]> #      got: 'Num|17758144'

[08:23] <[Tux]> This is Rakudo version 2016.07.1-190-g6cd6efe built on MoarVM version 2016.07-18-g2f269d8

[08:23] <[Tux]> csv-ip5xs       10.147

[08:23] <[Tux]> test            15.718

[08:23] <[Tux]> test-t           7.694

[08:23] <[Tux]> csv-parser      17.025

[08:23] * [Tux] => $work

[08:29] <arnsholt> m: say Numeric.gist; say Numeric.Str

[08:29] <camelia> rakudo-moar 6cd6ef: OUTPUT«(Numeric)␤Use of uninitialized value of type Numeric in string context.␤Methods .^name, .perl, .gist, or .say can be used to stringify it to something meaningful.  in block <unit> at <tmp> line 1␤␤»

[08:29] <arnsholt> Huh

[08:31] <arnsholt> [Tux]: Anyways, looks like the stringification logic of something changed in Rakudo. Might be https://github.com/rakudo/rakudo/commit/4d85cde90883e031650600b9f55a87e86acb632c

[10:33] <Zoffix> Holy shit. My Awesome Errors article exploded on Reddit.

[10:34] <DrForr> +$N!

[10:34] <nine> Zoffix: URI?

[10:34] <Zoffix> nine, https://www.reddit.com/r/programming/comments/4xuo1r/the_awesome_errors_of_perl_6/

[10:35] <nine> I only see 5 comments in the reddit linked on P6W

[10:35] <Zoffix> And the "Other discussions" of it posted on /r/perl6 and /r/programming

[10:35] <Zoffix> I'm not reading all those comments lol.

[10:35] <timotimo> yeah, more like shit errors!

[10:35] <timotimo> it's only 33 comments, dood

[10:36] <Zoffix> got 28 points... in /r/programming of all things

[10:36] <jnthn> Given this is reddit, it's probably an explosion of whining :P

[10:36] <Zoffix> jnthn, it is :)

[10:37] <Zoffix> The biggest thread is people trying to convince me to compile a multi-line piece of code by randomly sticking a quote into it, and tell the user where the quote should go the first time it compiles correctly.

[10:38] <tadzik> report first instance that produces valid syntax. (...) Probably less costly than the Levenshtein check

[10:38] <tadzik> found the guy that never wrote a parser :P

[10:39] <Zoffix> m: my $str = "␤BEGIN { trade-your-soul-for-a-sammich } ␤

[10:39] <camelia> rakudo-moar 6cd6ef: OUTPUT«===SORRY!=== Error while compiling <tmp>␤Unable to parse expression in double quotes; couldn't find final '"' ␤at <tmp>:3␤------> <BOL>⏏<EOL>␤»

[10:39] <Zoffix> yeah, let's insert a quote into the first line and see if stuff compiles :)

[10:40] <|Tux|> m: use Test;my Num $n;say $n.WHICH;like($n.WHICH,/^ "Num" \b/,"test")

[10:40] <camelia> rakudo-moar 6cd6ef: OUTPUT«Num|19522336␤Cannot resolve caller like(ObjAt, Regex, Str); none of these signatures match:␤    (Str $got, Regex $expected, $desc = "")␤  in block <unit> at <tmp> line 1␤␤»

[10:41] <|Tux|> m: use Test;my Num $n;say $n.WHICH;like($n.WHICH.Str,/^ "Num" \b/,"test")

[10:41] <camelia> rakudo-moar 6cd6ef: OUTPUT«Num|22270752␤not ok 1 - test␤␤# Failed test 'test'␤# at <tmp> line 1␤#      expected: '/^ "Num" \b/'␤#      got: 'Num|22270752'␤»

[10:42] <DrForr> Programming via git bisect. I guess it ahd to happen eventually :)

[10:42] <DrForr> *had

[10:42] <jnthn> A test that calls .Str on what .WHICH returns is not going to end up well... ObjAt should be treated as an opaque thing.

[10:43] <timotimo> Zoffix: better not tell people on /r/programming that compiling code can have side-effects

[10:43] <|Tux|> .Str was my first idea of how I could make this test pass

[10:43] <Zoffix> timotimo, why?

[10:43] <Zoffix> I was about to

[10:43] <timotimo> they'll totally throw a tantrum

[10:43] <Zoffix> Awesome

[10:43] * Zoffix tells

[10:43] <jnthn> |Tux|: My question is more at the level of "why does this test exist"? :)

[10:43] <timotimo> "you're telling me i can't even *compile* untrusted code i found on the internet without looking at it first?"

[10:44] <|Tux|> to test if the return of an object in + context is a Num

[10:44] <jnthn> |Tux|: Ah, then $obj ~~ Num

[10:44] <jnthn> |Tux|: Or if you don't want to allow it to be a subclass of Num, $obj.WHAT === Num

[10:45] <|Tux|> https://github.com/Tux/CSV/blob/master/t/30_field.t#L12

[10:45] <jnthn> Yeah, that test seems to be misunderstanding what .WHICH is for

[10:46] <jnthn> It's an opaque object to be used in things like object hashes and sets

[10:46] <jnthn> The most direct replacement is to just go with the type name, $n.^name

[10:46] <jnthn> But I'd advise one of the two that I suggested earlier

[10:47] <jnthn> In general, talking about types as string names in Perl 6 is pretty much always the wrong way to do it

[10:48] <|Tux|> pushed. refresh to see the change

[10:49] * |Tux| still learns every day (and I understand thi one completely)

[10:49] <|Tux|> short-sighted conversion of the early days

[10:50] <jnthn> :-)

[10:50] <jnthn> Looks good to me now

[10:51] <jnthn> lunch &

[10:58] <masak> timotimo: I wonder if that isn't true of Python and Ruby too, though.

[10:59] <timotimo> well, when you import something, i believe the __init__.py of a module gets called

[11:00] <|Tux|> Clean run from git checkout

[11:00] <|Tux|> This is Rakudo version 2016.07.1-190-g6cd6efe built on MoarVM version 2016.07-18-g2f269d8

[11:00] <|Tux|> csv-ip5xs        9.841

[11:00] <|Tux|> test            15.124

[11:00] <|Tux|> test-t           7.370

[11:00] <|Tux|> csv-parser      16.447

[11:03] <arnsholt> timotimo: Strictly speaking, Python doesn't have much of a separate compilation stage

[11:03] <timotimo> mhm

[11:03] <arnsholt> Modules have to be executed for loading, because def and class are actually covert assignment operators

[11:03] <timotimo> right

[11:03] <nine> Python and Perl 5 are remarkably similar under the hood

[11:04] <timotimo> why can't pypy run perl5 code then

[11:04] <arnsholt> Parts of them are. Python's naming/binding model is atrocious, IMO

[11:05] <arnsholt> Based more or less on "Implicit is better than explicit", hilariously enough =)

[11:06] * tadzik giggles

[11:07] <timotimo> i'm not sure how i feel about python having "bound method" objects and perl6 doesn't

[11:07] <nine> arnsholt: Python violates all of it's Zen thingies

[11:07] <tadzik> I lost so many hours expecting lambdas to work like proper closures

[11:07] <arnsholt> I may be exaggerating (possibly. a bit), but that's really how it feels

[11:07] <tadzik> and they theoretically do, if you're stupid about what an environment is %)

[11:08] <nine> arnsholt: my favourite however is still that in Python the stack holds an implicit reference to the objects while in Perl 5's XS you have to handle it explicitly.

[11:09] <arnsholt> tadzik: Well, the problem is that Python doesn't have the machinery necessary to let the programmer explicitly declare the scope of a variable. Thus the hilarity of using arrays instead

[11:09] <arnsholt> Mostly alleviated by nonlocal in Python 3, I think; but still

[11:09] <arnsholt> nine: Oh, but that's the source of one of my favourite Python weird trivia!

[11:09] <tadzik> arnsholt: oh, I think we're on about different things then, let me come up with an example

[11:10] <arnsholt> So in Python, all variables are scoped to the entire function they're declared in, right?

[11:10] <arnsholt> Except!

[11:11] <arnsholt> The try/except syntax can also introduce a variable, with the syntax "try: ...; except Exception as e"

[11:11] <tadzik> arnsholt: https://gist.github.com/tadzik/d6332f22dbf121b529511867767852c4 is my biggest complaint

[11:11] <arnsholt> e has a reference to the invocation record of the function you're in, which has references to all the variables in that function

[11:12] <arnsholt> Therefore, if e were scoped to the function, you'd get a circular reference, which would make the refcounting sad

[11:12] <timotimo> tadzik: yeah, you have to lambda x, a=a: x + a there

[11:12] <tadzik> yeah

[11:12] <arnsholt> Which is why e is scoped to the except block

[11:12] <tadzik> :D

[11:13] <arnsholt> tadzik: Oh, that! YEah, that sucks

[11:13] <arnsholt> Again, the problem is that you can't declare the scope of a, right?

[11:13] <arnsholt> So a is scoped to the top-level, which is what you're closing over

[11:13] <tadzik> I think the problem is that a means "the name a" not "the value of variable a"

[11:13] <tadzik> so whatever the name was set to last will be used

[11:13] <timotimo> tadzik: except if you return that lambda from your function when the function that held a and the lambda no longer exists on it sown

[11:14] <arnsholt> Basically, it's "my $a; for @args -> $a { @lambdas: push sub { $^x + $a } }"

[11:14] <timotimo> like, you don't get to access another function's a that way

[11:14] <tadzik> it may have caused some customers ending up with data of other customers in some product in some company once

[11:14] <tadzik> (before release though)

[11:15] <tadzik> timotimo: right

[11:16] <arnsholt> Python does have variable declarations, except implicitly through the assignment operator, but they're all pushed to the very top of the containing function (or the top-level if not in a function)

[11:16] <arnsholt> So yeah, you get stupid shit like that

[11:16] <nine> same as Javascript

[11:16] <arnsholt> Also, default values for function arguments aren't thunks

[11:16] <tadzik> this one's great too

[11:16] <arnsholt> They're evaluated *once* when the def is executed...

[11:17] <arnsholt> Which is hilariously broken, in every possible way

[11:17] <timotimo> at least that's a gotcha that everybody knows about

[11:17] <tadzik> I'd label it as a design bug

[11:17] <arnsholt> I once a priori diagnosed a colleague's Python bug simply due to knowing that bug

[11:17] <AlexDaniel> meanwhile, I learned while reading reddit comments that people don't want to know what the compiler was expecting… kinda weird, not sure if I will ever be able to understand this way of thinking.

[11:17] <tadzik> but python seems happy with it

[11:18] <arnsholt> I suspect it's kind of an implementation bug from the very early days

[11:18] <arnsholt> But since people tend to use ints and the like as defaults, it wasn't detected for a long time, by which point it was a de facto feature

[11:18] <arnsholt> Even if it strictly should be considered a feature

[11:19] <nine> AlexDaniel: frankly, I couldn't be less interested in what weirdly named syntactical category e.g. the PHP compiler was expecting (those T_WHATEVER thingies that never help). I guess the same is true for those commenters.

[11:19] <nine> AlexDaniel: they just don't know that those terms are rather meaningful to the Perl 6 programmer, as we can use the same grammar engine as the compiler in our own code.

[11:19] <arnsholt> T_PAYAYIIM_NEKUDOYATIM

[11:19] <arnsholt> Or whatever that fucking thing is called

[11:19] <timotimo> silly php, that's not how you spell "neko"

[11:23] <tadzik> I'd say it'd be nice to at least use the same names in the documentation as in those errors, so that searching for 'infix stopper' gives you something to work with

[11:24] <timotimo> "infix stopper" isn't really something the user would sensibly learn about

[11:24] <tadzik> then is it really meaningful in a user-facing error message?

[11:25] <tadzik> I can understand why reddit people say "these errors use confusing language"

[11:25] <tadzik> heck, I'm not sure what 'infix stopper' is, and I did some messing with the perl6 grammar

[11:26] <tadzik> I can see the value in having something to ack for in the rakudo code itself if I'm that commited to debugging my code, but I can understand that not everybody considers that helpful

[11:29] <arnsholt> Yeah, some of them are opaque (like infix stopper)

[11:29] <arnsholt> But infix, postfix and statement terminator are pretty clear

[11:29] <timotimo> those are, yes

[11:34] <tadzik> yep

[11:36] <jnthn> We could probably filter out some of 'em like "infix stopper"

[11:38] <timotimo> i don't know how to properly give the error a different cursor, i.e. to make it show the beginning of a gobbled block instead of the end

[11:41] <arnsholt> I'm still not sure what an infix stopper is, but the grammar tells me it's <?before> a !! if we're looking for a !!, or before a { or a lambda when it's marked for ws and we're looking for a { or the end of an argument list

[11:41] <arnsholt> =)

[11:41] <AlexDaniel> m: #`{{ blah blah blah␤ blah blah␤ blah␤

[11:41] <camelia> rakudo-moar 6cd6ef: OUTPUT«===SORRY!=== Error while compiling <tmp>␤Couldn't find terminator }} (corresponding {{ was at line 1)␤at <tmp>:4␤------> <BOL>⏏<EOL>␤    expecting any of:␤        }}␤»

[11:42] <AlexDaniel> I think we should report errors that don't report where the whole thing started

[11:42] <AlexDaniel> (the snipped above is #125247)

[11:42] <synopsebot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=125247

[12:03] <masak> arnsholt: what was the Python bug?

[12:04] <masak> arnsholt: oh, "default values aren't thunks"?

[12:09] <masak> tadzik: since you're naturally curious, let me share with you what an infix stopper is

[12:09] <masak> m: my $x; say [1, 2, 3] -> $x; for [1, 2, 3] -> $y { say $y }

[12:09] <camelia> rakudo-moar 6cd6ef: OUTPUT«===SORRY!=== Error while compiling <tmp>␤Unexpected block in infix position (missing statement control word before the expression?)␤at <tmp>:1␤------> my $x; say [1, 2, 3]⏏ -> $x; for [1, 2, 3] -> $y { say $y }␤    expecting any of:…»

[12:10] <masak> (`->` not defined, so cannot use it as an operator)

[12:10] <tadzik> :)

[12:10] <masak> m: sub infix:<< -> >>($l, $r) { "whoa!" }; my $x; say [1, 2, 3] -> $x

[12:10] <camelia> rakudo-moar 6cd6ef: OUTPUT«[1 2 3]␤»

[12:10] <masak> (now we can use it as an operator, but it's *ignored* and not evaluated)

[12:10] <masak> m: sub infix:<< -> >>($l, $r) { "whoa!" }; for [1, 2, 3] -> $y { say $y }

[12:10] <camelia> rakudo-moar 6cd6ef: OUTPUT«1␤2␤3␤»

[12:11] <masak> (here's the reason infix stoppers exist: so that the lambda `->` can override the infix operator `->` when needed)

[12:12] <masak> the `infixish` rule has a `<!infixstopper>` assertion early on, to make sure it's disjunct with infix stoppers

[12:13] <masak> currently we have three infix stoppers in the Perl 6 grammar: `!!` (of `?? !!` fame), `->`, and `{`

[12:13] <masak> all of these can be thought of as "eh eh, oh hai, I know you expected an infix here, but I'm here instead so deal with it"

[12:16] <tadzik> nodnod

[12:34] <arnsholt> masak: Yeah. Basically he came to me and said "something's weird with this thing I'm working on" and it was pretty obvious without looking at the code that the problem was non-thunking

[12:36] <arnsholt> masak: Oh, of course! That makes perfect sense

[12:36] <arnsholt> EXPR just reads terms and infixes until there're none left, so it needs to know when to stop

[13:10] <lizmat> m: sub a( --> Str() ) { 42 }; dd a   # should this work ?

[13:10] <yoleaux2> 02:20Z <MasterDuke> lizmat: it's not pretty, but it does work. should i submit a PR, or do you want something with Mu.possible-phasers for this RT? https://gist.github.com/MasterDuke17/eb8e42371424528d6ca8d8312ad0692b

[13:10] <camelia> rakudo-moar 6cd6ef: OUTPUT«Type check failed for return value; expected Str(Any) but got Int (42)␤  in block <unit> at <tmp> line 1␤␤»

[13:14] <gfldex> lizmat: this should not work

[13:14] <gfldex> m: sub a( --> Str(Int) ) { 42 }; dd a

[13:14] <camelia> rakudo-moar 6cd6ef: OUTPUT«Type check failed for return value; expected Str(Int) but got Int (42)␤  in block <unit> at <tmp> line 1␤␤»

[13:15] <gfldex> but this should (and do the right thing)

[13:15] <gfldex> m: sub a( --> Str(Int) ) { 42.Str }; dd a

[13:15] <camelia> rakudo-moar 6cd6ef: OUTPUT«Type check failed for return value; expected Str(Int) but got Str ("42")␤  in block <unit> at <tmp> line 1␤␤»

[13:15] <lizmat> gfldex: but Str() is just short for Str(Any), so why shouldn't Str() work?

[13:16] <gfldex> oh yes, it should work but doesn't yet. There may be a RT already.

[13:16] <lizmat> ok, so we are in agreement :-)

[13:16] <gfldex> ENEEDMORETEA

[13:21] <gfldex> lizmat: i just checked RT for "return" and could not find a matching RT for this

[13:22] <lizmat> gfldex: ok, shall I RT it or will you ?

[13:22] <gfldex> please RT

[13:28] <dalek> rakudo/nom: 50c24a8 | lizmat++ | src/core/Set (3 files):

[13:28] <dalek> rakudo/nom: Streamline various Set/SetHash methods

[13:28] <dalek> rakudo/nom:

[13:28] <dalek> rakudo/nom: e.g. Set.kv is now 6x faster, others are more in the 5-10% range

[13:28] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/50c24a8a61

[13:28] <lizmat> RT #128964  # gfldex

[13:28] <synopsebot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=128964

[13:38] <dalek> nqp/no-eval: 36f81ba | (Pawel Murias)++ | src/vm/js/ (8 files):

[13:38] <dalek> nqp/no-eval: [js] When loading a compunit save the actual context instead of creating a hackish substitute.

[13:38] <dalek> nqp/no-eval:

[13:38] <dalek> nqp/no-eval: Implement iterating over contexts and support nqp::existskey on them.

[13:38] <dalek> nqp/no-eval: review: https://github.com/perl6/nqp/commit/36f81ba779

[13:38] <dalek> nqp/no-eval: 907a0ca | (Pawel Murias)++ | t/nqp/101-lexpad-stuff.t:

[13:38] <dalek> nqp/no-eval: Test that existkey on ctxs and iterating over them works.

[13:38] <dalek> nqp/no-eval: review: https://github.com/perl6/nqp/commit/907a0cacee

[13:38] <dalek> nqp/no-eval: 3388449 | (Pawel Murias)++ | src/vm/js/Compiler.nqp:

[13:38] <dalek> nqp/no-eval: [js] Update comment.

[13:38] <dalek> nqp/no-eval: review: https://github.com/perl6/nqp/commit/33884492f4

[13:53] <[Coke]> TimToady++ # rt updates!

[14:54] <dalek> rakudo/nom: c159f0a | lizmat++ | src/core/SetHash.pm:

[14:54] <dalek> rakudo/nom: Make SetHash.Set about 80x faster

[14:54] <dalek> rakudo/nom:

[14:54] <dalek> rakudo/nom: for a 1000 element SetHash

[14:54] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/c159f0aa7e

[15:01] <unmatched}> :o

[15:01] <unmatched}> lizmat++

[15:07] <lizmat> so what *is* the difference between Hash.push and Hash.append ?

[15:12] <lizmat> m: my %h; %h.push(<a>,<e f g h>,<a>,<k l>); dd %h

[15:12] <camelia> rakudo-moar c159f0: OUTPUT«Hash %h = {:a($[("e", "f", "g", "h"), ("k", "l")])}␤»

[15:12] <lizmat> m: my %h; %h.append(<a>,<e f g h>,<a>,<k l>); dd %h

[15:12] <camelia> rakudo-moar c159f0: OUTPUT«Hash %h = {:a($["e", "f", "g", "h", "k", "l"])}␤»

[15:19] <nine> lizmat: looks like the same as between Array.push and Array.append?

[15:19] <lizmat> yeah... you need to push/append to the same key twice to see the difference, which was what got me confused

[15:30] <unmatched}> Rele6sr: reminder

[15:30] <Rele6sr> 🎺🎺🎺 Friends! I bear good news! Rakudo's release will happen in just 4 days! Please update the ChangeLog with anything you worked on that should be known to our users. 🎺🎺🎺

[15:30] <Rele6sr> 🎺🎺🎺 Here are still-open new RT tickets since last release: http://bug.perl6.party/1471361447.html And here is the git log output for commits since last release: http://bug.perl6.party/1471361450.html 🎺🎺🎺

[15:31] <unmatched}> 100 tickets.

[15:31] * unmatched} goes over to find any blockers

[15:31] <pmurias> mst: any public info on the "the sysadmin tool mst is building" alluded in the shadow cat blog post?

[15:32] <mst> pmurias: which post?

[15:35] <pmurias> mst: "MST travels to YAPC::EU 2016"

[15:36] <mst> aha

[15:37] <mst> that's the prolog-like thing that's going to underlie a cpan client and later a deployment tool

[15:37] <mst> hence why I was looking at lens-like things

[15:37] <mst> so I can do structural unification on config files

[15:39] <arnsholt> Mmmmmm, tasty tasty logic programming!

[15:40] <timotimo> the good thing about perl6 and unification is that we already have very good unicode support

[15:50] <unmatched}> :( "severe thunderstorm and possible tornado" weather warning :/ Hope I won't lose internet connection.

[15:50] <timotimo> i wish you the best of luck

[15:55] <|Tux|> looking forward seeing many of you in Cluj

[15:56] <dalek> rakudo/nom: 05cdc14 | lizmat++ | src/core/ (2 files):

[15:56] <dalek> rakudo/nom: Make MixHash.Mix|BagHash.Bag about 300x faster

[15:56] <dalek> rakudo/nom:

[15:56] <dalek> rakudo/nom: Mostly because .new is a lot more involved on Mixes and Bags, and

[15:56] <dalek> rakudo/nom: we're bypassing that altogether now.

[15:56] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/05cdc14939

[16:02] <|Tux|> This is Rakudo version 2016.07.1-192-gc159f0a built on MoarVM version 2016.07-18-g2f269d8

[16:02] <|Tux|> csv-ip5xs        9.801

[16:02] <|Tux|> test            15.086

[16:02] <|Tux|> test-t           7.254

[16:02] <|Tux|> csv-parser      16.192

[16:03] <|Tux|> note that ip5xs is under 10 now

[16:03] <|Tux|> nine++

[16:03] * |Tux| => HOME

[16:20] <[Coke]> RT: 1347; @LARRY: 11; CONC: 26; GLR: 4; JVM: 66; LHF: 1; LTA: 114; NEW: 869; NYI: 82; OSX: 5; PERF: 23; POD: 17; PRECOMP: 10; RFC: 32; SEGV: 33; STAR: 5; TESTNEEDED: 16; TODO: 10; UNI: 28; UNTAGGED: 491; WEIRD: 3

[16:21] <nine> But, but, but I didn't do anything :)

[16:25] <lizmat> afk&

[17:34] <dalek> rakudo/nom: 1628e48 | jnthn++ | src/Perl6/Optimizer.nqp:

[17:34] <dalek> rakudo/nom: Fix over-assuming optimization of R.

[17:34] <dalek> rakudo/nom:

[17:34] <dalek> rakudo/nom: It dropped values on the floor when there were more than two args,

[17:34] <dalek> rakudo/nom: as happens with list assoc things like `R,`.

[17:34] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/1628e485df

[17:34] <dalek> rakudo/nom: 65bb9fe | jnthn++ | docs/ChangeLog:

[17:34] <dalek> rakudo/nom: Accuratize ChangeLog notes on concurrency fixes.

[17:34] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/65bb9fe42b

[17:34] <dalek> roast: be9417e | jnthn++ | S03-metaops/reverse.t:

[17:34] <dalek> roast: Test for RT #128703.

[17:34] <dalek> roast: review: https://github.com/perl6/roast/commit/be9417e125

[17:34] <synopsebot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=128703

[17:40] <dalek> rakudo/nom: f1516f4 | (Zoffix Znet)++ | docs/ChangeLog:

[17:40] <dalek> rakudo/nom: Remove duplicate entry

[17:40] <dalek> rakudo/nom:

[17:40] <dalek> rakudo/nom: The other copy was added into Fixes section, which is a more correct section for this.

[17:40] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/f1516f43de

[17:42] <jnthn> d'oh :)

[17:42] <jnthn> Though arguably it's an addition :)

[17:42] <jnthn> I mean, we added the symbols to start blocks :P

[17:43] <unmatched}> But wasn't it to fix some sort of issues? :)

[17:43] <jnthn> I didn't quite notice it was nicely in sections though

[17:44] <jnthn> Well, it's a better default to make sure certain issues can't happen

[17:44] * jnthn will be doing Perl 6 stuff tomorrow

[17:44] <jnthn> Hopefully I sleep much better tonight than last night

[17:45] <brrt> it would be nice if our main perl6 people could stay in one piece these days

[17:46] <jnthn> Mostly I'm just happy my iffy stomach on Sunday cleared up really quickly :)

[17:48] <brrt> well, that's something

[17:48] <[Coke]> jnthn++

[17:51] <jnthn> Anyways, off to relax, eat, etc. :)

[18:22] <unmatched}> The rough plan for the Rele6sr :) Hoping to have it in place for 2016.09 release https://github.com/zoffixznet/Rele6sr/blob/master/ROADMAP.md

[18:22] <unmatched}> Making the release would essentially become doing this:

[18:22] <unmatched}> Rele6sr: release

[18:23] <unmatched}> :D

[18:24] <geekosaur> : skynet

[18:25] <stmuk> use Mojolicious::Lite:from<Perl5>;

[18:25] <stmuk> hahaha

[18:26] <unmatched}> It works quite well actually :)

[18:26] <unmatched}> Well, slow as hell, but works :)

[18:46] <dalek> rakudo/nom: 1728139 | lizmat++ | src/Perl6/World.nqp:

[18:46] <dalek> rakudo/nom: Fix for RT #126264, inspired by MasterDuke17++

[18:46] <dalek> rakudo/nom:

[18:46] <dalek> rakudo/nom: Basically taken from

[18:46] <dalek> rakudo/nom:   https://gist.github.com/MasterDuke17/eb8e42371424528d6ca8d8312ad0692b

[18:46] <synopsebot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=126264

[18:46] <dalek> rakudo/nom: except for the (unimplemented) COMPOSE, DOC.

[18:46] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/17281399dd

[18:48] <masak> unmatched}++ # Rele6sr

[18:57] <unmatched}> lizmat: looks like your fix for RT#128595 fixed RT#127933, 'cause it's a passing todo for me. In the RT#128595 you say that todos pass for it now, but I actually messed up that test and there's no way for it to pass

[18:57] <synopsebot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=128595

[18:57] <synopsebot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=127933

[18:57] <synopsebot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=128595

[18:57] <unmatched}> The two tests in question are next to each other in the file.

[18:58] <lizmat> is that the one testing for hanging ?

[18:59] <unmatched}> Yeah, the doesn't-hang() one. It still hangs, cause it's missing the "exit" bit

[18:59] <unmatched}> But the one after it, about native types in repl now works for me.

[19:00] <lizmat> brb, making tea

[19:01] <dalek> roast: 74b1c12 | (Zoffix Znet)++ | S19-command-line/repl.t:

[19:01] <dalek> roast: Remove poor fudged test for RT#128595

[19:01] <dalek> roast:

[19:01] <dalek> roast: The test tests for hanginess of the REPL, whereas the proper solution

[19:01] <dalek> roast: to the ticket is to not start the REPL in the first place, making this

[19:01] <synopsebot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=128595

[19:01] <dalek> roast: test bogus.

[19:01] <dalek> roast: review: https://github.com/perl6/roast/commit/74b1c12cab

[19:04] <unmatched}> Oh, not your fix for that ticket, but the fix for the ^C in repl stuff

[19:04] <lizmat> ah, now we still need to fix the module not found loading error

[19:06] <dalek> roast: 0e31be9 | (Zoffix Znet)++ | S19-command-line/repl.t:

[19:06] <dalek> roast: Unfudge now-passing tests for RT#127933

[19:06] <dalek> roast:

[19:06] <dalek> roast: Unclear what fixed the issue. Possibly the fix for RT#128900

[19:06] <dalek> roast: https://github.com/rakudo/rakudo/commit/be7ce04

[19:06] <synopsebot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=127933

[19:06] <synopsebot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=128900

[19:06] <dalek> roast: review: https://github.com/perl6/roast/commit/0e31be9782

[19:14] <lizmat> unmatched}: I'm considering removing the fallback to the nqp REPL if module loading failed

[19:14] <lizmat> the idea being that *if* someone too the trouble of adding the module to the command line

[19:14] <lizmat> they really need it, so there's no point REPLing without it

[19:15] <unmatched}> agreed.

[19:15] <lizmat> ok, spectesting that now

[19:26] <dalek> rakudo/nom: ba20d34 | lizmat++ | src/Perl6/Compiler.nqp:

[19:26] <dalek> rakudo/nom: Fix for RT #128595

[19:26] <dalek> rakudo/nom:

[19:26] <dalek> rakudo/nom: By basically removing the CATCH block and falling back to NQP REPL.

[19:26] <dalek> rakudo/nom: The idea being that *if* there's something wrong with either loading

[19:26] <synopsebot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=128595

[19:26] <dalek> rakudo/nom: a module, or with the REPL itself, the resulting fallback would not

[19:26] <dalek> rakudo/nom: be what the user would want anyway, so it's better to croak right away.

[19:26] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/ba20d347e6

[19:27] <unmatched}> jnthn++ looks your async fixes fixed my bug with Mojolicious + Websockets + Proc::Async running a shell app :D

[19:27] <unmatched}> s/bug/segv/;

[19:28] <unmatched}> Which means I can now write the "Perl 6 ♥ Mojolicious" article \o/

[19:30] <lizmat> ++unmatched}

[19:33] <masak> Go 1.7 does SSA and 37 optimization passes: https://pauladamsmith.com/blog/2016/08/go-1.7-ssa.html

[19:33] <jdv79> there were new async fixes?

[19:34] <unmatched}> jdv79: https://github.com/rakudo/rakudo/blob/nom/docs/ChangeLog#L18-L21

[19:34] <unmatched}> Though I don't know if any of that is related to the Proc::Async issue.

[19:36] <jdv79> nice

[19:41] <travis-ci> Rakudo build errored. Elizabeth Mattijsen 'Streamline various Set/SetHash methods

[19:41] <travis-ci> https://travis-ci.org/rakudo/rakudo/builds/152677364 https://github.com/rakudo/rakudo/compare/6cd6efebda64...50c24a8a61d0

[19:41] <buggable> ☢ [travis build above] Build log missing from at least one job. Check results manually.

[19:42] <unmatched}> Yup. One is missing.

[19:42] <unmatched}> I guess I should train buggable to not abort in such cases and just report how many are missing

[20:05] <AlexDaniel> .oO( one day we will substitute everyone here with a bot )

[20:05] <dalek> nqp/no-eval: 4aecc8e | (Pawel Murias)++ | src/vm/js/nqp-runtime/core.js:

[20:05] <dalek> nqp/no-eval: [js] Fix error in error message found by vendethiel++.

[20:05] <dalek> nqp/no-eval: review: https://github.com/perl6/nqp/commit/4aecc8e7f3

[20:05] <vendethiel> right on time \o/

[20:07] <jnthn> unmatched}: Wonder which fix it was; may have been the one involving condvars + GC, since that could affect relatively long-lived promises

[20:09] <lizmat> jnthn: in related news, TEST_HARNESS=6 make spectest still fails after X test files with "no subtests run"

[20:10] <jnthn> Hmm, well, we now know a bunch of bugs that it wasn't at least :P

[20:12] <lizmat> jnthn: true

[20:12] <lizmat> and I must say, the behaviour seems more stable now

[20:12] <lizmat> just not stable enough  :-(

[20:13] <jnthn> Is it always after the same X test files?

[20:14] <jnthn> hm, huh

[20:14] <jnthn> TEST_HARNESS=6 make spectest

[20:14] <jnthn> ...

[20:14] <jnthn> /usr/bin/perl t/harness5 --fudge --moar --keep-exit-code --tests-from-file=t/spectest.data

[20:14] <jnthn> It seems to run the 5 harness. Did I do something wrong? :)

[20:15] <dalek> rakudo/nom: dd9b760 | lizmat++ | src/core/Pair.pm:

[20:15] <dalek> rakudo/nom: Prevent mutable keys in Pairs, RT #128965

[20:15] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/dd9b760fce

[20:15] <synopsebot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=128965

[20:15] <lizmat> jnthn: oops, it's HARNESS_TYPE=6 make spectest

[20:16] <jnthn> yeah, just figured it from le Makefile :)

[20:16] <jnthn> Final error: Type check failed in assignment to $!buffer; expected Str but got Failure (Failure.new(exception...)

[20:17] <jnthn> Is that what you see also?

[20:17] <geekosaur> I was actually talking about something more general; the fact that Scalar gets exposed by .VAR means it can be slipped into anything that is supposed to be immutable, making it suddenly mutable

[20:17] <lizmat> yes, with TEST_JOBS= it just starts emitting "no subtests run"

[20:18] <jnthn> Hm, I have that in my environment

[20:18] <lizmat> with what value ?

[20:18] <jnthn> So it's running parallel anyway

[20:18] <jnthn> Oh... :)

[20:18] <lizmat> no, "TEST_JOBS+"

[20:18] <lizmat> *=

[20:18] <jnthn> I thought you mean "with TEST_JOBS=x" :P

[20:18] <lizmat> nope, the opposite  :-)

[20:19] <jnthn> hehe

[20:19] <jnthn> Trying that too, but it failed with that type check fail both times so far

[20:20] <jnthn> Smells like an over-sharing bug

[20:20] <jnthn> (Both times being parallel runs)

[20:20] <jnthn> Yup, I get the no subtests run thing too

[20:20] <jnthn> So, not OSX this time. ;)

[20:20] <lizmat> *phew*  :-)

[20:21] <jnthn> Yes, phew indeed, I still don't yet have that locally :)

[20:22] <jnthn> Here it seems like t/spec/S02-literals/string-interpolation.t is the first one that emits no subtests run

[20:23] <jnthn> Reliably

[20:23] <jnthn> Or at least, 3 times in a row :)

[20:23] <jnthn> Guess I'll dig into it during my Perl 6 time tomorrow. It'd be rather nice if that worked.

[20:23] <jnthn> And I suspect it ain't going to get golfed for me. :)

[20:24] <lizmat> yup, nice case of dogfooding

[20:26] <jnthn> Also it'd maybe mean http://act.yapc.eu/ye2016/talk/6715 can have a working-er live demo :)

[20:28] <lizmat> yup  :-)

[20:29] <geekosaur> hm. do we have a specification of what operation are permitted on .VAR? I'm thinking of putting a proxy around the Scalar it returns, to try to limit the damage

[20:29] <geekosaur> *operations are

[20:59] <lizmat> jnthn: not sure if you're following the discussion on RT #128965

[20:59] <synopsebot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=128965

[20:59] <lizmat> but I was thinking: wouldn't it be the simplest to have nqp::decont() go to the bottom and handle Scalar objects as well?

[20:59] <lizmat> or is the Scalar a HLL entity and does nqp:: not know about that ?

[21:03] <jnthn> Not following at present :)

[21:04] <geekosaur> the upshot is that allowing Scalar to be visible at the Perl 6 level breaks the type system. you can do things like make immutable types mutable.

[21:04] <jnthn> I've already said that's an issue I'd rather not worry about for the moment.

[21:04] <geekosaur> (and Zefrem *is* doing so)

[21:04] <timotimo> nqp:::decont already handles scalars?

[21:04] <geekosaur> only to one level

[21:04] <timotimo> oh

[21:05] <timotimo> every decont is supposed to strip as many layers as it takes?

[21:05] <timotimo> what if a container contains itself?

[21:05] <jnthn> No, decont is only ever one layer

[21:05] <geekosaur> so lizmat++ patched Pair to remove a Scalar if it's passed, and Zefrem promptly wrapped it in another Scalar so it still leaked in and made a mutable Pair

[21:05] <timotimo> hah

[21:05] <timotimo> zefram is good at breaking things

[21:05] <timotimo> BBIAB

[21:05] <lizmat> I'm just about to commit code to completely disallow Pair.new(Scalar:D)

[21:06] <lizmat> this also fixes typed hashes, bags and mixes

[21:06] <lizmat> albeit with a slightly LTA error message, on which I'm working now

[21:06] <geekosaur> then you'll have to do the same for any other immutable value type, or you just end up with the same problem all over again

[21:06] <jnthn> OK, but the more arbitrary patches we do now, the harder a good/consistent solution will be in a year or so's time when it gets to the top of the agenda.

[21:06] <geekosaur> which is why I think the correct solution is to make Scalar not leak through to the Perl 6 level

[21:06] <lizmat> the only other we have in core, is Set

[21:07] <jnthn> geekosaur: That too only hides the problem, no? What about Proxy, which will have the same sorts of issues?

[21:07] <lizmat> jnthn: I've added a typed exception for it, so it should be easy to trace in the future

[21:08] <geekosaur> hrm. I was actually wondering if just wrapping the Scalar from .VAR in a Proxy would be enough --- but now that you mention it...

[21:08] <geekosaur> still, having to special case everything that uses it seems like a non-scalable and potentially buggy answer

[21:09] <jnthn> geekosaur: Indeed.

[21:09] <lizmat> jnthn geekosaur afaik, this is only an issue for Pair, Bag|BagHash, Mix|MixHash, typed Hashes and Set|SetHash

[21:09] <jnthn> But people don't seem to be able to take "we'll deal with this later" for an answer. :/

[21:10] <lizmat> fixing Pair covers all but Set|SetHash

[21:10] <lizmat> so there would be only 2 places where we would need to do this check

[21:10] <jnthn> Anyway, it's Not My Problem until I've got a good number less problems that are affecting users who are trying to get things done in Perl 6, rather than break stuff.

[21:10] <geekosaur> (actually I think Proxy does the opposite of what I wanted, lets all the mutability of the Scalar through without enabling the kinds of things .VAR is presumably intended for

[21:12] <lizmat> jnthn: ok, will revert the check in Pair, and drop the exception and checking and leave for a future date

[21:13] <dalek> rakudo/nom: b00d92d | lizmat++ | src/core/Pair.pm:

[21:13] <dalek> rakudo/nom: Revert "Prevent mutable keys in Pairs, RT #128965"

[21:13] <dalek> rakudo/nom:

[21:13] <dalek> rakudo/nom: This reverts commit dd9b760fcedcad3a9329fa76c651ca5adf0a579c.

[21:13] <dalek> rakudo/nom:

[21:13] <synopsebot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=128965

[21:13] <dalek> rakudo/nom: This will be fixed more generally at a later date when there are

[21:13] <dalek> rakudo/nom: "a good number less problems that are affecting users who are

[21:13] <dalek> rakudo/nom: trying to get things done in Perl 6, rather than break stuff"

[21:13] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/b00d92de14

[21:14] <jnthn> also

[21:15] <jnthn> m: my $a = [1,2,3] => 4; $a.key[1]++; say $a

[21:15] <camelia> rakudo-moar dd9b76: OUTPUT«[1 3 3] => 4␤»

[21:16] <jnthn> That's another case of a pair with a mutable key. In fact, you can create class MyPretendScalar { has $.value is rw }, and use that as a key too

[21:17] <lizmat> m: my $a = [1,2,3] => 4; $a.key[1]++; say $a.WHICH

[21:17] <camelia> rakudo-moar dd9b76: OUTPUT«Pair|Array|52648624|Int|4␤»

[21:19] <jnthn> Right, there is a distinction in that sense

[21:19] <jnthn> I suspect the answer is that whatever .VAR returns, it'd better not be just another level of containerness

[21:19] <jnthn> But identifying what it *should* be is...trickier.

[21:20] <geekosaur> yeh

[21:21] <geekosaur> which is why I was thinking in the direction of a proxy that exposes the parts that should be exposed (hence asking what those parts should be earlier), but avoids the mutability leak

[21:21] <jnthn> Given we're in introspection teritory, some kind of variable meta-object

[21:22] <jnthn> (maybe :))

[21:22] <jnthn> I don't think Proxy is an especially good direction though, in so far as you can .VAR a Proxy also

[21:23] <geekosaur> I didn;t mean Proxy, but a different kind of proxy. If you could .VAR it, it would not be doing what it is supposed to.

[21:24] <jnthn> Well, .VAR is defined as identity on anything that doesn't explicitly handle it.

[21:25] <dalek> roast: e8632c5 | (Zoffix Znet)++ | S19-command-line/repl.t:

[21:25] <dalek> roast: Remove test for RT#127695

[21:25] <dalek> roast:

[21:25] <dalek> roast: The test checks REPL is exitable when a module cannot be loaded, however,

[21:25] <dalek> roast: as part of fixing of RT#128595 it was decided REPL must not start at all

[21:25] <synopsebot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=127695

[21:25] <synopsebot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=128595

[21:25] <dalek> roast: in such cases, making this test bogus.

[21:25] <dalek> roast:

[21:25] <dalek> roast: The test is not present in 6.c-errata

[21:25] <dalek> roast: review: https://github.com/perl6/roast/commit/e8632c5802

[21:25] <jnthn> Anyway, I really need to rest.

[21:25] <geekosaur> basically a specific proxy that enforces what amounts to access control for the Scalar. if .VAR on that were to return the Scalar, then the proxy would not be enforcing access control; .VAR should indeed return the proxy itself

[21:25] <lizmat> good night, jnthn and #perl6-dev!

[21:25] <jnthn> Oh, .VAR on that object wouldn't return the Scalar it was wrapping, surely :)

[21:27] <jnthn> my $a = 42; my $b = $a.VAR; my $c = $b.VAR; # $c is the meta-object for the Scalar $b, whose value just happens to be the meta-object of the variable $a

[21:28] <jnthn> Well, and "$c is" really really means "$c is a Scalar pointing to" :)

[21:28] <jnthn> Anyway, really resting...I was already frazzled before this. :-) 'night

[21:31] <dalek> roast: 8fa9045 | (Zoffix Znet)++ | S19-command-line/repl.t:

[21:31] <dalek> roast: REPL with -M must not start if module cannot be loaded

[21:31] <dalek> roast:

[21:31] <dalek> roast: RT#128595

[21:31] <dalek> roast: review: https://github.com/perl6/roast/commit/8fa90454e3

[21:31] <synopsebot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=128595
