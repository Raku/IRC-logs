[01:15] <dalek> rakudo/nom: 713ad51 | (Zoffix Znet)++ | src/core/Exception.pm:

[01:15] <dalek> rakudo/nom: Improve error message for malformed ranges in regexes

[01:15] <dalek> rakudo/nom:

[01:15] <dalek> rakudo/nom: Fixes RT#127801

[01:15] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/713ad510d3

[01:15] <synopsebot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=127801

[01:15] <Zoffix> Not 100% happy with this fixes, but I didn't think it was appropriate to mess with nqp for this (with QRegex::P6Regex::World in nqp)

[01:16] <Zoffix> m: my $a = 3; say 'a' ~~ /'a' ** $a..2/

[01:16] <camelia> rakudo-moar 59d808: OUTPUT«===SORRY!=== Error while compiling <tmp>␤Quantifier quantifies nothing␤at <tmp>:1␤------> my $a = 3; say 'a' ~~ /'a' **⏏ $a..2/␤»

[01:16] <Zoffix> That's unfixed.

[01:16] <Zoffix> m: my $a = 3; say 'a' ~~ /'a' ** 1..z/

[01:16] <camelia> rakudo-moar 59d808: OUTPUT«===SORRY!=== Error while compiling <tmp>␤Malformed Range␤at <tmp>:1␤------> my $a = 3; say 'a' ~~ /'a' ** 1..⏏z/␤»

[01:16] <Zoffix> That will mention the variables stuff.

[01:40] <Zoffix> m: say 2×12

[01:40] <camelia> rakudo-moar 713ad5: OUTPUT«24␤»

[01:40] <Zoffix> m: say 1×12

[01:40] <camelia> rakudo-moar 713ad5: OUTPUT«12␤»

[01:40] <Zoffix> m: say 0x12

[01:40] <camelia> rakudo-moar 713ad5: OUTPUT«18␤»

[01:40] <Zoffix> :trollface:

[02:09] <AlexDaniel> m: my $a = 3; say 'a' ~~ /'a' ** 1..z/; say ‘hello world’

[02:09] <camelia> rakudo-moar 713ad5: OUTPUT«===SORRY!=== Error while compiling <tmp>␤Malformed Range. If attempting to use variables for end points, wrap the entire range in curly braces.␤at <tmp>:1␤------> my $a = 3; say 'a' ~~ /'a' ** 1..⏏z/; say ‘hello world’␤»

[02:20] <Zoffix> m: my \z = 3; say 'aaaaaa' ~~ /'a' ** {1..z}/; say ‘hello world’

[02:20] <camelia> rakudo-moar 713ad5: OUTPUT«｢aaa｣␤hello world␤»

[02:20] <Zoffix> I guess that's fine. So just the $a..2 portion that sucks.

[02:39] <dalek> roast: 3f964dc | (Zoffix Znet)++ | S32-str/substr-rw.t:

[02:39] <dalek> roast: [TODO FUDGE] .substr-rw on a string constructed with x

[02:39] <dalek> roast:

[02:39] <dalek> roast: ...refers to the right character

[02:39] <dalek> roast:

[02:39] <dalek> roast: RT#127782

[02:39] <dalek> roast: review: https://github.com/perl6/roast/commit/3f964dca6d

[02:39] <synopsebot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=127782

[02:43] <Zoffix> m: my $a = '.' x 4 ~ 'a'; $a.substr-rw(1,1) = ''; say $a

[02:43] <camelia> rakudo-moar 713ad5: OUTPUT«....␤»

[02:43] <Zoffix> j: my $a = '.' x 4 ~ 'a'; $a.substr-rw(1,1) = ''; say $a

[02:43] <camelia> rakudo-jvm cd19db: OUTPUT«...a␤»

[04:01] <dalek> roast: 665310b | usev6++ | S19-command-line/repl.t:

[04:01] <dalek> roast: Unfudge some repl tests for rakudo-j

[04:01] <dalek> roast: review: https://github.com/perl6/roast/commit/665310beab

[07:50] <psch> java.lang.RuntimeException: java.lang.RuntimeException: Class file too large!

[07:50] <psch> blerg /o\

[07:50] <dalek> rakudo/nom: 60870c1 | lizmat++ | src/core/Hash.pm:

[07:50] <dalek> rakudo/nom: Make Hash.AT-KEY about 35% faster

[07:50] <dalek> rakudo/nom:

[07:50] <dalek> rakudo/nom: - rewrite in NQP completely

[07:50] <dalek> rakudo/nom: - no longer allocate $!storage unless really needed

[07:50] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/60870c13f6

[09:35] <jnthn> morning, all o/

[09:35] <psch> o/ jnthn

[09:36] <psch> is there a way i can get debug output from inside a core op?

[09:36] <psch> 'cause sayfh doesn't seem to work

[09:37] <jnthn> "inside a core op"?

[09:37] <psch> yeah.  specifically, nqp::handle is defined with add_core_op(... sub(...) { })

[09:37] <psch> and inside that sub i added a sayfh

[09:38] <psch> so, nqp core op

[09:40] <jnthn> How did you add it? Just an nqp::sayfh('debug output')?

[09:41] <psch> i mean, the testing code is two nested for loops, which translated to map should definitely hit nqp::handle

[09:41] <jnthn> Don't see why it wouldn't run

[09:41] <psch> yeah

[09:41] <jnthn> Two nested for loops in Rakudo?

[09:41] <psch> yup

[09:41] <psch> or did i not look closely enough at the map impl?

[09:41] <jnthn> But translated to map means really "translated to calls to .map" which is calling the map impl in CORE.setting

[09:42] <jnthn> So you'd get the debug output during the CORE.setting compilation

[09:42] <jnthn> Since that's, I guess, where the nqp::handle you're talking about is

[09:42] <psch> right, the handle call is in Any-iterable-methods

[09:43] <jnthn> Well, handle "call" is a little bit of a confusing way to think of it (to me anyway :)) because it's not a runtime call, it's rather asking the compiler to do code-gen for exception handling

[09:43] <psch> right

[09:44] <psch> so i'd have to codegen the debug output instead i guess

[09:44] <jnthn> Yeah

[09:44] <psch> alright, i can do that

[09:44] <jnthn> Alternatively, you could try nested while loops

[09:44] <jnthn> Oh, though those maybe do not compile so directly with handle

[09:45] <jnthn> Dunno if they exhibit the same problem though, but they'd likely be an easier time to debug if so

[09:45] <jnthn> Alternatively, you can write yourself a program using nqp::handle to mimic the map bug

[09:45] <jnthn> Which may be more golf-able

[09:46] <psch> j: A: for ^1 { B: for ^1 { last A } } # is the bug

[09:46] <camelia> rakudo-jvm cd19db: OUTPUT«===SORRY!===␤labeled last without loop construct␤»

[09:46] <jnthn> hmmm

[09:47] <psch> which, i guess, strongly depends on (1) how we use handle and (2) how we install handlers in nqp-j

[09:47] <jnthn> Yeah

[09:47] <psch> probably mostly the latter, though

[09:47] <jnthn> and (3) how labeled handlers work in nqp-j, which I've no idea about

[09:47] <jnthn> FROGGS++ implemented them, iirc :)

[09:47] <psch> from what i can tell handlerDynamic does seem to do the right thing

[09:48] <psch> we just don't get the label flag set for some reason

[09:48] <psch> j: A: for ^1 { B: for ^1 { last A }; last A }

[09:48] <camelia> rakudo-jvm cd19db: OUTPUT«===SORRY!===␤labeled last without loop construct␤»

[09:48] <psch> j: A: for ^1 { B: for ^1 { last B }; last A }

[09:48] <camelia> rakudo-jvm cd19db: ( no output )

[09:48] <psch> oh hm

[09:48] <psch> that looks like we have the handler but aren't looking the right way..?

[09:49] <jnthn> Or one hides the other or some other weirdness

[09:49] <psch> oh right

[09:49] <psch> i had a hunch about that

[09:49] <psch> we're comparing handlers by array identity in handler{Dynamic,Lexical}

[09:49] <psch> because, for some reason, curHandler is just an int[][]

[09:50] <psch> instead of a HandlerInfo[]

[09:50] <psch> curFrame.curHandler that is

[09:51] <psch> and since HandlerInfo() doesn't copy the array it gets its flags from that might be the reason for the skip..?

[09:52] <psch> err, curFrame.curHandler is a Long actually, curFrame.staticInfo.handlers is the int[][]

[09:53] <psch> well, long[][], but the point stands

[10:11] <dalek> rakudo/nom: 5af32b8 | jnthn++ | src/Perl6/Actions.nqp:

[10:11] <dalek> rakudo/nom: Fix bogus redeclaration error for anon subs.

[10:11] <dalek> rakudo/nom:

[10:11] <dalek> rakudo/nom: Also remove a little duplication in routine_def along the way.

[10:11] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/5af32b88d3

[10:11] <dalek> roast: cefe17f | jnthn++ | S06-routine-modifiers/scoped-named-subs.t:

[10:11] <dalek> roast: Test for RT #127540.

[10:11] <dalek> roast: review: https://github.com/perl6/roast/commit/cefe17f818

[10:11] <synopsebot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=127540

[10:11] <jnthn> There's an easy one to get me warmed up :)

[10:13] <timotimo> it's not warm enough yet? :)

[10:21] <stmuk_> http://pl6anet.org/drop/rakudo-star-2016.07-RC1.dmg

[10:36] <jnthn> m: use Teste; ok "a" ~~ m:g:ignoremark/<[á]>/

[10:36] <camelia> rakudo-moar 5af32b: OUTPUT«===SORRY!===␤Could not find Teste at line 1 in:␤    /home/camelia/.perl6␤    /home/camelia/rakudo-m-inst-1/share/perl6/site␤    /home/camelia/rakudo-m-inst-1/share/perl6/vendor␤    /home/camelia/rakudo-m-inst-1/share/perl6␤    CompUnit::Reposit…»

[10:36] <jnthn> o.O

[10:36] <jnthn> m: use Test; ok "a" ~~ m:g:ignoremark/<[á]>/

[10:36] <camelia> rakudo-moar 5af32b: OUTPUT«===SORRY!===␤chr codepoint cannot be negative␤»

[10:40] <psch> heh, codegen'ing the debug output i want makes Ops.x disappear for some reason

[10:48] <dalek> nqp: 8094c3d | jnthn++ | src/vm/moar/QAST/QASTRegexCompilerMAST.nqp:

[10:48] <dalek> nqp: Add code-gen of charclass with ignoremark.

[10:48] <dalek> nqp:

[10:48] <dalek> nqp: Missed a range check that could lead to chr being passed a -1 that was

[10:48] <dalek> nqp: meant to indicate index out of range.

[10:48] <dalek> nqp: review: https://github.com/perl6/nqp/commit/8094c3d748

[10:49] <dalek> rakudo/nom: eff785b | jnthn++ | tools/build/NQP_REVISION:

[10:49] <dalek> rakudo/nom: NQP version bump for regex code-gen fix.

[10:49] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/eff785b6ba

[10:49] <dalek> roast: 4e9a804 | jnthn++ | S05-metasyntax/charset.t:

[10:49] <dalek> roast: Test for RT #128270.

[10:49] <dalek> roast: review: https://github.com/perl6/roast/commit/4e9a804e54

[10:49] <synopsebot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=128270

[10:53] <psch> hm, it apparently just doesn't pass a tc, which might be because we don't necessarily have one during nqp setting compilation..?

[10:53] <psch> ...i'm just making worse problems for myself by trying to debug something apparently /o\

[10:54] <timotimo> if the tc is like the MVMThreadContext, then we can't possibly not have a tc

[10:55] <psch> well, it's calling into Ops.x(Ljava/lang/String;J)Ljava/lang/String;

[10:55] <psch> so, without the tc argument

[10:55] <timotimo> oh

[10:55] <jnthn> .tell pmurias it seems you forgot to commit t/nqp/019-chars.txt in 3f34d27f95

[10:55] <yoleaux2> jnthn: I'll pass your message to pmurias.

[10:55] <psch> so, right, it's not about "we might not have one", my mistake

[10:55] <timotimo> you can put a :tc argument into the Ops.nqp

[10:56] <timotimo> that'll cause the tc to be passed

[10:56] <psch> r: use nqp; say nqp::x("foo", 2)

[10:56] <camelia> rakudo-moar 5af32b, rakudo-jvm cd19db: OUTPUT«foofoo␤»

[10:56] <psch> timotimo: that's already there for nqp::x :)

[10:56] <timotimo> what is?

[10:56] <psch> the :tc argument

[10:56] <timotimo> oh, huh?

[10:56] <timotimo> so then why doesn't it pass the tc?!

[10:56] <psch> yes, my reaction exactly

[10:57] <psch> it's not even that it doesn't pass it

[10:57] <psch> it generates a lookup for an Ops.x without the argument

[10:57] <dalek> rakudo/nom: 4e2fd4e | lizmat++ | src/core/Hash.pm:

[10:57] <dalek> rakudo/nom: Make Hash.ASSIGN-KEY about 2x as fast

[10:57] <dalek> rakudo/nom:

[10:57] <dalek> rakudo/nom: - rewrite in nqp ops

[10:57] <dalek> rakudo/nom: - be smarter about handling initialization of $!storage

[10:57] <dalek> rakudo/nom: - add candidates for TypedHash[Type] case, because we need them :-(

[10:57] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/4e2fd4e4e7

[10:57] <psch> which, to me, clearly means "stop fiddling with those bits" /o\

[10:58] <dalek> roast: 0d538c2 | lizmat++ | S09-typed-arrays/hashes.t:

[10:58] <dalek> roast: Add some more sanity tests

[10:58] <dalek> roast: review: https://github.com/perl6/roast/commit/0d538c29ef

[11:33] <psch> j: A: for ^1 { FIRST { }; B: for ^1 { last A }; }

[11:33] <camelia> rakudo-jvm cd19db: ( no output )

[11:33] <psch> sooo

[11:33] <psch> something is different between the phaser-y SlippyIterator and the non-phaser-y SlippyIterator

[11:33] <psch> in &sequential-map

[11:35] <psch> well, there's probably a lot of things different about it...

[11:36] <psch> hm, the phasery one has an nqp::stmts around the nqp::handle

[11:37] <psch> also it does the Slip check inside of the nqp::handle

[11:37] <psch> during pull-one that is

[11:39] <psch> ah, nvm, i misread the diff apparently

[12:11] <dalek> nqp: 4d73fdd | jnthn++ | tools/build/MOAR_REVISION:

[12:11] <dalek> nqp: Bump MOAR_REVISION for repeat/concat/substr fix.

[12:11] <dalek> nqp: review: https://github.com/perl6/nqp/commit/4d73fdde0e

[12:12] <dalek> rakudo/nom: 8dff9df | jnthn++ | tools/build/NQP_REVISION:

[12:12] <dalek> rakudo/nom: Bump NQP_REVISION for repeat/concat/substr fix.

[12:12] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/8dff9dff5e

[12:19] <dalek> roast: 58d5bc1 | jnthn++ | S32-str/substr (2 files):

[12:19] <dalek> roast: Unfudge tests for RT #123602 and RT #127782.

[12:19] <dalek> roast: review: https://github.com/perl6/roast/commit/58d5bc1afb

[12:19] <synopsebot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=123602

[12:19] <synopsebot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=127782

[12:20] <nine> Why does travis report in #p6dev?

[12:23] <jnthn> No idea

[12:23] <jnthn> Hysterical raisons, maybe...

[12:23] <jnthn> Does it not report here also?

[12:24] <lizmat> no, it doesn't yet, for nqp at least

[12:24] <jnthn> aww

[12:25] * jnthn wonders who can fix that...

[12:25] <jnthn> ah, yay, probably me

[12:26] <dalek> nqp: eaaf6d8 | jnthn++ | .travis.yml:

[12:26] <dalek> nqp: Update Travis reports channel.

[12:26] <dalek> nqp: review: https://github.com/perl6/nqp/commit/eaaf6d82c6

[12:26] <jnthn> Rakudo already looks correct

[12:30] <travis-ci> NQP build failed. Jonathan Worthington 'Update Travis reports channel.'

[12:30] <travis-ci> https://travis-ci.org/perl6/nqp/builds/146363840 https://github.com/perl6/nqp/compare/4d73fdde0e81...eaaf6d82c6bb

[12:34] <jnthn> There we go :)

[12:40] <[Coke]> you killed the build! ;)

[12:43] <jnthn> .oO( video killed the rakudo star )

[12:44] <timotimo> oh lord

[12:44] <timotimo> at some point, those fantastic/horrible puns must run out

[12:49] <travis-ci> Rakudo build errored. Elizabeth Mattijsen 'Make Hash.ASSIGN-KEY about 2x as fast

[12:49] <travis-ci> https://travis-ci.org/rakudo/rakudo/builds/146345150 https://github.com/rakudo/rakudo/compare/eff785b6baaa...4e2fd4e4e7e6

[12:50] <timotimo> ^- just one of the mac travises hanging up

[13:19] <dalek> roast: 6943d85 | jnthn++ | S11-modules/module (2 files):

[13:19] <dalek> roast: Modernize and expand $?MODULE tests.

[13:19] <dalek> roast: review: https://github.com/perl6/roast/commit/6943d85675

[13:25] <dalek> rakudo/nom: 7427d3f | jnthn++ | src/Perl6/Grammar.nqp:

[13:25] <dalek> rakudo/nom: Implement $?MODULE and ::?MODULE.

[13:25] <dalek> rakudo/nom:

[13:25] <dalek> rakudo/nom: Which were in the docs and mysteriously forgotten, while $?CLASS and

[13:25] <dalek> rakudo/nom: $?ROLE have been around for ages.

[13:25] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/7427d3fe7b

[13:25] <dalek> rakudo/nom: a0b1841 | jnthn++ | t/spectest.data:

[13:25] <dalek> rakudo/nom: Run 2 test files for $?MODULE.

[13:25] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/a0b18410a3

[13:40] <jnthn> m: use Test; throws-like Q/my Array[Numerix] $x;/, X::Undeclared::Symbols, gist => /Numerix/

[13:40] <camelia> rakudo-moar a0b184: OUTPUT«    1..3␤    ok 1 - 'my Array[Numerix] $x;' died␤    not ok 2 - right exception type (X::Undeclared::Symbols)␤    ␤# Failed test 'right exception type (X::Undeclared::Symbols)'␤# at /home/camelia/rakudo-m-inst-1/share/perl6/precomp/12F52E39F6EA6D…»

[13:50] <jnthn> m: dd :<bar>

[13:50] <camelia> rakudo-moar a0b184: OUTPUT«"bar"␤»

[13:51] <jnthn> Hm :)

[13:51] <psch> isn't that just *%_

[13:51] <psch> m: dd (:<bar>)

[13:51] <camelia> rakudo-moar a0b184: OUTPUT«"bar"␤»

[13:51] <psch> huh

[13:51] <dalek> rakudo/nom: dfc53aa | jnthn++ | src/Perl6/Grammar.nqp:

[13:51] <dalek> rakudo/nom: Fix error for unknown symbol in parametric type.

[13:51] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/dfc53aae1a

[13:51] <dalek> roast: 089004c | jnthn++ | S32-exceptions/misc.t:

[13:51] <dalek> roast: Test for RT #128581.

[13:51] <dalek> roast: review: https://github.com/perl6/roast/commit/089004c908

[13:51] <synopsebot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=128581

[13:53] <jnthn> psch: Yeah, I was trying to figure out the explosion in RT #128603

[13:53] <synopsebot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=128603

[13:53] <jnthn> And then ran into this :)

[13:53] <jnthn> Thing is, I've no idea what it *should* do

[13:54] <psch> so we don't colonpair right with < >, i get that correctly?

[13:54] <psch> i'd think &val-ish key maybe?

[13:54] <jnthn> m: say :["foo"]

[13:54] <camelia> rakudo-moar a0b184: OUTPUT«[foo]␤»

[13:54] <jnthn> m: dd :["foo"]

[13:54] <camelia> rakudo-moar a0b184: OUTPUT«["foo"]␤»

[13:54] <jnthn> m: dd :{"foo"}

[13:54] <camelia> rakudo-moar a0b184: OUTPUT«-> ;; $_? is raw { #`(Block|53736800) ... }␤»

[13:54] <psch> oh, we don't colonpair at all with non-()..?

[13:54] <jnthn> Seems that if you don't give it a name, then it acts like the : ain't even there

[13:54] <psch> right

[13:55] <psch> yeah, the anon part seems important :)

[13:55] <jnthn> Which may even be right, considering things like token foo:bar { }

[13:55] <jnthn> In fact, I bet it's making that work that has made colonpair behave this way :)

[13:55] <psch> m: dd (:foo<bar baz>)

[13:55] <camelia> rakudo-moar a0b184: OUTPUT«:foo(("bar", "baz"))␤»

[13:55] <jnthn> m: dd (:<bar baz>)

[13:55] <camelia> rakudo-moar a0b184: OUTPUT«("bar", "baz")␤»

[13:55] <psch> but how am i gonna pass an anon named Positional

[13:55] <psch> scnr

[13:56] <jnthn> m: sub foo(*%_) { say %_ }; foo(:<bar>)

[13:56] <camelia> rakudo-moar a0b184: OUTPUT«Too many positionals passed; expected 0 arguments but got 1␤  in sub foo at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[13:56] <jnthn> Not like that :P

[13:56] <psch> m: sub f(:$!) { }; f

[13:56] <camelia> rakudo-moar a0b184: ( no output )

[13:56] <jnthn> m: sub foo(*%_) { say %_ }; foo(|{ '' => 'bar' })

[13:56] <camelia> rakudo-moar a0b184: OUTPUT«{ => bar}␤»

[13:56] <jnthn> That's how if you're curious ;)

[13:57] <psch> well, that's not really anon, it has a name :)

[13:57] <jnthn> Right, the empty string :)

[13:57] <psch> anyway, yeah, i'm just poking fun at :$! being allowed (but utterly meaningless) in a Signature

[13:57] <jnthn> Anyway...maybe TimToady will weigh in on what it should mean :)

[14:00] <dalek> roast: e25ff99 | (Zoffix Znet)++ | S05-match/capturing-contexts.t:

[14:00] <dalek> roast: [TODO FUDGE] "$/[0]--" interpolates correctly

[14:00] <dalek> roast:

[14:00] <dalek> roast: Postfix operators do not interfere with interpolation of $/[0]

[14:00] <dalek> roast:

[14:00] <dalek> roast: RT#127701

[14:00] <dalek> roast: review: https://github.com/perl6/roast/commit/e25ff99452

[14:00] <synopsebot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=127701

[14:15] <jnthn> m: use Test; is (for ^2 { [+] (^5 X ^5) }), (50, 50);

[14:15] <camelia> rakudo-moar dfc53a: OUTPUT«This Seq has already been iterated, and its values consumed␤(you might solve this by adding .cache on usages of the Seq, or␤by assigning the Seq into an array)␤  in block <unit> at <tmp> line 1␤␤»

[14:28] <dalek> rakudo/nom: b519088 | jnthn++ | src/Perl6/Optimizer.nqp:

[14:28] <dalek> rakudo/nom: Don't constant-fold something producing a Seq.

[14:28] <dalek> rakudo/nom:

[14:28] <dalek> rakudo/nom: Otherwise, if the value is used twice, we'll end up exhuasting it the

[14:28] <dalek> rakudo/nom: first time and it will explode every time afterwards. (We maybe want

[14:28] <dalek> rakudo/nom: to look at whether some things are bogusly marked PURE, but this will

[14:28] <dalek> rakudo/nom: fix all such problems and I can't think of a situation where you'd

[14:28] <dalek> rakudo/nom: ever want this misbehavior.)

[14:28] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/b519088f9d

[14:28] <dalek> roast: e33db6d | jnthn++ | S03-metaops/cross.t:

[14:28] <dalek> roast: Test for RT #127749.

[14:28] <dalek> roast: review: https://github.com/perl6/roast/commit/e33db6dd9e

[14:28] <synopsebot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=127749

[14:29] <jnthn> 3 more RTs and I'll hit 10 for the day :)

[14:30] <___> jnthn++ \o/

[14:38] <llfourn> jnthn++ #fixing all the things

[14:41] <jnthn> There's...quite a lot more of them left to fix :)

[14:47] <___> PR to fix RT#127648 https://github.com/rakudo/rakudo/pull/828  It fixes the issue in the ticket and passes all the spectests, but I'm not sure what this loop {} and what happens when it gets a Nil. Adding a `and $!closed_promise` to that `last` caused a bunch of spectest failures: https://github.com/rakudo/rakudo/pull/828/files#diff-2dda60448bff45302b1196e0c9a45eb7R111

[14:47] <synopsebot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=127648

[14:47] <___> s/what this loop/what this loop is for/;

[14:51] <___> Bad link. This loop, the one just above my changes: https://github.com/zoffixznet/rakudo/blob/0ee25be71cd4d9d4fa14b3044fe13baa75ea0d26/src/core/Channel.pm#L111

[14:54] <jnthn> The loop is to drain any values already in the channel without waiting.

[14:56] <___> Aha. I suspected that; now I'm unsure why the spectests were failing when I added the $closed_promise test to it

[14:56] <jnthn> m: unit sub MAIN ($x where { $^x > 1 } );  say "big"

[14:56] <camelia> rakudo-moar b51908: OUTPUT«===SORRY!===␤Expression needs parens to avoid gobbling block␤at <tmp>:1␤------> unit sub MAIN ($x where { $^x > 1 }⏏ );  say "big"␤Missing block (apparently claimed by expression)␤at <tmp>:1␤------> unit sub MAIN ($x where { $^…»

[14:56] <jnthn> This is a strange one to hunt down...

[14:56] <jnthn> I can easily fix it by removing one line.

[14:57] <jnthn> m: sub foo() is rw{ return 1 }

[14:57] <camelia> rakudo-moar b51908: OUTPUT«===SORRY!===␤Trait 'is rw' needs whitespace before block␤at <tmp>:1␤------> sub foo() is rw{ return 1 }⏏<EOL>␤Missing block (apparently claimed by 'is rw')␤at <tmp>:1␤------> sub foo() is rw{ return 1 }⏏<EOL>␤␤»

[14:57] <jnthn> m: sub foo() is rw{ return 1 };

[14:57] <camelia> rakudo-moar b51908: OUTPUT«===SORRY!===␤Trait 'is rw' needs whitespace before block␤at <tmp>:1␤------> sub foo() is rw{ return 1 }⏏;␤Missing block (apparently claimed by 'is rw')␤at <tmp>:1␤------> sub foo() is rw{ return 1 };⏏<EOL>␤␤»

[14:57] <jnthn> m: sub foo() is rw{ return 1 }; say 42

[14:57] <camelia> rakudo-moar b51908: OUTPUT«===SORRY!===␤Trait 'is rw' needs whitespace before block␤at <tmp>:1␤------> sub foo() is rw{ return 1 }⏏; say 42␤Missing block (apparently claimed by 'is rw')␤at <tmp>:1␤------> sub foo() is rw{ return 1 };⏏ say 42␤␤»

[14:58] <jnthn> m: unit sub foo() is rw{ return 1 }; say 42

[14:58] <camelia> rakudo-moar b51908: OUTPUT«===SORRY!===␤Trait 'is rw' needs whitespace before block␤at <tmp>:1␤------> unit sub foo() is rw{ return 1 }⏏; say 42␤Missing block (apparently claimed by 'is rw')␤at <tmp>:1␤------> unit sub foo() is rw{ return 1 };⏏ say…»

[14:58] <jnthn> m: unit sub MAIN() is rw{ return 1 }; say 42

[14:58] <camelia> rakudo-moar b51908: OUTPUT«===SORRY!===␤Trait 'is rw' needs whitespace before block␤at <tmp>:1␤------> unit sub MAIN() is rw{ return 1 }⏏; say 42␤Missing block (apparently claimed by 'is rw')␤at <tmp>:1␤------> unit sub MAIN() is rw{ return 1 };⏏ s…»

[14:58] <jnthn> Aha...

[14:59] <jnthn> The fix of mine makes that one work...

[14:59] <jnthn> Whe we'd maybe like it to fail as it does now

[14:59] <jnthn> Well, or wait

[15:00] <jnthn> No, that error seems wrong, since it makes it impossible to actually use a trait that wants a block argument with a unit sub MAIN

[15:00] <jnthn> Well, impossible is strong, you'd have to write it sub foo() is thingy({ blah }) { } instead

[15:00] <jnthn> m: unit sub MAIN() is rw{ return 1 }; say 42

[15:00] <camelia> rakudo-moar b51908: OUTPUT«===SORRY!===␤Trait 'is rw' needs whitespace before block␤at <tmp>:1␤------> unit sub MAIN() is rw{ return 1 }⏏; say 42␤Missing block (apparently claimed by 'is rw')␤at <tmp>:1␤------> unit sub MAIN() is rw{ return 1 };⏏ s…»

[15:01] <jnthn> m: sub MAIN() is rw{ return 1 } { say 42 }

[15:01] <camelia> rakudo-moar b51908: OUTPUT«42␤»

[15:01] <jnthn> That works though

[15:01] <jnthn> So I think the error is bogus

[15:01] <unmatched}> TIL you don't need () :/

[15:01] <jnthn> Certainly wasn't any spectests wanting it :)

[15:01] <jnthn> Same with colonparis fwiw

[15:01] <jnthn> m: dd :foo{ say 42 }

[15:01] <camelia> rakudo-moar b51908: OUTPUT«block <unit>␤»

[15:01] <jnthn> oops

[15:01] <jnthn> m: dd (:foo{ say 42 })

[15:02] <camelia> rakudo-moar b51908: OUTPUT«:foo(-> ;; $_? is raw { #`(Block|75837288) ... })␤»

[15:02] <unmatched}> m: dd (:foo"meow")

[15:02] <camelia> rakudo-moar b51908: OUTPUT«===SORRY!=== Error while compiling <tmp>␤Two terms in a row␤at <tmp>:1␤------> dd (:foo⏏"meow")␤    expecting any of:␤        infix␤        infix stopper␤        statement end␤        statement modifier␤        statement mo…»

[15:02] <jnthn> It's only for circumfixes

[15:02] <unmatched}> Ah

[15:02] <jnthn> but you can do it with traits, e.g. to pass an array you can say is foo[1,2,3]

[15:03] <jnthn> If anyone other than TimToady++ had stuck that line in, I'd be thinking "hm, probably a thinko" :)

[15:03] <jnthn> I guess TimToady can have thinkos too ;)

[15:03] <unmatched}> :)

[15:03] <jnthn> And not being able to use where blocks in a unit sub MAIN signature is clearly annoying :)

[15:06] <jnthn> Yowser, not a single spectest for unit sub

[15:07] <jnthn> m: sub MAIN() is rw{ return 1 }; say 42

[15:07] <camelia> rakudo-moar b51908: OUTPUT«===SORRY!===␤Trait 'is rw' needs whitespace before block␤at <tmp>:1␤------> sub MAIN() is rw{ return 1 }⏏; say 42␤Missing block (apparently claimed by 'is rw')␤at <tmp>:1␤------> sub MAIN() is rw{ return 1 };⏏ say 42␤␤»

[15:08] <jnthn> m: sub MAIN(); say 42

[15:08] <camelia> rakudo-moar b51908: OUTPUT«42␤»

[15:08] <jnthn> wow, you don't need the unit on there o.O

[15:08] <jnthn> TIL too :)

[15:15] <jnthn> m: use Test; @*ARGS = '2'; eval-lives-ok 'sub MAIN($x where { $x > 1 }); 1', 'Can have where in sub MAIN(...);';

[15:15] <camelia> rakudo-moar b51908: OUTPUT«not ok 1 - Can have where in sub MAIN(...);␤␤# Failed test 'Can have where in sub MAIN(...);'␤# at <tmp> line 1␤# Error: Expression needs parens to avoid gobbling block␤# Missing block (apparently claimed by expression)␤»

[15:18] <unmatched}> :/ I may have just murdered my $300 keyboard by spilling a bit of soup on it :/

[15:19] <jnthn> oh no /o\ :(

[15:23] <perlpilot> m: sub MAIN(); sub MAIN(); say "hi";

[15:23] <camelia> rakudo-moar b51908: OUTPUT«===SORRY!=== Error while compiling <tmp>␤Too late for unit-scoped sub definition;␤Please use the block form.␤at <tmp>:1␤------> sub MAIN(); sub MAIN();⏏ say "hi";␤»

[15:23] <perlpilot> m: sub foo(); sub MAIN(); say "hi";

[15:23] <camelia> rakudo-moar b51908: OUTPUT«===SORRY!=== Error while compiling <tmp>␤A unit-scoped sub definition is not allowed except on a MAIN sub;␤Please use the block form.␤at <tmp>:1␤------> sub foo();⏏ sub MAIN(); say "hi";␤»

[15:24] <dalek> rakudo/nom: 86843a3 | jnthn++ | src/Perl6/Grammar.nqp:

[15:24] <dalek> rakudo/nom: Remove a check that led to bogus errors.

[15:24] <dalek> rakudo/nom:

[15:24] <dalek> rakudo/nom: Of note, this forbade `unit sub MAIN($x where { $x > 1 }); ...` - that

[15:24] <dalek> rakudo/nom: is, any use of a `where` in a blockless sub MAIN. After some fiddling,

[15:24] <dalek> rakudo/nom: I couldn't work out what useful purpose it served, and no spectests

[15:24] <dalek> rakudo/nom: become unhappy as a result of removing it, so I'll consider it a

[15:24] <dalek> rakudo/nom: thinko.

[15:24] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/86843a3fdb

[15:24] <dalek> roast: 2b3eec7 | jnthn++ | S06-other/main-semicolon.t:

[15:24] <dalek> roast: Tests for RT #127785.

[15:24] <dalek> roast: review: https://github.com/perl6/roast/commit/2b3eec7acf

[15:24] <synopsebot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=127785

[15:42] <dalek> nqp: e9e34f4 | (Pawel Murias)++ | t/nqp/019-chars.txt:

[15:42] <dalek> nqp: Add missing file.

[15:42] <dalek> nqp: review: https://github.com/perl6/nqp/commit/e9e34f4bc6

[15:43] <unmatched}> m: use nqp; my $v = Str; say nqp::isnull($v)

[15:43] <camelia> rakudo-moar 86843a: OUTPUT«0␤»

[15:43] <unmatched}> m: use nqp; my $v = Nil; say nqp::isnull($v)

[15:43] <camelia> rakudo-moar 86843a: OUTPUT«0␤»

[15:43] <unmatched}> When does isnull return 1?

[15:44] <unmatched}> m: use nqp; say nqp::isnull(nqp::null())

[15:44] <camelia> rakudo-moar 86843a: OUTPUT«1␤»

[15:44] <unmatched}> Ah, I see.

[15:53] <jnthn> m: use Test; eval-lives-ok '(;)'; eval-lives-ok '(;;)'

[15:53] <camelia> rakudo-moar 86843a: OUTPUT«(signal XFSZ)Non-QAST node visited BOOTInt␤Weird node visited: BOOTInt␤Resultchild 0 can't returns! BOOTInt␤- QAST::Stmts  (;)␤  - QAST::Stmt :final (;)␤    - 0␤␤Non-QAST node visited BOOTInt␤Weird node visited: BOOTInt␤Resultchild 0 can'…»

[15:53] <jnthn> .oO( Xtremely F... SiZable )

[16:00] <[Coke]> having a problem with perl6-docs's bin/p6doc: there's a REPO line here:

[16:01] <[Coke]> https://github.com/perl6/doc/blob/master/bin/p6doc#L24

[16:01] <[Coke]> that is returning a bunch of directories for me that are NOT the perl6 I'm running with.

[16:04] <unmatched}> 0.o

[16:04] <unmatched}> That returns an empty list on my box

[16:04] <[Coke]> so, that's the difference on doc#714

[16:04] <unmatched}> m: say ($*REPO.repo-chain()>>.Str X~ </doc/>).grep: *.IO.d

[16:04] <camelia> rakudo-moar 86843a: OUTPUT«()␤»

[16:04] <[Coke]> I'm probably getting the Type::Str from my really old perl6 install that I'm not using anymore.

[16:05] <[Coke]> (that other perl6 isn't even in my path!)

[16:05] <unmatched}> m: say $*REPO.repo-chain».Str

[16:05] <camelia> rakudo-moar 86843a: OUTPUT«(/home/camelia/.perl6 /home/camelia/rakudo-m-inst-2/share/perl6/site /home/camelia/rakudo-m-inst-2/share/perl6/vendor /home/camelia/rakudo-m-inst-2/share/perl6 CompUnit::Repository::AbsolutePath<53701584> CompUnit::Repository::NQP<44343416> CompUnit::Repos…»

[16:05] <[Coke]> also, that probably shouldn't be so fixated on doc/

[16:06] <[Coke]> (not sure how the non string entries there relate to finding docs)

[16:12] <dalek> rakudo/nom: 0d491be | jnthn++ | src/Perl6/Optimizer.nqp:

[16:12] <dalek> rakudo/nom: Avoid an infinite loop in optimizer.

[16:12] <dalek> rakudo/nom:

[16:12] <dalek> rakudo/nom: Also make some debug output only show if debugging is enabled.

[16:12] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/0d491be25b

[16:12] <dalek> rakudo/nom: 59b7e51 | jnthn++ | src/Perl6/Actions.nqp:

[16:12] <dalek> rakudo/nom: Make sure we don't stick a 0 into the AST.

[16:12] <dalek> rakudo/nom:

[16:12] <dalek> rakudo/nom: Instead, put a Nil there if we have an empty statement.

[16:12] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/59b7e51b34

[16:13] <dalek> roast: 4f0f994 | jnthn++ | integration/weird-errors.t:

[16:13] <dalek> roast: Tests for RT #127473.

[16:13] <dalek> roast: review: https://github.com/perl6/roast/commit/4f0f994f6a

[16:13] <synopsebot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=127473

[16:21] * lizmat waves from Cologne

[16:21] <unmatched}> \o

[16:21] <lizmat> jnthn++  # fruitful Perl 6 day so far!

[16:22] <jdv79> what's in Cologne?

[16:23] <jnthn> His smell.

[16:23] <jnthn> lizmat: Yeah, I need one more to be at 10 RTs, then think I'll rest :)

[16:24] <jdv79> ha ha

[16:28] <lizmat> jdv79: Niederrhein Perl Mongers meeting

[16:32] <lizmat_> jnthn: could your Optimizer fixes have fixed RT #128655 by any chance?

[16:32] <synopsebot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=128655

[16:32] <jnthn> Hugely unlikely.

[16:37] <travis-ci> NQP build passed. Pawel Murias 'Add missing file.'

[16:37] <travis-ci> https://travis-ci.org/perl6/nqp/builds/146418676 https://github.com/perl6/nqp/compare/eaaf6d82c6bb...e9e34f4bc6db

[16:38] <lizmat_> jnthn: indeed, still there  :-(

[16:42] <jnthn> That one seems a bit more involved.

[16:43] * jnthn is still a little tired (though less so than the last couple of days :)) and has been picking of medium difficulty bugs today :)

[16:50] <[Coke]> RT: 1313; @LARRY: 2; CONC: 7; GLR: 5; JVM: 67; LHF: 1; LTA: 77; NEW: 861; NYI: 28; OSX: 6; PERF: 16; POD: 9; PRECOMP: 8; RFC: 22; SEGV: 24; STAR: 1; TESTNEEDED: 10; TODO: 8; UNI: 10; UNTAGGED: 652; WEIRD: 3

[16:54] <unmatched}> OK, seems Nil can't be a value sent via a Channel

[16:54] <unmatched}> 'cause .poll uses it to indicate no value is in the channel

[17:00] * unmatched} rejects https://rt.perl.org/Ticket/Display.html?id=127648

[17:01] <unmatched}> That was a bit anticlimatic, but at least I learned a bit about Channels :)

[17:02] <lizmat> unmatched} : also, Nil indicates the absence of a value, so that seems to be a little bit weird to want to be able to send that through a channel

[17:02] <TimToady> Nil is not a value, it's the absence of a value

[17:02] <yoleaux2> 15 Jul 2016 14:13Z <[Coke]> TimToady: - we've started tagging RTs that probably need design review with [@LARRY]; one more thing for you to look at if you get some time. other @larrys will pitch in as well. (many more tags to come)

[17:02] <lizmat> dinner&

[17:06] <dalek> rakudo/nom: 68afa3f | jnthn++ | src/Perl6/Actions.nqp:

[17:06] <dalek> rakudo/nom: Correct handling of -> ASubsetType:D $x { }.

[17:06] <dalek> rakudo/nom:

[17:06] <dalek> rakudo/nom: We took the base type of the definiteness type, and just assumed it

[17:06] <dalek> rakudo/nom: was already a simple nominal type. Now it is further analyzed, which

[17:06] <dalek> rakudo/nom: fixes the compilation and behavior of the above construct.

[17:06] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/68afa3f1e7

[17:07] <dalek> roast: b15102e | jnthn++ | S12-subset/subtypes.t:

[17:07] <dalek> roast: Tests for RT #127394.

[17:07] <dalek> roast: review: https://github.com/perl6/roast/commit/b15102e12a

[17:07] <synopsebot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=127394

[17:07] <TimToady> dinner &

[17:07] <nine> jnthn: so that's number 10?

[17:08] <jnthn> Indeed.

[17:08] <jnthn> And I'm tired and hungry, so that's a good stopping point :)

[17:08] <unmatched}> jnthn++ bug fixing \o/

[17:08] <nine> jnthn: congratulations :)

[17:17] <[Coke]> jnthn++

[17:49] <nine> my %a = a => {foo => 1}, b => {bar => 2}; say %a.values.first: *{"bar"}:exists

[17:49] <nine> m: my %a = a => {foo => 1}, b => {bar => 2}; say %a.values.first: *{"bar"}:exists

[17:49] <camelia> rakudo-moar 68afa3: OUTPUT«===SORRY!=== Error while compiling <tmp>␤You can't adverb ␤at <tmp>:1␤------> 2}; say %a.values.first: *{"bar"}:exists⏏<EOL>␤    expecting any of:␤        pair value␤»

[17:49] <nine> Does this qualify at least as an LTA error message?

[17:52] <lizmat> so, what are you trying to do there ?

[17:53] <nine> lizmat: this: say %a.values.first: { $_{"bar"}:exists }

[17:53] <lizmat> so, a HoH ?

[17:55] <nine> yes

[18:06] <lizmat> m: my %a = a => {foo => 1}, b => {bar => 2}; say %a.values.first: { $_<bar>:exists }

[18:06] <camelia> rakudo-moar 68afa3: OUTPUT«{bar => 2}␤»

[18:06] <lizmat> nine: agree, LTA

[18:07] <[TuxCM]> This is Rakudo version 2016.07.1-27-g68afa3f built on MoarVM version 2016.07-4-g236058a

[18:07] <[TuxCM]> test            14.948

[18:07] <[TuxCM]> test-t           7.942

[18:07] <[TuxCM]> csv-parser      16.241

[18:07] <[TuxCM]> MTA

[18:07] <unmatched}> Wooooo \o/

[18:07] <lizmat> cool!

[18:20] <nine> Yeah!

[18:24] <timotimo> nice

[18:29] <perlpilot> I like how the numbers are getting gradually smaller, but one day I expect that the decimal point will move to the left too  ;)   That will be an awesome day

[18:31] <unmatched}> Because we'll have 30GHz cores? :D

[18:31] <timotimo> yup :3

[18:31] <nine> A quick and totally scientific extrapolation shows that in about a year we will reach negative runtimes for test-t. Take that TheDamian!

[18:31] <timotimo> nah, the amount of ghz isn't going to increase very much any more

[18:31] <unmatched}> Didn't they make light-based (as opposed to electron-based) cores X months ago?

[18:31] <unmatched}> by make I mean in a lab, not for sale

[18:32] <perlpilot> sounds familiar

[18:33] <perlpilot> But the bottleneck will still be at the light/electron conversion point

[18:33] <unmatched}> https://www.engadget.com/2015/12/23/researchers-show-working-light-based-processor/

[18:34] <unmatched}> Well, if you can make a photonic core, you can probably make photonic everything :)

[18:35] <unmatched}> .oO( photonic torpedo )

[18:36] <skids> The bottleneck will be the speed of light.  At 4GHz a signal can only travel 74mm across a chip, whether it is made of light or of electrons.

[18:36] <skids> (in one clock cycle)

[18:36] <perlpilot> Well ... we keep saying "the bottleneck", but there will likely be several  ;)

[18:37] <unmatched}> The solution seems obvious. Scientists just need to increase the speed of light.

[18:37] <unmatched}> Which will happen in 2208

[18:38] <perlpilot> "Scientists today built the first tachyonic computer core.  It obtains huge speed gains by sending particles backwards in time"

[18:40] <unmatched}> I'm more betting on something coming out of the entanglement than tachions :D

[18:41] <perlpilot> That could make SIMD very very fast :)

[18:41] <perlpilot> But ... who knows what the future will bring?

[18:42] <unmatched}> Anti-biotic resistant superbugs that'll wipe us all out, of course :)

[18:43] <skids> That hardware can't "just get faster forever" is a good thing.  It will put a stop to the ever growing pile of cruft and force things to be distilled down a bit.

[18:43] <jdv79> maybe

[18:44] <perlpilot> unmatched}: ... and leave skynet as the dominant "life form" on earth.

[18:44] <unmatched}> :)

[18:44] <perlpilot> skids: you underestimate the power of humans to really screw things over  ;>

[18:45] <skids> No, I just appreciate the power of piles of crap to collapse unde rtheir own weight :-)

[18:45] <jdv79> yeah, thats a bit more optimistic than id count on

[18:46] <perlpilot> "Astronomers today have identified a new class of black hole that appears to be made entirely from the excrement of a near-by star cluster"

[18:57] <dalek> rakudo/nom: d789da1 | niner++ | src/core/CompUnit/Repository/Installation.pm:

[18:57] <dalek> rakudo/nom: Implement CompUnit::Repository::Installation::installed

[18:57] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/d789da1b30

[18:57] <nine> stmuk: ^^^

[19:04] <nine> m: my %installed = $*REPO.next-repo.next-repo.next-repo.installed().map({$_.meta<name> => $_}); say %installed<CORE>.content("lib/Test.pm6").get

[19:04] <camelia> rakudo-moar d789da: OUTPUT«use MONKEY-GUTS;          # Allow NQP ops.␤»

[19:06] <tbrowder> ref nqp:  I notice I can do "if $var ~~ $regex" and "unless $var ~~ $regex" but I can't do "if $var !~ $regex" (or "if $var !~~ $regex)"; am I doing something wrong, or is the "!"  form not available?

[19:07] <nine> I dare say it's just not available

[19:08] <unmatched}> nqp: my $re := /zoo/; my $var := "foobar"; say("meow") if !($var ~~ $re);

[19:08] <camelia> nqp-moarvm: OUTPUT«meow␤»

[19:09] <unmatched}> The !~~ is done in perl 6: https://github.com/rakudo/rakudo/blob/nom/src/core/Mu.pm#L810

[19:10] <tbrowder> aha, the joy of parens, but that seems weird after going parenless most everywhere

[19:10] * perlpilot read that as "... going pantless most everywhere" at first glance

[19:10] <tbrowder> probably a precedence thing

[19:11] <perlpilot> remember what NQP stands for  :)

[19:11] <tbrowder> yepper!

[19:11] <tbrowder> thnx all

[19:12] <perlpilot> tbrowder: on the plus side, I bet you could add !~~ to nqp and no one would object much.

[19:13] * unmatched} would

[19:13] <tbrowder> raison?

[19:14] <unmatched}> More things you add. More thinks you have to maintain, document, and debug.

[19:14] <perlpilot> unmatched}: but the impedence mismatch between Perl 6 and NQP would shrink, making it easier for Perl 6 people to contribute to the compiler   :)

[19:16] <unmatched}> heh

[19:16] <tbrowder> nice to hear a bit of electrical talk, I grew up loving to work with analog computers

[19:30] <[Coke]> perlpilot: does adding more ops to nqp, in general, slow nqp down?

[20:26] <travis-ci> Rakudo build errored. Stefan Seifert 'Implement CompUnit::Repository::Installation::installed'

[20:26] <travis-ci> https://travis-ci.org/rakudo/rakudo/builds/146462889 https://github.com/rakudo/rakudo/compare/68afa3f1e778...d789da1b3022

[20:46] <Zoffix> (just a timed out JVM on Mac)

[21:04] <perlpilot> [Coke]: good question.

[21:32] <jnthn> Adding a !~~ to NQP wouldn't have any noticable performance impact, no :)

[23:08] <Zoffix> $ ./perl6-m -e 'dd run(:out, "false").out.close'

[23:08] <Zoffix> Proc.new(in => IO::Pipe, out => IO::Pipe.new(:path(""),:chomp), err => IO::Pipe, exitcode => 1, pid => Any, signal => 0)

[23:09] <Zoffix> How is that returning a Proc? Here it seems to be returning a Mu: https://github.com/rakudo/rakudo/blob/nom/src/core/IO/Handle.pm#L122

[23:50] <Zoffix> Ehhh, never mind. It's in IO::Pipe: https://github.com/rakudo/rakudo/blob/nom/src/core/IO/Pipe.pm#L3

[23:50] <Zoffix> Major brainfart :(
