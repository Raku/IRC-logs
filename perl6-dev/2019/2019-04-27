[00:27] *** fake_space_whale joined
[01:00] *** lizmat joined
[03:24] *** fake_space_whale left
[03:33] *** vrurg left
[03:53] *** vrurg joined
[05:44] *** vrurg left
[06:30] *** lizmat left
[06:52] *** ufobat_ joined
[06:56] *** ufobat__ left
[07:54] *** [TuxCM] left
[08:04] *** lizmat joined
[08:14] *** [TuxCM] joined
[08:19] *** lizmat left
[08:26] *** lizmat joined
[09:05] <nine> 19:08 < sangy> it's crazy how hard it is to keep things reproducible

[09:05] <nine> well put

[09:24] *** ufobat_ left
[09:56] <lizmat> # expr bail: Cannot handle DEOPT_ONE (ins=sp_guardconc)

[09:57] <lizmat> fg

[10:07] <[TuxCM]> bg

[10:09] <timotimo> mfg

[10:09] <[TuxCM]> Rakudo version 2019.03.1-245-g07b4f7438 - MoarVM version 2019.03-101-g8eb232dbc

[10:09] <[TuxCM]> csv-test-xs-20      0.429 -  0.432

[10:09] <[TuxCM]> csv-ip5xs           0.683 -  0.699

[10:09] <[TuxCM]> test-t --race       0.772 -  0.775

[10:09] <[TuxCM]> test-t              1.660 -  1.667

[10:09] <[TuxCM]> csv-ip5xs-20        5.872 -  5.946

[10:09] <[TuxCM]> test                6.790 -  7.602

[10:09] <[TuxCM]> test-t-20 --race    8.763 -  8.862

[10:09] <[TuxCM]> csv-parser         21.784 - 22.855

[10:09] <[TuxCM]> test-t-20          27.501 - 27.858

[10:25] * lizmat just pushed https://github.com/rakudo/rakudo/commit/84144c794b7ea1949f60edf7cc7acb6fea9217f0

[10:25] <lizmat> First attempt at providing an interface to spesh logs

[10:26] <timotimo> oh!

[10:26] <timotimo> lizmat: have you seen moarvm's tools/ folder?

[10:26] <timotimo> it's not quite relevant to what you're working on

[10:27] <timotimo> but there's the graph_spesh tool that turns a piece of spesh log into a diagram for graphviz

[10:27] <lizmat> it gives some inspiration  :-)

[10:27] <timotimo> \o/

[10:33] <nine> Apparently the remaining reproducibility issues are all because of different order of register usage in the generated bytecode. The really weird thing is that this only appears in Perl 6 code. NQP code is perfectly reproducible despite using the same compiler backend with the same register allocator

[11:02] <nine> Where's the code generator for creating Scalar containers for arguments?

[11:51] <jnthn> nine: Probably that's to do with lexical to local lowering, in Perl6::Optimizer

[11:52] <jnthn> I dobut it goes over the lexicals to lower in anything other than hash order

[11:52] <jnthn> *doubt

[11:53] <jnthn> And so would ask for the locals in different orders

[12:04] <nine> jnthn: I've already made lexical_vars_to_locals iterate on sorted hash keys

[12:16] *** AlexDaniel left
[12:17] *** AlexDaniel joined
[12:39] <jnthn> OK, not sure then... Parameter lowering is in Perl6::Actions, lower_signature or similar, but I think that just works in parameter order, so can't imagine what might be random there

[12:45] *** MasterDuke joined
[12:46] *** MasterDuke left
[12:46] *** MasterDuke joined
[12:56] <nine> At least I could now confirm that hash randomization is indeed responsible for all remaining differences

[12:57] <nine> What's still confusing is that I don't see any differences in the order of the generated code. Just in the usage of registers by the code. So somewhere the order of processing does not actually change the order of the generated code but only the state of the register allocator.

[12:58] <nine> Since with the new MAST backend code is generated pretty much in order of walking the QAST, that shouldn't leave many possibilities

[13:00] *** [TuxCM] left
[13:00] <timotimo> fascinating

[13:00] *** [TuxCM] joined
[13:02] <MasterDuke> nine: so the register allocator needs a sort thrown in somewhere? or a way to seed the hash randomization?

[13:06] <nine> MasterDuke: the register allocator itself works completely predictable. It uses only arrays and is less than 40 LOC. And it's also used for NQP where we don't have any reproducibility issues anymore

[13:11] <nine> Apparently the optimizer is at least innocent

[13:48] <AlexDaniel> https://github.com/perl6/problem-solving/issues/17#issuecomment-487286532

[13:49] <AlexDaniel> that application is really strong, in my opinion

[13:49] <AlexDaniel> should we wait for somebody else to try also?

[13:50] <nine> I'm officially running out of ideas

[13:55] *** lucasb joined
[14:10] *** leont joined
[14:16] *** rba joined
[14:20] *** leont left
[14:37] <nine> Oooooooh https://github.com/perl6/nqp/blob/master/src/vm/moar/QAST/QASTCompilerMAST.nqp#L1346

[14:39] <nine> With that fixed, the moar --dump results of 2 builds are identical! But there's still differences in the bytecode. Apparently lists of 16 bit numbers are in different order.

[14:54] <gfldex> m: my %h = 1 => 2, 3 => 4; say %h.head(%h.elems / 2);

[14:54] <evalable6> gfldex, rakudo-moar 84144c794: OUTPUT: ¬´(exit code 1) This type cannot unbox to a native integer: P6opaque, Rat‚ê§  in block <unit> at /tmp/Bwk9Fuhm2T line 1‚ê§‚ê§¬ª

[14:55] *** patrickb joined
[14:57] <lizmat> m: <a b c>.head(1/2)   # golfed

[14:57] <evalable6> lizmat, rakudo-moar 84144c794: OUTPUT: ¬´(exit code 1) This type cannot unbox to a native integer: P6opaque, Rat‚ê§  in block <unit> at /tmp/7SwkT_30q8 line 1‚ê§‚ê§¬ª

[15:02] <gfldex> I'm undecided if that is just LTA or if asking for .head(Rat $n) in itself is wrong.

[15:03] <lizmat> it is an LTA error, it should coerce to Int

[15:03] <lizmat> gfldex: would appreciate a ticket

[15:03] <lizmat> fixing it now

[15:03] <gfldex> lizmat: will do

[15:05] <gfldex> lizmat: #2862

[15:05] <lizmat> gfldex++

[15:13] *** [TuxCM] left
[15:31] * lizmat misses the bots

[15:35] *** [TuxCM] joined
[15:46] *** leont joined
[16:08] <AlexDaniel> lizmat: uh, which ones?

[16:08] <lizmat> Geth  

[16:08] <AlexDaniel> Geth: help

[16:08] <Geth> AlexDaniel, Source at https://github.com/perl6/geth To add repo, add an 'application/json' webhook on GitHub pointing it to http://hack.p6c.org:8888/?chan=#perl6 and choose 'Send me everything' for events to send | use `ver URL to commit` to fetch version bump changes

[16:08] <AlexDaniel> so it's here but it doesn't work?

[16:08] <lizmat> so why is Geth not reporting my commits to rakudo ?

[16:09] * lizmat did 2 in the past 30 mins

[16:09] <AlexDaniel> ahhhh‚Ä¶ something about dns or whatever

[16:09] <AlexDaniel> it's probably running on another server now?

[16:13] *** [TuxCM] left
[16:15] <MasterDuke> lizmat: https://github.com/rakudo/rakudo/blob/master/lib/Spesh.pm6#L33 will miss `JIT: bailed completely because of <foo>`, right?

[16:16] <lizmat> MasterDuke: good catch, will fix

[16:17] <bartolin_> I'd like to suggest to unify nqp::substr across the different backends. Should I open an issue in the problem-solving repo for that or would a plain nqp issue suffice? (Nothing should be changed for Perl 6, only for NQP.)

[16:18] <lizmat> MasterDuke:  eh... maybe not needed, as the it will catch the next line ?

[16:18] <lizmat> bartolin_: I don't think a problem-solving issue is needed

[16:19] <lizmat> backend differences should be as small as possible  :-)

[16:20] <bartolin_> ok, thanks. I'll write down some context, options, etc. for an NQP issue

[16:31] <MasterDuke> lizmat: if a spesh log only has a `JIT: bailed completely because of <foo>`, but not a `expr bail: Cannot get template for: foo`, it won't get picked up

[16:32] <lizmat> can that happen ?

[16:32] <MasterDuke> don't know

[16:33] <lizmat> haven't seen it happen in the spesh logs that I've seen so far

[16:33] <MasterDuke> but those are two different kinds of bails. bailed completely means it isn't getting jitted at all, expr bail just means there's no template. might be nice to be able to differentiate

[16:34] <lizmat> ah, ok... hmmm...

[16:35] *** [TuxCM] joined
[16:42] <MasterDuke> oh, and we have in the not-too-distant past had the situation where there were templates for ops, but it wasn't lego jitted. i don't remember how that looked in the log, and that isn't really a usual situation, but it might cause a 'bailed completely' without an 'expr bail'

[16:44] <ugexe> https://github.com/MoarVM/MoarVM/pull/1098 <-- these have expr templates but no legojit

[16:48] *** raschipi joined
[16:48] <lizmat> MasterDuke: re cuids in spesh log

[16:48] *** [TuxCM] left
[16:49] <lizmat> I was living under the impression that each cuid would refer to the same frame

[16:49] <MasterDuke> ugexe++, those do create `bailed completely` in the spesh log, but *not* `expr bail`

[16:49] <lizmat> but that does not appear to be the case

[16:49] *** [TuxCM] joined
[16:49] <lizmat> so what is the function of cuid?

[16:50] * lizmat was hoping to be able to use it as some "primary key" for selection

[16:50] <MasterDuke> lizmat: i think i thought that too recently, but i don't remember exactly if/how that was wrong

[16:50] <MasterDuke> jnthn, timotimo, or brrt would know

[16:52] <MasterDuke> hm, "20:58 	timotimo 	but yeah, having a sub specifically for the op in question gives us a different cuid, which will have its own set of spesh candidates and everything" is the only thing slightly relevant i see in the channel logs

[16:57] <MasterDuke> it looks like cuids by themselves might not be unique, but cuild + file is

[16:59] <MasterDuke> 90% sure

[17:00] <lizmat> yeah, came to that conclusion as well

[17:00] <lizmat> which sorta makes the cuid superfluous

[17:00] <lizmat> for spesh log introspection purposes anyway

[17:22] *** leont left
[17:23] *** lizmat left
[17:45] <MasterDuke> why aren't roles augmentable?

[17:47] *** leont joined
[18:01] *** Kaypie left
[18:12] <patrickb> o/

[18:12] <raschipi> \o

[18:15] <patrickb> I'm pondering Windows process exec argument quoting behavior. There's already a bug report about it (https://github.com/rakudo/rakudo/issues/2005) and I did a small writeup about my research (https://gist.github.com/patzim/73d4e9c7f0cfc07d2db0f21c82aa1354#file-commandline-processing-md).

[18:15] <patrickb> This starts to feel rather spec-y.

[18:15] <patrickb> Is this a candidate for perl6/problem-solving?

[18:24] *** leont left
[18:35] <jnthn> .tell lizmat cuid is a unique ID within the compilation unit, which can be identified with the filename; mostly it's useful if the log has multiple routines of the same name from the same file in it

[18:35] <yoleaux> jnthn: I'll pass your message to lizmat.

[18:37] <jnthn> .tell lizmat to be clear, it's an ID for a Frame (which might be a routine, or block, or thunk)

[18:37] <yoleaux> jnthn: I'll pass your message to lizmat.

[18:38] <jnthn> MasterDuke: Partly because composition is flattening, so we copy out of the role, and partly because of the genericity handling (it matters that the methods are in a single body block)

[18:38] <jnthn> MasterDuke: Classes are not generic for the same (well, opposite) reason :)

[19:25] *** lucasb left
[20:11] <MasterDuke> jnthn: any reason you couldn't do it if you were ok with anything that *previously* did the role *not* getting whatever augment you did?

[20:28] *** ufobat joined
[20:39] <jnthn> I still don't really know how you'd get around the fact that the handling of genericity depends on closure semantics.

[20:39] <jnthn> It falls out of the "lexpads are closed by compile time" thing

[20:52] *** squashable6 left
[20:57] *** squashable6 joined
[21:07] <MasterDuke> jnthn: i don't really understand what you mean by handling of genericity? i feel this is something different than roles being parammeterizable

[21:07] <jnthn> 2 words for the same thing really

[21:08] <jnthn> But in role Foo[::T] { } then inside of there ::?CLASS and T are both lexicals bound by the signature

[21:09] <jnthn> So it's like saying "if I have a sub foo() { my $a }, how can I put another sub inside of foo in the future", and the answer is you can't

[21:10] <jnthn> (The point being, the augmented methods would have to go inside of the role body to close over the correct arguments)

[21:10] <MasterDuke> hm. but isn't that what augment enables? e.g., put another method inside a class?

[21:10] <jnthn> Not really

[21:10] <jnthn> Not in a lexical sense

[21:11] <jnthn> m: class C { my $a = 42 }; augment class C { say $a }

[21:11] <evalable6> jnthn, rakudo-moar cac95fbbc: OUTPUT: ¬´(exit code 1) 04===SORRY!04=== Error while compiling /tmp/AU9pxI14fE‚ê§augment‚Ä¶¬ª

[21:11] <evalable6> jnthn, Full output: https://gist.github.com/dc9c81a6c0275dcf91c7a94a25acc896

[21:11] <jnthn> m: use MONKEY; class C { my $a = 42 }; augment class C { say $a }

[21:11] <evalable6> jnthn, rakudo-moar cac95fbbc: OUTPUT: ¬´(exit code 1) 04===SORRY!04=== Error while compiling /tmp/22eR58HDrL‚ê§Variable '$a' is not declared‚ê§at /tmp/22eR58HDrL:1‚ê§------> 03C { my $a = 42 }; augment class C { say 08‚èè04$a }‚ê§¬ª

[21:12] <MasterDuke> ah, so we sort of could allow augmenting a role if it never used T or ::?CLASS or pre-existing lexicals?

[21:12] <MasterDuke> but since that's such a significant reduction in usability why bother?

[21:13] <jnthn> It's zero usability, because the type constraint of self of every method in the role is ::?CLASS

[21:13] <jnthn> So there's literally nothing you can augment in that doesn't require it 

[21:13] <MasterDuke> oh, right

[21:14] <jnthn> Well, I guess in theory if you wrote method foo(Mu: $bar) { } you sorta could

[21:15] <jnthn> But that won't end too well if it's a multi and competing with other candidates :)

[22:16] <AlexDaniel> patrickb: yes, especially if you want to end up with a document in the end

[22:26] *** patrickb left
[23:31] *** leont joined
