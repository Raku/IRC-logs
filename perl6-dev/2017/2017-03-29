[03:00] <SmokeMachine> does multi dispatch have performance problem?

[03:01] <SmokeMachine> I am trying to fix the hash multidimensional slice, and im abusing of it...

[03:01] <SmokeMachine> and almost not using nqp... :(

[03:04] <samcv> SmokeMachine, shouldn't have any performance change if it can determine the type on compiling. but if it's dynamic there can be some impact yes

[03:05] <SmokeMachine> samcv: thanks!

[03:06] <samcv> also depends how many you have. removing some can make a fair impact or restructuring so that you turn two multi's into one that has an if condition can also be more performant

[03:06] <samcv> usually that is not needed but in some cases that may be good to try if you think that may be causing an issue

[03:08] <SmokeMachine> I was abusing of it... Ill change it... (I was testing outside of the code... I added it to the right file and didn't work... :( )

[03:10] <SmokeMachine> samcv: that is what I was trying: https://www.irccloud.com/pastebin/fYK6sZos/

[03:12] <samcv> what error do you get SmokeMachine

[03:13] <samcv> it runs for me. but i'm not sure what the output should be or not

[03:13] <SmokeMachine> compile error... P6opaque: must compose before allocating

[03:14] <samcv> compiles for me

[03:14] <SmokeMachine> samcv: it gives me error when I port it to src/core/hash_slice.pm

[03:14] <samcv> can you paste the full text of the error?

[03:15] <samcv> everything

[03:15] <SmokeMachine> sure, 1 sec

[03:16] <SmokeMachine> The last version was returning Seq... this returns List (as expected) https://www.irccloud.com/pastebin/CGDZ7gJw/

[03:17] <SmokeMachine> samcv: the error: https://www.irccloud.com/pastebin/54Bx42Sp/

[03:19] <samcv> SmokeMachine, show me a diff of your changes

[03:20] <SmokeMachine> samcv: the diff https://www.irccloud.com/pastebin/Ntrrr2GH/

[03:33] <samcv> SmokeMachine, i'm guessing something is not containerizing somewhere. or something

[03:34] <samcv> try commenting multi's out and see when it starts compiling again

[03:35] <SmokeMachine> samcv: when I comment everything but the"multi recurse-at-key(\SELF, \indices, 0)" it gives error yes...

[03:37] <SmokeMachine> samcv: I think the problem is the WhateverStar!

[03:38] <SmokeMachine> samcv: I changed to a block and compiled! Ill uncomment everything and test again!

[03:38] <SmokeMachine> :(

[03:39] <SmokeMachine> another *...

[03:40] <SmokeMachine> compiled!

[03:41] <SmokeMachine> worked! :)

[03:49] <SmokeMachine> the spec tests passed...

[03:58] <samcv> good :) SmokeMachine

[03:58] <samcv> yeah commenting things out until it compiles can be helpful because the messages it gives compiling rakudo are not the best

[03:59] <SmokeMachine> samcv: https://github.com/FCO/rakudo/commit/39ef4fc00d6de99bcbe3be40d036861da63c512a

[03:59] <SmokeMachine> samcv: yes, it helps...

[04:00] <SmokeMachine> samcv: thanks for the help!

[04:00] <samcv> also yo should make sure to use `multi sub` for the postcircumfix

[04:01] <samcv> you don't have to for the subs inside the operator routine but you should call all multi's `multi sub`

[04:01] <SmokeMachine> samcv: it is... wasnt on my test to be sure that would use the one i was testing...

[04:01] <samcv> how is speed of the new function compared to the new one?

[04:01] <SmokeMachine> ah! ok!

[04:01] <samcv> kk np

[04:02] <SmokeMachine> samcv: the old one wasnt working for cases as %hash{1,1; 2}

[04:02] <samcv> not at all? or was it returning the wrong type of object?

[04:03] <SmokeMachine> it should return (True, True) and was returning False

[04:05] <samcv> that is no good

[04:06] <samcv> good work though

[04:08] <SmokeMachine> but the fix is much slower... :(

[04:09] <samcv> how much slower? 2x slower?

[04:10] <SmokeMachine> much more...

[04:10] <samcv> okay. then take out this multi multi recurse-at-key(\SELF, [$idx, +@indices where { .elems > 0 }]) {

[04:10] <samcv> and turn it into an if else statement

[04:11] <SmokeMachine> samcv: https://www.irccloud.com/pastebin/T4piLZQX/

[04:12] <samcv> SmokeMachine, i would take out the inside multi's and write it into if else statements

[04:12] <SmokeMachine> samcv: yes, Ill do that...

[04:12] <SmokeMachine> samcv: but ill do that tomorrow...

[04:12] <samcv> kk. sounds good

[04:13] <SmokeMachine> samcv: thanks for your help!

[04:13] <samcv> anytime

[04:13] <SmokeMachine> have a good *

[04:13] <samcv> good * :)

[07:22] <lizmat> Files=1181, Tests=55992, 197 wallclock secs (11.76 usr  4.57 sys + 1170.16 cusr 112.54 csys = 1299.03 CPU)

[10:33] <Zoffix> I had RAKUDO_MAX_THREADS=100 on my VM

[10:33] * Zoffix tries a normal-sized run

[10:46] <timotimo> i wonder if we already have the debugname set before that "need to compose before allocating" message happens. i'm expecting the debugname is set when we compose, though.

[10:47] <Zoffix> ZOFVM: Files=1230, Tests=132967, 117 wallclock secs (22.42 usr  3.06 sys + 2441.50 cusr 122.97 csys = 2589.95 CPU)

[10:47] <Zoffix> that's a 5harness stresstest

[10:47] * Zoffix waits for 6

[10:48] <Zoffix> Unhandled exception in code scheduled on thread 7

[10:48] <Zoffix> Cannot look up attributes in a TAP::Reporter::Console::Session type object

[10:48] <Zoffix> in method summary at /home/cpan/CPANPRC/rakudo/lib/TAP.pm6 (TAP) line 508

[10:48] <lizmat> ouch.  been a while since I saw that one

[10:50] <timotimo> wow, that's amazing

[10:51] <Zoffix> why?

[10:51] <timotimo> others have been trying to reproduce that error for multiple days

[10:51] <Zoffix> ah

[10:51] <timotimo> or am i thinking of something else?

[10:53] <timotimo> cool, the debugname is set in new_type, which is separate from compose

[10:53] <timotimo> so the error message about "compose before allocate" could get the debug name printed out, too

[10:53] * timotimo hacks

[10:54] <Zoffix> ZOF6VM: Files=1216, Tests=132907,  241 wallclock secs

[10:54] <Zoffix> samcv: ^ you wanted to see the difference between 5 and 6 harnesses. Notice how along with being twice as slow, the 6 harness reports 60 fewer tests were run

[10:55] <Zoffix> And 4 fewer files :S

[10:55] <Zoffix> m: say 1230/30

[10:55] <camelia> rakudo-moar 41ac4b: OUTPUT: Â«41â¤Â»

[10:57] <Zoffix> Maybe this line *is* buggy: https://github.com/rakudo/rakudo/blob/nom/t/harness6#L60

[10:57] <Zoffix> m: dd <a> Z <a b>

[10:57] <camelia> rakudo-moar 41ac4b: OUTPUT: Â«(("a", "a"),).Seqâ¤Â»

[10:57] <Zoffix> dunno if it'd always have the right size there or not.

[11:01] <timotimo> i can imagine it'd fail when @tfiles / @slow isn't a whole number?

[11:03] <timotimo> would probably be easy to check, no?

[11:10] <timotimo> fantastic

[11:10] <timotimo> the code SmokeMachine wrote gave "P6opaque: must compose before allocating"

[11:10] <timotimo> with my diff it also mentions that it's about WhateverCode

[11:13] <MasterDuke> nice

[11:15] <timotimo> pushed

[12:23] <dogbert17_> anyone want ta continue the talk about the test harnesses?

[12:25] <dogbert17_> the 'spectest.data' file contains 1253 rows. if I run a spectest which of these should be igonered? Only the ones marked 'stress?

[12:27] <dogbert17_> if we ignore headers an S01 tests the number of files is 1253 - 36 = 1217

[12:43] <dogbert17_> ok, so I have found the 8 files which differ in a spectest between harness5 (1168 files testes) and harness6 (1160 files tested)

[12:43] <MasterDuke> always the same files?

[12:44] <Zoffix> :S

[12:44] <Zoffix> My stresstest run only had 4 missing files

[12:44] <dogbert17_> these differ for me

[12:44] <dogbert17_> t/spec/integration/role-composition-vs-attribute.rakudo.moar, t/spec/integration/rule-in-class-Str.t

[12:44] <dogbert17_> t/spec/integration/say-crash.t, t/spec/integration/substr-after-match-in-gather-in-for.t

[12:44] <dogbert17_> t/spec/integration/topic_in_double_loop.t, t/spec/integration/variables-in-do.t

[12:44] <dogbert17_> t/spec/rosettacode/greatest_element_of_a_list.t, t/spec/rosettacode/sierpinski_triangle.t

[12:46] <Zoffix> "differ"? Differ how?

[12:47] <dogbert17_> they are not run by harness6 when doing a spectest

[12:48] <dogbert17_> I took the output from runs by harness5 and harness6, sorted it and ran diff

[12:50] <Zoffix> does harness 6 run the file when you individually run it? HARNESS_TYPE=6 make t/spec/rosettacode/greatest_element_of_a_list.t

[12:50] <dogbert17_> yes

[12:51] <Zoffix> Then the bug is likely in t/harness6

[12:51] <Zoffix> The part I linked to earlier is especially suspect

[12:51] <dogbert17_> your cmdline didn't work properly, see below

[12:52] <dogbert17_> dogbert@dogbert-VirtualBox ~/repos/rakudo $ HARNESS_TYPE=6 make t/spec/rosettacode/greatest_element_of_a_list.t

[12:52] <dogbert17_> /usr/bin/perl t/harness5 --fudge --moar --keep-exit-code --verbosity=1 t/spec/rosettacode/greatest_element_of_a_list.t

[12:52] <dogbert17_> it used harness5 instead

[12:53] <dogbert17_> I believe the makefile is hardcoded to use harness5 when you want to test a single file

[12:53] <Zoffix> oh, well, try using harness 6

[12:54] <Zoffix> `make -n spectest` to get the command and then change the files to just 1 file

[12:57] <dogbert17_> then it runs the file, btw I used './perl6-m -Ilib t/harness6 --fudge --tests-from-file=t/spectest.data2'  spectest.data2 contains the test file in question

[13:00] * dogbert17_ tests a vague theory, i.e. does the number of tested files change if the TEST_JOBS param is changed

[13:00] <Geth> Â¦ rakudo/nom: 4227b3824d | (Zoffix Znet)++ | docs/2017-IO-Grant--Action-Plan.md

[13:00] <Geth> Â¦ rakudo/nom: Log changes to IO Plan at the top

[13:00] <Geth> Â¦ rakudo/nom:

[13:00] <Geth> Â¦ rakudo/nom: Remove `other issues` from bottom and log changes due to discussions

[13:00] <Geth> Â¦ rakudo/nom: at the top so those who reviewed the plan already can easily see the

[13:00] <Geth> Â¦ rakudo/nom: new changes.

[13:00] <Geth> Â¦ rakudo/nom: review: https://github.com/rakudo/rakudo/commit/4227b3824d

[13:01] <MasterDuke> here's where it's hardcoded to HARNESS5 when making a single file: https://github.com/rakudo/rakudo/blob/nom/Configure.pl#L324

[13:02] <Zoffix> dogbert17_: just see if @tfiles here matches @files: https://github.com/rakudo/rakudo/blob/nom/t/harness6#L60

[13:02] <Zoffix> well, the number of them

[13:04] <dogbert17_> ok, will check

[13:06] <dogbert17_> well, @tfiles is 1160

[13:06] <Zoffix> and @files?

[13:06] <Zoffix> â­â­â­ğŸŒŸâ­â­â­ğŸŒ â­â­â­ğŸŒŸâ­â­â­ğŸŒ â­â­â­ğŸŒŸâ­â­â­ğŸŒ â­â­â­ğŸŒŸâ­â­â­ğŸŒ â­â­â­ğŸŒŸâ­â­â­ğŸŒ â­â­â­ğŸŒŸâ­â­â­

[13:06] <Zoffix> â­â­â­

[13:06] <Zoffix> â­â­â­ Reminder: the deadline to submit your suggestions and corrections to

[13:06] <Zoffix> â­â­â­           IO Action Plan is in 3 days, on April 1st. You can find the Plan at

[13:06] <Zoffix> â­â­â­ https://github.com/rakudo/rakudo/blob/nom/docs/2017-IO-Grant--Action-Plan.md

[13:07] <Zoffix> â­â­â­

[13:07] <Zoffix> â­â­â­ğŸŒŸâ­â­â­ğŸŒ â­â­â­ğŸŒŸâ­â­â­ğŸŒ â­â­â­ğŸŒŸâ­â­â­ğŸŒ â­â­â­ğŸŒŸâ­â­â­ğŸŒ â­â­â­ğŸŒŸâ­â­â­ğŸŒ â­â­â­ğŸŒŸâ­â­â­

[13:07] <dogbert17_> @files is 1139 ?

[13:08] <Zoffix> â­â­â­ If you already did, you can see the 2 new modifications and 2 changes to old modifications that have been proposed in the first section of the file: https://github.com/rakudo/rakudo/blob/nom/docs/2017-IO-Grant--Action-Plan.md#summary-of-the-changes-to-the-original-io-action-plan

[13:10] <Geth> Â¦ rakudo/nom: dc8124f1cd | (Zoffix Znet)++ | docs/2017-IO-Grant--Action-Plan.md

[13:10] <Geth> Â¦ rakudo/nom: List .extension(:parts) is proposed to take a Range

[13:10] <Geth> Â¦ rakudo/nom:

[13:10] <Geth> Â¦ rakudo/nom: - This was originally suggested as possible future expansion,

[13:10] <Geth> Â¦ rakudo/nom: but feels useful enough to include right now.

[13:10] <Geth> Â¦ rakudo/nom: review: https://github.com/rakudo/rakudo/commit/dc8124f1cd

[13:35] <dogbert17_> Zoffix: so why is tfiles 1160, shouldn't it be 1168?

[13:37] <dogbert17_> interesting, if I omit the TEST_JOBS directive @tfiles suddenly becomes 1168

[13:41] <Zoffix> The then bug is where I pointed to, in the Z

[13:41] <Zoffix> because it doesn't get run when TEST_JOBS is 1

[13:41] <Zoffix> Use the debug prints, Luke!

[13:42] <dogbert17_> that's so old school :)

[13:46] <brrt> and super effective

[13:48] <dogbert17_> if TEST_JOBS > 1 then @slow.elems = 29 and @files.elems = 1139 while @tfiles.elems ends up being 1160 (that's eight short)

[13:51] <Zoffix> m: say 29+1139

[13:51] <camelia> rakudo-moar dc8124: OUTPUT: Â«1168â¤Â»

[13:51] <Zoffix> m: say 1139/29

[13:51] <camelia> rakudo-moar dc8124: OUTPUT: Â«39.275862â¤Â»

[13:51] <Zoffix> m: say 1139 div 29

[13:51] <camelia> rakudo-moar dc8124: OUTPUT: Â«39â¤Â»

[13:51] <Zoffix> m: say 39 29

[13:51] <camelia> rakudo-moar dc8124: OUTPUT: Â«5===SORRY!5=== Error while compiling <tmp>â¤Two terms in a rowâ¤at <tmp>:1â¤------> 3say 397â5 29â¤    expecting any of:â¤        infixâ¤        infix stopperâ¤        postfixâ¤        statement endâ¤        statement modifierâ¤      â€¦Â»

[13:51] <Zoffix> m: say 39 * 29

[13:51] <camelia> rakudo-moar dc8124: OUTPUT: Â«1131â¤Â»

[13:51] <Zoffix> m: say (39 * 29) + 29

[13:51] <camelia> rakudo-moar dc8124: OUTPUT: Â«1160â¤Â»

[13:51] <Zoffix> Yup. Z is the cause

[13:52] * Zoffix is pleased to have had guessed this to be the problem area a few weeks ago :)

[13:52] <dogbert17_> .oO (the Z(offix) operator)

[13:52] <dogbert17_> Zoffix++, now all we need is to figure out a fix

[13:52] <Zoffix> Godspeed

[13:55] * dogbert17_ will look when he manages to get home from $work

[13:57] <Zoffix> m: dd <a> Z <b c>

[13:57] <camelia> rakudo-moar dc8124: OUTPUT: Â«(("a", "b"),).Seqâ¤Â»

[13:57] <Zoffix> m: dd roundrobin <a>, <b c>

[13:57] <camelia> rakudo-moar dc8124: OUTPUT: Â«(("a", "b"), ("c",)).Seqâ¤Â»

[13:57] <Zoffix> dogbert17_: ^ a hint :)

[13:57] <Zoffix> "c" is the missing files.

[13:59] <dogbert17_> Zoffix: interesting :)

[14:01] <[Coke]> m: say "\c[IDEOGRAPHIC TELEGRAPH SYMBOL FOR JANUARY]"

[14:01] <camelia> rakudo-moar dc8124: OUTPUT: Â«ã‹€â¤Â»

[14:30] <Zoffix> m: https://gist.github.com/zoffixznet/a79f2825a67338f04cfbbd5a7897124d

[14:30] <camelia> rakudo-moar dc8124: OUTPUT: Â«Wide   (Wide)â¤No such method 'is-prime' for invocant of type 'Wide'â¤  in sub foo at <tmp> line 8â¤  in sub foo at <tmp> line 7â¤  in block <unit> at <tmp> line 11â¤â¤Â»

[14:30] <Zoffix> Why is it even trying to call `.is-prime` on Wide? I gave it 41 to `nextwith`...

[14:32] <Zoffix> m: multi foo (Str) { nextwith 13 }; multi foo (Any $ where .is-prime) {say "ohai"}; foo "x"

[14:32] <camelia> rakudo-moar dc8124: OUTPUT: Â«No such method 'is-prime' for invocant of type 'Str'â¤  in sub foo at <tmp> line 1â¤  in sub foo at <tmp> line 1â¤  in block <unit> at <tmp> line 1â¤â¤Â»

[14:33] <Zoffix> Bug?

[14:34] <Zoffix> m: multi foo (Str) { nextwith 13 }; multi foo (Any $x where {dd $_; True}) {dd [ $x, $x.^name ]; say "ohai"}; foo "x"

[14:34] <camelia> rakudo-moar dc8124: OUTPUT: Â«Str $topic = "x"â¤Int $topic = 13â¤[13, "Int"]â¤ohaiâ¤Â»

[14:35] <Zoffix> Looks like the arg the `where` is trying is pre-loaded when dispatched is figured out, but when it actually runs the value is different :o

[14:35] <Zoffix> s/it actually runs/candidate actually runs/;

[14:38] <Zoffix> Oh, I just misread >_<

[14:38] * Zoffix needs moar coffee

[14:49] <SmokeMachine> samcv: my last try yesterday on this computer that Im using now took 0.3894857, the original 0.02741633. removing all the multis and fancy sub signatures its taking 0.1327739

[14:52] <SmokeMachine> samcv: this is my test, if you are interested... :) https://www.irccloud.com/pastebin/aPL55Xzq/

[14:53] <Zoffix> Interesting. I initially assumed ALL candidates are sorted from narrowest to widest and THEN they're tried in order until first match is found. But my experemintation shows first ALL candidates are tried to see if they match and then they're sorted.... Kinda makes me wonder, wouldn't the first version be way more performant, since you only try enough candidates to find a match and not all?

[14:53] * Zoffix is probably talking shit, but I can see the readers of my article wondering the same

[14:56] <Zoffix> Oh nevermind. My experiment was wrong.

[14:57] <Zoffix> or is it...

[14:57] <Zoffix> m: multi foo (IntStr) { say "IntStr"; }; multi foo (Any $ where { say "Tried to match against $_"; .is-prime}) { say "Any" }; foo <43>;

[14:57] <camelia> rakudo-moar dc8124: OUTPUT: Â«IntStrâ¤Â»

[14:57] <Zoffix> So it didn't try the Any... cool

[14:57] <Zoffix> m: multi foo (IntStr) { say "IntStr"; nextwith 13 }; multi foo (Any $ where { say "Tried to match against $_"; .is-prime}) { say "Any" }; foo <43>;

[14:57] <camelia> rakudo-moar dc8124: OUTPUT: Â«IntStrâ¤Tried to match against 43â¤Tried to match against 13â¤Anyâ¤Â»

[14:58] <Zoffix> But now it did... twice

[14:58] <dogbert17_> -        @tfiles = (@slow Z batch(@tfiles / @slow, @tfiles)).flatmap({ .map(|*) })

[14:58] <dogbert17_> +        @tfiles = (roundrobin @slow, batch(@tfiles / @slow, @tfiles)).flatmap({ .map(|*) })

[14:58] <dogbert17_> Zoffix ^^

[14:58] <Zoffix> Is that .flatmap({ .map(|*) }) really needed? What about just .flat

[15:00] <dogbert17_> seems to work with .flat

[15:01] <Zoffix> OK. I think I get it: it sorts candidates from narrowest to widest, then goes to find the first matching candidate. If you use `nextwith` and ilk, it will continue trying to find the next matching candidate *using original value* and then when it finds it, it'll try to bind the new value that was given to `nextwith` which makes `where` blocks run twice

[15:01] <Zoffix> I don't really get why it doesn't just continue trying with new value alone....

[15:02] <Zoffix> dogbert17_: "seems" is not very scientific. You can `dd` the result and see that it flattened right

[15:04] <dogbert17_> that will be done before a PR is submitted, running a spectest right now in order to se if anything explodes

[15:07] <Zoffix> I really should read the historic docs of how our multi dispatch works. Even our docs just link to glossary instead of explanation :/

[15:09] <dogbert17_> Files=1168, Tests=55436,  411 wallclock secs

[15:09] <Zoffix> \o/

[15:10] <dogbert17_> Files=1168, Tests=55436, 340 wallclock secs ( 6.60 usr  4.22 sys + 903.76 cusr 64.94 csys = 979.52 CPU) # harness5

[16:00] <Zoffix> multi foo { samewith 'blah' }; is the same as multi foo { foo 'blah' } is it not?

[16:10] <ugexe> I think it depends on where the `proto` is?

[16:12] <Zoffix> Like how? The where the proto is affects `foo` same as `samewith`, I'd think, on?

[16:12] <Zoffix> *no?

[16:13] <Zoffix> s: &samewith

[16:13] <SourceBaby> Zoffix, Sauce is at https://github.com/rakudo/rakudo/blob/dc8124f/src/core/control.pm#L136

[16:15] <Zoffix> looks like it just calls foo() to me...

[16:24] <ugexe> I guess my comment just affects dispatch in general, so just calling foo() is the same thing I suppose

[16:26] <ugexe> could have swore i've gotten into spots where I was telling myself use `samewith(...)` and if it gets stuck in an infinite dispatch loop use `foo(...)`

[17:03] <SmokeMachine> Any suggestion to make it faster? https://github.com/FCO/rakudo/commit/c5e8fcf919aa6ec4c43569f0a96ea959aa3663fa

[17:06] <dogbert17> Zoffix: can you make sense of RT #131073?

[17:06] <synopsebot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=131073

[17:08] <Zoffix> dogbert17: yes, it said "It's a spam email, possibly containing an infected attachment"

[17:10] <dogbert17> Zoffix: I see it was swiftly removed :)

[17:14] <Zoffix> m: multi foo(Int) { .say for (nextcallee() xx *)[^3]; }; multi foo(Cool) {}; multi foo(Any) {}; foo 42;

[17:14] <camelia> rakudo-moar dc8124: OUTPUT: Â«Nilâ¤Nilâ¤Nilâ¤Â»

[17:14] <Zoffix> m: multi foo(Int) { .say for eager (nextcallee() xx *)[^3]; }; multi foo(Cool) {}; multi foo(Any) {}; foo 42;

[17:14] <camelia> rakudo-moar dc8124: OUTPUT: Â«Nilâ¤Nilâ¤Nilâ¤Â»

[17:14] <Zoffix> buggy xx still?

[17:14] <[Coke]> note: clicking the big "S" is the "best" way to remove spam from the RT queue. (the one in the menu near actions)

[17:14] <Zoffix> That's the one I used.

[17:14] <[Coke]> I suspect it helps document what is spam versus what is a bad request.

[17:14] <Zoffix> m: multi foo(Int) { nextcallee.say for ^3; }; multi foo(Cool) {}; multi foo(Any) {}; foo 42;

[17:14] <camelia> rakudo-moar dc8124: OUTPUT: Â«sub foo (Cool $) { #`(Sub|52330576) ... }â¤sub foo ($) { #`(Sub|52330728) ... }â¤Nilâ¤Â»

[17:15] <[Coke]> Zoffix++ # I was expected to see it show up as red for me after that, which it didn't.

[17:15] <Zoffix> dammit... I really wanted to show off the coolness of xx :(

[17:15] <[Coke]> *expecting

[17:15] <Zoffix> m: .say for ("hi".say xx 3)[^3]

[17:15] <camelia> rakudo-moar dc8124: OUTPUT: Â«hiâ¤hiâ¤hiâ¤Trueâ¤Trueâ¤Trueâ¤Â»

[17:15] <Zoffix> m: .say for ("hi".say xx *)[^3]

[17:15] <camelia> rakudo-moar dc8124: OUTPUT: Â«hiâ¤hiâ¤hiâ¤Trueâ¤Trueâ¤Trueâ¤Â»

[17:15] <Zoffix> :S

[17:16] <Zoffix> m: .say for (say("hi") xx *)[^3]

[17:16] <camelia> rakudo-moar dc8124: OUTPUT: Â«hiâ¤hiâ¤hiâ¤Trueâ¤Trueâ¤Trueâ¤Â»

[17:16] <Zoffix> Oh gee, it thunks nextcallee and calls it elsewhere >_<

[17:16] <Zoffix> fair 'nuf

[17:20] <Zoffix> dd (nextcallee() for ^*)[^3]; has the same problem :/

[17:21] <Geth> Â¦ rakudo: dogbert17++ created pull request #1050: Fix for RT #131075

[17:21] <Geth> Â¦ rakudo: review: https://github.com/rakudo/rakudo/pull/1050

[17:21] <synopsebot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=131075

[17:23] <Geth> Â¦ rakudo/nom: 876637010e | (Jan-Olof Hendig)++ | t/harness6

[17:23] <Geth> Â¦ rakudo/nom: Fix for RT #131075

[17:23] <Geth> Â¦ rakudo/nom:

[17:23] <Geth> Â¦ rakudo/nom: It was noted by Zoffix++ that the number of tests run by harness6

[17:23] <Geth> Â¦ rakudo/nom: differed from the number run by harness5 when spec- or stresstesting.

[17:23] <synopsebot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=131075

[17:23] <Geth> Â¦ rakudo/nom: The problem turned out to be the piece of code combining the normal

[17:23] <Geth> Â¦ rakudo/nom: test files in spectest.data with the ones marked as being 'slow'.

[17:23] <Geth> Â¦ rakudo/nom: That code used the Z operator on lists that were not the same size,

[17:23] <Geth> Â¦ rakudo/nom: changing to roundrobin instead solves the problem. Zoffix++ for help.

[17:23] <Geth> Â¦ rakudo/nom: review: https://github.com/rakudo/rakudo/commit/876637010e

[17:23] <Geth> Â¦ rakudo/nom: b108c85105 | (Zoffix Znet)++ | t/harness6

[17:23] <Geth> Â¦ rakudo/nom: Merge pull request #1050 from dogbert17/fix-for-rt-131075

[17:23] <Geth> Â¦ rakudo/nom:

[17:23] <Geth> Â¦ rakudo/nom: Fix for RT #131075

[17:23] <synopsebot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=131075

[17:23] <Geth> Â¦ rakudo/nom: review: https://github.com/rakudo/rakudo/commit/b108c85105

[17:24] <dogbert17> oO

[17:31] <Zoffix> holy crap, nextcallee is finicky

[17:32] <Zoffix> loop { dd nextcallee } gives Any instead of my callee, presumable cause it looks for that block instead of my routine >_<

[17:32] <TimToady> huh, when did nextcallee officially get into the language?

[17:34] <[Coke]> the language or the compiler?

[17:34] <Zoffix> TimToady: Before Christmas apparently, tho looks it might've been accidental: https://github.com/perl6/roast/commit/d88edec2f3d6b2fcc650c97b9d42720526b489ca

[17:35] <Zoffix> That commit is the only instance of it in roast; though I see it mentioned in the docs too.

[17:35] <Zoffix> TimToady: I take it it shouldn't be?

[17:36] <TimToady> looks like it's just in there to test wrapping

[17:36] <TimToady> take a reference to the innards of a dispatcher seems...fraught...

[17:36] <[Coke]> https://github.com/rakudo/rakudo/commit/b627af6410d74d1da04e4d7a4ebac1bc13b125cc is the commit that put it in rakudo

[17:37] <TimToady> okay, I vaguely remember jnthn++ asking about calling something repeatedly

[17:37] <[Coke]> https://rt.perl.org/Ticket/Display.html?id=125783 is the ticket

[17:38] <TimToady> but that's for .wrap, dunno why you'd expect it to work in a loop

[17:38] <TimToady> it might work in a multi, or in a method dispatch

[17:39] <Zoffix> Well, I wanted to loop through candidates and find one on which `callwith` wouldn't fail to bind with

[17:40] <Zoffix> And the "loop through" part puts nextcallee into a loop and makes it give wrong results :)

[17:40] <TimToady> nextcallee doesn't do that

[17:40] <TimToady> nextcallee will always give you the same next one

[17:40] <TimToady> unless you actually call down

[17:40] <TimToady> it's not for iterating the candidate list

[17:40] <Zoffix> Hm, then there's a bug. Because it shifts the candidates

[17:41] <Zoffix> m: https://gist.github.com/zoffixznet/80955d554803d120ee95d68e0c8c7d3a

[17:41] <camelia> rakudo-moar b108c8: OUTPUT: Â«Middle    (Middle)â¤Non-Prime 42â¤We're back! The return value is from NotPrimeâ¤Â»

[17:41] <TimToady> hmm, well, maybe it could be used that way then

[17:41] <Zoffix> Without `nextcallee` call, `callwith` ^ would've called the `Wider` candidate and failbind

[17:42] <Zoffix> Now... if only I could stick it in a loop ğŸ¤”ğŸ¤”ğŸ¤”

[17:43] <Zoffix> s: &nextcallee

[17:43] <TimToady> try something non-closurey, like a hyper?

[17:43] <SourceBaby> Zoffix, Sauce is at https://github.com/rakudo/rakudo/blob/dc8124f/src/core/control.pm#L131

[17:43] <TimToady> well, but what to hyper it with, since it's a function...

[17:44] <Zoffix> hehe

[17:45] <TimToady> obviously you just need a goto

[17:46] <Zoffix> :D

[17:48] <TimToady> anyway, hyper would have its own dispatcher, obviously, which would interfere

[17:48] <TimToady> so I suspect you can't do this in Perl 6 without dropping into nqp

[17:49] <TimToady> dispatchers are, by necessity, considered very low level

[17:49] <TimToady> well, or you could implement goto :D

[17:50] <TimToady> or we could implement an opcode that would give you the nth dispatcher going outward

[17:52] <Zoffix> I'm gonna take the easy way out... Just not mention anything about looping and nextcallee in my article :)

[17:53] <TimToady> the intent was obviously to only deal with the next candidate, not the one after that :)

[17:53] <Zoffix> seems like it :)

[17:55] <TimToady> I suppose we could add a loop inside nextcallee, with an optional :nth() arg, since nextcallee itself is perhaps not in anyone's hotpath, but that wouldn't help your article

[17:56] <TimToady> or add a nextcallees function that returns them all

[17:57] <TimToady> that would maintain better inlineability for nextcallee itself

[18:04] <TimToady> interesting that shift_caller deconts after pulling from an nqp list, so something (probably .wrap?) pokes containerized routines into it

[18:04] <TimToady> I wonder why we don't decont when poking things in, rather than when pulling candidates out...

[18:04] <TimToady> or maybe it's superstitious?

[18:05] <TimToady> seems like a heck of a lot of unnecessary deconts, if so, so probably is there for a reason

[18:06] <TimToady> I guess we need to be able to store wrappable candidates

[18:08] * TimToady wonders how much faster we'd run if we didn't allow such late wrapping, and what would break

[18:08] <TimToady> maybe it type-specializes away somewhere

[18:08] <Zoffix> Well, I *think* I succeeded in my quest: my $r = &?ROUTINE; my @nextcallees = .[.first(* === $r, :k) ^.. *] with $r.dispatcher.candidates;

[18:09] <TimToady> I guess .dispatcher will return the nextsame list, not the whole list

[18:10] <Zoffix> of wait, It also needs a .grep: *.cando: \(.signature) or whatever

[18:10] * Zoffix moves on...

[18:21] <TimToady> huh, p6finddispatcher is heavier than I expected, seems to act more like p6createbrandnewdispatcher...

[18:21] <TimToady> probably a consequence of not having cons lists...

[18:22] <TimToady> or maybe I'm reading it wrong

[18:22] * [Coke] gets ready to get laid off Friday!

[18:23] <Zoffix> :(

[18:23] <[Coke]> (new job literally starts Saturday, everything is fine)

[18:23] <Zoffix> say $new-job cmp $old-job

[18:25] <TimToady> m: class Foo { method x { say &?ROUTINE.dispatcher.WHICH } }; class Bar is Foo { method x { say &?ROUTINE.dispatcher.WHICH; nextsame } }; Bar.new.x

[18:25] <camelia> rakudo-moar b108c8: OUTPUT: Â«Mu|U36394168â¤Mu|U36394168â¤Â»

[18:25] <TimToady> okay, it doesn't clone dispatchers for nextsame, whew! :)

[18:26] <TimToady> just uses the current dispatcher destructively

[18:30] <SmokeMachine> is it just for me or is t/spec/S05-modifier/ignorecase.rakudo.moar broken?

[18:31] <SmokeMachine> and t/spec/S09-hashes/objecthash.rakudo.moar seems to have a redeclared %h there too...

[18:31] <Zoffix> I saw ignorecase. pass a TODO once in a while recently...

[18:32] <TimToady> SmokeMachine: are you running on HEAD?

[18:33] <TimToady> maybe you need . config.status or so?

[18:33] <SmokeMachine> TimToady: I think so... I just rebase my changes and tried again...

[18:33] <SmokeMachine> maybe...

[18:33] <SmokeMachine> Ill see that..

[18:34] <TimToady> could be the tests outracing the bumps...

[18:35] <SmokeMachine> this is the problem for objecthash: https://github.com/perl6/roast/blob/master/S09-hashes/objecthash.t#L87

[18:35] <SmokeMachine> redeclaring the %h

[18:47] <TimToady> I'm guessing whoever added that didn't run the test individually, and the warning got hidden

[18:47] <SmokeMachine> the ignore case test worked after I ./Configure again...

[18:48] <TimToady> I can never remember the Configure options, which is why I do . config.status :)

[18:50] <SmokeMachine> :)

[18:57] <Zoffix> m: say DateTime.now > DateTime: :2016year

[18:57] <camelia> rakudo-moar b108c8: OUTPUT: Â«Cannot resolve caller Real(DateTime: ); none of these signatures match:â¤    (Mu:U \v: *%_)â¤  in block <unit> at <tmp> line 1â¤â¤Â»

[18:57] <Zoffix> :/ I thought we added these :\

[18:57] <Zoffix> m: say DateTime.now after DateTime: :2016year

[18:57] <camelia> rakudo-moar b108c8: OUTPUT: Â«Use of uninitialized value of type DateTime in string context.â¤Methods .^name, .perl, .gist, or .say can be used to stringify it to something meaningful.â¤  in block <unit> at <tmp> line 1â¤Trueâ¤Â»

[18:57] <Zoffix> m: say DateTime.now after DateTime: :2022year

[18:57] <camelia> rakudo-moar b108c8: OUTPUT: Â«Use of uninitialized value of type DateTime in string context.â¤Methods .^name, .perl, .gist, or .say can be used to stringify it to something meaningful.â¤  in block <unit> at <tmp> line 1â¤Trueâ¤Â»

[18:57] <Zoffix> :(

[18:57] <Zoffix> terrible

[18:59] <Zoffix> Oh, I'm just missing a .new \o/

[18:59] <Zoffix> m: say DateTime.now > DateTime.new: :2016year

[18:59] <camelia> rakudo-moar b108c8: OUTPUT: Â«Trueâ¤Â»

[18:59] <Zoffix> m: say DateTime.now > DateTime.new: :2018year

[18:59] <camelia> rakudo-moar b108c8: OUTPUT: Â«Falseâ¤Â»

[18:59] <samcv> Zoffix, those todo's pass magically for unknown reasons

[18:59] <samcv> just flapping

[18:59] <Geth> Â¦ rakudo: FCO++ created pull request #1051: Fix multidimensional hash slice

[18:59] <Geth> Â¦ rakudo: review: https://github.com/rakudo/rakudo/pull/1051

[18:59] <Geth> Â¦ roast: FCO++ created pull request #259: Add tests for multi dimensional hash slice

[18:59] <Geth> Â¦ roast: review: https://github.com/perl6/roast/pull/259

[18:59] <Zoffix> samcv: why magically? It uses .pick, so randomly it picks examples that avoid the bug, don't it?

[18:59] <samcv> which is kind of weird in and of itself.

[19:00] <samcv> maybe

[19:00] <samcv> that may be true

[19:00] <samcv> i will adjust it

[19:03] <samcv> i see why it could pass wrongly. fixing

[19:03] <SmokeMachine> this PR fixes the multi dimensional hash slice... but without it, the only feature thats right takes 0.02741633 on my machine... with it it takes 0.1098307, but it fix what didn't work without that...

[19:03] <samcv> gonna do  ('a'..'r','u'..'z').flat.pick

[19:03] <SmokeMachine> its much slower... but works... is that ok?

[19:04] <samcv> is there a way to do ranges like this without havng to make two and then flatten it?

[19:05] <Zoffix> SmokeMachine: yes. Wrong answer that's fast is worse than right answer that's slow :)

[19:06] <Zoffix> m: sub postcircumfix:<{; }> (\a, \b) { dd b }; my %h; %h{1;1...5}

[19:06] <camelia> rakudo-moar b108c8: OUTPUT: Â«(1, (1, 2, 3, 4, 5).Seq)â¤Â»

[19:07] <Zoffix> SmokeMachine: ^ looks like it's possible to pass a Seq as a slice. Does your code handle it right? 'cause Seq isn't a List

[19:07] <Zoffix> and you have nqp::istype(blah, List) up in there

[19:08] <SmokeMachine> Zoffix: yes... I didn't thought about the Seq...

[19:08] <SmokeMachine> fixing

[19:08] <Zoffix> SmokeMachine: I think people usually use nqp::istype(blah, Iterable)

[19:08] <Zoffix> OTOH Hash/Map are also Iterable, so *shrug*

[19:08] <SmokeMachine> Zoffix: great@

[19:08] <SmokeMachine> !

[19:09] <SmokeMachine> Zoffix: Positional?

[19:09] <Zoffix> SmokeMachine: Seq isn't positional

[19:09] <SmokeMachine> :(

[19:09] <Zoffix> :)

[19:09] <Zoffix> SmokeMachine: I think Iterable is the best bet.

[19:09] <SmokeMachine> ok! fixing!

[19:13] <Geth> Â¦ roast: bacc9cb41c | (Samantha McVey)++ | S05-modifier/ignorecase.t

[19:13] <Geth> Â¦ roast: ignorecase.t don't generate random strings containing the needle

[19:13] <Geth> Â¦ roast:

[19:13] <Geth> Â¦ roast: This *may* have been the reason some of these tests were passing sometimes

[19:13] <Geth> Â¦ roast: review: https://github.com/perl6/roast/commit/bacc9cb41c

[19:14] <samcv> ok should maybe be fixed now. now it'll repick if it picks a string that contains 'st' in it

[19:18] <SmokeMachine> Zoffix: changed...

[19:19] <SmokeMachine> if the PR is ok, can I accept it?

[19:21] <Zoffix> Probably :)

[19:22] <samcv> SmokeMachine, how commonly used is this in perl 6 code?

[19:22] <Zoffix> m: use nqp; my \indices = [1..*]; dd nqp::iseq_I(indices.elems, 1),

[19:22] <camelia> rakudo-moar b108c8: OUTPUT: Â«P6opaque: get_boxed_ref could not unbox for the representation '20' of type Failureâ¤  in block <unit> at <tmp> line 1â¤â¤Â»

[19:22] <SmokeMachine> samcv: I don't think its very used...

[19:23] <samcv> ok then making it correct is probably better than making it fast

[19:23] <Zoffix> .oO( when is making it fast is better than making it correct :D )

[19:23] <Zoffix> m: sub rand { 4 }; say rand

[19:23] <camelia> rakudo-moar b108c8: OUTPUT: Â«4â¤Â»

[19:26] <Zoffix> I guess .is-prime falls into that category

[19:26] <Zoffix> Since it's not 100% right

[19:26] <SmokeMachine> Zoffix: why isn't it 100% right?

[19:27] <Zoffix> SmokeMachine: because it's probabilistic :) It uses a formula that most of the time gives right results, but not 100% all the time. There are some inputs that it'll say they're prime/not-prime

[19:28] <SmokeMachine> 'make' is not recognized as an internal or external command?

[19:28] <samcv> Zoffix, which inputs are those?

[19:28] <samcv> and are they in roast?

[19:28] <Zoffix> sudo apt-get install build-essential?

[19:29] <SmokeMachine> what does that mean? https://ci.appveyor.com/project/moritz/rakudo/build/1.0.2699/job/tvk0by5gea2bqd59

[19:29] <SmokeMachine> Zoffix: ^^

[19:30] <Zoffix> Man, what';s the name of a popular Perl guy?

[19:30] <samcv> https://msdn.microsoft.com/en-us/library/1kay26wa.aspx

[19:30] <samcv> dunno

[19:30] <samcv> i have seen it before

[19:30] <samcv> jnthn, ?

[19:30] <Zoffix> Damn. Damian Conway

[19:30] <Zoffix> *sigh* was trying to remember the name to find the talk about the .is-prime stuff

[19:31] <Zoffix> This one: https://www.youtube.com/watch?v=Nq2HkAYbG5o

[19:31] <Zoffix> I *think* it's it; I attended the "extended version"; but maybe regular version has is prime stuff too

[19:31] <Zoffix> And well, it names what we use for is-prime and using that name you can google what inputs it's not right for :)

[19:32] * Zoffix guesses you'd have to wait a lot of time for it to complete to process them :)

[19:33] <samcv> i think i've seen that talk. was good.

[19:34] <Zoffix> SmokeMachine: no idea. Something's up with appveyor again. It's not just your commit, all the previous ones have that problem too

[19:36] <jnthn> samcv: Sounds like the issue that was fixed in https://github.com/MoarVM/MoarVM/commit/36360063b86f662285065c68aed69214c82e37b5

[19:36] <samcv> cool

[19:37] <jnthn> Just means that it doesn't cope with sizeof(void *) or so

[19:37] <jnthn> Or more like, won't let you do pointer arith on void*

[19:37] <jnthn> Since it doesn't know the units

[19:37] <jnthn> I guess other compilers assume the unit is bytes

[19:51] <timotimo> SmokeMachine: i think you can get away with only calling SELF.EXISTS-KEY when the outermost and second-from-outermost if hits its else-branch

[19:51] <timotimo> SmokeMachine: also, check how indices[1 .. indices.end] compares to indices[1..*] and indices.skip(1)

[19:51] <timotimo> m: say (1, 2, 3, 4).skip(1)

[19:51] <camelia> rakudo-moar b108c8: OUTPUT: Â«(2 3 4)â¤Â»

[20:06] <SmokeMachine> m: my @a = ^10; $ = @a.skip(1) for ^10000; say now - INIT now

[20:06] <camelia> rakudo-moar b108c8: OUTPUT: Â«0.0568199â¤Â»

[20:06] <SmokeMachine> m: my @a = ^10; $ = @a[1 .. @a.end]for ^10000; say now - INIT now

[20:06] <camelia> rakudo-moar b108c8: OUTPUT: Â«0.6056935â¤Â»

[20:06] <SmokeMachine> changing to skip!

[20:07] <SmokeMachine> m: my @a = ^10; say = @a.skip

[20:07] <camelia> rakudo-moar b108c8: OUTPUT: Â«5===SORRY!5=== Error while compiling <tmp>â¤Preceding context expects a term, but found infix = insteadâ¤at <tmp>:1â¤------> 3my @a = ^10; say =7â5 @a.skipâ¤Â»

[20:07] <SmokeMachine> m: my @a = ^10; say @a.skip

[20:07] <camelia> rakudo-moar b108c8: OUTPUT: Â«(1 2 3 4 5 6 7 8 9)â¤Â»

[20:07] <SmokeMachine> m: my @a = ^10; $ = @a.skip for ^10000; say now - INIT now

[20:07] <camelia> rakudo-moar b108c8: OUTPUT: Â«0.0490078â¤Â»

[20:07] <SmokeMachine> timotimo: thanks!

[20:10] <SmokeMachine> m: my say ^10 .skip

[20:10] <camelia> rakudo-moar b108c8: OUTPUT: Â«5===SORRY!5===â¤Type 'say' is not declaredâ¤at <tmp>:1â¤------> 3my say7â5 ^10 .skipâ¤Malformed myâ¤at <tmp>:1â¤------> 3my7â5 say ^10 .skipâ¤â¤Â»

[20:10] <SmokeMachine> :(

[20:11] <timotimo> haha "my say"? :)

[20:12] <SmokeMachine> m: say ^10 .skip

[20:12] <camelia> rakudo-moar b108c8: OUTPUT: Â«(1 2 3 4 5 6 7 8 9)â¤Â»

[20:12] <SmokeMachine> (sorry)

[20:12] <SmokeMachine> m: my $a = ^10; $ = $a.skip.cache for ^10000; say now - INIT now

[20:12] <camelia> rakudo-moar b108c8: OUTPUT: Â«0.09728743â¤Â»

[20:17] <SmokeMachine> with skip it got from 0.1098307  to 0.0547416

[20:17] <timotimo> *nice*

[20:17] <SmokeMachine> thanks!

[20:17] <SmokeMachine> (but I had to .skip.cache)

[20:21] <SmokeMachine> if/when you guys think its ok to merge the PR, please tell me

[20:48] <Zoffix> yeah merge it

[21:01] <lizmat> m: my %h{Any} = now => 42; dd %h   # guess this is a case of DIHWIDT

[21:01] <camelia> rakudo-moar b108c8: OUTPUT: Â«Hash[Any,Any] %h = (my Any %{Any} = :now(42))â¤Â»

[21:04] <SmokeMachine> lizmat: sorry, what means DIHWIDT?

[21:04] <lizmat> Doctor, It Hurts When I Do This

[21:04] <lizmat> (then don't do that :-)

[21:04] <timotimo> yas

[21:05] <[Coke]> buggable: DIHWIDT?

[21:05] <lizmat> m: my %h{Any} = now,42; dd %h

[21:05] <camelia> rakudo-moar b108c8: OUTPUT: Â«Hash[Any,Any] %h = (my Any %{Any} = Instant.from-posix(<1265707485887/849>, Bool::False) => 42)â¤Â»

[21:05] <[Coke]> ETOOMANYBOTS

[21:05] <lizmat> ah, better  :-)

[21:06] <SmokeMachine> Zoffix: create a merge commit, squash and merge or rebase and merge?

[21:08] <Zoffix> SmokeMachine: dunno, just click some button :)

[21:09] <Zoffix> I'd say it's a case of DWIM. You asked for quoted key, so you got it. It'd be pretty weird if your keys got automatically changed the second you imported some term or constant.

[21:09] <Zoffix> m: my %h{Any} = (now) => 42; dd %h

[21:09] <camelia> rakudo-moar b108c8: OUTPUT: Â«Hash[Any,Any] %h = (my Any %{Any} = Instant.from-posix(<1862036359552/1249>, Bool::False) => 42)â¤Â»

[21:09] <Zoffix> m: my %h{Any} = 42 R=> now; dd %h

[21:09] <camelia> rakudo-moar b108c8: OUTPUT: Â«Hash[Any,Any] %h = (my Any %{Any} = Instant.from-posix(<2512034655006/1685>, Bool::False) => 42)â¤Â»

[21:09] <Geth> Â¦ rakudo/nom: a758c0bbf9 | (Fernando Correa)++ | src/core/hash_slice.pm

[21:09] <Geth> Â¦ rakudo/nom: Fix multidimensional hash slice

[21:09] <Geth> Â¦ rakudo/nom:

[21:09] <Geth> Â¦ rakudo/nom: &postcircumfix:<{; }> wasnt prepard to receive a List as one (or more) position(s)

[21:09] <Geth> Â¦ rakudo/nom: of the argument list (eg: %h{"bla", "ble"; "bli"})

[21:09] <Geth> Â¦ rakudo/nom: review: https://github.com/rakudo/rakudo/commit/a758c0bbf9

[21:09] <Geth> Â¦ rakudo/nom: dc812a4a5a | (Fernando Correa de Oliveira)++ | src/core/hash_slice.pm

[21:09] <Geth> Â¦ rakudo/nom: Merge pull request #1051 from FCO/multidimensional-hash-slice

[21:09] <Geth> Â¦ rakudo/nom:

[21:09] <Geth> Â¦ rakudo/nom: Fix multidimensional hash slice

[21:09] <Geth> Â¦ rakudo/nom: review: https://github.com/rakudo/rakudo/commit/dc812a4a5a

[21:09] <lizmat> SmokeMachine++

[21:10] <Geth> Â¦ roast: a25592a533 | (Fernando Correa)++ | S09-hashes/objecthash.t

[21:10] <Geth> Â¦ roast: Add tests for multi dimensional hash slice

[21:10] <Geth> Â¦ roast: review: https://github.com/perl6/roast/commit/a25592a533

[21:10] <Geth> Â¦ roast: fc4e2c7b25 | (Fernando Correa de Oliveira)++ | S09-hashes/objecthash.t

[21:10] <Geth> Â¦ roast: Merge pull request #259 from FCO/multidimensional-hash-slice

[21:10] <Geth> Â¦ roast:

[21:10] <Geth> Â¦ roast: Add tests for multi dimensional hash slice

[21:10] <Geth> Â¦ roast: review: https://github.com/perl6/roast/commit/fc4e2c7b25

[21:10] <SmokeMachine> lizmat: thanks!

[21:11] <Zoffix> SmokeMachine: what does the .skip.cache do tho?

[21:11] <lizmat> the .skip skips the first element of the sequence, the .cache makes sure that you can .AT-POS it without losing the iterator

[21:12] <SmokeMachine> Zoffix: what lizmat sad

[21:12] <Zoffix> Ah

[21:13] <SmokeMachine> Zoffix: and @a.skip is 10 times faster than @a[1 .. @a.end]

[21:13] <Zoffix> Sweet

[21:17] <Geth> Â¦ rakudo/nom: a8c6eca78d | (Elizabeth Mattijsen)++ | src/core/set_operators.pm

[21:17] <Geth> Â¦ rakudo/nom: Make Str (elem) Map / Map (cont) Str 50x faster

[21:17] <Geth> Â¦ rakudo/nom:

[21:17] <Geth> Â¦ rakudo/nom: At least.  Because this timing is for a one element hash.  Since these

[21:17] <Geth> Â¦ rakudo/nom: candidates don't need to coerce anything to a Set, the gain for larger

[21:17] <Geth> Â¦ rakudo/nom: Maps / Hashes would be even bigger.

[21:17] <Geth> Â¦ rakudo/nom: review: https://github.com/rakudo/rakudo/commit/a8c6eca78d

[21:18] <lizmat> now, if I would have a way to do MMD on object hashes...

[21:18] <lizmat> I could do the same for Any (elem) ObjHash

[21:19] <Zoffix> Holy shit.

[21:19] <Zoffix> lizmat++

[21:19] <DrForr> lizmat: Before I forget, Perl6::Tidy does some very primitive indentation.

[21:19] <SmokeMachine> lizmat++

[21:20] <SmokeMachine> lizmat: sorry again, but whats MMD?

[21:20] <lizmat> multi method dispatch

[21:20] <SmokeMachine> thanks!

[21:36] <b2gills> That commit does something slightly different to calling .Set, as ï½¢'a' (elem) { 'a' => 0 }ï½£ will now return True but used to return False.

[21:36] <b2gills> I think it is an improvement though, as it makes more sense.

[21:37] <lizmat> argh

[21:37] <lizmat> yes

[21:37] <lizmat> hmmm

[21:38] <lizmat> fwiw, that wasn't picked up by spectesting

[21:38] <lizmat> m: say 'a' (elem) { 'a' => 0 }

[21:38] <camelia> rakudo-moar a8c6ec: OUTPUT: Â«Trueâ¤Â»

[21:39] <lizmat> argh, too late  :-)

[21:53] <nebuchadnezzar> lizmat: isn't bisectable6 here for that purpose?

[21:54] <nebuchadnezzar> I confess I'm a little bit lost will the bots

[21:54] <Geth> Â¦ rakudo/nom: 5aebaf1fe4 | (Elizabeth Mattijsen)++ | src/core/set_operators.pm

[21:54] <Geth> Â¦ rakudo/nom: Fix Str (elem) Map / Map (elem) Str for False values

[21:54] <Geth> Â¦ rakudo/nom:

[21:54] <Geth> Â¦ rakudo/nom: As b2gills++ pointed out, we still need Set semantics.  So we

[21:54] <Geth> Â¦ rakudo/nom: actually need to check the value truthiness.  This reduces the

[21:54] <Geth> Â¦ rakudo/nom: speed increase from 50x to 15x.  Again, for a 1 elem hash.  Larger

[21:54] <Geth> Â¦ rakudo/nom: maps / hashes should be much faster still.

[21:54] <Geth> Â¦ rakudo/nom: review: https://github.com/rakudo/rakudo/commit/5aebaf1fe4

[22:02] * lizmat has done enough damage for today

[22:02] <lizmat> good night, #perl6-dev!

[22:10] <Zoffix> night

[23:31] <samcv> night

[23:37] <Zoffix> night

[23:43] <SmokeMachine> m: my %a = 1 => {2 => {3 => 42}}; say %a{1;2;3}:exists

[23:43] <camelia> rakudo-moar 5aebaf: OUTPUT: Â«Trueâ¤Â»

[23:43] <SmokeMachine> m: my %a = 1 => {2 => {3 => 42}}; say %a{1,1;2;3}:exists

[23:43] <camelia> rakudo-moar 5aebaf: OUTPUT: Â«(True True)â¤Â»

[23:44] <SmokeMachine> m: my %a = 1 => {2 => {3 => 42}}; say %a{1;*;3}:exists # I think I forgot this case... what should it return?

[23:44] <camelia> rakudo-moar 5aebaf: OUTPUT: Â«Falseâ¤Â»

[23:46] <SmokeMachine> m: my %a = 1 => {2 => {3 => 42}}; say %a{1;*;3}

[23:46] <camelia> rakudo-moar 5aebaf: OUTPUT: Â«(42)â¤Â»

[23:51] <Zoffix> m: .say with do with 42 { $_ }

[23:51] <camelia> rakudo-moar 5aebaf: OUTPUT: Â«42â¤Â»

[23:51] * Zoffix loves it
