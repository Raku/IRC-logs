[00:08] <japhb> .oO( "I'd like to buy the channel a [Coke], and keep it company ..." )

[00:13] <TimToady> japhb: === should be exactly what you want, as long as you don't need to compare Junction or Mu objects

[00:14] <TimToady> and if it's slow, we oughta find out why

[00:16] <TimToady> now off to the #perl6 backlog...

[00:18] <japhb> TimToady: Ah, now that I look more closely, === tries to treat a value type differently.  But for general classes not derived from a builtin value type, I guess it should just fall back to the base case, which shouldn't be horribly slow for my use case.

[00:22] <notviki> note that general case compares .perl outputs, so it'll give a false positive if two objects differ only by their private attributes.

[00:24] <TimToady> er, isn't that eqv that does that?

[00:24] <TimToady> === shouldn't be

[00:25] <TimToady> === should be defaulting to ObjAt comparison or so

[00:26] <TimToady> only value types should be using .WHICH comparisons under eqv

[00:27] <notviki> oh, maybe I'm misremembering...

[00:27] <notviki> s: &infix:<eqv>

[00:27] <SourceBaby> notviki, Sauce is at https://github.com/rakudo/rakudo/blob/6703b4c/src/core/Mu.pm#L844

[00:27] <notviki> s: &infix:<===>

[00:27] <SourceBaby> notviki, Sauce is at https://github.com/rakudo/rakudo/blob/6703b4c/src/core/Any.pm#L464

[00:27] <TimToady> m: say [1,2,3].WHICH

[00:27] <camelia> rakudo-moar 6703b4: OUTPUT«Array|75527936␤»

[00:27] <TimToady> yeah, that's an ObjAt

[00:28] <TimToady> I guess it's okay if eqv is used to compare those for the default ===

[00:28] <notviki> Yeah, sorry. It's eqv that does that, not ===

[00:28] <dalek> nqp: b3d3e08 | MasterDuke17++ | src/NQP/Actions.nqp:

[00:28] <dalek> nqp: Just a whitespace fix

[00:28] <dalek> nqp: review: https://github.com/perl6/nqp/commit/b3d3e08683

[00:29] <notviki> currently it compares nqp::eqaddr and .WHICHes as strings

[00:30] <TimToady> well, our signal for value types currently goes through .WHICH, which is stringy, but we could probably speed that up for known value types

[00:31] <notviki> m: dd set('a Str|b') === set([<a b>])

[00:31] <camelia> rakudo-moar 6703b4: OUTPUT«Bool::True␤»

[00:31] <TimToady> yes, that too

[00:31] <TimToady> as I recall we speculated a special type for that, but NYI

[00:32] <TimToady> in fact, ObjAt is that speculated type

[00:33] <TimToady> m: say 42.WHICH.WHAT

[00:33] <camelia> rakudo-moar 6703b4: OUTPUT«(ObjAt)␤»

[00:33] <TimToady> which it is, at least there

[00:35] <TimToady> m: say set([<a b>]).keys[0].WHAT

[00:35] <camelia> rakudo-moar 6703b4: OUTPUT«(Str)␤»

[00:36] <TimToady> m: say set([<a b>]).keys[0].WHICH.WHAT

[00:36] <TimToady> hmm

[00:36] <camelia> rakudo-moar 6703b4: OUTPUT«(ObjAt)␤»

[00:37] <TimToady> okay, just a Str collision inside ObjAt, I guess

[00:38] <TimToady> but something inside should be noticing that a Str and an Array are different types and rejecting === equivalence

[00:39] <TimToady> m: say 'a Str|b' === [<a b>]

[00:39] <camelia> rakudo-moar 6703b4: OUTPUT«False␤»

[00:40] <TimToady> m: say 'a Str|b'.WHICH === [<a b>].WHICH

[00:40] <camelia> rakudo-moar 6703b4: OUTPUT«False␤»

[00:40] <TimToady> m: say [<a b>].WHICH

[00:40] <camelia> rakudo-moar 6703b4: OUTPUT«Array|49578936␤»

[00:42] <TimToady> m: say set([<a b>]).WHICH

[00:42] <camelia> rakudo-moar 6703b4: OUTPUT«Set|Str|a Str|b␤»

[00:43] <TimToady> okay, just an injection attack :)

[00:46] <TimToady> m: say set(<a b>).WHICH  # the extra [] confused my lizard^Wp5 brane

[00:46] <camelia> rakudo-moar 6703b4: OUTPUT«Set|Str|a Str|b␤»

[00:47] <TimToady> these new-fangled 1-arg semantics...

[00:51] <notviki> m: dd set [<a b>], [<c e>]

[00:51] <camelia> rakudo-moar 6703b4: OUTPUT«set("a","c","b","e")␤»

[00:51] <notviki> Isn't what I expected it to end up as....  (set of two arrays)

[00:54] <TimToady> m: say &set.signature

[00:54] <camelia> rakudo-moar 6703b4: OUTPUT«(*@a --> Set)␤»

[00:54] <TimToady> I guess it's * rather than +

[00:54] <TimToady> did someone change that at some point?

[00:55] * notviki has no idea

[00:55] <TimToady> m: dd Set.new: [<a b>], [<c e>]

[00:55] <camelia> rakudo-moar 6703b4: OUTPUT«set($["a", "b"],$["c", "e"])␤»

[00:56] <timotimo> i didn't think we would still be vulnerable to the injection of wrong strings

[01:05] <TimToady> I guess set/bag listops have been flattening for a good long while, probably from before GLR

[01:06] <samcv> TimToady, RE \c[unicode name], was \c intended to allow using unicode 1 names?

[01:06] <samcv> because there is 1 test in 6.c-errata which tests that, and in master there are far more. testing unicode 1 names

[01:07] <samcv> but i don't know if that was intended at all

[01:07] * TimToady is not quite sure what you mean by 'unicode 1 names'

[01:07] <samcv> m: say "\n".uniname

[01:07] <camelia> rakudo-moar 6703b4: OUTPUT«LINE FEED (LF)␤»

[01:07] <samcv> that

[01:08] <samcv> that's a unicode 1 name. currently it has no unicode name, but it has unicode alias'

[01:08] <samcv> namely: "LINE FEED" and "LF"

[01:08] <samcv> are its official unicode alias names

[01:08] <samcv> but it is tested as \c[LINE FEED (LF)]

[01:08] <samcv> we do test \c[LF] btw which is an alias name

[01:09] <TimToady> well, I dunno that we have to stay that backward compatible

[01:09] <TimToady> that's a rather klunky name

[01:09] <samcv> yeah. i don't really like having to rely on unicode 1 names

[01:09] <samcv> exactly :\

[01:09] <samcv> i think we should only do actual unicode names and unicode alias names, so LINE FEED and LF will work

[01:10] <samcv> and for example NULL is an alias name for U+000

[01:10] <samcv> even though it has no unicode name

[01:10] <TimToady> that seems fine to me; I tend to doubt anyone is relying on that, when there have always been shorter ways, like \n or \x0a

[01:10] <samcv> yeah

[01:13] <samcv> the only cases where the unicode 1 names we currently allow for \c and the alias names, are like LINE FEED (LF) where the (LF) is not there and uh one more

[01:13] <samcv> CARRIAGE RETURN (CR)

[01:13] <samcv> yeah those two

[01:14] <diakopter> .u WHITEY SANTA

[01:14] <yoleaux2> No characters found

[01:14] <samcv> plus \c[BELL] is \c[BEL] or \c[ALERT] since BELL conflicts with the emoji bell symbol

[01:14] <diakopter> .u MONGOLIAN SPOT

[01:14] <yoleaux2> No characters found

[01:15] <TimToady> m: say "\a".uniname

[01:15] <camelia> rakudo-moar 6703b4: OUTPUT«BELL␤»

[01:15] <TimToady> oopsie

[01:23] <samcv> so should 6.c-errata be changed?

[01:23] <samcv> to not be LINE FEED (LF) and just LINE FEED?

[01:26] <TimToady> I think I'm okay with treating that as an erratum, though I can well imagine someone squawking, since it's really right on the edge

[01:27] <TimToady> I suppose we could do a deprecation cycle on the u1 names, if anyone thinks we really need it

[01:27] <TimToady> but I'm guess we don't really need it

[01:27] <TimToady> *ssing

[01:39] <samcv> yeah in almost all cases the unicode 1 names and the alias names match up

[01:39] <samcv> in all but like 3 cases

[01:39] <samcv> the CARRIAGE RETURN (CR) and LINE FEED  (LF) and i doubt anybody is using those

[01:39] <samcv> and then \c[BELL] will have to be \c[BEL] because it already conflicted with the bell symbol

[01:40] <samcv> m: "\c[BELL]".ords.say

[01:40] <camelia> rakudo-moar 6703b4: OUTPUT«(7)␤»

[01:40] <timotimo> let's call one ASCII BELL and the other UNICODE BELL

[01:40] <samcv> that's what i thought it would say, the one that came first

[01:40] <timotimo> to give people a really, really hard time

[01:40] <samcv> hehahah

[01:40] <timotimo> or one is "Ring Ring" and the other is "Actually A Bell"

[01:41] <samcv> heh

[01:41] <samcv> that's pretty horrible

[01:41] <samcv> \c[ALERT] is much better than \c[BELL] tbh

[01:44] <TimToady> well, that's why we have \a

[01:45] <samcv> yeah

[01:45] <TimToady> we haven't had actual bells since the ancient ASR-33 or so that I learned to program on back in the dark ages :)

[01:46] <timotimo> surely there's usb-connectable bells that you can hook up to \a

[01:47] <diakopter> 👡

[01:47] <diakopter> .u 👡

[01:47] <yoleaux2> U+1F461 WOMANS SANDAL [So] (👡)

[01:48] <diakopter> .u 👢

[01:48] <yoleaux2> U+1F462 WOMANS BOOTS [So] (👢)

[01:48] <TimToady> so, where's MANS SANDAL?

[01:48] <samcv> u: sandal

[01:48] <unicodable6> samcv, U+1F461 WOMANS SANDAL [So] (👡)

[01:48] <timotimo> men aren't supposed to wear sandals!!

[01:48] <timotimo> be very afraid of the unicode fashion police

[01:49] <diakopter> .u 👞

[01:49] <yoleaux2> U+1F45E MANS SHOE [So] (👞)

[01:49] <TimToady> so where's MANS BOOTS?

[01:49] <diakopter> women get sandals not shoes

[01:50] <diakopter> .u 👞

[01:50] <yoleaux2> U+1F45E MANS SHOE [So] (👞)

[01:50] <diakopter> nooo

[01:50] <diakopter> .u 👯

[01:50] <yoleaux2> U+1F46F WOMAN WITH BUNNY EARS [So] (👯)

[01:51] <diakopter> that's the one men need

[01:51] <TimToady> .u clothes

[01:51] <yoleaux2> U+2EC2 CJK RADICAL CLOTHES [So] (⻂)

[01:51] <yoleaux2> U+2F90 KANGXI RADICAL CLOTHES [So] (⾐)

[01:51] <yoleaux2> U+1F45A WOMANS CLOTHES [So] (👚)

[01:51] <timotimo> bunny ears are fantastic. i want some.

[01:51] <TimToady> so where's MANS CLOTHES?

[01:51] * timotimo heads to bed

[01:52] <timotimo> have a fun unicode time, everybody

[02:19] <samcv> ok so regarding being able to do unicode sequences. so \c[ ] expects to get a plain codepoint back, not a synthetic in nqp

[02:19] <samcv> if it gets back a negative number it assumes it didn't find a codepoint

[02:30] <TimToady> feel free to make it work with graphemes

[02:38] <samcv> ah looks like it calls chr on it. so hm

[02:50] <ugexe> jnthn: if you `zef update` then `zef install Archive::Libarchive` should install now (looks like the author updated their meta6.json to fix this)

[03:05] <samcv> so i guess i will have to add a new op which gets a string from a name

[05:55] <samcv> nice i'm making some good progress on this

[05:56] <samcv> already have the data generating into the database, just have to setup a new hash for this data

[06:46] <samcv> \o/ it works!

[06:47] <samcv> say(nqp::getstrbyname('Santa Claus: light skin tone')) #> 🎅🏻

[06:47] <samcv> sweet

[07:10] <[Tux]> This is Rakudo version 2016.12-264-g6703b4c55 built on MoarVM version 2016.12-71-g331a6b43

[07:10] <[Tux]> csv-ip5xs        2.945

[07:10] <[Tux]> test            13.312

[07:10] <[Tux]> test-t           5.360

[07:10] <[Tux]> csv-parser      13.816

[07:10] <samcv> hi [Tux]

[07:10] <[Tux]> o/

[07:10] <samcv> you ready for emoji-ception

[07:10] <RabidGravy> wee!

[09:04] <Geth> rakudo/nom: f961c025fa | (Elizabeth Mattijsen)++ | src/core/Rakudo/Metaops.pm

[09:04] <Geth> rakudo/nom: Add support for generic op "chain" associativity.

[09:04] <Geth> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/f961c025fa

[09:24] <samcv> nice. Geth doesn't print empty lines :-D

[09:25] <Geth> rakudo/nom: ed5c86616c | (Elizabeth Mattijsen)++ | src/core/List.pm

[09:25] <Geth> rakudo/nom: No need to check for old Z handling anymore

[09:25] <Geth> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/ed5c86616c

[11:49] <lizmat> Files=1164, Tests=56524, 198 wallclock secs (11.19 usr  4.66 sys + 1178.22 cusr 133.64 csys = 1327.71 CPU)

[13:58] <[Coke]> jnthn: coke/bughunt in doc still gets the occasional segfault. (got 5 OK runs, one "broken Promise" run, and then a segfault), with ed5c866

[13:59] <jnthn> I guess that's progress...

[14:00] <notviki> wonder how feasible it would be to make an env var that points to where you want .precomp to be

[14:01] <notviki> it always gets in the way when you, say, grep for stuff in  a repo or `tree` a repo.

[14:01] <notviki> Especially in roast, where there's tons of different .precomps :/

[14:02] <[Coke]> notviki: I tend to use ack for that sort of thing, which lets me ignore stuff pretty easily.

[14:03] <notviki> heh

[14:03] <notviki> right, that's one more thing it interferes it: you have to stuff it into .gitignore

[14:05] * jnthn just does that by now and isn't so bothered by it

[14:05] <notviki> -bash: ack: command not found

[14:05] <jnthn> I'm not sure I work in any languages where I don't need to put something into .gitignore

[14:05] * moritz has to put .swp file in every .gitignore :/

[14:06] <[Coke]> moritz: gah, no, you put it in YOUR gitignore.

[14:06] <notviki> Heh... so the answer is the broken window theory lives :P

[14:10] <notviki> find / -type d -exec perl6 -I '{}' -e '' \;

[14:19] <[Coke]> (docs) perl6 --profile htmlify.p6 segfaults almost immediately.

[14:41] <timotimo> whoops :)

[15:29] <pmurias> rakudo only uses nqp::p6captureouters2?

[15:32] <pmurias> (and the nqp::p6captureouters is obsolete)

[15:40] <jnthn> pmurias: Seems so :)

[15:40] <jnthn> I forget the exact history, but it's likely in the git log :)

[15:49] <pmurias> should I remove the obsolete variant from the jvm?

[15:56] <pmurias> jnthn: if I have 'my $x = 1; role Foo { method bar() {$x} }' what sets the scope for the role method (allowing it to see $x)?

[16:01] <moritz> isn't there even a known bug with role methods not seeing outer lexicals properly?

[16:02] <pmurias> m: my $x = 123; role Foo {method bar() {$x} }; say(Foo.bar)

[16:02] <camelia> rakudo-moar ed5c86: OUTPUT«123␤»

[16:03] <pmurias> moritz: what's the bug?

[16:03] <moritz> pmurias: dunno, might need some more conditions to reproduce, or might be fixed by now

[16:03] <moritz> sorry, I'm really vague here; please ignore me

[16:04] <pmurias> there is such a problem in nqp

[16:16] <ugexe> https://github.com/rakudo/rakudo/blob/nom/src/core/CompUnit/Repository/Installation.pm#L449 Does this look like its not doing the right thing to anyone else? I suspect $dist-id is meant to be the index *before* the sort takes place, because otherwise $dist-id will always be the same: 0

[16:17] <jnthn> pmurias: The method's scope is just that of the role body, it's the role scopes that are interesting. We push them into a list, and then capture them again at module load time

[16:17] <jnthn> I think using the op you were just asking about

[16:18] <Geth> rakudo/nom: 9ad94d783b | (Zoffix Znet)++ | t/06-tap-harness/01-desc-backslashes.t

[16:18] <Geth> rakudo/nom: Fix broken test file

[16:18] <Geth> rakudo/nom:

[16:18] <Geth> rakudo/nom: Missing variable declaration...

[16:18] <Geth> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/9ad94d783b

[16:18] <Geth> rakudo/nom: aee7af356c | (Zoffix Znet)++ | 3 files

[16:18] <Geth> rakudo/nom: Fix TAP::Harness failing on full-file skippage

[16:18] <Geth> rakudo/nom:

[16:18] <Geth> rakudo/nom: The TAP specs[^1][^2] say the SKIP directive should report text

[16:18] <Geth> rakudo/nom: after `# SKIP\S*\s+` as the reason for failure and that `TODO`

[16:18] <Geth> rakudo/nom: directive must have space after `TODO` if explanation follows.

[16:18] <Geth> rakudo/nom:

[16:18] <Geth> rakudo/nom: The current behaviour is we look for SKIP/TODO followed by any

[16:18] <Geth> rakudo/nom: number of *alphanumeric *characters. This fails to match the

[16:18] <Geth> rakudo/nom: full-file skippage as that directive has a `:` char in it (if

[16:18] <Geth> rakudo/nom: we follow the specs' examples that show it as "Skipping: …").

[16:18] <Geth> rakudo/nom:

[16:18] <Geth> rakudo/nom: Fix by making SKIP directive follow the TAP spec \S*\s+ pattern;

[16:18] <Geth> rakudo/nom: <…commit message has 7 more lines…>

[16:18] <Geth> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/aee7af356c

[16:19] <notviki> \o/ no more lazy bots that stop midway through my commit messages

[16:23] <moritz> by the way, is Geth a goth?

[16:23] <notviki> goth? why goth?

[16:23] <perlpilot_> ugexe: isn't $dist-id a filename?

[16:23] <notviki> moritz: http://masseffect.wikia.com/wiki/Geth

[16:24] <moritz> notviki: just for the sake of the pun

[16:25] <ugexe> perlpilot_: ah maybe. i'll have to dig in I guess but that would make sense

[16:27] <ugexe> I also wonder if that *.value<ver> is on a Version object or a Str

[16:27] <ugexe> sort on *.value<ver>^

[16:28] <perlpilot_> ugexe: from line 439, looks like it's a Version object

[16:35] <ugexe> perlpilot_: cool, thanks for digging in for me!

[16:38] * [Coke] wonders if there is something like samemark that is additive instead of destructive.

[16:39] <notviki> destructive?

[16:40] <[Coke]> yes. it replaces all the existing combining marks with the new ones.

[16:40] <notviki> ah

[16:42] * notviki gets a new bot feature idea...

[16:42] <notviki> You give it a pattern for a routine name and it tells greps core ones for that pattern

[16:42] <notviki> only "samemark" matches "mark"

[16:43] * TimToady could see the use of an addmark method

[16:44] <TimToady> or allow multiple arguments to samemark, where all patterns are applied in parallel

[16:44] <TimToady> then addmark just means the 1st arg is the original

[16:45] <[Coke]> that'd work for my use here. (which is the dumb unicode mangler)

[16:45] <[Coke]> huggable: 6.d

[16:45] <huggable> [Coke], Proposals for 6.d language: https://github.com/perl6/specs/blob/master/v6d.pod

[16:47] <TimToady> allowing multiple additive patterns to samemark wouldn't have to wait for 6.d, since it'd be upward compatible

[16:50] * notviki spots a public word-by-word method :/

[16:51] <notviki> m: dd "heh heh".word-by-word

[16:51] <camelia> rakudo-moar aee7af: OUTPUT«Too few positionals passed; expected 2 or 3 arguments but got 1␤  in block <unit> at <tmp> line 1␤␤»

[16:51] <notviki> m: dd "heh heh".word-by-word: "heh"

[16:51] <camelia> rakudo-moar aee7af: OUTPUT«"heh heh"␤»

[16:53] <notviki> m: dd "heh heh".word-by-word: "\x[308]", *.contains("heh").not

[16:53] <camelia> rakudo-moar aee7af: OUTPUT«Too many positionals passed; expected 1 argument but got 2␤  in block <unit> at <tmp> line 1␤␤»

[16:53] <notviki> s: "", 'word-by-word'

[16:53] <SourceBaby> notviki, Sauce is at https://github.com/rakudo/rakudo/blob/aee7af3/src/core/Str.pm#L1993

[16:54] <notviki> it can take two args....

[16:55] <notviki> ah

[16:55] <notviki> m: dd "heh heh".word-by-word: "\x[308]", {$^a, $^b; $a.contains("heh").not }

[16:55] <camelia> rakudo-moar aee7af: OUTPUT«This type cannot unbox to a native string: P6opaque, Bool␤  in block <unit> at <tmp> line 1␤␤»

[16:55] <notviki> m: dd "heh heh".word-by-word: "\x[308]", {$^a, $^b; $a.contains("heh").not.Str }

[16:55] <camelia> rakudo-moar aee7af: OUTPUT«"False False"␤»

[17:01] <[Coke]> Is there a way to get the marks from a string? (save the intermediate work samemark is doing)

[17:02] <notviki> m: "é".codes».uniname.say

[17:02] <camelia> rakudo-moar aee7af: OUTPUT«(START OF HEADING)␤»

[17:02] <notviki> :|

[17:03] <notviki> m: "é".codes.say

[17:03] <camelia> rakudo-moar aee7af: OUTPUT«1␤»

[17:03] <notviki> oh right

[17:03] <notviki> m: "é".bytes.say

[17:03] <camelia> rakudo-moar aee7af: OUTPUT«No such method 'bytes' for invocant of type 'Str'␤Did you mean '.encode($encoding).bytes'?␤  in block <unit> at <tmp> line 1␤␤»

[17:03] <[Coke]> m: "é".NKFD>>uniname.say

[17:03] <camelia> rakudo-moar aee7af: OUTPUT«===SORRY!=== Error while compiling <tmp>␤Missing dot on method call␤at <tmp>:1␤------> "é".NKFD>>⏏uniname.say␤    expecting any of:␤        method arguments␤        postfix␤»

[17:03] <[Coke]> m: "é".NKFD>>.uniname.say

[17:03] <camelia> rakudo-moar aee7af: OUTPUT«No such method 'NKFD' for invocant of type 'Str'␤  in block <unit> at <tmp> line 1␤␤»

[17:04] <notviki> m: "é".NFD».uniname.say

[17:04] <camelia> rakudo-moar aee7af: OUTPUT«(LATIN SMALL LETTER E COMBINING ACUTE ACCENT)␤»

[17:04] <notviki> m: dd "é".NFD

[17:04] <camelia> rakudo-moar aee7af: OUTPUT«Uni.new(0x0065, 0x0301).NFD␤»

[17:04] <notviki> m: "é".NFD».uniname.elems.say

[17:04] <camelia> rakudo-moar aee7af: OUTPUT«2␤»

[17:04] <notviki> oh ok

[17:04] <notviki> m: dd "é".NFD».uniprop

[17:04] <camelia> rakudo-moar aee7af: OUTPUT«("Ll", "Mn")␤»

[17:05] <notviki> m: dd "é\x[308]".NFD».uniprop

[17:05] <camelia> rakudo-moar aee7af: OUTPUT«("Ll", "Mn", "Mn")␤»

[17:06] <notviki> m: dd Uni.new(|"a".NFD, |"é\x[308]".NFD[1..*]).Str

[17:06] <camelia> rakudo-moar aee7af: OUTPUT«"á̈"␤»

[17:06] <notviki> w00t

[17:07] <[Coke]> heh.

[17:11] <notviki> m: dd Uni.new(0x0308 xx 500_000).Str

[17:11] <camelia> rakudo-moar aee7af: OUTPUT«(signal SEGV)»

[18:16] <travis-ci> Rakudo build failed. Zoffix Znet 'Fix TAP::Harness failing on full-file skippage

[18:16] <travis-ci> https://travis-ci.org/rakudo/rakudo/builds/190661975 https://github.com/rakudo/rakudo/compare/ed5c86616c98...aee7af356cc8

[18:16] <buggable> [travis build above] ☠ Did not recognize some failures. Check results manually.

[18:22] <notviki> o-oh

[18:22] <notviki> ZOFVM: Files=1213, Tests=133499, 161 wallclock secs (22.09 usr  3.02 sys + 3073.64 cusr 254.09 csys = 3352.84 CPU)

[18:32] <notviki> hm t/04-nativecall/14-rw-attrs.t ............ Failed 16/16 subtests

[18:33] <notviki> and the other job "t/04-nativecall/06-struct.t .............. No subtests run"

[18:37] <Geth> nqp: e3cf5bc85d | (Jonathan Worthington)++ | tools/build/MOAR_REVISION

[18:37] <Geth> nqp: Bump to get latest MoarVM.

[18:37] <Geth> nqp: review: https://github.com/perl6/nqp/commit/e3cf5bc85d

[18:37] <camelia> nqp-moarvm: OUTPUT«Confused at line 2, near "e3cf5bc85d"␤   at gen/moar/stage2/NQPHLL.nqp:765  (/home/camelia/rakudo-m-inst-1/share/nqp/lib/NQPHLL.moarvm:panic)␤ from gen/moar/stage2/NQP.nqp:908  (/home/camelia/rakudo-m-inst-1/share/nqp/lib/nqp.moarvm:comp_unit)␤ from gen/moar…»

[18:37] <camelia> nqp-moarvm: OUTPUT«Confused at line 2, near "Bump to ge"␤   at gen/moar/stage2/NQPHLL.nqp:765  (/home/camelia/rakudo-m-inst-1/share/nqp/lib/NQPHLL.moarvm:panic)␤ from gen/moar/stage2/NQP.nqp:908  (/home/camelia/rakudo-m-inst-1/share/nqp/lib/nqp.moarvm:comp_unit)␤ from gen/moar…»

[18:37] <camelia> nqp-moarvm: OUTPUT«Confused at line 2, near "review: ht"␤   at gen/moar/stage2/NQPHLL.nqp:765  (/home/camelia/rakudo-m-inst-1/share/nqp/lib/NQPHLL.moarvm:panic)␤ from gen/moar/stage2/NQP.nqp:908  (/home/camelia/rakudo-m-inst-1/share/nqp/lib/nqp.moarvm:comp_unit)␤ from gen/moar…»

[18:37] <notviki> oh boy

[18:37] <notviki> I guess camelia *did* have ignore on dalek :P

[18:37] <ugexe> heh

[18:38] * notviki will fix shortly

[18:44] <AlexDaniel> notviki: what about making sure that it doesn't write something that can trigger a bot?

[18:44] <AlexDaniel> for example

[18:45] <AlexDaniel> nqp¦ Bump to get latest MoarVM.

[18:46] <AlexDaniel> broken bar is part of latin-1 so…

[18:46] <notviki> star: use LWP::Simple; dd LWP::Simple.post: "http://geth.perl6.party/?chan=%23zofbot", {"X-GitHub-Event" => "push"}, '{"repository":{"name":"nqp", "full_name":"fakety-fake"},"ref": "refs/heads/meows","commits":[{"message":"Zoffix was here", "id":"meowmeow", "added":[], "removed": [], "modified":["fakety.fake"],"author":{"name":"fake Zoffix"}}]}'

[18:47] <camelia> star-m 2016.10: OUTPUT«"OK"␤»

[18:48] <AlexDaniel> because at some point it can also start triggering whateverable

[18:48] <AlexDaniel> so what now, make all bots ignore Geth just because it is printing stuff in a way that looks like a command?

[18:49] <notviki> star: use LWP::Simple; dd LWP::Simple.post: "http://geth.perl6.party/?chan=%23perl6-dev", {"X-GitHub-Event" => "push"}, '{"repository":{"name":"nqp", "full_name":"fakety-fake"},"ref": "refs/heads/master","commits":[{"message":"Zoffix was here", "id":"meowmeow", "added":[], "removed": [], "modified":["fakety.fake"],"author":{"name":"fake Zoffix"}}]}'

[18:49] <Geth> nqp: meowmeow | (fake Zoffix)++ | fakety.fake

[18:49] <Geth> nqp: Zoffix was here

[18:49] <Geth> nqp: review: https://github.com/fakety-fake/commit/meowmeow

[18:49] <camelia> star-m 2016.10: OUTPUT«"OK"␤»

[18:49] <notviki> There. Fixed fover \o/

[18:50] <notviki> AlexDaniel: dalek has been doing that for years and no one blinked an eye. You know whether the source is at. If it bothers you, change it: https://github.com/zoffixznet/geth

[18:50] <AlexDaniel> :S

[18:51] <notviki> AlexDaniel: https://github.com/zoffixznet/geth/blob/master/lib/Geth/Plugin/GitHub.pm6#L124

[18:52] <geekosaur> the usual convention is output a leading space, then bots ignore anything with a leading space. or use /notify for output and bots only accept commands via /msg (remembering that channel messages are /msg #chan)

[18:52] <Geth> rakudo/nom: e182deb529 | (Jonathan Worthington)++ | tools/build/NQP_REVISION

[18:52] <Geth> rakudo/nom: Get latest MoarVM.

[18:52] <Geth> rakudo/nom:

[18:52] <Geth> rakudo/nom: * Improvements to memory management of various aspects of invocation

[18:52] <Geth> rakudo/nom:   records (aka call frames), greatly reducing memory pressure in a

[18:52] <Geth> rakudo/nom:   number of cases, especially in applications that produce and store a

[18:52] <Geth> rakudo/nom:   large number of closures. Up to 20% improvement to CORE.setting

[18:52] <Geth> rakudo/nom:   build time and ~10% peak memory use reduction observed.

[18:52] <Geth> rakudo/nom: * I/O memory buffers properly contribute to full collection criteria,

[18:53] <Geth> rakudo/nom:   reducing memory overhead required.

[18:53] <Geth> rakudo/nom: * Fix an occasional heap profiler crash, and prevent heap profiler

[18:53] <Geth> rakudo/nom:   from greatly reducing the number of full GC collections.

[18:53] <Geth> rakudo/nom: * Prevent specializer log slots from keeping alive, and so leaking,

[18:53] <Geth> rakudo/nom: <…commit message has 3 more lines…>

[18:53] <Geth> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/e182deb529

[18:53] <notviki> neat

[18:53] <jnthn> But what if I saved the most exciting thing until last? :P

[18:53] <jnthn> (I didn't. :P)

[18:54] <[Coke]> jnthn: DAMMIT.

[18:54] <Geth> roast: 65979128a2 | (Jonathan Worthington)++ | S32-str/utf8-c8.t

[18:54] <Geth> roast: Tests to cover MoarVM #482.

[18:54] <Geth> roast: review: https://github.com/perl6/roast/commit/65979128a2

[18:54] <[Coke]> fooled me, anyway. :)

[18:54] <jnthn> Well, it's exciting if you were hit by either of the two final fixes mentioned I guess :)

[18:55] <diakopter> can bisectable do timing comparisons

[18:55] <AlexDaniel> m: say ‘hello’

[18:55] <camelia> rakudo-moar aee7af: OUTPUT«hello␤»

[18:55] <[Coke]> re-building and re-testing my doc repo weirdness...

[18:55] <diakopter> or evalable or whatever

[18:55] <[Coke]> diakopter: include a time check that you chunk out into seconds or something?

[18:55] <AlexDaniel> diakopter: you will have to do ｢(now - BEGIN now) < 2｣ or something like this

[18:56] <Geth> roast: f52aef7a62 | (Jonathan Worthington)++ | S19-command-line/arguments.t

[18:56] <Geth> roast: Unfudge a now-passing test.

[18:56] <Geth> roast: review: https://github.com/perl6/roast/commit/f52aef7a62

[18:56] <TimToady> people should really get in the habit of using INIT now rather than BEGIN now, or you won't be safe from any kind of precompilation

[18:56] <diakopter> yeah, I wad just curious about the raw nqp man-or-boy (closure heavy) benchmark

[18:57] <diakopter> *was

[18:57] <AlexDaniel> e: say 42

[18:57] <geekosaur> wasn't that benchable?

[18:58] <jnthn> Hm, I was jnthn++ under dalek

[18:58] <AlexDaniel> TimToady++

[18:58] <jnthn> Does Geth source its mappings differently? :)

[18:58] <diakopter> notviki said he preferred the long names

[18:58] <notviki> jnthn: dalek sourced them from rakudo/rakudo/AUTHORS or something,  did it?

[18:59] <AlexDaniel> benchable can also give some timing information, yes

[18:59] <TimToady> 'sides, INIT is one character shorter, and one handed (plus shift)

[18:59] <notviki> Well, I said that in response to "most people would want github usernames"

[18:59] <AlexDaniel> but I'm not sure if it's going to work, I don't remember the last time I used benchable

[18:59] <notviki> diakopter: how does dalek do it? rakudo's AUTHORs?

[19:00] <AlexDaniel> TimToady: you're assuming a specific keyboard layout

[19:00] <diakopter> yes, with a few hardcoded overrides in addition

[19:00] <lizmat> Stage parse      :  52.099   # wee,. was ~60 before for me

[19:00] <TimToady> AlexDaniel: sure, but that's a pretty safe assumption for the vast majority of people

[19:01] <TimToady> and I'd like you to fine me a keyboard where typing INIT takes more keystrokes than BEGIN :P

[19:01] <notviki> star: use LWP::Simple; dd LWP::Simple.post: "http://geth.perl6.party/?chan=%23perl6-dev", {"X-GitHub-Event" => "push"}, '{"repository":{"name":"nqp", "full_name":"fakety-fake"},"ref": "refs/heads/master","commits":[{"message":"Zoffix was here", "id":"meowmeow", "added":[], "removed": [], "modified":["fakety.fake"],"author":{"name":"fake Zoffix"}}]}'

[19:01] <Geth> nqp: meowmeow | (fake Zoffix)++ | fakety.fake

[19:01] <camelia> star-m 2016.10: OUTPUT«"OK"␤»

[19:01] <Geth> nqp: Zoffix was here

[19:01] <Geth> nqp: review: https://github.com/fakety-fake/commit/meowmeow

[19:02] <diakopter> hehe that's cool

[19:02] <TimToady> *find

[19:02] <AlexDaniel> TimToady: actually, I'm not sure what you're talking about. I don't know a layout where INIT can be written with one hand, so I think I misunderstood you completely

[19:02] <jnthn> lizmat: Yeah, and it's some seconds off all the later stages too :)

[19:02] <notviki> \o/

[19:02] <TimToady> AlexDaniel: oh, yeah, there's that pesky T

[19:02] <TimToady> hmm

[19:02] <lizmat> wonders what that will have done for test-t

[19:02] <lizmat> [Tux]  ??   ^^^

[19:03] <jnthn> lizmat: Hard to say.

[19:03] <diakopter> well which one tab-completes best

[19:03] <jnthn> lizmat: Though it surely can't have hurt. :-)

[19:03] <AlexDaniel> geekosaur: what about using a zero width space instead?

[19:04] <diakopter> is there an Inline::TypeScript

[19:04] <lizmat> hmmm... spectest doesn't appear to spectacularly faster :-(

[19:05] <jnthn> Yeah, that's going to be in the few percent at best

[19:05] * notviki builds head and tries stresstest

[19:05] <jnthn> Longer-running programs were the main winners from the improvements.

[19:05] <diakopter> that's dominated by startup..

[19:05] <jnthn> Invocation and frame teardown did get simpler for everything

[19:06] <jnthn> But it was the smaller bit of the win.

[19:06] <diakopter> someone could write a test harness for make spectest to run all in one process

[19:06] <notviki> :o

[19:06] <diakopter> actually that would be a great exercise for notviki

[19:06] <jnthn> It may well take down the memory overhead of spectest6

[19:06] <notviki> me?

[19:06] <notviki> why me?

[19:07] <diakopter> because you know the language and you're fast

[19:07] <notviki> :o

[19:07] <jnthn> Rest, dinner, etc. &

[19:07] <geekosaur> AlexDaniel, mostly it's to make it easier to also hide other stuff from bots when needed. maybe you can type that character easily...

[19:08] <diakopter> what's spectest6

[19:08] <AlexDaniel> ​nqp: Bump to get latest MoarVM.

[19:08] <notviki> diakopter: spectest, but using Perl 6 TAP::Harness instead of perl5's prove

[19:08] <lizmat> diakopter: basically "HARNESS_TYPE=6 make spectest"

[19:09] <lizmat> notviki: is "make test" supposed to run the t/06-tap-harness tests ?

[19:09] <diakopter> oh I see. well someone could probably make a threaded one in one process

[19:10] <notviki> lizmat: no, it's not added into the list yet. I should find time and massage failing test files and update make test to run all that's runnable

[19:10] <lizmat> diakopter: the perl6 version uses Proc::Async, afaik, so yes, it does that already (in a way)

[19:10] <lizmat> notviki: oki

[19:10] <diakopter> well I mean to save on startup

[19:11] <notviki> we'

[19:11] <notviki> we'd likely still net-lose, due to Perl 6 and not Perl 5

[19:11] <diakopter> if there's a failure, it could fall back to processes for a real test

[19:12] <lizmat> jnthn: as a datapoint: the tests out of sync problems appear to be gone, but the "No such method 'end-entries' for invocant of type 'Match'" (aka, calling a method on the wrong object, or v.v.) is still there

[19:13] <lizmat> so I guess we still have a race condition in grammars  :-(

[19:15] <notviki> the out of sync stuff sounds like the "\" in test description bug that got fixed...

[19:15] <lizmat> ah, could be  :-)

[19:15] <notviki> wonder if the end-entries stuff is a test flapping and some buggy-path in TAP::Harness gets walked

[19:16] <notviki> ZOFVM: Files=1213, Tests=133501, 144 wallclock secs (23.08 usr  3.03 sys + 2583.24 cusr 195.21 csys = 2804.56 CPU)

[19:16] <lizmat> notviki: note it's not always "end-entries", it is a bunch of other methods called on the wrong object

[19:16] <notviki> And earlier today that was: Files=1213, Tests=133499, 161 wallclock secs (22.09 usr  3.02 sys + 3073.64 cusr 254.09 csys = 3352.84 CPU)

[19:16] <notviki> lizmat: oh :(

[19:17] <notviki> m: dd [ 3352.83 - 2804.56, 161-144]

[19:17] <camelia> rakudo-moar e182de: OUTPUT«[548.27, 17]␤»

[19:17] <notviki> seems like a nice win for stresstest \o/

[19:18] * notviki tries HARNESS_TYPE=6 make stresstest

[19:18] <notviki> Oh and Stage parse      :  59.380 :)

[19:18] <notviki> Was in the 70s recently

[19:19] <[Coke]> jnthn: so when I tested it earlier, I didn't think about "in moar but not yet in rakudo" - latest version is mainly 'Tried to get the result of a broken Promise' in coke/bughunt

[19:20] <notviki> uhhh... that didn't take long: "Unhandled exception in code scheduled on thread 56" No such method 'made' for invocant of type 'TAP::Runner::State'

[19:20] <lizmat> notviki: what I said, it's not always "end-entries"  :-(

[19:22] <notviki> Second run went further but crashed with "Error in `/home/cpan/CPANPRC/rakudo/install/bin/moar': double free or corruption (out): 0x00007f8005c44f40 ***"

[19:23] <notviki> third time a charm? :)

[19:25] <notviki> "Unhandled exception in code scheduled on thread 14" "Cannot call method 'Stringy' on a null object"

[19:25] <notviki> Well, that was good fun.

[19:32] <notviki> w00t... 4th charm a charm: Files=1188, Tests=133315,  333 wallclock secs

[19:32] <notviki> Result: PASS

[19:34] <notviki> hm... weird that it counted fewer files but more tests

[19:34] <notviki> m: say 1213-1188

[19:34] <camelia> rakudo-moar e182de: OUTPUT«25␤»

[19:35] <notviki> 25 files missing. Oh and not more tests, just ~70 fewer

[19:38] <lizmat> notviki: yeah, I think that's another indication something's wrong  :-(

[19:42] <lizmat> argh

[19:43] <lizmat> So I have made Zop 13x faster

[19:43] <lizmat> but it breaks on ZII, Zor, Z&& and Zand because of fetching values when they technically wouldn't need to

[19:43] <lizmat> aka

[19:44] <lizmat> m: my $a = 0; dd 0 Zand ($a++,); dd $a

[19:44] <camelia> rakudo-moar e182de: OUTPUT«(0,).Seq␤Int $a = 0␤»

[19:45] <lizmat> so the above would now say: Int $a = 1

[19:45] <lizmat> grrrr

[19:47] <notviki> :(

[19:49] <lizmat> I can't help but think: do we really need that ?

[19:49] <lizmat> I mean:

[19:49] <lizmat> m: my $a = 0; dd &[and](0,$a++); dd $a

[19:49] <camelia> rakudo-moar e182de: OUTPUT«0␤Int $a = 1␤»

[19:51] <notviki> here it gets computed before it even reached the routine tho

[19:51] <TimToady> m: my $a = 0; dd [and](0,$a++); dd $a

[19:51] <camelia> rakudo-moar e182de: OUTPUT«0␤Int $a = 0␤»

[19:51] <notviki> :o

[19:51] <notviki> m: my $a = 0; dd [and] 0, $a++; dd $a

[19:51] <camelia> rakudo-moar e182de: OUTPUT«0␤Int $a = 0␤»

[19:52] <notviki> crazy

[19:52] <TimToady> well, it knows the operator at compile time, and how it thunks

[19:52] <notviki> Ah

[19:52] <TimToady> with &foo, you don't

[19:52] <TimToady> could as easily be $foo(0, $a++)

[19:53] <Geth> rakudo/nom: 8654389832 | (Elizabeth Mattijsen)++ | src/core/Rakudo/Metaops.pm

[19:53] <Geth> rakudo/nom: Add support for generic "non" op, and fastpath &[,]

[19:53] <Geth> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/8654389832

[19:53] <TimToady> and yes, it was insane to make [and] thunk properly, almost as insane as [^^]

[19:53] <TimToady> m: my $a = 0; dd [^^](0,$a++); dd $a

[19:53] <camelia> rakudo-moar e182de: OUTPUT«0␤Int $a = 1␤»

[19:53] <TimToady> m: my $a = 0; dd [^^](0,$a++,$a++); dd $a

[19:53] <camelia> rakudo-moar e182de: OUTPUT«1␤Int $a = 2␤»

[19:53] <TimToady> m: my $a = 0; dd [^^](1,$a++,$a++); dd $a

[19:53] <camelia> rakudo-moar e182de: OUTPUT«Nil␤Int $a = 2␤»

[19:54] <TimToady> hmm

[19:54] <lizmat> TimToady: so I gather you wanna keep it?

[19:54] <TimToady> keep what?

[19:54] <TimToady> reduce thunking correctly?

[19:54] <lizmat> m: my $a = 0; dd 0 Zand ($a++,); dd $a   # $a = 0 rather than 1

[19:54] <camelia> rakudo-moar e182de: OUTPUT«(0,).Seq␤Int $a = 0␤»

[19:54] <TimToady> m: my $a = 0; dd [^^](1,++$a,$a++); dd $a

[19:54] <camelia> rakudo-moar e182de: OUTPUT«Nil␤Int $a = 1␤»

[19:55] <TimToady> well, that seems correct too

[19:56] * lizmat goes back to the drawing board

[19:56] <TimToady> but you can't do it with normal high-order functions unless you thunk everything on spec

[20:01] <TimToady> and that's a recipe for slow, not to mention all the bad press Algol got for making swap impossibly by using call-by-name semantics

[20:01] <TimToady> *ble

[20:02] <lizmat> well, Zop *is* 13 times faster now, also for Zand

[20:02] <lizmat> it's just that the side effects are applied always

[20:02] <lizmat> for each element of the Zip

[20:02] <TimToady> so yeah, our metaops are thunk aware in a way that HOP can't emulate unless you make everything lazy

[20:03] <TimToady> but if you're Haskell, you don't have the side effects anyway :)

[20:03] <lizmat> TimToady: but they only need to be thunk aware on and/or/&&/||/xor/^^ right ?

[20:04] <TimToady> but you can't know that's what you have with $foo(0,$a++)

[20:04] <lizmat> I *can* know which metaop is being applied, and take the lazy path for those

[20:04] <lizmat> and take the fast path for all the others

[20:04] <TimToady> so I think the current division at the operator vs function boundary is probably a bit saner than trying to guess whether the &foo is too indirect

[20:06] <TimToady> you can probably still combine the implementations to some extent, but I'd really like to preserve the thunky behavior of the ops, since it was a lot of work to get right in the first place :)

[20:06] <lizmat> hence the tests for it  :-)

[20:06] <TimToady> ayup

[20:07] <lizmat> so, by the looks of it, this applies for all ops that have &op.prec('thunky').starts-with('.')

[20:07] <lizmat> or for all ops that have any thunky ?

[20:08] <TimToady> well, xx is thunky in the 1st arg

[20:09] <TimToady> and so is RRxx :)

[20:09] <lizmat> m: dd 1,2 Zxx 2,3

[20:09] <camelia> rakudo-moar e182de: OUTPUT«((1, 1), (2, 2, 2)).Seq␤»

[20:10] <notviki> wow cool!

[20:10] <TimToady> m: dd rand,rand Zxx 2,3

[20:10] <camelia> rakudo-moar e182de: OUTPUT«((0.0977303009167496e0, 0.0771304285501788e0), (0.422388783553719e0, 0.602094833607288e0, 0.434087383252164e0)).Seq␤»

[20:10] <TimToady> note each rand is thunky there

[20:11] <TimToady> m: dd 2,3 ZRxx rand,rand

[20:11] <camelia> rakudo-moar 865438: OUTPUT«((0.367301135044424e0, 0.276367978963408e0), (0.949134865005526e0, 0.347063326826044e0, 0.777447812991421e0)).Seq␤»

[20:11] <TimToady> and there

[20:14] <bartolin> r: use nqp; class A { has Mu $!foo; method bar () { $!foo := Any; say nqp::isnull($!foo) ?? "null" !! $!foo } }.new.bar  # RT #130532

[20:14] <camelia> rakudo-moar 865438, rakudo-jvm fb4f16: OUTPUT«(Any)␤»

[20:14] <bartolin> sorry, this one:

[20:14] <bartolin> r: use nqp; class A { has Mu $!foo; method bar () { $!foo := nqp::null; say nqp::isnull($!foo) ?? "null" !! $!foo } }.new.bar  # RT #130532

[20:14] <camelia> rakudo-moar 865438: OUTPUT«null␤»

[20:14] <camelia> ..rakudo-jvm fb4f16: OUTPUT«(Mu)␤»

[20:16] <bartolin> does anyone has an idea, where that behaviour of r-j could stem from (which code area)

[20:17] <bartolin> j: use nqp; my Mu $foo; $foo := nqp::null; say nqp::isnull($foo) ?? "null" !! $foo  # this works

[20:17] <camelia> rakudo-jvm fb4f16: OUTPUT«null␤»

[20:19] <samcv> morning perl 6 dev o/

[20:20] <notviki> \o

[20:20] <bartolin> hi samcv

[20:20] <samcv> hey

[20:20] <lizmat> samcv o/

[20:27] <lizmat> m: m: my $a = 0; dd 0,1,0 Zand $a++,$a++,$a++; dd $a   # TimToady: do you consider this to be correct ?

[20:27] <camelia> rakudo-moar 865438: OUTPUT«(0, 0, 0).Seq␤Int $a = 1␤»

[20:28] <TimToady> seems right, since only one LHS is true

[20:29] <lizmat> ok, so the fact that the first $a++ isn't executed, affects the outcome of the 2nd

[20:30] <lizmat> and that's to be expected

[20:31] <notviki> m: m: my $a = 0; dd 0,1,0 Zand ++$a,++$a,++$a;

[20:31] <camelia> rakudo-moar 865438: OUTPUT«(0, 1, 0).Seq␤»

[20:31] <notviki> amazing...

[20:31] <notviki> oh...

[20:32] <notviki> the fact that the second gets executed but doesn't affect the third one?

[20:32] <notviki> m: m: my $a = 0; dd 0,1,0 Zand ++$a,++$a,++$a; dd $a

[20:32] <camelia> rakudo-moar 865438: OUTPUT«(0, 1, 0).Seq␤Int $a = 1␤»

[20:32] <notviki> m: m: my $a = 0; dd 0,1,1 Zand ++$a,++$a,++$a; dd $a

[20:32] <camelia> rakudo-moar 865438: OUTPUT«(0, 1, 2).Seq␤Int $a = 2␤»

[20:32] <notviki> oh never mind me

[20:49] <Geth> rakudo/nom: f66d4b3a58 | (Elizabeth Mattijsen)++ | 2 files

[20:49] <Geth> rakudo/nom: Put the new Zop handling live for 13x improvement

[20:49] <Geth> rakudo/nom:

[20:49] <Geth> rakudo/nom: - except for thunky.starts-with('.') ops

[20:49] <Geth> rakudo/nom:   these are lazy in the fetching of values from the iterators in a

[20:49] <Geth> rakudo/nom:   way that I haven't fully grokked, so we're using the old code for

[20:49] <Geth> rakudo/nom:   those cases.  This includes: Zand, Z&&, Zor, Z||, Zxor, Z^^

[20:49] <Geth> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/f66d4b3a58

[20:51] <travis-ci> Rakudo build passed. Jonathan Worthington 'Get latest MoarVM.

[20:51] <travis-ci> https://travis-ci.org/rakudo/rakudo/builds/190709721 https://github.com/rakudo/rakudo/compare/aee7af356cc8...e182deb52990

[21:19] <Geth> rakudo/nom: 9a11eacdb2 | (Elizabeth Mattijsen)++ | src/core/Rakudo/Internals.pm

[21:19] <Geth> rakudo/nom: ReifiedListIterator can have its own "skip-one"

[21:19] <Geth> rakudo/nom:

[21:19] <Geth> rakudo/nom: Because it is as easy as incrementing the index:

[21:19] <Geth> rakudo/nom:

[21:19] <Geth> rakudo/nom:   $ 6 '$_ = (1,2,3).iterator; .skip-one; dd .pull-one'

[21:19] <Geth> rakudo/nom:   2

[21:19] <Geth> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/9a11eacdb2

[21:24] <lizmat> m: my $a = 0; try (1,2,3,4,++$a) >>+<< (3,4,5); dd $a   # TimToady: is it ok if that would say 0 in the future ?

[21:24] <camelia> rakudo-moar f66d4b: OUTPUT«Int $a = 1␤»

[21:25] <lizmat> aka, not reify the entire list, but fail as soon as one of the iterators returns IterationEnd and the other doesn't ?

[21:49] <samcv> how2 generate stageX moarvm for nqp. i think that's the issue i'm seeing

[21:49] <samcv> No registered operation handler for 'getstrbyname'

[21:49] <samcv> because the stage wasn't compiled with that op, so won't let me compile nqp to use this op right?

[21:53] <samcv> make m-bootstrap-files ?

[22:24] <lizmat> samcv: no idea  :-(

[22:27] <lizmat> m: my $a = 0; try (1,2,3,4,++$a) >>+<< (3,4,5); dd $a   # TimToady jnthn: is it ok if that would say 0 in the future ?

[22:27] <camelia> rakudo-moar 9a11ea: OUTPUT«Int $a = 1␤»

[22:28] <lizmat> m: dd (1,2 >>+<< 2,3).WHAT   # also, is there a reason this is a List and not a Seq ?

[22:28] <camelia> rakudo-moar 9a11ea: OUTPUT«List␤»

[22:37] * lizmat hopes to see an answer for this tomorrow

[22:37] <lizmat> good night, #perl6-dev!

[22:38] <notviki> night

[23:05] <samcv> ok well i figured out probably (maybe) how to reget but i still get that error

[23:05] <samcv> make m-bootstrap-files

[23:17] <samcv> oh i got it. was a stupid mistake

[23:34] <samcv> because jvm and js don't have nqp::getstrfromname which will be in mvm soon. i was thinking of making a getstrfromname routine for those, that just calls nqp::char(nqp::codepointfromname)

[23:34] <samcv> does this sound like a good idea? because i want to change Actions.nqp to use the new function, and allow us to use it in rakudo as well

[23:35] <samcv> the functions act identically except getstrfromname also adds additional things which are multiple codepoints like emoji sequences and potentially other things in the future

[23:45] <samcv> notviki, any clue on this?

[23:46] <notviki> nope, sorry

[23:46] <samcv> also can i do #?if jvm js

[23:48] <notviki> samcv: don't think so, but the script that cares about those is this one: https://github.com/rakudo/rakudo/blob/nom/tools/build/gen-cat.nqp#L29-L39

[23:48] <notviki> (no idea if anything else does)

[23:52] <samcv> can i improve it?

[23:52] <samcv> well answer is probably yes

[23:53] <samcv> i want #?if #?else

[23:53] <samcv> i don't think we support else

[23:55] <notviki> buggable was using 2.5GB of RAM :(

[23:55] <notviki> need to dig up what's leaking in it...

[23:55] <timotimo> you can definitely do #?if !moar

[23:55] <notviki> oh

[23:56] <notviki> ah, right there's the ('!')? in that regex

[23:56] <notviki> samcv: ^

[23:56] <samcv> oh ok

[23:56] <samcv> yay
