[00:00] <Geth> rakudo/nom: 7f970357bd | (Samantha McVey)++ | t/spectest.data

[00:00] <Geth> rakudo/nom: Remove duplicate test

[00:00] <Geth> rakudo/nom:

[00:00] <Geth> rakudo/nom: GraphemeBreakTest.t provides the same functionality

[00:00] <Geth> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/7f970357bd

[00:02] <Geth> roast: db27cf25ab | (Samantha McVey)++ | 2 files

[00:02] <Geth> roast: Remove duplicate test and testgen

[00:02] <Geth> roast:

[00:02] <Geth> roast: GraphemeBreakTest.t provides the same and has been updated for Unicode

[00:02] <Geth> roast: 9.0

[00:02] <Geth> roast: review: https://github.com/perl6/roast/commit/db27cf25ab

[00:39] <samcv> m: multi sub prefix:<[~]>(*@a where {$_.all ~~ Str}) returns Str {    @a.join('');}; say [~] 'thing', 'this'

[00:39] <camelia> rakudo-moar 7f9703: OUTPUT¬´thingthis‚ê§¬ª

[00:40] <samcv> so this works, but it fails if they try and use Int's or other Cool things. and if I use Cool, then it fails if it's undefined yet, something they use

[00:40] <samcv> would it be bad to not do type check and just have things coernce to strings by doing join? which is kind of what [~] already does.

[00:40] <samcv> this [~] special case is 3x+ faster

[00:41] <samcv> m: say [~] 1,2,3

[00:41] <camelia> rakudo-moar 7f9703: OUTPUT¬´123‚ê§¬ª

[00:42] <samcv> m: my $var; say [~] $var, 1, 3;

[00:42] <camelia> rakudo-moar 7f9703: OUTPUT¬´Use of uninitialized value $var of type Any in string context.‚ê§Methods .^name, .perl, .gist, or .say can be used to stringify it to something meaningful.‚ê§  in block <unit> at <tmp> line 1‚ê§13‚ê§¬ª

[00:42] <samcv> ok so i guess that doesn't work

[00:42] <samcv> oh wait. yeah it does output 13 so

[00:42] <samcv> we probably shouldn't have to do typechecks here

[00:42] <samcv> m: say [~] DateTime.new.now;

[00:42] <camelia> rakudo-moar 7f9703: OUTPUT¬´Cannot call DateTime.new with no parameters‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§Actually thrown at:‚ê§  in any  at gen/moar/Metamodel.nqp line 3072‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[00:43] <samcv> m: say [~] DateTime.now;

[00:43] <camelia> rakudo-moar 7f9703: OUTPUT¬´2017-01-16T01:43:03.493890+01:00‚ê§¬ª

[00:43] <samcv> yeah

[00:44] <samcv> yeah it's like 10x faster

[00:53] <brokenchicken> m: multi sub prefix:<[~]> { @_.join }; for ^100_000 { $ = [~] 42, ".".IO, "foo" }; say now - INIT now

[00:53] <camelia> rakudo-moar 7f9703: OUTPUT¬´WARNINGS for <tmp>:‚ê§Useless use of constant string "foo" in sink context (lines 1, 1)‚ê§2.41212390‚ê§¬ª

[00:53] <brokenchicken> m: multi sub prefix:<[~]> is looser(&[,]) { @_.join }; for ^100_000 { $ = [~] 42, ".".IO, "foo" }; say now - INIT now

[00:53] <camelia> rakudo-moar 7f9703: OUTPUT¬´5.83574109‚ê§¬ª

[00:54] <brokenchicken> m: for ^100_000 { $ = [~] 42, ".".IO, "foo" }; say now - INIT now

[00:54] <camelia> rakudo-moar 7f9703: OUTPUT¬´5.34457378‚ê§¬ª

[01:01] <samcv> it won't let me use *@a in the signature for the Str.pm file. complaining about don't change the grammar

[01:01] <samcv> or maybe because it's a prefix

[01:02] <samcv> idk

[01:02] <brokenchicken> Is it still faster tho, when you make its precedence right?

[01:03] <timotimo> if you define an operator in the setting that hasn't been declared in the grammar first, that'll cause a very expensive operation not only during compilation, but during every startup

[01:04] <samcv> ah ok

[01:04] <samcv> well 10x faster is a pretty big speedup. so i would hope the answer is yes

[01:05] <timotimo> i tried to make <[~]> use .join a long time ago, but there was something that spoke against it ... i've forgotten what it was :(

[01:07] <samcv> ah

[01:07] <timotimo> maybe it was just something i did wrong, though

[01:08] <brokenchicken> samcv: but how do you get 10x? My eval above shows it as a few percent slower...

[01:08] <timotimo> camelia is not very good for measuring

[01:09] <samcv> what were you concatening, not strings right?

[01:09] <samcv> concatening strings it's much faster

[01:09] <samcv> and the case you tested, it's a tiny bit slower but not too much

[01:09] <brokenchicken> timotimo: not for 1000% faster vs 7% slower :P

[01:10] <brokenchicken> m: multi sub prefix:<[~]> is looser(&[,]) { @_.join }; for ^100_000 { $ = [~] "x", "y", "foo" }; say now - INIT now

[01:10] <camelia> rakudo-moar 7f9703: OUTPUT¬´2.8740187‚ê§¬ª

[01:10] <brokenchicken> m: multi sub prefix:<[~]> is looser(&[,]) { @_.join }; for ^100_000 { $ = [~] "x", "y", "foo" }; say now - INIT now

[01:10] <camelia> rakudo-moar 7f9703: OUTPUT¬´2.92866880‚ê§¬ª

[01:10] <brokenchicken> m: for ^100_000 { $ = [~] "x", "y", "foo" }; say now - INIT now

[01:10] <camelia> rakudo-moar 7f9703: OUTPUT¬´2.82883002‚ê§¬ª

[01:10] <brokenchicken> m: for ^100_000 { $ = [~] "x", "y", "foo" }; say now - INIT now

[01:10] <camelia> rakudo-moar 7f9703: OUTPUT¬´2.8594142‚ê§¬ª

[01:10] <timotimo> with only three short strings you're not going to measure much improvement

[01:10] <timotimo> also, are you sure it's running the exact sub you declared?

[01:11] <brokenchicken> So what's the version with 10x improvement?

[01:11] <samcv> concatening strings

[01:11] <brokenchicken> -_-

[01:11] <samcv> just strings

[01:11] <brokenchicken> forget it

[01:11] <samcv> you talking to me timotimo ? yeah i am

[01:11] <timotimo> no i meant brokenchicken

[01:11] <samcv> ah ok

[01:12] <timotimo> with the camelia eval

[01:16] <brokenchicken> samcv: we have a special case for [+]; try sticking the [~] in there: https://github.com/rakudo/rakudo/blob/7f97035/src/core/metaops.pm#L180

[01:20] <timotimo> on a related note, this is one of the coolest hacks involving .join that i know:

[01:20] <timotimo> m: say <[ ]>.join("this goes in the middle")

[01:20] <camelia> rakudo-moar 7f9703: OUTPUT¬´[this goes in the middle]‚ê§¬ª

[01:22] <timotimo> anyway, i'm really hoping to get good sleep tonight

[01:22] <timotimo> seeya!

[06:54] <lizmat> Files=1163, Tests=56128, 188 wallclock secs (11.06 usr  4.49 sys + 1123.74 cusr 116.58 csys = 1255.87 CPU)

[07:02] <raiph> hi lizmat

[07:04] <raiph> .ask lizmat cf http://stackoverflow.com/questions/41668358/how-can-i-use-a-non-caching-infinite-lazy-list-in-perl-6#comment70539046_41670048 Do you recall the downsides of the original rule that an `@` sigil or explicit `.cache` indicates caching of a lazy list/sequence and a `my \foo...` or `my $foo` indicates no caching? (Am I imagining it used t

[07:04] <yoleaux2> raiph: I'll pass your message to lizmat.

[07:04] <raiph> o be that way?)

[07:04] <lizmat> hmmm...

[07:04] <yoleaux2> 07:04Z <raiph> lizmat: cf http://stackoverflow.com/questions/41668358/how-can-i-use-a-non-caching-infinite-lazy-list-in-perl-6#comment70539046_41670048 Do you recall the downsides of the original rule that an `@` sigil or explicit `.cache` indicates caching of a lazy list/sequence and a `my \foo...` or `my $foo` indicates no caching? (Am I imagining it used t

[07:05] <lizmat> may not be quite awake yet  :-)

[07:05] <raiph> i'm just about asleep, so I guess we're even :)

[07:06] <raiph> (2am here)

[07:07] <lizmat> hmmm... first time I see a .skip-at-least-pull-one in the wild  :-)

[07:08] <lizmat> raiph: I think without the caching, we would see many more X::Seq::Consumed errors

[07:08] <lizmat> in the core specifically

[07:09] <lizmat> situations like : if @a { say @a }

[07:09] <lizmat> does that make sense to you ?

[07:10] <samcv> nice lizmat

[07:10] <samcv> that seems cool. the skip-at-least-pull-one. even though it is super long

[07:11] <lizmat> yeah, you should know what you're doing if you're using that one  :-)

[07:11] <raiph> lizmat: I thought the `@` in `@a` implied caching

[07:11] <samcv> you have made iterator faster right lizmat ?

[07:12] <samcv> have you tested iterating over like 300,000 things?

[07:12] <raiph> lizmat: so I don't understand why `if @a { @a }` would cause a problem

[07:12] <lizmat> raiph: yes, it does, but we also tried to not make it cache during the GLR

[07:12] <samcv> seems to spend a lot of time in the iterator but not sure if the profiler is just telling me it's happening inside the iterator or if the iterator itself is using a lot of cpu

[07:12] <lizmat> and then things like: if @a { say @a } would break

[07:12] <samcv> let me check the last profile i made

[07:13] <lizmat> samcv: I haven't touched the Iterator role for a while now

[07:13] <samcv> ah

[07:13] <samcv> https://github.com/rakudo/rakudo/commit/f761d34a54485a9d971f1790d5cc34aee4bdc58b ok just roundrobin then?

[07:13] <lizmat> samcv: yea

[07:14] <lizmat> expecting to push R:It.CrossIterables in the next few hours

[07:15] <samcv> this is a new method?

[07:15] <samcv> returns a list of shared items?

[07:15] <samcv> atm i iterate over all codpoints and then inside that loop iterate over all the things in the enum hash or the boolean value hash for unicode database

[07:16] <samcv> takes a while

[07:17] <samcv> it's probably normal for it to tell me it spent lots of time in sink of src/core/Seq.pm right?

[07:17] <samcv> when iterating over things

[07:18] <samcv> then under that it says <anon> in any-iterable-methods.pm

[07:18] <raiph> lizmat: thanks for answers

[07:18] <raiph> goodnight #perl6

[07:18] <samcv> night raiph

[07:23] <samcv> maybe it will be faster If I make one iterable and iterate through the same one? instead of calling `%code-to-prop.keys.sort(+*)` inside of the block where i iterate per codepoint

[07:25] <lizmat> night raiph

[07:26] <lizmat> well, there's still an issue in Any-iterable-methods that for some reason needs a block inside some nqp code

[07:26] <lizmat> at least it did in the past, perhaps I should revisit that  :-)

[07:27] <samcv> iterables get consumed though right?

[07:28] <lizmat> not necessarily

[07:28] <lizmat> an Iterable is a class that provides an .iterator method

[07:28] <samcv> ok so probably would be fastest to call sort, and then save that sequence?

[07:29] <lizmat> an Array is also an Iterable

[07:29] <samcv> instead of for every port calling .sort(+*) on the property names?

[07:29] <lizmat> but it could be completely reified, and thus not "consume" anything

[07:29] <samcv> or does it magically optimize it

[07:29] <lizmat> no magic yet, I'm afraid

[07:29] <lizmat> do you have a gist ?

[07:29] <samcv> sec

[07:29] <samcv> https://gist.github.com/744caecc3a10f6d66056727dc9b9354b

[07:30] <samcv> https://gist.github.com/samcv/744caecc3a10f6d66056727dc9b9354b#file-ucd-gen-p6-L447 see here

[07:30] <[Tux]> This is Rakudo version 2016.12-337-g7f970357b built on MoarVM version 2016.12-115-ged2df9ac

[07:30] <[Tux]> csv-ip5xs        2.800

[07:30] <[Tux]> test            12.484

[07:30] <[Tux]> test-t           5.081

[07:30] <[Tux]> csv-parser      13.955

[07:30] <samcv> this part is the slowest part I think

[07:31] <samcv> and for some reason if I don't put quietly it warns me about Any used in a string context‚Ä¶

[07:31] <samcv> i have no clue what that's about. because if i uncomment the "say $point" below it, it always prints out a value

[07:32] <samcv> and it shows that warning even if i I don't sort by number and just do string sorting

[07:33] <samcv> wow ok it took 26 minutes to run the whole script ;P

[07:33] <lizmat> well, I see that the inner loop is sorting %code-to-prop.keys.sort(+*) over and over again

[07:33] <lizmat> perhaps you should take that out of the loop and do it once ?

[07:33] <samcv> yeah

[07:33] <samcv> that's what I was thinking

[07:49] <samcv> lizmat, how do i construct a nqp array?

[07:49] <samcv> when coding in perl 6

[07:50] <samcv> oh maybe it's just failing for nqp::bootintarray. nqp::array seems to allow me to assign it to a variable

[07:51] <timotimo> nqp::bootintarray gives you the type for a bootint array

[07:51] <timotimo> you then need to create it

[07:51] <samcv> ah ok

[07:51] <timotimo> nqp::list and friends create it for you

[07:52] <timotimo> nqp::list_i will also give you a bootintarray, i believe

[07:52] <lizmat> indeed

[07:52] <timotimo> but it'll create it for you, and i think it also lets you directly put stuff into the argument list

[07:52] <samcv> Type check failed in binding; expected Positional but got List ($())

[07:52] <samcv> that's what i get when i try nqp::list. that was the first thing I tried

[07:52] <samcv> maybe because i assigned it to an @array?

[07:54] <timotimo> right, you have to type your variable Mu, and most likely use a $ sigil

[07:54] <samcv> ah ok

[07:55] <samcv> m: use nqp; my $array := nqp::list_i; nqp::push_i($array, 2).say

[07:55] <camelia> rakudo-moar 7f9703: OUTPUT¬´2‚ê§¬ª

[07:55] <samcv> that seems to work

[07:55] <samcv> m: use nqp; my $array := nqp::list_i; nqp::push_i($array, 2); say nqp::elems($array)

[07:55] <camelia> rakudo-moar 7f9703: OUTPUT¬´1‚ê§¬ª

[07:55] <samcv> ok cool

[07:56] <timotimo> m: use nqp; my $array := nqp::list_i(2); .say for @$array

[07:56] <camelia> rakudo-moar 7f9703: OUTPUT¬´Cannot find method 'cache': no method cache and no .^find_method‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[07:56] <timotimo> m: use nqp; my $array := nqp::list_i(2); .say for $array

[07:56] <camelia> rakudo-moar 7f9703: OUTPUT¬´Cannot find method 'map': no method cache and no .^find_method‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[07:56] <timotimo> m: use nqp; my $array := nqp::list_i(2); $array[$_].say for ^$array.elems

[07:56] <camelia> rakudo-moar 7f9703: OUTPUT¬´Cannot find method 'elems': no method cache and no .^find_method‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[07:56] <timotimo> m: use nqp; my $array := nqp::list_i(2); $array[$_].say for ^nqp::elems($array)

[07:56] <camelia> rakudo-moar 7f9703: OUTPUT¬´X::Multi::NoMatch exception produced no message‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[07:56] <timotimo> m: use nqp; my $array := nqp::list_i(2); nqp::atpos($array, $_).say for ^nqp::elems($array)

[07:56] <camelia> rakudo-moar 7f9703: OUTPUT¬´MVMArray: atpos expected int register‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[07:56] <samcv> what's the NoMatch, it can't match the type?

[07:56] <timotimo> m: use nqp; my $array := nqp::list_i(2); say nqp::atpos($array, $_) for ^nqp::elems($array)

[07:56] <camelia> rakudo-moar 7f9703: OUTPUT¬´MVMArray: atpos expected int register‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[07:57] <timotimo> m: use nqp; my $array := nqp::list_i(2); say (my int $a = nqp::atpos($array, $_)) for ^nqp::elems($array)

[07:57] <camelia> rakudo-moar 7f9703: OUTPUT¬´MVMArray: atpos expected int register‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[07:57] <timotimo> m: use nqp; my $array := nqp::list_i(2); say (my int $a = nqp::atpos($array, $_.Int)) for ^nqp::elems($array)

[07:57] <camelia> rakudo-moar 7f9703: OUTPUT¬´MVMArray: atpos expected int register‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[07:57] <timotimo> :\

[07:57] <timotimo> probably from not being able to call postcircumfix:<[ ]> on a not-even-derived-from-Mu

[07:57] <samcv> ah

[07:58] <lizmat> list_i is problematic like that  :-(

[07:58] <timotimo> oh!

[07:59] <timotimo> m: use nqp; my $array := nqp::list_i(2); say nqp::atpos_i($array, $_) for ^nqp::elems($array)

[07:59] <camelia> rakudo-moar 7f9703: OUTPUT¬´2‚ê§¬ª

[07:59] <samcv> m:  use nqp; my $array := nqp::list_i; nqp::push_i($array, 2); nqp::join(' ',$array)

[07:59] <camelia> rakudo-moar 7f9703: OUTPUT¬´MVMArray: atpos expected int register‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[07:59] <samcv> how can i join an int array?

[07:59] <timotimo> i forgot that you have to _i

[07:59] <samcv> ah

[07:59] <timotimo> you can't, you'll have to manually stringify the parts

[07:59] <samcv> ok

[07:59] <timotimo> you can join a string array, i believe. but string arrays are hardly more efficient than regular object arrays

[08:00] <samcv> i'll just make a list_s then

[08:00] <samcv> ah

[08:00] <samcv> in that case i'll just make one huge array and then do it all at once or something

[08:03] <timotimo> may i ask what you're doing? porting the unicode generator to perl6? or tests or something?

[08:03] <samcv> the unicode generator

[08:04] <timotimo> cool

[08:04] <samcv> making the bitfield rows and making the point index are the two slowest parts of the code

[08:04] <samcv> and easy enough to write in nqp if i can figure out how to do it :P

[08:06] <lizmat> nqp::join on a list_s is *much* faster than a HLL Str.join

[08:13] <samcv> is there a nqp op for variable assignment, or just use := in perl 6 code?

[08:14] <timotimo> you're better off using :=, i believe

[08:16] <timotimo> i wonder if someone wants to give moarvm an appveyor config at some point

[08:17] <samcv> well that was much faster

[08:17] <samcv> that would be nice

[08:17] <timotimo> oh?

[08:17] <samcv> nqp::while($iter,

[08:17] <samcv> $string := nqp::concat(nqp::concat($string, nqp::base_I(nqp::shift($iter), 10)), ',')

[08:17] <samcv> );

[08:18] <timotimo> you're lucky that we have ropes

[08:18] <timotimo> otherwise concatenating strings over and over like that would get you in performance trouble

[08:19] <lizmat> samcv: in my experience, nqp::push_s to a list_s, and then nqp::join is generally faster

[08:19] <samcv> ok I will do that

[08:19] <samcv> simpler too

[08:19] <lizmat> but please benchmark: don't take my word for it  :-)

[08:19] <samcv> well. though

[08:20] <samcv> I have to uhm split every such length though

[08:20] <samcv> to fit it onto lines

[08:20] <timotimo> you could do it after the join :P

[08:20] <timotimo> (well, then you'd have to find the location of spaces and such)

[08:21] <samcv> well of commas but yeah

[08:31] <Geth> rakudo/nom: 1842af41c0 | (Elizabeth Mattijsen)++ | src/core/Rakudo/Iterator.pm

[08:31] <Geth> rakudo/nom: Introducing R:It.CrossIterables(|Map|Op)

[08:31] <Geth> rakudo/nom:

[08:31] <Geth> rakudo/nom: The future workhorse of Xop

[08:31] <Geth> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/1842af41c0

[08:42] <Geth> rakudo/nom: 8a3ff7b64b | (Elizabeth Mattijsen)++ | src/core/List.pm

[08:42] <Geth> rakudo/nom: Make X and cross(...,:with) about 5x faster

[08:42] <Geth> rakudo/nom:

[08:42] <Geth> rakudo/nom: By using the new R:It.CrossIterables logic.  Still looking at the

[08:42] <Geth> rakudo/nom: METAOP_CROSS handling.

[08:42] <Geth> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/8a3ff7b64b

[08:55] <lizmat> hmmm... getting segfaults  :-(

[08:55] <timotimo> what, by using your iterables? :o

[08:56] <lizmat> yeah  :-(

[08:56] <lizmat> in METAOP_CROSS

[08:56] <lizmat> https://gist.github.com/lizmat/815429b57a30915c8a732b626e7f3c8f  # diff

[08:57] <lizmat> $ 6 'dd "000" ... "077"'

[08:57] <lizmat> Segmentation fault: 11

[08:57] <timotimo> i'll have a look

[08:57] <lizmat> not sure how *that* relates to Xop, but there you go  :(

[08:58] <timotimo> ugh

[09:05] <lizmat> ... does wind up in METAOP_CROSS

[09:06] <timotimo> could be it splits that up into 0..0 and 0..7 and Xes that?

[09:06] <lizmat> could be

[09:07] <timotimo> how did we put an object with a null STable pointer into the multi cache?

[09:07] * lizmat is unsure  :-)

[09:07] <timotimo> hold on

[09:08] <lizmat> I don''t think I added any multis in the last few commits

[09:08] <lizmat> hmmm... it *is* using the new code

[09:08] <timotimo> i think i confused the arg array with the multi cache contents

[09:12] * timotimo turns optimize off in the hopes of getting sane stuff in gdb

[09:12] <timotimo> so ... we're somehow calling some function with a nulled out register

[09:12] <timotimo> and trying to find a node for it in the cache we accidentally deref to get its STable

[09:13] <timotimo> from SETTING::src/core/Rakudo/Iterator.pm:855  (/home/timo/perl6/install/share/perl6/runtime/CORE.setting.moarvm:pull-one)

[09:15] <timotimo> well, it probably shouldn't segfault if you manage to do that, so i'll put in a null check

[09:15] <timotimo> but can you figure out what call passes a null in the first argument?

[09:15] <lizmat> that's the pull-one, it's not supposed to take an argument apart from the iterator object

[09:16] <lizmat> so that would imply the iterator object got nulled ?

[09:17] <timotimo> no, there's one more call frame on the stack

[09:17] <timotimo> so it's something the pull-one calls that asplodes

[09:17] <timotimo> at <unknown>:1  (/home/timo/perl6/install/share/perl6/runtime/CORE.setting.moarvm:)

[09:17] <timotimo> ^- really not very helpufl

[09:18] <lizmat> hmmm.... that *could* be the mapper

[09:18] <timotimo> sprinkle some debug says ;)

[09:18] <lizmat> yeah, doing that now  :-)

[09:26] <timotimo> huh

[09:26] <timotimo> now it's exploding because a null made it into the argument of getcodeobj

[09:26] <lizmat> timotimo: it's definitely the mapper call: the first time it's ok, the second it isn't

[09:27] <lizmat> guess I found a source of chaos  :-)

[09:27] <timotimo> at <unknown>:1  (/home/timo/perl6/install/share/perl6/runtime/CORE.setting.moarvm:outer)

[09:27] <timotimo> from SETTING::src/core/Backtrace.pm:222  (/home/timo/perl6/install/share/perl6/runtime/CORE.setting.moarvm:)

[09:27] <timotimo> from SETTING::src/core/Backtrace.pm:240  (/home/timo/perl6/install/share/perl6/runtime/CORE.setting.moarvm:outer-caller-idx)

[09:28] <timotimo> <Internal error while creating backtrace: getcodeobj needs a code ref   in method outer at SETTING::src/core/Code.pm line 26

[09:28] <timotimo> in block  at SETTING::src/core/Backtrace.pm line 222

[09:28] <timotimo> in method outer-caller-idx at SETTING::src/core/Backtrace.pm line 240

[09:28] <timotimo> what fun!

[09:29] <lizmat> -                      (my $result := $!mapper($!next)),

[09:29] <lizmat> +                      (my $result := $!mapper(nqp::clone($!next))),

[09:29] <lizmat> that fixes it

[09:29] <lizmat> I guess I cannot depend on the op not destroying the IterationBuffer

[09:30] <lizmat> running full spectest now

[09:30] <timotimo> oh no, clones :\

[09:30] <timotimo> also ... congrats on getting a null frame into the call stack somehow

[09:31] <timotimo> hum. the error i now get is MVMArray cannot shift from empty array

[09:31] <timotimo> (that's before the "internal error" line above)

[09:38] <Geth> rakudo/nom: 2e80df0467 | (Elizabeth Mattijsen)++ | src/core/Rakudo/Iterator.pm

[09:38] <Geth> rakudo/nom: Prevent segfault on "000" ... "077"

[09:38] <Geth> rakudo/nom:

[09:38] <Geth> rakudo/nom: This apparently uses X~ underneath, and that caused a segfault if

[09:38] <Geth> rakudo/nom: the result buffer wasn't cloned before applying the op.

[09:38] <Geth> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/2e80df0467

[09:38] <samcv> how do I get the name of a variable? my $var; say $var.name #> var

[09:39] <lizmat> m: my $a = 42; say $a.VAR.name

[09:39] <camelia> rakudo-moar 8a3ff7: OUTPUT¬´$a‚ê§¬ª

[09:40] <samcv> nice

[09:43] <samcv> m: my @a; my $var2 = 10; @a.push($var2); for @a { .VAR.name.say }

[09:43] <camelia> rakudo-moar 8a3ff7: OUTPUT¬´@a‚ê§¬ª

[09:43] <samcv> it loses its name when it gets added to args right

[09:43] <samcv> any way for a sub to know the name of the variables it's passed?

[09:44] <samcv> using slurpy *@args

[09:44] <timotimo> hm, you can try "is raw" on it

[09:45] <lizmat> m: $ 6 'sub a(*@a is raw) { dd @a[0].VAR.name }; a(my $b = 42)  # yup, TIL  :-)

[09:45] <camelia> rakudo-moar 8a3ff7: OUTPUT¬´5===SORRY!5=== Error while compiling <tmp>‚ê§Two terms in a row‚ê§at <tmp>:1‚ê§------> 3$7‚èè5 6 'sub a(*@a is raw) { dd @a[0].VAR.nam‚ê§    expecting any of:‚ê§        infix‚ê§        infix stopper‚ê§        statement end‚ê§        statement modif‚Ä¶¬ª

[09:45] <lizmat> m: sub a(*@a is raw) { dd @a[0].VAR.name }; a(my $b = 42)  # yup, TIL  :-)

[09:45] <camelia> rakudo-moar 8a3ff7: OUTPUT¬´"\$b"‚ê§¬ª

[09:45] <samcv> nice.

[09:47] <Geth> rakudo/nom: a26f51361b | (Elizabeth Mattijsen)++ | src/core/metaops.pm

[09:47] <Geth> rakudo/nom: Make Xop about 7x faster

[09:47] <Geth> rakudo/nom:

[09:47] <Geth> rakudo/nom: Except for the Xand family, which is still using the old code.

[09:47] <Geth> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/a26f51361b

[09:49] <timotimo> what is Xand?

[09:50] <moritz> m: say (0, 1) Xand (3,4 9

[09:50] <camelia> rakudo-moar 8a3ff7: OUTPUT¬´5===SORRY!5=== Error while compiling <tmp>‚ê§Two terms in a row‚ê§at <tmp>:1‚ê§------> 3say (0, 1) Xand (3,47‚èè5 9‚ê§    expecting any of:‚ê§        infix‚ê§        infix stopper‚ê§        statement end‚ê§        statement modifier‚ê§        state‚Ä¶¬ª

[09:50] <moritz> m: say (0, 1) Xand (3,4)

[09:50] <camelia> rakudo-moar 8a3ff7: OUTPUT¬´(0 0 3 4)‚ê§¬ª

[09:50] <moritz> X meta op at work

[09:50] <samcv> I can reduce compilation time by putting things in a module right? and if the code in the module doesn't change, compiling a long program will be faster

[09:51] <timotimo> yeah, usually

[09:51] <lizmat> m: dd (0,1) Xand (1,0)

[09:51] <camelia> rakudo-moar a26f51: OUTPUT¬´(0, 0, 1, 0).Seq‚ê§¬ª

[09:52] <timotimo> i'm not sure why that's a special case, but okay :)

[09:52] <timotimo> 7x faster is pretty fantastic

[09:53] <lizmat> m: my $a = 0; dd ((0,1) Xand ($a++,$a++); say $a

[09:53] <camelia> rakudo-moar a26f51: OUTPUT¬´5===SORRY!5=== Error while compiling <tmp>‚ê§Unable to parse expression in parenthesized expression; couldn't find final ')' ‚ê§at <tmp>:1‚ê§------> 3 = 0; dd ((0,1) Xand ($a++,$a++); say $a7‚èè5<EOL>‚ê§    expecting any of:‚ê§        postfix‚ê§   ‚Ä¶¬ª

[09:53] <lizmat> m: my $a = 0; dd (0,1) Xand ($a++,$a++); say $a

[09:53] <camelia> rakudo-moar a26f51: OUTPUT¬´(0, 0, 0, 1).Seq‚ê§2‚ê§¬ª

[09:53] <lizmat> hmmm

[09:54] <lizmat> yeah, not 4

[09:54] <lizmat> the short-circuiting is what makes them special

[09:54] <timotimo> ah, that makes sense

[09:55] <timotimo> so they have an additional level of closure there?

[09:55] * timotimo BBL

[09:55] <lizmat> timotimo: I'm not grokking that part quite yet, TBH

[10:08] <samcv> nqp::base_I($i, 10) is how to go from int to str base 10 right? or is there one only for base 10?

[10:08] <samcv> or is that it

[10:09] <lizmat> https://github.com/perl6/nqp/blob/master/docs/ops.markdown says:

[10:09] <lizmat> base_I(Int $i, int $radix)

[10:09] <lizmat> Returns a string representing the integer $i in base $radix

[10:09] <samcv> well I know it works

[10:09] <samcv> just wondering if there was one that just assumed it was base 10

[10:09] <lizmat> doesn't appear to be one

[10:10] <samcv> kk

[10:10] <samcv> also do integer operands to nqp ops have to unbox every time?

[10:10] <samcv> or no

[10:10] <samcv> if i run the same thing a bajillion times

[10:11] <jnthn> Integer ops or big integer ops?

[10:11] <arnsholt> You can unbox them by binding them to a natively typed thing

[10:11] <jnthn> Int is always a boxed type; there's no unboxing/boxing since there's no native bigint

[10:11] <samcv> it's just the number 10 in the source file

[10:12] <samcv> kk arnsholt that's what i had tried. but wasn't sure if it automatically did it only once

[10:12] <jnthn> Ah, you're asking if the 10 to nqp::base_I(...) will generate unbox code every time?

[10:12] <samcv> i was doing my $i := unbox_i(10) or whatever

[10:12] <samcv> yeah that jnthn

[10:13] <arnsholt> I don't think that should be necessary

[10:13] <jnthn> Pretty sure we'll code-gen it directly as a native int

[10:13] <samcv> ok good

[10:13] <jnthn> my $i := nqp::unbox_i(10); is pointless fwiw

[10:13] <jnthn> Since binding to an untyped Scalar will force boxing of it again

[10:14] <Geth> rakudo/nom: babfc3ced5 | (Elizabeth Mattijsen)++ | src/core/Rakudo/Metaops.pm

[10:14] <Geth> rakudo/nom: Make error message on 1 Xcmp 2 Xcmp 3 a bit clearer

[10:14] <Geth> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/babfc3ced5

[10:15] <samcv> oh

[10:15] <samcv> you can't bind to a typed value though

[10:16] <samcv> is there a base_i? i don't see one

[10:16] <samcv> so I have to box it before calling base_I?

[10:18] <Geth> roast: 0634c5aa5e | (Elizabeth Mattijsen)++ | S03-metaops/cross.t

[10:18] <Geth> roast: Unfudge now passing test

[10:18] <Geth> roast:

[10:18] <Geth> roast: Still not sure what the stance is on being more specific on the error

[10:18] <Geth> roast: being thrown.  So not specifying error just yet.

[10:18] <Geth> roast: review: https://github.com/perl6/roast/commit/0634c5aa5e

[10:19] <lizmat> m: dd <1 2> Xcmp <1 2> Xcmp <1 2>

[10:19] <camelia> rakudo-moar a26f51: OUTPUT¬´Incorrect number of elements: expected 2, got 3‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[10:19] <lizmat> this *should* probably be caught at compile time

[10:19] <samcv> idk why this isn't working. P6opaque: get_boxed_ref could not unbox for the representation '20' of type scalar

[10:19] <samcv> what does that mean? do i have to unbox a scalar or something? in Perl 6 it's just an Int

[10:21] <lizmat> try nqp::unbox_i() ?

[10:22] <samcv> screw it. just gonna have this hash have string values

[10:22] <samcv> not int's

[10:22] <samcv> that did work tho lizmat

[10:23] <samcv> maybe Ops.markdown is wrong saying it takes in Int? idk

[10:23] <samcv> or an Int in nqp not an Int in p6?

[10:24] <jnthn> Natively keyed hashes are not implemented yet.

[10:24] <jnthn> So it'll always box to Int on storage

[10:24] <samcv> that's not what I meant

[10:24] <samcv> it has values that are Int's atm

[10:24] <samcv> not keys

[10:24] <samcv> the keys are strings

[10:24] <jnthn> Natively valued ones aren't either

[10:25] <samcv> but in nqp?

[10:26] <timotimo> samcv: to make that unbox work you need to nqp::decont

[10:26] <samcv> ah ok

[10:30] <jnthn> No, no native hashes anywhere yet.

[10:30] <samcv> well i mean whatever it is still a string

[10:30] <samcv> not an object

[10:33] <lizmat> https://gist.github.com/lizmat/b9da3fbcf0cb0ab41e10c99f4b554bed  # seemed like a straightforward improvement, but this breaks tests.  Huh?

[10:35] <Geth> roast: flexibeast++ created pull request #222: uniprop: add tests for 5 more properties

[10:35] <Geth> roast: review: https://github.com/perl6/roast/pull/222

[10:35] <jnthn> m: dd List.reduce(&[+])

[10:35] <camelia> rakudo-moar babfc3: OUTPUT¬´Nil‚ê§¬ª

[10:36] <jnthn> Not sure.

[10:36] <lizmat> rakudobug it ?

[10:37] <lizmat> fwiw, specifying "is nodal" with the candidates didn't fix it either

[10:38] <samcv> in a nqp hash how do I set a keys value?

[10:38] <samcv> to some string

[10:38] <jnthn> nqp::bindkey

[10:38] <samcv> no bindkey_s?

[10:39] <samcv> or is that what you meant by NYI

[10:39] <timotimo> keys in nqp hashes are always str

[10:39] <jnthn> < jnthn> No, no native hashes anywhere yet.

[10:39] <samcv> yes i saw that

[10:39] <samcv> exactly timotimo that's what i wanted to do

[10:39] <samcv> ok so the just bindkey then. will do that

[10:39] <timotimo> i forgot how we implement object hashes :P

[10:39] <jnthn> Massive cheating :)

[10:39] <timotimo> something involving nqp::objid

[10:39] <timotimo> or some other name

[10:39] <samcv> cheating is ok

[10:40] <timotimo> which generates a unique never-changing ID for an object

[10:40] <jnthn> timotimo: That's how we get a WHICH for referene types

[10:40] <jnthn> *reference

[10:40] <timotimo> (though not guaranteed to be free forever once the object in question dies)

[10:40] <jnthn> Object hashes use that

[10:40] <timotimo> (i.e. can be re-used)

[10:40] <jnthn> It can be, but if that happens the object wasn't in a hash any more ;)

[10:41] <jnthn> I suspect we'll implement object hash stuff at Perl 6 level, and revisit ObjAt along the way, fwiw.

[10:42] <Geth> roast: bbab08a343 | Alexis++ | S15-unicode-information/uniprop.t

[10:42] <Geth> roast: uniprop: add tests for 5 more properties

[10:42] <Geth> roast:

[10:42] <Geth> roast: Diacritic, Default_Ignorable_Code_Point, ID_Start,

[10:42] <Geth> roast: IDS_Binary_Operator, IDS_Trinary_Operator

[10:42] <Geth> roast: review: https://github.com/perl6/roast/commit/bbab08a343

[10:42] <Geth> roast: 71aafc1b46 | (Samantha McVey)++ | S15-unicode-information/uniprop.t

[10:42] <Geth> roast: Merge pull request #222 from flexibeast/master

[10:42] <Geth> roast:

[10:42] <Geth> roast: uniprop: add tests for 5 more properties

[10:42] <Geth> roast: review: https://github.com/perl6/roast/commit/71aafc1b46

[10:42] <lizmat> jnthn: object hash stuff is already at Perl6 level, no ?

[10:44] <jnthn> lizmat: Sorta, but still uses nqp::hash and friends underneath

[10:44] <lizmat> ah, yes, it does  :-)

[10:44] <lizmat> so you're suggesting a new type of nqp::hash ?

[10:44] <jnthn> Which forces us to do nasty things, like form fragile ObjAt strings which seem to be an everlasting source of bugs.

[10:45] <jnthn> No, we'd just implement it using nqp::list for the actual storage

[10:46] * jnthn will have to make a sketch of this in this copious available time. ;-)

[10:46] <lizmat> hehe

[10:46] <timotimo> ah, we'll expose our string hashing via a nqp op and implement our own bucketing/linkedlist stuff

[10:46] <jnthn> timotimo: Yeah, I think something like that.

[10:47] <jnthn> timotimo: But probably no linked list.

[10:47] <timotimo> yeah, linked lists are boo

[10:47] <jnthn> Or at least, if we do, only on collisions.

[10:47] <jnthn> And then not linked even :)

[10:47] <timotimo> unhinged lists

[10:48] <samcv> MoarVM panic: Memory allocation failed; could not allocate 18446744073709551612 bytes

[10:48] <samcv> hah

[10:48] <jnthn> o.O

[10:48] <timotimo> oh yeah

[10:48] <timotimo> m: say 18446744073709551612.base(16)

[10:48] <camelia> rakudo-moar babfc3: OUTPUT¬´FFFFFFFFFFFFFFFC‚ê§¬ª

[10:48] <samcv> that happening when trying to bintd a key

[10:48] <samcv> why would

[10:49] <samcv> maybe will try and unbox more things

[10:49] <timotimo> i wonder if some sort of endless recursion happens or something?

[10:49] <timotimo> can you set a gdb break point in MVM_panic and see what's on the plate^Wstack?

[10:50] <samcv> yeah.

[10:50] <timotimo> i'll be AFK for a while

[10:55] <samcv> seems to be in MVM_bigint_to_str

[10:56] <samcv> https://gist.github.com/samcv/3c1403b941b18644eb5fd73745d2ac89 here is the bt

[11:27] <timotimo> base 0?

[11:27] <timotimo> that'll give you Inf :)

[11:28] <timotimo> m: use nqp; nqp::radix("123", 0)

[11:28] <camelia> rakudo-moar babfc3: OUTPUT¬´===SORRY!===‚ê§Arg count 2 doesn't equal required operand count 5 for op 'radix'‚ê§¬ª

[11:28] <timotimo> what op is it again ...

[11:28] <timotimo> m: use nqp; nqp::base_I("123", 0)

[11:28] <camelia> rakudo-moar babfc3: OUTPUT¬´P6opaque: get_boxed_ref could not unbox for the representation '20' of type Str‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[11:28] <timotimo> m: use nqp; nqp::base_I(nqp::decont("123"), 0)

[11:28] <camelia> rakudo-moar babfc3: OUTPUT¬´P6opaque: get_boxed_ref could not unbox for the representation '20' of type Str‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[11:29] <timotimo> m: use nqp; nqp::base_I(nqp::unbox_s("123"), 0)

[11:29] <camelia> rakudo-moar babfc3: OUTPUT¬´P6opaque: get_boxed_ref could not unbox for the representation '20' of type Str‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[11:29] <timotimo> m: use nqp; nqp::base_I(nqp::unbox_s(nqp::decont("123")), 0)

[11:29] <camelia> rakudo-moar babfc3: OUTPUT¬´P6opaque: get_boxed_ref could not unbox for the representation '20' of type Str‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[11:29] <timotimo> ‚Ä¶

[11:30] <timotimo> nqp: nqp::base_I("123", 0)

[11:30] <camelia> nqp-moarvm: OUTPUT¬´This representation (P6str) cannot unbox to other types (for type BOOTStr)‚ê§   at <tmp>:1  (<ephemeral file>:<mainline>)‚ê§ from gen/moar/stage2/NQPHLL.nqp:1582  (/home/camelia/rakudo-m-inst-1/share/nqp/lib/NQPHLL.moarvm:eval)‚ê§ from gen/moar/stage2/NQPHLL.nqp:1‚Ä¶¬ª

[11:30] <timotimo> nqp: nqp::base_I(nqp::unbox_s("123"), 0)

[11:30] <camelia> nqp-moarvm: OUTPUT¬´This representation (P6str) cannot unbox to other types (for type BOOTStr)‚ê§   at <tmp>:1  (<ephemeral file>:<mainline>)‚ê§ from gen/moar/stage2/NQPHLL.nqp:1582  (/home/camelia/rakudo-m-inst-1/share/nqp/lib/NQPHLL.moarvm:eval)‚ê§ from gen/moar/stage2/NQPHLL.nqp:1‚Ä¶¬ª

[11:30] <timotimo> jesus christ.

[11:31] <jnthn> Don't you need a bigint there?

[11:38] <timotimo> oh, maybe i do?

[11:39] <timotimo> nqp: nqp::base_I(123, 0)

[11:39] <camelia> nqp-moarvm: OUTPUT¬´This representation (P6int) cannot unbox to other types (for type BOOTInt)‚ê§   at <tmp>:1  (<ephemeral file>:<mainline>)‚ê§ from gen/moar/stage2/NQPHLL.nqp:1582  (/home/camelia/rakudo-m-inst-1/share/nqp/lib/NQPHLL.moarvm:eval)‚ê§ from gen/moar/stage2/NQPHLL.nqp:1‚Ä¶¬ª

[11:53] <samcv> oh i checked looks like it was my mistake. but it was 10 in one of the correct spots but not the other one :P

[11:53] <samcv> m: use nqp; nqp::base_I(nqp::decont('10'), 0)

[11:53] <camelia> rakudo-moar babfc3: OUTPUT¬´P6opaque: get_boxed_ref could not unbox for the representation '20' of type Str‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[11:54] <samcv> weird

[11:59] <timotimo> anyway, yeah, base of 0 will get you an explosion and we should probably just straight up die when we see a 0 as base

[12:00] <samcv> yea

[12:21] <lizmat> m: dd (1..* X* 1..*)[^3]

[12:21] <camelia> rakudo-moar babfc3: OUTPUT¬´(1, 2, 3)‚ê§¬ª

[12:21] <lizmat> $ 6 '(1..* X* 1..*)[^3]'

[12:21] <lizmat> Can only have one lazy sequence in a cross

[12:22] <lizmat> this breaks one spectest

[12:22] <lizmat> I think having 2 lazy lists in a X doesn't make sense, as the second will hide the first except the first value

[12:44] <samcv> does anybody see what i'm doing wrong here in this nqp section? https://gist.github.com/samcv/2584c8777142b501e7cf4760ef426807#file-ucd-gen-p6-L374

[12:45] <samcv> This representation (NativeRef) cannot unbox to other types (for type IntLexRef)

[12:45] <samcv> in sub make-point-index at ./UCD-gen.p6 line 374

[12:59] <jnthn> Probably it wants an nqp::decont_i somewhere

[13:00] <jnthn> fwiw, nqp::add_i may as well be written with +

[13:00] <jnthn> The static inliner should already be catching those cases

[13:07] <samcv> jnthn, any clue where? it only started throwing that error when I changed from a for 0..$point-max to nqp::repeat_until

[13:23] <jnthn> samcv: Somehwere where you used a native with an nqp:: op

[13:23] <samcv> kk

[13:26] * jnthn just had quite a bug hunt because it seems Digest::SHA1::Native ends up modifying the Buf you give it to SHA-1 somehow :S

[13:27] <samcv> :|

[14:08] <Geth> roast: 12f6ef1e24 | (Elizabeth Mattijsen)++ | S15-unicode-information/uniprop.t

[14:08] <Geth> roast: Make file compile and correct number of tests

[14:08] <Geth> roast: review: https://github.com/perl6/roast/commit/12f6ef1e24

[14:15] <Geth> rakudo/nom: d4a5b695ea | (Elizabeth Mattijsen)++ | src/core/Rakudo/Iterator.pm

[14:15] <Geth> rakudo/nom: Make 1 X foo about 20% faster

[14:15] <Geth> rakudo/nom:

[14:15] <Geth> rakudo/nom: The "1" case was being treated as an iterator rather than a constant.

[14:15] <Geth> rakudo/nom: Making it act as a single element reified list makes things significantly

[14:15] <Geth> rakudo/nom: faster  :-)

[14:15] <Geth> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/d4a5b695ea

[14:21] <samcv> i'm going to bed very soon all

[14:24] <lizmat> samcv: at 4:25am in the morning, that sounds like an excellent plan  :-)

[14:24] <samcv> it's 6:24 am ;)

[14:24] <lizmat> oops

[14:24] <lizmat> yes

[14:24] <lizmat> duh

[14:24] <samcv> close tho

[14:24] <lizmat> it's already 15:24 here, not 13:24  :)

[14:26] <Geth> rakudo/nom: d3035a8359 | (Pawel Murias)++ | 3 files

[14:26] <Geth> rakudo/nom: Remove an obsolete nqp::p6captureouters op.

[14:26] <Geth> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/d3035a8359

[14:37] <Geth> rakudo/nom: 2a7c27aa2f | (Elizabeth Mattijsen)++ | src/core/Rakudo/Iterator.pm

[14:37] <Geth> rakudo/nom: Make X die on various forms of lazy sequences

[14:37] <Geth> rakudo/nom:

[14:37] <Geth> rakudo/nom: - 1,2 X 1..*  now dies with:

[14:37] <Geth> rakudo/nom:   "Can only have single element lists before a lazy sequence in a cross"

[14:37] <Geth> rakudo/nom:   The reason for this is that the "2" of the first list will never be

[14:37] <Geth> rakudo/nom:   reached, and thus indicates a thinko of the developer.

[14:37] <Geth> rakudo/nom:

[14:37] <Geth> rakudo/nom: <‚Ä¶commit message has 13 more lines‚Ä¶>

[14:37] <Geth> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/2a7c27aa2f

[14:37] <lizmat> jnthn TimToady comments?

[14:42] <lizmat> RT #112602

[14:42] <lizmat> ah, no synopsebot

[14:43] <lizmat> https://rt.perl.org//Public/Bug/Display.html?id=112602

[14:46] <Geth> roast: 4fd31a1643 | (Elizabeth Mattijsen)++ | S03-metaops/cross.t

[14:46] <Geth> roast: Adapt test so it doesn't die

[14:46] <Geth> roast:

[14:46] <Geth> roast: Related ticket: https://rt.perl.org//Public/Bug/Display.html?id=112602

[14:46] <Geth> roast: Related commit: https://github.com/rakudo/rakudo/commit/2a7c27aa2f

[14:46] <Geth> roast: review: https://github.com/perl6/roast/commit/4fd31a1643

[14:52] <Geth> roast/6.c-errata: f425c24cf8 | (Elizabeth Mattijsen)++ | S03-metaops/cross.t

[14:52] <Geth> roast/6.c-errata: Adapt test so it doesn't die

[14:52] <Geth> roast/6.c-errata:

[14:52] <Geth> roast/6.c-errata: Related ticket: https://rt.perl.org//Public/Bug/Display.html?id=112602

[14:52] <Geth> roast/6.c-errata: Related commit: https://github.com/rakudo/rakudo/commit/2a7c27aa2f

[14:52] <Geth> roast/6.c-errata: review: https://github.com/perl6/roast/commit/f425c24cf8

[15:07] <MasterDuke> lizmat: your recent change to S15-unicode-information/uniprop.t, doesn't it have an extra ' (single quote) at the beginning? https://github.com/perl6/roast/blob/12f6ef1e241ae59640051f23398269d9480f9fe4/S15-unicode-information/uniprop.t#L167

[15:08] <lizmat> hmmm... that's weird

[15:08] <samcv> no it was a PR I merged

[15:08] <samcv> and i'm pretty sure it's correct

[15:08] <samcv> unless it doesn't compile

[15:09] <lizmat> it didn't compile, it does compile now

[15:09] <samcv> oh

[15:09] <lizmat> .u 'Ã¥

[15:09] <yoleaux2> U+0027 APOSTROPHE [Po] (')

[15:09] <yoleaux2> U+0334 COMBINING TILDE OVERLAY [Mn] (‚óåÃ¥)

[15:09] <samcv> anyway i am asleep now

[15:10] <samcv> night

[15:10] <lizmat> if I remove the first quote, it doesn't compile

[15:10] <lizmat> good night, samcv, sleep tight!

[15:11] <MasterDuke> ah, i guess because of the combining. my browser must not show it correctly on the github page

[15:12] <lizmat> something is getting confused somewhere, that much is clear  :-)

[15:12] <MasterDuke> it definitely looks different in vim

[15:28] <moritz> have you folks seen http://www.craftinginterpreters.com/contents.html ?

[15:29] <moritz> not looked at it in detail yet, but might be an interesting resource

[16:16] <pmurias> jnthn: re avoiding duplication of magical variable, can the variables have traits placed on them outside of them being declared?

[16:16] <jnthn> pmurias: Technically, but I think in that case it's a "tough luck" situation :)

[16:17] <jnthn> pmurias: I mean, you can in theory obtain the thing and stick a trait on it at any point you want by calling trait_mod:<is> manually

[16:17] <jnthn> But that probably falls under "if you do it, you get to keep all the pieces when it breaks"

[16:29] <pmurias> jnthn: If the users grabs the variable using VAR it should be cloned anyway. Also I'm doing the optimalization for variables that already share the container descriptors.

[16:39] <Geth> geth: f53e2016d6 | (Zoffix Znet)++ | lib/Geth/GitHub/Hooks/Preprocessor.pm6

[16:39] <Geth> geth: Refactor version bump fetching into separate method

[16:39] <Geth> geth: review: https://github.com/perl6/geth/commit/f53e2016d6

[16:55] <lizmat> dinner&

[17:02] <Geth> geth: dd458f0dfa | (Zoffix Znet)++ | 2 files

[17:02] <Geth> geth: Implement on-demand version bump changes fetcher

[17:02] <Geth> geth:

[17:02] <Geth> geth: - Adds triggered command `ver GITHUB_URL_TO_VERSION_BUMP_COMMIT`

[17:02] <Geth> geth: - Useful for release managers

[17:02] <Geth> geth: review: https://github.com/perl6/geth/commit/dd458f0dfa

[17:03] <brokenchicken> Geth: ver https://github.com/rakudo/rakudo/commit/644cd342d7aa32ba11b1fc612c7f8351885e12f5

[17:03] <Geth> brokenchicken, version bump brought in these changes: https://github.com/perl6/nqp/compare/2016.12-97-g7b6fff9...2016.12-98-g10fa8082

[17:03] <brokenchicken> Geth: ver https://github.com/perl6/nqp/commit/1d4f071453

[17:03] <Geth> brokenchicken, version bump brought in these changes: https://github.com/MoarVM/MoarVM/compare/2016.12-104-g64e2d938...2016.12-113-gd1da1ba

[17:03] <brokenchicken> .botsnack

[17:03] <yoleaux2> :D

[17:03] <synopsebot6> om nom nom

[17:23] <b2gills> lizmat: since you just worked with infix:<X>

[17:23] <b2gills> m: say Bool.pick Xxx 20 # doesn't thunk left side

[17:23] <camelia> rakudo-moar 2a7c27: OUTPUT¬´((True True True True True True True True True True True True True True True True True True True True))‚ê§¬ª

[17:23] <b2gills> m: say (Bool.pick,) Xxx 20 # does thunk left side

[17:23] <camelia> rakudo-moar 2a7c27: OUTPUT¬´((False False True True False True True True False True True False False True False True True True True False))‚ê§¬ª

[17:24] <b2gills> ( It was broken before today, so you didn't make it worse )

[18:12] <lizmat> star: say Bool.pick Xxx 20

[18:12] <camelia> star-m 2016.10: OUTPUT¬´((True True True True True True True True True True True True True True True True True True True True))‚ê§¬ª

[18:19] <lizmat> b2gills: suggest making a ticket  :-)

[18:35] <pmurias> I should use 'make spectest' to check if my optimalization didn't break anything?

[18:36] <lizmat> doing a "make spectest" is always a good thing

[18:36] * lizmat runs at least one just before committing

[18:38] <lizmat> $ 6 'my @a = ^50; for @a.skip(40) { print "$_ " }'

[18:38] <lizmat> 40 41 42 43 44 45 46 47 48 49

[18:38] <lizmat> does that make sense ^^^

[18:41] * brokenchicken didn't even know we had such a method

[18:41] <lizmat> brokenchicken: we don't

[18:41] <brokenchicken> Ah

[18:41] <lizmat> but it's about 6 lines of code

[18:41] <lizmat> so I'm very tempted to add it  :-)

[18:43] <lizmat> inspired by one of the comments on http://stackoverflow.com/questions/41668358/how-can-i-use-a-non-caching-infinite-lazy-list-in-perl-6

[18:44] <brokenchicken> What happens with my @a = ^50; my $z = @a.skip(40); for @a { print "$_ " }; for $z { print "

[18:44] <brokenchicken> $_" }

[18:45] <brokenchicken> I guess I'm not really following what .skip() returns

[18:46] <lizmat> in Seq.pm: method skip(Int() $n) { $!iter.skip-at-least($n); self }

[18:46] <lizmat> in Any.pm:  method skip(Int() $n) { Seq.new(self.iterator).skip($n) }

[18:47] <lizmat> .skip returns a Seq, and the same .Seq when called on a .Seq

[18:49] <brokenchicken> Ah

[18:49] <pmurias> lizmat: so @a.skip($n) would be @a[$n..*] but lazy?

[18:50] <lizmat> the skip would not be lazy, but the rest would be, yes

[18:51] <lizmat> when called on a Seq, it just eats away at its iterator without caching

[18:55] <perlpilot> lizmat: I like .skip() fwiw.

[18:56] <lizmat> $ 6 'dd "words".IO.lines.skip(235880)'

[18:56] <lizmat> ("Zyryan", "zythem", "Zythia", "zythum", "Zyzomys", "Zyzzogeton").Seq

[18:56] <perlpilot> Though it does make me think that we may need more docs on laziness wrt caching vs. non-caching

[18:58] <lizmat> $ 6 'dd "words".IO.lines.skip(235880).head(3)'

[18:58] <lizmat> ("Zyryan", "zythem", "Zythia").Seq

[18:58] <lizmat> :-)

[18:59] <brokenchicken> :D

[19:35] <Geth> rakudo/nom: f67df8ad9d | (Pawel Murias)++ | src/Perl6/World.nqp

[19:35] <Geth> rakudo/nom: Reuse the containers that magic variables containers are cloned off.

[19:35] <Geth> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/f67df8ad9d

[19:44] <lizmat> pmurias: any idea on savings ?  ^^^

[19:47] <pmurias> haven't measure that, should be bigger on the jvm and js backends as moar does some $_ removal they don't do

[19:50] <lizmat> oki  :-)

[20:50] <pmurias> lizmat: it saved 19735 serialized objects on the js backend, I'm not sure how to count the number of serialized objects on the moarvm one

[20:51] <lizmat> how much is that in % ?

[20:52] <samcv> hellp

[20:53] <samcv> *hello

[20:53] <lizmat> morning!

[20:58] <pmurias> lizmat: it's ~54% of the objects used directly by QAST::WVal

[20:58] <lizmat> pmurias: cool!

[21:23] <lizmat> and another Perl6 Weekly hits the Net: https://p6weekly.wordpress.com/2017/01/16/2017-03-üôÜ%E2%80%8D‚ôÄ%EF%B8%8F-woman-gesturing-ok/

[21:41] <timotimo> can't click that link :<

[21:41] <timotimo> https://p6weekly.wordpress.com/2017/01/16/2017-03-%20%E2%80%8D‚ôÄ%EF%B8%8F-woman-gesturing-ok/

[21:41] <timotimo> maybe?

[21:41] <timotimo> crap, that's not a normal space

[21:42] <lizmat> https://p6weekly.wordpress.com  # also works this week

[21:42] <timotimo> ah! it was an emoji!

[21:42] <lizmat> yes

[21:42] <timotimo> my terminal refused to let me copy that

[21:42] <timotimo> on top of not displaying it

[21:42] <lizmat> I felt evil trying to see what it will break :-)

[21:45] <Geth> rakudo/nom: 4386e77b39 | (Elizabeth Mattijsen)++ | src/core/Rakudo/Iterator.pm

[21:45] <Geth> rakudo/nom: Fix copy-pastoes

[21:45] <Geth> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/4386e77b39

[21:52] <Geth> rakudo: usev6++ created pull request #995: [JVM] Add option --nqp-lib=blib to start script

[21:52] <Geth> rakudo: review: https://github.com/rakudo/rakudo/pull/995

[21:54] <Geth> rakudo/nom: 4320fdc2fa | usev6++ | 2 files

[21:54] <Geth> rakudo/nom: [JVM] Add option --nqp-lib=blib to start script

[21:54] <Geth> rakudo/nom:

[21:54] <Geth> rakudo/nom: ... so that rakudo-j works without 'make install', again.

[21:54] <Geth> rakudo/nom: nine++ for the suggestion.

[21:54] <Geth> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/4320fdc2fa

[21:54] <Geth> rakudo/nom: 3e373ffe26 | (Pawe≈Ç Murias)++ | 2 files

[21:54] <Geth> rakudo/nom: Merge pull request #995 from usev6/jvm_build_blib

[21:54] <Geth> rakudo/nom:

[21:54] <Geth> rakudo/nom: [JVM] Add option --nqp-lib=blib to start script

[21:54] <Geth> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/3e373ffe26

[22:14] <Geth> rakudo/nom: 9537ccd87a | (Elizabeth Mattijsen)++ | src/core/Rakudo/Iterator.pm

[22:14] <Geth> rakudo/nom: Revert "Make X die on various forms of lazy sequences"

[22:14] <Geth> rakudo/nom:

[22:14] <Geth> rakudo/nom: This reverts commit 2a7c27aa2f4c7744912c1405fe5ed5ba45941d3d.

[22:14] <Geth> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/9537ccd87a

[22:36] <Geth> rakudo/nom: 0cd921e351 | (Elizabeth Mattijsen)++ | src/core/Rakudo/Iterator.pm

[22:36] <Geth> rakudo/nom: Fix for RT #130566

[22:36] <Geth> rakudo/nom:

[22:36] <Geth> rakudo/nom: Turned out the check for $!todo wasn't triggering for lazy Lists,

[22:36] <Geth> rakudo/nom: so it was assumed it was an empty List.  Which will never generate

[22:36] <synopsebot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=130566

[22:36] <Geth> rakudo/nom: any values.

[22:36] <Geth> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/0cd921e351

[23:00] <MasterDuke> is it ok that this ( https://github.com/perl6/nqp/blob/master/src/QRegex/Cursor.nqp#L553 ) uses nqp::lc() instead of nqp::fc()?

[23:20] <samcv> lizmat, say "\c[woman gesturing OK] (woman gesturing OK)";

[23:20] <samcv> idk why the parens are there?

[23:20] <samcv> m: say "\c[woman gesturing OK] (woman gesturing OK)";

[23:20] <camelia> rakudo-moar 0cd921: OUTPUT¬´üôÜ‚Äç‚ôÄÔ∏è (woman gesturing OK)‚ê§¬ª

[23:20] <samcv> i guess that does output

[23:20] <samcv> seemed odd to me to put it inside the text. but i guess no worries

[23:49] <samcv> lizmat, maybe put it as a comment in the code block?
