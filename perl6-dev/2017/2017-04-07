[00:16] <Geth> ¦ nqp: 19f9cdf4f6 | (Timo Paulssen)++ | t/nqp/019-file-ops.t

[00:16] <Geth> ¦ nqp: fix skip for symlink on windows

[00:16] <Geth> ¦ nqp: review: https://github.com/perl6/nqp/commit/19f9cdf4f6

[06:32] <[Tux]> This is Rakudo version 2017.03-159-gbbfb28d49 built on MoarVM version 2017.03-88-g21fc7a22

[06:32] <[Tux]> csv-ip5xs        3.262

[06:32] <[Tux]> test            12.469

[06:32] <[Tux]> test-t           4.973 - 5.013

[06:32] <[Tux]> csv-parser      12.879

[06:33] <samcv> hoping will have 2.2x speed boost to regex [Tux] soon. if all goes as planned :) https://github.com/MoarVM/MoarVM/pull/574

[06:33] <samcv> hopefully will make your test go down

[06:41] <llfourn> samcv++, to all regexes?

[06:41] <samcv> most

[06:42] * llfourn is patiently exited

[06:42] <samcv> anytime it is regex between an 8bit string and 8bit string or 32bit string and 32bit string. and may optimize it so if the needle is short and longer haystack, to convert needle to 32bit to get the fastness

[06:43] <samcv> 'a' x 100000 ~ 'b' ~~ /b/ # is 2.2x faster and that's worst case. so may be better under other cases

[06:43] <samcv> well probably not worse than that lol

[06:43] <samcv> cause that is the worst

[06:44] <samcv> but will initially have a (totally made this up right now) 50% speed boost on mac, and 2.2x on linux? due to how memmem is implemented on BSD it's just normal

[06:44] <samcv> but i need somebody on mac to bench before/after so i can know what it *actually* is

[06:44] <llfourn> ah ok

[06:44] <samcv> travis builds and passes fine on mac

[06:44] <llfourn> I got a mac :)

[06:44] <samcv> ok :)

[06:44] <samcv> would you be willing to test it out for me?

[06:45] <llfourn> yep sure.

[06:45] <llfourn> doing it now.

[06:45] <[Tux]> in my world, there should never be an else after return/die/croak/exit

[06:45] <samcv> ok do `'a' x 1000000000 ~ 'b' ~~ /b/; say now - INIT now;`

[06:45] <samcv> a few times on before/after

[06:46] <samcv> what?

[06:49] * llfourn builds new nqp/moar from master first

[06:50] <samcv> thank you llfourn :-)

[06:53] <samcv> i'll be right back ~20min

[07:07] * llfourn builds samcv's branch

[07:17] <samcv> ty kindly

[07:19] <llfourn> BEFORE: 8.56313 AFTER: 4.00579 # on mac

[07:19] <llfourn> nicely done!!!

[07:21] <llfourn> samcv: https://gist.github.com/LLFourn/a77fbe3f6ca1af1a03b6eab3e50b2818 # the script fyi

[07:23] <samcv> yay

[07:23] <samcv> sweet

[07:23] <samcv> very good

[07:23] <samcv> am i famous yet

[07:24] * llfourn hopes the fame doesn't destroy samcv

[07:24] <samcv> heh

[07:53] <samcv> 'a' x 1000000000 ~ 'bcd' ~~ /abc/; say now - INIT now

[07:53] <samcv> can you test that too llfourn

[07:59] <llfourn> samcv: yup

[07:59] <samcv> yay

[07:59] <samcv> maybe even a longer one. try 'bcd' and 'bcdefghijklmno'

[08:00] <samcv> want to try different needle sizes and see how they compare under the mac version

[08:03] <llfourn> BEFORE: 9.18799 AFTER: 7.29706 # mac

[08:03] <llfourn> samcv:^

[08:03] <samcv> cool

[08:03] <llfourn> (tries larger one)

[08:04] <samcv> yeah it should be faster in all cases than before at minimum

[08:04] <samcv> ty

[08:05] <samcv> yeah checking for 'abc' is slower unless it's optimized because the whole string has 'a' in it :P

[08:05] <samcv> so kind of what i'd guess the thing that would show the least improvement compared to before

[08:09] <llfourn> samcv: longer one is roughly the same, 9.26053, 7.37217

[08:09] <samcv> coolio

[08:10] <llfourn> still pretty big improvement. I'm excited to see how much it improves the parsing of the grammars in my project.

[08:10] <samcv> so looks about 220% to 125% speed

[08:10] <samcv> yeah

[08:10] <llfourn> samcv++

[08:11] <samcv> NeuralAnomaly, status

[08:11] <NeuralAnomaly> samcv, [✘] Next release will be in 1 day and 1 week. Since last release, there are 18 new still-open tickets (7 unreviewed and 0 blockers) and 162 unreviewed commits. See http://perl6.fail/release/stats for details

[08:13] <samcv> hmm is that a challenge...

[08:13] <samcv> would be cool to have it be in the next release

[08:17] <llfourn> is that the next release of Moar or rakudostar?

[08:19] <llfourn> it's rakudostar nvm. I'll make sure to test it before then ;)

[08:19] <samcv> moar

[08:19] <samcv> moar/rakudo/nqp

[08:24] <llfourn> oh ok.

[08:33] <lizmat> Files=1185, Tests=56472, 200 wallclock secs (11.98 usr  4.91 sys + 1192.92 cusr 115.29 csys = 1325.10 CPU)

[08:46] <lizmat> re RT #131112: somehow we need to teach MoarVM that IterationSet is the same as an nqp::hash

[08:46] <lizmat> apparently something like that exists for IterationBuffer, as that precomps without any issue

[09:12] <Geth> ¦ rakudo/nom: 14251e4e20 | (Elizabeth Mattijsen)++ | src/core/Rakudo/Iterator.pm

[09:12] <Geth> ¦ rakudo/nom: R:It.AllButLastNValues can take lazy iterator

[09:12] <Geth> ¦ rakudo/nom:

[09:12] <Geth> ¦ rakudo/nom: So no need to test laziness, or take the extra parameter for a potential

[09:12] <Geth> ¦ rakudo/nom: error message

[09:12] <Geth> ¦ rakudo/nom: review: https://github.com/rakudo/rakudo/commit/14251e4e20

[09:17] <Geth> ¦ rakudo/nom: 1fea4951b5 | (Elizabeth Mattijsen)++ | src/core/Any-iterable-methods.pm

[09:17] <Geth> ¦ rakudo/nom: Allow for .head(*-N)

[09:17] <Geth> ¦ rakudo/nom:

[09:17] <Geth> ¦ rakudo/nom: If you're interested in all values of an Iterable *except* the last

[09:17] <Geth> ¦ rakudo/nom: N ones, you now can with the .head method:

[09:17] <Geth> ¦ rakudo/nom:

[09:17] <Geth> ¦ rakudo/nom:   $ 6 'dd (^10.head(*-6)'

[09:17] <Geth> ¦ rakudo/nom:   (0, 1, 2, 3).Seq

[09:17] <Geth> ¦ rakudo/nom: <…commit message has 8 more lines…>

[09:17] <Geth> ¦ rakudo/nom: review: https://github.com/rakudo/rakudo/commit/1fea4951b5

[10:09] <Geth> ¦ rakudo/nom: 6ef7b59a84 | (Elizabeth Mattijsen)++ | src/core/set_operators.pm

[10:09] <Geth> ¦ rakudo/nom: Simplify 1-arg candidates for (|) and (&)

[10:09] <Geth> ¦ rakudo/nom: review: https://github.com/rakudo/rakudo/commit/6ef7b59a84

[10:17] <Zoffix> m: my @a = ^10; say @a.head: *

[10:17] <camelia> rakudo-moar 1fea49: OUTPUT: «(0 1 2 3 4 5 6 7 8 9)␤»

[10:17] <Zoffix> m: my @a = ^10; say @a.tail: *

[10:17] <camelia> rakudo-moar 1fea49: OUTPUT: «Cannot resolve caller Numeric(Whatever: ); none of these signatures match:␤    (Mu:U \v: *%_)␤  in block <unit> at <tmp> line 1␤␤»

[10:17] <Zoffix> Is the latter meant to work?

[10:17] <Zoffix> Ah, not yet

[10:17] <lizmat> not yet indeed I guess

[10:18] <lizmat> I'll add it

[10:20] <Zoffix> Check it out:

[10:20] <Zoffix> m: use nqp; my $seq = gather { nqp::indexingoptimized("aaaaaaaaaaa" x 10000).take for ^200000 }; $seq[^30000].tail(1).say

[10:21] <camelia> rakudo-moar 1fea49: OUTPUT: «MoarVM panic: Memory allocation failed; could not allocate 110000 bytes␤»

[10:21] <Zoffix> m: use nqp; my $seq = gather { nqp::indexingoptimized("aaaaaaaaaaa" x 10000).take for ^200000 }; $seq.head(30000).tail(1).say

[10:21] <camelia> rakudo-moar 1fea49: OUTPUT: «(aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa…»

[10:21] <Zoffix> It's now possible to 1-shot index into the middle of a seq without caching it :)

[10:22] <Zoffix> I guess it was possible before. But I just now realized it :)

[10:22] <lizmat> .tail would be even faster

[10:22] <lizmat> as opposed to tail(1)

[10:56] <Geth> ¦ rakudo/nom: 495f9708b3 | (Elizabeth Mattijsen)++ | src/core/set_operators.pm

[10:56] <Geth> ¦ rakudo/nom: Make (-) a multi

[10:56] <Geth> ¦ rakudo/nom:

[10:56] <Geth> ¦ rakudo/nom: Start of optimization work on (-)

[10:56] <Geth> ¦ rakudo/nom: review: https://github.com/rakudo/rakudo/commit/495f9708b3

[10:56] <Geth> ¦ rakudo/nom: 49c0ab6419 | (Elizabeth Mattijsen)++ | src/core/set_operators.pm

[10:56] <Geth> ¦ rakudo/nom: Make Setty (-) Setty about 40x faster

[10:56] <Geth> ¦ rakudo/nom:

[10:56] <Geth> ¦ rakudo/nom: - add a candidate for it

[10:56] <Geth> ¦ rakudo/nom: - that is highly optimized and written in nqp

[10:56] <Geth> ¦ rakudo/nom: - prevents potentially expensive .WHICH calculation

[10:57] <Geth> ¦ rakudo/nom: - so many real live situations could be faster still

[10:57] <Geth> ¦ rakudo/nom: review: https://github.com/rakudo/rakudo/commit/49c0ab6419

[11:13] <lizmat> m: my @a = ^10; dd @a.tail(Inf)

[11:13] <camelia> rakudo-moar 49c0ab: OUTPUT: «This type cannot unbox to a native integer: P6opaque, Num␤  in block <unit> at <tmp> line 1␤␤»

[11:13] <lizmat> m: my @a = ^10; dd @a.Seq.tail(Inf)

[11:13] <camelia> rakudo-moar 49c0ab: OUTPUT: «(0, 1, 2, 3, 4, 5, 6, 7, 8, 9).Seq␤»

[11:13] <lizmat> Seq's already supported .tail(*) and .tail(Inf)

[11:27] <lizmat> m: my $m = (a => 10).Mix; my $n = (a => 20).Mix; dd $m (-) $n   # expected ("a" => -10).Mix

[11:27] <camelia> rakudo-moar 49c0ab: OUTPUT: «().Mix␤»

[11:29] <lizmat> I can understand this behaviour for Bags, but the whole point of Mixes was that the weight could also be negative

[11:41] <Zoffix> I'd expected -10 too

[11:44] <Zoffix> m: dd (:10a).Mix (&) (:a(-20)).Mix

[11:44] <camelia> rakudo-moar 49c0ab: OUTPUT: «("a"=>-20).Mix␤»

[11:45] <Zoffix> we do do negatives up in here

[11:45] <lizmat> indeed

[11:46] * lizmat tries that behaviour and waits for any spectest breakage

[12:07] <lizmat> breakage  :-(

[12:09] <Zoffix> lizmat: is it breakage in 6.c-errata or in tests that aren't part of the language yet?

[12:09] <lizmat> not sure yet

[12:13] <lizmat> looks like post errata, with errata I get quite a number of tests passing

[12:15] <lizmat> argh, testing with wrong version

[12:17] <lizmat> ok, no errors in errata, only passing todo's

[12:18] <Zoffix> So the change's good then :)

[12:19] <lizmat> well, in errata it wasn't tested

[12:19] <lizmat> tests have been added since

[12:22] <Zoffix> lizmat: which tests fail?

[12:23] <lizmat> t/spec/S03-operators/mix.rakudo.moar (Wstat: 1792 Tests: 135 Failed: 7)

[12:23] <lizmat> Failed tests:  29, 31, 33, 35, 130, 132, 134

[12:23] <AlexDaniel> Zoffix: I have a feeling that you hold the record for the number of rejected tickets :)

[12:24] <AlexDaniel> (rejected by you I mean)

[12:24] <lizmat> aaaahhh  I think I know why

[12:24] <AlexDaniel> … possibly the other way round for me…

[12:24] <lizmat> no I don't  :-)

[12:26] <Zoffix> m: my $a = bag <blood love>; my $m = ("blood" => 1.1, "rhetoric" => 1, "love" => 1.2).Mix; dd ($a (|) $m) (-) ($m (&) $a)

[12:26] <camelia> rakudo-moar 49c0ab: OUTPUT: «("rhetoric"=>1,"blood"=>0.1,"love"=>0.2).Mix␤»

[12:27] <Zoffix> m: my $a = bag <blood love>; my $m = ("blood" => 1.1, "rhetoric" => 1, "love" => 1.2).Mix; dd ($m (&) $a)

[12:27] <camelia> rakudo-moar 49c0ab: OUTPUT: «("blood"=>1,"love"=>1).Mix␤»

[12:27] * lizmat needs to think a bit about that with some fresh air

[12:27] <Zoffix> m: my $a = bag <blood love>; my $m = ("blood" => 1.1, "rhetoric" => 1, "love" => 1.2).Mix; dd ($a (|) $m)

[12:27] <camelia> rakudo-moar 49c0ab: OUTPUT: «("rhetoric"=>1,"blood"=>1.1,"love"=>1.2).Mix␤»

[12:27] <lizmat> afk for an hour or so&

[12:27] <Zoffix> m: my $a = bag <blood love>; my $m = ("blood" => 1.1, "rhetoric" => 1, "love" => 1.2).Mix; dd $a (^) $m

[12:27] <camelia> rakudo-moar 49c0ab: OUTPUT: «("rhetoric"=>1,"blood"=>0.1,"love"=>0.2).Mix␤»

[12:28] <Zoffix> lizmat: don't really see why making (-) go into negative with Mixes would fail that test :/ Since it doesn't.

[12:30] <Zoffix> AlexDaniel: definitely not. 75% of rejected tickets were rejected even before I came to Perl 6:

[12:30] <Zoffix> https://rt.perl.org/Search/Results.html?Format=%27%3Cb%3E%3Ca%20href%3D%22__WebPath__%2FTicket%2FDisplay.html%3Fid%3D__id__%22%3E__id__%3C%2Fa%3E%3C%2Fb%3E%2FTITLE%3A%23%27%2C%0A%27%3Cb%3E%3Ca%20href%3D%22__WebPath__%2FTicket%2FDisplay.html%3Fid%3D__id__%22%3E__Subject__%3C%2Fa%3E%3C%2Fb%3E%2FTITLE%3ASubject%27%2C%0AStatus%2C%0AQueueName%2C%0AOwnerName%2C%0APriority%2C%0A%27__NEWLINE__%27%2C%0A%27__NBSP__%

[12:30] <Zoffix> 27%2C%0A%27%3Csmall%3E__Requestors__%3C%2Fsmall%3E%27%2C%0A%27%3Csmall%3E__CreatedRelative__%3C%2Fsmall%3E%27%2C%0A%27%3Csmall%3E__ToldRelative__%3C%2Fsmall%3E%27%2C%0A%27%3Csmall%3E__LastUpdatedRelative__%3C%2Fsmall%3E%27%2C%0A%27%3Csmall%3E__TimeLeft__%3C%2Fsmall%3E%27&Order=DESC&OrderBy=Created&Page=3&Query=Queue%20%3D%20%27perl6%27%20AND%20Status%20%3D%20%27rejected%27&Rows=50

[12:30] <Zoffix> dat url

[12:32] <AlexDaniel> .oO( and the other 25% were rejected by you :P )

[12:32] <AlexDaniel> Zoffix: anyway, nothing wrong with that

[12:32] <Zoffix> Nah

[13:06] <Zoffix> 271 tests new IO::Path.extension has. All sorts of weird cases and all...

[13:06] <Zoffix> And the VERY FIRST time I tried to use it in real code encountered a bug :|

[13:06] <Zoffix> m: dd "foo.".extension("bar")

[13:06] <camelia> rakudo-moar 49c0ab: OUTPUT: «No such method 'extension' for invocant of type 'Str'␤  in block <unit> at <tmp> line 1␤␤»

[13:07] <Zoffix> m: dd "foo.".IO.extension("bar")

[13:07] <camelia> rakudo-moar 49c0ab: OUTPUT: «"foo..bar".IO(:SPEC(IO::Spec::Unix),:CWD("/home/camelia"))␤»

[13:07] <Zoffix> :)

[13:08] <Zoffix> Line 102 in Path.pm needs to be extended to nqp::unless(nqp::chars($ext), nqp::eqat($base, '.', nqp::sub_i(nqp::chars($base), 1)))

[13:12] <Geth> ¦ rakudo/nom: 1b34ea64b7 | (Elizabeth Mattijsen)++ | 2 files

[13:12] <Geth> ¦ rakudo/nom: Allow Array|List.tail(*) and .tail(Inf)

[13:12] <Geth> ¦ rakudo/nom:

[13:12] <Geth> ¦ rakudo/nom: For consistency with .head.  Spotted by Zoffix++

[13:12] <Geth> ¦ rakudo/nom: review: https://github.com/rakudo/rakudo/commit/1b34ea64b7

[13:12] <Geth> ¦ rakudo/nom: a6d49b42a9 | (Elizabeth Mattijsen)++ | 2 files

[13:12] <Geth> ¦ rakudo/nom: Make SANITY a public method

[13:12] <Geth> ¦ rakudo/nom:

[13:12] <Geth> ¦ rakudo/nom: - we still have a performance issue with private methods in roles

[13:12] <Geth> ¦ rakudo/nom: - need to be able to access its logic from &infix:<(-)>

[13:12] <Geth> ¦ rakudo/nom: review: https://github.com/rakudo/rakudo/commit/a6d49b42a9

[13:13] <Zoffix> .oO( Perl 6 now publicly offers SANITY! )

[13:14] <lizmat> :-)

[13:15] <Geth> ¦ rakudo/nom: 19cdcd122a | (Elizabeth Mattijsen)++ | src/core/set_operators.pm

[13:15] <Geth> ¦ rakudo/nom: Make Mixy (-) Mixy produce negative results

[13:15] <Geth> ¦ rakudo/nom:

[13:15] <Geth> ¦ rakudo/nom: Removing an element for negative values is a bug, especially in the

[13:15] <Geth> ¦ rakudo/nom: situation of a chained (-) where a later Mix with a negative value

[13:15] <Geth> ¦ rakudo/nom: cannot "revive" a removed element.  So on existence, just substract

[13:15] <Geth> ¦ rakudo/nom: the value, and then at the end, remove the elements with value 0.

[13:15] <Geth> ¦ rakudo/nom: review: https://github.com/rakudo/rakudo/commit/19cdcd122a

[14:07] <lizmat> looks like test fail is in the use of (-) in a testing sub

[14:32] <Zoffix> lizmat: https://rt.perl.org/Ticket/Display.html?id=130845#txn-1450094

[14:34] <Zoffix> That's not bdfoy I'm telling to use IRC for discussions. Moreover, this is the third time he's asking support questions on the bug queue. The first two of which had a direct answer in the docs; the junctions one has an indirect answer: what would be the point of `one` junction if they collapsed the values? And all three would have an instant answer on IRC

[14:34] <Zoffix> "So please, treat everybody the same!  :-)"

[14:34] <Zoffix> I am

[14:37] <lizmat> Zoffix: point take :-)

[14:37] <lizmat> *taken

[14:39] <lizmat> looking at (^) tests, it looks like one set of fails is caused by improper expectation of (-)

[14:41] <lizmat> but another set is actually caused by improper expectation of (^) wrt to Mixes

[14:41] <lizmat> m: dd (a => 1.1).Mix (^) (a => 1.0).Mix

[14:41] <camelia> rakudo-moar 19cdcd: OUTPUT: «().Mix␤»

[14:42] <lizmat> is what I expect

[14:42] <lizmat> because (^) is really only about keys / or existence of a key if you will

[14:42] <lizmat> m: dd (a => 1.1).Mix (^) (b => 1.0).Mix

[14:42] <camelia> rakudo-moar 19cdcd: OUTPUT: «("b"=>1,"a"=>1.1).Mix␤»

[14:43] <Zoffix> c: HEAD~10 dd (a => 1.1).Mix (^) (a => 1.0).Mix

[14:43] <committable6> Zoffix, ¦HEAD~10: «("a"=>0.1).Mix»

[14:43] <Zoffix> That's what I'd expect. And I think that's what abstr6ct implemented

[14:44] <lizmat> docs state: Returns the symmetric set difference of all its arguments, i.e., a Set made up of all the elements that $a has but $b doesn't and all the elements $b has but $a doesn't

[14:44] <Zoffix> ab5tract

[14:45] <lizmat> so at least the documentation would be incomplete

[14:45] <lizmat> wrt to Bags and Mixes

[14:45] <Zoffix> And here's the PR: https://github.com/rakudo/rakudo/pull/934

[14:45] <lizmat> if (^) would produce that, what would be the difference with (-) ?

[14:45] <Zoffix> It ends with my asking to update the docs with no response

[14:46] <Zoffix> (a => 1.0).Mix (^) (a => 1.1).Mix would still produce ("a"=>0.1).Mix while (-) would produce ("a"=>-0.1).Mix

[14:46] <Zoffix> c: HEAD~10 dd (a => 5).Bag (^) (a => 10).Bag

[14:47] <committable6> Zoffix, ¦HEAD~10: «("a"=>5).Bag»

[14:47] <Zoffix> m: dd (a => 5).Bag (^) (a => 10).Bag

[14:47] <camelia> rakudo-moar 19cdcd: OUTPUT: «("a"=>5).Bag␤»

[14:47] <Zoffix> Yeah, it still works that way for Bags

[14:48] <Zoffix> If both have elems, it takes largest value and subtracts the smaller ones from it. Which for sets has the effect of removing the item, since all the weights are 1

[14:49] <Zoffix> Oh and here's the first PR, specifically this comment: https://github.com/rakudo/rakudo/pull/911#issuecomment-257941267

[14:49] <lizmat> m: dd (a => 6).Bag (^) (a => 10).Bag

[14:49] <camelia> rakudo-moar 19cdcd: OUTPUT: «("a"=>4).Bag␤»

[14:49] <lizmat> m: dd (a => 10).Bag (^) (a => 6).Bag

[14:49] <camelia> rakudo-moar 19cdcd: OUTPUT: «("a"=>4).Bag␤»

[14:49] <lizmat> m: dd (a => 10).Bag (-) (a => 6).Bag

[14:49] <camelia> rakudo-moar 19cdcd: OUTPUT: «("a"=>4).Bag␤»

[14:50] <lizmat> m: dd (a => 6).Bag (-) (a => 10).Bag

[14:50] <camelia> rakudo-moar 19cdcd: OUTPUT: «().Bag␤»

[14:50] <Zoffix> m: dd (a => 10).Bag (^) (a => 60).Bag (^) (a => 30).Bag

[14:50] <camelia> rakudo-moar 19cdcd: OUTPUT: «("a"=>20).Bag␤»

[14:51] <lizmat> ok, so (^) takes highest value, substracts all the others

[14:52] <Zoffix> Yeah.

[14:52] <lizmat> and (-) takes first value and substract all the others

[14:52] <Zoffix> Yes.

[14:52] <lizmat> for sets that doesn't matter

[14:52] <lizmat> there's no difference

[14:54] <lizmat> ok, so some of the tests are really bogus, because they implement the value to test in the same way as the code in the setting

[14:55] <Zoffix> Between the ops? There's still the diff for sets:

[14:55] <Zoffix> m: dd set() (-) set(<a>)

[14:55] <camelia> rakudo-moar 19cdcd: OUTPUT: «set()␤»

[14:55] <Zoffix> m: dd set() (^) set(<a>)

[14:55] <camelia> rakudo-moar 19cdcd: OUTPUT: «set("a")␤»

[14:55] <lizmat> ah, good point  :-)

[14:56] <lizmat> hmmm... looks like I need to take on (^) before continuing with (-)

[15:00] <lizmat> Zoffix: do you consider 19cdcd122a8b08dc7 to be ok or not ?

[15:06] <Zoffix> lizmat: yeah OK.

[15:06] <Zoffix> m: dd (a => 2).Mix (^) (a => 10).Mix (^) (a => 2).Mix

[15:06] <camelia> rakudo-moar 19cdcd: OUTPUT: «Type check failed in binding to parameter 'elems'; expected Any but got Mu (Mu)␤  in block <unit> at <tmp> line 1␤␤»

[15:06] <Zoffix> c: HEAD~10 dd (a => 2).Mix (^) (a => 10).Mix (^) (a => 2).Mix

[15:06] <committable6> Zoffix, ¦HEAD~10: «("a"=>6).Mix»

[15:06] <Zoffix> So that ^ makes sense to me, but....

[15:06] <Zoffix> c: HEAD~10 dd (a => 8).Mix (^) (a => 10).Mix (^) (a => 8).Mix

[15:06] <committable6> Zoffix, ¦HEAD~10: «("a"=>6).Mix»

[15:06] <Zoffix> wat?

[15:07] <lizmat> 16 - 10

[15:07] <lizmat> (8+8)-10

[15:07] <Zoffix> Wouldn't then the first one be (2+2)-10 = -6?

[15:08] <Zoffix> Ahhhh

[15:08] <Zoffix> (8, 10) => (10-8) => 2; (2, 8) => (8-2) => 6

[15:09] <Zoffix> c: HEAD~10 dd (a => 8).Mix (^) (a => 10).Mix (^) (a => 3).Mix

[15:09] <committable6> Zoffix, ¦HEAD~10: «("a"=>1).Mix»

[15:09] <Zoffix> cool

[15:09] <lizmat> that is yuck

[15:09] <Zoffix> :)

[15:10] <lizmat> m: dd (a => 8).Mix (^) (a => 10).Mix (^) (a => 8).Mix

[15:10] <camelia> rakudo-moar 19cdcd: OUTPUT: «Type check failed in binding to parameter 'elems'; expected Any but got Mu (Mu)␤  in block <unit> at <tmp> line 1␤␤»

[15:10] <lizmat> ah, I borked that

[15:11] <lizmat> so, we expect a => -6 on that last one, right ?

[15:11] <lizmat> aka 10 - 8 - 8

[15:12] <lizmat> c: HEAD~10 dd (a => 8).Mix (^) (a => 10).Mix (^) (a => 10).Mix

[15:12] <committable6> lizmat, ¦HEAD~10: «("a"=>8).Mix»

[15:12] <lizmat> wat ?

[15:13] <Zoffix> lizmat: -6 would be my intutive expectation yeah: take largest value, subtract all of the rest out of it

[15:13] <Zoffix> (8, 10) => 2; (2, 10) => 8

[15:14] <lizmat> ah, yes

[15:14] <Zoffix> c: HEAD~10 dd set(<a>).Bag (^) set(<a>).Bag (^) set(<a>).Bag

[15:14] <committable6> Zoffix, ¦HEAD~10: «("a"=>1).Bag»

[15:14] <Zoffix> But then... would that end up as empty?

[15:14] <Zoffix> 1-1-1; vs (1-1) => 0; (1-0) => 1

[15:15] <Zoffix> ¯\_(ツ)_/¯

[15:15] <lizmat> the coercion to bag is => 1

[15:15] <Zoffix> Maybe TimToady has an idea

[15:15] <lizmat> yeah, I'm thinking about reverting the last few commits

[15:15] <Zoffix> c: HEAD~10 dd set(<a>) (^) set(<a>) (^) set(<a>)

[15:15] <committable6> Zoffix, ¦HEAD~10: «set()»

[15:15] <Zoffix> This does end up empty. So *shrug*

[15:17] <Zoffix> NeuralAnomaly: status

[15:17] <NeuralAnomaly> Zoffix, [✘] Next release will be in 1 day and 1 week. Since last release, there are 17 new still-open tickets (6 unreviewed and 0 blockers) and 170 unreviewed commits. See http://perl6.fail/release/stats for details

[15:18] <Geth> ¦ rakudo/nom: 904db7a113 | (Elizabeth Mattijsen)++ | src/core/set_operators.pm

[15:18] <Geth> ¦ rakudo/nom: Revert work on (-) for now

[15:18] <Geth> ¦ rakudo/nom:

[15:18] <Geth> ¦ rakudo/nom: Until we have clarity on how (^) and (-) should work on Mixes and Bags.

[15:18] <Geth> ¦ rakudo/nom: review: https://github.com/rakudo/rakudo/commit/904db7a113

[15:20] <lizmat> hmmm... I'm wondering whether the chained behaviour of (^) and (-) isn't really the result of codegen

[15:28] * TimToady is too busy thinking about how to unify Cursor and Match to have any ideas...

[15:29] <Zoffix> We just need to come up with behaviour for Mixes that degenerates into Bag and Set cases.

[15:32] <lizmat> ok, no worries:  $m (-) $m (-) $m and [(-)] $m,$m,$m execute the same way

[15:32] <TimToady> do we allow antiballs in a Bag currently?  seems to me if you want negative Mix values you need to allow negative Bag values...but then the problem becomes negative Set values, which set theory doesn't have

[15:33] <lizmat> TimToady: I think we decided Bags should never have negative values

[15:33] <lizmat> if you want negative Bag values, use a Mix with integer weights

[15:34] <TimToady> well, but that's a semantic discontinuity, if you're looking for degenerate behavior to be the same...

[15:34] <TimToady> so it seems like there has to be a discontinuity somewhere, we just need to be clear where it is

[15:34] <lizmat> perhaps Bag (-) Bag should return a Mix

[15:35] <lizmat> ?

[15:35] <Zoffix> "take largest value and subtract the rest" fits.

[15:35] <lizmat> for (^) right?

[15:35] <lizmat> and for (-): take first value and subtract the rest

[15:35] <Zoffix> Right

[15:35] <TimToady> maybe we need to distinuish signed Mixys from unsigned Mixys...

[15:36] <Zoffix> And then (^) is symmetrical version of (-), where it doesn't matter how the args are ordered, you always get the same result.

[15:36] <Zoffix> m: dd (:a(-10)).Mix.Bag

[15:36] <camelia> rakudo-moar 904db7: OUTPUT: «().Bag␤»

[15:37] <TimToady> then we'd have UBag and UMix to represent the versions that clamp to positive

[15:37] <lizmat> .oO( I won't say "yuck" )

[15:37] <Zoffix> And USet? :)

[15:37] <TimToady> and Set is the same as USet :)

[15:40] <TimToady> or we let people say Mixy[UInt] or so to get unsigny ones, or Mixy[Int] to get signy ones, whatever we pick for the default

[15:40] <Zoffix> But then there's still this discontinuity that we currently have for Mix -> Bag; (:20a).Mix (^) (:30a).Mix (^) (:15a).Mix => (:a(-5)).Mix (:20a).Bag (^) (:30a).Bag (^) (:15a).Bag => ().Bag, so then if we're adding UBag, that'd be (:a(-5)).Bag; but then set(<a>) (^) set(<a>) (^) set(<a>) would need to end up as (:a(-1)).Set;

[15:40] <TimToady> well, probably need another param for the key type eventually

[15:42] <TimToady> this is probably an area where it's mathematically provable that we can't have our cake and eat it too :)

[15:42] <lizmat> isn't that just moving the problem from Bag (^) Mix to Mix(Uint] (^) Mix ?

[15:42] <Zoffix> Or we could leave the stuff the same and just not have negatives in Bags. (:20a).Bag (^) (:30a).Bag (^) (:15a).Bag => ().Bag would be the right answer an

[15:43] <lizmat> .oO( guess I picked the wrong time to be optimising set operators )

[15:43] <TimToady> well, I think standard bag theory doesn't have negatives

[15:43] <Zoffix> The -1 => nothing is the degenerativeness of a Mix -> Bag conversion to me, same as 1.1 -> 1

[15:43] <Zoffix> Is there standard mix theory?

[15:44] * lizmat pictures Tom Cruise

[15:44] <Zoffix> heh "math bag theory" gives me big bang in google. It auto-suggests without even giving me an option to opt out of it :\

[15:44] <TimToady> or maybe we want to clamp Mix like Bag, and then define something beyond Mix that also allows negatives, but throws them away when you downcast

[15:45] <lizmat> but Mix has allowed negative weights since 6.c

[15:46] <TimToady> and we can decide to leave it that way, recognizing that we're really trying to do two different things with it, I suppose

[15:46] <TimToady> and Mix subtraction is an entirely different beasty than Bag subtraction

[15:47] <TimToady> or is it "beastie"?

[15:47] <TimToady> darn English orthography...

[15:47] <TimToady> .oO(orthographie?)

[15:47] <Zoffix> :P

[15:49] <lizmat> summary: (^) will take largest value and subtract all of the others

[15:49] <Zoffix> +1

[15:49] <lizmat> (-) will take first value and subtract all of the others

[15:50] <lizmat> only at the end of a chain of subtractions, will the elements with weight 0 be removed

[15:52] <TimToady> if we're going to allow negatives in Mixes, we should make sure there's a handy method to remove negatives if positive clamping is wanted

[15:52] <lizmat> so algorithmically, the difference between the two is that for (^) we first create a hash with the highest value * 2

[15:52] <lizmat> as opposed to (-) where we just take the first

[15:53] <lizmat> TimToady: we *have* been allowing negative weights in Mixes since way before Christmas

[15:53] <TimToady> so do we have such a method?

[15:54] <lizmat> no, but one would be easily created

[15:54] <Zoffix> m: dd (:a(-10), :42b).Mix.grep(*.value > 0).Mix

[15:54] <camelia> rakudo-moar 904db7: OUTPUT: «("b"=>42).Mix␤»

[15:54] <TimToady> I guess that has to be done differently for Mix vs MixHash

[15:54] <TimToady> MixHash could remove negatives in place

[15:55] <lizmat> yeah

[15:55] <TimToady> a Mix method would have to return a new Mix

[15:55] <lizmat> so, name bikeshedding commences  :-)

[15:55] <lizmat> .positively

[15:55] <Zoffix> .u

[15:55] <yoleaux2> Search for a Unicode character by codepoint, name, or raw character

[15:55] <TimToady> well, or it always returns a new one, and you use .= on MixHash to do it in place

[15:56] <lizmat> .Mix(UInt) ?

[15:57] <Zoffix> But 1.5 isn't UInt

[15:57] <lizmat> ah, yeah

[15:57] <TimToady> in general, our coercers have not taken extra args

[15:57] <TimToady> in general I'd prefer if type parameterizion stays in roles

[15:57] <Zoffix> IMO we don't need a method unless we're adding a UMix type that will reject negatives same as Bag does.  .grep(*.value > 0) isn't that much typing

[15:58] <lizmat> Zoffix: but that explodes the combinatorial of Mix Umix Bag Set and its combinations wrt set operators

[15:59] <TimToady> .oO(MixyBridge...)

[15:59] <Zoffix> How? Set < Bag < UMix < Mix; One fits a subset of the next one.

[15:59] <Zoffix> UMix (^) Mix returns a Mix

[16:00] <lizmat> hmmm... UMix could actually be implemented as a subclass of Mix with its own SANITY method

[16:00] <Zoffix> I dunno; is there any user demand for this stuff?

[16:00] <TimToady> good question

[16:01] <lizmat> well, one of the reasons I'm working on this is to make set ops like not be ultra, ultra slow so nobody wants to use them

[16:01] <TimToady> it's not all that hard to write one's own mix to umix coercer, really

[16:02] <TimToady> so I'm okay with leaving the current types with the current(ish) semantics

[16:03] <TimToady> and we can leave enforcement of positive mixes in the user's operational sphere

[16:03] <TimToady> unless we decide people are going to define .positively in the wrong way somehow

[16:04] <lizmat> but (-) and (^) would still get unexpected behaviour for Mix.positively mixes if they're still Mixes

[16:04] <TimToady> well, people would have to know when to apply it, and when not to

[16:05] <lizmat> for a UMix (a => 10).UMix (-) (a => 20).UMix would be UMix()

[16:05] <lizmat> but would be (a => -10).Mix for Mixes

[16:05] <TimToady> yes, I'm not against adding a UMix type, though that's kind of an ugly name...

[16:06] <lizmat> RealBag

[16:06] <lizmat> :-)

[16:06] <TimToady> but I'm also fond of not having combinatorial explosions :)

[16:07] <TimToady> .oO(that person is a RealBagHash!)

[16:07] <Geth> ¦ rakudo/nom: 15a25da899 | (Zoffix Znet)++ | src/core/IO/Path.pm

[16:07] <Geth> ¦ rakudo/nom: [io grant] Fix ambiguity in empty extension vs no extension

[16:07] <Geth> ¦ rakudo/nom:

[16:07] <Geth> ¦ rakudo/nom: When we go to replace an extension, an empty string extension

[16:07] <Geth> ¦ rakudo/nom: indicates both, lack of extension and a 1-part empty-string

[16:07] <Geth> ¦ rakudo/nom: extension. Add an extra check for whether the basename ends

[16:07] <Geth> ¦ rakudo/nom: with a dot to detect the latter.

[16:07] <Geth> ¦ rakudo/nom:

[16:07] <Geth> ¦ rakudo/nom: Fixes ".".IO.extension("doc") ending up as "..doc"

[16:07] <Geth> ¦ rakudo/nom: instead of just ".doc"

[16:07] <Geth> ¦ rakudo/nom: review: https://github.com/rakudo/rakudo/commit/15a25da899

[16:09] <Geth> ¦ roast: 2f09f182cf | (Zoffix Znet)++ | S32-io/io-path-extension.t

[16:09] <Geth> ¦ roast: [io grant] Fix incorrect test

[16:09] <Geth> ¦ roast:

[16:09] <Geth> ¦ roast: "." has a 1-part empty extension, so correct the test that expects

[16:09] <Geth> ¦ roast: replaced version to be "..doc"

[16:09] <Geth> ¦ roast: review: https://github.com/perl6/roast/commit/2f09f182cf

[16:09] <TimToady> unfortunately, the "mix" metaphor most naturally fits with the unsigned semantics, but I'm not sure I'm willing to move the signed semantics to a different type

[16:09] <Geth> ¦ roast: 305f206551 | (Zoffix Znet)++ | S32-io/io-path-extension.t

[16:09] <Geth> ¦ roast: [io grant] Test empty-string extensions in IO::Path.extension

[16:09] <Geth> ¦ roast:

[16:09] <Geth> ¦ roast: Rakudo fix: https://github.com/rakudo/rakudo/commit/15a25da899

[16:09] <Geth> ¦ roast: review: https://github.com/perl6/roast/commit/305f206551

[16:10] <TimToady> though that is the sort of thing we can think about breaking in a language upgrade

[16:10] <Zoffix> Can we though? From briefly scanning the upgrade doc, replacing the types or making their methods do different things is a hard thing to do.

[16:11] <TimToady> but only if we add a new type and deprecate any negative Mixes we see

[16:11] <Zoffix> huggable: versioning

[16:11] <huggable> Zoffix, https://gist.github.com/jnthn/c10742f9d51da80226fa

[16:12] <TimToady> we can't always be additive in a 100-year language, so some deprecation cycles will have to be allowed

[16:12] <Zoffix> Great :D

[16:12] <TimToady> but certainly additive is preferable when we can get away with it

[16:13] <jnthn> I'd hope we can at least manage additive for a few years, to give us the breathing space we need to figure out non-additive. :)

[16:13] <yoleaux2> 6 Apr 2017 13:06Z <lizmat> jnthn: looking at https://github.com/rakudo/rakudo/blob/nom/src/core/Iterable.pm#L82  , I'm not sure how Iterable.lazy actually works.  Feels to me at least the comments are incorrect

[16:13] <yoleaux2> 6 Apr 2017 13:14Z <lizmat> jnthn: I also don't grok why Iterable.lazy is not initialized with the iterator to start with

[16:13] <yoleaux2> 6 Apr 2017 15:13Z <Zoffix> jnthn: I'd like to add nqp::p6int_I(); that truncates an Int to fit into `int`. There are many places where super large values don't make sense, but to give PDG errors we stick to Int nqp ops, and lose some perf. With nqp::p6int_I() we'll truncate all super large Ints into int and use the int p6 ops on them. Do you see problems with adding such a thing? In .extension() using int instead of Int gives a

[16:13] <yoleaux2> 6 Apr 2017 15:13Z <Zoffix> jnthn: ~30% perf boost

[16:13] <yoleaux2> 6 Apr 2017 15:17Z <Zoffix> jnthn: or rather... in my bench: using Ints is 2x slower than old method; using ints is 1.66x slower; whatever the diff there is is the benefit of ints that I want to capture.

[16:13] <jnthn> o.O

[16:13] <lizmat> :-)

[16:14] <TimToady> I'm okay with leaving Mix as is, anyway, and we can slide in a different type for umix/rbag if we decide it's warranted

[16:15] <lizmat> m: dd (a => 1).Mix (-) (a => 2).Mix # do we agree this is wrong ?

[16:15] <camelia> rakudo-moar 15a25d: OUTPUT: «().Mix␤»

[16:15] <lizmat> that it should be (a => -1).Mix ?

[16:16] <TimToady> how long has that been broken?

[16:16] <lizmat> quite long I'm afraid

[16:16] <TimToady> and nobody's complained? there's a data point... :D

[16:16] <lizmat> TimToady: the implementation is *ultra* slow

[16:17] <lizmat> it's not for nothing that some improvements I've made are like 80x faster

[16:17] <lizmat> the data point could be as much as people don't use slow systems

[16:17] <lizmat> b: dd (a => 1).Mix (-) (a => 2).Mix

[16:17] <bisectable6> lizmat, On both starting points (old=2015.12 new=b62d1a7) the exit code is 0 and the output is identical as well

[16:17] <bisectable6> lizmat, Output on both points: «().Mix»

[16:18] <TimToady> it's still possible that nobody has used Mixes with the intention of having negatives

[16:19] <lizmat> true

[16:19] <Zoffix> lizmat: yeah, I agree. Both that it should be :a(-1) and that people avoided them due to slowness (it was a direct comment on my advent mixies/baggies article)

[16:20] <lizmat> and the 80x improvement is for objects with fast .WHICH methods

[16:21] <lizmat> if you would create sets of hashes, it would probably be even order of magnitudes slower

[16:22] <lizmat> because .WHICH would get recalculated many times over

[16:22] <lizmat> any Mix{} or Mix.AT-KEY() would imply a .WHICH calculation

[16:37] <lizmat> dinner&

[16:44] <jnthn> .tell lizmat I don't see anything immediately wrong in the comment. Note that the hiding of push-at-least is implicit (the method it gets from the role just delegates to push-exactly)

[16:44] <yoleaux2> jnthn: I'll pass your message to lizmat.

[16:45] <jnthn> .tell lizmat I guess it only obtains the iterator when needed as part of its laziness.

[16:45] <yoleaux2> jnthn: I'll pass your message to lizmat.

[16:45] <Zoffix> fwiw lizmat pointed out that my nqp::p6int_I op won't get speshed and so won't get perf boost I see, so I'm not so keen on adding it anymore.

[16:46] <Zoffix> But would be nice to have something nicer than stuff like this:

[16:46] <Zoffix> m: ^10 .head: *-Inf

[16:46] <camelia> rakudo-moar 15a25d: OUTPUT: «This type cannot unbox to a native integer: P6opaque, Num␤  in block <unit> at <tmp> line 1␤␤»

[16:46] <jnthn> When would you actually want to truncate silently?

[16:47] <Zoffix> jnthn: like IO::Path.extension. You won't have more than 2**63-1 extension parts

[16:47] <Zoffix> "x" xx 2**63-1 stuff like this maybe?

[16:48] <jnthn> We've had so many RTs that complain about "I fed this super unreasonably use value to foo and it overflowed/truncated to some special number" that I really don't feel like introducing an op that explicitly makes that happen :P

[16:48] <jnthn> *unreasonably huge

[16:48] <jnthn> Well, the policy we've gone with so far is "if it's too big just throw"

[16:48] <jnthn> So just use nqp::unbox_i, which I think will throw on ridiculously big

[16:49] <jnthn> And is otherwise pretty efficient

[16:49] <Zoffix> jnthn: those RTs would be solved by the truncation. The tickets were: I used super large number and it becomes negative; or I've used this unreasonbly large Int and it threw an LTA error

[16:49] <jnthn> Yes, and we've largely fixed those by making nqp::unbox_i throw a decent error, no?

[16:49] <jnthn> Plus various other such cases

[16:49] <jnthn> m: my int $i = 2 ** 65

[16:49] <camelia> rakudo-moar 15a25d: OUTPUT: «Cannot unbox 66 bit wide bigint into native integer␤  in block <unit> at <tmp> line 1␤␤»

[16:49] <Zoffix> And IIRC all of these LTA errors were avoided by switching to using slow, big_I path

[16:49] <Zoffix> At least, that's what I done in .extension

[16:50] <jnthn> You only need to unbox the value once at entry to the method, though?

[16:50] <Zoffix> Inf alone makes just-unboxing tough

[16:50] <Zoffix> since it isn't an int

[16:50] <Zoffix> m: use nqp; nqp::unbox_i(Inf)

[16:50] <camelia> rakudo-moar 15a25d: OUTPUT: «This type cannot unbox to a native integer: P6opaque, Num␤  in block <unit> at <tmp> line 1␤␤»

[16:51] <jnthn> Adding an unbox_I isn't going to help on that front

[16:51] <jnthn> Or whatever you wanted to call it :)

[16:51] <jnthn> I'd just make that case fall out of multi-dispatch, though

[16:51] <Zoffix> nqp::p6int_N() would :) It would turn it into 2**63-1 :D

[16:52] <Zoffix> I guess I need to catalogue all these usecases first :)

[16:53] <jnthn> So have a candidate that works on Num or so, and does the extra checks there and delegates to an Int candidate

[16:53] <jnthn> And for the common case where an Int is passed, then you don't have to execute that code dealing with Num and Inf at all

[16:54] <Zoffix> That's what I did for .extension yesterday: https://github.com/rakudo/rakudo/blob/nom/src/core/Rakudo/Internals.pm#L348-L373

[16:54] <Zoffix> And .extension(:parts(1..1)) is like 10x slower than .extension(:parts(1))

[16:55] <Zoffix> m: my $p = "foo.txt".IO; for ^100_000{ $ = $p.extension: :parts(1) }; say now - INIT now

[16:55] <camelia> rakudo-moar 15a25d: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Missing block (whitespace needed before curlies taken as a hash subscript?)␤at <tmp>:1␤------> 3 ^100_000{ $ = $p.extension: :parts(1) }7⏏5; say now - INIT now␤    expecting any of:␤        b…»

[16:55] <Zoffix> m: my $p = "foo.txt".IO; for ^100_000 { $ = $p.extension: :parts(1) }; say now - INIT now

[16:55] <camelia> rakudo-moar 15a25d: OUTPUT: «0.796016␤»

[16:55] <Zoffix> m: my $p = "foo.txt".IO; for ^100_000 { $ = $p.extension: :parts(1..1) }; say now - INIT now

[16:55] <camelia> rakudo-moar 15a25d: OUTPUT: «5.580508␤»

[16:56] <Zoffix> m: my $p = "foo.txt".IO; for ^100_000 { $ = $p }; say now - INIT now

[16:56] <jnthn> Are people liable to actually write 1..1? :)

[16:56] <camelia> rakudo-moar 15a25d: OUTPUT: «0.0647822␤»

[16:56] <Zoffix> m: say (5.52/.73)

[16:56] <camelia> rakudo-moar 15a25d: OUTPUT: «7.561644␤»

[16:56] <Zoffix> 7.5x

[16:56] <jnthn> .oO( They aren't if it's 7.5x slower :P )

[16:57] <Zoffix> :)

[16:58] <Zoffix> But anyway, don't want to add any ops anymore, but will keep an eye on when this clash of HLL vs. native types  occurs, to see if there's a Better Way™

[16:58] <jnthn> fwiw, && and || compile into nqp::if and nqp::unless

[16:59] <jnthn> So your nqp::if nest at the start of the routine could be written with && instead of nqp::if for no loss, and a readability win :)

[16:59] <Zoffix> jnthn: ah, thanks.

[17:00] <jnthn> yay, pizza is here :)

[17:00] <jnthn> bbl

[17:10] <AlexDaniel> \o/ more rejected tickets

[17:10] <AlexDaniel> :)

[17:17] <Zoffix> m: say so any("flarg",42)».Numeric

[17:17] <camelia> rakudo-moar 15a25d: OUTPUT: «True␤»

[17:18] <Zoffix> AlexDaniel: I'm just gonna ignore it.

[17:18] <Zoffix> Clearly I'm doing something wrong every time I interface with humans, so I'll stick to code.

[17:18] <Zoffix> And an AI robot who'll keep me company in here \o/

[17:18] <AlexDaniel> Zoffix: I was referring to another ticket of mine which was closed not so long ago by jnthn

[17:19] <AlexDaniel> or, rejected by jnthn but closed by [Coke] :)

[17:19] <Zoffix> AlexDaniel: ah, I see

[17:19] <Zoffix> AlexDaniel: putting a dent into my record? :)

[17:19] <AlexDaniel> heh

[17:20] <AlexDaniel> but it makes sense. As the language is getting more mature, design decisions are sorted out and clarified, so more rejected tickets because of a clearer picture

[17:21] <AlexDaniel> I wonder if you graph the number of rejections over months, will you see it going up like crazy? :)

[17:22] <Zoffix> m: say any("flarg",42)».Numeric.WHAT

[17:22] <camelia> rakudo-moar 15a25d: OUTPUT: «(Junction)␤»

[17:22] <Zoffix> Is there a way to make it print out the types inside the junction?

[17:22] <Zoffix> Oh, right

[17:23] <Zoffix> m: say sub ($_) { .^name }( any("flarg",42)».Numeric )

[17:23] <camelia> rakudo-moar 15a25d: OUTPUT: «any(List, List)␤»

[17:23] <Zoffix> .. list? :S

[17:23] <Zoffix> m: say sub ($_) { .^name }( any("flarg",42).Numeric )

[17:23] <camelia> rakudo-moar 15a25d: OUTPUT: «Cannot resolve caller Numeric(Str: ); none of these signatures match:␤    (Mu:U \v: *%_)␤  in block <unit> at <tmp> line 1␤␤»

[17:23] <Zoffix> m: say sub ($_) { .^name }( +any("flarg",42) )

[17:23] <camelia> rakudo-moar 15a25d: OUTPUT: «any(Failure, Int)␤»

[17:23] <Zoffix> Success \o/.

[17:24] <AlexDaniel> m: say Numeric(any(52,42))

[17:24] <camelia> rakudo-moar 15a25d: OUTPUT: «Cannot invoke this object (REPR: Uninstantiable; Numeric)␤  in block <unit> at <tmp> line 1␤␤»

[17:24] <AlexDaniel> I wonder if this should work

[17:24] <Zoffix> m: try say sub ($_) { .^name }( any("flarg",42) == 42 )

[17:24] <camelia> rakudo-moar 15a25d: ( no output )

[17:24] <AlexDaniel> or, at least, not give an error like this?

[17:25] <Zoffix> m: try { say sub ($_) { .^name }( any("flarg",42) == 42 ) }

[17:25] <camelia> rakudo-moar 15a25d: ( no output )

[17:26] <Zoffix> m: try { say sub ($_) { .^name }( any("flarg",42) == 42 ); CATCH { default { .resume } } }

[17:26] <camelia> rakudo-moar 15a25d: OUTPUT: «This exception is not resumable␤  in block  at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[17:29] <Zoffix> m: any("flarg",0).Numeric

[17:29] <camelia> rakudo-moar 15a25d: OUTPUT: «Cannot resolve caller Numeric(Str: ); none of these signatures match:␤    (Mu:U \v: *%_)␤  in block <unit> at <tmp> line 1␤␤»

[17:29] <Zoffix> AlexDaniel: well, I would've expected ^ that to work :/

[17:30] <AlexDaniel> Zoffix: that's a method called on a junction, no?

[17:30] <Zoffix> AlexDaniel: which propagtes it into all elements, no?

[17:31] <Zoffix> m: dd any("flarg",42).uc

[17:31] <camelia> rakudo-moar 15a25d: OUTPUT: «any("FLARG", "42")␤»

[17:31] <Zoffix> m: dd any("flarg",42).flip

[17:31] <camelia> rakudo-moar 15a25d: OUTPUT: «any("gralf", "24")␤»

[17:31] <AlexDaniel> Zoffix: but if so, how would you call methods of Junction?

[17:31] <AlexDaniel> hm

[17:31] <AlexDaniel> m: say Junction ~~ Cool

[17:31] <camelia> rakudo-moar 15a25d: OUTPUT: «False␤»

[17:32] <Zoffix> AlexDaniel: you define them in Junction.pm, I guess. Rather verbose .Bool and .defined are there

[17:33] <AlexDaniel> m: say any(52.5,42.5).Int

[17:33] <camelia> rakudo-moar 15a25d: OUTPUT: «any(52, 42)␤»

[17:33] <AlexDaniel> so you can do .Int but not .Real or .Numeric

[17:33] <Zoffix> method AUTOTHREAD is that what does all the magic?

[17:33] <Zoffix> Or CALL-ME? https://github.com/rakudo/rakudo/blob/nom/src/core/Junction.pm#L221

[17:33] <Zoffix> m: class { method CALL-ME (|) { say "here" }; method AUTOTHREAD { say "there" } }.meows

[17:33] <camelia> rakudo-moar 15a25d: OUTPUT: «No such method 'meows' for invocant of type '<anon|78278192>'␤  in block <unit> at <tmp> line 1␤␤»

[17:33] <Zoffix> :(

[17:37] <Zoffix> Looks like all the magic is in the binder that passes stuff through Junction.AUTOTHREAD

[17:41] <AlexDaniel> m: say 42; say +any(‘abc’, 42.5)

[17:41] <camelia> rakudo-moar 15a25d: OUTPUT: «42␤===SORRY!===␤Cannot convert string to number: base-10 number must begin with valid digits or '.' in '3⏏5abc' (indicated by ⏏)␤»

[17:41] <AlexDaniel> ok, that's not good

[17:41] <Zoffix> Why not?

[17:42] <Zoffix> Missing line number?

[17:42] <AlexDaniel> Zoffix: run time ===SORRY!===, no line number

[17:42] <Zoffix> Ah

[17:42] <AlexDaniel> mch: say 42; say +any(‘abc’, 42.5)

[17:42] <committable6> AlexDaniel, ¦2015.12,HEAD(b62d1a7): «42␤===SORRY!===␤Cannot convert string to number: base-10 number must begin with valid digits or '.' in '03⏏04abc' (indicated by ⏏) «exit code = 1»»

[17:42] * Zoffix files the Numeric(Str:) one

[17:42] <Zoffix> Junction bug day \o/

[17:42] <AlexDaniel> ya

[17:42] <AlexDaniel> maybe we can also make them faster along the way

[17:43] <Zoffix> heh

[17:48] <AlexDaniel> ok RT #131118

[17:48] <AlexDaniel> … I mean #RT 131119

[17:50] * Zoffix toggles the power switch on synopsebot

[17:50] <Zoffix> \o/

[17:50] <Zoffix> RT#131119

[17:50] <synopsebot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=131119

[17:50] <Zoffix> And mine is https://rt.perl.org/Ticket/Display.html?id=131120

[17:51] * Zoffix & for the rest of the day

[17:53] <Geth> ¦ rakudo/nom: 7ba2fc5a0e | (Elizabeth Mattijsen)++ | src/core/Any-iterable-methods.pm

[17:53] <Geth> ¦ rakudo/nom: Make error on .head(*-Inf) less LTA

[17:53] <Geth> ¦ rakudo/nom:

[17:53] <Geth> ¦ rakudo/nom: Spotted by Zoffix++

[17:53] <Geth> ¦ rakudo/nom: review: https://github.com/rakudo/rakudo/commit/7ba2fc5a0e

[18:03] <AlexDaniel> m: say (25, 42, 50).tail(*-2)

[18:03] <camelia> rakudo-moar 15a25d: OUTPUT: «Cannot resolve caller Numeric(WhateverCode: ); none of these signatures match:␤    (Mu:U \v: *%_)␤  in block <unit> at <tmp> line 1␤␤»

[18:10] <lizmat> AlexDaniel: it's .head, not .tail

[18:10] <yoleaux2> 16:44Z <jnthn> lizmat: I don't see anything immediately wrong in the comment. Note that the hiding of push-at-least is implicit (the method it gets from the role just delegates to push-exactly)

[18:10] <yoleaux2> 16:45Z <jnthn> lizmat: I guess it only obtains the iterator when needed as part of its laziness.

[18:11] <AlexDaniel> lizmat: d-oh! Thanks!

[18:11] <AlexDaniel> m: say (25, 42, 50).head(*-2)

[18:11] <camelia> rakudo-moar 7ba2fc: OUTPUT: «(25)␤»

[18:12] <lizmat> the d-oh was on me last night  :-)

[18:12] <AlexDaniel> commit: HEAD say (25, 42, 50).head(*-2)

[18:12] <committable6> AlexDaniel, ¦HEAD(b62d1a7): «Cannot resolve caller Real(WhateverCode: ); none of these signatures match:␤    (Mu:U \v: *%_)␤  in block <unit> at /tmp/mZtldtwblK line 1␤ «exit code = 1»»

[18:12] <lizmat> m: say (^Inf).head(* - 5).[^10]

[18:12] <camelia> rakudo-moar 7ba2fc: OUTPUT: «(0 1 2 3 4 5 6 7 8 9)␤»

[18:12] * AlexDaniel slaps committable6

[18:13] <AlexDaniel> what the hell, why is it stuck on some really old commit

[18:13] <Zoffix> m: say (25, 42, 50).tail(3-2)

[18:13] <camelia> rakudo-moar 7ba2fc: OUTPUT: «(50)␤»

[18:13] <Zoffix> m: say (25, 42, 50).tail(*)

[18:13] <camelia> rakudo-moar 7ba2fc: OUTPUT: «(25 42 50)␤»

[18:13] <Zoffix> m: say (25, 42, 50).tail(*-2)

[18:13] <camelia> rakudo-moar 7ba2fc: OUTPUT: «Cannot resolve caller Numeric(WhateverCode: ); none of these signatures match:␤    (Mu:U \v: *%_)␤  in block <unit> at <tmp> line 1␤␤»

[18:14] <Zoffix> m: say (25, 42, 50).head(2)

[18:14] <camelia> rakudo-moar 7ba2fc: OUTPUT: «(25 42)␤»

[18:14] <Zoffix> .oO( .tail(*-2) => "all but the first two" )

[18:14] <lizmat> yeah, was thinking that just now

[18:14] * Zoffix &

[18:14] <lizmat> makes sense I guess

[18:15] <AlexDaniel> commit: 7ba2fc5a0e92 say (25, 42, 50).head(*-2)

[18:15] <committable6> AlexDaniel, ¦7ba2fc5: «Cannot find this revision (did you mean “34a4c0a”?)»

[18:15] <AlexDaniel> committable6: I'll kill you :S

[18:15] <committable6> AlexDaniel, ¦I'll: «Cannot find this revision (did you mean “all”?)»

[18:17] <cowens> What are CompUnit::Repository::AbsolutePath<140211490473264>, CompUnit::Repository::NQP<140211475454056>, CompUnit::Repository::Perl5<140211475454096>?  I assume they are additional ways to get modules, but do they have file paths?

[18:19] <TimToady> is there any way in nqp to do the equivalent of: constant ThisType = ThatType;  ?

[18:19] <TimToady> jnthn: ^^

[18:20] <TimToady> (trying to get around some bootstrapping issue on my experiment in cursor/match unification)

[18:20] <samcv> good morning everyone

[18:21] <TimToady> very nearly good afternoon :)

[18:31] <perlnecrohacker> gm

[18:31] <[Coke]> o/

[18:32] <perlnecrohacker> \m/

[18:33] <jnthn> TimToady: Um...trying to think of one

[18:33] <jnthn> TimToady: You just need a way to alias a symbol to a value?

[18:33] <jnthn> (At compile time)

[18:37] <jnthn> TimToady: I think the simplest way is for me to just implement it :P

[18:42] <TimToady> well, the specific case is that I would like to make NQPMatch an alias to NQPCursor, or vice versa, because I have an nqp where those really are the same thing, and compiles up all the way through to trying to compile the P6 setting before it blows sky high :)

[18:43] <TimToady> but I think turning .MATCH into (close to) a no-op is going to be much faster in the long run

[18:43] <TimToady> though for now the Cursor is just being a Capture in addition to cursoring, and .MATCH just builds the array/hash into the capture instead of the match object

[18:44] <jnthn> Will my constant do or do you need package scoped?

[18:44] <TimToady> (the cursor still has a stub $!match because certain things depend on it algorigthmically, but that is likely to change to a boolean, rather than an object that does nothing but return true :)

[18:45] <Geth> ¦ roast: 6aa2290b4b | (David Warring)++ | 2 files

[18:45] <Geth> ¦ roast: add fudged test for RT #131112

[18:45] <Geth> ¦ roast: review: https://github.com/perl6/roast/commit/6aa2290b4b

[18:45] <synopsebot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=131112

[18:45] <TimToady> well, I suppose that depends on where stage1 is looking up the old names

[18:45] <TimToady> I can certainly try 'my constant' to see if it's enough

[18:47] <TimToady> eventually I'd like to populate the "capture" inside the cursor/match lazily, but nqp isn't up to that yet

[18:47] <TimToady> so it still has to build it at MATCH time for now

[18:47] <TimToady> when we do get it lazily, we can also get rid of the artificial distinction of throwing in {} randomly to force .MATCH calls

[18:48] <jnthn> I'll add my and our :)

[18:49] <lizmat> jnthn: also, if you could give me a pointer on: https://rt.perl.org/Ticket/Display.html?id=131112

[18:50] <lizmat> I think that's a release blocker atm

[18:50] <jnthn> Ah

[18:51] <jnthn> Yeah, we've not used that as a standlone REPR before I guess

[18:51] <TimToady> currently nqp runs fine with only NQPCursor, and no NQPMatch, but I'd think I'd like to unify under the Match name rather than the Cursor name, and that's where I run into the bootstrap issue

[18:52] <samcv> jnthn, what version of MSVC should i download which is whatever the earliest we support

[18:52] <samcv> want to try compiling on windows

[18:53] <Geth> ¦ nqp: 4bb9e64157 | (Jonathan Worthington)++ | 2 files

[18:53] <Geth> ¦ nqp: Quick, partial, implementation of `constant`.

[18:53] <Geth> ¦ nqp:

[18:53] <Geth> ¦ nqp: * Needs writing as `my constant A := B` or `our constant C := D`

[18:53] <Geth> ¦ nqp: * Only supports having a typename on the RHS so far

[18:53] <Geth> ¦ nqp: review: https://github.com/perl6/nqp/commit/4bb9e64157

[18:53] <jnthn> TimToady: See if ^ will help

[18:53] <TimToady> \o/

[18:53] <lizmat> jnthn: nqp::hash() precomps fine afaics

[18:53] <jnthn> Sure

[18:53] <jnthn> This is an...interesting bit of legacy :)

[18:54] <jnthn> Should be easily addressed

[18:55] <lizmat> hmmm

[18:55] <jnthn> Yeah, src/6model/reprs/MVMHash.c needs the serialize and deserialize functions implemented

[18:55] <jnthn> Mildly surprised that didn't happen already :)

[18:56] <lizmat> well... if that happens, we can actually precomp quite a bit of initialization in the setting as well

[18:56] <lizmat> or am I missing something there ?

[18:56] <lizmat> (BTW, I was wrong about nqp::hash precomping ok()

[18:57] <lizmat> $ cat Tst.pm

[18:57] <lizmat> class Tst { use nqp; our constant X = nqp::hash }

[18:57] <lizmat> $ perl6 -I. -MTst -e 'say Tst::X'

[18:57] <lizmat> ===SORRY!===

[18:57] <lizmat> Missing serialize REPR function for REPR VMHash (BOOTHash)

[18:59] <jnthn> Yeah, can -e it too

[18:59] <perlnecrohacker> perl6 -I. -MTst -e 'say Tst::X'

[18:59] <perlnecrohacker> ===SORRY!===

[18:59] <perlnecrohacker> Could not find Tst at line 1 in:

[18:59] <perlnecrohacker> /home/perlowcoder

[18:59] <perlnecrohacker> /root/.perl6

[18:59] <perlnecrohacker> /root/.rakudobrew/moar-nom/install/share/perl6/site

[18:59] <perlnecrohacker> /root/.rakudobrew/moar-nom/install/share/perl6/vendor

[18:59] <perlnecrohacker> /root/.rakudobrew/moar-nom/install/share/perl6

[18:59] <perlnecrohacker> CompUnit::Repository::AbsolutePath<-1172939160>

[18:59] <perlnecrohacker> CompUnit::Repository::NQP<-1173688368>

[18:59] <perlnecrohacker> CompUnit::Repository::Perl5<-1173688344>

[18:59] <jnthn> If you --target=mbc

[19:00] <lizmat> jnthn: so do you tnink we will see nqp::hash precomp support in the next week?

[19:00] <lizmat> otherwise, I will need to take some action :-(

[19:01] <samcv> quick! what msvc is our oldest supported! somebody

[19:04] <jnthn> samcv: I don't know that we've declared any official policy on that

[19:04] <samcv> so what should i download

[19:04] <jnthn> I've got Microsoft (R) C/C++ Optimizing Compiler Version 17.00.61030 for x64 if that helps :)

[19:05] <samcv> so what msvc version is it

[19:06] <samcv> i am very confused about this

[19:06] <samcv> and does dling the visual C++ also build C?

[19:08] <jnthn> Yeah, it compiles C too

[19:08] <TimToady> jnthn: unfortunately, it just blows up earlier since stage1 doesn't know 'my constant', oh well

[19:08] <samcv> ok i think that may be 2012?

[19:08] <jnthn> TimToady: You can always update the bootstrap :)

[19:08] <samcv> based on what this says https://en.wikipedia.org/wiki/Microsoft_Visual_C%2B%2B#Common_MSVC_versions

[19:08] <samcv> since you have 17 i'm guessing that's _MSC_VER 1700

[19:08] <jnthn> samcv: Yes, that appears to be it :)

[19:09] <jnthn> Sorry, forgot the numbers don't map usefully to the thing they label it as

[19:10] <samcv> well i can get 2017 community for free. but they won't let me get earlier without subscription

[19:11] <samcv> well found 2015 build tools http://landinghub.visualstudio.com/visual-cpp-build-tools maybe that's what i need.

[19:13] <samcv> well. gonna go to windows computer and try to install i think maybe i found build tools 2013. so maybe that will have what i need

[19:15] <jnthn> lizmat: https://github.com/MoarVM/MoarVM/commit/9653dc6aa1 should do it

[19:15] <lizmat> whee...

[19:15] <lizmat> ok if I bump Moar and nqp ?

[19:15] <jnthn> lizmat: Yes, but please can you spectest it first?

[19:16] <jnthn> Need to visit the shop before it closes :)

[19:16] <lizmat> ack

[19:16] <jnthn> Well, set off a spectest here too, but it won't be done before I go :)

[19:16] <jnthn> bbiab :)

[19:20] <samcv> kk gonna try building ona 32-bit machine

[19:20] <samcv> strawberry perl, git, installing msvc. then that should be what i need right?

[19:21] <samcv> lol @strawberry perl can't be installed in a directory with spaces :O

[19:30] <Geth> ¦ rakudo/nom: a4b30dc7d1 | (Elizabeth Mattijsen)++ | 3 files

[19:30] <Geth> ¦ rakudo/nom: Make sure we get an IterationSet when assigning

[19:30] <Geth> ¦ rakudo/nom:

[19:30] <Geth> ¦ rakudo/nom: If a (Set|Bag|Mix)Hash was created empty, and was later assigned to it,

[19:30] <Geth> ¦ rakudo/nom: it would create an internal nqp::hash instead of an IterationSet,

[19:30] <Geth> ¦ rakudo/nom: causing havoc down the line.

[19:30] <Geth> ¦ rakudo/nom: review: https://github.com/rakudo/rakudo/commit/a4b30dc7d1

[19:35] <samcv> oh it used gcc

[19:35] <samcv> but idk where gcc came from. or what itstalled it. but that wasn't what i wanted. and it didn't actually compile properly

[19:36] <Geth> ¦ rakudo/nom: de983bc4dd | (Elizabeth Mattijsen)++ | src/core/Mix.pm

[19:36] <Geth> ¦ rakudo/nom: Make Mix.MixHash coercion about 25x faster

[19:36] <Geth> ¦ rakudo/nom:

[19:36] <Geth> ¦ rakudo/nom: For a 10 element Mix.

[19:36] <Geth> ¦ rakudo/nom: review: https://github.com/rakudo/rakudo/commit/de983bc4dd

[20:00] <Geth> ¦ roast: a906ddc387 | (Elizabeth Mattijsen)++ | S11-modules/require.t

[20:00] <Geth> ¦ roast: Unfudge now passing todo

[20:00] <Geth> ¦ roast: review: https://github.com/perl6/roast/commit/a906ddc387

[20:08] <Zoffix> m: dd [\<] 8, 9, 2

[20:08] <camelia> rakudo-moar de983b: OUTPUT: «(Bool::True, Bool::True, Bool::False).Seq␤»

[20:09] <Zoffix> I thought the triangle reduce used previous value, so it'd be True < 2 for the last one, which is True, not false

[20:10] <Zoffix> m: dd [\+] 8, 9, 2

[20:10] <camelia> rakudo-moar de983b: OUTPUT: «(8, 17, 19).Seq␤»

[20:11] <Zoffix> m: dd True < 2

[20:11] <camelia> rakudo-moar de983b: OUTPUT: «Bool::True␤»

[20:12] <Zoffix> m: dd [\(^)] (:10a).Mix, (:30a).Mix, (:20a).Mix

[20:12] <camelia> rakudo-moar de983b: OUTPUT: «(("a"=>10).Mix, ("a"=>20).Mix, ().Mix).Seq␤»

[20:13] <Zoffix> m: dd [\<=] 8, 9, 2

[20:13] <camelia> rakudo-moar de983b: OUTPUT: «(Bool::True, Bool::True, Bool::False).Seq␤»

[20:14] * Zoffix shrugs

[20:14] <lizmat> this could be a bug

[20:15] <lizmat> otoh, <= coerces Bool to 0|1

[20:30] <AlexDaniel> commit: 7ba2fc5a0e92 say (25, 42, 50).head(*-2)

[20:30] <committable6> AlexDaniel, ¦7ba2fc5: «(25)»

[20:30] <AlexDaniel> ok, fixed

[20:36] <Zoffix> lizmat: yeah, it does. So the True from 8 <= 9 is treated as 1 and 1 <= 2 is True not False that it gives for the last value

[20:36] <lizmat> AlexDaniel: so is there still something I should look at performance wise ?

[20:37] <Zoffix> But maybe it's normal, so that it gives right ansfer for the final result

[20:38] <Zoffix> Basically, I came upon this when thinking of using the (^) op in there. 'cause it has to know of the entire chain to give right result innit?

[20:38] <Zoffix> If we make it subtract stuff from largest elements

[20:38] <lizmat> not for (^) per se, but for (-) yes

[20:40] <Zoffix> Oh yeah, for (-) too :/

[20:40] <AlexDaniel> lizmat: possibly, but not sure if I can propose something :(

[20:42] <Zoffix> m: dd [\(-)] set(<a>), bag(<a b>), (:a(-20), :b(2), :c).Mix

[20:42] <camelia> rakudo-moar de983b: OUTPUT: «(set("a"), ().Bag, ().Mix).Seq␤»

[20:45] <Zoffix> m: dd [\(-)] set(<a>), bag(<a a a b>), (:a(-20), :b(2), :c).Mix

[20:45] <camelia> rakudo-moar de983b: OUTPUT: «(set("a"), ().Bag, ().Mix).Seq␤»

[20:46] <Zoffix> Right, 'cause it'd be -22 for 'a', but since Bag part would not do the negative the final result would be onpy -20 for 'a'

[20:49] <Zoffix> SmokeMachine: see now why I was hesitant to say [\...] would always return final item same as […]? :) Sometimes it can't, turns out

[20:55] <lizmat> hmmm.. did we lose Geth?

[20:55] <lizmat> I did 2 commits since https://github.com/rakudo/rakudo/commit/de983bc4dd

[20:57] <lizmat> Zoffix: perhaps Geth needs a kick ?

[20:59] <lizmat> Zoffix: can we "replay" the last 2 commits ?

[20:59] <lizmat> rakudo commits ?

[20:59] <Zoffix> weird. It was still connected and responsive (showed you talk in the log). Maybe GitHub's webhooks were down

[21:00] <Zoffix> lizmat: they can be replayed by clicking resend in Settings Webhooks in rakudo's repo but I don't have sufficient perms to the repo to do it myself

[21:00] <lizmat> I'll be committing shortly again

[21:02] * lizmat doesn't see any Settings at all

[21:02] <Zoffix> no issues in https://status.github.com/

[21:25] <geekosaur> I would expect the web hooks to be best effort

[21:27] <jnthn> I see some webhooks it claims were successfully delivered but didn't pop up here, fwiw

[21:34] <Geth> ¦ rakudo/nom: 2d8ac1e916 | (Elizabeth Mattijsen)++ | src/core/Mix.pm

[21:34] <Geth> ¦ rakudo/nom: Make Mix.BagHash coercion about 28x faster

[21:34] <Geth> ¦ rakudo/nom:

[21:34] <Geth> ¦ rakudo/nom: For a 10 element Mix.

[21:34] <Geth> ¦ rakudo/nom: review: https://github.com/rakudo/rakudo/commit/2d8ac1e916

[21:34] <lizmat> seems it works again

[21:34] <lizmat> commits missed:

[21:35] <lizmat> https://github.com/rakudo/rakudo/commit/7875eaf9d4ccdbf6f018

[21:35] <lizmat> (Bump NQP_REVISION)

[21:35] <lizmat> https://github.com/rakudo/rakudo/commit/d793e210d9a8af966b39e

[21:35] <lizmat> (Make prefs/prop-mappings initialize at compile time)

[22:00] <Geth> ¦ rakudo/nom: af50e064f8 | (Elizabeth Mattijsen)++ | src/core/Mix.pm

[22:00] <Geth> ¦ rakudo/nom: Make Mix.Bag coercion about 28x faster

[22:00] <Geth> ¦ rakudo/nom:

[22:00] <Geth> ¦ rakudo/nom: For a 10 element Mix.  Also abstract logic from .BagHash coercion

[22:00] <Geth> ¦ rakudo/nom: into !BAGGIFY method.

[22:00] <Geth> ¦ rakudo/nom: review: https://github.com/rakudo/rakudo/commit/af50e064f8

[22:00] <lizmat> and that concludes my hacking for today

[22:00] <lizmat> good night, #perl6-dev!

[22:01] <Zoffix> Night

[22:01] <Zoffix> It should be possible to make geth log recent commits and then tell it to (auto?) report the missing ones when it unbreaks

[22:02] <Zoffix> Gonna work on IRC::Client and bots after IO grant :)

[22:25] <[Coke]> .seen rjbs

[22:25] <yoleaux2> I haven't seen rjbs around.

[22:33] <Zoffix> /msg yoleaux .tell dpk Hey. Is there any way for you to dump yoleaux's pending messages to users (possibly limited to #perl6 users)? We'd like to use our yoleaux2 bot in #perl6, but without losing all the pending messages that yoleaux has

[22:52] * Zoffix eyes https://metacpan.org/pod/Mojo::File#sibling

[22:53] <Zoffix> m: say '/home/sri/.bashrc'.IO.parent.child('.foo')

[22:53] <camelia> rakudo-moar af50e0: OUTPUT: «"/home/sri/.foo".IO␤»

[22:53] <Zoffix> ^ that is sort-of the same, but isn't if the original path is a directory

[22:53] <Zoffix> m: say '/home/sri/.bashrc/'.IO.parent.child('.foo')

[22:53] <camelia> rakudo-moar af50e0: OUTPUT: «"/home/sri/.foo".IO␤»

[22:53] <Zoffix> Oh wait

[22:53] <Zoffix> Oh yeah tis the same.

[22:54] <Zoffix> Then nevermind.

[22:57] <Zoffix> I do want to steal the creation of IO::Path from a list of parts tho / splitting to parts; at least in the $*SPECless world. I think that's one usecase I recall thinking about that isn't replicated by IO::Path and needs use of $*SPEC

[22:57] <Zoffix> m: dd <a b c>.join('/').IO

[22:57] <camelia> rakudo-moar af50e0: OUTPUT: «"a/b/c".IO(:SPEC(IO::Spec::Unix),:CWD("/home/camelia"))␤»

[22:57] * Zoffix shrugs

[22:57] <Zoffix> Maybe isn't as needed

[23:04] <AlexDaniel> Zoffix: you maintain yoleaux2 now, right?

[23:05] <AlexDaniel> Zoffix: https://irclog.perlgeek.de/perl6/2017-04-07#i_14395253

[23:06] <AlexDaniel> Zoffix: if I give you a list of undelivered messages, will you be able to feed them into yoleaux2?

[23:11] <Zoffix> ...

[23:11] <Zoffix> Now that we finally find who the author is, people find reasonable alternatives -_-

[23:11] <Zoffix> kindf

[23:11] <mst> Zoffix: yeah, well, I was afk when [Coke] first asked me :)

[23:12] <Zoffix> AlexDaniel: isn't the bot is also in #parrot or #pugs or something or other? You'd need to parse more than 1 channel.

[23:12] <Zoffix> 'cause it delivers them cross-channel too

[23:12] <mst> Zoffix: I looked

[23:12] <mst> the bot is not in any other perl6-ish channels anymore

[23:13] <mst> so I think if we handle perl6 we've probably got almost all of them

[23:14] <Zoffix> OK

[23:14] <Zoffix> AlexDaniel: yeah, that'll work, I guess.

[23:15] <mst> I mean, we can try and track down dpk

[23:15] <mst> it's just at what point it becomes easier to just say "fuck it" and do the import

[23:15] <AlexDaniel> .seen dpk

[23:15] <yoleaux2> I haven't seen dpk around.

[23:15] <AlexDaniel> <yoleaux> I saw dpk 28 Feb 2017 12:10Z in #swhack: <dpk> ⬑ bettar

[23:15] <mst> ...

[23:15] <mst> 00:15 -!-  idle     : 0 days 1 hours 22 mins 55 secs

[23:15] <mst> did nobody try /msg yet?

[23:16] <Zoffix> hah

[23:16] <Zoffix> I used a bot to .tell a message but it didn't occur to me to see if the user was online :P

[23:16] * mst did 'info dpk' on nickserv then /whois

[23:16] <mst> y'all suck :P

[23:16] <Zoffix> :)

[23:16] <mst> (which is why I encourage you to ask me about this stuff ;)

[23:17] <AlexDaniel> and just in case, it is dpkendal at dpk.org.uk …

[23:18] <AlexDaniel> anyway, who is going to /msg ? :)

[23:18] <mst> Zoffix is, because now we have to co-ordinate getting yoleaux and yoleaux2 synced anyway :D

[23:19] <Zoffix> I'm shy.

[23:19] <Zoffix> And I'm wroking on a bot to replace human interaction.

[23:20] <AlexDaniel> :S

[23:21] <Zoffix> Also, I tried opening yoleaux2's "tell.db" with sqlite3 and it didn't work, so short of feeding all the messages through IRC I don't yet know how to add them to yoleaux2 :)

[23:21] <mst> where's the source?

[23:21] <mst> AlexDaniel: can you ping dpk?

[23:22] <AlexDaniel> mst: https://github.com/dpk/yoleaux

[23:22] <AlexDaniel> sure

[23:23] <mst> Zoffix: oh lol it's using ruby's Storable

[23:23] <mst> https://github.com/dpk/yoleaux/blob/master/database.rb

[23:24] <Zoffix> ah

[23:24] <mst> easy enough to stuff/unstuff in that case though

[23:27] <AlexDaniel> hm… but what if we simply run yoleaux on all channels?

[23:27] <AlexDaniel> I mean, ask him to make it join other ones

[23:29] <mst> so you're ok losing any messages from on here since you put it in here?

[23:30] <AlexDaniel> he says that it doesn't really store where these messages originated from

[23:30] <AlexDaniel> so we cannot easily import messages from its DB

[23:30] <AlexDaniel> but, he says that if we give him yoleaux2 db, he can feed it into yoleaux

[23:30] <mst> I wasn't expecting us to, only import *into* yoleaux2's db if we went that route

[23:31] <mst> the only thing that you'd do with yoleaux's db is xref which messages are still outstanding

[23:31] <mst> you'd still parse the #perl6 logs to know which messages were *sent* there

[23:31] <mst> but consolidating the yoleaux2 db back into yoleaux would also seem fine to me

[23:33] <Zoffix> AlexDaniel: OK: https://temp.perl6.party/tell.db

[23:33] <Zoffix> It's from ~/.yoleaux/ is that the right one?

[23:33] <Zoffix> huh TIL weechat autocompletes your paths with TAB

[23:33] <AlexDaniel> yes

[23:34] <Zoffix> OK, then bring yoleaux here and I'll kill yoleaux2

[23:34] <Zoffix> And #moarvm

[23:34] <AlexDaniel> ok, here's the plan

[23:34] <Zoffix> And #perl6-toolchain or what was it

[23:34] <AlexDaniel> dpk will come here tomorrow around 18:00 CEST

[23:34] <AlexDaniel> (he can't do it now)

[23:35] <Zoffix> OK

[23:35] <AlexDaniel> it would be nice to have a list of channels we want yoleaux on, yes

[23:36] <mst> see, this is why I was wondering if we might not be better running one we can reconfigure

[23:37] <AlexDaniel> mst: unless it's written in perl 6, I don't think we should bother

[23:37] * mst shrugs

[23:37] <mst> I said 'if' advisedly

[23:39] <AlexDaniel> huggable: bots

[23:39] <huggable> AlexDaniel, The #perl6 irc channel normally hosts several helpful bots. I am a bot, and everyone else voiced on this channel is a bot. See the full list here: https://github.com/perl6/doc/issues/711#issuecomment-235414744

[23:45] <AlexDaniel> (oh… actually, *before* 18:00 CEST. In any case, I've sent him the link to tell.db)
