[03:14] <Geth> ¦ nqp/appveyor: 2e7cd40291 | (Samantha McVey)++ | .appveyor.yml

[03:14] <Geth> ¦ nqp/appveyor: Try debugging Appveyor

[03:14] <Geth> ¦ nqp/appveyor: review: https://github.com/perl6/nqp/commit/2e7cd40291

[03:22] <samcv> nqp is building in the appveyor branch, but for some reason not running the tests, not sure why

[03:24] <Geth> ¦ nqp/appveyor: 16802a7cb6 | (Samantha McVey)++ | .appveyor.yml

[03:24] <Geth> ¦ nqp/appveyor: Run nmake and nmake install in different steps (appveyor)

[03:24] <Geth> ¦ nqp/appveyor: review: https://github.com/perl6/nqp/commit/16802a7cb6

[04:15] <Geth> ¦ rakudo: Gnouc++ created pull request #1164: Make :delete works with lazy Arrays

[04:15] <Geth> ¦ rakudo: review: https://github.com/rakudo/rakudo/pull/1164

[04:15] <Geth> ¦ roast: Gnouc++ created pull request #326: :delete on lazy Arrays

[04:15] <Geth> ¦ roast: review: https://github.com/perl6/roast/pull/326

[04:53] <travis-ci> Rakudo build errored. Elizabeth Mattijsen 'Map/Hash have their own optimized .sort

[04:53] <travis-ci> https://travis-ci.org/rakudo/rakudo/builds/276935301 https://github.com/rakudo/rakudo/compare/48a84d6aff9c...476741e77d76

[04:53] <buggable> [travis build above] ✓ All failures are due to: missing build log (1 failure).

[05:04] <Geth> ¦ nqp/appveyor: 3748aa53cc | (Samantha McVey)++ | .appveyor.yml

[05:04] <Geth> ¦ nqp/appveyor: Turn build section of Appveyor build off

[05:04] <Geth> ¦ nqp/appveyor:

[05:04] <Geth> ¦ nqp/appveyor: Hopefully avoid "Specify which project or solution file to use

[05:04] <Geth> ¦ nqp/appveyor: because the folder contains more than one project or solution file."

[05:04] <Geth> ¦ nqp/appveyor: error.

[05:04] <Geth> ¦ nqp/appveyor: review: https://github.com/perl6/nqp/commit/3748aa53cc

[06:03] <[Tux]> This is Rakudo version 2017.09-27-gda5c36c13 built on MoarVM version 2017.09.1-13-g3dea7dff

[06:03] <[Tux]> csv-ip5xs        1.339 -  1.341

[06:03] <[Tux]> test            10.012 - 10.168

[06:03] <[Tux]> test-t           3.452 -  3.482

[06:03] <[Tux]> csv-parser      12.642 - 13.312

[07:36] <lizmat> Files=1227, Tests=75113, 294 wallclock secs (14.49 usr  5.24 sys + 1992.84 cusr 205.69 csys = 2218.26 CPU)

[07:38] <Geth> ¦ rakudo/nom: 0385b2aa45 | (Cuong Manh Le)++ | src/core/Array.pm

[07:38] <Geth> ¦ rakudo/nom: Make :delete works with lazy Arrays

[07:38] <Geth> ¦ rakudo/nom:

[07:38] <Geth> ¦ rakudo/nom: Fixes RT#131790

[07:38] <Geth> ¦ rakudo/nom: review: https://github.com/rakudo/rakudo/commit/0385b2aa45

[07:38] <synopsebot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=131790

[07:38] <Geth> ¦ rakudo/nom: 3e35819914 | lizmat++ (committed using GitHub Web editor) | src/core/Array.pm

[07:38] <Geth> ¦ rakudo/nom: Merge pull request #1164 from Gnouc/nom

[07:38] <Geth> ¦ rakudo/nom:

[07:38] <Geth> ¦ rakudo/nom: Make :delete works with lazy Arrays

[07:38] <Geth> ¦ rakudo/nom: review: https://github.com/rakudo/rakudo/commit/3e35819914

[07:39] <Geth> ¦ roast: 9cc47b28a9 | (Cuong Manh Le)++ | S32-array/delete-adverb.t

[07:39] <Geth> ¦ roast: :delete on lazy Arrays

[07:39] <Geth> ¦ roast:

[07:39] <Geth> ¦ roast: RT #131790

[07:39] <Geth> ¦ roast: review: https://github.com/perl6/roast/commit/9cc47b28a9

[07:39] <synopsebot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=131790

[07:39] <Geth> ¦ roast: bf4b2048d5 | lizmat++ (committed using GitHub Web editor) | S32-array/delete-adverb.t

[07:39] <Geth> ¦ roast: Merge pull request #326 from Gnouc/master

[07:39] <Geth> ¦ roast:

[07:39] <Geth> ¦ roast: :delete on lazy Arrays

[07:39] <Geth> ¦ roast: review: https://github.com/perl6/roast/commit/bf4b2048d5

[08:13] <travis-ci> Rakudo build passed. Elizabeth Mattijsen 'Bump nqp: new libuv and fix for thread ID race'

[08:13] <travis-ci> https://travis-ci.org/rakudo/rakudo/builds/276986184 https://github.com/rakudo/rakudo/compare/476741e77d76...198b84971dff

[10:11] <travis-ci> Rakudo build failed. Elizabeth Mattijsen 'Iterable eqv Iterable should check types first

[10:11] <travis-ci> https://travis-ci.org/rakudo/rakudo/builds/277009878 https://github.com/rakudo/rakudo/compare/198b84971dff...0beeef9baa42

[10:11] <buggable> [travis build above] ✓ All failures are due to: GitHub connectivity (1 failure).

[10:18] <lizmat> afk for most of the day&

[12:36] <Geth> ¦ rakudo/supply-locking-refactor: 93a66d75b9 | (Jonathan Worthington)++ | src/core/Supply.pm

[12:36] <Geth> ¦ rakudo/supply-locking-refactor: An on-demand Supply isn't magically serial/sanitry

[12:36] <Geth> ¦ rakudo/supply-locking-refactor:

[12:36] <Geth> ¦ rakudo/supply-locking-refactor: We had a case right here in CORE.setting that violated it, so user's

[12:36] <Geth> ¦ rakudo/supply-locking-refactor: own code sure as heck might do so also.

[12:36] <Geth> ¦ rakudo/supply-locking-refactor: review: https://github.com/rakudo/rakudo/commit/93a66d75b9

[12:36] <Geth> ¦ rakudo/supply-locking-refactor: 9e179355cf | (Jonathan Worthington)++ | src/core/Supply.pm

[12:36] <Geth> ¦ rakudo/supply-locking-refactor: Filter out duplicate done/quit messages

[12:36] <Geth> ¦ rakudo/supply-locking-refactor: review: https://github.com/rakudo/rakudo/commit/9e179355cf

[12:37] <Zoffix> ZOFVM: Files=1277, Tests=152091, 161 wallclock secs (20.70 usr  3.29 sys + 3016.86 cusr 269.89 csys = 3310.74 CPU)

[12:37] <Zoffix> I sure how that's just we added more tests :/

[12:37] <Zoffix> m: say 161/137

[12:37] <camelia> rakudo-moar 3e3581: OUTPUT: «1.175182␤»

[12:37] <Zoffix> 17% slower :/

[12:39] <Zoffix> buggable: speed :50

[12:39] <buggable> Zoffix, Refusing to draw more than 4 rows

[12:39] <Zoffix> buggable: speed 50 :4

[12:39] <buggable> Zoffix,       ▅           ▆    ▇ ↑              ↑█         dates: 2017-09-02–2017-09-19

[12:39] <buggable> Zoffix,  ▂    █▄          █    █▃█           ▃  ██         range: 3.376s–4.237s

[12:39] <buggable> Zoffix, ▆█▂   ██          █▃  ▄███▆ ▃▁ █ ▂  ▃█▆▄██▂▃ ▁     speed: 3% faster

[12:39] <buggable> Zoffix, ███▇▄▃██▅▇▅█▆▅▇▁▄▅██▇▇█████▆██▇█▆█▂▂████████▇█▄▃▅▇

[12:40] <jnthn> Pretty :)

[12:45] <Geth> ¦ rakudo/supply-locking-refactor: c46be84ca3 | (Jonathan Worthington)++ | src/core.d/await.pm

[12:45] <Geth> ¦ rakudo/supply-locking-refactor: Move classes outside of `REACT` sub

[12:45] <Geth> ¦ rakudo/supply-locking-refactor:

[12:45] <Geth> ¦ rakudo/supply-locking-refactor: That pattern caused some pain with `SUPPLY` before now.

[12:45] <Geth> ¦ rakudo/supply-locking-refactor: review: https://github.com/rakudo/rakudo/commit/c46be84ca3

[12:45] <Geth> ¦ rakudo/supply-locking-refactor: 633a15b82b | (Jonathan Worthington)++ | src/core/Supply.pm

[12:45] <Geth> ¦ rakudo/supply-locking-refactor: Sanitize per tapping, not per Supply

[12:45] <Geth> ¦ rakudo/supply-locking-refactor:

[12:45] <Geth> ¦ rakudo/supply-locking-refactor: I've put this off before now as it causes a couple of regressions in

[12:45] <Geth> ¦ rakudo/supply-locking-refactor: S17-supply/basic.t, but it's the right thing to do, and not doing it

[12:45] <Geth> ¦ rakudo/supply-locking-refactor: causes other issues. Regressions will be investigated and dealt with

[12:45] <Geth> ¦ rakudo/supply-locking-refactor: before this branch is merged.

[12:45] <Geth> ¦ rakudo/supply-locking-refactor: review: https://github.com/rakudo/rakudo/commit/633a15b82b

[12:45] <Geth> ¦ rakudo/supply-locking-refactor: ef4d16fe19 | (Jonathan Worthington)++ | src/core/Supply.pm

[12:45] <Geth> ¦ rakudo/supply-locking-refactor: Serialize lock should be per tap, not per Supply

[12:45] <Geth> ¦ rakudo/supply-locking-refactor:

[12:45] <Geth> ¦ rakudo/supply-locking-refactor: This may allow for finer-grained concurrency in the case of supplies

[12:45] <Geth> ¦ rakudo/supply-locking-refactor: being used for publish/subscribe.

[12:45] <Geth> ¦ rakudo/supply-locking-refactor: review: https://github.com/rakudo/rakudo/commit/ef4d16fe19

[12:45] <Geth> ¦ rakudo/supply-locking-refactor: 5a9bb4a58e | (Jonathan Worthington)++ | src/core/Supply.pm

[12:45] <Geth> ¦ rakudo/supply-locking-refactor: Remove unused attribute

[12:45] <Geth> ¦ rakudo/supply-locking-refactor: review: https://github.com/rakudo/rakudo/commit/5a9bb4a58e

[12:49] <Zoffix> ZOFVM: Files=1277, Tests=152091, 143 wallclock secs (20.57 usr  3.13 sys + 2952.57 cusr 231.80 csys = 3208.07 CPU)

[12:51] <Geth> ¦ rakudo/nom: bb45791c5d | (Zoffix Znet)++ | 2 files

[12:51] <Geth> ¦ rakudo/nom: Make `eqv` throw typed exceptions on lazy comparisons

[12:51] <Geth> ¦ rakudo/nom:

[12:51] <Geth> ¦ rakudo/nom: Closes RT#132117: https://rt.perl.org/Ticket/Display.html?id=132117

[12:51] <Geth> ¦ rakudo/nom:

[12:51] <synopsebot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=132117

[12:51] <Geth> ¦ rakudo/nom: P.S.: the exception's wording says "lazy lists". It's lowercased "list",

[12:51] <Geth> ¦ rakudo/nom: which I suppose is enough wiggle room to be OK when throwing for lazy Seqs

[12:51] <Geth> ¦ rakudo/nom: review: https://github.com/rakudo/rakudo/commit/bb45791c5d

[12:53] <Geth> ¦ roast: 66c13e9402 | (Zoffix Znet)++ | S03-operators/eqv.t

[12:53] <Geth> ¦ roast: Spec `eqv` behaviour with lazy arguments

[12:53] <Geth> ¦ roast:

[12:53] <Geth> ¦ roast: RT#132117: https://rt.perl.org/Ticket/Display.html?id=132117

[12:53] <Geth> ¦ roast: Rakudo fixes: https://github.com/rakudo/rakudo/commit/66c2d05f29

[12:53] <synopsebot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=132117

[12:53] <Geth> ¦ roast:               https://github.com/rakudo/rakudo/commit/48a84d6aff

[12:53] <Geth> ¦ roast:               https://github.com/rakudo/rakudo/commit/bb45791c5d

[12:53] <Geth> ¦ roast: review: https://github.com/perl6/roast/commit/66c13e9402

[12:58] <Geth> ¦ roast: 7e5caccdee | (Zoffix Znet)++ | S03-operators/eqv.t

[12:58] <Geth> ¦ roast: Add couple more eqv on lazy tests

[12:58] <Geth> ¦ roast:

[12:58] <Geth> ¦ roast: To cover potential separate candidates for Lists/Arays (rakudo

[12:58] <Geth> ¦ roast: has separate ones for Seqs)

[12:58] <Geth> ¦ roast: review: https://github.com/perl6/roast/commit/7e5caccdee

[13:05] <Geth> ¦ roast: 7ece4e5787 | (Jonathan Worthington)++ | S17-supply/basic.t

[13:05] <Geth> ¦ roast: Remove tests with some odd exepctations

[13:05] <Geth> ¦ roast:

[13:05] <Geth> ¦ roast: They claimed to cover RT #123477, and there are indeed tests in this

[13:05] <Geth> ¦ roast: file that cover that issue. However, these tests went further: they

[13:05] <synopsebot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=123477

[13:05] <Geth> ¦ roast: expected not only that the protocol would be enforced from the point

[13:05] <Geth> ¦ roast: of view of an individual tap (which is what the RT ticket was using),

[13:05] <Geth> ¦ roast: but also that this would carry over to future taps of the same Supply.

[13:05] <Geth> ¦ roast: <…commit message has 10 more lines…>

[13:05] <Geth> ¦ roast: review: https://github.com/perl6/roast/commit/7ece4e5787

[14:32] <Geth> ¦ rakudo/supply-block-refactor: f53d396374 | (Jonathan Worthington)++ | src/core/Supply.pm

[14:32] <Geth> ¦ rakudo/supply-block-refactor: Closure clone per supply/react, not per whenever

[14:32] <Geth> ¦ rakudo/supply-block-refactor:

[14:32] <Geth> ¦ rakudo/supply-block-refactor: Saves some work for supply/react blocks that have multiple whenever

[14:32] <Geth> ¦ rakudo/supply-block-refactor: blocks inside of them. Also sprinkle some comments explaining what's

[14:32] <Geth> ¦ rakudo/supply-block-refactor: going on.

[14:32] <Geth> ¦ rakudo/supply-block-refactor: review: https://github.com/rakudo/rakudo/commit/f53d396374

[14:58] <jnthn> m: react { await Promise.in(0.1) }; say 'ok'

[14:58] <camelia> rakudo-moar bb4579: OUTPUT: «ok␤»

[14:58] <jnthn> m: use v6.d.PREVIEW; react { await Promise.in(0.1) }; say 'ok'

[14:58] <camelia> rakudo-moar bb4579: OUTPUT: «ok␤»

[14:58] <jnthn> m: await start react { await Promise.in(0.1) }; say 'ok'

[14:58] <camelia> rakudo-moar bb4579: OUTPUT: «ok␤»

[14:58] <jnthn> m: use v6.d.PREVIEW; await start react { await Promise.in(0.1) }; say 'ok'

[14:58] <camelia> rakudo-moar bb4579: OUTPUT: «A react block:␤  in code  at <tmp> line 1␤␤Died because of the exception:␤    An operation first awaited:␤      in block  at <tmp> line 1␤␤    Died with the exception:␤        No matching continuation reset found␤          in block  at …»

[14:59] <jnthn> Darn.

[14:59] <jnthn> Figured it wasn't going to be due to any of the patches in my branch.

[15:19] <Geth> ¦ rakudo/supply-block-refactor: 29863a0bdc | (Jonathan Worthington)++ | src/core/ThreadPoolScheduler.pm

[15:19] <Geth> ¦ rakudo/supply-block-refactor: Fix non-blocking react { await blah() }

[15:19] <Geth> ¦ rakudo/supply-block-refactor:

[15:19] <Geth> ¦ rakudo/supply-block-refactor: The `react` (and also `await $some-supply`) constructs will tap the

[15:19] <Geth> ¦ rakudo/supply-block-refactor: `Supply` upon the call to `subscribe-awaiter`. This causes some

[15:19] <Geth> ¦ rakudo/supply-block-refactor: amount of synchronous execution to take place, and that code may then

[15:19] <Geth> ¦ rakudo/supply-block-refactor: itself `await`. This broke because the continuation tag was removed

[15:19] <Geth> ¦ rakudo/supply-block-refactor: by the react/await prior to this. Protect the continuation tag, so it

[15:19] <Geth> ¦ rakudo/supply-block-refactor: survives.

[15:19] <Geth> ¦ rakudo/supply-block-refactor: review: https://github.com/rakudo/rakudo/commit/29863a0bdc

[15:19] <jnthn> .tell pmurias A while back you asked if the continuation protect flag should stay or go away. Turns out, stay: https://github.com/rakudo/rakudo/commit/29863a0bdc

[15:19] <yoleaux> jnthn: I'll pass your message to pmurias.

[15:20] <jnthn> m: use v6.d.PREVIEW; use Test; lives-ok { await start react { await Promise.in(0.1) } }

[15:20] <camelia> rakudo-moar bb4579: OUTPUT: «not ok 1 - ␤# Failed test at <tmp> line 1␤# No matching continuation reset found␤»

[16:35] <jnthn> Got a test for the above locally, will push it once I merge stuff

[17:22] <Geth> ¦ nqp: 4bc6050d6e | (Zoffix Znet)++ | tools/build/MOAR_REVISION

[17:22] <Geth> ¦ nqp: Bump MoarVM

[17:22] <Geth> ¦ nqp: review: https://github.com/perl6/nqp/commit/4bc6050d6e

[17:22] <Geth> ¦ nqp: version bump brought these changes: https://github.com/MoarVM/MoarVM/compare/2017.09.1-7-geeb664e...2017.09.1-16-g3b4b032

[17:22] <Geth> ¦ rakudo/nom: dff7d9b28a | (Zoffix Znet)++ | tools/build/NQP_REVISION

[17:22] <Geth> ¦ rakudo/nom: Bump NQP

[17:22] <Geth> ¦ rakudo/nom: review: https://github.com/rakudo/rakudo/commit/dff7d9b28a

[17:22] <Geth> ¦ rakudo/nom: version bump brought these changes: https://github.com/perl6/nqp/compare/2017.09-2-g862cde8...2017.09-3-g4bc6050

[17:24] <Geth> ¦ rakudo/nom: 0d2ca0d7e1 | (Zoffix Znet)++ | t/02-rakudo/10-nqp-ops.t

[17:24] <Geth> ¦ rakudo/nom: Test p6bindattrinvres with getattr of bigint…

[17:24] <Geth> ¦ rakudo/nom:

[17:24] <Geth> ¦ rakudo/nom: …does not SEGV.

[17:24] <Geth> ¦ rakudo/nom:

[17:24] <Geth> ¦ rakudo/nom: RT#132128:  https://rt.perl.org/Ticket/Display.html?id=132128

[17:24] <Geth> ¦ rakudo/nom: Rakudo fix: https://github.com/rakudo/rakudo/commit/dff7d9b28a

[17:24] <synopsebot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=132128

[17:24] <Geth> ¦ rakudo/nom: NQP    fix: https://github.com/perl6/nqp/commit/4bc6050d6e

[17:24] <Geth> ¦ rakudo/nom: MoarVM fix: https://github.com/MoarVM/MoarVM/commit/3b4b032984

[17:24] <Geth> ¦ rakudo/nom: review: https://github.com/rakudo/rakudo/commit/0d2ca0d7e1

[17:24] <Zoffix> oops, slightly wrong ticket in commit message.

[17:26] <Geth> ¦ rakudo/nom: de56c05649 | (Zoffix Znet)++ | t/02-rakudo/10-nqp-ops.t

[17:26] <Geth> ¦ rakudo/nom: Add reference to ticket to the test

[17:26] <Geth> ¦ rakudo/nom: review: https://github.com/rakudo/rakudo/commit/de56c05649

[18:10] <Geth> ¦ rakudo/nom: 0834036dd4 | (Zoffix Znet)++ | src/core/Int.pm

[18:10] <Geth> ¦ rakudo/nom: Fix issues with Int.new

[18:10] <Geth> ¦ rakudo/nom:

[18:10] <Geth> ¦ rakudo/nom: - Fix wrong error (default constructor blah blah) with wrong args

[18:10] <Geth> ¦ rakudo/nom: - Fix subclassed Ints returning an Int instead of subclass

[18:10] <Geth> ¦ rakudo/nom:

[18:10] <Geth> ¦ rakudo/nom: Fixes RT#132128: https://rt.perl.org/Ticket/Display.html?id=132128

[18:10] <synopsebot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=132128

[18:10] <Geth> ¦ rakudo/nom: review: https://github.com/rakudo/rakudo/commit/0834036dd4

[18:11] <Geth> ¦ roast: ba7d5c1dd1 | (Zoffix Znet)++ | S32-num/int.t

[18:11] <Geth> ¦ roast: Test subclassing of Int.new

[18:11] <Geth> ¦ roast:

[18:11] <Geth> ¦ roast: RT#132128:  https://rt.perl.org/Ticket/Display.html?id=132128

[18:11] <Geth> ¦ roast: Rakudo fix: https://github.com/rakudo/rakudo/commit/0834036dd4

[18:11] <synopsebot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=132128

[18:11] <Geth> ¦ roast: review: https://github.com/perl6/roast/commit/ba7d5c1dd1

[18:55] <Geth> ¦ nqp/jit_nativecall: e7f0c9b3d8 | (Stefan Seifert)++ | 12 files

[18:55] <Geth> ¦ nqp/jit_nativecall: Map the new nativecallinvokejit OP

[18:55] <Geth> ¦ nqp/jit_nativecall:

[18:55] <Geth> ¦ nqp/jit_nativecall: nativecallbuild now has a return value indicating whether we were able

[18:55] <Geth> ¦ nqp/jit_nativecall: to JIT compile code for the call site

[18:55] <Geth> ¦ nqp/jit_nativecall: review: https://github.com/perl6/nqp/commit/e7f0c9b3d8

[18:55] <Geth> ¦ rakudo/jit_nativecall: 8 commits pushed by (Stefan Seifert)++

[18:55] <Geth> ¦ rakudo/jit_nativecall: 25f9a7fb0e | Use the new nativeinvoke for calling JITed NC code directly

[18:55] <Geth> ¦ rakudo/jit_nativecall: 0ed922d662 | Test more integerial return types in NC

[18:55] <Geth> ¦ rakudo/jit_nativecall: 5d6d69f66c | Test Pointer return values in argless function

[18:55] <Geth> ¦ rakudo/jit_nativecall: 73bd7ece9f | Test argless native functions returning strings

[18:55] <Geth> ¦ rakudo/jit_nativecall: 8169ed38af | Decont arguments before running JITed native calls

[18:56] <Geth> ¦ rakudo/jit_nativecall: 3a9bbbff48 | Give generated native call function bodies a name

[18:56] <Geth> ¦ rakudo/jit_nativecall: e18625e54a | Remove unnecessary creation of an extra serialization context

[18:56] <Geth> ¦ rakudo/jit_nativecall: 8f9dc2027a | Explicitly pass the params to nativecallinvokejit

[18:56] <Geth> ¦ rakudo/jit_nativecall: review: https://github.com/rakudo/rakudo/compare/571cf2c0fc...8f9dc2027a

[19:05] <smls> Anyone up for reviewing my NPQ PR (QRegex fixes) from 4 weeks ago, before it bitrots? https://github.com/perl6/nqp/pull/368

[19:06] <smls> Pinging TimToday (Still the highest authority on intended P6 regex behavior, right? Although this case looks like an obvious fix...)

[19:06] <smls> Pinging jnthn (git blame of most of the surrounding code).

[19:19] <Zoffix> .oO( that stuff's over my head )

[19:20] <Geth> ¦ rakudo: dwarring++ created pull request #1165: fix subset isa method on a subset.

[19:20] <Geth> ¦ rakudo: review: https://github.com/rakudo/rakudo/pull/1165

[19:44] <Geth> ¦ nqp/jit_nativecall: 4bc6bcc51b | (Stefan Seifert)++ | 12 files

[19:44] <Geth> ¦ nqp/jit_nativecall: Map the new nativeinvoke OP

[19:44] <Geth> ¦ nqp/jit_nativecall:

[19:44] <Geth> ¦ nqp/jit_nativecall: nativecallbuild now has a return value indicating whether we were able

[19:44] <Geth> ¦ nqp/jit_nativecall: to JIT compile code for the call site

[19:44] <Geth> ¦ nqp/jit_nativecall: review: https://github.com/perl6/nqp/commit/4bc6bcc51b

[19:44] <Geth> ¦ nqp/jit_nativecall: e2029c8fd5 | (Stefan Seifert)++ | 12 files

[19:44] <Geth> ¦ nqp/jit_nativecall: Map the new nativeinvoke OP

[19:44] <Geth> ¦ nqp/jit_nativecall:

[19:44] <Geth> ¦ nqp/jit_nativecall: nativecallbuild now has a return value indicating whether we were able

[19:44] <Geth> ¦ nqp/jit_nativecall: to JIT compile code for the call site

[19:44] <Geth> ¦ nqp/jit_nativecall: review: https://github.com/perl6/nqp/commit/e2029c8fd5

[19:52] <Geth> ¦ rakudo/jit_nativecall: 6 commits pushed by (Stefan Seifert)++

[19:52] <Geth> ¦ rakudo/jit_nativecall: b6e6860fd6 | Test more integerial return types in NC

[19:52] <Geth> ¦ rakudo/jit_nativecall: b7843ee029 | Test Pointer return values in argless function

[19:52] <Geth> ¦ rakudo/jit_nativecall: 4bb2ab27cb | Test argless native functions returning strings

[19:52] <Geth> ¦ rakudo/jit_nativecall: 058a97fe3c | Use the new nativeinvoke for calling JITed NC code directly

[19:52] <Geth> ¦ rakudo/jit_nativecall: 13b3505e33 | Give generated native call function bodies a name

[19:52] <Geth> ¦ rakudo/jit_nativecall: eff9d47602 | Remove unnecessary creation of an extra serialization context

[19:52] <Geth> ¦ rakudo/jit_nativecall: review: https://github.com/rakudo/rakudo/compare/8f9dc2027a...eff9d47602

[19:52] <nine> Ok, everything ready for review :)

[19:56] <samcv> do we want to enable perl6 -n0 to have null separated lines

[19:57] <samcv> or maybe -0n idk. seems perl5 accepts both but that seems odd

[19:58] <ilmari> because -0 and -n are separate flags

[19:58] <ilmari> and perl5 allows bundling flags

[20:00] <samcv> ah

[20:00] <samcv> makes sense now :)

[20:09] * lizmat comes back from a day afk to find all sorts of new goodies  :-)

[20:49] <lizmat> m: dd 2.WHERE, Int.new(2).WHERE

[20:49] <camelia> rakudo-moar 083403: OUTPUT: «139898000064752␤139898001015248␤»

[20:50] <lizmat> Zoffix: why should they be different ?  You can't assign into an Int, can you ?

[20:53] <Zoffix> lizmat: that's an old test. Perhaps it should be improved. What it's testing is:

[20:53] <Zoffix> m: dd (2 does role Meows {}).^name; (Int.new: 2).^name.say

[20:53] <camelia> rakudo-moar 083403: OUTPUT: «"Int+\{Meows}"␤Int␤»

[20:53] <Zoffix> c: HEAD~200 m: dd (2 does role Meows {}).^name; (Int.new: 2).^name.say

[20:53] <committable6> Zoffix, ¦HEAD~200: «"Int+\{Meows}"␤Int+{Meows}»

[20:53] <Zoffix> I think that was fixed today, so that test didn't test the failure

[20:54] <Zoffix> I mean, it's an old test I wrote, so that's what I intended :)

[20:54] <lizmat> ok, because I'v just made Int.new 7x faster, but it fails that test

[20:55] <Geth> ¦ rakudo/nom: cee1be22cf | (David Warring)++ | src/Perl6/Metamodel/SubsetHOW.nqp

[20:55] <Geth> ¦ rakudo/nom: fix subset isa method on a subset.

[20:55] <Geth> ¦ rakudo/nom:

[20:55] <Geth> ¦ rakudo/nom: perl6 -e'subset S of Int; subset S2 of S; say S2.isa(S)'

[20:55] <Geth> ¦ rakudo/nom:

[20:55] <Geth> ¦ rakudo/nom: now returns True. fully resolves RT #132073

[20:55] <Geth> ¦ rakudo/nom: review: https://github.com/rakudo/rakudo/commit/cee1be22cf

[20:55] <synopsebot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=132073

[20:55] <Geth> ¦ rakudo/nom: b66f5e1cc8 | (Zoffix Znet)++ (committed using GitHub Web editor) | src/Perl6/Metamodel/SubsetHOW.nqp

[20:55] <Geth> ¦ rakudo/nom: Merge pull request #1165 from dwarring/subset-isa2

[20:55] <Geth> ¦ rakudo/nom:

[20:55] <Geth> ¦ rakudo/nom: fix subset isa method on a subset.

[20:55] <Geth> ¦ rakudo/nom: review: https://github.com/rakudo/rakudo/commit/b66f5e1cc8

[20:55] <lizmat> (while preserving subclassability / mixability)

[20:55] <Zoffix> wow cool :)

[20:56] <Zoffix> OK, remove the test :) It's not part of 6.c-errata

[20:56] <lizmat> will do

[20:56] <Zoffix> m: dd (2 does role Meows {}).^name; (Int.new: 2).^name.say

[20:56] <camelia> rakudo-moar 083403: OUTPUT: «"Int+\{Meows}"␤Int␤»

[20:57] <Zoffix> m: dd (2e0 does role Meows {}).^name; (Num.new: 2e0).^name.say

[20:57] <camelia> rakudo-moar 083403: OUTPUT: «"Num+\{Meows}"␤Num␤»

[20:57] <lizmat> m: class Y is Int {}; dd Y.new(42).WHAT, Int.new(42).WHAT

[20:57] <camelia> rakudo-moar 083403: OUTPUT: «Y␤Int␤»

[20:59] <Zoffix> (Int.new: 2).^name.say returning `Int+\{Meows}` above is basically about cached constants I think. And whatever Int.new is doing now reboxes the native int into a fresh thing

[21:05] <lizmat> hmm... seems the int version is still borked:

[21:05] <lizmat> m: dd (2 does role Meows {}).^name; (Int.new: my int $ = 2).^name.say

[21:05] <camelia> rakudo-moar 083403: OUTPUT: «"Int+\{Meows}"␤Int+{Meows}␤»

[21:05] <lizmat> and that's what I was using as a model for optimization :-(

[21:06] <timotimo> huh, is the boxed int cache in moarvm faulty?

[21:06] <lizmat> well, perhaps ?

[21:06] <Zoffix> :(

[21:07] <Zoffix> m: dd (2e0 does role Meows {}).^name; (Num.new: my num $ = 2e0).^name.say

[21:07] <camelia> rakudo-moar 083403: OUTPUT: «"Num+\{Meows}"␤Num␤»

[21:07] <Zoffix> s: Num, 'new', \(my num $ = 2e0)

[21:07] <SourceBaby> Zoffix, Sauce is at https://github.com/rakudo/rakudo/blob/0834036dd/src/core/Num.pm#L32

[21:08] <Zoffix> seems same as Int's version for natives.

[21:09] <Zoffix> m: use MONKEY; augment class Int { method znew ($v) { nqp::box_i($v.Int, self) } }; dd (2 does role Meows {}).^name; (Int.znew: my int $ = 2).^name.say

[21:09] <camelia> rakudo-moar 083403: OUTPUT: «"Int+\{Meows}"␤Int+{Meows}␤»

[21:10] <Zoffix> m: use MONKEY; augment class Num { method znew ($v) { nqp::box_n($v.Num, self) } }; dd (2e0 does role Meows {}).^name; (Num.znew: my num $ = 2e0).^name.say

[21:10] <camelia> rakudo-moar 083403: OUTPUT: «"Num+\{Meows}"␤Num␤»

[21:10] <Zoffix> .oO( Nums aren't cached? )

[21:11] <lizmat> what would be the key?  :-)

[21:11] <Zoffix> key?

[21:13] <Zoffix> FWIW, as I remember it, solving this issue for Int is something I just thought up while fixing the issue of >64bit ints failing. So I don't think there was a usecase it was fixing and there weren't test for it in 6.c-errata. We could say it's cached; deal with it. If there's no way around it

[21:13] <Zoffix> Well, I didn't even fix it and wrote a faulty test, so... :)

[21:16] * Zoffix &

[21:47] <lizmat> m: dd 2 does role Meows {}; dd 2.WHAT   # this feels like a very bad case of action at a distance

[21:47] <camelia> rakudo-moar b66f5e: OUTPUT: «2␤Int+{Meows}␤»

[21:47] <lizmat> perhaps 2 does ...  should not be allowed ?

[21:47] <timotimo> probably :)

[21:47] <timotimo> you know how much fun you can have when you alter java's boxed int cache? :D

[21:58] <ilmari> boxed_int[4] = new Integer(7); ?

[21:58] <timotimo> yeah, like that

[21:58] <geekosaur> suddenly I am reminded of fortran fun

[21:59] * gfldex stares at „java“ and „fun“ in the same sentence

[21:59] <geekosaur> (i.e. java didn't invent that)

[22:00] <ilmari> gfldex: but "fortran" and "fun" is fine?

[22:00] <geekosaur> fortran is call by reference, so if you call a function with a numeric literal then that literal has to be compiled into a memory location. these are in common storage so there will be only one of each distinct literal in each program

[22:00] <timotimo> cool, you can also modify strings

[22:00] <geekosaur> since it's call by reference, it's cool with updating the value (perl 6's "is rw" automatically)

[22:00] <geekosaur> hijinks ensue

[22:01] <geekosaur> I should probably specify fortran IV, I think newer takes (don't recall about fortran 95) allow by-value

[22:03] <geekosaur> this was possible --- and being used in the wild --- for several decades before compiler writers realized it (by trying to add by-value optimizations and having the odd program suddenly break)

[22:12] <travis-ci> Rakudo build failed. Zoffix Znet 'Merge pull request #1163 from skids/rt132119

[22:12] <travis-ci> https://travis-ci.org/rakudo/rakudo/builds/277036247 https://github.com/rakudo/rakudo/compare/0beeef9baa42...da5c36c134db

[22:12] <buggable> [travis build above] ✓ All failures are due to: GitHub connectivity (1 failure).

[22:31] <samcv> discussed this with jnthn in #moarvm. i think it makes sense for .codes to count each utf8-c8 grapheme as 1 code

[22:31] <samcv> since it shouldn't be decomposed ever

[22:32] <samcv> plan to change that, as well as fixing a problem where string operations on strings containing utf8-c8 synthetics would cause them to turn into normal text.

[22:32] <samcv> m: my @ints = 103, 248, 111, 217, 210, 97; my $b = Buf.new(@ints); my Str $u=$b.decode("utf8-c8"); say $u.chars; $u.=subst("a","a"); say $u.chars

[22:32] <camelia> rakudo-moar b66f5e: OUTPUT: «6␤9␤»

[22:33] <samcv> replace a with a, and it turns the utf8c8 graphemes into standard text which it should not. will be fixing that too

[22:33] <samcv> any objections to the .codes returning 1 for each utf8c8 grapheme?

[22:34] <samcv> though i guess .ords decomposes the utf8c8 into non utf8c8. not sure what it should do in that case anyway

[22:34] <samcv> m: my @ints = 103, 248, 111, 217, 210, 97; my $b = Buf.new(@ints); my Str $u=$b.decode("utf8-c8"); say $u.ords. say $u

[22:34] <camelia> rakudo-moar b66f5e: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Two terms in a row␤at <tmp>:1␤------> 3u=$b.decode("utf8-c8"); say $u.ords. say7⏏5 $u␤    expecting any of:␤        infix␤        infix stopper␤        postfix␤        statement end␤ …»

[22:35] <samcv> m: my @ints = 103, 248, 111, 217, 210, 97; my $b = Buf.new(@ints); my Str $u=$b.decode("utf8-c8"); say $u.ords; say $u

[22:35] <camelia> rakudo-moar b66f5e: OUTPUT: «(103 1114109 120 70 56 111 1114109 120 68 57 1114109 120 68 50 97)␤g?xF8o?xD9?xD2a␤»

[22:54] <timotimo> my terminal doesn't understand this at all %)

[23:03] <samcv> well. it's utf8c8 :P

[23:03] <samcv> it's a private area character

[23:04] <samcv> timotimo, any thoughts on having .codes return 1 for each utf8c8 synth?

[23:05] <samcv> i mean .ords converts it into like what you see on your screen as the output. but that's because it's not printing out as utf8c8 and converting to utf8

[23:05] <samcv> m: my @ints = 103, 248, 111, 217, 210, 97; my $b = Buf.new(@ints); my Str $u=$b.decode("utf8-c8"); $*OUT.say: :enc<utf8c8>,$u.ords; say $u

[23:05] <camelia> rakudo-moar b66f5e: OUTPUT: «(103 1114109 120 70 56 111 1114109 120 68 57 1114109 120 68 50 97)␤g?xF8o?xD9?xD2a␤»

[23:06] <samcv> m: my @ints = 103, 248, 111, 217, 210, 97; my $b = Buf.new(@ints); my Str $u=$b.decode("utf8-c8"); $*OUT.say: :enc<utf8c8>,$u.ords;

[23:06] <camelia> rakudo-moar b66f5e: OUTPUT: «(103 1114109 120 70 56 111 1114109 120 68 57 1114109 120 68 50 97)␤»

[23:06] <samcv> m: my @ints = 103, 248, 111, 217, 210, 97; my $b = Buf.new(@ints); my Str $u=$b.decode("utf8-c8"); $*OUT.say: :enc<utf8c8>, $u

[23:06] <camelia> rakudo-moar b66f5e: OUTPUT: «g?xF8o?xD9?xD2a␤»

[23:06] <samcv> m: my @ints = 103, 248, 111, 217, 210, 97; my $b = Buf.new(@ints); my Str $u=$b.decode("utf8-c8"); $*OUT.say: :enc<utf8-c8>, $u

[23:06] <camelia> rakudo-moar b66f5e: OUTPUT: «g?xF8o?xD9?xD2a␤»

[23:06] <samcv> m: my @ints = 103, 248, 111, 217, 210, 97; my $b = Buf.new(@ints); my Str $u=$b.decode("utf8-c8"); $*OUT.write: :enc<utf8-c8>, $u

[23:06] <camelia> rakudo-moar b66f5e: OUTPUT: «Type check failed in binding to parameter '$buf'; expected Blob but got Str ("g?xF8o?xD9?xD2a")␤  in block <unit> at <tmp> line 1␤␤»

[23:07] <samcv> forget what i'm supposed to use :P

[23:08] <jnthn> $*OUT.write: $u.encode('utf8-c8')

[23:08] <jnthn> Or $*OUT.encoding('utf8-c8'); say $u

[23:12] <samcv> for now i'm not going to change .codes. will think about it a little more

[23:13] <samcv> also .ords returns flattened synthetics. which is weird. not sure what that shuold do either. any idea jnthn

[23:13] <samcv> oh looks like you're going to bed. night o/

[23:13] <samcv> i sort of feel .ords should return the name number as .codes does. so i'm kind of unsure what to do

[23:14] <samcv> and would probalby want to change both at the same time so it's consistent

[23:17] <timotimo> samcv: i don't know what use cases there are for .codes on an utf8-c8 string and what's more convenient

[23:19] <samcv> oh. make distclean solved my issue with compiling moarvm not updating its version number. even after running ./Configure.pl again

[23:19] <samcv> hmm

[23:22] <timotimo> really, the biggest problem with utf8-c8 i see at the moment is that if you pipe random binary data in you can accidentally hit "valid" utf8 that will still throw an exception

[23:26] <samcv> ah so that's what causes it

[23:30] <timotimo> hm, i can't provoke it right now for some reason

[23:30] <timotimo> so maybe it actually got fixed and i just didn't notice?

[23:32] <timotimo> yeah, i've been running a loop that runs Buf.new(^256 .roll(64)).decode("utf8-c8") until it throws an exception

[23:33] <timotimo> that's cool.

[23:44] <samcv> m: my $b = Buf.new([245, 187, 185, 167]).decode("utf8-c8").say

[23:44] <camelia> rakudo-moar b66f5e: OUTPUT: «Error encoding UTF-8 string: could not encode codepoint 1556071 (0x17BE67), codepoint out of bounds. Cannot encode higher than 1114111 (0x10FFFF)␤  in block <unit> at <tmp> line 1␤␤»

[23:45] <samcv> m: my $b = Buf.new([245, 187, 185, 167]).decode("utf8-c8").ords.say

[23:45] <camelia> rakudo-moar b66f5e: OUTPUT: «(1556071)␤»

[23:49] <samcv> well i fixed one of them at least timotimo

[23:50] <samcv> maybe

[23:52] <timotimo> i wonder if i just did my code wrong that i never stumbled upon any case where it threw an exception

[23:52] <timotimo> weird.

[23:54] <samcv> well i found the issue

[23:54] <samcv> it doesn't check if the codepoint is too large

[23:54] <samcv> i fuond the rigth spot and put a check in and it didn't die
