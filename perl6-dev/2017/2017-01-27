[01:12] <samcv> what do people think of this? https://github.com/rakudo/rakudo/compare/nom...samcv:skip-Inf

[01:12] <samcv> atm if you do "use Test; skip 'reason', Inf" it will cause an infinite loop

[01:13] <samcv> so we can either make it throw or make it act as skip-rest does

[01:34] <brokenchicken> I think: YAGNI (You Ain't Gonna Need It) and it's an anti-pattern as the correct way to skip the rest of tests is with skip-rest. I imagine that also slows down all skip() due to the where clause (it can't cache candidate look up IIRC) and we use skip() in skip fudges.

[01:41] <brokenchicken> "due to the where clause" -> that `Inf` in signature is just a sugar for `where $_ eqv Inf` or something along those lines

[01:45] <Geth> nqp: ef1aa3787b | (Samantha McVey)++ | tools/lib/NQP/Configure.pm

[01:45] <Geth> nqp: Have Configure.pl tell you what version of Moar it wants if it finds one too old

[01:45] <Geth> nqp: review: https://github.com/perl6/nqp/commit/ef1aa3787b

[01:45] <perlawhi1l> Found a significant bug with `IO.lines` iterator, i think introduced recently with liz's work on iterators

[01:45] <perlawhi1l> m: $++ for 'mbox'.IO.lines.batch(30)

[01:45] <camelia> rakudo-moar d06d7c: OUTPUT«readline requires an object with REPR MVMOSHandle␤  in block <unit> at <tmp> line 1␤␤»

[01:46] <perlawhi1l> also affects partial rotor

[01:46] <perlawhi1l> m: $++ for 'mbox'.IO.lines.rotor(30, :partial)

[01:46] <camelia> rakudo-moar d06d7c: OUTPUT«readline requires an object with REPR MVMOSHandle␤  in block <unit> at <tmp> line 1␤␤»

[01:46] <perlawhi1l> if the file's lines are not %% $n, you'll get that error

[01:47] <brokenchicken> bisectable6: $++ for 'mbox'.IO.lines.batch(30)

[01:47] <bisectable6> brokenchicken, Bisecting by output (old=2015.12 new=d06d7c1) because on both starting points the exit code is 1

[01:47] <bisectable6> brokenchicken, bisect log: https://gist.github.com/6b28171fbb84877cb2f2aa11a6af42c6

[01:47] <bisectable6> brokenchicken, (2015-12-25) https://github.com/rakudo/rakudo/commit/07fecb52eb1fd07397659f19a5cf36dc61f84053

[01:48] <perlawhi1l> it's file IO, so will need a file that bisectable can read

[01:48] <brokenchicken> c: HEAD $++ for '/home/.bash_history'.IO.lines.batch(30)

[01:48] <committable6> brokenchicken, ¦«HEAD»: Failed to open file /home/.bash_history: no such file or directory␤  in block <unit> at /tmp/D8ETrngHjO line 1␤␤Actually thrown at:␤  in block <unit> at /tmp/D8ETrngHjO line 1␤ «exit code = 1»

[01:48] <MasterDuke> there is a stdin set for the *ables

[01:48] <brokenchicken> c: HEAD $++ for '/home/bisectable/.bash_history'.IO.lines.batch(30)

[01:48] <committable6> brokenchicken, ¦«HEAD»: readline requires an object with REPR MVMOSHandle␤  in block <unit> at /tmp/7klq6b6Dxv line 1␤ «exit code = 1»

[01:48] <brokenchicken> bisect: HEAD $++ for '/home/bisectable/.bash_history'.IO.lines.batch(30)

[01:48] <bisectable6> brokenchicken, On both starting points (old=2015.12 new=d06d7c1) the exit code is 1 and the output is identical as well

[01:48] <bisectable6> brokenchicken, Output on both points: 04===SORRY!04=== Error while compiling /tmp/2qpD2EFqxv␤Undeclared name:␤    HEAD used at line 1␤

[01:48] <brokenchicken> really....

[01:49] <brokenchicken> oh, oops

[01:49] <brokenchicken> bisect: $++ for '/home/bisectable/.bash_history'.IO.lines.batch(30)

[01:49] <bisectable6> brokenchicken, Bisecting by output (old=2015.12 new=d06d7c1) because on both starting points the exit code is 1

[01:49] <bisectable6> brokenchicken, bisect log: https://gist.github.com/4e26fa248358385f68312fffe7729bcc

[01:49] <bisectable6> brokenchicken, (2016-09-27) https://github.com/rakudo/rakudo/commit/222d16b0b94911fdedb06ee6ad817d0f14b9c05c

[01:49] <brokenchicken> mc: $++ for '/home/bisectable/.bash_history'.IO.lines.batch(30)

[01:49] <committable6> brokenchicken, ¦«2015.12»: Method 'batch' not found for invocant of class 'Seq'␤  in block <unit> at /tmp/5FskAHpaoV line 1␤ «exit code = 1»

[01:49] <brokenchicken> *sigh*

[01:49] <brokenchicken> c: all $++ for '/home/bisectable/.bash_history'.IO.lines.batch(30)

[01:50] <committable6> brokenchicken, https://gist.github.com/a30f4e22de92ce6d425ec8136bf7abdc

[01:50] <MasterDuke> bisect: old=2016.10 $++ for '/home/bisectable/.bash_history'.IO.lines.batch(30)

[01:50] <bisectable6> MasterDuke, Bisecting by output (old=2016.10 new=d06d7c1) because on both starting points the exit code is 1

[01:50] <bisectable6> MasterDuke, bisect log: https://gist.github.com/70213b2c283fcdb9fd05824282bc629d

[01:50] <bisectable6> MasterDuke, (2017-01-22) https://github.com/rakudo/rakudo/commit/e0201f15dffcef82af8750a3d8ca77341b0a8e7f

[01:50] <perlawhi1l> hah... try with rotor

[01:50] <perlawhi1l> batch didn't exist prior to that commit

[01:50] <brokenchicken> bisect: old=2016.12 new=HEAD $++ for '/home/bisectable/.bash_history'.IO.lines.batch(30)

[01:50] <bisectable6> brokenchicken, Bisecting by output (old=2016.12 new=d06d7c1) because on both starting points the exit code is 1

[01:50] <bisectable6> brokenchicken, bisect log: https://gist.github.com/738cbc60184af8bfe3c55c9fe7ae6de4

[01:50] <bisectable6> brokenchicken, (2017-01-22) https://github.com/rakudo/rakudo/commit/e0201f15dffcef82af8750a3d8ca77341b0a8e7f

[01:51] <brokenchicken> good plan

[01:51] <brokenchicken> bisect: old=2016.12 new=HEAD $++ for '/home/bisectable/.bash_history'.IO.lines.rotor(30, :partial)

[01:51] <bisectable6> brokenchicken, Bisecting by exit code (old=2016.12 new=d06d7c1). Old exit code: 0

[01:51] <bisectable6> brokenchicken, bisect log: https://gist.github.com/1be431d0e1c297b76a1c19cc22f53dd7

[01:51] <bisectable6> brokenchicken, (2017-01-18) https://github.com/rakudo/rakudo/commit/fd8df7f2ad509689a64b8825e1c4bb622cf7486f

[01:52] <samcv> wow. uh

[01:52] <samcv> fail Util.pm doesn't have the right order of arguments for skip

[01:52] <samcv> had: skip 1, "reason"; and only reason it worked before is the reason became 1 and it just skipped once prolly

[01:53] <samcv> was failing loads of tests with that Int constraint cause Util.pm was trying to pass a string as the number of times to skip, since it had the number and reason reversed

[01:53] <perlawhi1l> brokenchicken: so it looks like that rotor is using R::I.Batch() which explains the identical behaivior

[01:53] <brokenchicken> samcv: there's a check for that though: https://github.com/rakudo/rakudo/blob/nom/lib/Test.pm6#L354

[01:54] <samcv> well...

[01:54] <samcv> idk what to tell you

[01:54] <brokenchicken> samcv: which Util.pm?

[01:55] <samcv> it's in roast

[01:55] <samcv> i'm gonna commit a fix now

[01:57] <brokenchicken> samcv: those conditions just never got ran (or if they did, user didn't notice)

[01:57] <samcv> they do get run

[01:57] <samcv> because it fails tests if i don't have them in the right order

[01:57] <samcv> or do you mean the check to make sure it's a number?

[01:57] <samcv> they definetly get run

[01:58] <brokenchicken> $ perl6 -Ipackages -MTest::Util -e 'is_run "42", {}'

[01:58] <brokenchicken> skip() was passed a non-numeric number of tests.  Did you get the arguments backwards?

[01:58] <Geth> roast: 6b1e00b212 | (Samantha McVey)++ | packages/Test/Util.pm

[01:58] <Geth> roast: Fix Util.pm which had reversed routine arguments for skip

[01:58] <Geth> roast: review: https://github.com/perl6/roast/commit/6b1e00b212

[01:58] <brokenchicken> perlawhi1l: right. file the ticket

[01:58] <brokenchicken> huggable: rakudobug

[01:58] <huggable> brokenchicken, Report bugs by emailing to [email@hidden.address]
[01:58] * brokenchicken goes to bed

[01:58] <samcv> i am saying that they do get run because it fails tests if i don't fix the roast Util.pm file

[01:58] <samcv> when I have an Int constraint to the skip sub

[01:59] <samcv> for whatever reason it didn't catch it

[01:59] <samcv> have a good sleep brokenchicken o/

[02:12] <Geth> rakudo/nom: ae9d517853 | (Samantha McVey)++ | lib/Test.pm6

[02:12] <Geth> rakudo/nom: Have skip check we get an Int so we don't have a loop when given Inf

[02:12] <Geth> rakudo/nom:

[02:12] <Geth> rakudo/nom: If we do: skip 'reason, Inf; we would get an infinite loop. Instead let's make sure we are

[02:12] <Geth> rakudo/nom: passed in an Int.

[02:12] <Geth> rakudo/nom:

[02:12] <Geth> rakudo/nom: In addition the !~~ Numeric was not catching all cases for some reason, and Util.pm was able

[02:12] <Geth> rakudo/nom: to give it a Str

[02:12] <Geth> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/ae9d517853

[02:21] <samcv> oh god this isn't good at all. so i got further into being able to use this module by adding its dependencies to the primary perl 6 script

[02:22] <samcv> but then once I added all the deps, i didn't get any of the "Missing or wrong version of dependency" errors, and instead got a segfault :(

[02:22] <samcv> nine, you around?

[07:57] <nine> samcv: just woke up

[08:00] <samcv> this is where i'm seeing the issue https://github.com/samcv/UCD/tree/module-problem

[08:00] <samcv> i made a branch and saved the changes so could be debugged, and just did not move that code into a module and kept working

[08:00] <samcv> if you want to clone and run UCD-gen.p6

[08:01] <samcv> will give you time to wake up tho :P

[08:18] <nine> Failed to open file /home/nine/install/UCD/UNIDATA/extracted/DerivedNumericValues.txt: no such file or directory

[08:21] <samcv> so it compiled?

[08:21] <nine> looks like

[08:22] <samcv> hmmmm

[08:22] * samcv clones it into another folder

[08:22] <samcv> i thought i deleted all precom :\

[08:23] <nine> Have you run it with RAKUDO_MODULE_DEBUG=1? That could give you a hint at where it's going wrong

[08:24] <samcv> let me try that

[08:29] <samcv> this is what i got https://gist.github.com/d2cd4605802cc49c9f535b16e57b3593

[08:35] <nine> That kinda looks like it didn't write that dependency into the precomp file?

[08:36] <nine> Can you take a look at the first few lines (until the first empty line) of /home/samantha/git/UCD-samcv/lib/.precomp/76FE986208165AAEB6161831CBDF7247AAE8CAEC.1485481379.09471/FE/FEC37283C4809ED9F18FA7E1043E3FF262D31FEA

[08:38] <samcv> nine, https://gist.github.com/dbf8c9fe88a63aba47ff5b56492830c8

[08:39] <nine> Yes, that's just the one dependency.

[08:42] <nine> Wait, what?! It didn't record the dependency because it just isn't a dependency.

[08:42] <nine> But anyway, I'm not sure if augmenting and precompilation mix too well

[08:44] <samcv> hm

[08:44] <samcv> it worked fine for all the other ones :\

[08:51] <samcv> and seems to work for you :\ so that's really werid

[08:54] <nine> Btw. the surest way to get rid of stale precomp files is to recompile rakudo ;)

[08:55] <samcv> will try that

[10:04] * jnthn can't remember if we made use of `augment` imply "no precompilation" yet

[10:15] <gfldex> jnthn: i remeber that we did

[10:25] <nine> gfldex: that may be our intention, but we don't have code that forces this yet.

[10:30] <gfldex> nine: did you see this? https://irclog.perlgeek.de/perl6/2017-01-26#i_13992409

[10:35] <nine> gfldex: no

[10:45] <nine> gfldex: running with RAKUDO_MODULE_DEBUG=1 may give you some hint

[11:22] <samcv> nine, i'm getting more problems like things that i am exporting not being imported

[11:24] <samcv> err actually. well the same problem as before

[11:24] <samcv> missing or wrong version of dependency

[11:24] <samcv> ack

[11:26] <samcv> even after commenting out the augment string part

[11:33] <nine> maybe it's the print?

[11:33] <nine> I think Encode40 prints something? Precompilation uses STDOUT for communicating dependencies

[11:37] <samcv> ok i can try removing all of them

[11:38] <samcv> i remove it and it still prints the dot out :\

[11:40] <samcv> oh wait. hm

[11:40] <samcv> nvm

[11:40] * nine slowly exhales

[11:40] <brokenchicken> :)

[11:43] <samcv> ok now i still get the error :)

[11:43] <samcv> it doesn't print out a dot tho :P

[11:43] <samcv> ahh

[11:53] <samcv> well i rearranged enough things into different modules i finally got it working :\

[11:55] <samcv> didn't seem related to Augment though, since still had the problem when I commented all that out

[11:55] <gfldex> nine: that's what I got https://gist.github.com/gfldex/ca23861f16861d8f468957844d141a55

[12:09] <|Tux|> This is Rakudo version 2017.01-59-gae9d51785 built on MoarVM version 2017.01-14-g357438a9

[12:09] <|Tux|> csv-ip5xs        2.800

[12:09] <|Tux|> test            12.314

[12:09] <|Tux|> test-t           5.007

[12:09] <|Tux|> csv-parser      13.756

[12:12] <gfldex> is there any way to dump what is precompiled under ~/.perl6 ?

[12:24] <Geth> roast: 104a3c8fbb | (Elizabeth Mattijsen)++ | S32-list/iterator.t

[12:24] <Geth> roast: Remove List.invert test

[12:24] <Geth> roast:

[12:24] <Geth> roast: List.invert seems to depend on having Pairs as members.  This feels

[12:24] <Geth> roast: really at odds with other .invert implementations, which basically

[12:24] <Geth> roast: just works off foo.pairs.  Changing the List.invert implementation

[12:24] <Geth> roast: to also work on .pairs makes the tests pass, but this seems countrary

[12:24] <Geth> roast: to TimToady's intent with List.invert, as seen in baeabb4c .

[12:24] <Geth> roast: review: https://github.com/perl6/roast/commit/104a3c8fbb

[12:32] <Geth> roast: 513cc0c1ca | (Elizabeth Mattijsen)++ | S02-types/set-iterator.t

[12:32] <Geth> roast: Add basic iterator tests for Set/SetHash

[12:32] <Geth> roast: review: https://github.com/perl6/roast/commit/513cc0c1ca

[12:33] <Geth> rakudo/nom: f3c9e11d77 | (Elizabeth Mattijsen)++ | t/spectest.data

[12:33] <Geth> rakudo/nom: Run Set/SetHash iterator tests

[12:33] <Geth> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/f3c9e11d77

[12:37] <Geth> roast: 5762d844d7 | (Elizabeth Mattijsen)++ | S02-types/bag-iterator.t

[12:37] <Geth> roast: Add basic Bag/BagHash iterator tests

[12:37] <Geth> roast: review: https://github.com/perl6/roast/commit/5762d844d7

[12:38] <Geth> rakudo/nom: dd6c7b6466 | (Elizabeth Mattijsen)++ | t/spectest.data

[12:38] <Geth> rakudo/nom: Make sure we run Bag/BagHash iterator tests

[12:38] <Geth> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/dd6c7b6466

[12:43] <Geth> roast: e5c0fe8bc3 | (Elizabeth Mattijsen)++ | S02-types/mix-iterator.t

[12:43] <Geth> roast: Add basic Mix/MixHash iterator tests

[12:43] <Geth> roast: review: https://github.com/perl6/roast/commit/e5c0fe8bc3

[12:44] <Geth> rakudo/nom: 2734533a05 | (Elizabeth Mattijsen)++ | t/spectest.data

[12:44] <Geth> rakudo/nom: Make sure we run basic Mix/MixHash iterator tests

[12:44] <Geth> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/2734533a05

[12:57] <dogbert17_> lizmat: did you see this? https://irclog.perlgeek.de/perl6-dev/2017-01-27#i_13996365

[12:58] <lizmat> dogbert17_: no, did you make a ticket ?

[13:00] <Geth> roast: b9dee81d57 | (Elizabeth Mattijsen)++ | packages/Test/Iterator.pm

[13:00] <Geth> roast: Abstract iterator testing logic into Test::Iterator

[13:00] <Geth> roast: review: https://github.com/perl6/roast/commit/b9dee81d57

[13:01] <Geth> roast: f5f65406f2 | (Elizabeth Mattijsen)++ | 5 files

[13:01] <Geth> roast: Have iterator tests use Test::Iterator

[13:01] <Geth> roast: review: https://github.com/perl6/roast/commit/f5f65406f2

[13:03] <lizmat> afk&

[13:07] <dogbert17_> lizmat: no, I assumed that the people involved in the discussion would do that. If they have forgotten to do it I'll add it later today

[13:25] <brokenchicken> mc: .pull-one xx 1000 given $*PROGRAM.IO.lines.iterator

[13:25] <committable6> brokenchicken, ¦«2015.12»: readline requires an object with REPR MVMOSHandle␤  in block  at /tmp/l7c6P8ZjVs line 1␤  in block <unit> at /tmp/l7c6P8ZjVs line 1␤ «exit code = 1»

[13:26] <brokenchicken> Seems that bug existed for ages and RI::Batch just exposed it

[13:33] <brokenchicken> Ah, I see where it's at

[14:04] <brokenchicken> I'm getting stresstest failures in t/spec/S02-types/num.t and t/spec/S09-hashes/objecthash.t: https://gist.github.com/zoffixznet/422f019322f3dfd2051773bd02b2e250

[14:05] <brokenchicken> m: dd (my %h).list.perl

[14:05] <camelia> rakudo-moar 273453: OUTPUT«"().Seq"␤»

[14:05] <brokenchicken> hm

[14:07] <brokenchicken> stale roast

[14:12] <Geth> rakudo/nom: ede01c2476 | (Zoffix Znet)++ | src/core/IO/Handle.pm

[14:12] <Geth> rakudo/nom: Fix crash in .pull-one on IO::Handle.lines iterator

[14:12] <Geth> rakudo/nom:

[14:12] <Geth> rakudo/nom: That seems to occur with RI::Batch/RI::Rotor iterators or

[14:12] <Geth> rakudo/nom: when .pull-one is called manually.

[14:12] <Geth> rakudo/nom:

[14:12] <Geth> rakudo/nom: The iterator calls .get() on the Handle that reads from its $!PIO

[14:12] <Geth> rakudo/nom: and when that's exhaused the $!PIO is set to null. So when the next

[14:12] <Geth> rakudo/nom: .pull-one is done, we try to .get() on a closed handle by attempting

[14:12] <Geth> rakudo/nom: to read from nqp::null() that $!PIO is now is.

[14:12] <Geth> rakudo/nom:

[14:12] <Geth> rakudo/nom: Bug find: https://irclog.perlgeek.de/perl6-dev/2017-01-27#i_13996365

[14:12] <Geth> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/ede01c2476

[14:13] <Geth> roast: 44ba5ec46d | (Zoffix Znet)++ | S16-io/lines.t

[14:13] <Geth> roast: Test IO::Handle.lines iterator does not crash when...

[14:13] <Geth> roast:

[14:13] <Geth> roast: ...the handle gets closed

[14:13] <Geth> roast: Rakudo fix: https://github.com/rakudo/rakudo/commit/ede01c2476

[14:13] <Geth> roast: review: https://github.com/perl6/roast/commit/44ba5ec46d

[14:14] <brokenchicken> IO::Handle.get() is in want of some loving for cases when the handle is closed... I hear there's a grant application for that area, so fingers crossed it gets approved :}

[14:15] <brokenchicken> hmm

[14:16] <brokenchicken> $!handle.WHAT is probably a mistake in the above fix. If this stuff's on a subclass of IO::Handle that'll explode.

[14:16] <brokenchicken> Need to do some $work first but will take a look at that today.

[14:16] <brokenchicken> ZOFVM: Files=1220, Tests=133304, 189 wallclock secs (22.21 usr  3.21 sys + 3568.36 cusr 266.27 csys = 3860.05 CPU)

[14:23] <brokenchicken> m: $++ for 'mbox'.IO.lines.rotor(30, :partial)

[14:23] <camelia> rakudo-moar 273453: OUTPUT«readline requires an object with REPR MVMOSHandle␤  in block <unit> at <tmp> line 1␤␤»

[14:23] <brokenchicken> m: $++ for 'mbox'.IO.lines.rotor(30)

[14:23] <camelia> rakudo-moar 273453: ( no output )

[14:31] <brokenchicken> m: $++ for 'mbox'.IO.lines.batch(30)

[14:31] <camelia> rakudo-moar ede01c: ( no output )

[14:31] <brokenchicken> m: $++ for 'mbox'.IO.lines.rotor(30, :partial)

[14:31] <camelia> rakudo-moar ede01c: ( no output )

[15:34] <dogbert17_> brokenchicken++

[16:10] <Geth> rakudo/nom: 12 commits pushed by jnthn++

[16:10] <Geth> rakudo/nom: review: https://github.com/rakudo/rakudo/compare/ede01c2476...dd1cb5fc9a

[16:11] <jnthn> That was the merge in of v6.d.PREVIEW and non-blocking await :)

[16:12] <brokenchicken> cool

[16:12] <brokenchicken> We now officially have more than one language version that can be used :P

[16:13] <jnthn> :)

[16:17] <moritz> \o/

[16:22] <[Coke]> so, how do we spectect v6.d.PREVIEW?

[16:23] <brokenchicken> right now that file juse uses v6.d.PREVIEW and that mode is enabled in it

[16:23] <[Coke]> master? 6.d.PREVIEW branch?

[16:23] <brokenchicken> that file => the one file with a test in it

[16:23] <[Coke]> ok. that's fine for now, we'll have to have a plan as we get closer to Diwali.

[16:25] <jnthn> It'll be easy enough to grep that out later, I figure.

[16:26] <[Coke]> jnthn: I don't necessarily want us to do exactly the same thing we did with christmas, though. (maybe we remove fudges, for example?)

[16:27] <jnthn> [Coke]: Removing the fudges in the thing we tag as 6.d would be nice if we can do it

[16:27] <jnthn> My expectation the month or so before 6.d is we'll do something like

[16:27] <jnthn> 1) Rakudo starts to consider 6.d the current default version

[16:28] <jnthn> 2) We remove the now-redundant `use v6.d.PREVIEW`

[16:28] <jnthn> 3) In a branch, do whatever else we'd like to do in the roast suite we will tag 6.d

[16:28] <jnthn> 4. Tag 6.d there around when the first Rakudo monthly with 6.d support is released.

[16:28] <jnthn> heh, 4) :)

[16:29] <perlpilot> m: use v6.c.PREVIEW;

[16:29] <camelia> rakudo-moar ede01c: ( no output )

[16:29] <jnthn> 6.c > 6.c.PREVIEW :)

[16:29] <perlpilot> I was just musing about step #2's relation to v6.c

[16:30] <jnthn> m: use v6.d.PREVIEW

[16:30] <camelia> rakudo-moar ede01c: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤No compiler available for Perl v6.d.PREVIEW␤at <tmp>:1␤------> 3use v6.d.PREVIEW7⏏5<EOL>␤»

[16:30] <jnthn> Not rebuilt yet :)

[16:31] <perlpilot> anyway ... jnthn++  :-)

[16:32] * jnthn writes tests to see that `await` in whenever blocks works out as expected. :)

[16:32] <jnthn> Or at least, as I expected :P

[16:36] <brokenchicken> m: use v6.d.PREVIEW; say &await.file; use v6.c; say &await.file;

[16:36] <camelia> rakudo-moar dd1cb5: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤No compiler available for Perl v6.c␤at <tmp>:1␤------> 3 v6.d.PREVIEW; say &await.file; use v6.c7⏏5; say &await.file;␤»

[16:36] <brokenchicken> m: use v6.c

[16:36] <camelia> rakudo-moar dd1cb5: ( no output )

[16:36] <brokenchicken> hm

[16:37] <brokenchicken> m: {use v6.d.PREVIEW; say &await.file}; {use v6.c; say &await.file; }

[16:37] <camelia> rakudo-moar dd1cb5: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤No compiler available for Perl v6.c␤at <tmp>:1␤------> 036.d.PREVIEW; say &await.file}; {use v6.c7⏏5; say &await.file; }␤»

[16:37] <brokenchicken> m: {use v6.c; say &await.file}; {use v6.d.PREVIEW; say &await.file; }

[16:37] <camelia> rakudo-moar dd1cb5: OUTPUT«SETTING::src/core.d/await.pm␤SETTING::src/core.d/await.pm␤»

[16:40] <brokenchicken> m: 'use v6.d.PREVIEW; say &await.file'.EVAL; 'use v6.c; say &await.file;'.EVAL

[16:40] <camelia> rakudo-moar dd1cb5: OUTPUT«SETTING::src/core/asyncops.pm␤SETTING::src/core/asyncops.pm␤»

[16:42] <jnthn> A use v6.blah directive needs to be the first thing in a file, really. If we ain't enforcing that already, we should start doing so.

[16:43] <brokenchicken> ah

[16:43] <jnthn> Or at the very least, it needs to be no later than we'd allow a unit package decl.

[16:43] <jnthn> Hmmm...

[16:43] <jnthn> Now I start writing tests for await and whenever I start realizing it's semantically more interesting that I first realized. :)

[16:47] <brokenchicken> m: EVALFILE '/tmp/foo1'; EVALFILE '/tmp/foo2';

[16:47] <camelia> rakudo-moar dd1cb5: OUTPUT«SETTING::src/core/asyncops.pm␤SETTING::src/core/asyncops.pm␤»

[16:48] <brokenchicken> m: use lib </tmp/foo>; use c; use d;

[16:48] <camelia> rakudo-moar dd1cb5: OUTPUT«SETTING::src/core/asyncops.pm␤SETTING::src/core.d/await.pm␤»

[16:48] <brokenchicken> Success \o/

[16:49] <b2gills> I was just trying out `use v6.d.PREVIEW` on the REPL, and it either doesn't do anything at all, or it doesn't set $*PERL ( -Mv6.d.PREVIEW  doesn't work either, and it would be nice )

[16:51] <brokenchicken> m: use v6.d.PREVIEW; say $*PERL

[16:51] <camelia> rakudo-moar dd1cb5: OUTPUT«Perl 6 (6.d)␤»

[16:55] <jnthn> Hm, that should perhaps say 6.d.PREVIEW :)

[17:07] <b2gills> Well it does seem like `use v6.d.PREVIEW` at least does something if it is the first thing in a REPL session, checked by calling `&await.candidates».signature`

[17:28] <[Coke]> jnthn: if it has to be the first thing in a file, does that mean no lexical version scoping?

[17:30] <jnthn> [Coke]: Yes.

[17:30] <[Coke]> awwww, I thought that was going to be a thing. :)

[17:30] * brokenchicken too

[17:32] <jnthn> Thing is, if another language version implies a different setting, and the setting is the outer scope of the program, what does it mean to change language version in a nested scope?

[17:41] <brokenchicken> Ah

[17:43] <brokenchicken> I don't fully get then why the setting version can be changed in separate files, yet the `our` symbols are all in the same GLOBAL:: namespace

[17:43] <Geth> roast: 8dead1cd38 | (Jonathan Worthington)++ | S17-supply/syntax-nonblocking-await.t

[17:43] <Geth> roast: Add new test file for supply syntax non-blocking.

[17:43] <Geth> roast:

[17:43] <Geth> roast: We'll flesh out the semantics of `await` inside of a `supply`,

[17:43] <Geth> roast: `react`, and `whenever` block a little later on. For now, this just

[17:43] <Geth> roast: ensures that `react` itself is non-blocking.

[17:43] <Geth> roast: review: https://github.com/perl6/roast/commit/8dead1cd38

[17:43] <jnthn> The setting doesn't define any GLOBAL symbols?

[17:44] <brokenchicken> Hm. OK.

[17:44] <jnthn> Everything is my-scoped

[17:44] <jnthn> Every program you write has the setting as its outer scope

[17:44] <brokenchicken> Maybe it'll be clearer when I finish the Internals Course. Hoping to finally do it this weekend :)

[17:44] <jnthn> It's semantically like your program is written textually within a bare block at the end of CORE.setting

[17:45] <brokenchicken> Ah

[17:45] <jnthn> Here's another nice thing:

[17:45] <Geth> rakudo/nom: 4aa8d70ebf | (Jonathan Worthington)++ | src/core.d/await.pm

[17:45] <Geth> rakudo/nom: Make `react` also non-blocking in 6.d.PREVIEW.

[17:45] <Geth> rakudo/nom:

[17:45] <Geth> rakudo/nom: Or at least, make it that way if it's called in a `start` block.

[17:45] <Geth> rakudo/nom: This means you can have many thousands of `start react { ... }`

[17:45] <Geth> rakudo/nom: constructs running with just a handful of CPU threads; they will no

[17:45] <Geth> rakudo/nom: longer block up a real thread.

[17:45] <Geth> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/4aa8d70ebf

[17:45] <Geth> rakudo/nom: 012c54cc71 | (Jonathan Worthington)++ | t/spectest.data

[17:45] <Geth> rakudo/nom: Run S17-supply/syntax-nonblocking-await.t.

[17:45] <Geth> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/012c54cc71

[17:45] <brokenchicken> Oh awesome

[17:46] * brokenchicken frequently uses start react ...

[17:46] <jnthn> 6.d will let you do it without worrying :)

[17:46] <brokenchicken> \o/

[17:48] <jnthn> Need to do a bit of thinking about use of await inside of supply/react/whenever

[17:51] <jnthn> More immediately, need dinner :) bbl

[18:53] <TimToady> jnthn: what do you think of reserving the [] subsig (leaving () subsig as is) for forcing pairs to be treated as positionals rather than nameds?  Currently we always turn them into named, but that makes it impossible to make a positional subsig that matches, say, two Pairs in a list

[18:54] <TimToady> which grondilu++ was attempting the other day, to process an X operator between lists of pairs

[18:56] <TimToady> also might be slightly faster to bind [] than () in that case, if we know we don't have to scan for pairs

[18:57] <TimToady> probably needs a deprecation till 6.d if we notice :$foo inside [] subsig

[18:59] <TimToady> we'd need some signal into the binder that it can make a Capture by just slapping @!list in, rather than using .Capture

[18:59] <TimToady> also, currently, the [] vs () distinction doesn't seem very useful, so this would justify that some

[19:04] <samcv> jnthn, get some really odd errors with `use 6.d.PREVIEW` inside the doc's htmlify.p6

[19:04] <samcv> No such method 'contents' for invocant of type 'Str'

[19:08] <samcv> oh i guess it happens even when we don't use that. different errors than we used to get though. it used to totally segfault

[19:08] <samcv> or whatever it did

[19:09] <[Coke]> samcv: the old paralleism code in there was very broken, yes.

[19:09] <[Coke]> (coke/bughunt branch golf'd the issue, was never fixed, SFAIK)

[19:09] <samcv> like it's calling methods on the wrong things :\

[19:10] <samcv> it used to crash for me, now it has weirder things happen :) which either means it's more fixed or less fixed or different?

[19:12] <[Coke]> I think the weird things used to lead to crashes which were fixed. now we have to fix the weird things 9which seems like some objects getting replaced by other, unexpected objects)

[19:18] <RabidGravy> yeah, I've seen that in other places too

[19:18] <RabidGravy> if you really punish HTTP::Server::Async it starts trying to throw blocks as exceptions

[19:24] <dogbert17> anyone knows if t/spec/S09-typed-arrays/native-str.t is broken atm?

[19:26] <brokenchicken> wasn't 6 hours ago

[19:26] <dogbert17> ok 146 - does join a str array

[19:26] <dogbert17> MoarVM panic: Collectable 0x8d696d4 in fromspace accessed

[19:26] <dogbert17> Dubious, test returned 1 (wstat 256, 0x100)

[19:26] <dogbert17> I do have some GC debug flags turned on

[19:32] <Geth> roast: 93c356a9e1 | (Elizabeth Mattijsen)++ | packages/Test/Iterator.pm

[19:32] <Geth> roast: Add some tests for iterator exhaustion

[19:32] <Geth> roast: review: https://github.com/perl6/roast/commit/93c356a9e1

[19:33] <Geth> rakudo/nom: 4830583387 | (Elizabeth Mattijsen)++ | src/core/Rakudo/Iterator.pm

[19:33] <Geth> rakudo/nom: Fix problem with sink-all in R:It.ReifiedList

[19:33] <Geth> rakudo/nom:

[19:33] <Geth> rakudo/nom: Spotted by additional iterator testing.

[19:33] <Geth> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/4830583387

[19:38] <MasterDuke_> is it ever the case that `$foo ~~ 123` != `$foo == 123` or `$foo ~~ 'bar'` != `$foo eq 'bar'`?

[19:39] <brokenchicken> s: 123, 'ACCEPTS', \($)

[19:39] <SourceBaby> brokenchicken, Sauce is at https://github.com/rakudo/rakudo/blob/012c54c/src/core/Any.pm#L18

[19:39] <brokenchicken> Yup

[19:39] <brokenchicken> m: my $foo; say $foo ~~ 0

[19:39] <camelia> rakudo-moar 012c54: OUTPUT«False␤»

[19:39] <brokenchicken> m: my $foo; say $foo == 0

[19:39] <camelia> rakudo-moar 012c54: OUTPUT«Use of uninitialized value of type Any in numeric context␤  in block <unit> at <tmp> line 1␤True␤»

[19:39] <brokenchicken> (it says True after the warning)

[19:40] <brokenchicken> s: "x", 'ACCEPTS', \($)

[19:40] <SourceBaby> brokenchicken, Sauce is at https://github.com/rakudo/rakudo/blob/012c54c/src/core/Any.pm#L18

[19:40] <brokenchicken> And same for strings

[19:40] <brokenchicken> s: "x", 'ACCEPTS', \("y")

[19:40] <SourceBaby> brokenchicken, Sauce is at https://github.com/rakudo/rakudo/blob/012c54c/src/core/Str.pm#L106

[19:40] <MasterDuke_> brokenchicken++

[19:41] <brokenchicken> s: &infix:<eq>, \("x", "y")

[19:41] <SourceBaby> brokenchicken, Sauce is at https://github.com/rakudo/rakudo/blob/012c54c/src/core/Str.pm#L2767

[19:41] <brokenchicken> s: &infix:<eq>, \("x", ("y" but "z"))

[19:41] <SourceBaby> brokenchicken, Sauce is at https://github.com/rakudo/rakudo/blob/012c54c/src/core/Str.pm#L2767

[19:42] <brokenchicken> s: &infix:<eq>, \("x", (42 but "z"))

[19:42] <SourceBaby> brokenchicken, Sauce is at https://github.com/rakudo/rakudo/blob/012c54c/src/core/Stringy.pm#L39

[19:42] <MasterDuke_> hm, so the optimizer couldn't just turn the ~~ into the correct op if the RHS is a constant

[19:44] <MasterDuke_> but can it know if the LHS is initialized?

[19:45] <MasterDuke_> `if nqp::isconcrete($foo)` might work

[19:46] <brokenchicken> m: say (42 but role { method Stringy { "x" } }) ~~ "x"

[19:46] <camelia> rakudo-moar 012c54: OUTPUT«False␤»

[19:46] <MasterDuke_> but that's probably more of a run-time thing.

[19:46] <brokenchicken> m: say (42 but role { method Stringy { "x" } }) eq "x"

[19:46] <camelia> rakudo-moar 012c54: OUTPUT«True␤»

[19:47] <brokenchicken> Though unsure if that's more of an indication of inconsistencies thatn actual design

[19:48] <MasterDuke_> and there is some way to tell if an object has roles/is a subclass, correct?

[19:49] * brokenchicken wonders how often people use ~~ instead of == or eq

[19:49] <MasterDuke_> m: use nqp; say nqp::isint(42 but role { method Stringy { "x" } })

[19:49] <camelia> rakudo-moar 012c54: OUTPUT«0␤»

[19:49] <brokenchicken> m: use nqp; say nqp::isint(42000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000)

[19:49] <camelia> rakudo-moar 012c54: OUTPUT«0␤»

[19:49] <MasterDuke_> i was going to grep through all-modules for those when i get to my machine

[19:50] <MasterDuke_> m: use nqp; say nqp::isbigint(42000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000)

[19:50] <camelia> rakudo-moar 012c54: OUTPUT«===SORRY!===␤No registered operation handler for 'isbigint'␤»

[19:50] <MasterDuke_> m: use nqp; say nqp::isbig(42000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000)

[19:50] <camelia> rakudo-moar 012c54: OUTPUT«===SORRY!===␤No registered operation handler for 'isbig'␤»

[19:50] <MasterDuke_> m: use nqp; say nqp::isbig_I(42000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000)

[19:50] <camelia> rakudo-moar 012c54: OUTPUT«1␤»

[19:50] <brokenchicken> m: use nqp; say nqp::isbig_I(.5)

[19:51] <camelia> rakudo-moar 483058: OUTPUT«P6opaque: get_boxed_ref could not unbox for the representation '20' of type Rat␤  in block <unit> at <tmp> line 1␤␤»

[19:52] <brokenchicken> m: say "42 " ~~ 42

[19:52] <camelia> rakudo-moar 483058: OUTPUT«True␤»

[19:52] <brokenchicken> m: say "42 " ~~ "42 "

[19:52] <camelia> rakudo-moar 483058: OUTPUT«True␤»

[19:52] <brokenchicken> m: say "42 " ~~ "42"

[19:52] <camelia> rakudo-moar 483058: OUTPUT«False␤»

[19:53] <brokenchicken> Guess can be handy when you're unsure whether you got a number or a stirng

[19:55] <brokenchicken> MasterDuke_: FWIW, there's already some magics for ACCEPTS in Actions.nqp (search for "ACCEPTS")

[19:55] <brokenchicken> I think we have it turn "foo" ~~ /regex/ into .match call or something or other

[19:58] <MasterDuke_> i don't see anything particularly magical?

[19:58] <brokenchicken> I mean some improvements to codegen :)

[19:58] <brokenchicken> to make stuff faster

[19:59] <brokenchicken> Never mind :)

[20:01] <MasterDuke_> heh, i don't see a whole lot of optimizations going on

[20:01] <MasterDuke_> though i found this typo unreasonably amusing: https://github.com/rakudo/rakudo/blob/nom/src/Perl6/Actions.nqp#L6492-L6493

[20:02] <geekosaur> smarmy match?

[20:03] <brokenchicken> hehe :)

[20:03] <brokenchicken> m: multi infix:<~~>(\x, \y) {}

[20:03] <camelia> rakudo-moar 483058: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Cannot override infix operator '~~', as it is a special form handled directly by the compiler␤(consider implementing an ACCEPTS method)␤at <tmp>:1␤------> 3multi infix:<~~>7⏏5(\x, \y) {}␤»

[20:04] <brokenchicken> Hm. I don't know much about it, but from QASTs I see the code generated for it calls &infix:<~~> ("- QAST::Op(callstatic &infix:<~~>) <wanted> ~~"). But if users can't make their own, we can go directly and code-gen an .ACCEPTS method call, no?

[20:05] <brokenchicken> .oO( prolly not 'cause chaining? )

[20:28] <Geth> roast: 32954b2879 | (Elizabeth Mattijsen)++ | S32-list/iterator.t

[20:28] <Geth> roast: Ensure lazyiness is preserved of iterators

[20:28] <Geth> roast: review: https://github.com/perl6/roast/commit/32954b2879

[20:28] <lizmat> *laziness

[20:29] <brokenchicken> lizmat++ all the tests \o/

[21:04] <jnthn> m: dd (.list, .hash) given (a => 1, b => 2).Capture)

[21:04] <camelia> rakudo-moar 483058: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Unexpected closing bracket␤at <tmp>:1␤------> 3t, .hash) given (a => 1, b => 2).Capture7⏏5)␤»

[21:04] <jnthn> m: dd (.list, .hash) given (a => 1, b => 2).Capture

[21:04] <camelia> rakudo-moar 483058: OUTPUT«((), Map.new((:a(1),:b(2))))␤»

[21:04] <jnthn> TimToady: At present, [...] is just (...) plus a Positional constraint

[21:05] <jnthn> TimToady: And both call .Capture to get the capture to unpack

[21:05] <jnthn> TimToady: We could, arguably, make [...] require Positional (still) and instead call .list or so

[21:05] <jnthn> (Or perhaps .cache)

[21:06] <jnthn> I suspect that'd actually make destructuring an array more performant, by saving us the cost of the Capture round-trip...

[21:06] <jnthn> So it seems like a promising idea at first blush

[21:06] <jnthn> m: dd (a => 1).list

[21:06] <camelia> rakudo-moar 483058: OUTPUT«(:a(1),)␤»

[21:07] <jnthn> And that makes a list of 1 thing, so seems it'd handle what you're wanting reasonably

[21:09] <jnthn> And [:$foo] and [*%foo] in this case would always be deprecation-warning worthy

[21:09] <jnthn> Because you'd just never hit them

[21:09] <jnthn> With the new behavior

[21:09] <jnthn> So that part seems sensible too

[21:11] <Geth> nqp/master: 7 commits pushed by pmurias++

[21:11] <Geth> nqp/master: 807a87acce | Test nqp::join with boxed strings.…

[21:11] <Geth> nqp/master: 6fad15e454 | Fix test description.…

[21:11] <Geth> nqp/master: 67b3e98c0d | [js] Make nqp::istype work on nqp::null_s().…

[21:11] <Geth> nqp/master: 261e7188de | Test nqp::istype on nqp::null_s.…

[21:11] <Geth> nqp/master: 0127c04f9a | [js] Make nqp::atkey(nqp::null, ...) and nqp::atpos(nqp::null, ...) return nqp::null.…

[21:11] <Geth> nqp/master: 7a2bdacdac | [js] Fix bug when binding to a variable with an expression that reference the variable.…

[21:11] <Geth> nqp/master: 9d29f76c82 | Regression test for a bug fixed on the js backend.…

[21:11] <Geth> nqp/master: review: https://github.com/perl6/nqp/compare/ef1aa3787b...9d29f76c82

[21:11] <dogbert17> m: grammar Grammar::Foo { rule TOP { 'z' | <unicode_escape> }; token unicode_escape { '\\u' :i <[0..9a..f]> ** 4 }}; my $res = Grammar::Foo.parse( '\u2603' ); # tests rt130637

[21:11] <camelia> rakudo-moar 483058: OUTPUT«(signal SEGV)»

[21:13] <dogbert17> Program received signal SIGSEGV, Segmentation fault.

[21:13] <dogbert17> 0xb7c73015 in nqp_nfa_run (tc=0x804c450, nfa=0x818c340, target=0x818adac, offset=3, total_fates_out=0xbfffd868) at src/6model/reprs/NFA.c:479

[21:14] <dogbert17> 479                 MVMint64 act = edge_info[i].act;

[21:19] <jnthn> .oO( That was a not f**king awesome run... )

[21:20] * jnthn wonders what i is

[21:20] <jnthn> Since that's probably the only thing that's liable to be out of bounds there

[21:21] <dogbert17> I see that there is a MVM_NFA_DEB env flag, might that help?

[21:23] <jnthn> May do so, yeah

[21:23] <jnthn> Though if it's a malformed NFA then we can detect that at the point we make it from the state list

[21:23] <jnthn> Rather than bounds-checking every time we're matching

[21:23] <jnthn> That'll probably also give us a better idea what we're making the NFA for when it goes wrong

[21:24] <jnthn> Though there aren't many candidates in that grammar tbh :)

[21:24] <jnthn> There's only one alternation :)

[21:24] <jnthn> Guess we can try to golf it down some

[21:25] <Geth> roast: 323d9342ab | (Elizabeth Mattijsen)++ | S02-types/range-iterator.t

[21:25] <Geth> roast: Add basic Range.iterator tests

[21:25] <Geth> roast: review: https://github.com/perl6/roast/commit/323d9342ab

[21:25] <dogbert17> does this gist tell you anything? https://gist.github.com/dogbert17/251983f9e43713545e1feacb0f65039e

[21:25] <jnthn> m: grammar Grammar::Foo { rule TOP { 'z' | <unicode_escape> }; token unicode_escape { '\\u' <[0..9a..f]> ** 4 }}; my $res = Grammar::Foo.parse( '\u2603' );

[21:25] <camelia> rakudo-moar 483058: ( no output )

[21:25] <jnthn> It's fine without the :i for example

[21:26] <Geth> rakudo/nom: 456092af7b | (Elizabeth Mattijsen)++ | t/spectest.data

[21:26] <Geth> rakudo/nom: Make sure we run the Range.iterator tests

[21:26] <Geth> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/456092af7b

[21:27] <Geth> rakudo/nom: 05738657f8 | (Elizabeth Mattijsen)++ | src/core/Range.pm

[21:27] <Geth> rakudo/nom: Fix problems in Range.iterator

[21:27] <Geth> rakudo/nom:

[21:27] <Geth> rakudo/nom: Specifically in push-all/sink-all in the generic iterator case.

[21:27] <Geth> rakudo/nom: Spotted in testing.

[21:27] <Geth> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/05738657f8

[21:27] <diakopter> speaking of NFA, last I checked/knew, the edge/node compiler was making verrrrrry inefficient NFAs, but every change I tried to make broke it... in other words a lot of extra edges had to be there for reasons I couldn't divine. has anyone looked at that in a couple years?

[21:28] <jnthn> diakopter: TimToady did, I think :)

[21:28] <jnthn> dogbert17: Well, we can see it matched \, u, 2, and 6, and then exploded :)

[21:28] <jnthn> And that bit is beyond the :i

[21:29] <jnthn> So it fits so far

[21:29] <jnthn> m: grammar Grammar::Foo { rule TOP { 'z' | <unicode_escape> }; token unicode_escape { :i <[0..9a..f]> ** 4 }}; my $res = Grammar::Foo.parse( '2603' );

[21:29] <camelia> rakudo-moar 483058: OUTPUT«(signal SEGV)»

[21:29] <jnthn> That gets rid of the \u part

[21:29] <diakopter> I mention this because it suddenly occurs to me another possibility for the symptoms I was seeing

[21:29] <dogbert17> cool

[21:29] * jnthn bbiab :)

[21:30] <diakopter> jnthn: did he find a bunch of improvements?

[21:30] <diakopter> TimToady: oy

[21:35] <lizmat> hmmm... maybe it's time to re-instate IO::CatPath and IO::CatHandle: https://github.com/rakudo/rakudo/commit/a28270f009e15baa04ce76e5

[21:38] <dogbert17> at least the SEGV is not something which was introduced recently. it fails on moar-2016.8.1 as well

[21:46] <lizmat> a thought: given that roast determines what is Perl 6, and Test.pm is pure perl 6 code, shouldn't Test.pm live in roast then ?

[21:47] <dogbert17> m: grammar Grammar::Foo { rule TOP { 'z' | <unicode_escape> }; token unicode_escape { :i <[0..9a..f]> ** 4 }}; my $res = Grammar::Foo.parse( 'abcd' );

[21:47] <camelia> rakudo-moar 057386: ( no output )

[21:50] <brokenchicken> lizmat, I'd think no. It's just implementation. Roast should have proper tests of Test.pm's routines IMO tho

[21:50] <lizmat> brokenchicken: I think those actually live in "make test"

[21:51] <lizmat> t/01-sanity

[21:51] <lizmat> brb

[21:55] <brokenchicken> yeah, though they're a bit rudimentary for something that everything in roast relies on

[21:55] <brokenchicken> the failure modes seem to be just tested by todo'ing a test

[21:56] <brokenchicken> maybe that's enough *shrug*

[21:56] <brokenchicken> lizmat, how would we distribute Test.pm if it were in roast?

[21:56] <lizmat> in t/spec/packages ?

[21:57] <lizmat> that's where the other Test:: modules live

[21:57] <lizmat> like the recent Test::Iterator additin

[21:57] <brokenchicken> I mean for users

[21:57] <lizmat> actually, initially I was thinking the other way around: moving those Test:: modules to lib

[21:57] <[Coke]> if I had another implementation, I wouldn't want to have to support all of Test.pm in order to run -any- tests.

[21:58] <brokenchicken> m: use Test::Util

[21:58] <camelia> rakudo-moar 057386: OUTPUT«===SORRY!===␤Could not find Test::Util at line 1 in:␤    /home/camelia/.perl6␤    /home/camelia/rakudo-m-inst-2/share/perl6/site␤    /home/camelia/rakudo-m-inst-2/share/perl6/vendor␤    /home/camelia/rakudo-m-inst-2/share/perl6␤    CompUnit::Re…»

[21:58] <lizmat> m: use lib 't/spec/packages'; use Test::Util

[21:58] <camelia> rakudo-moar 057386: OUTPUT«===SORRY!===␤Could not find Test::Util at line 1 in:␤    /home/camelia/t/spec/packages␤    /home/camelia/.perl6␤    /home/camelia/rakudo-m-inst-2/share/perl6/site␤    /home/camelia/rakudo-m-inst-2/share/perl6/vendor␤    /home/camelia/rakudo-m-i…»

[21:58] <lizmat> hmmm...

[22:02] <lizmat> [Coke]: so you would depend on rakudo's Test.pm ?

[22:05] <[Coke]> no, I'd roll my own so I didn't necessarily need to support all the internals that Test.pm was using.

[22:05] <brokenchicken> BTW, while we're on a related topic: lib/TAP.pm. Currently we ship and install it to users. But jnthn++ said it probably should be private for us to use in for spectest6 and user-facing version should be an ecosystem module. My view on that is yes, remove from core, but don't keep second copy in core; just have some make command fetch the ecosystem version for spectest6

[22:06] <[Coke]> or start with a copy and add stub functions for some of the test functions I couldn't support yet

[22:06] <[Coke]> brokenchicken: if we're going to fetch modules, perhaps also fetch Inline::Perl5 at the same time.

[22:06] <brokenchicken> +1

[22:06] <[Coke]> was always a PITA when doing stresstest by hand.

[22:12] <MasterDuke> bisectable6: grammar Grammar::Foo { rule TOP { 'z' | <unicode_escape> }; token unicode_escape { :i <[0..9a..f]> ** 4 }}; my $res = Grammar::Foo.parse( '2603' );

[22:12] <bisectable6> MasterDuke, On both starting points (old=2015.12 new=0573865) the exit code is 0, exit signal is 11 (SIGSEGV) and the output is identical as well

[22:12] <bisectable6> MasterDuke, Output on both points:

[22:36] <jnthn> Note that we use Test.pm also for the NativeCall tests and various others that don't live in roast

[23:04] <lizmat> m: use nqp; nqp::handle((my $a := 42), 'REDO', ($a := 42))   # finally managed to golf this one down

[23:04] <camelia> rakudo-moar 057386: OUTPUT«===SORRY!===␤Cannot reference undeclared local '__lowered_lex_1'␤»

[23:05] <lizmat> m: use nqp; nqp::handle((my $a = 42), 'REDO', ($a := 42))   # replaced first by assignment

[23:05] <camelia> rakudo-moar 057386: ( no output )

[23:06] <lizmat> m: use nqp; nqp::handle((my $a := 42), 'NEXT', $a)  # even shorter

[23:06] <camelia> rakudo-moar 057386: OUTPUT«===SORRY!===␤Cannot reference undeclared local '__lowered_lex_1'␤»

[23:09] * lizmat hopes that jnthn will be able to make sense of ^^^

[23:12] <jnthn> Well, Perl6::Optimizer makes various assumptions, one of which is that you're writing Perl 6. :)

[23:13] <jnthn> During code-gen, the $a (third arg) will get wrapped in a block

[23:13] <jnthn> The optimizer doesn't see this coming, 'cus you can't create such a situation with nqp:: ops

[23:13] <jnthn> And so it thinks it can get away with lexical => local lowering

[23:13] <jnthn> uh, *without

[23:13] <jnthn> I don't know quite how to patch it off-hand

[23:14] * jnthn hopes that this doesn't mean he's going to spend hours dealing with similar cases when he finally gets around to making Perl6::Optimizer do such lowers more aggressively...

[23:15] <jnthn> Hopefully we can teach it about this case

[23:15] <lizmat> jnthn: it would make map/for significantly faster afaik

[23:16] <lizmat> e.g. https://github.com/rakudo/rakudo/blob/nom/src/core/Any-iterable-methods.pm#L231

[23:17] <jnthn> *nod*

[23:17] <lizmat> ok, now that I have more clarity on the underlying issue, I may find some way around it  :-)

[23:17] <jnthn> Finding a way to make it not lower that lexical is probably the most expedient solution.

[23:17] <lizmat> but not tonight, will sleep some more on it

[23:18] <jnthn> We're blessed with ample resources to optimize CORE.setting by turning things into nqp:: ops, and precious few for making that not be needed. :)

[23:18] <lizmat> ?

[23:19] <lizmat> ah, ok, needed to read that aloud a few times  :-)

[23:19] <jnthn> :)

[23:19] <lizmat> a sign I should get some sleep

[23:19] <jnthn> lizmat++ # optimizing stuff

[23:19] <lizmat> so good night, #perl6-dev!

[23:19] <jnthn> 'night

[23:19] <brokenchicken> night

[23:20] <jnthn> (Also, a less tired me can probably figure out the way to patch Perl6::Optimizer, so check in with me tomorrow)

[23:25] <Geth> rakudo/nom: cfae23a567 | (Zoffix Znet)++ | src/core/IO/Handle.pm

[23:25] <Geth> rakudo/nom: Fix crash on IO::Handle.lines in subclasses

[23:25] <Geth> rakudo/nom:

[23:25] <Geth> rakudo/nom: A .lines fix this morning made a mistake when specifying the type

[23:25] <Geth> rakudo/nom: object to get $!PIO from. The $!handle.WHAT will not contain

[23:25] <Geth> rakudo/nom: $!PIO for subclasses of IO::Handle and so a crash will occur.

[23:25] <Geth> rakudo/nom:

[23:25] <Geth> rakudo/nom: [1] https://github.com/rakudo/rakudo/commit/ede01c24766def69e0740b5

[23:25] <Geth> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/cfae23a567

[23:27] <Geth> roast: fb58578110 | (Zoffix Znet)++ | S16-io/lines.t

[23:27] <Geth> roast: Test .lines does not crash on subclasses of IO::Handle

[23:27] <Geth> roast:

[23:27] <Geth> roast: Rakudo fix: https://github.com/rakudo/rakudo/commit/cfae23a567

[23:27] <Geth> roast: review: https://github.com/perl6/roast/commit/fb58578110

[23:28] <jnthn> brokenchicken++ # taking care of subclassability
