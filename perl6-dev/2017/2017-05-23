[00:14] <MasterDuke> timotimo: was that MVM_dump_backtrace output from that coerce_ni at all useful?

[00:17] <timotimo> it confirmed my hypothesis

[00:17] <timotimo> but we're now interested in the code that gens the code that runs there

[00:18] <MasterDuke> where is that code?

[00:19] <timotimo> i expect something in the QASTCompilerMAST is to blame

[00:20] <MasterDuke> oof, not the easiest stuff to grok

[00:21] <timotimo> yup

[05:20] <Geth> ¦ roast: 6e446c4d68 | usev6++ | S16-io/prompt.t

[05:20] <Geth> ¦ roast: [JVM] Fudge newly added test for no-arg prompt

[05:20] <Geth> ¦ roast: review: https://github.com/perl6/roast/commit/6e446c4d68

[06:20] <[Tux]> This is Rakudo version 2017.05-32-g379ef6f1d built on MoarVM version 2017.05-9-g37460c7a

[06:20] <[Tux]> csv-ip5xs        2.473

[06:20] <[Tux]> test            12.766

[06:20] <[Tux]> test-t           4.235 - 4.244

[06:20] <[Tux]> csv-parser      13.246

[07:32] <lizmat> Files=1194, Tests=58717, 212 wallclock secs (12.62 usr  4.90 sys + 1252.25 cusr 119.67 csys = 1389.44 CPU)

[08:41] <Geth> ¦ rakudo/nom: 1283599c9a | (Elizabeth Mattijsen)++ | CREDITS

[08:41] <Geth> ¦ rakudo/nom: Update my email address

[08:41] <Geth> ¦ rakudo/nom: review: https://github.com/rakudo/rakudo/commit/1283599c9a

[09:27] <Geth> ¦ nqp: ac7f21ab86 | (Jonathan Worthington)++ | 3 files

[09:27] <Geth> ¦ nqp: Implement line reading in steaming decoder on JVM.

[09:27] <Geth> ¦ nqp: review: https://github.com/perl6/nqp/commit/ac7f21ab86

[09:49] <Geth> ¦ nqp: 19fe0e62a0 | (Jonathan Worthington)++ | 3 files

[09:49] <Geth> ¦ nqp: Implement decoderbytesavailable on JVM.

[09:49] <Geth> ¦ nqp: review: https://github.com/perl6/nqp/commit/19fe0e62a0

[10:11] <Geth> ¦ nqp: feaefe66cf | (Jonathan Worthington)++ | 3 files

[10:11] <Geth> ¦ nqp: Implement decodertakebytes on JVM.

[10:11] <Geth> ¦ nqp:

[10:11] <Geth> ¦ nqp: Thus fully passing 05-decoder.t on JVM.

[10:11] <Geth> ¦ nqp: review: https://github.com/perl6/nqp/commit/feaefe66cf

[10:12] <Geth> ¦ nqp: 23a1a12aa9 | (Jonathan Worthington)++ | t/jvm/05-decoder.t

[10:12] <Geth> ¦ nqp: Correct test plan.

[10:12] <Geth> ¦ nqp: review: https://github.com/perl6/nqp/commit/23a1a12aa9

[10:42] <Geth> ¦ rakudo/refactor-socket-encoding: e58f591c01 | (Jonathan Worthington)++ | src/core/IO/Socket/INET.pm

[10:42] <Geth> ¦ rakudo/refactor-socket-encoding: Remove leftover from JVM workaround.

[10:42] <Geth> ¦ rakudo/refactor-socket-encoding: review: https://github.com/rakudo/rakudo/commit/e58f591c01

[10:43] <nine> Something wierd is going on with the MANIFEST detection in http://modules.perl6.org/todo/nine

[10:44] <nine> All those dists in fact have a MANIFEST and the todo even showed that about an hour ago. Except for Inline::Python which ironically was the first of these to even get a MANIFEST

[10:45] <jnthn> Phew, just 4 failing tests in IO-Socket-INET.t to go on JVM, but otherwise the other sync socket tests in that file and in other files seem to be passing.

[10:46] <Geth> ¦ nqp: d260917d59 | (Jonathan Worthington)++ | src/vm/jvm/runtime/org/perl6/nqp/sixmodel/reprs/DecoderInstance.java

[10:46] <Geth> ¦ nqp: Initialize decoded up front.

[10:46] <Geth> ¦ nqp:

[10:46] <Geth> ¦ nqp: We'll almost always end up with it, and it saves null checks (which

[10:46] <Geth> ¦ nqp: can be easily forgotten - and *were* forgotten - elsewhere).

[10:46] <Geth> ¦ nqp: review: https://github.com/perl6/nqp/commit/d260917d59

[10:59] <jnthn> lunch; bbiab

[11:56] * jnthn back

[12:32] <Geth> ¦ nqp: dbc1484c55 | (Jonathan Worthington)++ | 2 files

[12:32] <Geth> ¦ nqp: Correct an off-by-one in JVM streaming decoder.

[12:32] <Geth> ¦ nqp:

[12:32] <Geth> ¦ nqp: This caused us to fail to return the second-to-last char even when it

[12:32] <Geth> ¦ nqp: was clearly safe to do so.

[12:32] <Geth> ¦ nqp: review: https://github.com/perl6/nqp/commit/dbc1484c55

[12:33] <jnthn> Hurrah, with that the socket tests all pass on JVM too

[12:33] <nine> \o/

[12:34] <Zoffix> m: my @a = <a b c d e>; dd @a.pick(*-30)

[12:34] <camelia> rakudo-moar 128359: OUTPUT: «Coercion to UInt out of range. Is: -25, should be in 0..^Inf␤  in block <unit> at <tmp> line 1␤␤Actually thrown at:␤  in block <unit> at <tmp> line 1␤␤»

[12:34] <Zoffix> IMO that should just return an empty list; 'cause the whole point of using `*` is that I don't know what size my list is and I want to pick N-x items

[12:35] <jnthn> So in theory that's the socket re-work to not use libuv and to coordinate the decoding in Rakudo sorted out

[12:35] * Zoffix goes with .pick(*/3)

[12:35] <Zoffix> jnthn++ sweet

[12:36] <jnthn> In practice, I'd really like to do a spectest with the Moar/Rakudo branch on OSX before merging

[12:36] <jnthn> Should perhaps find a module that uses sockets to try out also

[12:38] <Zoffix> m: my @a = <a b c d e f g e h>; @a[(^*).pick: */3] .= uc; dd @a

[12:38] <camelia> rakudo-moar 128359: OUTPUT: «Cannot resolve caller pick(Range: WhateverCode); none of these signatures match:␤    (Range $: *%_)␤    (Range $: Whatever, *%_)␤    (Range $: Cool $todo, *%_)␤  in block <unit> at <tmp> line 1␤␤»

[12:38] <Zoffix> :(

[12:38] <Zoffix> m: my @a = <a b c d e f g e h>; @a[(^*).list.pick: */3] .= uc; dd @a

[12:38] <camelia> rakudo-moar 128359: OUTPUT: «Array @a = ["a", "b", Any, "d", "E G C", "f", Any, "e", "h"]␤»

[12:38] <Zoffix> what are those Anys? :/

[12:39] <Zoffix> Ah... I guess this use is not supported 'cause I see it joined them all up in 1 string

[12:39] <jnthn> I think you're maybe expecting more * currying than is happening

[12:40] <jnthn> Or not

[12:40] * moritz didn't even know of .pick(&callable)

[12:40] <Zoffix> I'm attempting to change 1/3rd random elements in the array to the value of their .method call

[12:40] <jnthn> I'm confused what you wanted so it's perhaps better written another way :P

[12:41] <Zoffix> Or more specifically: I have an array of IO::Paths, I want a part of them to be IO::Handles, so I want to call .open on them (and put the handle where IO::Path used to be, in the array)

[12:43] <Zoffix> m: my @a = <a b c d e f g e h>; @a[$_] .= uc for @a.keys.pick: */3; dd @a

[12:43] <camelia> rakudo-moar 128359: OUTPUT: «Array @a = ["A", "b", "c", "d", "E", "F", "g", "e", "h"]␤»

[12:43] <Zoffix> that does the job, I guess

[12:43] <jnthn> Yeah, I was just realizing, the .= uc was not being distributed :)

[12:44] <[Coke]> Having just sent out the RFP for this round of grants, I wonder how Zoffix++ and samcv++ are doing on the existing ones.

[12:47] <cono> jnthn: did you have a chance to look into my PR to your branch? :)

[12:47] <jnthn> cono: Not yet, was busily fighting JVM/NIO so far today

[12:48] <jnthn> Though I think I've done with that :)

[12:48] <jnthn> Well yay, LWP::Simple tests are all happy with my changes

[12:51] * jnthn would still kinda like an OSX test run...

[12:52] * [Coke] can try that.

[12:53] <[Coke]> jnthn: what/where/huh?

[12:53] <cono> moarvm branch: sync-socket-no-uv    rakudo: refactor-socket-encoding

[12:54] <Zoffix> [Coke]: I have all IO routines in an excel file marking which I code-reviewed, documented (or checked documention is present and valid), and tested (or checked the tests are present and sufficient). The current number of completed routines is 84%. I'm currently working on IO::CatHandle and hoping to finish it before the long weekend. After that, I need to finish the remaining routines and The Definitive IO

[12:54] <Zoffix> Guide. Then I'll need to regenerate data on perl6.wtf (and if my spreadsheet is accurate, all of the routines would then have coverage). I'm hoping to complete that plus the final grant report by end of the upcoming Monday, May 29th. Looking at the completeness criteria in the original grant prosal, there is item "the IO Action Plan document and it will be fully implemented". However, there are two items

[12:54] <Zoffix> that aren't implemented (yet) that I'm hoping is OK for completeness of the grant: (1) Handle's closed status: the Action Plan proposed a role mixin, but it was found to be a poor solution, so the alernative is to make MoarVM do better errors for reads on non-IO stuff (on Nil). (2) Change nqp::stat to accept more than 1 stat info bit to fetch, so that we get some perf improvement in methods like .rwx that

[12:54] <Zoffix> do 5 calls instead of 1. The reason both of those aren't yet implemented is because I don't know moarvm that well. So I *will* implement those things at some point in the future, but I just feel like me trying to learn and rush these to complete the grant might not produce the greatest of work.

[12:55] <Zoffix> So in summation, if the last two points are OK, as far as grant completion goes, then I'll have my final report by end of Monday, May, 29th (EST) and will be done with the grant.

[12:55] <[Coke]> cono, jnthn, building now.

[12:56] <Zoffix> * long weekend (I mean this weekend, including Monday; all my weekends this year have been long)

[12:56] <[Coke]> jnthn: MoarVM op 'asyncwritestr' is unknown as a core or extension op

[12:57] <[Coke]> on that rakudo branch, I rm -rf'd ./install and ran: perl Configure.pl --gen-moar=sync-socket-no-uv --gen-nqp

[12:58] <jnthn> Try --gen-nqp=master

[12:59] <[Coke]> You asked me to build sync-socket-no-uv, but 2017.04-78-g1aa523ed is not new enough to satisfy version 2017.05

[12:59] <[Coke]> let me try this by hand, I guess.

[13:00] <jnthn> arrrgh

[13:00] <jnthn> Yeah :/

[13:00] <moritz> merge master into sync-socket-no-uv?

[13:00] <jnthn> Urgh

[13:01] <jnthn> Then the history looks a mess

[13:01] <jnthn> But yeah, [Coke]++ could do that locally :)

[13:01] <[Coke]> I can do this, just requires one more cup of coffee.

[13:02] <jnthn> I guess actually I could just merge the MoarVM branch :)

[13:03] <jnthn> Because we have all of this _VERSION stuff to keep anyone doing normal builds from seeing it anyway :)

[13:03] * jnthn does that

[13:03] <cono> you can rebase to new master

[13:03] <cono> it will clean up history

[13:03] <jnthn> I could but if others have it checked out that won't go well ;)

[13:04] <jnthn> (For them :))

[13:04] <jnthn> I've done it now anyway

[13:04] <jnthn> (merged the MoarVM branch

[13:04] <jnthn> )

[13:04] <cono> np, I can deal with it :)

[13:04] <jnthn> [Coke]: So now what to test is MoarVM master/NQP master/Rakudo refactor-socket-encoding

[13:08] * [Coke] returns from coffee to find easy instructions.

[13:09] <[Coke]> Use of uninitialized value $moar_version_output in pattern match (m//) at tools/lib/NQP/Configure.pm line 300.

[13:09] <[Coke]> (it's going fine, just saw that early on)

[13:11] <jnthn> Odd...though miles away from anything I've touched...

[13:12] <[Coke]> make test is fine, firing up stresstest.

[13:14] <jnthn> MasterDuke++ # adding TEST_JOBS support to nqp's make test

[13:14] <jnthn> They run in like 2s here now :)

[13:15] <Zoffix> my $moar_version_output = qx{ $moar_exe --version };

[13:15] <Zoffix> Looks like moar --version is busted?

[13:15] <Zoffix> (to produce that varning)

[13:15] <jnthn> weird

[13:15] <jnthn> moar --version

[13:15] <jnthn> This is MoarVM version 2017.05-20-g9f9a2a0 built with JIT support

[13:15] <jnthn> On HEAD

[13:15] <Zoffix> or the logic fetching it

[13:15] <nine> Hmm...weiss ned, ob I mi ja sagen trau. Im Endspurt bei der Umstellung auf CMS 3000 warn wir sehr nachlaessig mit Tests schreiben.

[13:15] <Zoffix> https://github.com/perl6/nqp/blob/master/tools/lib/NQP/Configure.pm#L283-L286

[13:16] <nine> Is there a wrong window contest as well?

[13:16] <Zoffix> Ya! Ya! Shprehen ze dauch!

[13:16] <jnthn> Nein!

[13:17] <jnthn> [Coke]: I expect some test fails 'cus that branch is behind master; main thing I'm looking for is if any socket ones fail :)

[13:21] <[Coke]> jnthn: https://gist.github.com/coke/11cf1d9ae57957e227e9cba720135038

[13:22] <jnthn> yah, that's exact same set as I have on Linux (and all due to fixes in nom that my branch doesn't have)

[13:22] <jnthn> Excellent. :D

[13:22] <jnthn> [Coke]++

[13:26] <Geth> ¦ nqp: 6f0b5b46a0 | (Jonathan Worthington)++ | tools/build/MOAR_REVISION

[13:26] <Geth> ¦ nqp: Bump MOAR_REVISION.

[13:26] <Geth> ¦ nqp:

[13:26] <Geth> ¦ nqp: Brings socket changes to no longer use libuv.

[13:26] <Geth> ¦ nqp: review: https://github.com/perl6/nqp/commit/6f0b5b46a0

[13:26] <Geth> ¦ nqp: version bump brought these changes: https://github.com/MoarVM/MoarVM/compare/2017.05...2017.05-20-g9f9a2a0

[13:27] <cono> jnthn: I have this issue when try to compile MoarVM: ./libmoar.so: undefined reference to `MVM_coerce_s_n'

[13:27] <jnthn> cono: Did you re-Configure?

[13:27] <jnthn> (That was added in a new file, so maybe you've got an outdated Makefile)

[13:27] <cono> nah

[13:27] <cono> thanks

[13:28] <Geth> ¦ rakudo/nom: 13 commits pushed by (Jonathan Worthington)++

[13:28] <Geth> ¦ rakudo/nom: review: https://github.com/rakudo/rakudo/compare/1283599c9a...8ee383e374

[13:30] <Geth> ¦ rakudo/nom: 6f202fbe9b | (Jonathan Worthington)++ | tools/build/NQP_REVISION

[13:30] <Geth> ¦ rakudo/nom: Bump NQP_REVISION.

[13:30] <Geth> ¦ rakudo/nom:

[13:30] <Geth> ¦ rakudo/nom: * Gets complete JVM support for the streaming decode API, which gets

[13:30] <Geth> ¦ rakudo/nom:   synchronous sockets back to passing all of their tests after the

[13:30] <Geth> ¦ rakudo/nom:   recent refactors.

[13:30] <Geth> ¦ rakudo/nom: * Brings in MoarVM changes that mean libuv is no longer used for

[13:30] <Geth> ¦ rakudo/nom:   synchronous sockets. This in turn means that the exceptions and

[13:31] <Geth> ¦ rakudo/nom:   crashes when trying to use handles across different threads are

[13:31] <Geth> ¦ rakudo/nom:   now cleared up (for example, accepting a handle on one thread and

[13:31] <Geth> ¦ rakudo/nom:   handing it off to another to communicate).

[13:31] <Geth> ¦ rakudo/nom: review: https://github.com/rakudo/rakudo/commit/6f202fbe9b

[13:31] <Geth> ¦ rakudo/nom: version bump brought these changes: https://github.com/perl6/nqp/compare/2017.05...2017.05-23-g6f0b5b4

[13:32] <brrt> jnthn++

[13:33] <jnthn> Now it "just" needs doing for ordinary file handles

[13:33] <jnthn> And procs

[13:33] <jnthn> :P

[13:36] <[Coke]> jnthn++

[13:42] <cono> jnthn: why you have closed my pr ? :( if I push changes it just updates it

[13:43] <cono> anyway, opened new one: https://github.com/MoarVM/MoarVM/pull/602

[13:43] <cono> reworked to simple int/SOCKET logic

[13:43] <Zoffix> \o/

[13:43] <jnthn> cono: I didn't close it?

[13:43] <jnthn> I left review on it

[13:44] <jnthn> Or at least, that's all I thought I did

[13:44] <jnthn> Hm, I can't find an RT for the sockets/threads thing

[13:44] <lizmat> jnthn: looked closed to me

[13:47] <cono> but new IO-Socket-INET.t still segfaults to me :( zsh: segmentation fault  perl6 ./IO-Socket-INET.t

[13:47] <cono> after 9 successfull tests :D

[13:47] <jnthn> huh, how'd I end closing it...d'oh

[13:47] <jnthn> It even said I did it but I've no memory of doing so ;)

[13:48] <Zoffix> .oO( Multiple PR Disorder... )

[13:48] <cono> :)

[13:49] <nine> Mei Anmerkung war eigentlich: prepare, execute, fetchrow_hashref, fetchrow_hashref, fetchrow_hashref, ...

[13:49] <Zoffix> heh

[13:49] * nine thinks he should just go home and stay away from any keyboards for the day

[13:50] <Zoffix> war? prepare? execute?

[13:50] * Zoffix moves further away

[13:50] <Zoffix> :)

[13:52] <brrt> lol

[13:53] <jnthn> star: https://gist.github.com/jnthn/6f6168ad424a95624b39fe5b7dd007e1

[13:53] <camelia> star-m 2016.10: OUTPUT: «(timeout)1..5␤»

[13:53] <jnthn> m: https://gist.github.com/jnthn/6f6168ad424a95624b39fe5b7dd007e1

[13:54] <camelia> rakudo-moar 6f202f: OUTPUT: «(timeout)1..5␤»

[13:55] <jnthn> huh

[13:55] * Zoffix forcees IO::CatHandle being slower than IO::ArgFiles :|

[13:55] <jnthn> m: say IO::Socket::INET.new

[13:55] <camelia> rakudo-moar 6f202f: OUTPUT: «IO::Socket::INET is disallowed in restricted setting␤  in sub restricted at src/RESTRICTED.setting line 1␤  in method new at src/RESTRICTED.setting line 32␤  in block <unit> at <tmp> line 1␤␤»

[13:55] <jnthn> arse

[13:55] <jnthn> c: HEAD say IO::Socket::INET.new

[13:55] <committable6> jnthn, ¦HEAD(1283599): «IO::Socket::INET is disallowed in restricted setting␤  in sub restricted at src/RESTRICTED.setting line 1␤  in method new at src/RESTRICTED.setting line 32␤  in block <unit> at /tmp/E7Jt0KzBoQ line 1␤ «exit code = 1»»

[13:55] <Zoffix> heh

[13:55] <jnthn> So many bots so useless for checking my test :P

[13:55] <Zoffix> :D

[13:56] <jnthn> Do I really have to build an older revision again? :/

[13:56] <Zoffix> I know there's... a secret way to bisect without restricted mode

[13:56] <Zoffix> Dunno about executing a particular commit... MasterDuke AlexDaniela?

[13:56] <Zoffix> Dunno about executing a particular commit... MasterDuke AlexDaniel?

[13:57] <Zoffix> Oh!

[13:57] <Zoffix> specify same start and end commits

[13:57] <Zoffix> 1 sec

[13:58] <Zoffix> Oh, I think the secret way is disabled now. I'm getting no response.

[13:58] <jnthn> :(

[13:59] * jnthn builds 2017.05

[14:02] <jnthn> yup, it fails there

[14:03] <Geth> ¦ roast: a5a46acfd4 | (Jonathan Worthington)++ | S32-io/socket-accept-and-working-threads.t

[14:03] <Geth> ¦ roast: Cover accept on one thread and recv on another.

[14:03] <Geth> ¦ roast:

[14:03] <Geth> ¦ roast: Which didn't work prior to the latest fixes.

[14:03] <Geth> ¦ roast: review: https://github.com/perl6/roast/commit/a5a46acfd4

[14:11] <Zoffix> m: class Foo { method x ($ = 42) {} }; class Bar { has $.foo = Foo.new; method x(|c) { $!foo.x: |c } }; my $m = Bar.new; for ^500_000 { $ = $m.x }; say now - INIT now

[14:11] <camelia> rakudo-moar 6f202f: OUTPUT: «0.99089139␤»

[14:11] <Zoffix> m: class Foo { method x ($ = 42) {} }; class Bar { has $.foo = Foo.new; method x() { $!foo.x } }; my $m = Bar.new; for ^500_000 { $ = $m.x }; say now - INIT now

[14:11] <camelia> rakudo-moar 6f202f: OUTPUT: «0.4294206␤»

[14:11] <Zoffix> ^ I'm gonna NOT support custom IO::Handles that take non-standard args in IO::CatHandle. It's just too expensive to shuttle "rest of args" around to all the methods

[14:18] <Zoffix> m: await start get

[14:18] <camelia> rakudo-moar 6f202f: ( no output )

[14:18] <Zoffix> \o/

[14:18] <Zoffix> jnthn++

[14:18] <Zoffix> Oh wait, there's no socket involved there...

[14:18] <Zoffix> m: await start get

[14:18] <camelia> rakudo-moar 6f202f: ( no output )

[14:18] <Zoffix> m: await start get

[14:18] <camelia> rakudo-moar 6f202f: ( no output )

[14:19] <Zoffix> m: await start get

[14:19] <camelia> rakudo-moar 6f202f: ( no output )

[14:19] <Zoffix> vOv works :D

[14:19] <jnthn> Maybe it's something to do with the bot

[14:19] <jnthn> $ perl6-m -e 'await start get'

[14:19] <jnthn> Tried to get the result of a broken Promise

[14:19] <jnthn> in block <unit> at -e line 1

[14:19] <jnthn> Original exception:

[14:19] <jnthn> Tried to read() from an IO handle outside its originating thread

[14:19] <Zoffix> Ah oK :)

[14:19] <jnthn> Yeah, I'm about to start on IO::Handle next I *think*

[14:20] <lizmat> .tell masak looks like Mixy semantics on (<) and (<=) are tricky, e.g. would (a => -1).Mix (<) ().Mix be True or False?

[14:20] <yoleaux> lizmat: I'll pass your message to masak.

[14:22] <jnthn> Hm, IO::ArgFiles inherits from IO::Handle but seems not to use any of its state?

[14:22] <lizmat> .tell could be False because key "a" is missing on right hand side Mix, could be True if missing keys are considered to have value 0

[14:22] <yoleaux> lizmat: I'll pass your message to could.

[14:22] <lizmat> .tell masak could be False because key "a" is missing on right hand side Mix, could be True if missing keys are considered to have value 0

[14:22] <yoleaux> lizmat: I'll pass your message to masak.

[14:23] <jnthn> Zoffix: Why does IO::ArgFiles inherit from IO::Handle?

[14:24] <Zoffix> jnthn: in my design? IO::ArgFiles is IO::CatHandle (for backwards compatibility). IO::CatHandle is IO::Handle because it can be basically used anywhere IO::Handle can be used. ATM only write methods aren't defined as I'm unsure what they should do

[14:25] <jnthn> And tell and seek and native-descriptor...

[14:25] <Zoffix> .tell and .seek do it on currently active handle

[14:25] <yoleaux> Zoffix: I'll pass your message to and.

[14:25] <Zoffix> stupid bot

[14:25] <Zoffix> and native descriptor too

[14:25] <jnthn> Zoffix: In your local changes?

[14:26] <Zoffix> jnthn: in the finished product, they would yeah. I'm still hacking on it

[14:26] <jnthn> OK

[14:26] <jnthn> It's just that IO::Handle is chock full of stuff that works against $!PIO

[14:26] <jnthn> And then absolutely none of it is used in ArgFiles

[14:26] <Zoffix> each, but all the methods are the same

[14:26] <Zoffix> s/each/yeah/;

[14:27] <jnthn> This is good in so far as I can refactor IO::Handle without hurting anything

[14:27] <jnthn> Uh, anything in ArgFiles

[14:27] <jnthn> It just looks a tad odd

[14:27] <jnthn> Almost as if IO::Handle wanted to be a role or something

[14:28] <lizmat> .oO( I think I can hear Zoffix starting to scream now )

[14:28] <jnthn> :)

[14:28] <jnthn> Mostly I'm just scoping out the likely impact of the changes I'm about to do :)

[14:29] <jnthn> It looks very much like the two things that subclass IO::Handle aren't messing with its guts

[14:30] <Zoffix> more or less yeah. Like Pipe uses $!PIO, but I'm guessing it stays

[14:30] <jnthn> So in theory, if nothing *else* pokes into IO::Handle, this shouldn't be too bad

[14:30] <jnthn> Yes

[14:30] <jnthn> What's going to happen is:

[14:30] <jnthn> IO::Handle will gain a Decoder instance

[14:31] <jnthn> We'll read bytes from the VM and shove them into it

[14:31] <jnthn> Then all char I/O will pull from the decoder

[14:32] <jnthn> The end result being that all I/O at VM level will be binary

[14:32] <Zoffix> Will that make stuff slower?

[14:32] <jnthn> Greatly simplifying the move away from libuv, and enabling us to add userspace encodings in the future

[14:32] <jnthn> Maybe yes in the immediate, but not automatically

[14:32] <jnthn> At the moment we have to do a mutex acquisition every single time we call down to the VM I/O layer

[14:32] <Zoffix> OK.

[14:33] <jnthn> The Decoder does a far cheaper check to make sure it's not being abused.

[14:33] <jnthn> And if we're reading a line at a time, then we'll most of the time only need to touch the decoder

[14:33] <jnthn> Not the handle

[14:34] <jnthn> So input I think should either break even or come out faster

[14:34] <Zoffix> Sweet

[14:35] <jnthn> Output - we need to call encode and then pass stuff on VM-wards

[14:35] <jnthn> I worry a tad more about this performance wise

[14:36] <jnthn> We could of course add buffering and batch it if needed

[14:37] <jnthn> (for files, not for consoles)

[14:39] <jnthn> Anyways, making a branch, digging in :)

[14:40] <Zoffix> \o/

[14:44] <cono> jnthn: If I push bump of tools/build/MOAR_REVISION, would it be possible to merge this PR in the future w/o this file ?

[14:45] <jnthn> cono: If it's not in the PR then somebody will have to do it manually before they merge it anyway

[14:45] <jnthn> Since the op doesn't exist in an earlier version of MoarVM

[14:46] <cono> ah, looks like build with master got a success

[14:46] <jnthn> Oh, the PR builds against MoarVM master?

[14:47] <cono> it does 3 builds: https://travis-ci.org/perl6/nqp/builds/235231650?utm_source=github_status&utm_medium=notification

[14:47] <jnthn> oh, right

[14:47] <jnthn> Yeah

[14:47] <jnthn> So MOAR_REVISION is needed for the --gen-moar one to pass

[14:47] <cono> yeah, but it will be complicated to merge this PR afterwards

[14:48] <cono> to omit changes to MOAR_REVISION

[14:48] <jnthn> Why woulod we need to do that?

[14:48] <jnthn> *would

[14:48] <jnthn> The MOAR_REVISION change is a required part of the PR

[14:48] <jnthn> Without that we can't merge it without manual intervention

[14:48] <Zoffix> cono: MOAR_REVISION tells it which version of MoarVM to build. So your PR needs a newer version, hence you'd include the version bump in your PR

[14:49] <Zoffix> and the content of that file is just `git describe` in MoarVM's repo for the version that you need

[14:50] <cono> I'm a bit confused, so is it fine if I put particular revision? I thought only tags or branches should be placed there

[14:50] <jnthn> No, a `git describe` output is fine in there

[14:50] <jnthn> It's only when we cut a release that it should be a tag

[14:50] <jnthn> But between releases it's fine

[14:51] <cono> in this case you should accept PRs in proper order to not spoil MOAR_REVISION

[14:52] <jnthn> Or we have to manually merge. In reality, it's only a small percentage of PRs that need to do version bumps so it's not really a problem.

[14:54] <Zoffix> There probably will be a merge conflict 'cause there was a bump https://github.com/perl6/nqp/commit/6f0b5b46a01eae4899e1e9b6b361fe8d73bba5a8

[14:54] <Zoffix> ^_^

[14:55] <Zoffix> oh cool, github lets you resolve them on the web now

[14:55] <cono> yea :)

[14:55] <cono> just tried :)

[14:55] <cono> k, travis run on the go

[14:59] <Zoffix> cono: I sent you an invite to perl6 github org; that gives you a commit bit to most of perl6/ repos, include perl6/npq. If you find yourself interested in rakudo/rakudo commit bit, it's a bit more involved as you need to sign the CLA ( details https://github.com/rakudo/rakudo/blob/nom/CONTRIBUTING.md#the-contribution-process ) and for MoarVM... I don't know the process :)

[15:01] <cono> thanks will read :)

[15:08] <Geth> ¦ rakudo/refactor-handle-encoding: fba01e38d8 | (Jonathan Worthington)++ | src/core/IO/Handle.pm

[15:08] <Geth> ¦ rakudo/refactor-handle-encoding: Simplify some forms of print/put/say.

[15:08] <Geth> ¦ rakudo/refactor-handle-encoding:

[15:08] <Geth> ¦ rakudo/refactor-handle-encoding: These cases all do some computation (evaluating a format or looping)

[15:08] <Geth> ¦ rakudo/refactor-handle-encoding: to produce the string to output. Also have various forms produce a

[15:08] <Geth> ¦ rakudo/refactor-handle-encoding: single concatenated string rather than making multiple calls down to

[15:08] <Geth> ¦ rakudo/refactor-handle-encoding: the I/O layer. This will avoid multiple calls to the encoder.

[15:08] <Geth> ¦ rakudo/refactor-handle-encoding: review: https://github.com/rakudo/rakudo/commit/fba01e38d8

[15:18] <Zoffix> "Stage parse      : 184.415" sheesh, this box is fun :|

[15:18] <jnthn> Ouch

[15:18] <Zoffix> 32-bit

[15:19] <Geth> ¦ rakudo/refactor-handle-encoding: b1a3f118ea | (Jonathan Worthington)++ | src/core/IO/Handle.pm

[15:19] <Geth> ¦ rakudo/refactor-handle-encoding: Eliminate nqp::printfh use in IO::Handle.

[15:19] <Geth> ¦ rakudo/refactor-handle-encoding:

[15:19] <Geth> ¦ rakudo/refactor-handle-encoding: It goes away in favor of explicit calls to .encode and then calling

[15:19] <Geth> ¦ rakudo/refactor-handle-encoding: nqp::writefh. This is, without further optimization effort, probably

[15:19] <Geth> ¦ rakudo/refactor-handle-encoding: a slowdown, having glanced Str.encode. It's not enough to make any

[15:19] <Geth> ¦ rakudo/refactor-handle-encoding: difference to spectest time, however, so it's likely not all that

[15:19] <Geth> ¦ rakudo/refactor-handle-encoding: dramatic. This does regress one spectest, which seems to be trying

[15:19] <Geth> ¦ rakudo/refactor-handle-encoding: to do string I/O with the encoding 'bin'.

[15:19] <Geth> ¦ rakudo/refactor-handle-encoding: review: https://github.com/rakudo/rakudo/commit/b1a3f118ea

[15:20] <jnthn> my $fh = open PATH, :rw, :bin, :enc<ASCII>;

[15:20] <jnthn> That somehow ends up with $!encoding containing bin

[15:21] <lizmat> feels to me that should be an error

[15:21] <Geth> ¦ rakudo/newer-cat-handle: 1b8535ef4c | (Zoffix Znet)++ | src/core/IO/CatHandle.pm

[15:21] <Geth> ¦ rakudo/newer-cat-handle: Remove unneeded code

[15:21] <Geth> ¦ rakudo/newer-cat-handle: review: https://github.com/rakudo/rakudo/commit/1b8535ef4c

[15:21] <Geth> ¦ rakudo/newer-cat-handle: 8b2133cc6d | (Zoffix Znet)++ | 3 files

[15:21] <Geth> ¦ rakudo/newer-cat-handle: Implement IO::CatHandle.lines

[15:21] <Geth> ¦ rakudo/newer-cat-handle:

[15:21] <Geth> ¦ rakudo/newer-cat-handle: and fix all the compilation errors

[15:21] <Geth> ¦ rakudo/newer-cat-handle: review: https://github.com/rakudo/rakudo/commit/8b2133cc6d

[15:22] <Geth> ¦ roast/newer-cat-handle: fe84c4ac4f | (Zoffix Znet)++ | S32-io/io-cathandle.t

[15:22] <Geth> ¦ roast/newer-cat-handle: Write IO::CatHandle.lines tests

[15:22] <Geth> ¦ roast/newer-cat-handle: review: https://github.com/perl6/roast/commit/fe84c4ac4f

[15:22] <jnthn> Should you be allowed to .print/.put/.say if you opened with :bin?

[15:22] <Zoffix> IMO no

[15:22] <jnthn> The only thing I can at present see that is actually impacted by :bin is the default kind of Supply you get when doing .Supply on the handle

[15:23] <Zoffix> " jnthn │ That somehow ends up with $!encoding containing bin"

[15:23] <Zoffix> jnthn: that's because opening in `bin` mode sets .encoding to 'bin'

[15:23] <Zoffix> Or changing .encoding attribute to 'bin' puts the handle in binary mode.

[15:24] <Zoffix> and :bin wins over :enc arg

[15:24] <jnthn> Right

[15:24] <jnthn> With my latest changes we now end up calling $str.encode('bin') as a result :)

[15:24] <jnthn> Which blows up :)

[15:24] <Zoffix> heh

[15:24] <jnthn> Note that in the entire spectest suite we do this in precisely *one* place

[15:24] <jnthn> And it's incidental

[15:25] <jnthn> Rather than the subject of the test

[15:25] <Zoffix> That .encoding is set to 'bin'?

[15:25] <jnthn> The test is S32-io/seek.t

[15:25] <jnthn> It uses .print once at the start of the test

[15:25] <jnthn> To put some stuff in the file

[15:25] <jnthn> All other stuff it does is .read/.seek/.tell

[15:26] <jnthn> Part of the reason I'm asking this is because it also impacts the changes to *input*

[15:27] <Zoffix> That's just an error in the test file

[15:27] <jnthn> We support mixed mode input/output

[15:27] <jnthn> That is to say, you can open a file as :enc<ascii> for example

[15:27] <jnthn> And .get

[15:27] <jnthn> But it's also possible to .read

[15:27] <Zoffix> Yeah

[15:27] <jnthn> This is really "fun"

[15:28] <jnthn> Because we have to feed the bytes into the streaming decoder

[15:28] <jnthn> And obtain them from it

[15:28] <jnthn> And it needs to keep track of how much it ate

[15:28] <jnthn> So it can give the right bytes back

[15:28] <jnthn> Which is a bit of bookkeeping

[15:28] <Zoffix> IMO it shouldn't be possible to also .read. You want binary stuff, put the handle in binary mode.

[15:28] <jnthn> Well, that case isn't the problem

[15:29] <jnthn> We already support it

[15:29] <jnthn> If you don't know enough about normalization buffers you can screw yourself but, well, tough

[15:29] <jnthn> That *is* a problem

[15:29] <jnthn> Is that if we let .get/.lines work in :bin mode too then we have to shove everything through the decode API

[15:29] <jnthn> Even though we never actually decode

[15:30] <ugexe> it can be "useful" for things like http 1.*, where you know the encoding of the first chunk (headers) but not the following (body / chunked body)

[15:30] <jnthn> Which means a bunch of memory copies

[15:30] <jnthn> ugexe: Yes, and that case is safe because newlines are normalization terminators, so you won't end up in bother :)

[15:31] <jnthn> I'm not proposing to change the ability to read/write on handles that are opened without :bin, anyways

[15:31] <jnthn> I'm asking whether we should allow any kind of char-level I/O when you *did* open with :bin

[15:31] <jnthn> Because if the answer is "no" then we can have much faster binary I/O

[15:31] <jnthn> Well, input at least

[15:32] <jnthn> Output doesn't care :)

[15:33] <Geth> ¦ roast: a0c5ef2cfc | (Zoffix Znet)++ | S32-io/seek.t

[15:33] <Geth> ¦ roast: Fix broken seek test setup

[15:33] <Geth> ¦ roast:

[15:33] <Geth> ¦ roast: The setup tries to open the file in both binary and text mode and then

[15:33] <Geth> ¦ roast: .print()s test data to it.

[15:33] <Geth> ¦ roast:

[15:33] <Geth> ¦ roast: Fix by using the Test::Util helper to create the test file. This test

[15:33] <Geth> ¦ roast: file is not part of 6.c-errata

[15:33] <Geth> ¦ roast: review: https://github.com/perl6/roast/commit/a0c5ef2cfc

[15:33] <Zoffix> jnthn: ^ that should fix the fallout you mentioned

[15:33] * jnthn spectests with that :)

[15:33] <jnthn> Zoffix++

[15:34] <jnthn> My feeling is that :bin should set a boolean

[15:34] <jnthn> Not set $!encoding

[15:34] <jnthn> Because we can test a boolean quickly

[15:35] <Geth> ¦ rakudo/nom: 0cb4df4422 | (Elizabeth Mattijsen)++ | src/core/set_operators.pm

[15:35] <Geth> ¦ rakudo/nom: Make Map (<=) Map about 15x faster

[15:35] <Geth> ¦ rakudo/nom:

[15:35] <Geth> ¦ rakudo/nom: Based on a 25/26 element hash

[15:35] <Geth> ¦ rakudo/nom: review: https://github.com/rakudo/rakudo/commit/0cb4df4422

[15:35] <jnthn> To say "no, you're in binary mode" if you try to do stuff you shouldn't on a binary handle

[15:35] <jnthn> Rather than having to do iseq_s($!encoding, 'bin')

[15:36] <jnthn> spectest clean again

[15:36] <Zoffix> \o/

[15:40] <jnthn> Haivng found we only broke one spectest (now fixed) if we did print/say/put on a :bin file, just thrown in a check if we do get/lines/words/getc/readchars on a bin handle

[15:40] <jnthn> To have some data on taht

[15:40] <jnthn> *that

[15:42] <jnthn> No failures

[15:44] <jnthn> So it looks like we're clear to rule that on a :bin handle you can only read/write

[15:44] <Zoffix> and .spurt

[15:45] <Zoffix> and .slurp and .Slupply

[15:45] <jnthn> Why?

[15:45] <Zoffix> They support bin modes

[15:46] <jnthn> Oh

[15:46] <jnthn> You were saying other things that should be allowed :)

[15:46] <Zoffix> Yeah :)

[15:46] <jnthn> Yeah, I wasn't even considering the ones that are already clearly defiend as working on both by virtue of a flag :)

[15:46] <jnthn> They of course should be :)

[15:46] <Geth> ¦ rakudo/nom: f6f54dcfe6 | (Elizabeth Mattijsen)++ | src/core/set_operators.pm

[15:46] <Geth> ¦ rakudo/nom: Make Map (<) Map about 15x faster

[15:46] <Geth> ¦ rakudo/nom:

[15:46] <Geth> ¦ rakudo/nom: Based on a 25/26 element hash

[15:46] <Geth> ¦ rakudo/nom: review: https://github.com/rakudo/rakudo/commit/f6f54dcfe6

[15:47] <jnthn> Alrighty, then I'll probably go that way

[15:48] <jnthn> It occurs to me that nqp::isconcrete($!decoder) is also another way to detect non-binary

[15:48] <jnthn> (Where $!decoder will soon be added, and will hold the decoder)

[15:51] <jnthn> Figure it's probably time to go and make some dinner, so will carry on with this tomorrow :)

[16:03] <Zoffix> Looks like out of everyone committing today, I'm having the most unproductive time :) Having chasing compilation errors for the past hour :}

[16:04] <Zoffix> ZofBot: I feel sad now

[16:04] <ZofBot> Zoffix, jib" file is determined as follows: <prefix>-<package-name>-<version>-<authority>

[16:07] <lizmat> Zoffix: I have support for Baggy semantics for (<) and (<=) ready, but they break some Mixy (<) Mixy tests

[16:07] <lizmat> hence my question to masak

[16:08] <lizmat> so I'm not feeling particularly productive today either

[16:09] <Zoffix> :)

[16:12] <Geth> ¦ rakudo/nom: d3783d541c | (Elizabeth Mattijsen)++ | src/core/set_operators.pm

[16:12] <Geth> ¦ rakudo/nom: We need to decont() to reap benefits of nqp::eqaddr

[16:12] <Geth> ¦ rakudo/nom:

[16:12] <Geth> ¦ rakudo/nom: Also comment on why we don't need to handle object hashes seperately

[16:12] <Geth> ¦ rakudo/nom: review: https://github.com/rakudo/rakudo/commit/d3783d541c

[16:16] <Geth> ¦ rakudo/newer-cat-handle: 04eeaeedcc | (Zoffix Znet)++ | src/core/IO/CatHandle.pm

[16:16] <Geth> ¦ rakudo/newer-cat-handle: Make IO::CatHandle.lines pass its tests

[16:16] <Geth> ¦ rakudo/newer-cat-handle: review: https://github.com/rakudo/rakudo/commit/04eeaeedcc

[16:16] <Zoffix> *phew* finally. Should be smooth saling for the rest of the cathandle

[16:16] * Zoffix &

[16:59] <ugexe> famous last words

[17:04] <Zoffix> :)

[17:21] <timotimo> wtmp begins Mon Feb  1 03:55:37 2016

[17:22] <cygx> Zoffix: re .seek/.tell, in principle they need not throw if the bytes stuck in the decoding buffers are properly taken into account

[17:22] <cygx> if they are not, it's probably better to throw

[17:23] <Zoffix> ok

[17:24] <Zoffix> timotimo: what's wtmp?

[17:24] * Zoffix is experiencing Perl6geist

[17:24] <Geth> ¦ rakudo/nom: 8fe858d665 | (Elizabeth Mattijsen)++ | src/core/Baggy.pm

[17:24] <Geth> ¦ rakudo/nom: Oops, forgot to remove code that's no longer needed

[17:24] <Geth> ¦ rakudo/nom:

[17:24] <Geth> ¦ rakudo/nom: This should have happened in accf51985006df755e

[17:24] <Geth> ¦ rakudo/nom: review: https://github.com/rakudo/rakudo/commit/8fe858d665

[17:24] <Geth> ¦ rakudo/nom: d92e71dec4 | (Elizabeth Mattijsen)++ | src/core/set_operators.pm

[17:24] <Geth> ¦ rakudo/nom: Give (<) Baggy and Mixy semantics for Bags/Mixes

[17:24] <Geth> ¦ rakudo/nom:

[17:24] <Geth> ¦ rakudo/nom: This oddly enough does *not* break any spectests, even though before

[17:24] <Geth> ¦ rakudo/nom: only Set semantics were used.  Given A and B:

[17:24] <Geth> ¦ rakudo/nom:

[17:24] <Geth> ¦ rakudo/nom: For Bags: a key in A must exist in B with val(A) < val(B)

[17:24] <Geth> ¦ rakudo/nom: For Mixes:

[17:24] <Geth> ¦ rakudo/nom:  - matching keys in A and B should have val(A) < val(B)

[17:24] <Geth> ¦ rakudo/nom:  - missing keys in A should have val(B) > 0

[17:24] <Geth> ¦ rakudo/nom:  - missing keys in B should have val(A) < 0

[17:24] <Geth> ¦ rakudo/nom: review: https://github.com/rakudo/rakudo/commit/d92e71dec4

[17:25] <lizmat> m: say (a => -1).Mix (<) mix()   # will become True

[17:25] <camelia> rakudo-moar d3783d: OUTPUT: «False␤»

[17:25] <Zoffix> I accidentally used `dd` to dump a var in Perl 5 code... and to my surprise there *is* a `&dd` sub that converts the stuff into `<dd>...</dd>` markup, but it's coming from nowhere. Not the 1 module I'm `use`ing nor anywhere else in the code

[17:25] <Zoffix> I think this website is trying to tell me it wants me to rewrite it in Perl 6 :}

[17:26] <lizmat> Zoffix: wouldn't be the first time people copied a good idea from Perl 6 :-)

[17:26] <timotimo> Zoffix: that's the output of "last words" on the console ;)

[17:26] <Zoffix> wtmp begins Tue May  2 08:11:28 2017

[17:26] <lizmat> m: say mix() (<) (a => -1).Mix   # will become False

[17:26] <camelia> rakudo-moar d3783d: OUTPUT: «False␤»

[17:27] <Zoffix> timotimo: hah

[17:27] <Zoffix> lizmat: looks kinda crazy :i

[17:27] <lizmat> m: say mix().Set (<) (a => -1).Mix.Set

[17:27] <camelia> rakudo-moar d3783d: OUTPUT: «False␤»

[17:28] <lizmat> m: say set() (<) <a>.Set

[17:28] <camelia> rakudo-moar d3783d: OUTPUT: «False␤»

[17:28] <lizmat> huh ?

[17:28] <Zoffix> I see

[17:28] <lizmat> that *should* be true in my book ?

[17:28] <lizmat> m: say SetHash.new (<) <a>.Set

[17:28] <Zoffix> I would've figured the "Bag is a degenerate Mix and Set is a degenerate Bag" thing to be applied to all the operators

[17:28] <camelia> rakudo-moar d3783d: OUTPUT: «False␤»

[17:29] <lizmat> Zoffix: that's what I'm working on  :-)

[17:30] <Zoffix> lizmat: hm, but then to me (a => -1).Mix is a mix with 1 element and mix() is a mix with 0 elements, so it's obviously a subset of the first mix.

[17:30] <Zoffix> like... the subsettiness isn't concerned with weights

[17:30] <Zoffix> oh

[17:30] <Zoffix> lizmat: never mind :) it clicked

[17:30] <lizmat> well, if you have Baggy semantics, the weights *are* concerned

[17:30] <lizmat> and a missing key is supposed to be 0

[17:30] <Zoffix> yeah, now I get it :)

[17:32] <Zoffix> Bisectable points to for the set() (<) <a>.Set thing: https://github.com/rakudo/rakudo/commit/431ed4e30e1568095eba30423671c8a2855c11dc

[17:34] <lizmat> yeah, found it  :-)

[17:49] <Geth> ¦ rakudo/nom: e6506bfdd7 | (Elizabeth Mattijsen)++ | src/core/set_operators.pm

[17:49] <Geth> ¦ rakudo/nom: Fix behaviour of set() (<) X.Set

[17:49] <Geth> ¦ rakudo/nom:

[17:49] <Geth> ¦ rakudo/nom: The empty set is always a proper subset of any non-empty Set.

[17:49] <Geth> ¦ rakudo/nom: review: https://github.com/rakudo/rakudo/commit/e6506bfdd7

[18:16] <Geth> ¦ rakudo/nom: c9c1ee3dcc | (Elizabeth Mattijsen)++ | src/core/Rakudo/QuantHash.pm

[18:16] <Geth> ¦ rakudo/nom: Introducing R:Q.MIX-ALL-(POSITIVE|NEGATIVE)

[18:16] <Geth> ¦ rakudo/nom:

[18:16] <Geth> ¦ rakudo/nom: Abstracting some functionality from Mixy (<) Mixy to be used in

[18:16] <Geth> ¦ rakudo/nom: Mixy (<=) Mixy

[18:16] <Geth> ¦ rakudo/nom: review: https://github.com/rakudo/rakudo/commit/c9c1ee3dcc

[18:16] <Geth> ¦ rakudo/nom: dd6d6cc477 | (Elizabeth Mattijsen)++ | src/core/set_operators.pm

[18:16] <Geth> ¦ rakudo/nom: Use new R:Q.MIX-ALL-(POSITIVE|NEGATIVE)

[18:16] <Geth> ¦ rakudo/nom: review: https://github.com/rakudo/rakudo/commit/dd6d6cc477

[18:23] <cono> Zoffix: will you be able to merge https://github.com/perl6/nqp/pull/360 and https://github.com/rakudo/rakudo/pull/1086 ?

[18:24] <Zoffix> cono: unsure if you know of it... but did you run spectest?  TEST_JOBS=8 make spectest   (where 8 is $number-of-cores-on-your-processor *1.3)

[18:25] <Zoffix> I recall mentions of segfaults somewhere. Is that something new added by the PRs or was that in there already?

[18:25] <cono> it doesn't work for me :( most of them rely on $*DISTRO.name instead of $*VM.osname and on my linux it gives "gentoo"

[18:26] <cono> Zoffix: its only for new tests: https://github.com/perl6/roast/pull/270

[18:26] <cono> I'm not asking to merge it yet :)

[18:26] <Zoffix> Ah, OK

[18:26] <Zoffix> m: dd [ $*DISTRO.name,  $*VM.osname ]

[18:26] <camelia> rakudo-moar e6506b: OUTPUT: «["opensuse", "linux"]␤»

[18:27] <Zoffix> ok, 1 sec. Lemme build and spectest

[18:27] <cono> look into current IO-Socket-INET.t

[18:27] <cono> there are distro.name

[18:27] <cono> and there are no opensuse

[18:27] <cono> only ubuntu, linux

[18:27] <cono> imho it should be rewrited to $VM.osnmae

[18:28] <Geth> ¦ nqp/master: 5 commits pushed by cono++, (Jonathan Worthington)++

[18:28] <Geth> ¦ nqp/master: eeb23791e2 | Add mapping of the op code get_port_sk

[18:28] <Geth> ¦ nqp/master: 191958d1ca | Rename get_port -> getport

[18:28] <Geth> ¦ nqp/master: b5f29e9a23 | Bump moar revision

[18:28] <Geth> ¦ nqp/master: bd575988ac | Merge branch 'master' into socket_get_port_op

[18:28] <Geth> ¦ nqp/master: debd8be6a4 | Merge pull request #360 from cono/socket_get_port_op

[18:28] <Geth> ¦ nqp/master: review: https://github.com/perl6/nqp/compare/6f0b5b46a0...debd8be6a4

[18:28] <Geth> ¦ nqp/master: version bump brought these changes: https://github.com/MoarVM/MoarVM/compare/2017.05...2017.05-24-gd86a35b6

[18:30] <Zoffix> yeah, we got VM.osname only like this month

[18:31] <Zoffix> c: bisect say VM.osname

[18:31] <committable6> Zoffix, ¦bisect: «Cannot find this revision (did you mean “6ccecb1”?)»

[18:31] <Zoffix> bisect: say VM.osname

[18:31] <bisectable6> Zoffix, Bisecting by exit code (old=2015.12 new=1283599). Old exit code: 1

[18:31] * Zoffix notices bisectable6 got a lot slower :/

[18:32] <Zoffix> star: VM.osname

[18:32] <camelia> star-m 2016.10: OUTPUT: «No such method 'osname' for invocant of type 'VM'␤  in block <unit> at <tmp> line 1␤␤»

[18:32] <cono> $*VM i guess

[18:32] <Zoffix> Oh well

[18:32] <Zoffix> m: say VM.osname

[18:32] <lizmat> m: say $VM.config<osname>

[18:32] <camelia> rakudo-moar dd6d6c: OUTPUT: «linux␤»

[18:32] <camelia> rakudo-moar dd6d6c: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Variable '$VM' is not declared␤at <tmp>:1␤------> 3say 7⏏5$VM.config<osname>␤»

[18:32] <lizmat> m: say $*VM.config<osname>

[18:32] <camelia> rakudo-moar dd6d6c: OUTPUT: «linux␤»

[18:33] <lizmat> j: say $*VM.properties<os.name>

[18:33] <camelia> rakudo-jvm fb4f16: OUTPUT: «Linux␤»

[18:33] <lizmat> yuck

[18:33] <Zoffix> heh

[18:33] <Zoffix> j: say VM.osname

[18:33] <camelia> rakudo-jvm fb4f16: OUTPUT: «Method 'osname' not found for invocant of class 'VM'␤  in block <unit> at <tmp> line 1␤␤»

[18:33] <cono> j: say $*VM.osname

[18:33] <camelia> rakudo-jvm fb4f16: OUTPUT: «Method 'osname' not found for invocant of class 'VM'␤  in block <unit> at <tmp> line 1␤␤»

[18:33] <lizmat> huh?

[18:33] <cono> m: say $*VM.osname

[18:33] <camelia> rakudo-moar dd6d6c: OUTPUT: «linux␤»

[18:34] <Zoffix> it's still stuck on Jan 4th commit

[18:34] <lizmat> yup, looks like  :-(

[18:34] <Zoffix> .tell nine seems camelia's JVM rakudo is stuck again. Uses Jan 3rd commit

[18:34] <yoleaux> Zoffix: I'll pass your message to nine.

[18:35] <Zoffix> uhh "No registered operation handler for 'getport'"

[18:36] <timotimo> insufficiently new nqp

[18:36] <Zoffix> ah, ok, I expected it to build master since I manually cloned it

[18:37] <timotimo> did we forget to bump the version requirement?

[18:37] <Geth> ¦ rakudo/nom: b1d83f9d69 | (Elizabeth Mattijsen)++ | src/core/set_operators.pm

[18:37] <Geth> ¦ rakudo/nom: Give (<=) Baggy and Mixy semantics for Bags/Mixes

[18:37] <Geth> ¦ rakudo/nom:

[18:37] <Geth> ¦ rakudo/nom: This oddly enough does *not* break any spectests, even though before

[18:37] <Geth> ¦ rakudo/nom: only Set semantics were used.  Given A and B:

[18:37] <Geth> ¦ rakudo/nom:

[18:37] <Geth> ¦ rakudo/nom: For Bags: a key in A must exist in B with val(A) <= val(B)

[18:37] <Geth> ¦ rakudo/nom: For Mixes:

[18:37] <Geth> ¦ rakudo/nom:  - matching keys in A and B should have val(A) <= val(B)

[18:37] <Geth> ¦ rakudo/nom:  - missing keys in A should have val(B) >= 0

[18:37] <Geth> ¦ rakudo/nom:  - missing keys in B should have val(A) <= 0

[18:37] <Geth> ¦ rakudo/nom:  - since we don't have 0 values in Mixes, the <= can be <

[18:37] <Geth> ¦ rakudo/nom: review: https://github.com/rakudo/rakudo/commit/b1d83f9d69

[18:37] <cono> timotimo: do we have version requirement for nqp too ?

[18:37] <Zoffix> timotimo: no, it's the fork

[18:37] <Zoffix> cono: yeah, in tools/build/NQP_REVISION in rakudo

[18:38] <cono> heh, should I add it to my PR ?

[18:38] <cono> I mean to this one: https://github.com/rakudo/rakudo/pull/1086

[18:38] <Zoffix> Nah, I'll bump it while your fork compiles and stresstests :)

[18:38] <cono> thanks a lot :)

[18:40] <lizmat> Please note that Baggy/Mixy semantics for (<) and (<=) and friends can be easily moved to 6.d should that be necessary

[18:40] <Zoffix> lizmat: do they break 6.c tests?

[18:41] <lizmat> it's just adding a number of candidates to (<) and (<=)

[18:41] <lizmat> 6.c hmmm...

[18:41] <lizmat> it doesn't break anything in roast/master

[18:41] <Zoffix> Ah, then IMO they're fine :D

[18:42] <lizmat> that doesn't mean there won't be any ecosystem fallout

[18:42] <lizmat> you could argue that any tests are apparently poorly written

[18:42] <timotimo> have you considered grepping through perl6-all-modules for the operators you've changde?

[18:43] <lizmat> m: say <a b>.Bag (<) <a b c>.Bag   # doesn't matter whether Set or Bag semantics

[18:43] <camelia> rakudo-moar dd6d6c: OUTPUT: «False␤»

[18:43] <Zoffix> huggable: all modules

[18:43] <huggable> Zoffix, https://github.com/moritz/perl6-all-modules

[18:43] <Zoffix> .oO( need a bot that greps that from IRC )

[18:44] <cono> or something like this :) https://grep.metacpan.org/

[18:44] <lizmat> m: say <a b>.Bag.Set (<) <a b c>.Bag.Set

[18:44] <camelia> rakudo-moar dd6d6c: OUTPUT: «True␤»

[18:44] <Zoffix> yeah

[18:44] <lizmat> so that changed

[18:44] <lizmat> m: say <a b>.Bag (<=) <a b c>.Bag

[18:44] <camelia> rakudo-moar dd6d6c: OUTPUT: «True␤»

[18:45] <lizmat> m: say <a b>.Bag.Set (<=) <a b c>.Bag.Set   # didn't change

[18:45] <camelia> rakudo-moar dd6d6c: OUTPUT: «True␤»

[18:46] <lizmat> problem with grepping is that (<) also affects (>) as well as the unicode versions of each

[18:46] <lizmat> so that's like 8 different ops to look for

[18:46] <Zoffix> What sucks is the coverage tells us these ops are covered: https://perl6.wtf/SETTING__src_core_set_operators_pm.coverage.html#L204

[18:46] <lizmat> note that $a (>) $b is essentially $b (<) $a

[18:46] <Zoffix> but evidently lots of cases aren't covered

[18:47] <lizmat> well, that is from an older version of the settings: I added a lot of candidates

[18:47] <lizmat> that aren'y shown in there

[18:47] <cono> wow Bag nice data structure for ml classification prolems

[18:48] <Zoffix> ZOFVM: Files=1242, Tests=135655, 114 wallclock secs (22.22 usr  3.16 sys + 2342.07 cusr 138.52 csys = 2505.97 CPU)

[18:48] <Geth> ¦ rakudo/nom: e13a3a6837 | (Zoffix Znet)++ | tools/build/NQP_REVISION

[18:48] <Geth> ¦ rakudo/nom: Bump NQP

[18:48] <Geth> ¦ rakudo/nom:

[18:48] <Geth> ¦ rakudo/nom: NQP bump brought changes:

[18:48] <Geth> ¦ rakudo/nom: https://github.com/perl6/nqp/compare/2017.05-23-g6f0b5b4...2017.05-28-gdebd8be

[18:48] <Geth> ¦ rakudo/nom:

[18:48] <Geth> ¦ rakudo/nom: debd8be Merge pull request #360 from cono/socket_get_port_op

[18:48] <Geth> ¦ rakudo/nom: bd57598 Merge branch 'master' into socket_get_port_op

[18:48] <Geth> ¦ rakudo/nom: b5f29e9 Bump moar revision

[18:48] <Geth> ¦ rakudo/nom: 191958d Rename get_port -> getport

[18:48] <Geth> ¦ rakudo/nom: eeb2379 Add mapping of the op code get_port_sk

[18:48] <Geth> ¦ rakudo/nom: review: https://github.com/rakudo/rakudo/commit/e13a3a6837

[18:48] <Geth> ¦ rakudo/nom: version bump brought these changes: https://github.com/perl6/nqp/compare/2017.05-23-g6f0b5b4...2017.05-28-gdebd8be

[18:48] <Geth> ¦ rakudo/refactor-socket-encoding: bc98e671c9 | cono++ | src/core/IO/Socket/INET.pm

[18:48] <Geth> ¦ rakudo/refactor-socket-encoding: Update localport if we made bind on port 0

[18:49] <Geth> ¦ rakudo/refactor-socket-encoding:

[18:49] <Geth> ¦ rakudo/refactor-socket-encoding: There is a common practice to bind on first un-used port, you have to

[18:49] <Geth> ¦ rakudo/refactor-socket-encoding: bind on port 0 and after that with help of getsockname call you can get

[18:49] <Geth> ¦ rakudo/refactor-socket-encoding: what port is in use.

[18:49] <Geth> ¦ rakudo/refactor-socket-encoding: review: https://github.com/rakudo/rakudo/commit/bc98e671c9

[18:49] <Geth> ¦ rakudo/refactor-socket-encoding: ab9d9e2528 | cono++ | src/core/IO/Socket/INET.pm

[18:49] <Geth> ¦ rakudo/refactor-socket-encoding: Rename get_port -> getport

[18:49] <Geth> ¦ rakudo/refactor-socket-encoding: review: https://github.com/rakudo/rakudo/commit/ab9d9e2528

[18:49] <Geth> ¦ rakudo/refactor-socket-encoding: 919fc362d5 | (Zoffix Znet)++ (committed using GitHub Web editor) | src/core/IO/Socket/INET.pm

[18:49] <Geth> ¦ rakudo/refactor-socket-encoding: Merge pull request #1086 from cono/refactor-socket-encoding

[18:49] <Geth> ¦ rakudo/refactor-socket-encoding:

[18:49] <Geth> ¦ rakudo/refactor-socket-encoding: Update localport if we made bind on port 0

[18:49] <Geth> ¦ rakudo/refactor-socket-encoding: review: https://github.com/rakudo/rakudo/commit/919fc362d5

[18:49] <cono> sorry for not squashing it :( Just read that its required step

[18:49] <timotimo> i'm not sure we require squashing commits for pull requests?

[18:49] * Zoffix didn't even know that was a required step :}

[18:50] <Zoffix> wait, wtf happend..

[18:50] <cono> https://github.com/rakudo/rakudo/blob/nom/CONTRIBUTING.md#the-contribution-process

[18:50] <cono> // and please squash out any intermediate commits, like adding/removing debug output.

[18:50] <timotimo> i expect that only refers to stuff that gets added in one part of the PR, and then removed again later

[18:51] <Zoffix> Oh it got merged into the sock refactor, but should've gone to nom, no?

[18:51] <timotimo> i'm not actually sure what you did :D

[18:51] <Zoffix> yup

[18:51] <cono> dunno, jnthn asked me to use this branch

[18:51] <timotimo> ah, the one before was just a nqp version bump

[18:52] <jnthn> I merged the refactor-socket-encoding branch earlier

[18:52] <Geth> ¦ rakudo: zoffixznet++ created pull request #1087: Merge sock branch

[18:52] <Geth> ¦ rakudo: review: https://github.com/rakudo/rakudo/pull/1087

[18:52] <jnthn> I think it's just recreated the branch

[18:52] <Geth> ¦ rakudo/nom: 4 commits pushed by cono++, (Zoffix Znet)++

[18:52] <Geth> ¦ rakudo/nom: bc98e671c9 | Update localport if we made bind on port 0

[18:52] <Geth> ¦ rakudo/nom: ab9d9e2528 | Rename get_port -> getport

[18:52] <Geth> ¦ rakudo/nom: 919fc362d5 | Merge pull request #1086 from cono/refactor-socket-encoding

[18:52] <Geth> ¦ rakudo/nom: a2e28a9595 | Merge pull request #1087 from rakudo/refactor-socket-encoding

[18:52] <Geth> ¦ rakudo/nom: review: https://github.com/rakudo/rakudo/compare/e13a3a6837...a2e28a9595

[18:53] <jnthn> So it's just a case of merging it into nom

[18:53] <Zoffix> Yeah

[18:53] <jnthn> Or doing a like that :P

[18:54] * Zoffix notes to self: double check branches next time you're merging stuff :)

[18:54] <cono> as for the segfault, I'll open issue in MoarVM with link to roast's PR, as currently I don't have a clue what is going on in GC... pretty a lot of things to learn

[18:55] <timotimo> have i seen that segv?

[18:55] <cono> timotimo: https://github.com/perl6/roast/pull/270

[18:56] <cono> it strange that it fails after third run of the same sub: https://pastebin.com/HbKZq5PC

[18:56] <timotimo> there's some #define in the code that will make gc problems appear closer to what caused 'em

[18:57] <cono> so first 2 times of thread.finish works fine

[18:58] <cono> what define?

[18:58] <Zoffix> ZOFVM: Files=1242, Tests=135655, 113 wallclock secs (22.01 usr  3.13 sys + 2351.16 cusr 137.27 csys = 2513.57 CPU)

[18:58] <Zoffix> Result: PASS

[18:58] <Zoffix> y

[18:58] <Zoffix> k. That's nom HEAD all pass :)

[18:58] * Zoffix returns to lurning

[18:58] <timotimo> it's called MVM_GC_DEBUG

[18:59] <timotimo> (but there's also some enum values called MVM_GC_DEBUG_SOMETHING, which are for something different

[18:59] * jnthn bbl

[19:00] <jnthn> cono++ # .localport improvements :)

[19:00] <cono> thanks :)

[19:05] <Zoffix> TIL "2nd Defenestration of Prague" is a thing

[19:05] <Zoffix> Happened on this day, in 1618: https://twitter.com/weird_hist/status/867092502624522241

[19:05] <timotimo> how did they defenestrate prague, and how the heck did they manage to do it a second time? :P

[19:05] <Zoffix> :)

[19:20] <moritz> windows still open, eh? :-)

[20:01] <lizmat> m: &infix:<(elem)>.name   # is there a way to get at "(elem)" without having to do matching on .name ?

[20:01] <evalable6> lizmat, rakudo-moar a2e28a959: OUTPUT: «»

[20:01] <lizmat> m: say &infix:<(elem)>.name   # is there a way to get at "(elem)" without having to do matching on .name ?

[20:01] <evalable6> lizmat, rakudo-moar a2e28a959: OUTPUT: «infix:<(elem)>»

[20:02] <jnthn> I don't know of one; by that point it's just a mangled symbol in the symbol table

[20:02] <timotimo> and it being installed in the grammar with the right kind of token makes it "work"

[20:02] * jnthn decides to keep away from open windows

[20:02] <lizmat> but the grammar somehow needs to know it's (elem) ?

[20:03] <lizmat> I'm just thinking having the actual operator name available would be nice to have for hyper ops error messages

[20:05] <jnthn> At parse time, then we have the pieces to hand. At import time we only have the symbol name, and we do it by a match :-)

[20:05] <jnthn> You can steal the regex at least ;-)

[20:05] <lizmat> ok, fair enough

[20:05] <jnthn> (Near the end of method import in Perl6::World, fwiw)

[20:06] <jnthn> So yeah, there ain't a smarter way. :)

[20:06] <lizmat> I'll just go for: "for &infix:<∈>, "∈", &infix:<(elem)>, "(elem)" -> &op, $name:

[20:06] <jnthn> But note that we already reduce the numerous forms that may exist down to just a couple of them

[20:07] <lizmat> jnthn: not sure what you mean ?

[20:07] <lizmat> I mean, we have candidates for all forms

[20:07] <jnthn> I mean that it could be written infix:<< + >> and infix:<+> and infix:['+']

[20:08] <jnthn> But .name is already standardized to just infix:<+> whichever one it is written as in the source code

[20:08] <lizmat> ah, yes, ok, gotcha

[20:08] <jnthn> So it's actually much easier to match that it may first appear :)

[20:08] <jnthn> *than

[20:41] <Geth> ¦ roast: 7356cee9d2 | (Elizabeth Mattijsen)++ | S03-operators/set.t

[20:41] <Geth> ¦ roast: Make (elem) and (cont) tests more data driven

[20:41] <Geth> ¦ roast:

[20:41] <Geth> ¦ roast: To make it easier to add a whole load of other tests.

[20:41] <Geth> ¦ roast: review: https://github.com/perl6/roast/commit/7356cee9d2

[20:49] <Geth> ¦ roast: 93a79c852c | (Elizabeth Mattijsen)++ | S03-operators/set.t

[20:49] <Geth> ¦ roast: Rename variables to current representation

[20:49] <Geth> ¦ roast:

[20:49] <Geth> ¦ roast: SetHash used to be called KeySet (hence $ks -> $sh)

[20:49] <Geth> ¦ roast: BagHash used to be called KeyBag (hence $kb -> $bh)

[20:49] <Geth> ¦ roast:

[20:49] <Geth> ¦ roast: For easier understandability.

[20:49] <Geth> ¦ roast: review: https://github.com/perl6/roast/commit/93a79c852c

[20:58] <Geth> ¦ roast: 03f448c646 | (Elizabeth Mattijsen)++ | 3 files

[20:58] <Geth> ¦ roast: Use a slightly faster showkv

[20:58] <Geth> ¦ roast: review: https://github.com/perl6/roast/commit/03f448c646

[21:06] <Geth> ¦ roast: 95e574b6ef | (Elizabeth Mattijsen)++ | S03-operators/set.t

[21:06] <Geth> ¦ roast: Fix copy-pasto

[21:06] <Geth> ¦ roast: review: https://github.com/perl6/roast/commit/95e574b6ef

[21:08] * lizmat is going to reorganize the set operator tests in S03-operators/(set|bag|mix).t into files grouped by operator

[21:09] <lizmat> so that we can have a more thorough test coverage easier

[21:12] <Geth> ¦ roast: a5d5075f0f | (Elizabeth Mattijsen)++ | 2 files

[21:12] <Geth> ¦ roast: Move (elem) and related tests to S03-operators/elem.t

[21:12] <Geth> ¦ roast: review: https://github.com/perl6/roast/commit/a5d5075f0f

[21:14] <Geth> ¦ rakudo/nom: c82b72ae3a | (Elizabeth Mattijsen)++ | t/spectest.data

[21:14] <Geth> ¦ rakudo/nom: Add S03-operators/elem.t for testing

[21:14] <Geth> ¦ rakudo/nom: review: https://github.com/rakudo/rakudo/commit/c82b72ae3a

[22:01] * Zoffix judges RT#131349 an accidental improvement

[22:02] <AlexDaniel> it probably is

[22:02] <Geth> ¦ roast: e86264fe7d | (Elizabeth Mattijsen)++ | S03-operators/elem.t

[22:02] <Geth> ¦ roast: More thorough tests for (elem) and friends

[22:02] <Geth> ¦ roast: review: https://github.com/perl6/roast/commit/e86264fe7d

[22:02] <Zoffix> The behaviour change is due to a perf commit ( 7ea0f66189 ) but Baggy and Map  .invert return Seqs too, and we already have .antipair on Pair to get an inverted pair

[22:02] <Zoffix> gonna fix up the docs, add tests, and close the ticket

[22:03] * lizmat has written too many tests today and goes to bed

[22:03] <Zoffix> night

[22:04] <Zoffix> Also lizmat++ tests \o/

[22:08] <MasterDuke> jnthn, timotimo: sorry to keep bugging you about it, but any more pointers on that nqp int bug? i've added lots of prints in ./src/vm/moar/QAST/QASTCompilerMAST.nqp, but haven't found anything relevant/helpful

[22:39] <Zoffix> cool, found a bug while writing those test5s

[22:39] <Zoffix> m: my @t = [ <a b c>      => <d e f>,             <d e f>      => <a b c>      ],; for @t -> ($a, $b) {}

[22:39] <evalable6> Zoffix, rakudo-moar c82b72ae3: OUTPUT: «(exit code 1) This type cannot unbox to a native string: P6opaque, List␤  in block <unit> at /tmp/n054vyw6Ox line 1␤»

[22:40] <Zoffix> m: for [(<a b> => <d e>, <c d>),] -> ($a, $b) {}

[22:40] <evalable6> Zoffix, rakudo-moar c82b72ae3: OUTPUT: «(exit code 1) This type cannot unbox to a native string: P6opaque, List␤  in block <unit> at /tmp/jgWfb6tyKO line 1␤»

[22:41] <Zoffix> m: for [(Pair.new: <a b>, <d e>),] -> ($a) {}

[22:41] <evalable6> Zoffix, rakudo-moar c82b72ae3: OUTPUT: «(exit code 1) Too few positionals passed; expected 1 argument but got 0 in sub-signature␤  in block <unit> at /tmp/n_Q1TLKr3R line 1␤»

[22:41] <Zoffix> huh? I *am* passing 1 in sub sig

[22:42] <Zoffix> nm

[22:42] <Zoffix> m: for [(<a b> => <d e>,),] -> ($a) {}

[22:42] <evalable6> Zoffix, rakudo-moar c82b72ae3: OUTPUT: «(exit code 1) This type cannot unbox to a native string: P6opaque, List␤  in block <unit> at /tmp/GvDtKhehsp line 1␤»

[22:42] <Zoffix> m: for [((<foo> => <d e>),),] -> ($a) {}

[22:42] <evalable6> Zoffix, rakudo-moar c82b72ae3: OUTPUT: «(exit code 1) Too few positionals passed; expected 1 argument but got 0 in sub-signature␤  in block <unit> at /tmp/42XTnfpZeF line 1␤»

[22:42] * Zoffix doesn't seem to get it

[22:44] <Zoffix> m: my @a; @a[0] = (<foo> => <d e>),; dd @a; for @a -> ($a) {}

[22:44] <evalable6> Zoffix, rakudo-moar c82b72ae3: OUTPUT: «(exit code 1) Array @a = [(:foo(("d", "e")),),]␤Too few positionals passed; expected 1 argument but got 0 in sub-signature␤  in block <unit> at /tmp/3uPqnFDfqa line 1␤»

[22:44] <Zoffix> yeah, something's weird

[22:45] <Zoffix> aha

[22:45] <Zoffix> m: dd (<a b> => 42,).Capture

[22:45] <evalable6> Zoffix, rakudo-moar c82b72ae3: OUTPUT: «(exit code 1) This type cannot unbox to a native string: P6opaque, List␤  in block <unit> at /tmp/UKE9ABo5a_ line 1␤»

[22:46] <Zoffix> m: (class {} => 42,).Capture

[22:46] <evalable6> Zoffix, rakudo-moar c82b72ae3: OUTPUT: «(exit code 1) Cannot unbox a type object (<anon|58874688>) to a str.␤  in block <unit> at /tmp/8dT_67Gnbc line 1␤»

[22:46] <ugexe> m: for [((<foo> => <d e>),),] -> $a {} # but why is it ok without ()?

[22:46] <evalable6> ugexe, rakudo-moar c82b72ae3: OUTPUT: «»

[22:46] <Zoffix> yeah, just need a parametirezed nqp::hash

[22:47] <Zoffix> ugexe: because <foo> is a Str not a List

[22:47] <Zoffix> ugexe: oh, I misread the question

[22:47] <ugexe> yeah i mean it seems to be () + Capture that causes it?

[22:47] <Zoffix> ugexe: because then it just passes the list without unpacking it

[22:47] <Zoffix> Yeah, it's List.Capture that causes it: this line: https://github.com/rakudo/rakudo/blob/c82b72a/src/core/List.pm#L886

[22:57] <Zoffix> TBH, kinda weird that just any old Pair gets turned into a named arg

[22:57] <Zoffix> Maybe containerized thing doesn't apply to them

[22:59] <Zoffix> Filed as https://rt.perl.org/Ticket/Display.html?id=131351

[23:00] <ugexe> agree, i'd expect you'd have to | it for that

[23:04] <Zoffix> m: sub ( (:$a, :$b) ) { dd [ $a, $b ] }( [:42a, :72b], )

[23:04] <evalable6> Zoffix, rakudo-moar c82b72ae3: OUTPUT: «[42, 72]»

[23:05] <Zoffix> m: sub ( (:$a, :$b) ) { dd [ $a, $b ] }( [%(:42a, :72b)], )

[23:05] <evalable6> Zoffix, rakudo-moar c82b72ae3: OUTPUT: «[42, 72]»

[23:05] <Zoffix> m: sub ( (:$a, :$b) ) { dd [ $a, $b ] }( [%(:42a, :72b),], )

[23:05] <evalable6> Zoffix, rakudo-moar c82b72ae3: OUTPUT: «(exit code 1) Too many positionals passed; expected 0 arguments but got 1 in sub-signature␤  in sub  at /tmp/Fx0ibYcWJn line 1␤  in block <unit> at /tmp/Fx0ibYcWJn line 1␤»

[23:05] <Zoffix> mkay

[23:11] <Zoffix> m: dd %(<a b c> => <d e f>, :42a).invert

[23:11] <evalable6> Zoffix, rakudo-moar c82b72ae3: OUTPUT: «(42 => "a", :d("a b c"), :e("a b c"), :f("a b c")).Seq»

[23:12] <Zoffix> this also looks messed up

[23:12] <Zoffix> m: dd %(<a b c d>) => %(<e f g h>).invert

[23:12] <evalable6> Zoffix, rakudo-moar c82b72ae3: OUTPUT: «({:a("b"), :c("d")}) => (:h("g"), :f("e")).Seq»

[23:13] <Zoffix> m: dd (%(<a b c d>) => %(<e f g h>)).invert

[23:13] <evalable6> Zoffix, rakudo-moar c82b72ae3: OUTPUT: «((:g("h")) => {:a("b"), :c("d")}, (:e("f")) => {:a("b"), :c("d")}).Seq»

[23:13] <Zoffix> this too

[23:13] * Zoffix shrugs

[23:15] <Zoffix> m: dd %( %(<a b c x>) => %(<d e f g>) )

[23:15] <evalable6> Zoffix, rakudo-moar c82b72ae3: OUTPUT: «Hash % = {"a\tb\nc\tx" => ${:d("e"), :f("g")}}»

[23:15] <Zoffix> this three

[23:15] <Zoffix> ZofBot: it's a bug hole! Abort! Abort! Leave while you can!

[23:15] <ZofBot> Zoffix, here https://github.com/perl6/whateverable/blob/edcb6687b1a617c77fb533c2874141ec67b4a5f7/build.p6#L172-L173

[23:17] <Zoffix> oh wait, last one is ok

[23:18] <Zoffix> m: dd :{ %(<a b c d>) => %(<d e f g>) }.invert

[23:18] <evalable6> Zoffix, rakudo-moar c82b72ae3: OUTPUT: «((:d("e")) => {:a("b"), :c("d")}, (:f("g")) => {:a("b"), :c("d")}).Seq»

[23:18] <Zoffix> this one is kinda weird

[23:20] <Zoffix> Ah, I've been in this hole already.

[23:20] <Zoffix> It's by design. If you want just invert behaviour, that's waht .antipairs are for

[23:20] <Zoffix> Per http://design.perl6.org/S32/Containers.html#Hash and a test

[23:21] * Zoffix sees future-[Coke] frown as he reads over these soliloquies, trying to backlog :P

[23:21] <geekosaur> perhaps if it keeps tripping you/others up, it should be reconsidered and maybe much more clearly documented

[23:21] * Zoffix shrugs

[23:21] <Zoffix> I'm not exactly a model user. I never read docs and don't program tons of Perl 6

[23:22] <Zoffix> Yeah, this behaviour is documented: https://docs.perl6.org/type/Map#method_invert

[23:22] * Zoffix notes to read the docs next time :D

[23:33] <Geth> ¦ roast: f4828aaf64 | (Zoffix Znet)++ | S02-types/pair.t

[23:33] <Geth> ¦ roast: Spec Pair.invert

[23:33] <Geth> ¦ roast:

[23:33] <Geth> ¦ roast: RT#131349: https://rt.perl.org/Ticket/Display.html?id=131349

[23:33] <Geth> ¦ roast: review: https://github.com/perl6/roast/commit/f4828aaf64

[23:33] <synopsebot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=131349

[23:53] <Zoffix> Ah, hahaha

[23:54] <Zoffix> There actually *are* test for Pair.invert, but notice the problem: https://github.com/perl6/roast/blob/6.c-errata/S02-types/pair.t#L330-L332

[23:54] <Zoffix> They're using [0] index without checking what's it being called on, the tests were passing despite behaviour being wrong :)
