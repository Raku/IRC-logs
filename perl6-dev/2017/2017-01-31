[00:21] <brokenchicken> m: (^0x30000)».chr.grep(*.match(/<:Digit>/).not)».uniprops.flat.unique.say

[00:21] <camelia> rakudo-moar 3e28b1: OUTPUT«(Nd No Nl Lo)␤»

[00:27] <samcv> jnthn, lizmat on the <:Digit> matches anything.

[00:27] <samcv> Digit resolves to Numeric_Type fyi

[00:27] <samcv> m: say "something" ~~ /<:Numeric_Type>/

[00:27] <camelia> rakudo-moar 3e28b1: OUTPUT«｢s｣␤»

[00:28] <samcv> m: 'a'.uniprop('Numeric_Type').say

[00:28] <camelia> rakudo-moar 3e28b1: OUTPUT«None␤»

[00:28] <samcv> m: 'a'.uniprop-int('Numeric_Type').say

[00:28] <camelia> rakudo-moar 3e28b1: OUTPUT«0␤»

[00:32] <samcv> i wish i could understand that QAST file, i mean i'm not totally sure of the flow of the statements there. somebody will have to help me so i can fix some of these problems

[00:41] <brokenchicken> Which QAST file?

[00:45] <samcv> brokenchicken, src/vm/moar/QAST/QASTRegexCompilerMAST.nqp

[00:47] <samcv> the odd thing is that you can do scripts without qualifying the property like <:Latin>, all the property value's are comingled in moarvm

[00:47] <samcv> even though they are not unique between properties, so it causes some weirdness

[00:48] <samcv> it needs to check property name's before it checks property values. so likek for <:space>, the only reason it works is because 'space' is resolving to the Line_Feed property, and spaces have Line_Feed=space

[00:48] * brokenchicken knows nothing in that area

[00:48] <brokenchicken> (yet)

[00:48] <samcv> it _should_ check the property names, find there's a space property, and check uniprop-int

[00:49] <samcv> if it's not a property name, then we should check the property value list, and so it will find Latin refers to the script property, then check that Script == Latin

[00:49] <samcv> but it does it the reverse order atm

[00:49] <samcv> so values take precedence over property names

[00:51] <samcv> there need to be some big changes to mvm, and we won't be able to look up property names for anything except script and script extensions and idk maybe a few more, but

[00:51] <samcv> i think we only want Script and General category to be unqualified when doing <:Latin> or <:Ll>

[00:52] <timotimo> we can introduce new ops for you at any time

[00:52] <samcv> yeah ofc

[00:52] <timotimo> (though not in the next few hours, because i'm hoping to be sleeping then)

[00:52] <samcv> the main problem is the current ucd2c.pl assumed property values would be unique (aside from Yes/No) etc

[00:52] <timotimo> ah, yes indeed

[00:52] <timotimo> so we're blocked by the ucd2c rewrite?

[00:52] <samcv> yeah

[00:52] <samcv> well partially. we can still change the order of lookups

[00:53] <samcv> check if the requested <:Foo> is a property name first

[00:53] <samcv> we can fix that part

[00:54] <samcv> and we'll prolly have an op that is like hasuniprop, but it doesn't take unicode property codes, it takes the actual string names/values

[00:55] <samcv> and i'll probably retain a big jumbled hash table that holds all the property values, at least until all the changes are made. but one issue is RE: unimatch

[00:56] <samcv> i'm guessing unimatch fails if you try and check a property value that is non-unique

[00:56] <samcv> also i was never sure what the point of unimatch even was

[00:56] <samcv> i.e. usecase

[00:59] <samcv> my $prop := Rakudo::Internals.PROPCODE($propname);

[00:59] <samcv> so nqp::matchuniprop($code,$prop,Rakudo::Internals.PVALCODE($prop,$pvalname));

[00:59] <samcv> atm this is the code for sub unimatch

[01:00] <samcv> err wait that's the one for the property specific one, not the one that matcches any property

[01:00] <samcv> err nvm it is

[01:00] <samcv> multi sub unimatch(Int:D $code, Stringy:D $pvalname, Stringy:D $propname = $pvalname) {

[01:01] <samcv> haha, it uses the property value as the property name? and yeah uh... that's really kinda hard for me to look at

[01:01] <samcv> since property names can be the same as property values

[01:03] <timotimo> gotta go sleep, my brain isn't doing very much

[01:05] <samcv> night

[01:05] <timotimo> o/

[01:05] <samcv> brokenchicken, fyi it seems +'10' can be cached while .Int cannot

[01:05] <timotimo> perhaps you mean compile-time evaluated?

[01:06] <samcv> ah

[01:06] <samcv> that is probably true

[01:07] <samcv> that makes sense then

[01:16] <brokenchicken> samcv: why .Int cannot? Int => (digits-only ?? nqp::radix() !! .Numeric -> val()) whereas + => (Numeric -> val())

[01:17] <samcv> well Int i guess as timotimo said isn't compile time evaluated

[01:18] <brokenchicken> And .Numeric is?

[01:22] <samcv> it would seem

[01:23] <samcv> m: for ^10000 { +'10' / +'20' }; say now - INIT now;

[01:23] <camelia> rakudo-moar 3e28b1: OUTPUT«WARNINGS for <tmp>:␤Useless use of "/" in expression "+'10' / +" in sink context (line 1)␤0.0037290␤»

[01:23] <samcv> m: for ^10000 { '10'.Int / +'20'.Int }; say now - INIT now;

[01:23] <camelia> rakudo-moar 3e28b1: OUTPUT«WARNINGS for <tmp>:␤Useless use of "/" in expression ".Int / +" in sink context (line 1)␤0.1282265␤»

[01:24] <samcv> .Int is 34x slower there

[01:25] <brokenchicken> m: for ^10000 { $ = +'10' }; say now - INIT now;

[01:25] <camelia> rakudo-moar 3e28b1: OUTPUT«0.0039301␤»

[01:26] <brokenchicken> m: for ^10000 { $ = '10'.Int }; say now - INIT now;

[01:26] <camelia> rakudo-moar 3e28b1: OUTPUT«0.03161738␤»

[01:26] <brokenchicken> m: say 0.0316/.0039

[01:26] <camelia> rakudo-moar 3e28b1: OUTPUT«8.102564␤»

[01:27] <brokenchicken> m: for ^10000 { $ = '10'.Numeric }; say now - INIT now;

[01:27] <camelia> rakudo-moar 3e28b1: OUTPUT«0.1368020␤»

[01:27] <brokenchicken> Weird, considering + -> a.Numeric

[01:28] <brokenchicken> Turning off optimizer turns the scales

[01:30] <brokenchicken> Ahhh

[01:30] * brokenchicken just had an 'aha' moment

[01:31] <brokenchicken> Hm. Actually no :)

[01:31] <brokenchicken> Oh, I misread this QAST

[01:33] <brokenchicken> Yeah, the optimizer evaluates +'10' at compile time, cause prefix:<+> is marked pure.

[01:35] <brokenchicken> m: class Foo is Str { method numify { self.Int } }; my $f = Foo.new: :value('10'); for ^10000 { $ = $f.numify }; say now - INIT now

[01:35] <camelia> rakudo-moar 3e28b1: OUTPUT«0.03264332␤»

[01:35] <brokenchicken> m: class Foo is Str { method numify is pure { self.Int } }; my $f = Foo.new: :value('10'); for ^10000 { $ = $f.numify }; say now - INIT now

[01:35] <camelia> rakudo-moar 3e28b1: OUTPUT«0.03204627␤»

[01:35] <brokenchicken> Is doesn't work on methods?

[01:43] <brokenchicken> Apparently not. Just compiled a version making Str.Num, Str.Numeric, Str.Int, and all val() multies `is pure` and no effect

[01:53] <samcv> hm

[07:34] <TimToady> m: for ^10000 { $ = Int('10') }; say now - INIT now;

[07:34] <camelia> rakudo-moar 3e28b1: OUTPUT«0.04653305␤»

[07:40] * TimToady has most of a patch getting rid of $*ACTIONS lookups, but still failing 14 spectests, so something's probably leaking $!actions outward from some cursor or other that doesn't reset to the outer self's $!actions

[07:45] <TimToady> (eventually might do this with a method mixin rather than an attribute, which would be simpler in some ways, not so simple in others...)

[07:45] * nine wonders if there is a way to just speed up lookup of dynamics

[07:46] <TimToady> well, that would help too, and we've talked about it some

[07:47] <nine> How are dynamics managed right now?

[07:47] <TimToady> instead of keeping a direct cache entry in each frame, you'd keep a pointer to the next frame with a 'my $*foo' anywhere, and from that frame keep a more extensible cache, since most frames don't set dynvars

[07:48] <TimToady> we just scan down frames for a frame that has cached the name currently

[07:48] <TimToady> and if it was too far away, we cache it in a closer frame

[07:48] <TimToady> but it's still a linear scan

[07:49] <TimToady> on average we're still looking at 5 or so frames before we get a match

[07:49] <TimToady> actually, might be worse will all the new dynvars competing for the single entry per frame

[07:49] <nine> Me knowing nothing of how to implement dynamics, I'd keep a hash of arrays around. Hash key is obviously the name of the dynamic variable. The array is the stack of values with assignment pushing the value on the stack. Lookup would be just a single hash access + the access to the last element of the array.

[07:50] <TimToady> with a pointer instead of an entry, we could jump straight to the frame that is likely to contain the cached element in a hash or some such

[07:50] <TimToady> and it could be more authoritative too, for anything immutable

[07:51] <nine> I think we're thinking along similar lines: push the work into assignment of a dynvar instead of the reading.

[07:52] <TimToady> well, the reading can still hoist from a further cache to a closer one, but you know it's always the closest one you're populating, so better than "half way down the framelist"

[07:52] <TimToady> I think your approach sounds a bit thread-unsafe

[07:52] <TimToady> more like how P5 does things

[07:52] <TimToady> we'd still root things in the frames, just not look at every frame anymore

[07:53] <TimToady> we could also be helped with some kind of key interning, since we do a lot of string cmps

[07:54] <TimToady> but the $*ACTIONS, %*LANG, %*PRAGMAS need to be fixed anyway regardless, since the current language is supposed to be

[07:54] <TimToady> carried by the cursor, not by dynvars

[07:58] <TimToady> on the dynvar frame hashes, we might be able to just poke extra temp entries into the lexpad for the frame that already has a 'my $*something', if we're willing to cheat a bit on the immutability of lexpads

[07:59] <TimToady> anyway, our dynvar overhead is currently around 5% compiling the setting, and we could certainly get most of that back by doing smarter caching

[10:04] <jnthn> morning, #perl6-dev

[10:05] <moritz> \o jnthn

[10:08] <jnthn> TimToady++ # working to eliminate $*ACTIONS

[10:13] <moritz> what's the new paradigma?

[10:14] <moritz> storing the actions class in an attribute somewhere?

[10:18] <jnthn> Believe so, since $!attribute was mentioned

[10:18] <jnthn> uh, $!actions

[10:19] <timotimo> wow, most of that? neat.

[10:21] <jnthn> From backlog: methods are late-bound, which is why we can't know if they're pure and compile-time resolve them.

[10:30] <timotimo> jnthn: well, we could for constants because we already know their type then and could see if find_method is what we'd expect from "harmless" classes

[10:32] <jnthn> True

[10:34] <samcv> proto sub prefix:<+>($?) is pure { * }

[10:34] <samcv> multi sub prefix:<+>(\a) { a.Numeric }

[10:35] <samcv> i mean the prefix does a method call

[10:35] <DrForr> role Mostly-Harmless {};

[10:35] <jnthn> The problem isn't the mechanics of doing a method call, it's that things in our lexical scope are part of our langauge, and method calls are interpreted as part of the object's language.

[10:36] <jnthn> That's one of the key Perl 6 design principles, so I'm just a tad wary when we consider cheating. :-)

[10:41] <timotimo> well, the prefix is a sub

[10:41] <timotimo> so we can just look it up

[10:42] <timotimo> when we want to figure things out about an object's methods, we have to ask the object, and it's allowed to give us whatever answer it finds pleasing

[10:42] <timotimo> that's why you can create objects that "have" methods based on a SOAP definition, or XMLRPC, or just every combination of car and cdr cddr cdddr cddddr cdddddddddddr cdddddddddddddddddddr

[11:01] <Geth> rakudo/nom: ee7c1bba49 | (Jonathan Worthington)++ | src/core.d/await.pm

[11:01] <Geth> rakudo/nom: Improve error reporting of `await` in 6.d.

[11:01] <Geth> rakudo/nom:

[11:01] <Geth> rakudo/nom: The work so far actually made things a little worse, in so far as we

[11:01] <Geth> rakudo/nom: no longer called Promise.result, and thus did not get an exception

[11:01] <Geth> rakudo/nom: with both the original exception location and the location it was

[11:01] <Geth> rakudo/nom: awaited. This improves things for the new `await` implementation.

[11:01] <Geth> rakudo/nom: Furthermore, it means that all `await`s will get the treatment, not

[11:01] <Geth> rakudo/nom: just those that `await` a `Promise`. So, unlike in 6.c, `await` of a

[11:01] <Geth> rakudo/nom: `Supply` and a `Channel` will play ball and show both locations.

[11:01] <Geth> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/ee7c1bba49

[11:06] <Geth> roast: f26c4ed873 | (Jonathan Worthington)++ | S17-promise/nonblocking-await.t

[11:06] <Geth> roast: Tests for exceptions produced by `await` in 6.d.

[11:06] <Geth> roast: review: https://github.com/perl6/roast/commit/f26c4ed873

[11:09] <brokenchicken> hm... prefix:<+> does a.Numeric and we can constant fold it, but if we do a.Numeric ourselves then we can't?

[11:09] * brokenchicken doesn't really follow that one

[11:09] <timotimo> yeah

[11:09] <timotimo> the decision whether or not we constant-fold is based on the "is pure" trait

[11:10] <timotimo> we can only sanely look that up in lexically scoped things, i.e. subs

[11:10] <timotimo> when we get a method call on an object instead, the object is free to decide what it gives us

[11:10] <timotimo> if for example it needs to do a network request, you'll quite possibly get a different answer during precompilation vs run time

[11:10] <timotimo> or the method may not exist during compilation, but it will during run time

[11:12] <brokenchicken> But all those arguments apply to the a.Numeric call inside the prefix:<+>

[11:12] <timotimo> no

[11:12] <brokenchicken> huh

[11:12] <timotimo> we make the decision to constant fold +, then we Just Do It

[11:13] <timotimo> though to be fair, if the Numeric method on that object is shitty, we're fucked

[11:13] <jnthn> Well, if Numeric does something terrible then the folding will still do said terrible thing :)

[11:14] <timotimo> the thing is that we can easily look up if a sub is marked pure

[11:14] <timotimo> it's hard to look up if a method is marked pure

[11:16] <brokenchicken> m: class Foo is Str { method numify { self.Int } }; sub numify (\a) is pure { a.numify }; my $f = Foo.new: :value('10'); for ^1000000 { $ = numify $f }; say now - INIT now

[11:16] <camelia> rakudo-moar ee7c1b: OUTPUT«2.671370607␤»

[11:16] <brokenchicken> m: class Foo is Str { method numify { self.Int } }; sub numify (\a) is pure { a.numify }; my $f = Foo.new: :value('10'); for ^1000000 { $ = $f.numify }; say now - INIT now

[11:16] <camelia> rakudo-moar ee7c1b: OUTPUT«2.3328330␤»

[11:17] <brokenchicken> Seems the `is pure` thing doesn't even work in userland?

[11:17] <timotimo> that's not a constant

[11:17] <timotimo> your $f there

[11:17] <brokenchicken> m: class Foo is Str { method numify { self.Int } }; sub numify (\a) is pure { a.numify }; constant $f = Foo.new: :value('10'); for ^1000000 { $ = $f.numify }; say now - INIT now

[11:17] <camelia> rakudo-moar ee7c1b: OUTPUT«2.2604848␤»

[11:18] <brokenchicken> m: class Foo is Str { method numify { self.Int } }; sub numify (\a) is pure { a.numify }; constant $f = Foo.new: :value('10'); for ^1000000 { $ = numify $f }; say now - INIT now

[11:18] <camelia> rakudo-moar ee7c1b: OUTPUT«2.31849855␤»

[11:18] <nine> brokenchicken: the difference is that the author of prefix:<+> made a promise to the compiler that it will behave. So it's the author who trusts .Numeric

[11:19] <brokenchicken> m: sub numify (\a) is pure { a.Numeric }; for ^1000000 { $ = numify '10' }; say now - INIT now

[11:19] <camelia> rakudo-moar ee7c1b: OUTPUT«0.2556820␤»

[11:19] <brokenchicken> nine: same can be done with methods.

[11:20] <timotimo> brokenchicken: we'd already have to trust the object before we even try to look at the object whether a given method is pure or not

[11:20] <nine> brokenchicken: foo.bar(); foo.bar(); foo.bar(); can call 3 different methods

[11:21] <brokenchicken> The trust can be given by the type object with the `is pure` methods published with the meta object during composition.

[11:21] <brokenchicken> m: sub numify (\a) is pure { a.Numeric }; for ^1000000 { $ = '10'.Numeric }; say now - INIT now

[11:21] <camelia> rakudo-moar ee7c1b: OUTPUT«11.3806293␤»

[11:22] <brokenchicken> m: say 11.38/.255

[11:22] <camelia> rakudo-moar ee7c1b: OUTPUT«44.627451␤»

[11:22] <brokenchicken> To get 44x speed increment

[11:22] * brokenchicken &

[11:22] <Geth> rakudo/nom: a2d69a0638 | (Jonathan Worthington)++ | src/core.d/await.pm

[11:22] <Geth> rakudo/nom: Avoid saying "at: in", which reads oddly.

[11:22] <Geth> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/a2d69a0638

[11:27] <Geth> rakudo/nom: f22170f772 | (Jonathan Worthington)++ | src/core.d/await.pm

[11:27] <Geth> rakudo/nom: Improve `react` error reporting in 6.d.

[11:27] <Geth> rakudo/nom:

[11:27] <Geth> rakudo/nom: This re-instates getting both the location of the `react` block as

[11:27] <Geth> rakudo/nom: well as the location of the original exception. However, the language

[11:27] <Geth> rakudo/nom: of the message is far better. In 6.c we report that a `Promise` was

[11:27] <Geth> rakudo/nom: broken, thus leaking an implementation detail of `react`. This new

[11:27] <Geth> rakudo/nom: erorr clearly states it was a `react` block that was at fault.

[11:27] <Geth> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/f22170f772

[11:29] <Geth> roast: 26f910e382 | (Jonathan Worthington)++ | S17-supply/syntax-nonblocking-await.t

[11:29] <Geth> roast: Test react exception handling in 6.d.

[11:29] <Geth> roast: review: https://github.com/perl6/roast/commit/26f910e382

[11:30] <dogbert17> jnthn: any 6.c bugfixing on todays agenda?

[11:31] <jnthn> dogbert17: Yeah, I think I've done what I wanted to with await/react for now :)

[11:31] <timotimo> nice.

[11:33] <dogbert17> any bug in particular?

[11:33] <jnthn> Would be good to figure out a way to spectest with 6.d.PREVIEW on any existing thest that doesn't demand 6.c

[11:33] <timotimo> i'd like to bump up the priority of fixing inlining of subs with native arguments :(

[11:33] <jnthn> timotimo: spesh inlining of them?

[11:33] <timotimo> either that, or static-optimizer-inlining of them

[11:33] <timotimo> on the static optimizer level we currently create loads and loads and loads of nativerefs

[11:34] <timotimo> *and* don't inline - and i think we don't even spesh-inline those after the fact

[11:35] <jnthn> Hmm

[11:35] <jnthn> Seems we do inline things like $a + 1

[11:35] <jnthn> Where $a is native

[11:35] <timotimo> but do we create a nativeref?

[11:36] <jnthn> Shouldn't, but lemme check the bytecode

[11:36] <timotimo> we seem to

[11:36] <jnthn> The QAST tree says lexicalref but the add_i compilation is meant to be smart enough not to do that :)

[11:36] <timotimo> so where did i get the impression that we do a shitty job at this …

[11:37] <jnthn> 00022   getlex       loc_5_int, lex_Frame_1__int

[11:37] <jnthn> 00023   const_i64_16 loc_7_int, 1

[11:37] <jnthn> 00024   add_i        loc_7_int, loc_5_int, loc_7_int

[11:37] <jnthn> Obviously not from a simple example like 'my int $x = 41; say $x + 1' :)

[11:38] <jnthn> dogbert17: Got any particular ones you'd like me to look at?

[11:39] <dogbert17> jnthn, timotimo: what happens if you run: perl6-valgrind-m -e 'for ^900 { IO::Socket::INET.new( :port($_), :host("127.0.0.1") ); CATCH {next}; say $_~" is open" }'

[11:40] <dogbert17> I get invalid reads and the code seems to leek memory

[11:40] <jnthn> Let's see...

[11:40] <jnthn> ==28778==  Address 0xffeffc484 is on thread 1's stack

[11:40] <jnthn> ==28778==  12964 bytes below stack pointer

[11:40] <dogbert17> .oO

[11:41] <jnthn> During GC destruction

[11:41] <dogbert17> what about definitely lost mem?

[11:41] <jnthn> There's that too

[11:41] <jnthn> But it looks like we're taking a reference to something on the stack when we should be heap allocating

[11:41] <dogbert17> does it 'feel' simple or does it require cheese :-)

[11:42] <dogbert17> I have hidden more detailed info in the last comment here: https://github.com/MoarVM/MoarVM/issues/234

[11:44] <dogbert17> the nursery change was obviously not necessary

[11:48] <jnthn> Ah, I think I may see it

[11:49] <dogbert17> that was quick :)

[11:50] <timotimo> neat

[12:03] <jnthn> Seems we freed too quick but also threw an exception and longjmp'd over some libuv internals

[12:07] <dogbert17> is it easy or difficult to fix?

[12:10] <jnthn> Think I've got a fix

[12:10] <jnthn> Looking at the leaks

[12:12] <jnthn> Seems I've got 'em. :)

[12:13] * jnthn spectests

[12:14] <dogbert17> jnthn++, you made short work of that one :)

[12:18] <jnthn> Except t/spec/S32-io/socket-accept-and-working-threads.t now seems to explode

[12:20] <dogbert17> flapping?

[12:21] <jnthn> No, I actually introduced a double-free. Obvious in hindsight

[12:21] <jnthn> Probably need lunch :)

[12:21] <dogbert17> lunch++

[12:21] <jnthn> Valgrind seems happier now

[12:25] <jnthn> And looking good still on the original code we set out to fix

[12:25] <jnthn> Anther spectest while I have lunch :)

[12:25] <jnthn> bbiab

[12:32] * dogbert17 follows jnthn's lunch example

[12:52] <travis-ci> Rakudo build errored. Jonathan Worthington 'Avoid saying "at: in", which reads oddly.'

[12:52] <travis-ci> https://travis-ci.org/rakudo/rakudo/builds/196909943 https://github.com/rakudo/rakudo/compare/ee7c1bba49d4...a2d69a06389b

[12:52] <buggable> [travis build above] ☠ Did not recognize some failures. Check results manually.

[12:54] <timotimo> Cannot add PPA: 'ppa:ubuntu-toolchain-r/test'.

[12:54] <timotimo> Please check that the PPA name or format is correct.

[13:09] * jnthn back

[13:09] <jnthn> o.O

[13:10] <jnthn> Pretty sure that's not my fault :P

[13:10] <jnthn> yay, clean spectest

[13:13] <jnthn> dogbert17: Pushed 3 commits that sort it out. Might you be able to verify it's gone for you and/or add a test case? :)

[13:19] <brokenchicken> That error happened in the past. I think it's something to do with travis's "trusty beta" thing

[13:20] <dogbert17> jnthn: cool, I'll try it out

[13:21] <dogbert17> will try to figure out a test case

[13:29] <dogbert17> cool, the 'socket(PF_NETLINK, SOCK_RAW, 0)         = -1 EMFILE (Too many open files)' is also gone

[13:30] <dogbert17> brokenchicken, could jnthn's latest fixes be of interest to your bots by any chance?

[13:32] <jnthn> Also, do the bots still leak after the stuff I merged just after the Jan relesae? :)

[13:35] * brokenchicken shrugs

[13:35] <brokenchicken> not tested anything

[13:42] <brokenchicken> m: say 'rakudo.moar' eq 'rakudo.moar'

[13:42] <camelia> rakudo-moar f22170: OUTPUT«True␤»

[13:45] * dogbert17 fixes a recently discovered ENOCOFFEE error

[13:53] <dogbert17> jnthn: one question, if I change the loop to ^3900 valgrind spews out a bunch of '==29436== Warning: invalid file descriptor 1031 in syscall socket()'. Is it something to worry about?

[13:59] <jnthn> Sounds a bit odd

[13:59] <jnthn> Nice, I've got valgrind --leak-check=full on perl6-valgrind-m -e '' to show no leaks :)

[13:59] <jnthn> That'll make things a bit less noisy when we're leak hunting in the future :)

[14:00] <jnthn> And give us an every so slightly smaller memory footprint

[14:00] <dogbert17> perhaps the fact that I had set the Nursery to 16k had something to do with it

[14:01] <dogbert17> very nice

[14:01] <Geth> rakudo/nom: 43666039ae | (Zoffix Znet)++ | 2 files

[14:01] <Geth> rakudo/nom: Update t/harness* help texts to match accepted options

[14:01] <Geth> rakudo/nom:

[14:01] <Geth> rakudo/nom: Fixes RT#130659: https://rt.perl.org/Public/Bug/Display.html?id=130659

[14:01] <Geth> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/43666039ae

[14:01] <synopsebot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=130659

[14:01] <Geth> rakudo/nom: f94cb21ef5 | (Zoffix Znet)++ | t/harness5

[14:01] <Geth> rakudo/nom: Fix VM conditional

[14:01] <Geth> rakudo/nom:

[14:02] <Geth> rakudo/nom: - Remove useless ternary that was accidentally left over[^1]

[14:02] <Geth> rakudo/nom:     when parrot option was tossed.

[14:02] <Geth> rakudo/nom: - Use $moar instead of $jvm to check against, to match another

[14:02] <Geth> rakudo/nom:     similar check earlier in the file.

[14:02] <Geth> rakudo/nom:

[14:02] <Geth> rakudo/nom: [1] https://github.com/rakudo/rakudo/commit/c84ff300d59fb318e

[14:02] <dogbert17> it seems to have been the small nursery which caused the warnings

[14:02] <Geth> rakudo/nom: [2] https://github.com/rakudo/rakudo/blob/f22170f7725264/t/harness5#L39

[14:02] <Geth> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/f94cb21ef5

[14:05] <jnthn> They're still a bit odd, though...

[14:07] <dogbert17> it's always FD 1031

[14:15] <dogbert17> jnthn: if you're on the hunt for memory leaks t/spec/S17-procasync/no-runaway-file-limit.t is a good example

[14:16] <dogbert17> definitely lost: 147,513 bytes in 1,192 blocks

[14:17] <jnthn> t/spec/S17-procasync/no-runaway-file-limit.t

[14:17] <jnthn> oops

[14:17] <jnthn> :)

[14:17] * jnthn takes a look

[14:19] <jnthn> heh, this is none too fast under valgrind :)

[14:19] <dogbert17> no, takes a few minutes

[14:24] <dogbert17> did your latest commits mean the end of the --full-cleanup bug?

[14:35] <jnthn> No

[14:36] <jnthn> They mean that perl6-valgrind-m -e '' with --leak-check=full in valgrind will report no lost memory

[14:37] <jnthn> (Well, a few things lost due to DLL handles, but you have to --show-leak-kinds=all to get those)

[14:37] <jnthn> The --full-cleanup bug in multi-threaded programs is thanks to it trying to clean up mutexes which are still held

[14:37] <jnthn> Which is a much thornier problem

[14:39] <dogbert17> thx for the explanation, I usually make a copy of perl6-valgrind-m because it has that option enabled, which has tripped me up a few times

[14:42] <dogbert17> there are no many spectests which leaks memory, one is t/spec/S17-procasync/no-runaway-file-limit.t the other is t/spec/S17-lowlevel/lock.t

[14:43] <brokenchicken> m: say do for ^3 { $/ = $++; $/ }

[14:43] <camelia> rakudo-moar f94cb2: OUTPUT«(2 2 2)␤»

[14:43] <brokenchicken> This ain't a bug, is it? Or do blocks supposed to get fresh $/ or something ?

[14:45] <jnthn> No, they aren't

[14:45] <jnthn> So no bug

[14:46] <jnthn> Hm, I'm suspecting $!void_context in the optimizer isn't entirely accurate...

[14:47] <brokenchicken> Hm. This leads to very interesting interactions that by extension aren't buggy:

[14:47] <brokenchicken> m: say <a1 a2 a3>.map({S/huh//})

[14:47] <camelia> rakudo-moar f94cb2: OUTPUT«(a1 a2 a3)␤»

[14:47] <brokenchicken> m: say eager <a1 a2 a3>.map({S/huh//})

[14:47] <camelia> rakudo-moar f94cb2: OUTPUT«(a3 a3 a3)␤»

[14:48] <brokenchicken> The first ones are different because they get printed each before the next iteration updates $/; while the version that returns stuff from $!reified has all the items updated to last value of $/

[14:52] <brokenchicken> Makes perfect sense once you understand what's going on, but that's quite a trap :P

[14:53] <brokenchicken> m: my $stuff = <a1 a2 a3>.map({S/huh//}); say $stuff[^1]; say $stuff[^2]; say $stuff[^3]

[14:53] <camelia> rakudo-moar f94cb2: OUTPUT«(a1)␤(a2 a2)␤(a3 a3 a3)␤»

[14:53] <brokenchicken> ehehehe

[14:55] <jnthn> o.O

[14:56] <brokenchicken> :D

[14:56] <brokenchicken> m: say eager <a1 a2 a3>.map({S/huh//});

[14:56] <camelia> rakudo-moar f94cb2: OUTPUT«(a3 a3 a3)␤»

[14:56] <brokenchicken> m: say eager <a1 a2 a3>.map({S/huh//.Str});

[14:56] <camelia> rakudo-moar f94cb2: OUTPUT«(a1 a2 a3)␤»

[14:57] <brokenchicken> :)

[15:01] <jnthn> Darn, two attempts at fixing https://rt.perl.org/Ticket/Display.html?id=130615 that don't work :/

[15:04] <jnthn> hah, it makes 2 todo tests pass and fails one

[15:04] <brokenchicken> :)

[15:06] <jnthn> m: sub a($b) { $b = 1 }; a(2);

[15:06] <camelia> rakudo-moar f94cb2: OUTPUT«Cannot assign to a readonly variable ($b) or a value␤  in sub a at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[15:06] <jnthn> huh, the error there changed to "Cannot assign to an immutable value"

[15:08] <jnthn> bah

[15:08] <jnthn> It's because we nail an inline that we didn't before

[15:08] <jnthn> Which in turn does away with some info

[15:09] <jnthn> This kinda reminds me that I was going to pull inlining of anything not natively typed out of the optimizer anyway...

[15:09] <jnthn> The static one, that is

[15:10] <jnthn> Because spesh can inline better and preserve semantics better

[15:10] <jnthn> And then we'd also keep a bunch less info around in precomp files.

[15:10] <jnthn> And do a bunch less analysis.

[15:12] <lizmat> sounds like a plan  :-)

[15:16] <Geth> rakudo/optimizer-tweaks: 489bcec7b2 | (Jonathan Worthington)++ | src/Perl6/Optimizer.nqp

[15:16] <Geth> rakudo/optimizer-tweaks: Generalize sink branch optimize logic.

[15:16] <Geth> rakudo/optimizer-tweaks:

[15:16] <Geth> rakudo/optimizer-tweaks: Given:

[15:16] <Geth> rakudo/optimizer-tweaks: - QAST::Want

[15:16] <Geth> rakudo/optimizer-tweaks:     <some node>

[15:16] <Geth> rakudo/optimizer-tweaks:     v

[15:16] <Geth> rakudo/optimizer-tweaks:     QAST::Op p6sink

[15:16] <Geth> rakudo/optimizer-tweaks: <…commit message has 5 more lines…>

[15:16] <Geth> rakudo/optimizer-tweaks: review: https://github.com/rakudo/rakudo/commit/489bcec7b2

[15:16] * dogbert17 tries to build the docs on his 32 bit vm, will it work or will it crash after having allocated 2+ gigs ...

[15:17] <jnthn> That's the RT #130615 fix, modulo the regression that's finally going to make me sort out the inline situation :)

[15:17] <synopsebot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=130615

[15:23] <dogbert17> Writing type document for Num ...

[15:23] <dogbert17> MoarVM panic: Memory allocation failed; could not allocate 2013836 bytes

[15:23] <dogbert17> :(

[15:26] * jnthn wonders where it all goes...

[15:28] <dogbert17> could it still be https://rt.perl.org/Public/Bug/Display.html?id=130494

[15:28] <lizmat> m: say $*PERL; { use v6.d.PREVIEW; say $*PERL }   # is this a bug ?

[15:28] <camelia> rakudo-moar f94cb2: OUTPUT«Perl 6 (6.d)␤Perl 6 (6.d)␤»

[15:30] <lizmat> jnthn: ^^ would have expected to see "Perl 6 (6.c)␤Perl 6 (6.d)␤"

[15:30] <brokenchicken> IIRC the use v6.* has to occur no later than how `unit...` can occur.

[15:31] <brokenchicken> So I'd expect the above to throw with "too late to switch versions"

[15:31] <brokenchicken> m: say $*PERL; { unit class Meows; say $*PERL }

[15:31] <camelia> rakudo-moar f94cb2: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤A unit-scoped class definition is not allowed in a subscope;␤Please use the block form.␤at <tmp>:1␤------> 3say $*PERL; { unit class Meows;7⏏5 say $*PERL }␤»

[15:32] <brokenchicken> m: say $*PERL; {say $*PERL }; unit class Meows;

[15:32] <camelia> rakudo-moar f94cb2: OUTPUT«Perl 6 (6.c)␤Perl 6 (6.c)␤»

[15:32] <brokenchicken> oh. OK. :)

[15:32] <lizmat> brokenchicken: so from this I gather that a "use v6.x" should not be allowed in *any* subscope either ?

[15:34] <brokenchicken> lizmat: as I understand it, yeah. Because setting it the outter scope (or something) it doesn't really make sense for there being two settings at the same time

[15:35] <brokenchicken> lizmat: jnthn's explantion: https://irclog.perlgeek.de/perl6-dev/2017-01-27#i_13999497 and https://irclog.perlgeek.de/perl6-dev/2017-01-27#i_13999797

[15:37] <jnthn> Yes, but is that we acept it :)

[15:39] <jnthn> *the bug

[15:42] <lizmat> hmmm..  I guess the use handling code is already special cased for v6.x anyways

[15:42] <jnthn> aye

[15:42] <lizmat> so that shouldn't interfere with lexically using a module and its exports

[15:43] <lizmat> m: { use Test }; ok 1

[15:43] <camelia> rakudo-moar f94cb2: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Undeclared routine:␤    ok used at line 1␤␤»

[15:45] <jnthn> Only end up saving us 48.5KB off CORE.setting size

[15:45] <jnthn> (Only generating inline_info for natives, that is)

[15:45] <jnthn> Bit of a time saving too, though

[15:48] <brokenchicken> Wonder what's the point of S/// returning $/ instead of just the string

[15:48] <brokenchicken> Especially since it whines when you use it without getting the result;

[15:49] <brokenchicken> m: "foo" ~~ S:2nd/o/x/; say $/

[15:49] <camelia> rakudo-moar f94cb2: OUTPUT«Potential difficulties:␤    Smartmatch with S/// is not useful. You can use given instead: S/// given $foo␤    at <tmp>:1␤    ------> 3"foo" ~~ 7⏏5S:2nd/o/x/; say $/␤fox␤»

[15:49] <brokenchicken> Feels like original design didn't mean for that warning and people were expected to use $/ to get the result?

[15:50] <lizmat> m: class A { has Int $.a = 42 }; my $a = A.new; for ^100000 { $a.a }; say now - INIT now

[15:50] <camelia> rakudo-moar f94cb2: OUTPUT«0.07085673␤»

[15:51] <lizmat> m: class A { has int $.a = 42 }; my $a = A.new; for ^100000 { $a.a }; say now - INIT now

[15:51] <camelia> rakudo-moar f94cb2: OUTPUT«0.0810552␤»

[15:51] <lizmat> m: say 0.0810552 / 0.07085673   # native int attribute slower

[15:51] <camelia> rakudo-moar f94cb2: OUTPUT«1.14393086␤»

[15:51] <lizmat> was this already ticketed ^^^ ?

[15:54] <jnthn> It's having to box it every time

[15:54] <jnthn> It's nothing we can really solve in Rakudo.

[15:55] <jnthn> Once spesh gets good enough, that benchmark will also measure nothing :)

[15:55] <jnthn> Because it'll inline the method then see it's all pure and throw it all away :)

[15:56] <brokenchicken> \o/

[15:57] <jnthn> At the moment we inline but we don't re-analyze the inline in its new context.

[16:00] <Geth> rakudo/optimizer-tweaks: 8cea57f187 | (Jonathan Worthington)++ | src/Perl6/Actions.nqp

[16:00] <Geth> rakudo/optimizer-tweaks: Only generate static inline info when native args.

[16:00] <Geth> rakudo/optimizer-tweaks:

[16:00] <Geth> rakudo/optimizer-tweaks: Some years back, when Rakudo's optimizer was implemented, we didn't

[16:00] <Geth> rakudo/optimizer-tweaks: run on a VM that could do inlining. This is no longer the case, and

[16:00] <Geth> rakudo/optimizer-tweaks: it's much easier to do the analysis for correct semantic preservation

[16:00] <Geth> rakudo/optimizer-tweaks: in a VM and get it consistently right than it is in Rakudo. A VM can

[16:00] <Geth> rakudo/optimizer-tweaks: also only expend the effort on hot code. So, from now on we will only

[16:00] <Geth> rakudo/optimizer-tweaks: <…commit message has 7 more lines…>

[16:00] <lizmat> ok, just wondering  :-)

[16:00] <Geth> rakudo/optimizer-tweaks: review: https://github.com/rakudo/rakudo/commit/8cea57f187

[16:05] <dogbert17> jnthn: https://github.com/MoarVM/MoarVM/issues/234 looks fixed to me, what is not entirely obvious is how to test that

[16:06] <dogbert17> should I run the port scanner as a test?

[16:07] <jnthn> Hm, dunno if we'll trigger things if we do that

[16:07] <jnthn> Guess we could try :)

[16:08] <dogbert17> it's not obvious (to me at least) how to test this

[16:08] <jnthn> Well, the problem was that it SEGV'd?

[16:08] <dogbert17> yes, that was the original problem

[16:08] <jnthn> So we can run the code and pass "Survived without SEGV" or so

[16:08] <dogbert17> I guess so

[16:08] <jnthn> (well, explaining what we survived preferably)

[16:09] <dogbert17> yup

[16:09] <dogbert17> guess we need a moarvm bump first

[16:10] <jnthn> ah, yes

[16:22] <Geth> rakudo/nom: 5401a1aa8f | (Jonathan Worthington)++ | src/Perl6/Optimizer.nqp

[16:22] <Geth> rakudo/nom: Generalize sink branch optimize logic.

[16:22] <Geth> rakudo/nom:

[16:22] <Geth> rakudo/nom: Given:

[16:22] <Geth> rakudo/nom: - QAST::Want

[16:22] <Geth> rakudo/nom:     <some node>

[16:22] <Geth> rakudo/nom:     v

[16:22] <Geth> rakudo/nom:     QAST::Op p6sink

[16:22] <Geth> rakudo/nom: <…commit message has 5 more lines…>

[16:22] <Geth> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/5401a1aa8f

[16:22] <Geth> rakudo/nom: f8b3469439 | (Jonathan Worthington)++ | src/Perl6/Actions.nqp

[16:22] <Geth> rakudo/nom: Only generate static inline info when native args.

[16:22] <Geth> rakudo/nom:

[16:22] <Geth> rakudo/nom: Some years back, when Rakudo's optimizer was implemented, we didn't

[16:22] <Geth> rakudo/nom: run on a VM that could do inlining. This is no longer the case, and

[16:22] <Geth> rakudo/nom: it's much easier to do the analysis for correct semantic preservation

[16:22] <Geth> rakudo/nom: in a VM and get it consistently right than it is in Rakudo. A VM can

[16:22] <Geth> rakudo/nom: also only expend the effort on hot code. So, from now on we will only

[16:23] <Geth> rakudo/nom: <…commit message has 7 more lines…>

[16:23] <Geth> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/f8b3469439

[16:24] * lizmat pulls and spectests

[16:27] <jnthn> I get a coupe of passing todos in mine :)

[16:27] <yoleaux2> 16:25Z <brrt> jnthn: what also leaks (at least indirectly) is the memory for the extension ops in the JIT

[16:27] <yoleaux2> 16:26Z <brrt> jnthn: the solution for that (and a bunch of other things) is to have a data segment and stash the extension ops memory there, which is something i've been meaning to implement

[16:30] <Geth> roast: 57e5c39c7e | (Elizabeth Mattijsen)++ | S02-types/native.t

[16:30] <Geth> roast: Unfudge now passing tests on Moar

[16:30] <Geth> roast: review: https://github.com/perl6/roast/commit/57e5c39c7e

[16:30] <lizmat> jnthn: confirmed and unfudged for moar

[16:34] <dogbert17> jnthn: is this too sloppy?

[16:34] <dogbert17> is((for ^2000 { IO::Socket::INET.new( :port($_), :host("127.0.0.1") ); CATCH {next}; next }), "", "Surviving without SEGV due to incorrect connect handling")'

[16:42] <jnthn> dogbert17: I might write it like lives-ok { for ^2000 { ... } }, "Surviving..."; or so

[16:42] <jnthn> lizmat: Nice :)

[16:42] <dogbert17> jnthn: will fix

[16:42] <jnthn> dogbert17++

[16:43] <jnthn> lizmat: fwiw, anywhere you were writing nqp::add($a, $a, 1) instead of $a++ 'cus it was slower in sink context, should now be safe to do $a++ again :)

[16:43] <lizmat> well, ++$a, but yes  :-)  cool!

[16:44] <jnthn> :)

[16:44] <lizmat> but only in sink context ?

[16:44] <jnthn> It was OK in non-sink before too :)

[16:44] <lizmat> ah, ok

[16:44] <jnthn> The problem was that it was a ton slower in sink contxt

[16:44] <jnthn> *context

[16:44] <jnthn> As RT'd not so long ago

[16:46] <brokenchicken> There's also this ticket if you're into making the Optimizer better today :) https://rt.perl.org/Ticket/Display.html?id=130613#ticket-history

[16:47] <jnthn> I looked at that one

[16:47] <jnthn> Will be harder.

[16:47] <brokenchicken> if x {} is way slower than if x {} else {}; because the former gets `else { Empty }` attached to it so it could be used in lists. And optimizer can see if value isn't used and remove it

[16:47] <brokenchicken> Ahhh. OK :)

[16:53] <dogbert17> jnthn, lizmat: this is an old optimizer bug isn't it https://rt.perl.org/Public/Bug/Display.html?id=128655

[16:54] <lizmat> could be, seems to work ok now  :-)

[16:55] <brokenchicken> Seems still broken on 2017.01-121-gf94cb21

[16:56] <brokenchicken> Hm. I recall trying to fix that bug and it's not even so much an optimizer bug but candidate resolution bug.

[16:56] * brokenchicken digs for another ticket

[17:00] <brokenchicken> Hm. Well, it's this: https://rt.perl.org/Ticket/Display.html?id=129844

[17:00] <mst> well, that's fascinating: http://rachelbythebay.com/w/2017/01/30/env/

[17:00] <brokenchicken> But it doesn't explain my findings for previous ticket and I'm 99.9999% sure I nuked the directory with my notes on my home box

[17:01] <jnthn> Turns out one spectest file produces malfomred NFAs of the nature of the ones that make RT #130637 happen

[17:01] <synopsebot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=130637

[17:01] <jnthn> Except that case doesn't explode, apparently

[17:02] <brokenchicken> As I recall it, the 128655 happens in BOOTSTRAP.nqp in find_best_dispatchee() the non-native candidate ends up being first in the list and that's why it's used.

[17:06] <jnthn> mst: Fun. :S

[17:06] <TimToady> jnthn: on the early vs late binding thing, that's why I tested Int() vs .Int, and was...disappointed...that Int was just as slow as the method call, which means it's probably delegating to the method internally, I suppose

[17:06] <jnthn> TimToady: Yes, that form struck me as something we should be able to optimize better

[17:06] <jnthn> TimToady: Though...can we always take a coercer as pure?

[17:06] <lizmat> afk&

[17:07] <TimToady> we always know the type lexically, I think

[17:07] <jnthn> (I can't think of a reason we can't)

[17:07] <TimToady> and I thought we even, at one point, stipulated that .Int could recognize itself as a coercion and optimize lexically, but maybe that never happened

[17:08] <jnthn> mst: fwiw, we don't setenv anywhere in Perl 6 afaik; we slurp the environment up the first time it's requested, and for anything we spawn we construct the environment explicitly for the subprocess.

[17:08] <TimToady> (and that if we really wanted to call an Int method we could force it with ."Int"

[17:09] * jnthn doesn't recall that, but if we know it's a coercer I guess we can

[17:09] <jnthn> The whole coercion area is still in need of some attention..

[17:10] <dogbert17> brokenchicken, jnthn: where should I put the socket test, S32-io ?

[17:10] <TimToady> so basically, treat .Int more as a postfix operator like .WHAT if we know the "Int" type

[17:10] <jnthn> dogbert17: Somewhere under S32-io, I think. There's an IO-Socket-INET.t or so it can go at the end of

[17:11] <dogbert17> ok, PR coming up

[17:11] <brokenchicken> bunch of socket files there :) https://gist.github.com/zoffixznet/3c1abebdcac9ed2d1e69ae2dfd256e83

[17:12] <brokenchicken> dogbert17: I have "tg" alias set to `tree -f | grep -i `; and 90% of the time I can find a good file to put the tests in by running that command with some relevant keywords

[17:12] <brokenchicken> And the other 10% I use grep -Ri 'blah'

[17:13] <brokenchicken> well, other 9.95%. And the other 0.05% I create new test files :)

[17:13] <TimToady> alternately, we could have a different notation for postfix coercion than .

[17:13] <brokenchicken> How about ♥?

[17:14] * TimToady looks at brokenchicken

[17:14] <brokenchicken> m: sub infix:<♥> ($a, $b) { $a."{$b.^name}"() }; dd "42"♥Int

[17:14] <camelia> rakudo-moar f8b346: OUTPUT«42␤»

[17:14] <brokenchicken> hehe

[17:15] <TimToady> we asked for easier to optimize, not harder... :P

[17:17] <jnthn> Hmm, think I've found where :i <[A..F]>**2 ends up generating a bad NFA

[17:19] <dogbert17> heh, S32-io/IO-Socket-INET.t has never worked properly for me since my $*DISTRO.name is ubuntu not linux

[17:20] * TimToady maintains a cordial hatred for case insensitivity...

[17:24] <[Coke]> my least favorite CI problem is Cold Fusion's casual disregard for case on Struct keys. (which is fine if you're a standalone app that never interacts with other web services or javascript.) (and by fine I mean AAAAIGH)

[17:24] <dogbert17> m: grammar Grammar::Foo { rule TOP { 'z' | <unicode_escape> }; token unicode_escape { :i <[0..9a..f]> ** 4 }; };  my $res = Grammar::Foo.parse( "1234abcd" ) # TimToady mystery

[17:24] <camelia> rakudo-moar f8b346: OUTPUT«(signal SEGV)»

[17:24] <ilmari> m: dd [ $*DISTRO.name, $*DISTRO.version, $*DISTRO.release ]

[17:24] <camelia> rakudo-moar f8b346: OUTPUT«["opensuse", v13.2.Harlequin, "13.2"]␤»

[17:25] <ilmari> shouldn't .version and .release be the other way around?

[17:25] <brokenchicken> hm, on my box I get ["linux", v3.2.0.23.generic, "unknown"]

[17:26] <brokenchicken> And on another box: ["debian", v8.jessie, "8"]

[17:27] <brokenchicken> And on another boix: ["mswin32", v6.3, "unknown"]

[17:27] <brokenchicken> And on another box: ["debian", v7.wheezy, "7"]

[17:29] <brokenchicken> Hm, lsb_release -a gives me "7.2" for "Release:" on that last one

[17:29] <brokenchicken> and Windows7 is really 6.3? I've been cheated!

[17:30] <jnthn> dogbert17: I've fixed the SEGV on that one, it's just that if I commit that fix then we'll fail a spectest :)

[17:31] <jnthn> ('cus it catches a bad NFA we make in a test)

[17:31] <ilmari> looking at Distro.BUILD, on linux it's putting the numeric one (VERSION_ID from /etc/os-release or Release: from lsb_release -a) in Str $.release and the the free-text one (VERSION from /etc/os-release or Description: from lsb_release -a) in  Version $.version,

[17:35] <dogbert17> jnthn++ you're way to fast for me :)

[17:35] <jnthn> I've got a fix in the NFA builder too that fixes the grammar in the RT. That's the good news.

[17:35] <jnthn> Bad news is that we still get a spectest failure

[17:35] <jnthn> After the added validation in Moar

[17:35] <jnthn> Meaning that we misconstruct the NFA in some other place too

[17:37] <Geth> roast: dogbert17++ created pull request #227: Test moarvm 234

[17:37] <Geth> roast: review: https://github.com/perl6/roast/pull/227

[17:48] <brokenchicken> m: $*DISTRO.^methods.say

[17:48] <camelia> rakudo-moar f8b346: OUTPUT«(BUILD cur-sep Str gist release is-win path-sep name auth version signature desc)␤»

[17:49] <ilmari> m: dd $*DISTRO

[17:49] <camelia> rakudo-moar f8b346: OUTPUT«Distro opensuse = Distro.new(release => "13.2", is-win => Bool::False, path-sep => ":", name => "opensuse", auth => "https://opensuse.org/", version => v13.2.Harlequin, signature => Blob, desc => "2017-01-31T18:49:09.293568+01:00")␤»

[17:50] <Geth> roast: db09cd9fe2 | dogbert17++ | S32-io/IO-Socket-INET.t

[17:50] <Geth> roast: Test moarvm 234 (#227)

[17:50] <Geth> roast:

[17:50] <Geth> roast: * Add ubuntu as a dist

[17:50] <Geth> roast:

[17:50] <Geth> roast: * Add test for MoarVM #234

[17:50] <Geth> roast: review: https://github.com/perl6/roast/commit/db09cd9fe2

[17:51] <ilmari> dogbert17: that's not enough, any linux with /etc/os-release or lsb_release will have a more specific $*DISTRO.name

[17:52] <Geth> roast: 68a5c63f2f | (Zoffix Znet)++ | S32-io/IO-Socket-INET.t

[17:52] <Geth> roast: Add `debian` to list of OSes

[17:52] <Geth> roast: review: https://github.com/perl6/roast/commit/68a5c63f2f

[17:53] <ilmari> it would be nice to know if a distro is linux regardless of the name

[17:53] <brokenchicken> That kinda sucks that we apparently don't have a way to $^O eq 'linux'

[17:53] <brokenchicken> yeah

[17:53] <ilmari> m: say $*VM.config<osname>

[17:53] <camelia> rakudo-moar f8b346: OUTPUT«linux␤»

[17:53] <brokenchicken> oh cool

[17:53] <ilmari> (which is what Distro keys off to check /etc/os-release  or `lsb_release`

[17:53] <ilmari> )

[17:54] <ilmari> m: say $*VM.config<osvers> # kernel version, as opposed to distro version

[17:54] <camelia> rakudo-moar f8b346: OUTPUT«3.16.7-35-default␤»

[17:54] <brokenchicken> j: say $*VM.config<osname>; say $*VM.config<osvers>

[17:54] <camelia> rakudo-jvm fb4f16: OUTPUT«(Any)␤(Any)␤»

[17:54] <brokenchicken> heh

[17:55] <ilmari> s: Distro, "BUILD"

[17:55] <SourceBaby> ilmari, Sauce is at https://github.com/rakudo/rakudo/blob/f8b3469/src/core/Distro.pm#L11

[17:55] <brokenchicken> j: dd [ $*DISTRO.name, $*DISTRO.version, $*DISTRO.release ]

[17:55] <camelia> rakudo-jvm fb4f16: OUTPUT«["opensuse", v13.2.Harlequin, "13.2"]␤»

[17:55] <ilmari> j: dd [ $*VM.properties<os.name>, $VM.properties.<os.version> ]

[17:55] <camelia> rakudo-jvm fb4f16: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Variable '$VM' is not declared␤at <tmp>:1␤------> 3dd [ $*VM.properties<os.name>, 7⏏5$VM.properties.<os.version> ]␤»

[17:56] <ilmari> j: dd [ $*VM.properties<os.name>, $*VM.properties<os.version> ]

[17:56] <camelia> rakudo-jvm fb4f16: OUTPUT«["Linux", "3.16.7-42-default"]␤»

[18:00] <jnthn> m: grammar Oops { token TOP { <?> | <.xdigit> ** 1..2 <.xdigit> } }; Oops.subparse('aaa');

[18:00] <camelia> rakudo-moar f8b346: ( no output )

[18:00] <jnthn> That also makes a bad NFA

[18:00] <jnthn> m: grammar Oops { token TOP { <?> | <.xdigit> ** 1..2 <.xdigit> } }; Oops.subparse('aaa') for ^1000;

[18:00] <camelia> rakudo-moar f8b346: ( no output )

[18:00] <jnthn> Though won't segv for some reason or other :)

[18:01] <brokenchicken> m: grammar Oops { token TOP { <?> | <.xdigit> ** 1..2 <.xdigit> } }; Oops.subparse('aaa') for ^1000000;

[18:01] <camelia> rakudo-moar f8b346: ( no output )

[18:02] <jnthn> m: grammar Oops { token TOP { <?> | <.unknown> ** 1..2 <.unknown> } }; Oops.subparse('aaa') for ^1000;

[18:02] <camelia> rakudo-moar f8b346: ( no output )

[18:02] <jnthn> That also produces a bad NFA

[18:02] <jnthn> xdigit doesn't have an NFA representation, it turns out

[18:03] <jnthn> Which may well be a bug in of itself

[18:06] <jnthn> oh wait, that doesn't even matter

[18:07] <jnthn> m: grammar Oops { token TOP { <?> | 'a' ** 1..2 'a' } }; Oops.subparse('aaa'); # also a bad NFA

[18:07] <camelia> rakudo-moar f8b346: ( no output )

[18:08] <TimToady> m: grammar Oops { token TOP { <?> | 'a' ** 1..2 'a' } }; say Oops.subparse('aaa');

[18:08] <camelia> rakudo-moar f8b346: OUTPUT«｢aaa｣␤»

[18:10] <jnthn> TimToady: It produces an NFA with an edge that goes to state 0, which doesn't exist, fwiw

[18:10] <TimToady> which one, the <.xdigit>?

[18:11] <jnthn> No, that 'a' ** 1..2 'a' one

[18:11] <TimToady> the 'a' one works if you say it ^^^

[18:11] <jnthn> Yeah

[18:11] <jnthn> There's an EPSILON edge

[18:11] <jnthn> It seems

[18:11] <jnthn> That goes to 0

[18:12] <jnthn> m: grammar Oops { token TOP { <?> | 'a' ** 1..2 'a' } }; say Oops.subparse('ab')

[18:12] <camelia> rakudo-moar f8b346: OUTPUT«｢｣␤»

[18:12] <TimToady> m: grammar Oops { token TOP { <?> | 'a' ** 1..2 'a' } }; say Oops.subparse('aab');

[18:12] <camelia> rakudo-moar f8b346: OUTPUT«｢｣␤»

[18:13] <jnthn> https://gist.github.com/jnthn/157808c456badeea026b3075db4a80e1

[18:13] <jnthn> That's the NQP_NFA_DEB output

[18:14] <TimToady> weird

[18:14] <jnthn> That 0 EPSILON is the problem one, I think

[18:14] <jnthn> m: grammar Oops { token TOP { <?> | 'a' ** 1..2 'b' } }; say Oops.parse('ab')

[18:14] <camelia> rakudo-moar f8b346: OUTPUT«Nil␤»

[18:14] <TimToady> it oughta turn into 'a' 'a'? more or less

[18:14] <jnthn> m: grammar Oops { token TOP { 'a' ** 1..2 'b' } }; say Oops.parse('ab')

[18:14] <camelia> rakudo-moar f8b346: OUTPUT«｢ab｣␤»

[18:14] <jnthn> Ah, I think that shows the bug

[18:15] <jnthn> Suspect valgrind would whine about it too

[18:15] <TimToady> how is that one a bug?  'ab' is a valid parse

[18:16] <TimToady> oh, on the earlier one

[18:19] <jnthn> Yeah, the one it gave Nil for, wrongly

[18:21] * TimToady wonders how much syntax-munging module code out there depends on unwarranted chumminess with dynvars

[18:22] <Geth> geth: f3eec4957b | (Zoffix Znet)++ | 2 files

[18:22] <Geth> geth: Report all authors when we don't print full commits

[18:22] <Geth> geth: review: https://github.com/perl6/geth/commit/f3eec4957b

[18:30] <TimToady> well, at least roast tests for none of %*LANG, %*PRAGMAS, or $*ACTIONS, so I suppose we can break any such modules with impunity :)

[18:33] <Geth> ¦ geth: 4d9365aeb5 | (Zoffix Znet)++ | lib/Geth/Plugin/GitHub.pm6

[18:33] <Geth> ¦ geth: Fix OCD

[18:33] <Geth> ¦ geth: review: https://github.com/perl6/geth/commit/4d9365aeb5

[18:38] <jnthn> Specteting what is hopefully a correct fix for the NFA thing

[18:40] <TimToady> jnthn: what does the nqp equivalent of "$cursor but role :: [$a] { method actions { $a } }" look like?

[18:41] <jnthn> but, not does?

[18:41] <jnthn> Lemme find an example

[18:41] <jnthn> Oh, actually the role startstop right at the top of src/Perl6/Grammar

[18:42] <TimToady> oh, right

[18:42] <jnthn> I don't think we do anonymous roles in NQP, but you can lexically scope it and give it a name

[18:42] <jnthn> And then self.HOW.mixin(self, stop.HOW.curry(stop, $stop)) for exampoe

[18:42] <jnthn> But that is "does" rather than "but"

[18:42] <TimToady> I think I need non-mutating for this

[18:42] <jnthn> For but, just nqp::clone first

[18:43] <jnthn> my $foo := nqp::clone($cursor)

[18:43] <TimToady> nod

[18:43] <jnthn> $foo.HOW.mixin($foo, TheRole.HOW.curry(TheRole, $a)) or so

[18:43] <TimToady> at the moment my patch is attempting to, er, patch all the returned $!actions values, which is fragile

[18:44] <TimToady> and at the statement level it has to both rebless and set $!actions, so I'd like to get that back to a simple rebless

[18:44] <TimToady> and save the cursor storage currentlly used (in my patch) for $!actions

[18:45] <TimToady> and eventually do something similar for LANG and PRAGMA changes

[18:45] <TimToady> so that the type of the cursor really does carry the current language, not just the current set of methods

[18:46] <Geth> ¦ nqp: 9b57e4f83e | (Jonathan Worthington)++ | src/QRegex/NFA.nqp

[18:46] <Geth> ¦ nqp: Fix NFA construction for :i charrange.

[18:46] <Geth> ¦ nqp:

[18:46] <Geth> ¦ nqp: Prior to the fix, it would produce zeroed states.

[18:46] <Geth> ¦ nqp: review: https://github.com/perl6/nqp/commit/9b57e4f83e

[18:46] <Geth> ¦ nqp: 485fce6d06 | (Jonathan Worthington)++ | src/QRegex/NFA.nqp

[18:46] <Geth> ¦ nqp: Fix NFA generation for x ** 1..2.

[18:46] <Geth> ¦ nqp:

[18:46] <Geth> ¦ nqp: Prior to this, it would produce an epsilon to a zero state, which

[18:46] <Geth> ¦ nqp: would lead to wrong rejection.

[18:46] <Geth> ¦ nqp: review: https://github.com/perl6/nqp/commit/485fce6d06

[18:46] <TimToady> hopefully the mixins are not the slow part of categoricals...

[18:47] <jnthn> Hmmm :

[18:47] <jnthn> They're at lesat somewhat responsible, but there's an amount of catching...

[18:47] <jnthn> We use the mechanism for start/stop things and survive it :)

[18:48] <TimToady> recalculating NFAs has gotta be a bigger part of it, I'd think

[18:48] <TimToady> though if we have a per-type cache of NFA, this could trigger that as well

[18:49] <Geth> ¦ rakudo: ronaldxs++ created pull request #1008: New fancier fudgeandrun

[18:49] <Geth> ¦ rakudo: review: https://github.com/rakudo/rakudo/pull/1008

[18:49] <jnthn> Yeah, that's what I'm fearing

[18:49] <jnthn> Well, we can try it and see

[18:49] <jnthn> Can always hack some kind of "it's OK to steal the cache in this case" thing

[18:49] <TimToady> well, the per-type is probably not quite the right peg, anyway

[18:49] <jnthn> That also

[18:50] <TimToady> yes, we need to reduce, reuse, and recycle :)

[18:50] <Geth> ¦ nqp: 501c53f2ca | (Jonathan Worthington)++ | tools/build/MOAR_REVISION

[18:50] <Geth> ¦ nqp: Bump MOAR_REVISION socket, NFA fixes.

[18:50] <Geth> ¦ nqp: review: https://github.com/perl6/nqp/commit/501c53f2ca

[18:50] <Geth> ¦ nqp: version bump brought these changes: https://github.com/MoarVM/MoarVM/compare/2017.01-13-g4aab5064...2017.01-25-g70d4bd5

[18:51] <TimToady> but that probably means method dispatch to the "current language" again somehow

[18:51] <jnthn> Goodness, nearly 8pm and I didn't start preparing dinner yet

[18:51] <TimToady> such that new NFA needs are reflected by mixed-in methods

[18:52] <TimToady> that might well speed up categoricals as well, which iiuc will force recalculation of all NFAs, not just the category's NFA

[18:53] <TimToady> (in the current caching system)

[18:53] <TimToady> but, hmm, we have to know the dependencies too... :/

[18:57] <Geth> ¦ rakudo/nom: 9ed4449db5 | (Jonathan Worthington)++ | tools/build/NQP_REVISION

[18:57] <Geth> ¦ rakudo/nom: Bump NQP_REVISION, which also bumps MOAR_REVISION.

[18:57] <Geth> ¦ rakudo/nom:

[18:57] <Geth> ¦ rakudo/nom: * Fix leaks and an invalid read in synchronous sockets on errors

[18:57] <Geth> ¦ rakudo/nom:   (jnthn++)

[18:57] <Geth> ¦ rakudo/nom: * Fix NFA generation for the constructs `x ** 1..2` and `:i <[A..Z]>`,

[18:57] <Geth> ¦ rakudo/nom:   and harden NFA processing in MoarVM so as to not read out of bounds

[18:57] <Geth> ¦ rakudo/nom:   (jnthn++)

[18:57] <Geth> ¦ rakudo/nom: <…commit message has 5 more lines…>

[18:57] <Geth> ¦ rakudo/nom: review: https://github.com/rakudo/rakudo/commit/9ed4449db5

[18:57] <Geth> ¦ rakudo/nom: version bump brought these changes: https://github.com/perl6/nqp/compare/2017.01-15-g7cbefd90...2017.01-46-g501c53f

[18:58] <TimToady> jnthn: if you mix in a named role that was mixed in before, is it currently a no-op, or does it reorder dispatch to give the new (old) mixin's methods priority?

[18:58] <jnthn> TimToady: Yes, the dependency tracking is the trickier bit that we need for this :)

[18:58] <jnthn> Each mixin adds a new level of inheritance

[18:59] <jnthn> There's no "do we already have this" check

[18:59] <jnthn> So you'll always see the method of the latest mixin

[19:00] <jnthn> m: role R[$a] { method m() { say $a } }; my $o = Mu.new; $o does R[1]; $o.m; $o does R[2]; $o.m

[19:00] <camelia> rakudo-moar f8b346: OUTPUT«1␤2␤»

[19:00] <jnthn> Think that's what you're asking

[19:00] <jnthn> Same semantics in NQP

[19:00] <brokenchicken> m: role R[$a] { method m() { say $a } }; my $o = Mu.new; $o does R[1]; $o.m; $o does R[2]; $o.m; say $o.^roles

[19:00] <camelia> rakudo-moar f8b346: OUTPUT«1␤2␤((R[Int]) (R[Int]))␤»

[19:02] <jnthn> m: role R[$a] { method m() { callsame; say $a } }; my $o = Mu.new; $o does R[1]; $o.m; $o does R[2]; $o.m

[19:02] <camelia> rakudo-moar f8b346: OUTPUT«1␤1␤2␤»

[19:02] <TimToady> so maybe we'd need a (mixed-in) method that returns the type to cache the NFA under, so we know which mixin levels mutate the NFA and which don't

[19:03] * TimToady suspects TANSTAAFL here...

[19:06] <TimToady> well, we're already mixing in for categoricals, so it'd be easy to put a method there that says "It's me! It's me!"

[19:08] <jnthn> Something like that, yeah

[19:08] <jnthn> Righty, really off to cook

[19:08] <jnthn> Will add the tests for the stuff I just commited above later

[19:12] <TimToady> unfortunately, some action mixins might change the structure of the tree that will eventually make the NFA, so we'd need to be able to distinguish those from action mixins that don't influence the NFA

[19:18] <TimToady> well, let's get the mutable cursor version working first as a baseline

[19:25] <Geth> ¦ rakudo/nom: 908621688b | (Ronald Schmidt)++ | t/fudgeandrun

[19:25] <Geth> ¦ rakudo/nom: fancier and hopefully friendlier fudgeandrun

[19:25] <Geth> ¦ rakudo/nom: review: https://github.com/rakudo/rakudo/commit/908621688b

[19:25] <Geth> ¦ rakudo/nom: 084cae1443 | (Ronald Schmidt)++ | t/fudgeandrun

[19:25] <Geth> ¦ rakudo/nom: fudgeandrun port to windows

[19:25] <Geth> ¦ rakudo/nom: review: https://github.com/rakudo/rakudo/commit/084cae1443

[19:25] <Geth> ¦ rakudo/nom: 0152316f56 | (Zoffix Znet)++ | t/fudgeandrun

[19:25] <Geth> ¦ rakudo/nom: Merge pull request #1008 from ronaldxs/new-fancier-fudgeandrun

[19:25] <Geth> ¦ rakudo/nom:

[19:25] <Geth> ¦ rakudo/nom: New fancier fudgeandrun

[19:25] <Geth> ¦ rakudo/nom: review: https://github.com/rakudo/rakudo/commit/0152316f56

[19:32] <dogbert17> brokenchicken: should we change S32-io/IO-Socket-INET.t to use Ilmari's suggestion instead?

[19:33] <brokenchicken> dogbert17: which was it, the linux distname thing? Yeah. Be sure to include both moarvm and JVM versions since apparently the keys where that info is at differ

[19:39] <[Tux]> This is Rakudo version 2017.01-127-g0152316f5 built on MoarVM version 2017.01-25-g70d4bd53

[19:39] <[Tux]> csv-ip5xs        2.787

[19:39] <[Tux]> test            12.223

[19:39] <[Tux]> test-t           4.869

[19:39] <[Tux]> csv-parser      13.699

[19:39] <[Tux]> :)

[19:39] <[Tux]> second run was https://pbs.twimg.com/media/C3bshFkWcAAXEGe.jpg

[19:39] <[Tux]> 4.878

[19:39] <brokenchicken> wooooooooooo \o/

[20:06] <[Coke]> jnthn: perl6-doc's coke/bughunt branch still dying with weird Promise errors as of 2017.01-108-g7e98504

[20:06] <[Coke]> Looks like the segfaults might be gone.

[20:11] <mr_ron> brokenchicken: just read your comment on moving fudgeandrun to roast.  Understand the concern but think issue of simplifying running roast tests still valid.  What about an 'impl' option for fudgeandrun similar to 'backend=(moar|jvm) but for other implementations/backends?  Are there other implementations being actively tested on roast?

[20:13] <brokenchicken> mr_ron: I know of one active closed-source impl but IIRC they aren't yet at roast-testing stage. IMO it's fine to just add a --compiler option that defaults to rakudo. I dunno what pmichaud or other @LARRYs would think about it :)

[20:29] <[Coke]> fudge already takes an implementation name - this script can default to rakudo and pass it through unchanged, that's fine

[20:36] <mr_ron> Coke: familiar now a bit with fudgeandrun but not following what you said.  The "fudge" program mentions a .spec_config file but I haven't actually seen one of those.

[20:37] <brokenchicken> mr_ron: FWIW, in our main Configure.pl we support perl's as early as 5.10.1; In case you wanted to maintain that in fudgerun too (I noticed a s///r, which is from 5.14)

[20:38] <mr_ron> OK will fix - hopefully today.

[20:42] <[Coke]> mr_ron: don't think rakudo uses that, no. but fudge still takes an "implementation" parameter to know what it should be fudging for.

[20:42] <[Coke]> a generic fudgeandrun tool should do the same.

[20:47] <mr_ron> fudgeandrun takes a backend and the suggestion was to add a compiler.  So we can do compiler.backend.  In the case of rakudo the backend default is parsed from 'perl6 --version'.  For other compilers the backend can default to '' so $impl would be just the compiler but they could add a backend too.

[21:06] <mr_ron> Coke: fudgeandrun cares a bit about what kind compiler it is running since it has to run it at some point.  fudge doesn't run the implementation.  I can do either or both of a --compiler and/or --impl but for now compiler seems enough.  Do you still feel we need --impl?

[21:11] <[Coke]> ... fudge absolutely cares about the implementation, or else how does it know what to fudge?

[21:11] <[Coke]> not backend. implementaiton.

[21:11] <[Coke]> so, 'rakudo' or 'rakudo.jvm' or 'pugs' or 'niecza'

[21:12] <[Coke]> if the tool lives in rakudo, we can take shortcuts. if it lives in roast, we cannot (although it is acceptable to have rakudo as a well documented default)

[21:12] <[Coke]> I mean, maybe we're agreeing.

[21:13] <[Coke]> I leave it to you; if brokenchicken and I didn't explain our concerns well enough, we'll comment on the PR.

[21:24] <mr_ron> with an added --compiler option fudgeandrun would continue to make implementation=compiler[.backend]? with compiler defaulting to rakudo (it wouldn't be hard to check).  So fudgeandrun sets an implementation it just conceptually divides it into two peices - compiler and backend.  Adding another --impl beyond that seems more complicated than needed.

[21:27] <mr_ron> Some documentation in fudgeandrun that implementation=compiler[.backend]? might help clarify

[21:29] <dogbert17> brokenchicken: you there?

[21:31] <dogbert17> anyone knows what the option --keep-exit-code is used for by harness5 ? I can't see that the program supports that option but I might be blind

[21:36] <mr_ron> --keep-exit-code is used by fudge.  I don't see it referenced directly in t/harness5 in the rakudo rep

[21:40] <dogbert17> mr_ron: if I run, e.g. 'make t/spec/S32-num/rand.t' the command that is actually run (it's written out on stdout) is

[21:40] <dogbert17> /usr/bin/perl t/harness5 --fudge --moar --keep-exit-code --verbosity=1 t/spec/S32-num/rand.t

[21:41] <dogbert17> it looks as if --keep-exit-code is sent to harness5

[21:43] <dogbert17> or is it passed through somehow

[21:44] <dogbert17> yes it is, sorry for the noise

[21:58] <Geth> ¦ nqp/master: 14 commits pushed by (Pawel Murias)++

[21:58] <Geth> ¦ nqp/master: review: https://github.com/perl6/nqp/compare/501c53f2ca...5490db6fe4

[22:14] <brokenchicken> dogbert17: I am now.

[22:15] <brokenchicken> dogbert17: the --keep-exit-code is passed to t/spec/fudgeall IIRC

[22:15] <brokenchicken> and there it's used to output proper exit code instead of a failing one. And I've no idea why that even exists

[22:26] <[Coke]> keep-exit-code was added in 2008 to allow fudged but otherwise passing files to report pass. (otherwise they failed because they weren't "clean")

[22:26] <[Coke]> https://github.com/perl6/roast/commit/1a3b0cc78b93cd91431a9e1448f823b63b1891de - added by [particle]

[22:27] <[Coke]> (and it was originally part of the pugs svn repo, is how old that is)

[22:27] <[Coke]> and i added .spec_config support (https://github.com/perl6/roast/commit/301db81ba3c0d002d08d9f754c9af2b9fe38d285)

[22:27] <[Coke]> must have been when dealing with the pugs/niecza/rakudo simultaneously.

[22:30] <Geth> ¦ roast: bb73a8947a | (Jonathan Worthington)++ | S05-metasyntax/longest-alternative.t

[22:30] <Geth> ¦ roast: Tests to cover RT #130637.

[22:30] <Geth> ¦ roast: review: https://github.com/perl6/roast/commit/bb73a8947a

[22:30] <synopsebot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=130637

[22:32] <mr_ron> Is there an actual .spec_config file to look at or documentation? I checked the niecza repo and didn't see anything ...

[22:38] <mr_ron> anyone - does .spec_config have a known standard format?

[22:43] <jnthn> There we go, that's RT #130637 sorted.

[22:43] <synopsebot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=130637

[22:45] * lizmat wonders if that fixes HARNESS_TYPE=6

[22:45] <lizmat> as that is also using a relatively small grammar to parse TAP

[22:56] <jnthn> No, this was pretty much reliable SEGV every single time if it happened. :)

[22:56] <jnthn> And needed the two very specific constructs in the tests

[22:56] <jnthn> Or it just didn't match at all

[22:56] <jnthn> So, unlikely, sadly

[22:58] <Geth> ¦ nqp: 34a05465e8 | (Zoffix Znet)++ | docs/ops.markdown

[22:58] <Geth> ¦ nqp: Add rudimentary docs for `locallifetime`

[22:58] <Geth> ¦ nqp:

[22:58] <Geth> ¦ nqp: https://irclog.perlgeek.de/perl6/2017-01-31#i_14021582

[22:58] <Geth> ¦ nqp: review: https://github.com/perl6/nqp/commit/34a05465e8

[22:58] * brokenchicken spots a week-old https://github.com/perl6/nqp/pull/344  mergeable?

[22:59] <brokenchicken> nfa debugger negative offsets

[22:59] <lizmat> jnthn: too bad  :-)

[23:06] <jnthn> brokenchicken: I think that was fixing debug output...can be merged I think

[23:06] <jnthn> Sleep time for me. 'night o/

[23:07] <Geth> ¦ nqp: 0e8d180c56 | (Timo Paulssen)++ | src/QRegex/NFA.nqp

[23:07] <Geth> ¦ nqp: make nfa debugger resistant to negative indents

[23:07] <Geth> ¦ nqp:

[23:07] <Geth> ¦ nqp: in at least one case $ind reached far into the negatives, and

[23:07] <Geth> ¦ nqp: before this patch it'd just straight-up crash during debug output.

[23:07] <Geth> ¦ nqp: review: https://github.com/perl6/nqp/commit/0e8d180c56

[23:07] <Geth> ¦ nqp: 213f551568 | (Zoffix Znet)++ | src/QRegex/NFA.nqp

[23:07] <Geth> ¦ nqp: Merge pull request #344 from perl6/robust_dentin_dentout

[23:07] <Geth> ¦ nqp:

[23:07] <Geth> ¦ nqp: make nfa debugger resistant to negative indents

[23:07] <Geth> ¦ nqp: review: https://github.com/perl6/nqp/commit/213f551568

[23:07] <brokenchicken> night

[23:10] <lizmat> jnthn: night!

[23:19] <Geth> ¦ rakudo/nom: b9d9279a6d | (Elizabeth Mattijsen)++ | src/core/Rakudo/Iterator.pm

[23:19] <Geth> ¦ rakudo/nom: Some R:It.Rotor fixes

[23:19] <Geth> ¦ rakudo/nom:

[23:19] <Geth> ¦ rakudo/nom: - fix off-by-one error in legality of negative gaps

[23:19] <Geth> ¦ rakudo/nom: - fix off-by-one error in error reporting of illegal negative gap

[23:19] <Geth> ¦ rakudo/nom: - remove superfluous call to .key, which we already did before

[23:19] <Geth> ¦ rakudo/nom: review: https://github.com/rakudo/rakudo/commit/b9d9279a6d

[23:28] <[Coke]> mr_ron: I see no remnants of .spec_config. Feel free to remove it.

[23:28] <[Coke]> (checked in a few repos)
