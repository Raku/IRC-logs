[00:48] <Zoffix> AlexDaniel: haha, that looks super uncomforttable

[00:49] <AlexDaniel> Zoffix: better than staring outside :)

[00:49] <AlexDaniel> Zoffix: but yes, it is way more comfortable if you manage to find a seat

[00:50] <timotimo> ugh, using syncthing on a git repository but ignoring the .git is also super bad :\

[00:55] <Zoffix> wtf that `with` there was just to check for Failures, so it can be rewritten as nqp::istype(..., Failure)

[00:55] <Zoffix> s/wtf/FWIW/

[00:55] <timotimo> hm, but changing it to .defined is no functional change ... maybe it's fine to do the failure thing, though

[00:56] <timotimo> when we let undefined values through, we'll get an error from ==, though?

[00:56] <timotimo> m: Numeric == 1e5

[00:56] <camelia> rakudo-moar e0e080: OUTPUT: ¬´WARNINGS for <tmp>:‚ê§Useless use of "==" in expression "Numeric == 1e5" in sink context (line 1)‚ê§Use of uninitialized value of type Numeric in numeric context‚ê§  in block <unit> at <tmp> line 1‚ê§¬ª

[00:56] <AlexDaniel> ‚Äús/wtf/FWIW/‚Äù XD

[00:56] <timotimo> not error, of course

[00:58] <MasterDuke_> does anyone have an opinion whether https://github.com/rakudo/rakudo/blob/nom/src/core/IO/Path.pm#L705-L708 looks better than just `IntStr.new((my int $mode = nqp::stat($!abspath, nqp::const::STAT_PLATFORM_MODE) +& 0o7777), sprintf(q|%04o|, $mode))`

[01:00] <MasterDuke_> timotimo: `a` is already defined according to the signature. could `a.Numeric` ever be undefined?

[01:03] <timotimo> sure

[01:03] <timotimo> m: say "hello".Numeric

[01:03] <camelia> rakudo-moar e0e080: OUTPUT: ¬´Cannot convert string to number: base-10 number must begin with valid digits or '.' in '3‚èè5hello' (indicated by ‚èè)‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§Actually thrown at:‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[01:04] <Zoffix> m: say defined "hello".Numeric

[01:04] <camelia> rakudo-moar e0e080: OUTPUT: ¬´False‚ê§¬ª

[01:05] <Zoffix> m: say defined class { method Numeric { Int } }.Numeric

[01:05] <camelia> rakudo-moar e0e080: OUTPUT: ¬´False‚ê§¬ª

[01:05] <MasterDuke_> ugh, let's pretend i never asked that

[01:05] <Zoffix> :D

[01:06] <Zoffix> AlexDaniel: do you program Perl 6 on that laptop?

[01:08] <MasterDuke_> AlexDaniel: yeah, i was wondering if you were trying to start the next trend like planking. will it go viral, "the most awkward Perl6 programming situation challenge"?

[01:09] <timotimo> be like the dude who's gaffer-taped to the ceiling

[01:13] <AlexDaniel> Zoffix: yes

[01:14] <Zoffix> \o/

[01:22] <AlexDaniel> MasterDuke_: that sounds pretty cool

[01:38] <BenGoldberg> I've got a silly question.  I know in C, one can provide optimization hints with things like __builtin_expect().  Is there, or will there be, a way for perl6 users to provide optimization hints?

[01:38] <BenGoldberg> Not necessarily that specific hint, but in general...

[01:39] <Zoffix> You already can with `is pure`; it means a sub can be constant-folded at compile time

[01:40] <Zoffix> And all the autothreaded stuff is a hint the compiler may use more then one thread to execute stuff (though ATM it's unimplemented)

[01:41] <MasterDuke_> is cached for memoization

[01:46] <AlexDaniel> m: sub foo($a) is pure { rand }; say foo(42); say foo(42)

[01:46] <camelia> rakudo-moar e0e080: OUTPUT: ¬´0.213078763462177‚ê§0.592591903192249‚ê§¬ª

[01:46] <AlexDaniel> that's probably misuse :)

[01:46] <Zoffix> m: sub foo($a) is pure { rand }; for ^3 { say foo(42) }

[01:46] <camelia> rakudo-moar e0e080: OUTPUT: ¬´0.792531094789826‚ê§0.792531094789826‚ê§0.792531094789826‚ê§¬ª

[01:46] <BenGoldberg> How valuable would it be for rakudo to be able to automatically transform something like this: multi sub foo(Bool $b) { if( SPECIALIZE($B) ) { return stuffiftrue() } else { return stuffiffalse() } } into multi sub foo(True) { stuffiftrue() }; multi sub foo(False) { stuffiffalse() }

[01:46] <AlexDaniel> Zoffix: right, that's what it means

[01:46] <AlexDaniel> right, right

[01:46] * geekosaur thinsk more helpful would be boxing analysis.. which he would someday like to tackle

[01:46] <BenGoldberg> m: sub foo($a) is pure { rand }; for ^3 { say foo(42) }; for ^3 { say foo(42) }

[01:46] <camelia> rakudo-moar e0e080: OUTPUT: ¬´0.784828960315073‚ê§0.784828960315073‚ê§0.784828960315073‚ê§0.922750986110419‚ê§0.922750986110419‚ê§0.922750986110419‚ê§¬ª

[01:46] * geekosaur scans back and wonders what Ashenzari has to do with anything :p

[01:50] <geekosaur> I mean, currently I think you could do it for, say, a loop, but not over an entire sub

[01:50] <MasterDuke_> i think jnthn and timotimo have commented that (un)boxing had a lot of optimization potential

[01:54] <geekosaur> it does, yes, which is why I'm interested. my two worries are the one I mentioned, and that I suspect brrt will have a heart attack >.>

[01:55] <geekosaur> (currently things generate code in place, which would need to change because later code might flip something that looks like an unboxing win into a lose)

[02:00] <MasterDuke_> geekosaur: i know nothing about boxing analysis, have you done it before?

[02:01] <geekosaur> not actively but in this case that's not much of a problem. I understand it reasonably well though

[02:02] <geekosaur> as long as we're not getting too jiggy with it e.g. there are cases where you might win from having both boxed and unboxed versions of something sitting around, trading space and update performance for read performance, but that gets rather more complicated

[02:03] <MasterDuke_> would it be added to spesh, the jit, or its own thing?

[02:04] <geekosaur> seems to me it works best as part of code gen, which si why my earlier comment

[02:04] <MasterDuke_> ah, right

[02:05] <geekosaur> rewriting the generated code after the fact like spesh would be possible, but loses optimization opportunities: if you do it at a higher level, you can unbox over most of a program

[02:05] <geekosaur> I think that's pretty impossible with the way code gen currently works thougjh

[02:06] <geekosaur> so maybe the first version would go with spesh and be effectively peephole optimization

[02:10] <MasterDuke_> i'd take that

[03:29] <Zoffix> damn

[03:29] <Zoffix> perl6 -e "dd 'bar.txt'.IO.open(:w).lock(0x10 + 1)"  throws on Linux, but not on Windows :/

[03:33] * Zoffix rewrites the tests to use suckier exceptions

[03:34] <Zoffix> Seems X::IO::CannotLock + X::IO::Locked was too ambitious

[03:34] <mst> hm?

[03:36] <Zoffix> Well, I wanted to throw X::IO::CannotLock when the user asked for shared lock on fh opened in write, or exclusive for fh opened in read, but apparently on Windows that doesn't throw

[03:36] <Zoffix> (code for the nqp::lockfh op on MoarVM: https://github.com/MoarVM/MoarVM/blob/a8448142d8b49a742a6b167907736d0ebbae9779/src/io/syncfile.c#L303-L358 )

[03:37] <Zoffix> And X::IO::Locked for when asked for non-blocking lock and we couldn't get it

[03:45] <mst> ok, but surely you could change it so win32 does throw?

[03:46] <Zoffix> Probably.

[03:52] <Zoffix> ....

[03:53] <Zoffix> and .unlock on a non-locked handle doesn't throw on Linux but does throw on Windows -_-

[03:53] <Zoffix> ZofBot: day of opposites

[03:53] <ZofBot> Zoffix, } sub cmp-ok(Mu $got, $op, Mu $expected, $desc?) is export {

[03:53] <Zoffix> Unlocking seeks stuff? Or is it just a copy-pastaed text in error: https://github.com/MoarVM/MoarVM/blob/a8448142d8b49a742a6b167907736d0ebbae9779/src/io/syncfile.c#L371

[03:54] * Zoffix assumes the latter

[03:56] <mst> maybe https://github.com/baudehlo/node-fs-ext/blob/master/fs-ext.cc is helpful?

[04:04] <Zoffix> I think so.

[04:04] <Zoffix> I don't know C tho :}

[04:04] <mst> I only sort of know C

[04:04] <Zoffix> huggable: locking :is: https://github.com/baudehlo/node-fs-ext/blob/master/fs-ext.cc

[04:04] <huggable> Zoffix, Added locking as https://github.com/baudehlo/node-fs-ext/blob/master/fs-ext.cc

[04:04] <mst> like, I can make things that compile and *then* segfault

[04:04] <Zoffix> :)

[04:05] <mst> whereas I'm actually good at perl, which is why I can write pure perl code that segfaults *while* compiling

[04:05] <Zoffix> heh

[04:13] <Zoffix> "P6opaque: must compose X::Comp::AdHoc before allocating"  ugghh what's its problem? https://gist.github.com/zoffixznet/3f0183192c4fb4d8e2b8e9c58c6f226e

[04:18] <BenGoldberg> X::Comp::AdHoc.^compose, maybe?

[04:18] <Zoffix> ?

[04:20] <Zoffix> ah, OK. I forgot to change the .lock calls in core

[04:24] <Zoffix> nope, not it

[04:24] <Zoffix> god dammit

[04:31] <Geth> ¬¶ nqp/uncurse: 211b0f2ba3 | (Pawel Murias)++ | src/vm/moar/profiler/template.html

[04:31] <Geth> ¬¶ nqp/uncurse: Fix bitrot in moarvm profiler

[04:31] <Geth> ¬¶ nqp/uncurse: review: https://github.com/perl6/nqp/commit/211b0f2ba3

[04:31] <Geth> ¬¶ nqp/uncurse: 30a965887f | (Pawel Murias)++ | src/vm/js/Compiler.nqp

[04:31] <Geth> ¬¶ nqp/uncurse: [js] Stuff to fix nqp::p6initied

[04:31] <Geth> ¬¶ nqp/uncurse: review: https://github.com/perl6/nqp/commit/30a965887f

[04:31] <Geth> ¬¶ nqp/uncurse: 9063d0ec3f | TimToady++ | 2 files

[04:31] <Geth> ¬¶ nqp/uncurse: Merge branch 'master' into uncurse

[04:31] <Geth> ¬¶ nqp/uncurse: review: https://github.com/perl6/nqp/commit/9063d0ec3f

[04:32] <Geth> ¬¶ rakudo/uncurse: 6 commits pushed by (Elizabeth Mattijsen)++, (Timo Paulssen)++, TimToady++

[04:32] <Geth> ¬¶ rakudo/uncurse: c16cdb2ce7 | Bump NQP version for Allocations tab in profile fix

[04:32] <Geth> ¬¶ rakudo/uncurse: 354a4dbbda | Update ChangeLog for latest NQP bump

[04:32] <Geth> ¬¶ rakudo/uncurse: 17d34cdc91 | allow for faster Enum ~~ Enum

[04:32] <Geth> ¬¶ rakudo/uncurse: 89457f8d57 | make Numeric.ACCEPTS(Any) about 15% faster

[04:32] <Geth> ¬¶ rakudo/uncurse: e0e0800897 | accidentally committed wrong version

[04:32] <Geth> ¬¶ rakudo/uncurse: b7f0a665f1 | Merge branch 'nom' into uncurse

[04:32] <Geth> ¬¶ rakudo/uncurse: review: https://github.com/rakudo/rakudo/compare/89fd91c1ea...b7f0a665f1

[04:50] <Zoffix> it was due to has $.os-error; in the class; which is also present in the inherited-from X::IO

[04:53] <TimToady> Zoffix: lemme know when you're in a state that I can merge uncurse, cuz I'm now thinking it would better to get it into this release so we don't risk divergent nqp bootstraps (and to get the 1-2% performance boost)

[04:54] <TimToady> and it does seem fairly stable

[04:54] <TimToady> and it doesn't seem to be interfering with where you're working so far

[04:55] <Zoffix> TimToady: merge away :)

[04:55] <TimToady> ookay

[04:58] <Geth> ¬¶ nqp/master: 17 commits pushed by TimToady++, (Jonathan Worthington)++

[04:58] <Geth> ¬¶ nqp/master: review: https://github.com/perl6/nqp/compare/30a965887f...9063d0ec3f

[04:58] <Geth> ¬¶ rakudo/nom: 20 commits pushed by TimToady++

[04:58] <Geth> ¬¶ rakudo/nom: review: https://github.com/rakudo/rakudo/compare/e0e0800897...b7c036c082

[04:58] <Geth> ¬¶ rakudo/nom: version bump brought these changes: https://github.com/perl6/nqp/compare/2017.03-94-g30a9658...2017.03-111-g9063d0e

[04:59] <TimToady> done

[05:00] <TimToady> I just had visions of someone using the next Rakudo Star 3 months from now and depending on old Cursor/Match stuff...

[05:02] <TimToady> plus, lets me un-todo a test :)

[05:02] <Zoffix> \o/

[05:06] <Zoffix> m: dd Q:b:s|\$fh|

[05:06] <camelia> rakudo-moar e0e080: OUTPUT: ¬´5===SORRY!5=== Error while compiling <tmp>‚ê§Variable '$fh' is not declared‚ê§at <tmp>:1‚ê§------> 3dd Q:b:s|\7‚èè5$fh|‚ê§¬ª

[05:06] <Zoffix> :b doesn't enable backslashing of stuff like that?

[05:06] <TimToady> nope, just the usual suspects

[05:07] <TimToady> though arguably adding :s should add a backslasher for $

[05:10] <TimToady> m: say Cursor.WHAT

[05:10] <camelia> rakudo-moar e0e080: OUTPUT: ¬´(Cursor)‚ê§¬ª

[05:10] <TimToady> m: say Cursor.WHAT

[05:10] <camelia> rakudo-moar b7c036: OUTPUT: ¬´(Match)‚ê§¬ª

[05:11] <TimToady> Cursor is now just an alias to Match

[05:13] <Zoffix> m: my $fh = 42; put q:s|$fh|

[05:13] <camelia> rakudo-moar b7c036: OUTPUT: ¬´42‚ê§¬ª

[05:13] <Zoffix> m: my $fh = 42; put q:s|\$fh|

[05:13] <camelia> rakudo-moar b7c036: OUTPUT: ¬´\$fh‚ê§¬ª

[05:16] <Geth> ¬¶ roast: 6db316eaae | TimToady++ | S05-match/perl.t

[05:16] <Geth> ¬¶ roast: now pass two Match.perl roundtripping tests

[05:16] <Geth> ¬¶ roast: review: https://github.com/perl6/roast/commit/6db316eaae

[05:39] <Geth> ¬¶ roast: 4194755c19 | (Zoffix Znet)++ | S32-io/lock.t

[05:39] <Geth> ¬¶ roast: [io grant] Test IO::Handle.lock/.unlock

[05:39] <Geth> ¬¶ roast: review: https://github.com/perl6/roast/commit/4194755c19

[05:39] <Geth> ¬¶ rakudo/nom: 214198bfb2 | (Zoffix Znet)++ | 5 files

[05:39] <Geth> ¬¶ rakudo/nom: [io grant] Implement proper args for IO::Handle.lock

[05:39] <Geth> ¬¶ rakudo/nom: review: https://github.com/rakudo/rakudo/commit/214198bfb2

[05:50] <chatter29> hey guys

[05:50] <chatter29> allah is doing

[05:50] <chatter29> sun is not doing allah is doing

[05:50] <chatter29> to accept Islam say that i bear witness that there is no deity worthy of worship except Allah and Muhammad peace be upon him is his slave and messenger

[05:52] <Zoffix> No way! The Flying Spaghetti Monster is our true saviour!

[05:52] * Zoffix starts a holy war

[05:58] <Zoffix> Yey! I won.

[06:00] <Zoffix> ZOFFLOP: t/spec/S17-promise/nonblocking-await.t

[06:01] <Geth> ¬¶ rakudo/nom: 9a2446c94f | (Zoffix Znet)++ | src/core/IO/Path.pm

[06:01] <Geth> ¬¶ rakudo/nom: [io grant] Move Bool return value to signature

[06:01] <Geth> ¬¶ rakudo/nom:

[06:01] <Geth> ¬¶ rakudo/nom: As I recall a recentish commit doing the same elsehwere went it,

[06:01] <Geth> ¬¶ rakudo/nom: with the reasoning that the signature return is a bit faster.

[06:01] <Geth> ¬¶ rakudo/nom: review: https://github.com/rakudo/rakudo/commit/9a2446c94f

[06:20] <Zoffix> ZOFVM: Files=1241, Tests=133735, 111 wallclock secs (22.32 usr  3.29 sys + 2308.44 cusr 144.68 csys = 2478.73 CPU)

[06:31] <Zoffix> m: 'foo' ~~ /(.)/; say so $0

[06:31] <camelia> rakudo-moar 9a2446: OUTPUT: ¬´1‚ê§¬ª

[06:31] <Zoffix> bisect: 'foo' ~~ /(.)/; say so $0

[06:31] <bisectable6> Zoffix, Bisecting by output (old=2015.12 new=9a2446c) because on both starting points the exit code is 0

[06:32] <Zoffix> bisect: 'foo' ~~ /(.)/; say $0.^name

[06:32] <bisectable6> Zoffix, bisect log: https://gist.github.com/88d99014caf30866f54284704aff2cf8

[06:32] <bisectable6> Zoffix, There are 20 candidates for the first ‚Äúnew‚Äù revision. See the log for more details

[06:32] <bisectable6> Zoffix, On both starting points (old=2015.12 new=9a2446c) the exit code is 0 and the output is identical as well

[06:32] <bisectable6> Zoffix, Output on both points: ¬´Match¬ª

[06:32] <Zoffix> m: 'foo' ~~ /(.)/; say $0.^name

[06:32] <camelia> rakudo-moar 9a2446: OUTPUT: ¬´Match‚ê§¬ª

[06:32] <Zoffix> s: do { 'foo' ~~ /(.)/; $0 }, 'Bool', \()

[06:32] <SourceBaby> Zoffix, Something's wrong: ‚ê§ERR: No such method 'cando' for invocant of type 'NQPRoutine'‚ê§  in block  at /home/zoffix/services/lib/CoreHackers-Sourcery/lib/CoreHackers/Sourcery.pm6 (CoreHackers::Sourcery) line 26‚ê§  in sub sourcery at /home/zoffix/services/lib/CoreHackers-Sourcery/lib/CoreHackers/Sourcery.pm6 (CoreHackers::Sourcery) line 29‚ê§  in block <unit> at -e line 6‚ê§‚ê§

[06:33] <Zoffix> s: Match.new, '

[06:33] <SourceBaby> Zoffix, Something's wrong: ‚ê§ERR: ===SORRY!=== Error while compiling -e‚ê§Unable to parse expression in single quotes; couldn't find final "'" ‚ê§at -e:7‚ê§------> <BOL><HERE><EOL>‚ê§    expecting any of:‚ê§        single quotes‚ê§        term‚ê§

[06:33] <[Tux]> This is Rakudo version 2017.03-285-g9a2446c94 built on MoarVM version 2017.03-138-g40881cdb

[06:33] <[Tux]> csv-ip5xs        3.048

[06:33] <[Tux]> test            12.503

[06:33] <[Tux]> test-t           5.120 - 5.144

[06:33] <[Tux]> csv-parser      13.154

[06:33] <Zoffix> s: Match.new, 'Bool', \()

[06:33] <SourceBaby> Zoffix, Something's wrong: ‚ê§ERR: No such method 'cando' for invocant of type 'NQPRoutine'‚ê§  in block  at /home/zoffix/services/lib/CoreHackers-Sourcery/lib/CoreHackers/Sourcery.pm6 (CoreHackers::Sourcery) line 26‚ê§  in sub sourcery at /home/zoffix/services/lib/CoreHackers-Sourcery/lib/CoreHackers/Sourcery.pm6 (CoreHackers::Sourcery) line 29‚ê§  in block <unit> at -e line 6‚ê§‚ê§

[06:34] <Zoffix> m: Match.new.Bool.say

[06:34] <camelia> rakudo-moar 9a2446: OUTPUT: ¬´1‚ê§¬ª

[06:39] <Zoffix> wonder where NQPMatchRole is at

[06:39] <Zoffix> Ah, just needed to pull nqp

[06:40] <Zoffix> k, got a fix lined up

[06:53] <Geth> ¬¶ rakudo/nom: 88140bbedf | (Zoffix Znet)++ | src/core/Match.pm

[06:53] <Geth> ¬¶ rakudo/nom: Fix Match.Bool

[06:53] <Geth> ¬¶ rakudo/nom:

[06:53] <Geth> ¬¶ rakudo/nom: Return a proper Bool instead of an Int

[06:53] <Geth> ¬¶ rakudo/nom: review: https://github.com/rakudo/rakudo/commit/88140bbedf

[06:53] <Geth> ¬¶ roast: 35402f654d | (Zoffix Znet)++ | S05-match/capturing-contexts.t

[06:53] <Geth> ¬¶ roast: Test return value of Match.Bool

[06:53] <Geth> ¬¶ roast: review: https://github.com/perl6/roast/commit/35402f654d

[06:53] <Zoffix> That fixes Pod::To::HTML test breakage

[07:38] <lizmat> Files=1191, Tests=56732, 197 wallclock secs (11.95 usr  4.68 sys + 1167.88 cusr 113.64 csys = 1298.15 CPU)

[10:06] <timotimo> geekosaur: not sure how much it'd be worth to do boxing/unboxing analysis at code gen time, because we don't inline very much at that stage

[10:07] <timotimo> geekosaur: spesh already has a thing where every version of every local has a "writer" set on it, that you can follow back to find the source of a value, which can for example be a boxing call

[10:31] <Zoffix> Thinking of keeping IO::Path.child as is. Tons of ecosystem usage. Forcing it to resolve is both much slower and potentally throwy if code was written not expecting the path to be resolvable when child is called. Also, the "secure" aspect of it is kinda weak, if you consider the code can be executed by older perl6 and silently become unsecure. Adding an arg to force securiness also isn't a great option,

[10:31] <Zoffix> since on older compilers it'll be again, silently ignored. So feels like using a new method name and putting `.child` through some deprecation cycle (deprecate in 6.d, remove in 6.e) is the best cource of action. Too bad its name is pretty perfect.

[10:32] <timotimo> in 6.f we will then deprecate the new name, reinstate the old name ...

[10:32] <Zoffix> :)

[10:33] <Zoffix> "/user/files/".IO.contain($user-input)

[10:33] <Zoffix> Decent enough name, but is 1-char away from a bug since IO::Path is Cool

[10:33] <timotimo> uuh

[10:33] * Zoffix goes for a nap, to sleep on it

[10:34] <timotimo> have a good one!

[13:30] <Zoffix> Well, dispite me joking about it in the upgrade notice, I'm gonna go with .child-secure

[13:30] <timotimo> Zoffix: do you recall the other pastebin services that let you eval perl6 code? besides glot.io?

[13:31] <Zoffix> In all the other path methods we don't really resolve the bits (well, other than .resolve, but even then you need to give it an arg)

[13:31] <Zoffix> huggable: glot.io

[13:31] <huggable> Zoffix, Run Perl 6 in your browser: https://tio.run/nexus/perl6 or https://glot.io

[13:31] <timotimo> yeah, that's the one i remember

[13:31] <timotimo> oh, tio.run, that's new to me

[13:32] <Zoffix> And the -secure in the name will let the reader pay more attention to the code and not modify it to something insecure willi-nilly

[13:32] <timotimo> https://github.com/hankache/perl6intro/issues/146 - this is why i ask

[13:33] <Zoffix> So we'll have: .child, .child-secure that's like child, but fully resolves the path and ensures it is indeed the child, and .concat-with that's like .child but lets the "child" be a parent path. In rakudo, .concat-with and .child are basically aliases, but as far as the language goes, giving parent paths to .child is undefined behaviour and giving them to .child-secure will make it fail

[13:39] <Zoffix> Or I guess .concat-with and .child will indeed be even specced as aliases. Otherwise, it'll be not recommended to use .child, unless you 100% know it's a child path, which is LTA.

[13:39] <Zoffix> Why aliases and not just .child? Because .child("../foo") reads stupid

[13:57] <nine> Why not $path.sub('foo')?

[14:00] <Zoffix> Feel a bit confusing, since we have `sub` as a term that means subroutines. But why not for which of the three? .child?

[14:01] <timotimo> https://rt.perl.org/Ticket/Display.html?id=129779 - i just closed this bug; it was the performance bug that we tested yesterday

[14:01] <timotimo> thanks to all of y'all for the help with it

[14:03] <Zoffix> 'cause .child's ship has sailed, I think. There's like 185 uses in ecosystem alone. Removing it for sake of renaming is too much breakage and IMO the name's pretty good ( .sub("../foo") reads weird to me just as child... though even more so, 'cause my brain switches to "subroutines here" thinking when hearing sub)

[14:04] <Zoffix> .concat-with is a bit long to type

[14:04] <Zoffix> .oO( .with )

[14:04] <timotimo> there's a python module that repurposes the / operator for path concat

[14:04] <Zoffix> :o

[14:05] <timotimo> so why not .slash :)

[14:06] <Zoffix> entirely meaningless name

[14:07] <Zoffix> m: say '.concat-with'.chars - '.slash'.chars

[14:07] <camelia> rakudo-moar 88140b: OUTPUT: ¬´6‚ê§¬ª

[14:07] <Zoffix> "foo".IO.with("../bar")

[14:08] <Zoffix> $stuff.IO.with($moar-stuff)

[14:08] <Zoffix> m: say '.concat-with'.chars - '.with'.chars

[14:08] <camelia> rakudo-moar 88140b: OUTPUT: ¬´7‚ê§¬ª

[14:08] <timotimo> just "with" is already something else

[14:09] <Zoffix> OK

[14:25] <nine> add?

[14:26] <nine> .append() would probably be as descriptive and accurate as you can get

[14:28] <nine> OTOH "appending" is exactly what the current .child does :/

[14:31] <Zoffix> I like .add

[14:31] <Zoffix> m: say "foo".IO.append: "../bar"

[14:31] <camelia> rakudo-moar 88140b: OUTPUT: ¬´Cannot resolve caller append(IO::Path: Str); none of these signatures match:‚ê§    (Any:U \SELF: |values is raw)‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[14:32] <Zoffix> So.... rename .concat-with to .add. Yey or nah

[14:32] <Zoffix> yey from me :)

[14:32] <nine> yey

[14:33] <nine> (I know, surprise, surprise)

[14:53] <Geth> ¬¶ rakudo/cat-handle: 031aa33225 | (Zoffix Znet)++ | 4 files

[14:53] <Geth> ¬¶ rakudo/cat-handle: [io grant] Start sketching out IO::CatHandle

[14:53] <Geth> ¬¶ rakudo/cat-handle:

[14:53] <Geth> ¬¶ rakudo/cat-handle: Stashing this to finish post-release. Looking closer at IO::ArgFiles

[14:53] <Geth> ¬¶ rakudo/cat-handle: impl, IO::CatHandle will need a lot more polish than just renaming

[14:53] <Geth> ¬¶ rakudo/cat-handle: IO::ArgFiles and a lot more tests too.

[14:53] <Geth> ¬¶ rakudo/cat-handle:

[14:53] <Geth> ¬¶ rakudo/cat-handle: No point in including a rushed and poorly tested work in release.

[14:53] <Geth> ¬¶ rakudo/cat-handle: review: https://github.com/rakudo/rakudo/commit/031aa33225

[14:54] <Zoffix> ^ mostly 'cause I want IO::CatHandle to be mostly-usable with code that uses IO::Handle and IO::ArgFiles is far from being that.

[14:55] <nine> Zoffix: I don't understand the rush to get your IO work into this release anyway.

[14:57] <Zoffix> nine: I guess it's a carry over mentality from my promising to finish my grant by end of March and being totally late with that. Plus, end users won't see stuff that doesn't make it into this release for the next three months.

[14:58] <nine> They have lived with the current state of IO for years.

[14:58] <Zoffix> ¬Ø\_(„ÉÑ)_/¬Ø

[14:58] <nine> Also if you get all the goodies in now, we'll have fewer to show off in the next release :)

[14:58] <Zoffix> heh

[15:30] <nine> Oh my...WHAT? The object pulling in CompUnit::Repository::Staging's SC during serialize_repossessions appears to be an NQPRoutine called 'security'.

[15:31] <nine> There's only one routine with that name in all of our code base. That's the part of Perl6::Grammar responsible for throwing an X::SecurityPolicy::Eval unless MONKEY-SEE-NO-EVAL is active

[15:46] <nine> What I also know is that there's not some reference to the repo, but one or more references to the serialization context where the Staging repo is in.

[16:15] <nine> I just realized: there's probably a valid workaround for this issue. The Staging repo is for when you want to precompile modules with an unpriviledged user in a staging area that is different from where the resulting files will be installed into.

[16:15] <nine> Because the unpriviledged user won't be allowed to write to /usr/share/perl6 directly.

[16:16] <nine> In other words: it's for when we create packages for distributions. Distributions however will do their own dependency tracking. They will compile the modules in depth first order of the dependency tree.

[16:17] <geekosaur> you hope

[16:17] <nine> This means that we can be reasonably sure that the dist we are currently packaging won't contain modules that replace one of its dependencies' dependencies (by providing a newer version).

[16:17] <nine> Thus we can skip the dependency re-resolving on detecting a change in the repo chain (including the offending EVAL).

[16:18] <nine> geekosaur: they have to for all other languages. I'd say it's reasonable to assume they will use the same mechanism for Perl 6 packages.

[16:21] <nine> Anyway this workaround can be a strictly opt-in thing. The alternative being just biting the bullet and including the dependency on the Staging repo in the precomp file. This can be controlled by the same switch.

[16:23] <timotimo> perl6 is quite nice to work with

[16:23] <nine> timotimo: noticed that, huh? :)

[16:24] <timotimo> i don't use perl6 for stuff often enough :)

[16:25] <timotimo> i work on internals most of the time instead :)

[16:26] <nine> Yeah, I too have worked on Perl 6 much more than with Perl 6. Very much enjoyed the times when I was just a user :)

[16:28] <Zoffix> timotimo: what's your opinion on .concat-with being renamed to .add ?

[16:28] <timotimo> i think it's acceptable

[16:29] <Zoffix> k

[16:32] <ugexe> too bad .subdir doesn't cover all its uses

[16:35] <nine> That's why I suggested .sub. But that may really be just too confusing.

[16:42] <ugexe> or we can draw on this old (unused) code/name https://github.com/rakudo/rakudo/blob/7556498daa3003efa1329a328b5faf15fbc38386/src/core/CompUnit/RepositoryRegistry.pm#L24 (absolutify... absolutifies... ?)

[16:43] <ugexe> although I guess the new functionality is only absolutifying it in spirit... it returns an IO::Path so it might be in relative form. doh

[16:49] <geekosaur> tbh I think haskell's </> operator makes a bit more sense :)

[16:51] <ugexe> https://github.com/rakudo/rakudo/pull/465 # that was already shut down

[16:52] <timotimo> hm, do we have a good idiom for transposing a list of lists?

[16:53] <timotimo> currently i wrote it all wordly-like as [@lol>>.[0], @lol>>.[1], ...]

[16:55] <Zoffix> m: my @lol = (1, 2), (3, 4), (5, 6); dd [ @lol¬ª[0], @lol¬ª[1], ]; dd [Z] @lol

[16:55] <camelia> rakudo-moar 88140b: OUTPUT: ¬´[(1, 3, 5), (2, 4, 6)]‚ê§((1, 3, 5), (2, 4, 6)).Seq‚ê§¬ª

[16:55] <timotimo> neat.

[16:55] <Zoffix> m: my @lol = (1, 2), (3, 4), (5, 6); dd [ @lol¬ª[0], @lol¬ª[1], ]; dd roundrobin @lol¬ª.List

[16:55] <camelia> rakudo-moar 88140b: OUTPUT: ¬´[(1, 3, 5), (2, 4, 6)]‚ê§((1, 3, 5), (2, 4, 6)).Seq‚ê§¬ª

[17:21] <timotimo> i kind of wish i had more datapoints for building this graphing script

[17:21] <timotimo> right now i have 2

[17:22] <timotimo> oh, i have 4 actually

[17:24] <timotimo> or is that the 4 kinds

[17:26] <timotimo> .... ?!?

[17:26] <timotimo> i don't recognize this data at all m)

[17:39] <Zoffix> m: constant %foo = foo => 2; dd %foo<foo> = 42; dd %foo

[17:39] <camelia> rakudo-moar 88140b: OUTPUT: ¬´Cannot modify an immutable Int‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[17:39] <Zoffix> Immutable; good

[17:39] <Zoffix> m: constant %foo = %(foo => 2); dd %foo<foo> = 42; dd %foo

[17:39] <camelia> rakudo-moar 88140b: OUTPUT: ¬´Int % = 42‚ê§Hash % = {:foo(42)}‚ê§¬ª

[17:39] <Zoffix> Not immutable; eh

[17:39] <Zoffix> m: constant %foo = 'foo', 2; dd %foo<foo> = 42; dd %foo

[17:39] <camelia> rakudo-moar 88140b: OUTPUT: ¬´5===SORRY!5=== Error while compiling <tmp>‚ê§Type check failed in constant declaration of %foo; expected Associative but got List (List)‚ê§at <tmp>:1‚ê§------> 3constant %foo = 'foo', 27‚èè5; dd %foo<foo> = 42; dd %foo‚ê§¬ª

[17:39] <Zoffix> don't work like that

[17:39] <Zoffix> m: constant %foo = ('foo', 2).Hash; dd %foo<foo> = 42; dd %foo

[17:39] <camelia> rakudo-moar 88140b: OUTPUT: ¬´Int % = 42‚ê§Hash % = {:foo(42)}‚ê§¬ª

[17:40] <Zoffix> Seems no easy way to make a constant hash without specifying pairs instead of a list of stuff?

[17:44] <Zoffix> m: ('foo', 2).pairs.map({ dd .value = .value })

[17:44] <camelia> rakudo-moar 88140b: OUTPUT: ¬´Cannot modify an immutable Str‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[17:44] <Zoffix> Immutable Str??

[17:44] <Zoffix> Oh nevermind, wrong use of pairs

[17:46] <Zoffix> Ah, there is

[17:46] <Zoffix> m: constant %foo = Map.new: 'foo', 2; dd %foo<foo> = 42; dd %foo

[17:46] <camelia> rakudo-moar 88140b: OUTPUT: ¬´Cannot modify an immutable Int‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[17:46] <Zoffix> m: constant %foo = Map.new: 'foo', 2; dd %foo

[17:46] <camelia> rakudo-moar 88140b: OUTPUT: ¬´Map.new((:foo(2)))‚ê§¬ª

[17:52] <Zoffix> uh

[17:52] <Zoffix> m: constant %foo = Map.new: <foo 2>; dd %foo<foo> = 42; dd %foo

[17:52] <camelia> rakudo-moar 88140b: OUTPUT: ¬´Int <element> = 42‚ê§Map.new((:foo(42)))‚ê§¬ª

[17:52] <Zoffix> But not in this form :S wtf

[17:54] <Zoffix> s: Map, 'new', \(<foo bar>)

[17:54] <SourceBaby> Zoffix, Sauce is at https://github.com/rakudo/rakudo/blob/88140bb/src/core/Map.pm#L11

[17:54] <Zoffix> s: Map, 'new', \(|<foo bar>)

[17:54] <SourceBaby> Zoffix, Sauce is at https://github.com/rakudo/rakudo/blob/88140bb/src/core/Map.pm#L11

[17:54] <Zoffix> m: dd Map.new(<foo bar>)<foo> = 42

[17:54] <camelia> rakudo-moar 88140b: OUTPUT: ¬´Int <element> = 42‚ê§¬ª

[17:55] <Zoffix> m: dd Map.new(|<foo bar>)<foo> = 42

[17:55] <camelia> rakudo-moar 88140b: OUTPUT: ¬´Cannot modify an immutable Str‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[17:56] <Zoffix> Seems to do with how slurpies are made

[17:56] <Zoffix> m: sub foo (*@foo) { dd @foo[1] = 42 }; foo <foo bar>; foo |<foo bar>;

[17:56] <camelia> rakudo-moar 88140b: OUTPUT: ¬´42‚ê§Cannot modify an immutable Str‚ê§  in sub foo at <tmp> line 1‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[17:56] <Zoffix> Seems to be part of https://rt.perl.org/Ticket/Display.html?id=130441#ticket-history

[17:58] <timotimo> fantastic. i get 4 datapoints for every kind X file ... and only three have non-constant values in 'em

[17:59] <Zoffix> Added the Map thing in a comment: https://rt.perl.org/Ticket/Display.html?id=130441#txn-1456934

[18:52] <Geth> ¬¶ rakudo/nom: 51e462925a | (Zoffix Znet)++ | src/core/IO/Path.pm

[18:52] <Geth> ¬¶ rakudo/nom: [io grant] Amend rules for last part in IO::Path.resolve

[18:52] <Geth> ¬¶ rakudo/nom:

[18:52] <Geth> ¬¶ rakudo/nom: Allow last part of path to not exist when using .resolve: :completely;

[18:52] <Geth> ¬¶ rakudo/nom: The resolution is still successful, and this lets us

[18:53] <Geth> ¬¶ rakudo/nom: .resolve(:completely) paths that we're about to create.

[18:53] <Geth> ¬¶ rakudo/nom: review: https://github.com/rakudo/rakudo/commit/51e462925a

[18:53] <Geth> ¬¶ roast: a716962791 | (Zoffix Znet)++ | S32-io/io-path.t

[18:53] <Geth> ¬¶ roast: [io grant] Amend rules for last part in IO::Path.resolve

[18:53] <Geth> ¬¶ roast:

[18:53] <Geth> ¬¶ roast: Allow last part of path to not exist when using .resolve: :completely;

[18:53] <Geth> ¬¶ roast: The resolution is still successful, and this lets us

[18:53] <Geth> ¬¶ roast: .resolve(:completely) paths that we're about to create.

[18:53] <Geth> ¬¶ roast: review: https://github.com/perl6/roast/commit/a716962791

[18:56] <Geth> ¬¶ rakudo/nom: b8458d34ae | (Zoffix Znet)++ | src/core/IO/Path.pm

[18:56] <Geth> ¬¶ rakudo/nom: [io grant] Reword `method child` for cleaner code

[18:56] <Geth> ¬¶ rakudo/nom: review: https://github.com/rakudo/rakudo/commit/b8458d34ae

[19:01] <Geth> ¬¶ rakudo/nom: 1887114dd8 | (Zoffix Znet)++ | 2 files

[19:01] <Geth> ¬¶ rakudo/nom: [io grant] Implement IO::Path.child-secure

[19:01] <Geth> ¬¶ rakudo/nom:

[19:01] <Geth> ¬¶ rakudo/nom: The original plan to make .child() resolve and check for secureness

[19:01] <Geth> ¬¶ rakudo/nom: was changed to leave .child() as is and implement .child-secure instead

[19:01] <Geth> ¬¶ rakudo/nom:

[19:01] <Geth> ¬¶ rakudo/nom: There is a lot of ecosystem usage of .child(), and there's no real

[19:01] <Geth> ¬¶ rakudo/nom: path for changing it, since the proposed .concat-with() is not available

[19:01] <Geth> ¬¶ rakudo/nom: <‚Ä¶commit message has 10 more lines‚Ä¶>

[19:01] <Geth> ¬¶ rakudo/nom: review: https://github.com/rakudo/rakudo/commit/1887114dd8

[19:02] <Zoffix> More eyes on securiness of .child-secure's code welcome :)

[19:03] <Geth> ¬¶ roast: f3c5dae288 | (Zoffix Znet)++ | 2 files

[19:03] <Geth> ¬¶ roast: [io grant] Test IO::Path.child-secure

[19:03] <Geth> ¬¶ roast:

[19:03] <Geth> ¬¶ roast: Also add a nul byte test to IO::Path.child.

[19:03] <Geth> ¬¶ roast: review: https://github.com/perl6/roast/commit/f3c5dae288

[19:26] <pmurias> has nqp-j been correctly rebootstrapped after the adding of constant support in the uncurse branch?

[19:42] <lizmat> m: my @a = [1,1],[2,2],[3,3]; dd @a; @a.splice: 0, 2, $[4,4]; dd @a  # feels like a bug that the containerization of [4,4] is being ignored

[19:42] <camelia> rakudo-moar 188711: OUTPUT: ¬´Array @a = [[1, 1], [2, 2], [3, 3]]‚ê§Array @a = [4, 4, [3, 3]]‚ê§¬ª

[19:45] <pmurias> hmm, how do I update the stage0 for the jvm backend?

[19:45] <timotimo> "make bootstrap-files-j" i think?

[19:49] <jnthn> lizmat: Yeah, it's because there's a candidate with @new at the end that it binds to, decontainerizing it in the process.

[19:49] <jnthn> So it's not actually hitting the slurpy at all

[19:49] <lizmat> so you agree it's wrong atm

[19:49] <jnthn> The slurpy is **@foo

[19:49] <jnthn> So in fact if it *was* hitting the slurpy it would be behaving right :)

[19:50] <jnthn> Yeah, it's wrong to discard the itemization

[19:50] <lizmat> ok, so we are in agreement

[19:50] <jnthn> I wonder if it was untested and then accidentally regressed when splice was optimized by breaking it out into a bunch of candidates

[19:50] <lizmat> will file a rakudobug

[19:50] <jnthn> Since I seem to recall splice getting at least something of a look during the GLR

[19:51] <jnthn> And I can't imagine we settled on "it ignores itemization" :)

[19:51] <lizmat> commitable: my @a = [1,1],[2,2],[3,3]; @a.splice: 0, 2, $[4,4]; dd @a

[19:51] <committable6> lizmat, ¬¶my: ¬´Cannot find this revision (did you mean ‚Äúall‚Äù?)¬ª

[19:51] <jnthn> bisectable6: my @a = [1,1],[2,2],[3,3]; @a.splice: 0, 2, $[4,4]; dd @a

[19:51] <bisectable6> jnthn, On both starting points (old=2015.12 new=1887114) the exit code is 0 and the output is identical as well

[19:51] <bisectable6> jnthn, Output on both points: ¬´Array @a = [4, 4, [3, 3]]¬ª

[19:51] <lizmat> ah

[19:51] <jnthn> Hm, nope

[19:51] <jnthn> It's been like that since Christmas

[19:51] <lizmat> ok, doesn't make it right, though :-)

[19:51] <jnthn> Indeed

[19:52] <lizmat> but will wait for the release to look at fixing it

[19:52] <jnthn> *nod*

[19:56] <Zoffix> jnthn: FWIW, I think it's safe to release MoarVM. I'll be doing the nqp::stat thing after release.

[19:56] <Zoffix> And I'm pretty much done with pre-release stuff for rakudo. Just need to fix this resolve stuff with combiners issue and pretty much that is it

[19:57] <lizmat> reported as RT #131162

[19:57] <synopsebot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=131162

[20:02] <lizmat> Zoffix: at this point we should probably settle for correct  :-)

[20:03] <lizmat> oops, wrongchan

[20:52] <Zoffix> ZOFFLOP: t/spec/S17-promise/nonblocking-await.t

[20:55] <Geth> ¬¶ rakudo/nom: f6387a8459 | (Pawel Murias)++ | src/Perl6/Actions.nqp

[20:55] <Geth> ¬¶ rakudo/nom: Stop using the no longer needed nqp::p6invokehandler

[20:55] <Geth> ¬¶ rakudo/nom:

[20:55] <Geth> ¬¶ rakudo/nom: Now that parrot is no longer supported we can just use the call op instead.

[20:55] <Geth> ¬¶ rakudo/nom: review: https://github.com/rakudo/rakudo/commit/f6387a8459

[20:56] <pmurias> (make spectest passed so hopefully this commit won't cause any trouble :)

[20:58] <Zoffix> ZOFVM: Files=1241, Tests=133747, 112 wallclock secs (22.25 usr  2.95 sys + 2329.40 cusr 129.38 csys = 2483.98 CPU)

[21:01] <Geth> ¬¶ rakudo/nom: 9d8e391f3b | (Zoffix Znet)++ | 3 files

[21:01] <Geth> ¬¶ rakudo/nom: [io grant] Fix IO::Path.resolve with combiners; timotimo++

[21:01] <Geth> ¬¶ rakudo/nom:

[21:01] <Geth> ¬¶ rakudo/nom: Stuff like "/\x[308]" is interpreted as a path separtor and a

[21:01] <Geth> ¬¶ rakudo/nom: filename named as a combiner, when we try to create files. A naive

[21:01] <Geth> ¬¶ rakudo/nom: split on '/' doesn't catch these separators however, so we implement

[21:01] <Geth> ¬¶ rakudo/nom: heavier logic where we work with bytes, swap all the dir separators

[21:01] <Geth> ¬¶ rakudo/nom: to nul bytes (that can't be in paths) and then split on nul bytes.

[21:01] <Geth> ¬¶ rakudo/nom:

[21:01] <Geth> ¬¶ rakudo/nom: This also fixes the issue in IO::Path.child-secure, where the path

[21:01] <Geth> ¬¶ rakudo/nom: with a combiner is assumed to be a child, even when it isn't.

[21:01] <Geth> ¬¶ rakudo/nom: review: https://github.com/rakudo/rakudo/commit/9d8e391f3b

[21:01] <Geth> ¬¶ roast: 92217f75ce | (Zoffix Znet)++ | S32-io/io-path.t

[21:01] <Geth> ¬¶ roast: [io grant] Test IO::Path.child-secure with combiners

[21:01] <Geth> ¬¶ roast: review: https://github.com/perl6/roast/commit/92217f75ce

[21:01] <timotimo> \o/

[21:21] <jnthn> Zoffix: OK...I'll do it tomorrow, if that's OK? Bit tired for it today

[21:21] <Zoffix> jnthn: sure :)

[21:26] <Geth> ¬¶ rakudo/nom: 0b5a41ba87 | (Zoffix Znet)++ | 9 files

[21:26] <Geth> ¬¶ rakudo/nom: [io grant] Rename IO::Path.concat-with to .add

[21:26] <Geth> ¬¶ rakudo/nom:

[21:26] <Geth> ¬¶ rakudo/nom: Per discussion[^1], make the name shorter, so people are more

[21:26] <Geth> ¬¶ rakudo/nom: willing to use it as an alias for .child when the path ain't

[21:26] <Geth> ¬¶ rakudo/nom: a child path.

[21:26] <Geth> ¬¶ rakudo/nom:

[21:26] <Geth> ¬¶ rakudo/nom: [1] https://irclog.perlgeek.de/perl6-dev/2017-04-16#i_14436165

[21:26] <Geth> ¬¶ rakudo/nom: review: https://github.com/rakudo/rakudo/commit/0b5a41ba87

[21:26] <Geth> ¬¶ roast: 39677c4059 | (Zoffix Znet)++ | S32-io/io-path.t

[21:26] <Geth> ¬¶ roast: [io grant] IO::Path.concat-with got renamed to .add

[21:26] <Geth> ¬¶ roast:

[21:26] <Geth> ¬¶ roast: Rakudo impl: https://github.com/rakudo/rakudo/commit/0b5a41ba87

[21:26] <Geth> ¬¶ roast: review: https://github.com/perl6/roast/commit/39677c4059

[21:27] * Zoffix calls it a day as well :)

[21:28] <Zoffix> \o

[21:38] <timotimo> nite Zoffix!

[22:17] <MasterDuke_> timotimo: if you're aren't completly busy making pretty coverage graphs, any more thoughts on sql profile output? i just pushed a commit to my branch that renames the `allocators` table to `types` and the `allocations.id` field to `allocations.type_id`

[22:17] <timotimo> ah, i like that

[22:18] <timotimo> i'm not sure i know where that branch lives

[22:19] <MasterDuke_> https://github.com/MasterDuke17/nqp/tree/make_profile_sql_output_better

[22:19] <timotimo> haha! i was looking for moarvm branches

[22:19] <timotimo> that doesn't make any sense, of course

[22:20] <timotimo> okay, so

[22:20] <timotimo> callees, right?

[22:20] <timotimo> it has a caller_id and an id

[22:21] <timotimo> i expect callees.caller_id to refer to callees.id

[22:21] <timotimo> but then how do i get from callees to the corresponding routine?

[22:21] <timotimo> also, allocations are also per-callees-entry, so we need a connection there, too

[22:22] <MasterDuke_> callees.(caller_)id = routines.id

[22:24] <MasterDuke_> yeah, i just saw that allocation <-> callee relationship in the newly-working-again regular profile

[22:24] <timotimo> oh

[22:24] <timotimo> if both id fields in callees refer to routines, that's Bad

[22:25] <timotimo> or at least weird

[22:25] <timotimo> consider subs A and B both call X, and X calls Y

[22:26] <timotimo> er ...

[22:26] <timotimo> ah, yeah

[22:27] <timotimo> now Y exists twice at rec_depth 2, X exists twice at rec_depth 1, and Y just has X as its caller_id

[22:27] <timotimo> but imagine A and B pass an integer through X to Y and Y sleeps for that long

[22:27] <timotimo> how do we figure out which Y record belongs to A (sleeps for 10s) and which Y record belongs to B (sleeps for 1s)

[22:29] <timotimo> does that make sense?

[22:31] <MasterDuke_> yeah. i'm just pulling the info right from the same data structure the json output is without manipulating it. but it maybe it does need some manipulation or other stuff added to make sense as db rows

[22:33] <MasterDuke_> i guess it's losing some of the tree structure

[22:37] <MasterDuke_> this would be to replicate the call graph section of the regular profile, right?

[22:45] <timotimo> well, yeah

[22:45] <timotimo> exactly

[22:46] <timotimo> the tree structure got flattened away because we didn't explicitly introduce a new "parent_id" field or something

[22:46] <timotimo> and i'd love for a new profiler data explorer to also be able to tell "this routine took 5s when called by A, but 10s when called by B"

[22:46] <timotimo> and much more importantly

[22:47] <timotimo> "bind_one_parameter" was called this often by those routines: A, B, C

[22:47] <MasterDuke_> yes, that would be nice

[22:47] <timotimo> yes oh god yes

[22:52] <MasterDuke_> ugh, not thinking very fast today. need to add a unique id every time we see a caller id?

[22:52] <timotimo> hm, a caller_id?

[22:53] <timotimo> we're walking the tree, right? we should have a new unique ID every time we reach one call graph node, and every node we discover from there (i.e. in the children list or whatever we have) will have the id we just made up set for its "parent"

[22:54] <MasterDuke_> right. then the existing caller_id is just so we can look up its name in the routines table

[22:54] <timotimo> right

[22:57] <MasterDuke_> caller_id for new unique id, caller_name_id for what caller_id is now?

[22:59] <timotimo> well, we don't really need the id from the caller any more

[22:59] <timotimo> so we'd get down to one field that references into the routines table

[23:01] <MasterDuke_> hm, guess so

[23:01] <timotimo> the last time i tried to put something like a unique id and a parent id in, the code absolutely wrecked my brain

[23:02] <timotimo> i'm really glad you're doing it for me :)

[23:05] <Zoffix> good grief, htmlify.p6's code is a fucking mess

[23:05] <timotimo> hey, weren't you going to bed? ;)

[23:05] <MasterDuke_> heh. it

[23:05] <timotimo> https://imgur.com/a/DKzJj - Zoffix, how do you like my graphs?

[23:05] <Zoffix> Was trying to make it replace $COLON$COLON with :: in URLs for the past half hour....

[23:05] <MasterDuke_> 's not like it doesn't take me lots of thinking and staring at the data over and over

[23:06] <Zoffix> timotimo: pretty

[23:06] <timotimo> <3

[23:06] <timotimo> MasterDuke_: yeah, the data is really not glancable

[23:09] <geekosaur> Zoffix, that's actually a bad idea, the actual list of special chars permitted in a URL is fairly limited

[23:13] <Zoffix> m: dd ':'.ord.base: 16

[23:13] <camelia> rakudo-moar 0b5a41: OUTPUT: ¬´"3A"‚ê§¬ª

[23:13] <Zoffix> geekosaur: fine, replaced with %3A%3A

[23:13] <timotimo> i think the reason why we have $COLON is because of filesystems?

[23:13] <Zoffix> But looks like there are a dozen places that each call different routines and hunting them all down is a PITA

[23:14] <timotimo> so maybe have a switch for served vs local docs?

[23:14] <Zoffix> timotimo: yes, and we have rewrite that makes https://docs.perl6.org/type/IO::Path URLs work, so there's no reason for our URLs to look idiotic with all the $COLON stuff in them

[23:15] <timotimo> OK

[23:18] * Zoffix gives up

[23:31] <samcv> well Zoffix i can fix the $COLON thing. but

[23:31] <samcv> we have to change the servers htacccess file

[23:32] <samcv> because it redirects actual colons to $COLON

[23:32] <samcv> so if we fix the build then it'll break the site cause it'll redirect to $COLON

[23:36] <Zoffix> samcv: my idea was to keep the files with $COLON; this way the build will still work on Windows. But just change all the URLs in the html files to use :: instead of $COLONs

[23:36] <Zoffix> samcv: also, it shouldn't be redirecting but just rewriting... where are you seeing the redirects?

[23:37] <Zoffix> I get only one requerst in Firefox

[23:38] <Zoffix> And yes, there's a way to redirect $COLON urls to :: urls, but that's extra load on the server and extra useless request for suers

[23:38] <Zoffix> *users

[23:39] <samcv> uh maybe it rewrites it

[23:39] <samcv> it probably rewrites it tbh

[23:39] <samcv> also we could always just uhm. only use $COLON on windows

[23:40] <samcv> then the links in the files will be the same links that the files *actually* are named

[23:40] <samcv> instead of requiring rewriting to even use the html files

[23:40] <Zoffix> samcv++ good iead

[23:40] * Zoffix does that

[23:41] <samcv> we tried that before

[23:41] <samcv> but it had to be reverted

[23:41] <samcv> should be a commit in the history if i look

[23:42] <Zoffix> huh.. wonder why it was reverted

[23:42] <samcv> just gotta make sure the website tries to access :: files not $COLON$COLON

[23:42] <Zoffix> Ah. OK. Yeah, that's just one line

[23:42] <samcv> because when you access webpage::blah.html

[23:42] <samcv> the server tries to give it the file at $COLEN$COLEN

[23:42] <samcv> which does't exist!

[23:42] <samcv> so reverted it

[23:43] <samcv> https://github.com/perl6/doc/commit/331472d0bfb1f07def0fb978846afb33b197c1b6

[23:43] <samcv> and this https://github.com/perl6/doc/commit/93db5f69ed7b39908480274d810aae0e0589ed26

[23:44] <timotimo> Qw‚üÖ ‚üÜ;

[23:44] <timotimo> that's baggy

[23:44] <samcv> it quotes!

[23:44] <samcv> they are allowed delimiters!

[23:44] <timotimo> i know

[23:44] <timotimo> it looks very much like a bag

[23:44] <timotimo> is what i mean

[23:46] <samcv> yeah they are S shaped bag delimiters

[23:46] <samcv> if we wanted to go crazy we could enable ‚üÖ ‚üÜ quoting to do bag( )

[23:46] <samcv> hahaha

[23:47] <timotimo> make it a slang

[23:49] <samcv> Zoffix, you gonna add this too https://github.com/perl6/doc/commit/93db5f69ed7b39908480274d810aae0e0589ed26

[23:49] <samcv> also note here that unix does have some badchars https://github.com/perl6/doc/commit/331472d0bfb1f07def0fb978846afb33b197c1b6#diff-5dfee1feb8b315ccfa42bd3125fdcb05R17

[23:49] <samcv> which is the '/'

[23:49] <samcv> so you will need to make those changes i made to htmlifgy.p6

[23:50] <samcv> err lib/Pod/Htmlify.pm6

[23:50] <geekosaur> is there a way to switch it on/off regardless of system? I could see someone trying to do this on a unix into a mounted cifs...

[23:50] <samcv> and the only reason it's not in htmlify.p6 is because it falsely triggers

[23:50] <geekosaur> or ntfs fuse mount, etc.

[23:50] <samcv> because directory names have a forward slash in them on linux

[23:51] <samcv> but they need to be added into lib/Pod/Htmlify.pm6

[23:52] <samcv> or it won't change '/' into $SOLIDUS or whatever it does

[23:53] <samcv> so hopefully you don't explode anything trying to write slashes to filenames

[23:53] <samcv> :O

[23:53] <samcv> cause that is not allowed

[23:53] <samcv> it'll break

[23:54] <samcv> i'll do it hold on
