[00:17] <agentzh> hi guys, as discussed originally in #perl6, i'd like to propose a "is ref" trait for class attribute declarations like has @.foo is ref;

[00:24] <agentzh> so that the default new() method will pass arrays or hash tables by ref by default instead of the current full value copying behavior.

[00:24] <agentzh> is that a good idea?

[00:41] <Zoffix> agentzh: for module space, sure.

[00:42] <agentzh> what do you mean by "module space"?

[00:42] <Zoffix> agentzh: write a module. Release it to https://modules.perl6.org

[00:43] <agentzh> so it cannot go into the core?

[00:44] <Zoffix> Why does it need to be in core?

[00:44] <agentzh> it would be very hard for the perl 6 compiler to take advantage of this hint for optimizations if it's not in the core language.

[00:44] <agentzh> very hard, if not impossible.

[00:45] <Zoffix> huh

[00:45] <agentzh> and the extra overhead in the external module may outweigh any benefit from saving the container copying.

[00:45] <agentzh> i find it very useful for class writers.

[00:45] <Zoffix> Well, then don't copy it. Use scalar attribute.

[00:46] <agentzh> otherwise we'll have to stick with $.foo for everything to avoid copying on @.foo and %.foo.

[00:46] <agentzh> that's ugly.

[00:46] <agentzh> defeating the purpose of sigils in the first place.

[00:46] <agentzh> (to some extend, at least)

[00:48] <Zoffix> No, it's not. I see no reason to be adding to core traits that modify well-defined container semantics. Especially since you're not even willing to make a module for this first. That just shows how un-needed the feature really is.

[00:49] <agentzh> well, it only affects the default new() method.

[00:49] <agentzh> making it pass those selective containers by ref instead of by value.

[00:49] <agentzh> if you know perl 6 supports another easy way to achieve the same result, please let me know.

[00:49] <llfourn> agentzh: I can easily see a module that made the default constructor bind attributes to the arguments. That is all the compiler needs to make "optimizations".

[00:50] <Zoffix> agentzh: I already told you the easy way to achieve that. Use $.foo

[00:50] <agentzh> Zoffix: and i've already said $.foo is ugly and defeating the purpose of sigils in the first place :)

[00:51] <agentzh> llfourn: i don't see how it's possible without using MOP if not using macros.

[00:51] <agentzh> llfourn: and MOP is definitely some extra overhead that the compiler may not optimize away completely.

[00:51] <samcv> agentzh, sigil is a container. if you want to pass container. use $

[00:52] <agentzh> samcv: it does not carry as much info as @. since $ can be anything.

[00:52] <agentzh> the same applies to %.

[00:53] <Zoffix> agentzh: which is nonsensical argumentation. What YOU'RE proposing is defeating the purpose of sigils. If you don't want the benefits the %.foo and @.foo offer you, then don't use them.

[00:53] <llfourn> agentzh: All you are doing is adding a custom constructor and a .new which will pass the list arguments raw and bind them to your @!foo attribute for example.

[00:53] <Zoffix> agentzh: @. and %. can have anything you want too.

[00:53] <llfourn> agentzh: there is no "MOP" overhead

[00:53] <agentzh> llfourn: the problem is that i have 46 classes in a single project, adding special new to each class is too much a burden to me ;)

[00:53] <llfourn> agentzh: yeah so write a module that does it automatically...

[00:56] <llfourn> class Foo { @!foo is raw; } # :)

[00:59] <ugexe> no suggestions for Proxy?

[01:01] <agentzh> alas, it is sad that it would require a nonstandard external module using MOP and open classes for such simple things.

[01:01] <agentzh> but anyway, thank you all for the feedback.

[01:02] <agentzh> i think we'll just implement the `is ref` trait in our own perl 6 dialect compiler anyway.

[01:02] <Zoffix> ugexe: you can just bind. Less typing.

[01:02] <samcv> m: https://gist.githubusercontent.com/samcv/69141a7e172159ef3758346b1b2ee82b/raw/0ad0e34e7b5404c7ce0851fca70afb5c3103bc51/gistfile1.txt

[01:02] <camelia> rakudo-moar fa9aa4: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Confused␤at <tmp>:1␤------> 3https:7⏏5//gist.githubusercontent.com/samcv/69141␤    expecting any of:␤        colon pair␤»

[01:02] <Zoffix> m: class Foo {has @.bar; submethod BUILD (:@bar) { @!bar := @bar }; method alter { @.bar[2] = 42 } }; my @bar = 42; my $x = Foo.new: :@bar; @bar[0] = 100; say $x.bar; $x.alter; say @bar;

[01:02] <camelia> rakudo-moar fa9aa4: OUTPUT: «[100]␤[100 (Any) 42]␤»

[01:03] <samcv> evalable6, https://gist.githubusercontent.com/samcv/69141a7e172159ef3758346b1b2ee82b/raw/0ad0e34e7b5404c7ce0851fca70afb5c3103bc51/gistfile1.txt

[01:03] <evalable6> samcv, Successfully fetched the code from the provided URL.

[01:03] <evalable6> samcv, rakudo-moar fa9aa4765: OUTPUT: «[1 2 3]␤[2 3]»

[01:03] <agentzh> Zoffix: but you still need to define BUILD yourself, no?

[01:03] <samcv> that seemed to copy the reference agentzh

[01:03] <samcv> i mean it changes when i change the object it was created from

[01:03] <Zoffix> m: class Foo {has @.bar; submethod TWEAK (:@bar) { @!bar := @bar }; method alter { @.bar[2] = 42 } }; my @bar = 42; my $x = Foo.new: :@bar; @bar[0] = 100; say $x.bar; $x.alter; say @bar;

[01:03] <camelia> rakudo-moar fa9aa4: OUTPUT: «[100]␤[100 (Any) 42]␤»

[01:03] <Zoffix> Can use TWEAK too

[01:04] <agentzh> p6: my @lst = <foo bar baz>; class A { has @.b is rw }; my $o = A.new(b => @lst); pop @lst; say $o;

[01:04] <camelia> rakudo-moar fa9aa4: OUTPUT: «A.new(b => ["foo", "bar", "baz"])␤»

[01:04] <agentzh> my example is like this.

[01:04] <agentzh> i just want to avoid array copying in @lst easily.

[01:04] * Zoffix shakes head.

[01:04] <agentzh> Zoffix: as i've said, i have 46 classes.

[01:05] <samcv> i didn't get copying in my gist agentzh

[01:05] <Zoffix> p6: my @lst = <foo bar baz>; class A { has $.b }; my $o = A.new(b => @lst); pop @lst; say $o;

[01:05] <agentzh> i'd rather add is ref trait to attributes instead of adding special BUILD or TWEAK.

[01:05] <camelia> rakudo-moar fa9aa4: OUTPUT: «A.new(b => $["foo", "bar"])␤»

[01:05] <samcv> maybe you're doing something different

[01:05] <llfourn> agentzh: Just make a module and then once everyone feels they need it maybe it will get into core?

[01:06] <llfourn> there's no chance otherwise.

[01:06] <agentzh> and some of those classes may already have TWEAK or BUILD.

[01:07] <llfourn> agentzh: maybe you can figure out a way to do it without clobbering pre-existing TWEAKs and BUILD from your module :)

[01:07] <agentzh> llfourn: thanks for the suggestion, but i'm sorry that i don't have a time to write such a module for rakudo. since we are not really interested in rakudo except using it to compare our own perl 6 dialect implementation.

[01:07] <agentzh> *have the time

[01:07] <llfourn> agentzh: fair enough :)

[01:08] <agentzh> anyway, thank you all for your time and suggestions.

[01:13] <Zoffix> We should really draft up a protocol for feature addition to core, with some rules to follow. It's tiring to constantly discuss something the proposers don't really care about.

[01:13] <Zoffix> Several times a week.

[01:14] <Zoffix> Last week I was baffled that a PR to add a feature wasn't even working. The submitter didn't even bother to ensure the feature they want to add was working.

[01:14] <Zoffix> Not with some edge case, but *at all*.

[01:15] <llfourn> +1 on that, python community seems to be happy with their PEP system (https://www.python.org/dev/peps/)

[01:16] <Zoffix> And this comment, I think, is very elucidating as to why people want to add stuff to core but are very hesitant to make a module instead: https://irclog.perlgeek.de/perl6/2017-03-27#i_14327502

[01:16] <Zoffix> "I give ideas. Someone else has to take care of the code"

[01:18] * Zoffix reads a few PEPs

[01:18] <Zoffix> That may be an overkill, at the moment.

[01:19] <Zoffix> Some of these proposals are 25+ pages long.

[01:20] <llfourn> Yep. Python 3's inbuilt event loop asyncio was a PEP so some of them are serious business.

[01:21] <agentzh> hopefully i won't have to write a 10+ page proposal for future ideas :)

[01:21] <Zoffix> :)

[01:21] <llfourn> I think we can cut off 9 or so pages if you write a module that does it :P

[01:22] <agentzh> llfourn: then i'd rather stick with our own perl 6 dialect language :)

[01:22] <llfourn> agentzh: to each their own :)

[01:23] <llfourn> agentzh: btw have you considered "is raw" rather than "is ref" because that's the trait we use on routine parameters when we want to pass them "raw".

[01:23] <agentzh> for unrelated issue, so now perl 6's language design is now determined by the test suite instead of the synopses?

[01:24] <agentzh> llfourn: interesting. looking into is raw now.

[01:24] <agentzh> was not aware of it.

[01:24] <agentzh> llfourn: where is it documented? failed to find is raw in docs.perl6.org.

[01:24] <llfourn> It's not searchable on docs.perl6.org :<

[01:25] <agentzh> oh

[01:25] <llfourn> hmm

[01:25] <agentzh> what do you mean by passing them "raw"?

[01:25] <agentzh> it is a new term for me.

[01:25] <agentzh> does it mean the same thing as "is ref"?

[01:25] <llfourn> agentzh: basically, it means passing the raw container I think.

[01:26] <agentzh> okay, then mostly the same thing.

[01:26] <agentzh> that's very close!

[01:26] <agentzh> looks like a good chance for is raw going into class attributes as well? *grin*

[01:26] <Zoffix> agentzh: yes, the roast (test suite) is the computer version of the spec and the docs are meant to be explanatory for humans. Basically, trying to keep the speculations up to date and accurate is too much work.

[01:26] <llfourn> m: say {;}.gist

[01:26] <camelia> rakudo-moar fa9aa4: OUTPUT: «-> ;; $_? is raw { #`(Block|52980376) ... }␤»

[01:26] <llfourn> agentzh: as you can see blocks by default are is raw

[01:27] <agentzh> Zoffix: good to know, thanks for the info.

[01:27] <agentzh> llfourn: nice

[01:27] <agentzh> okay, i'll play with is raw in our own compiler.

[01:27] <agentzh> llfourn: thanks for the info!

[01:28] <llfourn> agentzh: good luck :)

[01:28] <agentzh> thanks

[01:28] <agentzh> we're trying to build a more "practical" version of perl 6 compiler for commercial use.

[01:28] <agentzh> by "more practical", i mean much faster.

[01:28] <agentzh> hopefully much faster than even perl 5.

[01:28] <llfourn> agentzh: is it going to be open source?

[01:28] <agentzh> llfourn: maybe at some point. not right now.

[01:29] <llfourn> agentzh: ok I would love to look it it :D

[01:29] <agentzh> we'll give a free personal license for our perl 6 dialect compiler to official perl 6 team members :)

[01:29] <llfourn> agentzh: it's compiling into lua bytecode or something I think I saw?

[01:30] <agentzh> if you guys are interested.

[01:30] <agentzh> it's compiling into OpenResty/Lua code, so eventually LuaJIT bytecode.

[01:30] <agentzh> the compiler is called fanlang.

[01:30] <llfourn> ah cool so it compiles into lua first

[01:30] <agentzh> the compiler itself is written in perl 5 atm, but will soon get boostrapped by fanlang itself.

[01:31] <agentzh> llfourn: yes. since the LuaJIT bytecode is a moving target.

[01:31] <agentzh> there's constantly new changes made into the LuaJIT VM bytecode.

[01:31] <llfourn> ooo, can I ask why you didn't start writing the compiler in rakudo? speed?

[01:31] <agentzh> for new perofmrance features.

[01:31] <agentzh> yes, speed.

[01:31] <agentzh> and also simplicity.

[01:32] <agentzh> we only employ a common subset of perl 6, though this subset is getting larger and larger according to our own engineering needs.

[01:32] <llfourn> I am writing a perl6-dialect that compiles itno shell scripts :)

[01:32] <llfourn> https://github.com/spitsh/spitsh

[01:32] <agentzh> and we take performance very seriously when considering what perl 6 features to implement.

[01:32] <agentzh> from the very beginning.

[01:32] <agentzh> llfourn: huh, that's fun.

[01:32] <llfourn> I would find it very hard to have written it in p5.

[01:32] <agentzh> llfourn: our fanlang compiler will also target browser JS too soon.

[01:33] <agentzh> it's on our company's plan.

[01:33] <agentzh> maybe the shell language is too limited for us.

[01:33] <agentzh> it's fun stuff though.

[01:33] <llfourn> heh no yep it's for fun + config management

[01:34] <llfourn> I was just saying that it would be hard for me to parse the language in p5.

[01:34] <llfourn> perl6 grammars make it so much easier

[01:34] <agentzh> llfourn: i tried to use rakudo/p6 to implement one of our DSL compilers.

[01:34] <agentzh> but the compiling time was too much for us to bear.

[01:35] <agentzh> every single edit requires at minimum 6 sec to compile.

[01:35] <llfourn> oh you mean to precompile your perl6 code?

[01:35] <agentzh> so i eventually gave up.

[01:35] <llfourn> or was that before precomp?

[01:35] <agentzh> llfourn: yep, i tried everything suggested here and on #perl6.

[01:35] <agentzh> including concatenating every .pm6 files into a single giant p6 script.

[01:36] <agentzh> that gives the best result: 6 sec

[01:36] <agentzh> still too long for development.

[01:36] <agentzh> our p6 project contains 8000 LOC.

[01:36] <agentzh> relatively large project.

[01:36] <llfourn> ah ok. that's pretty big.

[01:36] <agentzh> our perl 6 dialect compiler is much bigger.

[01:36] <llfourn> I think spitsh is like 6k LOC.

[01:37] <agentzh> 23K+ LOC.

[01:37] <llfourn> wow!

[01:37] <agentzh> i told you it's a perl 6 dialect, large p6 subset.

[01:37] <agentzh> OO, smartmatching, a lot of common things.

[01:37] <agentzh> most of the statements

[01:37] <agentzh> a simplified grammar engine

[01:38] <agentzh> big enough to bootstrap itself i think :)

[01:38] <llfourn> Very excited to see it when it's released in whatever form :)

[01:39] <agentzh> llfourn: glad you'd look at it.

[01:39] <agentzh> will let you guys know.

[01:40] <agentzh> we are still busy polishing it.

[01:40] <agentzh> and using it to write real world DSL compilers for commercial products.

[01:40] <llfourn> agentzh: I think using Perl 6 syntax as a base to design a new langauge is a great idea.

[01:50] <agentzh> llfourn: agreed!

[05:30] <[TuxCM]> This is Rakudo version 2017.03-49-gfa9aa4765 built on MoarVM version 2017.03-25-ga8448142

[05:30] <[TuxCM]> csv-ip5xs        3.085

[05:30] <[TuxCM]> test            12.661

[05:30] <[TuxCM]> test-t           4.970 - 4.982

[05:30] <[TuxCM]> csv-parser      13.236

[05:38] <samcv> this seems fine right?

[05:38] <samcv> not ok 352 - retired metachars (\Q...\E)# TODO error messages

[05:38] <samcv> #      got: Unsupported use of \Q as quotemeta; in Perl 6 please use quotes or literal variable match at line 2,

[05:38] <samcv> i think it's showing the proper error message right?

[05:39] <samcv> also don't know what this is: `expected: <Unrecognized>`

[06:13] <samcv> j: 'ﬆ'.fc.say

[06:13] <camelia> rakudo-jvm fb4f16: OUTPUT: «ﬆ␤»

[06:50] <samcv> nqp: my $match := 'ﬆ' ~~ /st/; say($match);

[06:50] <camelia> nqp-moarvm: OUTPUT: «Substring length (-3) cannot be negative␤   at gen/moar/stage2/QRegex.nqp:2032  (/home/camelia/rakudo-m-inst-1/share/nqp/lib/QRegex.moarvm:Str)␤ from gen/moar/stage2/NQPCORE.setting:713  (/home/camelia/rakudo-m-inst-1/share/nqp/lib/NQPCORE.setting.moarvm:joi…»

[06:51] <samcv> nqp-j: my $match := 'ﬆ' ~~ /st/; say($match);

[06:51] <samcv> nqp-jvm: my $match := 'ﬆ' ~~ /st/; say($match);

[06:51] <camelia> nqp-jvm: OUTPUT: «Error occurred during initialization of VM␤Could not allocate metaspace: 1073741824 bytes␤»

[09:49] <lizmat> Files=1181, Tests=55992, 196 wallclock secs (11.68 usr  4.45 sys + 1163.77 cusr 111.90 csys = 1291.80 CPU)

[09:49] <yoleaux2> 09:27Z <jnthn> lizmat: p6firstflag has no thread-related handling, though for the sake of hyper/race we should only really be setting it in one thread anyway, I'd think

[09:53] <dogbert17_> m: say 1122333.split(/<!same>/, :skip-empty)

[09:53] <camelia> rakudo-moar fa9aa4: OUTPUT: «(11 22 333)␤»

[09:53] * dogbert17_ wonders what other secrets might be hiding in the regex engine

[09:55] <jnthn> That's cute :)

[09:57] <dogbert17_> one of TimToady's secrets which he divulged yesterday. There are no spectests though ...

[10:00] <dogbert17_> m: say 123456789.split(/<?at(4)>/) # experiment

[10:00] <camelia> rakudo-moar fa9aa4: OUTPUT: «(1234 56789)␤»

[10:01] <jnthn> .oO( In today's episode of "accidentally O(n)..." )

[11:40] <dogbert17_> jnthn: care to look at a gist?

[11:41] <dogbert17_> wrt RT #131003

[11:41] <synopsebot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=131003

[11:45] <dogbert17_> dunno if it contains any useful information but you never know: https://gist.github.com/dogbert17/ea5855ab29c74b1b518a9f86c2f24f62

[11:55] <jnthn> Hmm, interesting

[11:56] <dogbert17_> if it contains anything useful; I'll ask AlexDaniel to add it to the original report

[11:57] <jnthn> Yeah, it gives something to explore at least

[11:57] <jnthn> Could you try it with the GC debug stuff turned on also?

[11:57] <dogbert17_> will do

[13:03] <dogbert17_> jnthn: sry, was held up by a meeting. Here's a new gist: https://gist.github.com/dogbert17/3eb15ea55019d93590e8ea1d4966f7b2

[13:16] <Zoffix> .

[13:16] <yoleaux2> 09:26Z <brrt> Zoffix: that the usual way is to look at the JIT log and find the 'bail' entry corresponding to the JIT log of that frame

[13:17] <Zoffix> hm. I'm wondering if yoleaux2 is not delivering messages or if I'm missing the deliveries

[13:17] <Zoffix> Zoffix │ .ask jnthn what are your thoughts on removing $*SPEC and all the IO::Spec* in v6.d? We'd treat all the OSes as mostly-same rather than mostly-differn. e.g. we'd use "/" as path separator on all OS's

[13:19] <jnthn> Zoffix: It did deliver it

[13:19] <Zoffix> Ah, cool.

[13:19] <jnthn> Zoffix: But needs more thought

[13:19] <Zoffix> Sure.

[13:19] <jnthn> (delivered it in #moarvm since that's where I spoke first today)

[13:19] <jnthn> I can't say I've ever personally used it, but that doesn't mean others aren't

[13:20] <Zoffix> Oh, now I see it :)

[13:20] <Zoffix> I've seen some people use it, but personally, I think they're misusing it.

[13:20] <Zoffix> Instead of catpaths/splitdirs, you're meant to use .child/.parent, and the proposed in IO Plan, .cat-with methods on IO::Path

[13:26] <Geth> ¦ nqp/master: 6 commits pushed by (Pawel Murias)++

[13:26] <Geth> ¦ nqp/master: 07bf3e8064 | [js] Make nqp::backtrace return a stack trace

[13:26] <Geth> ¦ nqp/master: bbbad2be56 | [js] Remove duplicated code

[13:26] <Geth> ¦ nqp/master: 7471512874 | [js] Make bitshift on bignums round down

[13:26] <Geth> ¦ nqp/master: 51243c94f4 | Test that bitshifts round down not to zero

[13:26] <Geth> ¦ nqp/master: 85b8b45ab9 | [js] Fix bug when dividing big negative numbers

[13:26] <Geth> ¦ nqp/master: c360266c56 | Test dividing big negative numbers

[13:26] <Geth> ¦ nqp/master: review: https://github.com/perl6/nqp/compare/91070a8a60...c360266c56

[13:28] <Zoffix> My worry's more about trying to treat Windows/Linux as the same. Is there some edge case that will blow up in our face?

[13:29] <Zoffix> lizmat++ believes that ditching $*SPEC will give us a lot of performance boost, and I can see it happening: dynamic lookup is high in the profile and not having to call a method just to figure out what the "curdir" is can be beneficial too.

[13:29] <jnthn> Well, there's drive letter thing

[13:29] <jnthn> At the very least

[13:29] <jnthn> I guess also network paths maybe?

[13:30] <Zoffix> From what I understand, that's to be handled as paths with "volumes" and on Linux the volume is simply an empty string.

[13:31] <jnthn> Maybe another way to ask it is: how can I reliably ask if "/foo" is a relative path from a POSIX perspective should I wish to do that, even if I'm running on Windows, and vice versa?

[13:31] <jnthn> I think that question is the kinda thing IO::Spec could answer

[13:32] <jnthn> And if we remove it, then we're saying that such questions belong to module space

[13:32] <Zoffix> Currently it says it's absolute on Windows too tho

[13:32] <Zoffix> C:\Users\zoffi>perl6 -e "'/foo'.IO.is-absolute.say"

[13:32] <Zoffix> True

[13:32] <jnthn> heh, "interesting" :)

[13:32] <Zoffix> :D

[13:35] <Zoffix> I think this idea should be done as a module first...

[13:35] <jnthn> What do you think the impact of its removal would be?

[13:35] <jnthn> (on the ecosystem)

[13:37] <Zoffix> Looks big. So removing entirely in 6.d might not a good idea; maybe just deprecating.

[13:37] <Zoffix> 157 instances of $*SPEC in all modules

[13:38] <Zoffix> But a lot of them is stuff like my $class-path = $*SPEC.catfile( $class-dir, 'Metadata.pm' ); Which is what I thought originally, that people just aren't using IO::Path the way it was meant to be used

[13:50] <ugexe> fwiw getting zef to work well on windows between the various adapters was a huge PITA because of these windows things

[13:52] <ugexe> for instance: most code using `.dirname` probably meant `.parent` but may be using .dirname because its method name seems more natural

[13:53] <pmurias> agentzh: is fanlang implying that it's a fan language (in the way fanfiction does) intentional?

[13:53] <yoleaux2> 25 Mar 2017 05:14Z <Zoffix> pmurias: if you're interested, IO Action Plan is ready for review. The review period will end April 1st: https://irclog.perlgeek.de/perl6-dev/2017-03-25#i_14321373

[13:54] <ugexe> of course if you are using run/shell you also get to deal with trying to get scripts to deal with uris that don't start with . or / (use relative URIs for everything and pass in the vol to run/shell's :cwd)

[13:54] <Zoffix> pmurias: no, in Chinese Fan means... translator... I think

[14:01] <pmurias> hmm, roast/S03-operators/div.t fails because it assumes int is 64bit while rakudo.js has a 32bit int

[14:05] <pmurias> Zoffix: regarding the IO proposal having the method that does a file test assertion be called 'chdir' doesn't seem good

[14:06] <pmurias> I don't have a good name replacement name for it :(

[14:06] <Zoffix> ?

[14:06] * Zoffix doesn't follow

[14:07] <pmurias> my $*TMPDIR = '/tmp'.IO.chdir

[14:08] <Zoffix> I don't see that in the action plan...

[14:10] <pmurias> tmpdir is being removed, and it's replacement is supposed to be setting $*TMPDIR and calling .chdir,  right?

[14:11] <Zoffix> No, just setting it, period

[14:11] <Zoffix> You can ask .chdir to test the directory it's chdiring to, so alternatively, you could also do $*TMPDIR .= chdir: :r:x:w, "/whatever"

[14:12] <pmurias> the .chdir does do any chdiring

[14:12] <pmurias> * doesn't do

[14:15] <Zoffix> It changes the path and does tests on it..... Which is exactly what you'd want to do when you want to change $*TMPDIR and do tests on it

[14:21] <pmurias> no it doesn't

[14:22] <pmurias> m: say $*CWD.chdir('/tmp');say $*CWD

[14:22] <camelia> rakudo-moar fa9aa4: OUTPUT: «"/tmp".IO␤"/home/camelia".IO␤»

[14:23] <Zoffix> It clearly does.

[14:23] <pmurias> Zoffix: the .chdir method just performs the test it doesn't change the dir

[14:23] <Zoffix> It DOES! Your own code just showed it returned a new path!!

[14:24] * Zoffix leaves

[14:29] <Zoffix> pmurias: IO::Path.chdir returns a new path; if you give it a relative fragment it'll be relative to the invocant. It does tests too. &chdir() does the same thing but with $*CWD, and sets $*CWD to the new path. And &*chdir does the process chdir

[14:30] <dogbert17_> m: $*CWD.chdir('/tmp');say $*CWD

[14:30] <camelia> rakudo-moar fa9aa4: OUTPUT: «"/home/camelia".IO␤»

[14:30] <Zoffix> So $*TMPDIR .= chdir: :r:x:w, "whatever"; will create a new path, possibly relative to old $*TMPDIR, do tests on it and since .= operator is used, will assign the new path to $*TMPDIR

[14:32] <dogbert17_> .seen TimToady

[14:32] <yoleaux2> I saw TimToady 25 Mar 2017 17:41Z in #perl6-dev: <TimToady> it's probably a shibboleth to include the definite article :)

[14:52] <Geth> ¦ nqp/master: 4 commits pushed by skids++, (Zoffix Znet)++

[14:52] <Geth> ¦ nqp/master: 383e75b14f | Handle cloning/setting braids between NQPCursor and Perl6 Cursor

[14:52] <Geth> ¦ nqp/master: 4e519d2783 | Prevent warnings on action type objects -- use NO_VALUE sentinal

[14:52] <Geth> ¦ nqp/master: 7c13010c4c | Just use nqp::null raher than a sentinel in define_slang

[14:52] <Geth> ¦ nqp/master: 885d2c8161 | Merge pull request #349 from skids/FOREIGN_LANG

[14:52] <Geth> ¦ nqp/master: review: https://github.com/perl6/nqp/compare/c360266c56...885d2c8161

[14:58] <Geth> ¦ nqp: 7bd72e5c8b | (Zoffix Znet)++ | tools/build/MOAR_REVISION

[14:58] <Geth> ¦ nqp: Bump MoarVM

[14:58] <Geth> ¦ nqp:

[14:58] <Geth> ¦ nqp: Brings these commits:

[14:58] <Geth> ¦ nqp: https://github.com/MoarVM/MoarVM/compare/2017.03-25-ga8448142...2017.03-31-g8f9325b

[14:58] <Geth> ¦ nqp:

[14:58] <Geth> ¦ nqp: 8f9325b chr: For cp < 0x300 short circuit a unicode property test

[14:58] <Geth> ¦ nqp: f2acad4 MVM_string_chr: Only allocate and normalize for cp's that require it

[14:58] <Geth> ¦ nqp: ad44958 Merge pull request #557 from MasterDuke17/fix_overflow_to_negative_boundary_detection_in_mp_get_int64

[14:58] <Geth> ¦ nqp: c5eb7d5 Split into mp_get_int64 and mp_get_uint64

[14:58] <Geth> ¦ nqp: 65f35b2 Rename `sign` to `is_signed`

[14:58] <Geth> ¦ nqp: 84a730f Correctly detect+handle overflow in mp_get_int64

[14:58] <Geth> ¦ nqp: review: https://github.com/perl6/nqp/commit/7bd72e5c8b

[14:58] <Geth> ¦ nqp: version bump brought these changes: https://github.com/MoarVM/MoarVM/compare/2017.03-25-ga8448142...2017.03-31-g8f9325b

[15:10] <Geth> ¦ roast: 1ca4ce00ae | (Zoffix Znet)++ | S02-types/native.t

[15:10] <Geth> ¦ roast: Change TODO fudge into SKIP

[15:10] <Geth> ¦ roast:

[15:10] <Geth> ¦ roast: Tests now throw instead of just giving incorrect results

[15:10] <Geth> ¦ roast: review: https://github.com/perl6/roast/commit/1ca4ce00ae

[15:12] <Geth> ¦ rakudo/nom: 666ce35dd7 | (Zoffix Znet)++ | tools/build/NQP_REVISION

[15:12] <Geth> ¦ rakudo/nom: Bump NQP

[15:12] <Geth> ¦ rakudo/nom:

[15:12] <Geth> ¦ rakudo/nom: Brings these commits

[15:12] <Geth> ¦ rakudo/nom: https://github.com/perl6/nqp/compare/2017.03-12-g0adbb98...2017.03-32-g7bd72e5

[15:12] <Geth> ¦ rakudo/nom: 7bd72e5 Bump MoarVM

[15:12] <Geth> ¦ rakudo/nom: 885d2c8 Merge pull request #349 from skids/FOREIGN_LANG

[15:12] <Geth> ¦ rakudo/nom: c360266 Test dividing big negative numbers

[15:12] <Geth> ¦ rakudo/nom: <…commit message has 27 more lines…>

[15:12] <Geth> ¦ rakudo/nom: review: https://github.com/rakudo/rakudo/commit/666ce35dd7

[15:12] <Geth> ¦ rakudo/nom: version bump brought these changes: https://github.com/perl6/nqp/compare/2017.03-13-g67a74d24...2017.03-32-g7bd72e5

[15:12] <Geth> ¦ rakudo/nom: ffeb896daa | skids++ | src/Perl6/Grammar.nqp

[15:12] <Geth> ¦ rakudo/nom: Prevent problems when $!name has not been set

[15:12] <Geth> ¦ rakudo/nom: review: https://github.com/rakudo/rakudo/commit/ffeb896daa

[15:12] <Geth> ¦ rakudo/nom: fb1beef844 | (Zoffix Znet)++ | src/Perl6/Grammar.nqp

[15:12] <Geth> ¦ rakudo/nom: Merge pull request #1047 from skids/FOREIGN_LANG

[15:12] <Geth> ¦ rakudo/nom:

[15:12] <Geth> ¦ rakudo/nom: Fix SEGV in FOREIGN_LANG after nqp fixes in nqp PR#349

[15:12] <Geth> ¦ rakudo/nom: review: https://github.com/rakudo/rakudo/commit/fb1beef844

[15:25] <Zoffix> ZOFVM: Files=1230, Tests=132967, 122 wallclock secs (20.96 usr  3.44 sys + 2352.90 cusr 262.37 csys = 2639.67 CPU)

[15:26] <Zoffix> and a few passing todos; tried to unfudge but can't figure it out.

[15:27] <nine> Zoffix: the confusion about chdir is that it doesn't change the current working directory but people expect it to

[15:28] <ilmari> what _does_ it do if not _ch_ange _dir_ectory?

[15:29] <timotimo> it sets an internal "current working directory" that other stuff relies on

[15:32] <Zoffix> nine: but it does just that, as far as Perl 6 is concerned.

[15:32] <Zoffix> m: ".".IO.absolute.say; chdir "/tmp"; ".".IO.absolute.say

[15:32] <ilmari> to avoid the thread-racy nature of the process-global working directory?

[15:32] <camelia> rakudo-moar fb1bee: OUTPUT: «/home/camelia␤/tmp␤»

[15:34] <Zoffix> ilmari: that and also two threads doing different things; if one thread changes chdir, we don't want code in other thread to all of sudden doing things in the wrong dir.

[15:34] <Zoffix> Though we do provide &*chdir that changes the process-global working dir.

[15:35] <ilmari> that's what I meant

[15:35] <Zoffix> nine: or do you mean the IO::Path.chdir that just changes it for the invocant?

[15:35] <ilmari> unix "solved" it with the *at() family of syscalls

[15:38] <Zoffix> IO::Path.chdir is basically [ IO::Path.new (if argument is an absolute path) | IO::Path.concat-with (if arg is relative ] + .d + (.e)? + (.r)? + (.w)?

[15:38] <Zoffix> m: dd "/foo".IO.chdir: "/bar/"

[15:38] <camelia> rakudo-moar fb1bee: OUTPUT: «Failure.new(exception => X::IO::Chdir.new(path => "/bar/", os-error => "does not exist"), backtrace => Backtrace.new)␤»

[15:38] <Zoffix> m: dd "/foo".IO.chdir: "/tmp/"

[15:38] <camelia> rakudo-moar fb1bee: OUTPUT: «"/tmp/".IO(:SPEC(IO::Spec::Unix))␤»

[15:39] <Zoffix> This is kinda iffy since original had the file in it and now it's just a dir.

[15:40] <Zoffix> So deprecate IO::Path.chdir?

[15:41] <Zoffix> Another way to reword it: $foo.chdir($arg) is basically IO::Path.new($arg, :CWD($foo)) + .d + (.e)? + (.r)? + (.w)?

[15:41] <pmurias> ilmari: the method form _ch_ecks_the_dir_ectory

[15:41] <Zoffix> pmurias: all forms check the directory :/

[15:43] <pmurias> the sub form both checks the directory and sets $*CWD

[15:44] <Zoffix> and method form both checks the directory and returns the new paths set to it...

[15:44] <pmurias> yes

[15:47] <Geth> ¦ rakudo/nom: 5ca924df26 | (Zoffix Znet)++ | docs/2017-IO-Grant--Action-Plan.md

[15:47] <Geth> ¦ rakudo/nom: Add removal of IO::Path.chdir to list

[15:47] <Geth> ¦ rakudo/nom: review: https://github.com/rakudo/rakudo/commit/5ca924df26

[16:13] * TimToady notes that there are 36 different Chinese characters that are pronounced "fan"

[16:13] <yoleaux2> 26 Mar 2017 18:24Z <Zoffix> TimToady: what are your thoughts on removing $*SPEC and all the IO::Spec* in v6.d? We'd treat all the OSes as mostly-same rather than mostly-differn. e.g. we'd use "/" as path separator on all OS's

[16:14] * TimToady doesn't even know what $*SPEC does...

[16:14] <Zoffix> My current thought on that ^ is implement it as a module first and see if it's (a) works right enough; and (b) offers good perf improvement

[16:14] <Zoffix> Oh, heh. OK then nevermind :)

[16:17] <Zoffix> $*SPEC is set to an IO::Spec::* instance based on the OS running, which provides catpath/splitdir etc; So for example IO::Spec::Win32 has method dir-sep that returns \ but IO::Spec::UNix returns / instead and those are used to join a dir

[16:18] <Zoffix> And the idea is to toss all that. So that when you need to join a path, you just use '/' instead of having to do a dynamic var lookup and call its dirsep or whatever

[16:18] <TimToady> how do you represent D: and such?

[16:19] <TimToady> it's all very well to have an abstraction layer above, as browsers use, but there'd better be a complete mapping in that case

[16:19] <Zoffix> Without $*SPEC? From what I understand, all paths have a "volume" which on Linux is just an empty string

[16:20] <TimToady> and maybe access to the lower-level anyway

[16:20] <Zoffix> And this largely exists (and I assume works) in newio branch

[16:20] <TimToady> oh, is that why it's http:// with a double slash?

[16:20] <Zoffix> no idea :)

[16:21] <TimToady> except that's before the site name

[16:21] <Zoffix> There's file:// But it's file://C:/foo or file:///foo

[16:22] <TimToady> I guess I've never used file: on a windows boxoid

[16:23] <TimToady> the other weirdness we'll have to consider maybe is how to create utf8-c8 literals and such :/

[16:24] <TimToady> there's an impedance mismatch between the Str type and POSIX filenames, anyway

[16:24] <Zoffix> yeah

[16:25] <TimToady> so we'll need ways to deal with non-Str-comfortable filenames

[16:26] <TimToady> I know, we'll just run all filenames through EVAL, what could possibly go wrong?

[16:26] <jnthn> That's why we decode command line args, environment, filenames coming from dir, etc. using utf8-c8

[16:27] <TimToady> yes, but we also need to be able to generate utf8-c8 literals, I said

[16:27] <jnthn> No idea how we'll do that

[16:27] <TimToady> is why I said it :)

[16:27] <jnthn> Even Q:uni is problematic

[16:28] <TimToady> it has to be possible to think evil thoughts in Perl :)

[16:35] <b2gills> The thing with paths is older operating systems didn't use /. Though VMS, for example, does now have a UNIX mode so that is less of a problem than it is in Perl 5.

[16:52] <agentzh> pmurias: fan means translate in Chinese

[16:52] <agentzh> fanlang aims to provide an excellent way of "translating" little DSLs for machines.

[16:53] <agentzh> and we've found perl 6 being an excellent language for that purpose.

[16:53] <agentzh> at least a subset of it.

[17:25] <Zoffix> I don't see ::Spec::VMS, so presumably that isn't supported now either

[17:29] <SmokeMachine> Zoffix: hi there!

[17:29] <Zoffix> hi

[17:29] <SmokeMachine> could you help me? did you see my questions on #perl?

[17:29] <Zoffix> I don't follow that channel

[17:29] <SmokeMachine> (and thanks for the wellcome :) )

[17:30] <SmokeMachine> m: my %a = a => {b => 1}; say %a{"a","a";"b"}; say %a{"a","a";"b"}:exists # should it return True, True?

[17:30] <camelia> rakudo-moar 5ca924: OUTPUT: «(1 1)␤False␤»

[17:31] <Zoffix> don't know

[17:31] <SmokeMachine> it shouldn't be False, right?

[17:32] <SmokeMachine> im trying to fix this: https://rt.perl.org/Public/Bug/Display.html?id=130947#ticket-history

[17:41] <Zoffix> Don't even know what that syntax is supposed to do with hashes. Why does it give (1 1)?

[17:43] <b2gills> m: my %a = a => {b => 1}; say %a{"a","a"}»{"b"};

[17:43] <camelia> rakudo-moar 5ca924: OUTPUT: «(1 1)␤»

[17:44] <Zoffix> O.o

[17:45] <Zoffix> m: my %a = a => {b => 1}, c => {b => 42}; say %a{"a","c";"b", "b", "b"};

[17:45] <camelia> rakudo-moar 5ca924: OUTPUT: «(1 1 1 42 42 42)␤»

[17:45] <Zoffix> nuts

[17:46] <b2gills> m: my %a = a => {b => 1}, c => {b => 2}; say %a{"a","c";"b"}

[17:46] <camelia> rakudo-moar 5ca924: OUTPUT: «(1 2)␤»

[17:46] <b2gills> m: my %a = a => {b => 1}, c => {b => 2}; say %a{*;"b"}

[17:46] <camelia> rakudo-moar 5ca924: OUTPUT: «(1 2)␤»

[17:46] <Zoffix> cool

[17:47] <Zoffix> m: my %a = a => {b => {d => 99}}, c => {b => { d => 100 }}; say %a{"a","c";"b", "b", "b";"d","d"};

[17:47] <camelia> rakudo-moar 5ca924: OUTPUT: «(99 99 99 99 99 99 100 100 100 100 100 100)␤»

[17:48] <Zoffix> m: my %a = a => {b => 1}; say %a{"a","a";"b"}; say %a{"a";"b"}:exists

[17:48] <camelia> rakudo-moar 5ca924: OUTPUT: «(1 1)␤True␤»

[17:48] <SmokeMachine> %a{"a", "a"; "b"} == %a<a><b>, %a<a><b>

[17:48] <Zoffix> m: my %a = a => {b => 1}; say %a{"a","a";"b"}; say %a{"a","a"\}:exists

[17:48] <camelia> rakudo-moar 5ca924: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Unexpected closing bracket␤at <tmp>:1␤------> 031}; say %a{"a","a";"b"}; say %a{"a","a"\7⏏5}:exists␤»

[17:48] <Zoffix> m: my %a = a => {b => 1}; say %a{"a","a";"b"}; say %a{"a","a"}:exists

[17:48] <camelia> rakudo-moar 5ca924: OUTPUT: «(1 1)␤(True True)␤»

[17:48] <Zoffix> SmokeMachine: yeah, looks like it should be True, True

[17:48] <SmokeMachine> %hash{1;2;3} isn't prepared to receive list of lists...

[17:50] <SmokeMachine> the postcircunfix:<{; }>(\SELF, @indices, :$exists!) doesn't expect to @indices be multidimensional...

[17:50] <SmokeMachine> Zoffix: ok! ill fix that!

[17:52] <SmokeMachine> where can I find all nap::* functions?

[17:52] <SmokeMachine> *nqp::*

[17:53] <Zoffix> SmokeMachine: a lot of them are not documented. There's a list here: https://github.com/perl6/nqp/blob/master/docs/ops.markdown and nqp::p6* ones are here: https://github.com/rakudo/rakudo/blob/nom/docs/ops.markdown

[17:53] <SmokeMachine> Zoffix: thanks!

[18:14] <[Coke]> In general, you don't want nqp routines unless you are writing things in rakudo core.

[18:20] <AlexDaniel> s: &infix:<~~>, \(False, True)

[18:20] <SourceBaby> AlexDaniel, Sauce is at https://github.com/rakudo/rakudo/blob/5ca924d/src/core/Mu.pm#L849

[18:25] <SmokeMachine> [Coke]: that's the case, i think... Im editing src/core/hash_slice.pm

[18:26] <[Coke]> excellent.

[18:55] <SmokeMachine> m: use nqp; say nqp::islist([1, 2])

[18:55] <camelia> rakudo-moar 5ca924: OUTPUT: «0␤»

[18:55] <SmokeMachine> m: use nqp; say nqp::islist(1, 2)

[18:55] <camelia> rakudo-moar 5ca924: OUTPUT: «0␤»

[18:56] <SmokeMachine> ?

[18:56] <SmokeMachine> nqp: nqp::islist(1, 2)

[18:56] <camelia> nqp-moarvm: OUTPUT: «At Frame 0, Instruction 18, op 'decont', operand 1, MAST::Local of wrong type (4) specified; expected 8␤   at gen/moar/stage2/QAST.nqp:6577  (/home/camelia/rakudo-m-inst-2/share/nqp/lib/QAST.moarvm:assemble_and_load)␤ from gen/moar/stage2/NQPHLL.nqp:512  (/h…»

[18:56] <SmokeMachine> nqp: nqp::islist([1, 2])

[18:56] <camelia> nqp-moarvm: ( no output )

[18:56] <SmokeMachine> nqp: note(nqp::islist([1, 2]))

[18:56] <camelia> nqp-moarvm: OUTPUT: «1␤»

[18:56] <SmokeMachine> nqp: note(nqp::islist(1, 2))

[18:56] <camelia> nqp-moarvm: OUTPUT: «At Frame 0, Instruction 19, op 'decont', operand 1, MAST::Local of wrong type (4) specified; expected 8␤   at gen/moar/stage2/QAST.nqp:6577  (/home/camelia/rakudo-m-inst-2/share/nqp/lib/QAST.moarvm:assemble_and_load)␤ from gen/moar/stage2/NQPHLL.nqp:512  (/h…»

[18:57] <SmokeMachine> is there a different behavior of "pure" nqp and nqp inside perl6?

[18:59] <Zoffix> Yes, in Rakudo [] is not an nqp list, but an a Perl6 array

[18:59] <Zoffix> m: use nqp; say nqp::islist(nqp::list)

[18:59] <camelia> rakudo-moar 5ca924: OUTPUT: «1␤»

[18:59] <SmokeMachine> is there a way to (with nqp) discover if a var is a list?

[19:00] <Zoffix> "is a list" is a bit ambiguous. What do you mean?

[19:01] <SmokeMachine> m: use nqp; say nqp::istype((1, 2), List)

[19:01] <camelia> rakudo-moar 5ca924: OUTPUT: «1␤»

[19:02] <Zoffix> Note that Seqs aren't Lists

[19:02] <Zoffix> And neither are Ranges

[19:02] <SmokeMachine> i think 1;2, 3 are lists...

[19:02] <SmokeMachine> m: say (1; 2).WHAT

[19:02] <camelia> rakudo-moar 5ca924: OUTPUT: «(List)␤»

[19:03] <SmokeMachine> m: say (1; 2, 3)[1].WHAT

[19:03] <camelia> rakudo-moar 5ca924: OUTPUT: «(List)␤»

[19:04] <Zoffix> Huh. Turns out Atom has a warning for when you try to open large files. Asking if you still want to proceed. Considerring how slow it gets when loading largish files without that warning, I think clicking "Proceed" is unwise :)

[19:04] <Zoffix> m: dd (1; 2, 3).Array

[19:04] <camelia> rakudo-moar 5ca924: OUTPUT: «[1, (2, 3)]␤»

[19:04] <Zoffix> m: dd (1; 2, 3)>>.Array

[19:04] <camelia> rakudo-moar 5ca924: OUTPUT: «([1], [2, 3])␤»

[19:08] <Zoffix> m: my @a = [[<b c d>], [<d e f>]]; my @wat = (*;1,2); dd @a[*;1,2]

[19:08] <camelia> rakudo-moar 5ca924: OUTPUT: «("c", "d", "e", "f")␤»

[19:08] <Zoffix> m: my @a = [[<b c d>], [<d e f>]]; my @wat = (*;1,2); dd @a[@wat]

[19:08] <camelia> rakudo-moar 5ca924: OUTPUT: «(($["b", "c", "d"], $["d", "e", "f"]), Any)␤»

[19:09] <Zoffix> m: my %a = a => {b => {d => 99}}, c => {b => { d => 100 }}; my @wat = ("a","c";"b", "b", "b";"d","d"); dd %a{"a","c";"b", "b", "b";"d","d"}

[19:09] <camelia> rakudo-moar 5ca924: OUTPUT: «(99, 99, 99, 99, 99, 99, 100, 100, 100, 100, 100, 100)␤»

[19:09] <Zoffix> m: my %a = a => {b => {d => 99}}, c => {b => { d => 100 }}; my @wat = ("a","c";"b", "b", "b";"d","d"); dd %a{@wat}

[19:09] <camelia> rakudo-moar 5ca924: OUTPUT: «(Any, Any, Any)␤»

[19:09] * Zoffix surprised this doesn't work

[19:09] <Zoffix> At least it's consistently inconsistent

[19:34] <Zoffix> m: use nqp; my %h .= push: |"a:42\nbfdsasa:80\na:50\na:70".lines.map: { nqp::substr($_, 0, nqp::rindex($_, ':')) => nqp::substr($_, nqp::rindex($_, ':')+1)}; dd %h{*;}».Slip.flat.elems

[19:34] <camelia> rakudo-moar 5ca924: OUTPUT: «4␤»

[19:34] <Zoffix> Cool! Got to use {*;} stuff the same day I learned about it :)

[19:35] <Zoffix> m: use nqp; my %h .= push: |"a:42\nbfdsasa:80\na:50\na:70".lines.map: { nqp::substr($_, 0, nqp::rindex($_, ':')) => nqp::substr($_, nqp::rindex($_, ':')+1)}; dd %h.values».elems.sum

[19:35] <camelia> rakudo-moar 5ca924: OUTPUT: «4␤»

[19:35] <Zoffix> Though this version is consiser and clearer :P

[19:36] <Zoffix> And turns out I don't even need it at all >_<

[19:39] <bartolin> some of the newly added tests to S32-io/open.t fail badly on JVM. didn't work through all of them, but the first error is an IllegalArgumentException, because read and append cannot be used together (see https://docs.oracle.com/javase/8/docs/api/java/nio/channels/FileChannel.html#open-java.nio.file.Path-java.util.Set-java.nio.file.attribute.FileAttribute...-)

[19:40] <bartolin> $ ./perl6-j -e 'my $fh = open "foo", :append; $fh.close'

[19:40] <bartolin> java.lang.IllegalArgumentException: READ + APPEND not allowed

[19:43] <Zoffix> bartolin: are those the only failures? I was just adding different combinations of the args, so I guess the simplest solution is to just toss these tests: https://github.com/perl6/roast/blob/master/S32-io/open.t#L232-L250

[19:45] <bartolin> Zoffix: I'll take a closer look. would it make sense if I create a PR for roast for further discussion?

[19:47] <Zoffix> bartolin: if it's just the tests I linked to, I think you can just remove them and commit directly.

[19:48] <bartolin> Zoffix: it's at least the block before the linked one as well.

[19:48] <bartolin> (plain :append)

[19:48] <Zoffix> bartolin: oh, right, that can too go

[19:51] <bartolin> Zoffix: I'm looking. it'll take some time, though ...

[20:04] <Zoffix> I should probably make a JVM build and do it myself. There's a whole ton of new tests coming in the next 4 weeks.

[20:04] <bartolin> aha, a second problem is that :create is ignored if the file is opened only for reading. that's why one gets NoSuchFileExceptions for these tests: https://github.com/perl6/roast/blob/master/S32-io/open.t#L272-L314

[20:04] <Zoffix> heh

[20:05] <Zoffix> Looks like open's args need to be thought about a bit :)

[20:06] <bartolin> hmm, well. I'd prefer if you are not slowed down from your work on rakudo-m. on the other hand I'm not too keen to look at all the fallout of rakudo-j :-)

[20:07] <Zoffix> :)

[20:07] <Zoffix> I'll take care of the JVM for the new IO tests

[20:08] <bartolin> Zoffix++  # definitely not only for that commitment

[20:20] <SmokeMachine> my %a = a => {b => 42}; say %a{"a", "a"; "b", "b"}:exists should be (True, True, True, True) or ((True, True), (True, True)) ?

[20:20] <Zoffix> m: dd my %a = a => {b => 42}; say %a{"a", "a"; "b", "b"}

[20:20] <camelia> rakudo-moar 5ca924: OUTPUT: «Hash %a = {:a(${:b(42)})}␤(42 42 42 42)␤»

[20:21] <Zoffix> m: my %a = a => {b => 42}; dd %a{"a", "a"; "b", "b"}

[20:21] <camelia> rakudo-moar 5ca924: OUTPUT: «(42, 42, 42, 42)␤»

[20:21] <Zoffix> (True, True, True, True)

[20:21] <SmokeMachine> :(

[20:22] <Zoffix> Well, I think :)

[20:22] <Zoffix> But it'd make sense to me that it follows the same pattern as looking up those keys

[20:22] <SmokeMachine> Zoffix: I agree... but ((True, True),(True, True)) was already working... :P

[20:36] <SmokeMachine> Any idea to how I make it return a list and no a list of lists? https://www.irccloud.com/pastebin/gEtL9QWM/

[20:38] <SmokeMachine> https://www.irccloud.com/pastebin/rpWJx5rN/

[20:39] <Zoffix> m: dd flat ((True, True), (True, True))

[20:39] <camelia> rakudo-moar 5ca924: OUTPUT: «(Bool::True, Bool::True, Bool::True, Bool::True).Seq␤»

[20:39] <Zoffix> Thgough I don't know if it's always the right answer

[20:39] <Zoffix> or even at all, since it gives a Seq

[20:41] <SmokeMachine> I tried to add a .Slip on the nqp::while...

[20:42] <SmokeMachine> Zoffix: with the flat() https://www.irccloud.com/pastebin/18Dsv1GR/

[20:42] <SmokeMachine> (Bool::True, Bool::False, Bool::True, Bool::False, Bool::True, Bool::False, Bool::True, Bool::False).Seq

[20:42] <SmokeMachine> as you sad: it worked, but should it be a Seq?

[20:43] <SmokeMachine> should I just add a .List and that's it?

[20:43] <Zoffix> Dunno

[20:43] * Zoffix is done for the night

[20:43] * Zoffix &

[20:55] <Zoffix> irc

[20:55] <Zoffix> oops

[20:57] <Zoffix> I'm still gone. I'm just waiting for my stupid video card driver to update.... :)

[21:02] <timotimo> mhm

[21:06] <Zoffix> About to play Mass Effect 3 :)

[21:06] <Zoffix> I mean Mass Effect Andromeda

[21:06] <Zoffix> finished analyzing source file. 185 line/filename annotations found.

[21:06] <Zoffix> coverage report read: 2600 lines covered.

[21:06] <timotimo> i think it's a fun game

[21:06] <Zoffix> done analyzing annotations file: 37080 lines found

[21:06] <Zoffix> w00t progress!

[21:06] <timotimo> i don't have it yet, but i might get it

[21:06] <Zoffix> Though the index.html file it made is empty :/

[21:06] <timotimo> i never played ME3 :(

[21:18] <[Coke]> I only ever played ME2, wasn't psyched enough to get any of the others.

[21:18] <timotimo> i believe ME2 was much more shooter-esque than ME1, and ME3 continued that trend i think?

[21:22] <samcv> nqp test for regex `\Qabc\E` it is todo'd and looking for the error `<Unrecognized>` that seems maybe outdated?

[21:23] <samcv> it doesn't say <Unrecognized> but the error is a description that it's removed and what to use instead

[21:23] <samcv> so that test should be un-todo'd and changed probably right?

[21:23] <Zoffix> m: /\Qabc\E/

[21:23] <camelia> rakudo-moar 5ca924: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Unsupported use of \Q as quotemeta; in Perl 6 please use quotes or literal variable match␤at <tmp>:1␤------> 3/\Q7⏏5abc\E/␤»

[21:23] <Zoffix> yeah

[21:24] <samcv> kk that's what i thought thanks

[21:25] <Zoffix> ME1 is what got me psyched. Dunno how it's like to start with ME2, since you don't know wtf Garius is etc. And in ME3 you meet all the characters from ME1 that you've not met in ME2, so it'll probably be quite nonsensical :)

[21:30] <Zoffix> Looks like coverage parser can be simplified now. Since annotations and coverage report use the SETTING::src/blah format. The loop that loops through the setting source just needs to be reworked and I think I'll unbust the tool \o/

[21:37] <SmokeMachine> we have this test: isa-ok %multi-dim{1;2;3}:exists, Bool, "Bool test for literal multi dim key;" should I change?

[21:39] <Zoffix> That looks like a single key tho, so it should be a bool

[21:39] <Zoffix> m: my %multi-dim = 1 => { 2 => { 3 => 42 } }; dd %multi-dim{1;2;3}

[21:39] <camelia> rakudo-moar 5ca924: OUTPUT: «(42,)␤»

[21:39] <Zoffix> m: my %multi-dim = 1 => { 2 => { 3 => 42 } }; dd %multi-dim{1;2;3}:exists

[21:39] <camelia> rakudo-moar 5ca924: OUTPUT: «Bool::True␤»

[21:39] <Zoffix> Oh

[21:40] <Zoffix> Hm

[21:40] * Zoffix has no idea

[21:40] <Zoffix> SmokeMachine: maybe ask lizmat++? She was doing a lot of work with multi-dim stuff and might know what these things are meant to return

[21:42] <SmokeMachine> Zoffix: ok! Ill try!

[21:45] <Geth> ¦ nqp: f04f5dbcda | (Samantha McVey)++ | 3 files

[21:45] <Geth> ¦ nqp: Fix some regex tests and un-todo ~4 of them

[21:45] <Geth> ¦ nqp:

[21:45] <Geth> ¦ nqp: The tests were looking for the wrong words, and so have been todo'd even

[21:45] <Geth> ¦ nqp: though they have actually been fixed.

[21:45] <Geth> ¦ nqp: review: https://github.com/perl6/nqp/commit/f04f5dbcda

[22:16] <lizmat> and another Perl 6 Weekly hits the Net: https://p6weekly.wordpress.com/2017/03/27/2017-13-ios-not-the-same/

[22:23] <SmokeMachine> hi lizmat! could you, please, give me you opinion about what was discussed? https://irclog.perlgeek.de/perl6-dev/2017-03-27#i_14331593

[22:25] <SmokeMachine> lizmat: and thank you for the welcome! :)

[22:25] <lizmat> yeah, that looks like a bug to me and it should say True,True  :-)

[22:25] <lizmat> you're welcome

[22:28] <samcv> ugh it's still slower. somewhere i feel nqp/rakudo must be lowercasing or foldcasing this string when i do regex

[22:28] <samcv> because i benched worst case performance on nqp and it was basically the same

[22:28] <MasterDuke> stick a print in moar's lc and uc functions and see if it shows up?

[22:29] <samcv> yeah i guess i could do that

[22:29] <samcv> i mean i removed at least one place where it foldcased in nqp. and so all tests pass, all the todo's pass. but worstcase takes ~1.8x as long to go through an entire string

[22:30] <samcv> whereas on nqp it is even

[22:30] <samcv> perl 6 grammar/ast gods please save me :X

[22:35] <Zoffix> lizmat++ good weekly

[22:39] <timotimo> you know, you can also breakpoint those functions and rely on moar-gdb.py to properly print out the string in question

[22:39] <timotimo> just a thought :P

[22:41] <samcv> well --target=mast doesn't show any lc or uc calls

[22:42] <samcv> but it shows indexic_s which is right

[22:42] <samcv> so hmm. wondering why it's slower :\

[22:42] <samcv> is comparing mast output useful?

[22:43] <samcv> the speed diff changes only on changes to nqp. and nqp has no speed discrepency with case insensitive regex.

[23:08] <SmokeMachine> lizmat: what should that do? Return the first position of the list if it's only 1 element?

[23:56] <samcv> timotimo, it seems using nqp it takes about the same time to do nqp::index as nqp::indexic, but on perl6... it's slower. running the same nqp ops

[23:59] <samcv> i *think* maybe i'm just doing something wrong here
