[01:10] <Geth> ¦ nqp: 0c2d2e7fc3 | (Samantha McVey)++ | 6 files

[01:10] <Geth> ¦ nqp: Update qregex tests to allow backend specific todo's

[01:10] <Geth> ¦ nqp:

[01:10] <Geth> ¦ nqp: Previously :pge<comment> would todo under all backends. This has been changed

[01:10] <Geth> ¦ nqp: to :any<comment>. It will also allow todoing under specific backends as well

[01:10] <Geth> ¦ nqp: (jvm and moar currently supported).

[01:10] <Geth> ¦ nqp: review: https://github.com/perl6/nqp/commit/0c2d2e7fc3

[01:10] <Geth> ¦ nqp: 1e4c6099ff | (Samantha McVey)++ | 2 files

[01:10] <Geth> ¦ nqp: 01-qregex.t add ability to todo a specified number

[01:10] <Geth> ¦ nqp:

[01:10] <Geth> ¦ nqp: Also todo some JVM tests related to :i with ligatures.

[01:10] <Geth> ¦ nqp: review: https://github.com/perl6/nqp/commit/1e4c6099ff

[01:10] <Geth> ¦ nqp: 22fda51d60 | (Samantha McVey)++ | 6 files

[01:10] <Geth> ¦ nqp: Merge pull request #348 from samcv/qregex_tests

[01:10] <Geth> ¦ nqp:

[01:10] <Geth> ¦ nqp: Update qregex tests to allow backend specific todo's

[01:10] <Geth> ¦ nqp: review: https://github.com/perl6/nqp/commit/22fda51d60

[01:12] <samcv> so is it ok for me to remove all of the # todo :pugs<feature> in the nqp tests or no?

[01:18] <timotimo> yeah, pugs has been gone for so long, it's safe

[04:40] <Geth> ¦ nqp: bb04e11bdb | (Samantha McVey)++ | 5 files

[04:40] <Geth> ¦ nqp: Remove references of pugs from qregex tests

[04:40] <Geth> ¦ nqp:

[04:40] <Geth> ¦ nqp: Concensus seems that this is sufficiently old that we can remove these

[04:40] <Geth> ¦ nqp: TODO's for these tests. Also of note is that even if pugs was running, the

[04:40] <Geth> ¦ nqp: tests would not actually TODO under pugs.

[04:40] <Geth> ¦ nqp: review: https://github.com/perl6/nqp/commit/bb04e11bdb

[04:40] <Geth> ¦ nqp: 9f65489d6b | (Samantha McVey)++ | t/moar/09-concat.t

[04:40] <Geth> ¦ nqp: [moar] Add a test for concat returns correct NFG string

[04:40] <Geth> ¦ nqp:

[04:40] <Geth> ¦ nqp: Also test that it returns the correct charcount.

[04:40] <Geth> ¦ nqp:

[04:40] <Geth> ¦ nqp: This was added to increase coverage as well as to get better testing

[04:40] <Geth> ¦ nqp: for concat functions that concat two strings which change under normalization.

[04:40] <Geth> ¦ nqp:

[04:40] <Geth> ¦ nqp: Such as \r\n and a + diacritic

[04:40] <Geth> ¦ nqp: review: https://github.com/perl6/nqp/commit/9f65489d6b

[04:40] <samcv> timotimo, ok started to add some concat tests involving \r\n as well as diacritics

[07:26] <Geth> ¦ nqp: 17212d2101 | (Samantha McVey)++ | tools/build/MOAR_REVISION

[07:26] <Geth> ¦ nqp: Bump MoarVM to get concat speed + more than 30% with some jobs

[07:26] <Geth> ¦ nqp:

[07:26] <Geth> ¦ nqp: Speed up concatenation with control character at the joining

[07:26] <Geth> ¦ nqp: ends of the string.

[07:26] <Geth> ¦ nqp:

[07:26] <Geth> ¦ nqp: 477e023b Optimize MVM_nfg_is_concat_stable to speed up concatenation of strings

[07:26] <Geth> ¦ nqp: cac2a57c Do not set use rpath if installing into proper system locations

[07:26] <Geth> ¦ nqp: review: https://github.com/perl6/nqp/commit/17212d2101

[07:26] <Geth> ¦ nqp: version bump brought these changes: https://github.com/MoarVM/MoarVM/compare/2017.03-4-gfe1dc84a...2017.03-7-g029d1218

[07:30] <Geth> ¦ rakudo/nom: 027aa544e8 | (Samantha McVey)++ | tools/build/NQP_REVISION

[07:30] <Geth> ¦ rakudo/nom: Bump NQP/Moar to get concat speed + more than 30% with some jobs

[07:30] <Geth> ¦ rakudo/nom:

[07:30] <Geth> ¦ rakudo/nom: Speed up concatenation with control character at the joining

[07:30] <Geth> ¦ rakudo/nom: ends of the string, plus the other commits that have happened since.

[07:30] <Geth> ¦ rakudo/nom:

[07:30] <Geth> ¦ rakudo/nom: 17212d21 Bump MoarVM to get concat speed + more than 30% with some jobs

[07:30] <Geth> ¦ rakudo/nom: 9f65489d [moar] Add a test for concat returns correct NFG string

[07:30] <Geth> ¦ rakudo/nom: <…commit message has 8 more lines…>

[07:30] <Geth> ¦ rakudo/nom: review: https://github.com/rakudo/rakudo/commit/027aa544e8

[07:30] <Geth> ¦ rakudo/nom: version bump brought these changes: https://github.com/perl6/nqp/compare/2017.03...2017.03-10-g17212d21

[07:40] <Geth> ¦ nqp: 4e2ee32303 | (Samantha McVey)++ | .travis.yml

[07:40] <Geth> ¦ nqp: Travis CI JVM passes so don't ignore failures anymore

[07:40] <Geth> ¦ nqp:

[07:40] <Geth> ¦ nqp: JVM testing has been fixed from one of my previous commits, so it is

[07:40] <Geth> ¦ nqp: okay for us to remove the `allow_failures` line for JVM.

[07:40] <Geth> ¦ nqp: review: https://github.com/perl6/nqp/commit/4e2ee32303

[07:57] <[Tux]> This is Rakudo version 2017.03-20-g027aa544e built on MoarVM version 2017.03-7-g029d1218

[07:57] <[Tux]> csv-ip5xs        3.167

[07:57] <[Tux]> test            12.509

[07:57] <[Tux]> test-t           4.975 - 5.091

[07:57] <[Tux]> csv-parser      12.726

[07:59] <samcv> is that less than it was before [Tux] ?

[07:59] <samcv> heh did the version bump to try and get my speed improvement in there. may have no change depending on the code

[08:00] <samcv> hmm looks about the same. numbers seem to fluctuate a bit around 4.9

[08:00] <[Tux]> same within noise

[08:00] <[Tux]> huggable: speed

[08:00] <huggable> [Tux], http://tux.nl/Talks/CSV6/speed4.html

[08:01] <samcv> speeds up JSON::Fast 30% on a document with \r\n line endings at least

[08:01] <samcv> and probably speeds up the concatenatieon even more than that in certain cases

[08:02] <[Tux]> http://tux.nl/Talks/CSV6/images/test-t-6.png

[08:56] <Geth> ¦ roast: 8eff4844f3 | (Elizabeth Mattijsen)++ | S05-modifier/ignorecase.t

[08:56] <Geth> ¦ roast: Don't need to test 'ﬆ' case twice

[08:56] <Geth> ¦ roast: review: https://github.com/perl6/roast/commit/8eff4844f3

[09:38] <gfldex> m: class C {}; use MONKEY; augment class C { has $.baggage; }; my C $s .= new(baggage => 'foo');

[09:38] <camelia> rakudo-moar 027aa5: OUTPUT: «P6opaque: no such attribute '$!baggage' in type C when trying to get a value␤  in block <unit> at <tmp> line 1␤␤»

[09:38] <gfldex> this should either warn (in the augment block) or work

[10:02] <IOninja> buggable: speed

[10:02] <buggable> IOninja, ▁▁▂▁▂▁▁▁▁▁▂▁▂▂▂▂▂▂▂▁▂▁▁▃▂▂▂▂▂▁▁█▂▂▃▁▁▁▁▁▁▁▁▁▁▁▁▁▂▁ data for 2017-02-28–2017-03-22; range: 4.829s–7.664s

[10:08] <lizmat> gfldex: if you BEGIN the augment ?

[10:11] <IOninja> https://irclog.perlgeek.de/perl6-dev/2017-03-21#i_14303344

[10:12] <IOninja> Actually, indeed that would've been the case but that line of code had TWO bugs. Second one is the assumption Proc.Bool is `$!exitcode`, when it's actually `$!exitcode == 0`

[10:12] <IOninja> So the already-broken result was always inverted

[11:35] <dogbert17> o/

[11:36] <dogbert17> anyone, |Tux| in particular ever seen this before: 'Deprecated use of %*LANG<MAIN> assignment detected in use; module should export syntax using $*LANG.define_slang("MAIN",<grammar>,<actions>) instead

[11:36] <dogbert17> (value in braid: Perl6::Grammar, value in %*LANG: Perl6::Grammar+{Tuxic})

[11:39] <lizmat> maybe you should update your Slang::Tuxic ?

[11:40] <lizmat> I seem to recall FROGGS fixing it to support the new slang API

[11:40] <lizmat> or was it TimToady ?

[11:41] * dogbert17 tries 'zef install --force Slang::Tuxic'

[11:42] <dogbert17> Installing: Slang::Tuxic:ver('0.0.1'):auth('github:FROGGS') ...

[11:42] <dogbert17> and the warning still shows up

[11:43] <lizmat> :-(

[11:43] <lizmat> please file an issue  :-)

[11:43] <dogbert17> will do

[11:43] <lizmat> and/or a PR  :-)

[11:43] <lizmat> the change should be fairly small

[11:44] <dogbert17> hmm :)

[11:45] <dogbert17> lizmat: doing any cool optimizations atm?

[11:45] <lizmat> https://gist.github.com/lizmat/1c80d2210aeb4239810d7818fca7e575

[11:52] <dogbert17> that look hypercool :)

[11:52] <dogbert17> *looks

[11:54] <dogbert17> so that code works even before jnthn has fixed up race and hyper?

[11:54] <lizmat> it's another approach to it

[11:54] <dogbert17> ah

[11:55] <lizmat> it would need to make .hyper and .race act more like macro's

[11:55] <dogbert17> so you're waiting for comments from jnthn

[11:55] <timotimo> you can still do that kind of API with just making the methods "intelligent"

[11:56] <dogbert17> o/ timotimo

[11:56] <timotimo> o/

[11:56] <dogbert17> lizmat: is harness6 still working for you?

[11:57] <lizmat> dogbert17: yes, waiting for comments  :-)

[11:57] * lizmat checks

[11:57] <timotimo> i.e. .hyper would return a HyperMethodSponge that will soak up methods called on it until something that's supposed to go from hyper to eager semantics happens

[11:57] <timotimo> at that point it'll recall what methods with what arguments were called and set up a pipeline from those

[11:58] <DrForr> A .squeeze method would be apporpriate there :)

[11:59] <DrForr> *appropriate

[12:00] <timotimo> don't appropriate that method

[12:00] <lizmat> timotimo: how would you do that ?

[12:01] <lizmat> I mean, how can a method know which methods it gets called on it ?

[12:01] <moritz> has anybody considered an approach where we separate the storage of the lists/seqs from the evaluation methods?

[12:01] <timotimo> let me whip up a one-line eval real quick

[12:01] <lizmat> moritz: isn't that what I'm doing ?

[12:02] <moritz> lizmat: dunno, I didn't backlog enough :/

[12:02] <lizmat> dogbert17: at first try, works fine by me

[12:02] <lizmat> moritz: check out my gist: https://gist.github.com/lizmat/1c80d2210aeb4239810d7818fca7e575

[12:04] <timotimo> m: class Sponge { has @.calls; has $.target; method !newsponge($meth, $args) { my @newcalls = @calls[]; @newcalls.push($meth => $args); Sponge.new(calls => @newcalls, :$.target }; method map(&block) { self!newsponge("map", \(&block)); }; method grep($matcher) { self!newsponge("grep", \($matcher)) } }; my $bucket = "Hello"; Sponge( target => $bucket).map("hi").grep("lol").map("transform!!").perl.say

[12:04] <camelia> rakudo-moar 027aa5: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Variable '@calls' is not declared. Did you mean '@!calls'?␤at <tmp>:1␤------> 3ewsponge($meth, $args) { my @newcalls = 7⏏5@calls[]; @newcalls.push($meth => $args)␤»

[12:04] <timotimo> m: class Sponge { has @.calls; has $.target; method !newsponge($meth, $args) { my @newcalls = @.calls[]; @newcalls.push($meth => $args); Sponge.new(calls => @newcalls, :$.target }; method map(&block) { self!newsponge("map", \(&block)); }; method grep($matcher) { self!newsponge("grep", \($matcher)) } }; my $bucket = "Hello"; Sponge( target => $bucket).map("hi").grep("lol").map("transform!!").perl.say

[12:04] <camelia> rakudo-moar 027aa5: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Unable to parse expression in argument list; couldn't find final ')' ␤at <tmp>:1␤------> 3ponge.new(calls => @newcalls, :$.target 7⏏5}; method map(&block) { self!newsponge("␤»

[12:04] <timotimo> m: class Sponge { has @.calls; has $.target; method !newsponge($meth, $args) { my @newcalls = @.calls[]; @newcalls.push($meth => $args); Sponge.new(calls => @newcalls, :$.target) }; method map(&block) { self!newsponge("map", \(&block)); }; method grep($matcher) { self!newsponge("grep", \($matcher)) } }; my $bucket = "Hello"; Sponge( target => $bucket).map("hi").grep("lol").map("transform!!").perl.say

[12:04] <camelia> rakudo-moar 027aa5: OUTPUT: «Cannot coerce to Sponge with named arguments␤  in block <unit> at <tmp> line 1␤␤»

[12:04] <timotimo> oh yes

[12:04] <timotimo> m: class Sponge { has @.calls; has $.target; method !newsponge($meth, $args) { my @newcalls = @.calls[]; @newcalls.push($meth => $args); Sponge.new(calls => @newcalls, :$.target) }; method map(&block) { self!newsponge("map", \(&block)); }; method grep($matcher) { self!newsponge("grep", \($matcher)) } }; my $bucket = "Hello"; Sponge.new( target => $bucket).map("hi").grep("lol").map("transform!!").perl.say

[12:04] <camelia> rakudo-moar 027aa5: OUTPUT: «Type check failed in binding to '&block'; expected Callable but got Str ("hi")␤  in method map at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[12:05] <timotimo> right

[12:05] * lizmat updated the gist to handle cases where a worker would produce an empty list

[12:05] <timotimo> m: class Sponge { has @.calls; has $.target; method !newsponge($meth, $args) { my @newcalls = @.calls[]; @newcalls.push($meth => $args); Sponge.new(calls => @newcalls, :$.target) }; method map(&block) { self!newsponge("map", \(&block)); }; method grep($matcher) { self!newsponge("grep", \($matcher)) } }; my $bucket = "Hello"; Sponge.new( target =>

[12:05] <camelia> rakudo-moar 027aa5: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Preceding context expects a term, but found infix => instead␤at <tmp>:1␤------> 3$bucket = "Hello"; Sponge.new( target =>7⏏5<EOL>␤»

[12:05] <timotimo> $bucket).map({"hi"}).grep("lol").map({"transform!!"}).perl.say

[12:05] <timotimo> dang

[12:05] <timotimo> it split it across two lines

[12:06] <jnthn> lizmat: fwiw, I was already handling that without any macro-ish stuff needed in https://github.com/rakudo/rakudo/blob/nom/src/core/HyperSeq.pm and https://github.com/rakudo/rakudo/blob/nom/src/core/HyperIterator.pm and so forth

[12:06] <yoleaux2> 09:36Z <lizmat> jnthn: I left some comments with https://gist.github.com/lizmat/b76e88519b74667c8433190941bb6e6a

[12:06] <yoleaux2> 11:18Z <lizmat> jnthn: a new gist: https://gist.github.com/lizmat/1c80d2210aeb4239810d7818fca7e575

[12:06] <yoleaux2> 11:19Z <lizmat> jnthn: this version created R:It.(Hyper|Race)Actions iterators, that take a list of method => capture pairs to execute: so no special casing needed anymore

[12:06] <yoleaux2> 11:21Z <lizmat> jnthn: from where I sit, we only need to fix the syntactic sugar for transforming .hyper.map(foo).grep(bar) to R:It.HyperActions( , (map => \(foo), grep => \(bar) )

[12:06] <jnthn> I don't think it should be done as syntax sugar

[12:06] <jnthn> Doubly so when I already showed it can be done without. :P

[12:07] <timotimo> m: https://gist.github.com/timo/d176e52ae8ef164fefdac863e370a7b9

[12:07] <camelia> rakudo-moar 027aa5: OUTPUT: «Sponge.new(calls => [:map(\(-> ;; $_? is raw { #`(Block|62564352) ... })), :grep(\("lol")), :map(\(-> ;; $_? is raw { #`(Block|62565144) ... }))], target => "Hello")␤»

[12:07] <timotimo> have a sponge

[12:08] <lizmat> timotimo: but that would involve needing to support all methods in the world in the sponge, or provide a FALLBACK I suppose

[12:08] <timotimo> right

[12:08] <timotimo> we have to differentiate what a method would do anyway

[12:08] <timotimo> for example a .eager would kick us out of a hyper pipeline

[12:09] <timotimo> and .list and .Supply and what have you, those all need to go out of sponge mode directly

[12:09] <timotimo> and methods that aren't supposed to exist in the first place should throw exceptions immediately

[12:09] <timotimo> in the case of the hyperseq thing, HyperSeq would be Sponge, btw

[12:09] <lizmat> timotimo: but how can you know?

[12:09] <timotimo> BBIAB

[12:09] <lizmat> ack

[12:09] <timotimo> HyperSeq knows

[12:09] <timotimo> Sponge is just a demonstration of the pattern

[12:10] <lizmat> yeah, got that

[12:10] <timotimo> also, as jnthn said just now, it wouldn't even have to do the thing with the @.calls, just copy his impl of HyperSeq and HyperIterator "and so forth" i guess

[12:11] <lizmat> timotimo: but my approach is very different from jnthn's

[12:12] <lizmat> although I could see HyperSeq actiing like a Sponge  :-)

[12:13] <jnthn> Yeah, I need to look properly at what lizmat++ is proposing and figure out the advantages/disadvantages compared to what I was originally planning

[12:14] <jnthn> Though to me, a model where requesting the .iterator is the point that you fall out of the parallel pipeline and actually make work happen is nice in that it naturally handles a bunch of questions

[12:15] <[TuxCM]> dogbert17, https://github.com/FROGGS/p6-Slang-Tuxic/pull/3

[12:15] <jnthn> And everything that works in terms of .cache or .list will, in that model, simply work using the sequential iterator

[12:15] <jnthn> So we don't need to special-case stuff like .eager and .perl and so on

[12:15] <[TuxCM]> https://github.com/FROGGS/p6-Slang-Tuxic/commit/0af6050155c2f1ec7695ef083eef33e9b1985709

[12:16] <jnthn> lunch; bbi20

[12:24] <dogbert17> [TuxCM]: doesn't that mean the the problem shouldn't show up?

[12:25] <lizmat> perhaps it still installed the old version ?

[12:26] <lizmat> zef update or something maybe ?

[12:27] <dogbert17> lizmat: maybe I'm stupid but it seems to use both approaches no? https://github.com/FROGGS/p6-Slang-Tuxic/blob/master/lib/Slang/Tuxic.pm#L49

[12:28] <lizmat> perhaps we need a quietly in there ?

[12:28] <lizmat> quietly try ...

[12:28] <lizmat> m: try warn "foo"

[12:28] <camelia> rakudo-moar 027aa5: OUTPUT: «foo␤  in code  at <tmp> line 1␤»

[12:28] <lizmat> m: quietly try warn "foo"

[12:28] <camelia> rakudo-moar 027aa5: ( no output )

[12:29] <dogbert17> ah, so a quietly on the first/old approach then

[12:32] <lizmat> yup  :-)

[12:33] <[Coke]> ugexe: (Zef not zef) - ok, still a bug I think that you end up with a bunch of "Nil in string context" errors.

[12:33] <yoleaux2> 21 Mar 2017 22:21Z <IOninja> [Coke]: I built 2017.02 Rakudo and old (a507fbb) zef commit and it still has those warnings. It makes me think there's something bustified in the ecosystem JSON

[12:33] <yoleaux2> 21 Mar 2017 22:47Z <IOninja> [Coke]: re warnings in zef: https://irclog.perlgeek.de/perl6-dev/2017-03-21#i_14303217

[13:01] <timotimo> is anybody running a 4.10 linux kernel?

[13:02] <tadzik> I will when I reboot :P

[13:02] <timotimo> i wonder if i should just grab a kernel of that version from a testing repo or a copr, or heck build it myself

[13:03] <timotimo> because 4.10 has perf c2c

[13:03] <timotimo> i've been itching to try that out for a while now

[13:07] <lizmat> m: sub a(\method) { dd method }   # grin

[13:07] <camelia> rakudo-moar 027aa5: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Missing block␤at <tmp>:1␤------> 3sub a(\method) { dd method 7⏏5}   # grin␤»

[13:08] <lizmat> m: sub a(\sub) { dd sub }   # grin

[13:08] <camelia> rakudo-moar 027aa5: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Missing block␤at <tmp>:1␤------> 3sub a(\sub) { dd sub 7⏏5}   # grin␤    expecting any of:␤        new name to be defined␤»

[13:08] <lizmat> I guess method and sub are hardcoded in the grammar  :-)

[13:09] <timotimo> sure

[13:09] <timotimo> we might want to warn about that ...

[13:09] <timotimo> but you can work around it, of course

[13:10] <timotimo> m: sub a(\sub) { dd ::('sub') }

[13:10] <camelia> rakudo-moar 027aa5: ( no output )

[13:10] <lizmat> yeah, no problem

[13:10] <timotimo> m: sub a(\sub) { dd ::('sub') }; a({ say "woop" })

[13:10] <camelia> rakudo-moar 027aa5: OUTPUT: «-> ;; $_? is raw { #`(Block|39092024) ... }␤»

[13:10] <lizmat> just use another name or sigili it

[13:10] <lizmat> m: sub a($sub) { dd $sub }   # fine

[13:10] <camelia> rakudo-moar 027aa5: ( no output )

[13:10] <timotimo> well, you can get the same behavior as the \ sigil with "is raw", but my point is you don't need to do that

[13:10] <timotimo> unless

[13:10] <timotimo> you refer to ::(' as a sigil ')

[13:11] <lizmat> yeah, it was just unexpected :-)

[13:11] <lizmat> a bit of a wat :-)

[13:11] <lizmat> nothing I can't work around  :-)

[13:11] <timotimo> we can put a piece of code into the part that generates that error

[13:12] <timotimo> and check if there's a lexical variable with that name around

[13:12] <lizmat> no worries... am in a flow to get hyper and race working well  :-)

[13:13] <lizmat> using a sponge  :-)

[13:14] <lizmat> timotimo: a ^add_method causes a global deopt, right ?

[13:15] <lizmat> also: can I safely do an existskey on a hash from several threads if one of the threads may be adding to it ?

[13:19] <timotimo> not sure

[13:19] <timotimo> existskey might be safe

[13:20] <lizmat> and atkey ?

[13:20] <lizmat> I'll just wrap the whole logic into a protect block to be on the safe side

[13:20] <timotimo> oh wait

[13:20] <timotimo> if one of the threads is adding to it, then you're toast

[13:21] <lizmat> yeah, ok, wrapping it completely then  :-)

[13:25] <timotimo> in the future we'll have a plan that won't crash you when you do that

[13:25] <timotimo> you'll just get out-of-date data

[13:27] <lizmat> cool, but I'll just protect that code now  :-)

[13:27] <timotimo> yup

[13:34] * lizmat is enjoying herself  :-)

[13:35] <ugexe> [Coke]: thats not a pattern unique to zef. try doing `use Distribution-Name-Without-Matching-Module-Name` (`use zef`, `use Net::HTTP`)

[13:35] <ugexe> you'll get the same error right from rakudo

[13:36] <[Coke]> sure, but as a user of zef, I shouldn't be exposed to that.

[13:37] <ugexe> should any user be exposed to those Nil errors if they `use Some::Module`?

[13:37] <[Coke]> ... and let me back track that immediately and ask nine to fix it. :)

[13:38] <[Coke]> m: use barf

[13:38] <camelia> rakudo-moar 027aa5: OUTPUT: «===SORRY!===␤Could not find barf at line 1 in:␤    /home/camelia/.perl6␤    /home/camelia/rakudo-m-inst-1/share/perl6/site␤    /home/camelia/rakudo-m-inst-1/share/perl6/vendor␤    /home/camelia/rakudo-m-inst-1/share/perl6␤    CompUnit::Reposi…»

[13:39] <[Coke]> ugexe: looks like the errors only come when you try to print the result.

[13:39] <[Coke]> (e.g. in the REPL) - so what is zef doing with the result of a use that is triggering the Nil error?

[13:40] <[Coke]> m: say { use barf }

[13:40] <camelia> rakudo-moar 027aa5: OUTPUT: «===SORRY!===␤Could not find barf at line 1 in:␤    /home/camelia/.perl6␤    /home/camelia/rakudo-m-inst-1/share/perl6/site␤    /home/camelia/rakudo-m-inst-1/share/perl6/vendor␤    /home/camelia/rakudo-m-inst-1/share/perl6␤    CompUnit::Reposi…»

[13:40] <[Coke]> m: BEGIN say { use barf }

[13:40] <camelia> rakudo-moar 027aa5: OUTPUT: «===SORRY!===␤Could not find barf at line 1 in:␤    /home/camelia/.perl6␤    /home/camelia/rakudo-m-inst-1/share/perl6/site␤    /home/camelia/rakudo-m-inst-1/share/perl6/vendor␤    /home/camelia/rakudo-m-inst-1/share/perl6␤    CompUnit::Reposi…»

[13:40] <ugexe> zef install Net::HTTP && perl6 -e 'use Net::HTTP'

[13:40] <ugexe> or just `use zef;`

[13:40] <[Coke]> (get the bad error locally with ' perl6 -e 'say {use zef}' ')

[13:41] <[Coke]> ugexe: ok, but "perl6 -e 'use zef'" doesn't generate that error.

[13:41] <ugexe> it does for me

[13:41] <[Coke]> ah. there is a difference locally between:

[13:41] <[Coke]> 'use zef' and 'use barf' - zef gives the error, barf does not.

[13:41] <ugexe> `Use of Nil in string context` is what you mean right?

[13:41] <[Coke]> barf gives the useful error.

[13:42] <[Coke]> zef gives the "Use of Nil" error.

[13:42] <[Coke]> ZEF also gives the useful error

[13:42] <ugexe> but yeah, barf is properly ignored. `zef` is not because it matches a distribution name (it doesnt get checked if it actually provides a zef.pm that can be used)

[13:42] <ugexe> from rakudos perspective

[13:44] <[Coke]> (distribution name) ah, that's the key point. danke.

[13:44] <ugexe> yeah, it happens with Net::HTTP because thats *only* its distribution name - it provides no Net::HTTP module (just Net::HTTP::*)

[13:46] <[Coke]> ugexe: RT #131041

[13:46] <synopsebot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=131041

[13:47] <[Coke]> (my initial efforts at gathering data were confused by me using zef in one place and barf in another and expecting them to be the same. :)

[13:49] <[Coke]> .ask nine if he can look at https://rt.perl.org/rt3//Public/Bug/Display.html?id=131041

[13:49] <yoleaux2> [Coke]: I'll pass your message to nine.

[13:50] <[Coke]> synopsebot6: owner?

[13:50] <[Coke]> synopsebot6: code?

[13:50] <[Coke]> synopsebot6: help

[13:50] <[Coke]> synopsebot6: .

[13:50] <[Coke]> bah

[14:06] <timotimo> it me

[14:06] <timotimo> what's wrong with it?

[14:33] <timotimo> [Coke]: what's wrong with synopsebot6?

[16:09] <Zoffix_> lizmat, is there stuff from newio you think we still can and should bring back to 6.d? Since 6.d is additive to 6.c, looks like most of that stuff can't be transfered? There's one thing that I think is a wrong way to go and lots of stuff hinges on it: IO::Pathy's assumption that (or caching of info that) if an object exists that it'll continue to exist, yet it can be deleted by other programs or even

[16:09] <Zoffix_> another IO::Pathy. So this means `.e` on IO::File, IO::Dir, and IO::Local (what does ::Local represent?) will lie and just give the cached result. Is IO::Huh meant to play a role in this? (I tried a few commits but can't find one that doesn't have merge conflicts and compiles, so I can't play with the a newio rakudo). Basically, I don't know the masterplan behind here; you do. What should I and can bring

[16:09] <Zoffix_> to 6.d?

[16:10] <Zoffix_> .tell lizmat some questions: https://irclog.perlgeek.de/perl6-dev/2017-03-22#i_14307060

[16:10] <yoleaux2> Zoffix_: I'll pass your message to lizmat.

[16:20] <ugexe> i think IO::Huh was meant to allow something like IO::File.new(uri => ...) to work, which intended to let you supply your own reader/writer essentially

[16:20] <ugexe> all i remember from newio stuff was IO::File.new(uri => ...) and how I thought that would have been cool

[16:24] <lizmat> Zoffix_: I'm pretty burned out on newio: take of it what you like, or dump the whole thing

[16:24] <yoleaux2> 16:10Z <Zoffix_> lizmat: some questions: https://irclog.perlgeek.de/perl6-dev/2017-03-22#i_14307060

[16:24] <lizmat> sometimes the journey is more important than reaching the goal

[16:27] <Zoffix_> Noted.

[16:29] <ugexe> the other IO thing i'd really like to see is IO::Socket to be IO::Handle

[16:29] <ugexe> or at least an IO interface for dealing with a a file handle *or* socket data

[16:29] <jdv79> its all about the journey

[16:30] <Zoffix_> IO::Socket* stuff is out of scope of the grant.

[16:31] <Zoffix_> A lot of people requested Unix sockets too

[16:31] <lizmat> .tell jnthn almost completely functional .hyper / .race: https://gist.github.com/lizmat/6256f19136990b071ecc6695e7f5b5f2

[16:31] <yoleaux2> lizmat: I'll pass your message to jnthn.

[16:32] <ugexe> for $900 I figure everything you're doing is out of scope lol

[16:32] <lizmat> .tell jnthn had to call it hijper / rees because you can't augment a role

[16:32] <yoleaux2> lizmat: I'll pass your message to jnthn.

[16:32] <jnthn> lizmat: Please can we *not* write concurrent code in nqp::ops?

[16:32] <yoleaux2> 16:31Z <lizmat> jnthn: almost completely functional .hyper / .race: https://gist.github.com/lizmat/6256f19136990b071ecc6695e7f5b5f2

[16:32] <yoleaux2> 16:32Z <lizmat> jnthn: had to call it hijper / rees because you can't augment a role

[16:33] <jnthn> It's hard enough as it is :)

[16:34] <lizmat> jnthn: is it ok if I keep the processing inside a worker in nqp?

[16:34] <jnthn> Sure, hot path bits are fine

[16:34] <jnthn> It's just that nqp:: ops makde stuff quite hard to follow

[16:35] <lizmat> ok, will rewrite in HLL  :-)

[16:35] <jnthn> I'm looking forward to getting our code-gen sorted out enough that we can undo some of them in CORE.setting :)

[16:35] <lizmat> as am I  :-)

[16:36] <jnthn> (Yes, for now it's a decent trade-off.)

[16:37] <jnthn> I'm kinda coming around to having both a HyperSeq and RaceSeq

[16:37] <jnthn> Since while in some cases the difference will be pretty small (just order retention), in others they're very different

[16:37] <jnthn> (Such as with .reduce)

[16:37] <jnthn> And it'd be kinda nice to just let multi-dispatch resolve those.

[16:39] <jnthn> I wonder if HyperSeq and RaceSeq should also just inherit from Seq also

[16:40] <jnthn> Which would save us the FALLBACK

[16:41] <lizmat> hmmm...    I've solved that with 2 different iterators internally, with different pull-one/push-all but same sink-all

[17:25] <[Coke]> timotimo: extra / in the URL (rt3//)

[17:52] <timotimo> [Coke]: i'll have a look

[17:55] <timotimo> RT #12345

[17:55] <timotimo> RT #18401

[17:55] <synopsebot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=18401

[17:55] <timotimo> it's gone

[18:20] <Zoffix_> m: https://gist.github.com/zoffixznet/e6dd979e9291eb6be6d041e53700cfb4

[18:20] <camelia> rakudo-moar 027aa5: OUTPUT: «WARNINGS for <tmp>:␤Useless use of () in sink context (line 30)␤(0 => ("a", "b", "c"), 1 => 4, 2 => 5, 3 => 6).Seq␤(0 => ("a", "b", "c"),).Seq␤»

[18:20] <Zoffix_> That's whacked. The only difference between the two methods is the semicolon on line 30

[18:21] <Zoffix_> And warning is bogus

[18:21] <Zoffix_> Oh

[18:21] <Zoffix_> Right. It's inside the nqp::if() duh. NEVERMIND

[18:32] <nine> By now nqp:: ops are probably more natural to lizmat than the Dutch language.

[18:32] <yoleaux2> 13:49Z <[Coke]> nine: if he can look at https://rt.perl.org/rt3//Public/Bug/Display.html?id=131041

[18:44] <Zoffix_> ZOFVM: Files=1228, Tests=132905, 121 wallclock secs (21.52 usr  3.42 sys + 2343.52 cusr 271.72 csys = 2640.18 CPU)

[18:50] <Geth> ¦ rakudo/nom: 5927186d31 | (Zoffix Znet)++ | src/core/Any-iterable-methods.pm

[18:50] <Geth> ¦ rakudo/nom: Make Any.maxpairs/.minpairs use `cmp` and return Seq

[18:50] <Geth> ¦ rakudo/nom:

[18:50] <Geth> ¦ rakudo/nom: ...instead of numeric comparison. Per:

[18:50] <Geth> ¦ rakudo/nom: https://irclog.perlgeek.de/perl6-dev/2017-03-16#i_14275808

[18:50] <Geth> ¦ rakudo/nom:

[18:50] <Geth> ¦ rakudo/nom: Make them return a Seq instead of an Array, to maintain consistency

[18:50] <Geth> ¦ rakudo/nom: with Setty.maxpairs/.minpairs and other similar methods that all

[18:50] <Geth> ¦ rakudo/nom: return Seqs

[18:50] <Geth> ¦ rakudo/nom: review: https://github.com/rakudo/rakudo/commit/5927186d31

[18:51] <Geth> ¦ roast: 3eff8196a8 | (Zoffix Znet)++ | S29-any/minpairs-maxpairs.t

[18:51] <Geth> ¦ roast: Add tests for Any.maxpairs/.minpairs

[18:51] <Geth> ¦ roast:

[18:51] <Geth> ¦ roast: Rakudo fix: https://github.com/rakudo/rakudo/commit/5927186d31

[18:51] <Geth> ¦ roast: review: https://github.com/perl6/roast/commit/3eff8196a8

[18:52] <Geth> ¦ rakudo/nom: 8d06b8a13c | (Zoffix Znet)++ | t/spectest.data

[18:52] <Geth> ¦ rakudo/nom: Run S29-any/minpairs-maxpairs.t test file

[18:52] <Geth> ¦ rakudo/nom: review: https://github.com/rakudo/rakudo/commit/8d06b8a13c

[18:55] <lizmat> nine: very true

[19:12] <lizmat> hmmm... how can I find out how "for @a { .say }" is codegenned ?

[19:14] <lizmat> hmmm... looks like @a.map: { .say }

[19:14] <timotimo> does it have some kind of magic for single-arg-rule stuff?

[19:15] <lizmat> no, if I have something like:  for @a.map( ~* ).grep( * %% 2 )

[19:16] <lizmat> it gets codegenned like:  for @a.map( ~* ).grep( * %% 2 ).map ...

[19:16] <jnthn> At the moment, yes

[19:16] <lizmat> the last .map should serialize, but since it is called on the sponge, it gets parallelized :-(

[19:16] <jnthn> I think it passes a :item too

[19:17] <lizmat> ah, ok, lemme check  :-)

[19:17] <jnthn> The last map should serialize? Really?

[19:17] * jnthn had it as `hyper for @a { }` desugaring to `for @a.hyper { }` fwiw

[19:18] <jnthn> I think the "for is map" goes deep enough that if the thing you're iterating over is a HyperSeq or RaceSeq then your loop runs in parallel

[19:19] <Zoffix_> Wondering how to judge what to document and what is an impl. detail. Setty role implements maxpairs/minpairs, but it's just an optimization for Any.maxpairs/.minpairs

[19:21] <Zoffix_> m: class Foo does Setty { method maxpairs { say "hi" } }.new.maxpairs

[19:21] <camelia> rakudo-moar 8d06b8: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Cannot have a multi candidate for 'maxpairs' when an only method is also in the package 'Foo'␤at <tmp>:1␤»

[19:21] <Zoffix_> m: class Foo { method maxpairs { say "hi" } }.new.maxpairs

[19:21] <camelia> rakudo-moar 8d06b8: OUTPUT: «hi␤»

[19:21] * Zoffix_ documents it...

[19:24] <lizmat> jnthn: sorry, the code would be:  for @a.hyper.map( *++ ).grep( * %% 2 ) { ... }

[19:24] <lizmat> the implicit .map at the end should serialize, no ?

[19:24] <jnthn> lizmat: No, I don't think so

[19:24] <lizmat> ah?

[19:24] <lizmat> we;re talking hyper, not race, right ?

[19:25] <jnthn> Either

[19:25] <jnthn> I mean, we can decide it should go back to serial mode

[19:25] <lizmat> my @a = ^10; for @a.hyper.map( *++ ).grep( * %% 2 ) { .say }  # so this shoudn't 0 2 4 6 8 ?

[19:27] <jnthn> Depends how we decide to call it.

[19:28] <jnthn> If we want to say "for desugars to map, and at statement list level will always .sink" then it would follow that any hyper/race that map chains onto would be contaigous.

[19:29] <jnthn> The alternative would be to say that for is not defined in terms of .map, but in terms of .iterator (which is always sequential)

[19:29] <jnthn> But then we'd need to decide what `hyper for x { }` and `race for x { }` will mean :)

[19:30] <jnthn> I didn't give `for` a separate entry in my sheet because I'd just assumed it fell under map

[19:30] <jnthn> But it is worth considering if that's really wise, given it feels like an imperative construct

[19:30] <lizmat> hyper for x { }  should be like for x.hyper { }

[19:31] <jnthn> It could be.

[19:32] <jnthn> It's worth considering in with this if we *want* to force implementations to desugar `for` into a call to `map`

[19:32] <jnthn> Or if (non-hyper/race) would just directly code-gen something that deals with the iterator API

[19:32] <jnthn> Which would get us a decent speed-up

[19:33] <jnthn> Though maybe not in the longer term once we get better at optimizing higher-order stuff

[19:34] <lizmat> yeah, I mean, in profiles you don't see the map methods themselves, but the blocks of the iterators

[19:34] <jnthn> Aye

[19:34] <Geth> ¦ roast: 11626cb3e2 | (Zoffix Znet)++ | S29-any/minpairs-maxpairs.t

[19:34] <Geth> ¦ roast: Test Setty.maxpairs/.minpairs

[19:34] <Geth> ¦ roast:

[19:34] <Geth> ¦ roast: https://irclog.perlgeek.de/perl6-dev/2017-03-22#i_14307973

[19:34] <Geth> ¦ roast: review: https://github.com/perl6/roast/commit/11626cb3e2

[19:35] <jnthn> Anyway, seems I can argue `for` more than one way without it sounding unreasonable, so that will need more pondering :)

[19:36] <jnthn> The contaigion approach worries me just a bit because of somebody doing `for something() { ...mutate a ton of stuff... }`

[19:36] <jnthn> And landing in bother if the something() turns out to return a HyperSeq or RaceSeq

[19:37] <jnthn> If you're just calling .map on something, well, you have to be open to the fact that it can interpret that method call however it wants

[19:37] <lizmat> perhaps we need an .iterate  :-)

[19:37] <jnthn> But a `for` gaining parallel semantics might be a bit too muscular

[19:38] <jnthn> This also makes we wonder if HyperSeq ~~ Seq is really a good idea

[19:38] <jnthn> Because then you can't type-constrain on "this is serial"

[19:38] <lizmat> from what I see so far, its not

[19:39] <jnthn> There are significant commonalities that we'd share between the two, mind

[19:39] <jnthn> Maybe we need a Seqqy role :P

[19:39] <lizmat> ok, will HLLizing my prototype, I found some issues with for, which I've now fixed in the nqp version

[19:39] <lizmat> migrating to HLL now and then gisting again

[19:40] <jnthn> OK

[19:41] * jnthn ended up sleeping badly then waking up to a minor bombshell in $other-project, and realized that this just wouldn't be a productive day to try and work on Perl 6 stuffs...

[19:41] <jnthn> So shuffled my Perl 6 time tomorrow :)

[19:42] <jnthn> *to tomorrow

[19:43] <lizmat> oki

[19:57] <dogbert17> .seen broken-robot

[19:57] <yoleaux2> I haven't seen broken-robot around.

[19:57] <dogbert17> .seen brokenrobot

[19:57] <yoleaux2> I saw BrokenRobot 13 Jul 2016 15:41Z in #perl6-dev: <BrokenRobot> Challenge accepted! :)

[19:57] <dogbert17> m: say S:g:ii:nth(2) /m/g/ given "Lörem Ipsum Dolor Sit Amet"

[19:57] <camelia> rakudo-moar 8d06b8: OUTPUT: «P6opaque: no such attribute '$!reified' in type List when trying to get a value␤  in block <unit> at <tmp> line 1␤␤»

[19:58] <Geth> ¦ rakudo/nom: 6a77cda335 | (Stefan Seifert)++ | src/core/CompUnit/Repository/Installation.pm

[19:58] <Geth> ¦ rakudo/nom: Give a somewhat more helpful message

[19:58] <Geth> ¦ rakudo/nom:

[19:58] <Geth> ¦ rakudo/nom: When loading a non-existing module that matches a distribution name, we found

[19:58] <Geth> ¦ rakudo/nom: the distribution but failed to recognize that it doesn't contain a module of

[19:58] <Geth> ¦ rakudo/nom: that name. We now throw a proper exception in that case.

[19:58] <Geth> ¦ rakudo/nom: The code is not pretty and could use some re-structuring, but at least works...

[19:58] <Geth> ¦ rakudo/nom: review: https://github.com/rakudo/rakudo/commit/6a77cda335

[19:59] <nine> [Coke]: ^^^

[20:02] <dogbert17> is the syntax used above invalid or is this a regression?

[20:03] <timotimo> i didn't know you can put a space between S and the regexen

[20:03] <timotimo> also, how do :g and :nth interact?

[20:03] <timotimo> m: say S:g:ii:nth(2)/m/g/ given "Lörem Ipsum Dolor Sit Amet"

[20:03] <camelia> rakudo-moar 8d06b8: OUTPUT: «P6opaque: no such attribute '$!reified' in type List when trying to get a value␤  in block <unit> at <tmp> line 1␤␤»

[20:03] <timotimo> m: say S:ii:nth(2)/m/g/ given "Lörem Ipsum Dolor Sit Amet"

[20:03] <camelia> rakudo-moar 8d06b8: OUTPUT: «Lörem Ipsug Dolor Sit Amet␤»

[20:03] <timotimo> m: say S:ii:g/m/g/ given "Lörem Ipsum Dolor Sit Amet"

[20:03] <camelia> rakudo-moar 8d06b8: OUTPUT: «Löreg Ipsug Dolor Sit Aget␤»

[20:04] <timotimo> either works, but not both

[20:04] <dogbert17> timotimo: stole the example from here: https://perl6.party/post/Perl-6-S---Substitution-Operator

[20:05] <dogbert17> was trying to educate myself a bit

[20:06] <dogbert17> perhaps it's simply a typo

[20:06] <timotimo> bisectable: udo-moar 8d06b8: OUTPUT: «P6opaque: no such attribute '$!

[20:06] <bisectable6> timotimo, On both starting points (old=2015.12 new=6a77cda) the exit code is 1 and the output is identical as well

[20:06] <bisectable6> timotimo, Output on both points: «04===SORRY!04=== Error while compiling /tmp/rP_gGBOmip␤Confused␤at /tmp/rP_gGBOmip:1␤------> 03udo-moar 808⏏04d06b8: OUTPUT: «P6opaque: no such attrib»

[20:06] <timotimo> er, where did that come from

[20:06] <dogbert17> :)

[20:07] <dogbert17> bisectable: say S:g:ii:nth(2) /m/g/ given "Lörem Ipsum Dolor Sit Amet"

[20:07] <bisectable6> dogbert17, Bisecting by exit code (old=2015.12 new=6a77cda). Old exit code: 0

[20:07] <timotimo> thanks

[20:07] <bisectable6> dogbert17, bisect log: https://gist.github.com/6c7d160f99cb5e5874e5a2030219c8da

[20:07] <bisectable6> dogbert17, (2017-02-01) https://github.com/rakudo/rakudo/commit/97359ae42e2ae467eb80d3228cb80e5febb6a547

[20:08] <samcv> good * perl6

[20:08] <dogbert17> I believe the commit is by the author of the article I was reading

[20:08] <dogbert17> o/ samcv

[20:10] <dogbert17> perhaps the intrepid IOninja has an idea or two

[20:11] * dogbert17 continues reading

[20:13] <[Coke]> nine++

[20:13] <[Coke]> quick turnaround time, thanks!

[20:15] <samcv> u: { .uniprop('NFG_QC') eq 'M' }

[20:15] <unicodable6> samcv, Found nothing!

[20:20] <samcv> u: { .uniprop('NFG_QC') eq 'N' }

[20:21] <unicodable6> samcv, U+0000 <control-0000> [Cc] (control character)

[20:21] <unicodable6> samcv, U+0001 <control-0001> [Cc] (control character)

[20:32] <Zoffix_> m: say WHAT 'mmmmmmm'.match: :ii, :g,  /m/

[20:32] <camelia> rakudo-moar 6a77cd: OUTPUT: «(List)␤»

[20:32] <Zoffix_> m: say WHAT 'mmmmmmm'.match: :ii, :2nd, :g,  /m/

[20:32] <camelia> rakudo-moar 6a77cd: OUTPUT: «(Match)␤»

[20:33] <timotimo> interesting

[20:33] <timotimo> so one part of the code expects ":g means we get a list"

[20:33] <timotimo> another part of the code says "we have :2nd, so i'll give you just a single match"

[20:33] <timotimo> and the one part just says nqp::getattr($obj, List, '$!reified)

[20:34] <timotimo> and bam, end of the world

[20:34] <Zoffix_> I'd expect the :g with :2nd to continue giving every 2nd match, like CSS's :nth-child

[20:34] <timotimo> interesting. and :nd(1, 2, 3) acts like rotor, then?

[20:34] <timotimo> i mean :nd(1, 2, 3):g

[20:35] <Zoffix_> That just be a regular :g I guess

[20:35] <Zoffix_> Oh wait

[20:35] <Zoffix_> Nevermind

[20:35] <Zoffix_> I got confused

[20:35] <timotimo> oh, right, :nd(1, 2, 3) is a no-op

[20:35] <Zoffix_> Nevermind the "I'd expect" bit

[20:35] <timotimo> so would :nd(2, 3) match triples, then give only the 2nd and 3rd of each triplet?

[20:36] <Zoffix_> Seems overengineered?

[20:36] <Zoffix_> :g + :nth should throw maybr?

[20:37] <timotimo> *shrug*, if you expect :2nd:g to give every 2nd, how would :g + :nth(,,,) behave?

[20:37] <Zoffix_> But I then said nevermind that :)

[20:37] <timotimo> that's fair

[20:39] <Zoffix_> Cause I was first thinkibg of CSS, but now I remember you use literal `n` in the selector to specify the formula

[20:39] <timotimo> literal n in css you mean?

[20:47] <Zoffix_> Yeah, like :nth-child(2*n)

[20:47] <Zoffix_> :nth-child(2*n+10), etc

[20:47] <timotimo> ah, ok

[20:47] <timotimo> :nth-child(n.is-prime) :P

[20:48] <Zoffix_> Actually, no need for throwage in .match. The options don't really conflict, so I'll change the S/// to not choke on this combination

[20:48] <timotimo> cool

[20:50] <Zoffix_> m: say WHAT 'mmmmmmm'.match: :2nd  /m/

[20:50] <camelia> rakudo-moar 6a77cd: OUTPUT: «5===SORRY!5===␤Regex not terminated.␤at <tmp>:1␤------> 3say WHAT 'mmmmmmm'.match: :2nd  /m/7⏏5<EOL>␤Regex not terminated.␤at <tmp>:1␤------> 3say WHAT 'mmmmmmm'.match: :2nd  /m/7⏏5<EOL>␤Couldn't find terminator / (correspon…»

[20:50] <Zoffix_> oops

[20:50] <Zoffix_> wc

[20:51] <Zoffix_> Side effect of me learning that: if you can't copy-paste a code you tried in #zofbot, prefix the line with /msg #perl6-dev instead :)

[20:51] <Zoffix_> (copy-paste on the phone)

[20:54] <Zoffix_> m: S:nth(1, 2)/m/g/ with 'mmmm'; dd WHAT $/

[20:54] <camelia> rakudo-moar 6a77cd: OUTPUT: «Match␤»

[20:54] <Zoffix_> Also wrong, needs to be List

[20:56] <Zoffix_> m: 'mmmmmmm'.subst: :nth(1, 2, 3), /m/, 'g'; say WHAT $/

[20:56] <camelia> rakudo-moar 6a77cd: OUTPUT: «(Match)␤»

[20:56] <Zoffix_> hm that too

[20:56] <Zoffix_> Ah, that's part of m: 'mmmmmmm'.subst: :nth(1, 2, 3), /m/, 'g'; say WHAT $/

[20:56] <Zoffix_> I mean part of https://rt.perl.org/Ticket/Display.html?id=130688#ticket-history

[20:58] <timotimo> by being crappy to work with, smartphones destroy billions of dollars every year

[21:12] <dogbert17> Zoffix_: are you hacking Rakudo on your phone :)

[21:14] <Zoffix_> I could if I had to, as I have an ssh client on my phone. But... now I'm home, so no need to.

[21:14] <Zoffix_> Will fix the S/// bug after dinner.

[21:15] <Zoffix_> That's how I talk on IRC from the phone: ssh to server pop open the screen with weechat

[21:15] <dogbert17> Zoffix_++ cool, I stumbled upon it when reading your article about S///

[21:16] <timotimo> Zoffix_: Glowing Bear is a pretty nice weechat frontend, maybe it'll suit your needs at least a little bit

[21:24] * Zoffix_ bans Penetrate Offensive on Facebook

[21:24] <Zoffix_> Those two posts look really fishy. Like a bot scrapped them, one of them is about Perl 5 not perl6, and all have tracker URLs in videos :/

[21:25] <Zoffix_> samcv: do you have a racing car as the home pic on Facebook? There's a Samantha McVey in the banlist....

[21:25] <samcv> banlist?

[21:26] <samcv> yeah that's me. why am i banned

[21:26] <Zoffix_> dunno, gonna unban you

[21:26] <samcv> basically never go on fb

[21:26] <samcv> kk

[21:26] <Zoffix_> done

[21:26] <Zoffix_> This is the Perl6 FB group fwiw: https://www.facebook.com/groups/1595443877388632/

[21:26] <samcv> yeah i remember going there one day and not being able to get in

[21:26] <samcv> without even interacting at all with it

[21:27] <samcv> many months ago like a few days after i joined it

[21:27] <Zoffix_> maybe someone clicked a wrong button...

[21:27] <samcv> so somebody banned me >:o

[21:30] <timotimo> no paper trail available on facebook?

[21:32] * Zoffix_ looks

[21:33] <Zoffix_> Nadim Khemir declined Samantha McVey's request to join the group.

[21:33] <Zoffix_> Nov 17, 2016 3:37am

[21:33] <Zoffix_> Nadim Khemir blocked Samantha McVey from the group.

[21:33] <Zoffix_> Nov 17, 2016 3:37am

[21:36] <Geth> ¦ roast: 142d6d1946 | (Samantha McVey)++ | S05-modifier/ignorecase.t

[21:36] <Geth> ¦ roast: Correct typo in todo description for S05-modifier/ignorecase.t

[21:36] <Geth> ¦ roast: review: https://github.com/perl6/roast/commit/142d6d1946

[21:36] <samcv> rude!

[21:36] <Zoffix_> :)

[21:37] <lizmat> jnthn et al: updated gist for .race/.hyper prototype: https://gist.github.com/lizmat/4369e28d6c8a23d54e944881c4df07af

[21:38] <lizmat> this time with more comments and documentation  :-)

[21:38] <lizmat> and more HLL code :-)

[21:40] <timotimo> so much code %)

[21:40] <timotimo> did you end up adapting the sponge metaphor?

[21:41] <timotimo> i see a fallback in there

[21:42] <timotimo> hm. good question: what happens if we deopt globally. do we do that properly in a multithreaded context, too?

[21:43] <lizmat> I have *no* idea, but ^add_method in a class from multiple threads feels like a recipe for disaster

[21:44] <jnthn> The FALLBACK and so on shenanigans are fine for prototyping, but shouldn't make it into the real thing :)

[21:45] <timotimo> and i thought fallback always adds methods by itself

[21:45] <timotimo> just by virtue of you returning a method object

[21:45] <lizmat> jnthn: so you're rather have an ^add_method instead ?

[21:45] <jnthn> I'd rather just write methods :P

[21:46] <lizmat> ok, fair enough

[21:46] <jnthn> Or rather, find a factoring where we don't need this

[21:46] <lizmat> and as it's not needed for prototyping anymore, I'll remove it

[21:46] <timotimo> that worked out quick! :D

[21:47] <jnthn> I think if HyperSeq is not a kind of Seq, then we'll want a place to put the sequential commonalities they share

[21:48] <jnthn> I don't really understand why gist/perl/Str end up in the concurrent chain at all

[21:48] <timotimo> it's very hard to make a .perl that will roundtrip :D

[21:48] <jnthn> Though probably 'cus I didn't read enough of it yet :)

[21:49] <jnthn> I'd really like the serial methods to just work off .iterator though

[21:49] <lizmat> timotimo: if I don't provide a .perl, all I get is ConcurrenChain.new in .perl

[21:49] <lizmat> as it is not a subclass of Seq

[21:49] <jnthn> Oh, wait, it's not putting them into the concurrent chain

[21:50] <jnthn> Yeah, and it is doing self.iterator in there

[21:50] <lizmat> yup

[21:50] <jnthn> So I think it is doing what I expected

[21:50] <jnthn> OK, good

[21:51] <timotimo> ah, right

[21:55] <lizmat> hmmm... should we handle hypering .grep( :kv ) ?

[21:57] <jnthn> Yes, that and a long list of other things become...terribly good fun :P

[21:57] * timotimo doesn't immediately see it

[21:57] <lizmat> the k's from kv would be relative to the chunk

[21:58] <jnthn> lizmat: Does it handle .repeated across buffer boundaries, and .unique across buffers?

[21:58] <jnthn> (If so, I didn't figure out where)

[21:59] <lizmat> jnthn: simplest way would be to serialize those methods for now

[22:01] <lizmat> we would need to special case those

[22:01] <jnthn> I fear in reality we actually ahve to special-case *all* of them

[22:02] <jnthn> Even map and grep (consider the LAST phaser)

[22:02] <jnthn> And use, sequential fallback in order to get correct results is of course an important strategy :)

[22:02] <jnthn> *And yes

[22:02] <lizmat> ok, so if we know that the block doesn't have a LAST phaser  :-)

[22:03] <jnthn> I'll continue looking tomorrow, otherwise I fear I'll lay awake all night thinking about this :-)

[22:04] <lizmat> yeah, know the feeling  :-)

[22:14] <lizmat> for .unique it would be nice if we had a ConcBlockingHash repr, then we'd only need to plug that in

[22:15] <timotimo> it'd be neat if we could pre-size hashes

[22:15] <timotimo> but concurrent additions to a hash aren't safe either way

[22:15] <timotimo> so ... it'd end up actually useless

[22:18] <lizmat> wrt to LAST phaser, I don't really see a solution to that

[22:19] <lizmat> due to the nature of iterators, when we fill a buffer completely, we cannot know whether the last value in the buffer was the last value produced by the iterator or not

[22:19] <timotimo> can the coordinator give that info out to the worker that gets the buffer that was grabbed from the end?

[22:22] <Zoffix> m: dd WHAT 'abcd'.match: /./, :3x; dd WHAT 'abcd'.match: /./, :1x; dd WHAT 'abcd'.match: /./, :th(1,2,3);

[22:22] <camelia> rakudo-moar 6a77cd: OUTPUT: «List␤List␤List␤»

[22:22] <Zoffix> m: dd WHAT 'abcd'.match: /./, :th(1);

[22:22] <camelia> rakudo-moar 6a77cd: OUTPUT: «Match␤»

[22:22] <Zoffix> That's a bit inconsistent :/

[22:23] <Zoffix> The :1x case returning a List, I mean.

[22:24] <Zoffix_> s: 'abcd'.match, \(/./, :1x)

[22:24] <SourceBaby> Zoffix_, Something's wrong: ␤ERR: Cannot resolve caller match(Str: ); none of these signatures match:␤    (Any:U $: | is raw)␤    (Cool:D $: $target, *%adverbs)␤    (Str $: Cool:D $pattern, |c is raw)␤    (Str $: Regex:D $pattern, :continue(:$c)!, *%_)␤    (Str $: Regex:D $pattern, :pos(:$p)!, *%_)␤    (Str $: Regex:D $pattern, :global(:$g)!, *%_)␤    (Str $: Regex:D $pattern, :overlap(:$ov)!, *%_)␤    (Str $: Regex:D $pa

[22:24] <Zoffix_> s: 'abcd', 'match', \(/./, :1x)

[22:24] <SourceBaby> Zoffix_, Sauce is at https://github.com/rakudo/rakudo/blob/6a77cda/src/core/Str.pm#L1027

[22:24] <lizmat> m: my @a = ^10; dd @a[5].WHAT; dd @a[5,].WHAT

[22:25] <camelia> rakudo-moar 6a77cd: OUTPUT: «Int␤List␤»

[22:25] <lizmat> Zoffix_ # ^^ similar situation

[22:25] <lizmat> specification of the :th parameter implies returning a List

[22:27] <Zoffix_> lizmat: you mean :x? Because if :th is an int, it returns 1 Match

[22:28] <lizmat> ah, I was confused

[22:28] <lizmat> that could be a bug  :-)

[22:28] <Zoffix_> Looks like a simple fix though. Just a [0] here? https://github.com/rakudo/rakudo/blob/6a77cda/src/core/Str.pm#L914

[22:28] <Zoffix_> .[0] on the return value

[22:29] <Zoffix_> s: 'abcd', 'match', \(/./, :x(1e200))

[22:29] <SourceBaby> Zoffix_, Sauce is at https://github.com/rakudo/rakudo/blob/6a77cda/src/core/Str.pm#L1027

[22:30] <Zoffix_> m: 'abcd'.match(/./, :x(1e200)

[22:30] <camelia> rakudo-moar 6a77cd: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Unable to parse expression in argument list; couldn't find final ')' ␤at <tmp>:1␤------> 3'abcd'.match(/./, :x(1e200)7⏏5<EOL>␤»

[22:30] <Zoffix_> m: 'abcd'.match(/./, :x(1e200))

[22:30] <camelia> rakudo-moar 6a77cd: OUTPUT: «Cannot unbox 665 bit wide bigint into native integer␤  in block <unit> at <tmp> line 1␤␤»

[22:30] <Zoffix_> hehe

[22:31] <Zoffix_> Oh, no I'm wrong.

[22:31] <Zoffix_> If x == 1 then do it

[22:31] <Zoffix_> Eh, not a priority

[22:31] * Zoffix_ goes back to writing tests for S///

[22:32] <Zoffix_> m: dd 'abcd'.subst: /./, *.uc, :2nd, :3rd;

[22:32] <camelia> rakudo-moar 6a77cd: OUTPUT: «"abCd"␤»

[22:32] * Zoffix_ can totally see someone writing that :(

[22:33] <Zoffix_> lizmat: which did you mean was the bug? That :1x returns a List or that, say, :2nd returns a Match instead of a List?

[22:34] <lizmat> x always implies a List

[22:35] <Zoffix_> OK. Then there's no bug.

[22:35] <lizmat> :th always implies a single element

[22:35] <lizmat> so, indeed, no bug, I don't think

[22:35] <Zoffix_> :th(1, 2, 3) is a List tho

[22:59] <Zoffix_> gah, netsplit...

[22:59] <Geth> rakudo/nom: 43e09022b8 | (Zoffix Znet)++ | src/Perl6/Actions.nqp

[22:59] <Geth> rakudo/nom: Fix List-$/ adverb handling in S/// and s///

[22:59] <Geth> rakudo/nom:

[22:59] <Geth> rakudo/nom: The code makes the assumption that only :g/:global adverbs can cause

[22:59] <Geth> rakudo/nom: a List return value from Str.match. However, :th(1, 2, 3) and :x(5)

[22:59] <Geth> rakudo/nom: adverbs return a list, and :g mixed with :42nd returns just 1 Match.

[22:59] <Geth> rakudo/nom: The first two cause incorrect results in $/. The last one causes

[22:59] <Geth> rakudo/nom: a crash when we try to treat a Match object as a List.

[22:59] <Geth> rakudo/nom: <…commit message has 6 more lines…>

[22:59] <Geth> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/43e09022b8

[23:00] <Geth> ¦ roast: 3846dc460a | (Zoffix Znet)++ | S05-substitution/subst.t

[23:00] <Geth> ¦ roast: Test List/Match-$/ adverbs on S/// and s///

[23:00] <Geth> ¦ roast:

[23:00] <Geth> ¦ roast: Rakudo fix: https://github.com/rakudo/rakudo/commit/43e09022b8

[23:00] <Geth> ¦ roast: Bug find: https://irclog.perlgeek.de/perl6-dev/2017-03-22#i_14308172

[23:00] <Geth> ¦ roast: review: https://github.com/perl6/roast/commit/3846dc460a

[23:01] <Zoffix> dogbert17: ^ that should fix your issue

[23:02] * Zoffix is a bit scared fix compiled and worked right the first time...

[23:04] <dogbert17> Zoffix++, agree that things working first time is a bit scary

[23:12] <lizmat> m: dd ^10 .grep: { LAST say "byebye"; $_ %% 2 }   #  oops, apparently we don't have LAST support in grep ?

[23:12] <camelia> rakudo-moar 43e090: OUTPUT: «(0, 2, 4, 6, 8).Seq␤»

[23:14] * lizmat updated https://gist.github.com/lizmat/1c80d2210aeb4239810d7818fca7e575 some more

[23:14] <lizmat> now also handles .map with LAST phasers, and also grep (if that bug would be fixed)

[23:14] <lizmat> good night, #perl6-dev!

[23:16] <Zoffix> night

[23:16] <Zoffix> s: ^10, 'grep', \({ LAST say "byebye"; $_ %% 2 })

[23:16] <SourceBaby> Zoffix, Sauce is at https://github.com/rakudo/rakudo/blob/6a77cda/src/core/Any-iterable-methods.pm#L1018

[23:16] <lizmat> oops I meant https://gist.github.com/lizmat/4369e28d6c8a23d54e944881c4df07af

[23:16] <lizmat> really sleep&

[23:22] <Zoffix> the bug's 'cause .grep calls sequential-map using a made up block without any phasers, so it goes through the no-phasers fast-loop

[23:23] <Zoffix> hehe, we actually already had `redo` broken in grep :) in https://rt.perl.org/Ticket/Display.html?id=130529 and fixed in https://github.com/rakudo/rakudo/commit/362f674

[23:24] <Zoffix> which is where the new bug got introduced

[23:24] * Zoffix tries a fix

[23:26] <Zoffix> hm, broken here too:

[23:26] <Zoffix> m: say ^10 .grep: -> $a, $b { LAST say "byebye"; $a %% 2 }

[23:26] <camelia> rakudo-moar 43e090: OUTPUT: «((0 1) (2 3) (4 5) (6 7) (8 9))␤»

[23:42] <Zoffix> Is there some sort of... &one-block.users-phasers-from(&other-block) sort of thing?

[23:43] <Zoffix> hm, my phaser kung-fu is no good

[23:45] <Zoffix> .tell lizmat here's my naive attempt at fixing the phasers in grep(Callable), but I don't know how phasers are handled and so it didn't work (now that I look at it; I don't know why expected it to work in the first place >_<):  https://gist.github.com/zoffixznet/17b8c6ba35ba145c59ae71a766a3c738

[23:45] <yoleaux2> Zoffix: I'll pass your message to lizmat.
