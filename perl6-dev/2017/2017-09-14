[01:35] <AlexDaniel> .seen azawawi

[01:35] <yoleaux> I saw azawawi 27 May 2017 12:50Z in #perl6: <azawawi> jnthn: in Graphics::PLplot im aiming on providing Raw (native) and cooked with sugar API :)

[01:35] <AlexDaniel> test fails under prove but not when you run the file by itself

[01:36] <AlexDaniel> my best guess is that it is a buffering issue also, but I have troubles making sense out of it

[01:40] <Geth> ¦ roast: skids++ created pull request #314: adjust tests for closure of RT#131187

[01:40] <Geth> ¦ roast: review: https://github.com/perl6/roast/pull/314

[01:40] <synopsebot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=131187

[01:41] <Geth> ¦ roast: 563f957d06 | skids++ | S02-names/is_default.t

[01:41] <Geth> ¦ roast: unskip prexisting test that covers RT#131387

[01:41] <Geth> ¦ roast:

[01:41] <Geth> ¦ roast: Fix the obvious error in the test, so maybe do 6.c.errata, too

[01:41] <Geth> ¦ roast: review: https://github.com/perl6/roast/commit/563f957d06

[01:41] <synopsebot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=131387

[01:41] <Geth> ¦ roast: ce1a5a2e6b | skids++ | S02-names/is_default.t

[01:41] <Geth> ¦ roast: Thoroughly test attributes now that they work

[01:41] <Geth> ¦ roast: review: https://github.com/perl6/roast/commit/ce1a5a2e6b

[01:41] <Geth> ¦ roast: 6271d239cd | skids++ (committed using GitHub Web editor) | S02-names/is_default.t

[01:41] <Geth> ¦ roast: Merge pull request #314 from skids/rt131387

[01:41] <Geth> ¦ roast:

[01:41] <Geth> ¦ roast: Sorry, that's RT#131387

[01:41] <synopsebot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=131387

[01:41] <Geth> ¦ roast: review: https://github.com/perl6/roast/commit/6271d239cd

[02:40] <AlexDaniel> .seen pierre_

[02:40] <yoleaux> I saw pierre_ 7 Jul 2017 14:38Z in #perl6: <pierre_> which one should i use? (knowing that i can't install HTTP::UserAgent with zef, some tests are failing

[02:40] <AlexDaniel> .seen pierre

[02:40] <yoleaux> I haven't seen pierre around.

[02:49] <AlexDaniel> three modules to go

[03:12] <Geth> ¦ roast: skids++ created pull request #315: Add tests for RT#131962

[03:12] <Geth> ¦ roast: review: https://github.com/perl6/roast/pull/315

[03:12] <synopsebot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=131962

[03:12] <Geth> ¦ roast: 38faa6da57 | skids++ | S32-hash/keys_values.t

[03:12] <Geth> ¦ roast: Add tests for RT#131962

[03:12] <Geth> ¦ roast: review: https://github.com/perl6/roast/commit/38faa6da57

[03:12] <Geth> ¦ roast: 8fdce37baa | skids++ (committed using GitHub Web editor) | S32-hash/keys_values.t

[03:12] <Geth> ¦ roast: Merge pull request #315 from skids/rt131962

[03:12] <synopsebot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=131962

[03:12] <Geth> ¦ roast:

[03:12] <Geth> ¦ roast: Add tests for RT#131962

[03:12] <synopsebot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=131962

[03:12] <Geth> ¦ roast: review: https://github.com/perl6/roast/commit/8fdce37baa

[04:34] <travis-ci> Rakudo build passed. Elizabeth Mattijsen 'Make BUILDALLPLAN and BUILD_LEAST_DERIVED use same internal logic

[04:34] <travis-ci> https://travis-ci.org/rakudo/rakudo/builds/275184428 https://github.com/rakudo/rakudo/compare/532f70927800...b706b843121b

[05:28] <samcv> good *

[05:41] <AlexDaniel> o/

[05:51] <Skarsnik> Hello

[06:03] <AlexDaniel> \o

[06:04] <Skarsnik_> AlexDaniel, did you manage to read the toast data? ^^

[06:07] <AlexDaniel> Skarsnik_: sure. There are now three tickets like this: https://github.com/azawawi/perl6-ncurses/issues/16

[06:07] <AlexDaniel> Skarsnik_: and RT #132085 which is now closed and RT #132083

[06:07] <synopsebot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=132085

[06:07] <synopsebot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=132083

[06:08] <AlexDaniel> and that's it.

[06:08] <Skarsnik_> good ^^

[06:09] <AlexDaniel> Skarsnik: thanks :)

[06:10] <Skarsnik> 3 modules is not that much in the end ^^

[06:12] <AlexDaniel> the picture is much better than it was last month :)

[06:13] <AlexDaniel> but we had less changes this time also

[06:13] <AlexDaniel> Skarsnik: RT #132083 is quite interesting actually

[06:13] <synopsebot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=132083

[06:14] <AlexDaniel> but I have to get some sleep :)

[06:14] <Skarsnik> I have to go x)

[06:14] <Skarsnik> good nigh then x)

[06:22] <[Tux]> This is Rakudo version 2017.08-123-gc4043b068 built on MoarVM version 2017.08.1-156-g49b90b99

[06:22] <[Tux]> csv-ip5xs        1.348 -  1.391

[06:22] <[Tux]> test             9.915 - 10.123

[06:22] <[Tux]> test-t           3.542 -  3.669

[06:22] <[Tux]> csv-parser      11.447 - 11.494

[07:45] <lizmat> Files=1223, Tests=67782, 289 wallclock secs (11.02 usr  4.75 sys + 1950.09 cusr 205.81 csys = 2171.67 CPU)

[08:11] <lizmat> m: dd (1,2,3).Set.any  # one could argue that should be (1,2,3).any

[08:11] <camelia> rakudo-moar c4043b: OUTPUT: «any(1 => Bool::True, 3 => Bool::True, 2 => Bool::True)␤»

[08:11] <lizmat> opinions?  if so, what about Bag.any and Mix.any ?

[08:28] <nine> I've never really liked that our sets are really just hashes and that we make that so obvious.

[09:08] <jnthn> I think .any working by consistently .list-ifying the thing is probably right

[09:52] <Geth> ¦ rakudo/better-sched: 340d8ed3bb | (Jonathan Worthington)++ | src/core/ThreadPoolScheduler.pm

[09:52] <Geth> ¦ rakudo/better-sched: Respect max_threads

[09:52] <Geth> ¦ rakudo/better-sched:

[09:52] <Geth> ¦ rakudo/better-sched: To a degree, anyway. We will always start one timer, general, and

[09:52] <Geth> ¦ rakudo/better-sched: affinity thread if they're needed even if it takes us over the

[09:52] <Geth> ¦ rakudo/better-sched: maximum number of threads.

[09:52] <Geth> ¦ rakudo/better-sched: review: https://github.com/rakudo/rakudo/commit/340d8ed3bb

[09:52] <Geth> ¦ rakudo/better-sched: c50d35a90e | (Jonathan Worthington)++ | src/core/ThreadPoolScheduler.pm

[09:52] <Geth> ¦ rakudo/better-sched: Add extra timer workers as needed

[09:52] <Geth> ¦ rakudo/better-sched: review: https://github.com/rakudo/rakudo/commit/c50d35a90e

[09:58] <jnthn> Now my benchmark doesn't start 250 threads and uses 2.3 GB of RAM :P

[09:58] <jnthn> *and use

[09:58] <jnthn> Now it hits the default limit of 64

[09:59] <jnthn> Benchmark is await start { (eager (^10000).grep(*.is-prime)).elems } xx 500;

[09:59] <jnthn> Essentially, CPU-bound work

[09:59] <jnthn> Where we don't really benefit from more threads than CPU cores

[09:59] <jnthn> So next is to try and look at rusage and be smarter on that

[10:00] <jnthn> What's interesting, though, is that the time difference between the two is only 2s (2:17 vs 2:19)

[10:01] <jnthn> That is, these days it seems MoarVM copes pretty well with juggling a lot more threads than should sensibly be started, if it's gotta

[10:01] <jnthn> Probably thanks for my re-write of GC orchestration over the summer

[10:01] <jnthn> *thanks to

[10:48] <Geth> ¦ nqp: a3b1e9cfb9 | (Jonathan Worthington)++ | tools/build/MOAR_REVISION

[10:48] <Geth> ¦ nqp: Bump for new MoarVM getrusage op

[10:48] <Geth> ¦ nqp: review: https://github.com/perl6/nqp/commit/a3b1e9cfb9

[10:48] <Geth> ¦ nqp: version bump brought these changes: https://github.com/MoarVM/MoarVM/compare/2017.08.1-156-g49b90b99... No newline at end of file

[10:48] <Geth> ¦ nqp: 2d9ec57ab7 | (Jonathan Worthington)++ | src/vm/moar/QAST/QASTOperationsMAST.nqp

[10:48] <Geth> ¦ nqp: Add nqp::getrusage and constants on MoarVM backend

[10:48] <Geth> ¦ nqp: review: https://github.com/perl6/nqp/commit/2d9ec57ab7

[10:48] <Geth> ¦ nqp: version bump brought these changes: https://github.com/MoarVM/MoarVM/compare/2017.08.1-156-g49b90b99... No newline at end of file

[10:49] <jnthn> Well, there's getrusage, for whatever purposes people wish to put it to :)

[11:17] <jnthn> lunch &

[12:04] <stmuk> I'm seeing t/spec/S03-operators/buf.t fail on Rakudo version 2017.08-123-gc4043b0 built on MoarVM version 2017.08.1-158-g3c3a52f on linux

[12:09] <MasterDuke> consistently? even when run by itself? it's fine for me at same rakudo and nearly the same moar

[12:13] <stmuk> no and I'm running on its own in a loop and it seems ok :/

[12:14] * jnthn back

[12:17] <MasterDuke> jnthn: did you happen to see https://gist.github.com/MasterDuke17/7926d8fc9d377a865540730621e59b03 ? top 30 by exclusive_time for a profile-compile of --target=parse at 2017-2-3 and 2017-9-10

[12:17] <MasterDuke> very different results, but roughly the same total time to compile

[12:21] <MasterDuke> all the profiles i did up to and including 2017-2-3 had pretty similar results, then i didn't do any for a while, and now it's quite different

[12:21] <MasterDuke> maybe i should go back and do one at each release inbetween

[12:23] <stmuk> hmm I only saw the buf.t failure once

[12:23] <stmuk> with TEST_JOBS=6

[12:25] <MasterDuke> there are a couple that flop during a full spectest, but never fail when run by themselves

[12:34] <lizmat> m: class A { has $.a is required = 42 }; dd A.new  # wonder this should be a compile-time error

[12:34] <camelia> rakudo-moar c4043b: OUTPUT: «The attribute '$!a' is required, but you did not provide a value for it.␤  in block <unit> at <tmp> line 1␤␤»

[12:35] <lizmat> m: class A { has $!a is required }; dd A.new  # how can we ever set the private attribute during object creation?

[12:35] <camelia> rakudo-moar c4043b: OUTPUT: «The attribute '$!a' is required, but you did not provide a value for it.␤  in block <unit> at <tmp> line 1␤␤»

[12:37] <jnthn> m: class A { has $!a is required; submethod BUILD() { $!a = 42 } }; dd A.new

[12:37] <camelia> rakudo-moar c4043b: OUTPUT: «A.new␤»

[12:37] <lizmat> aaahhh  :-)

[12:37] <jnthn> I can imagine having some less trivial BUILD logic that conditionally sets stuff and finding `is required` a useful sanity check

[12:38] <jnthn> (Like, something should be set on all paths, then we make a thinko)

[12:38] <lizmat> and the "class A { has $.a is required = 42 }" case ?

[12:39] <jnthn> That's a useless use of is required, I think :)

[12:39] <lizmat> should it be a compile time error ?

[12:39] <lizmat> at BUILDPLAN creation time ?

[12:40] <lizmat> or a warning: "useless use of "is required" when a default is provided" ?

[12:40] <jnthn> More like at attribute composition time.

[12:40] <jnthn> It could feasibly be

[12:40] <jnthn> Error feels a tad harsh

[12:40] <lizmat> ah, yes, add a worry at that time?

[12:40] <jnthn> Not worth breaking existing code that does this over

[12:40] <jnthn> Yeah, something like that

[12:41] <jnthn> [SCHEDULER] Per-core utilization: 148.333333

[12:41] <jnthn> wat :)

[12:44] <stmuk> hmm the sha1 hashes in the perl6 -v are longer in newer versions of git

[12:46] <perlpilot> stmuk: maybe they adopted a different algorithm by default than SHA1

[12:48] <samcv> stmuk, does `git describe` work? in nqp or rakudo repo

[12:49] <samcv> what about `git describe --tags` though they probably give the same

[12:50] <samcv> i have 2.14.1 what version do you have stmuk

[12:50] <samcv> also i'm going to bed, will read backlog in the morning

[12:52] <stmuk> I'm using git version 2.7.4 which reports 2017.08-123-gc4043b0 and git version 2.13.2 which reports 2017.08-123-gc4043b068

[12:56] <perlpilot> According to the docs, "core.abbrev - Set the length object names are abbreviated to. If unspecified or set to "auto", an appropriate value is computed based on the approximate number of packed objects in your repository"  So, perhaps they changed the algorithm to figure out the minimum number of characters

[12:57] <perlpilot> (assuming you haven't actually set core.abbrev anywhere or didn't specify ala `git rev-parse --short=9 ...`

[12:57] <perlpilot> )

[13:04] <stmuk> https://github.com/git/git/commit/e6c587c733b4634030b353f4024794b08bc86892

[13:24] <jnthn> Cool, got it starting up to the number of CPU cores we have threads for that benchmark I posted earlier

[13:24] <jnthn> Which again greatly reduces memory use

[13:24] <jnthn> Results in a time reduction too thanks to not over-subscribing the CPU.

[13:25] <jnthn> Drops from 3.28 system to 0.36 system

[13:25] <jnthn> Probably from not having the overheads of dealing with too many threads

[13:29] <Geth> ¦ rakudo/better-sched: 683037be69 | (Jonathan Worthington)++ | src/core/ThreadPoolScheduler.pm

[13:29] <Geth> ¦ rakudo/better-sched: Start factoring CPU cores and usage into scheduler

[13:29] <Geth> ¦ rakudo/better-sched:

[13:29] <Geth> ¦ rakudo/better-sched: So that it can pick a better number of threads for the workoad. Now it

[13:29] <Geth> ¦ rakudo/better-sched: only boosts threads beyond the number of CPU cores if detects very low

[13:29] <Geth> ¦ rakudo/better-sched: resource usage in combination with a queue of work, which is suggestive

[13:29] <Geth> ¦ rakudo/better-sched: of a deadlock that may be resolved by an extra thread.

[13:29] <Geth> ¦ rakudo/better-sched: review: https://github.com/rakudo/rakudo/commit/683037be69

[13:31] <Geth> ¦ rakudo/better-sched: 89b9ac7830 | (Jonathan Worthington)++ | src/core/ThreadPoolScheduler.pm

[13:31] <Geth> ¦ rakudo/better-sched: Correct typos; MasterDuke17++

[13:31] <Geth> ¦ rakudo/better-sched: review: https://github.com/rakudo/rakudo/commit/89b9ac7830

[13:50] <lizmat> jnthn: with my BUILDPLAN work I'm now getting: Serialization Error: missing static code ref for closure '' (gen/moar/Metamodel.nqp:1455)

[13:51] <lizmat> this seems to be related to me just wanting to put a block into the buildplan

[13:51] <lizmat> @plan[@plan - 1][4] := -> $obj, $attr { ... }

[13:51] <jnthn> Yeah, you can't do that

[13:51] <lizmat> that's a "can't",. period ?  :-(

[13:51] <lizmat> or is there a way around that ?

[13:52] <jnthn> I think that sub ($obj, $attr) { ... } may work out

[13:52] * lizmat tries

[13:52] <jnthn> point blocks in NQP aren't really code objects

[13:52] <jnthn> One of the many places it cheats :)

[13:53] <lizmat> hehe... ok

[13:53] <jnthn> Hurrah for trying real-world things against the scheduler

[13:57] <jnthn> (found 2 bugs so far that stresstest didn't tickle)

[13:59] <lizmat> that also happened with the old scheduler?  or brand new bugs ?

[13:59] <jnthn> New bugs in the new scheduler

[13:59] <lizmat> squash them hard!  :-)

[14:00] <jnthn> Yeah, that's the aim :)

[14:13] <lizmat> Cannot find method 'throw' on object of type NQPMu

[14:13] <lizmat> sigh  :-(

[14:16] <Geth> ¦ rakudo/better-sched: 7c18112c59 | (Jonathan Worthington)++ | src/core/ThreadPoolScheduler.pm

[14:16] <Geth> ¦ rakudo/better-sched: Never hand back queue in Scalar

[14:16] <Geth> ¦ rakudo/better-sched: review: https://github.com/rakudo/rakudo/commit/7c18112c59

[14:16] <Geth> ¦ rakudo/better-sched: c285b489c6 | (Jonathan Worthington)++ | src/core/ThreadPoolScheduler.pm

[14:16] <Geth> ¦ rakudo/better-sched: Consistently use binding on $!affinity-workers

[14:16] <Geth> ¦ rakudo/better-sched: review: https://github.com/rakudo/rakudo/commit/c285b489c6

[14:16] <Geth> ¦ rakudo/better-sched: 7fcab1067d | (Jonathan Worthington)++ | src/core/ThreadPoolScheduler.pm

[14:16] <Geth> ¦ rakudo/better-sched: More typo fixes; MasterDuke17++

[14:16] <Geth> ¦ rakudo/better-sched: review: https://github.com/rakudo/rakudo/commit/7fcab1067d

[14:17] <jnthn> Hm, getting a few uninit warnings now when I stress Cro (which is how I found the above issues)

[14:18] <jnthn> Wonder if they're from the new scheduler too

[14:22] <jnthn> Yes.

[14:23] <lizmat> jnthn: my idea is to replace the "is required" handling by making it a default value that throws

[14:23] <jnthn> hm, interesting :)

[14:23] <lizmat> basically: has $.a = X::Attribute::Required.new(...).throw

[14:23] <jnthn> Can't think of an obvious downside ot that

[14:24] <lizmat> well, the downside is that I can't get it to work

[14:24] <lizmat> :-(

[14:24] <jnthn> ;)

[14:24] <jnthn> diff?

[14:25] <lizmat> well, the complete diff is rather large

[14:25] <lizmat> this is the bit where I try to set the block:

[14:25] <lizmat> @plan[@plan - 1][4] := sub ($obj, $attr) {

[14:25] <lizmat> X::Attribute::Required.new(

[14:25] <lizmat> name => $attr.name,

[14:25] <lizmat> why  => $attr.required

[14:25] <lizmat> ).throw

[14:25] <lizmat> };

[14:26] <lizmat> as the default value block is called as a method on the object, with the Attribute object as the parameter

[14:27] <Geth> ¦ rakudo/better-sched: b5605c2dd6 | (Jonathan Worthington)++ | src/core/ThreadPoolScheduler.pm

[14:27] <Geth> ¦ rakudo/better-sched: Fix affinity worker threshold logic

[14:27] <Geth> ¦ rakudo/better-sched:

[14:27] <Geth> ¦ rakudo/better-sched: Gets rid of a warning it very rightly produced, which showed up the

[14:27] <Geth> ¦ rakudo/better-sched: problem

[14:27] <Geth> ¦ rakudo/better-sched: review: https://github.com/rakudo/rakudo/commit/b5605c2dd6

[14:27] <jnthn> Isn't that NQP code?

[14:27] <lizmat> yes

[14:27] <jnthn> X::Attribute::Required doesn't exist yet

[14:28] <jnthn> The build plan is put together in the MOP

[14:28] <jnthn> The MOP is built before CORE.setting

[14:28] <jnthn> That and the namespces of the two langs don't overlap, doubly so given Perl 6 resolves things lexically too

[14:28] <lizmat> ok, I just had a bit of a epiphany

[14:28] <jnthn> Did you take a look at whether you can do it in Attribute.compose?

[14:29] <lizmat> you mean, the warning for has $.a is required = 42?

[14:29] <jnthn> No, adding the default that throws

[14:29] <jnthn> Though I guess that makes introspection of defaults show it up, which is arguably naughty

[14:29] <lizmat> yeah...  :-(

[14:30] <lizmat> but, i could call it something else  :-)

[14:30] <lizmat> ok, that's a thought  :)

[14:30] <jnthn> m: class A { has $.x is required; has $.y = 42; submethod TWEAK() { say $!y } }

[14:30] <camelia> rakudo-moar c4043b: ( no output )

[14:30] <jnthn> m: class A { has $.x is required; has $.y = 42; submethod TWEAK() { say $!y } }; A.new

[14:30] <camelia> rakudo-moar c4043b: OUTPUT: «The attribute '$!x' is required, but you did not provide a value for it.␤  in block <unit> at <tmp> line 1␤␤»

[14:30] <jnthn> m: class A { has $.x is required; has $.y = 42; submethod TWEAK() { $!x = 100; say $!y } }; A.new

[14:30] <camelia> rakudo-moar c4043b: OUTPUT: «The attribute '$!x' is required, but you did not provide a value for it.␤  in block <unit> at <tmp> line 1␤␤»

[14:30] <lizmat> would you consider that a bug?

[14:30] <jnthn> (Just checking TWEAK is too late)

[14:30] <lizmat> that last one ?

[14:31] <jnthn> Well, your optimization idea is predicated on it not being :-)

[14:31] <jnthn> I'd never really considered it, tbh

[14:42] <jnthn> Cool, now a Cro service that gets just one request at a time starts just a couple of pool threads, and one hammered with 100 concurrent requests maxes out at 7 threads on my 12-core box, presumably 'cus it feels adding more won't help much (will do some tuning though to see if it's really chosing well)

[14:42] <jnthn> *choosing

[14:43] <jnthn> Bad news is I seem to have got a new SEGV

[14:45] <jnthn> Hm, which seems to be nothing to do with my changes, looking at the stack trace

[14:45] <jnthn> And may also be the async socket server crash that gfldex reported

[14:47] <jnthn> d'oh

[14:51] <jnthn> MoarVM HEAD sorts it out

[14:51] <jnthn> gfldex: ^^

[14:57] <Geth> ¦ rakudo/better-sched: de311f46a9 | (Jonathan Worthington)++ | src/core/ThreadPoolScheduler.pm

[14:57] <Geth> ¦ rakudo/better-sched: Add RAKUDO_SCHEDULER_DEBUG_STATUS env var

[14:57] <Geth> ¦ rakudo/better-sched:

[14:57] <Geth> ¦ rakudo/better-sched: Which turns on output of regular status info, at the moment just the

[14:57] <Geth> ¦ rakudo/better-sched: calculated per-core utilization. This makes RAKUDO_SCHEDULER_DEBUG

[14:57] <Geth> ¦ rakudo/better-sched: just contain information about what kinds of new threads have been

[14:57] <Geth> ¦ rakudo/better-sched: created, which got hard to find among all the regular output made

[14:57] <Geth> ¦ rakudo/better-sched: with each supervision.

[14:57] <Geth> ¦ rakudo/better-sched: review: https://github.com/rakudo/rakudo/commit/de311f46a9

[15:04] <Skarsnik> .

[15:06] <Geth> ¦ rakudo/better-sched: 3b98fb9e39 | (Jonathan Worthington)++ | src/core/ThreadPoolScheduler.pm

[15:06] <Geth> ¦ rakudo/better-sched: Supervising 100 times a second is likely enough

[15:06] <Geth> ¦ rakudo/better-sched: review: https://github.com/rakudo/rakudo/commit/3b98fb9e39

[15:12] <jnthn> Alright, I think that gets the scheduler into better shape :)

[15:12] <jnthn> Of course one can measure and tweak these things almost endlessly

[15:16] <jnthn> But it seems to result in a lot less threads (and thus memory) for things that just do the odd light bit of async (like run does behind the scenes, or a web app barely under load), converges on the number of available cores for CPU bound things, and can add up to 64 threads by default now (though will be reluctant to go far beyond the CPU core count unless it looks like there's a deadlock due to insufficient threads)

[15:17] <nine> Sounds like a huge improvement :)

[15:18] <jnthn> Nicer for those of you with AMD 32-core chips too ;)

[15:18] <Skarsnik> ^^

[15:19] <nine> \o/

[15:19] <Skarsnik> The news Ryzen 7 cpu are tempting x)

[15:19] <Skarsnik> not sure they do 32 cores yet for regular people x)

[15:20] <nine> Well 16 cores and 32 threads: https://www.amd.com/en/products/cpu/amd-ryzen-threadripper-1950x

[15:21] <Skarsnik> Only 1200€

[15:21] <Skarsnik> cheap

[15:22] <jnthn> Yeah, when I said core I meant "virtual cores", or what your OS things it has to scheduler threads on :)

[15:22] <jnthn> *thinks

[15:22] <jnthn> Anyways, will merge this after the weekend release; it's just too close now for such a key component to be replaced

[15:22] <jnthn> Oh, also I need to probably make it work on JVM too :S

[15:23] <jnthn> And knowing JVM, there won't be a getrusage :P

[15:24] <Skarsnik> the jvm has nothing for this kind of work?

[15:24] <jnthn> I'd assume it does

[15:24] <jnthn> Though I don't know what

[15:25] <jnthn> And my initial search for getrusage equivalent in java doesn't show much up

[15:25] <Skarsnik> I mean to schedule thread so you don't have write a thread scheduler for it?

[15:25] <jnthn> Except that somebody called it through nja

[15:25] <jnthn> *jna

[15:25] <jnthn> Yeah, but the scheduler is a Perl 6 level thing

[15:28] <ilmari> https://docs.oracle.com/javase/8/docs/jre/api/management/extension/com/sun/management/OperatingSystemMXBean.html#getProcessCpuTime-- ?

[15:29] <jnthn> Think that's what https://stackoverflow.com/questions/36647405/java-api-to-get-cpu-memory-usage-of-my-java-application is talking about also

[15:29] <jnthn> Yeah, that'd be good enough I think

[15:29] <jnthn> Thanks

[15:51] <[Coke]> jnthn++!

[15:56] <Geth> ¦ nqp: 38aa9ce23f | (Jonathan Worthington)++ | 2 files

[15:56] <Geth> ¦ nqp: A very cheating getrusage for JVM

[15:56] <Geth> ¦ nqp:

[15:56] <Geth> ¦ nqp: In that it only fills out UTIME_SEC and UTIME_MSEC, which mercifully

[15:56] <Geth> ¦ nqp: are both one of the few things that seems easy to emulate on the JVM

[15:56] <Geth> ¦ nqp: and also the only ones we really need for Rakudo.

[15:56] <Geth> ¦ nqp: review: https://github.com/perl6/nqp/commit/38aa9ce23f

[16:05] <ugexe> is there a better way to hide output from a Proc::Async than .stdout.tap: {} ?

[16:06] <jnthn> No

[16:06] <jnthn> Well, actually yes

[16:07] <jnthn> .stdout(:bin).tap: {} will save decoding data only to throw it away

[16:07] <ugexe> ah right

[16:07] <jnthn> But in terms of shorter, no

[16:07] <ugexe> yeah didnt mean shorter... just avoiding overhead

[16:07] <jnthn> Ah, then yeah, that'll save a good amount of it

[16:08] <jnthn> May also be possible, though not so portable, to .bind-stdout(INIT open("/dev/null", :w))

[16:09] <jnthn> Which I suspect would be cheapest

[16:09] <[Coke]> wonder if we'd like a .stdout(:null)

[16:10] <jnthn> An .ignore-stdout would be more consistent with the current API

[16:11] <ugexe> i was ideally trying to open less file handles, since there is still an issue with exhausting file handles with something like `while 1 { with Proc::Async.new(:w, ...) { .tap.stdout: {}; .kill } }`

[16:12] <ilmari> $*SPEC.devnull is the portable spelling of "/dev/null"

[16:14] <Geth> ¦ rakudo/better-sched: 596611c8fd | (Jonathan Worthington)++ | src/core/ThreadPoolScheduler.pm

[16:14] <Geth> ¦ rakudo/better-sched: Fix non-MoarVM build with new scheduler

[16:14] <Geth> ¦ rakudo/better-sched:

[16:14] <Geth> ¦ rakudo/better-sched: Dropping the atomics gives slightly less accurate data, but should not

[16:14] <Geth> ¦ rakudo/better-sched: cause any bad behaviors.

[16:14] <Geth> ¦ rakudo/better-sched: review: https://github.com/rakudo/rakudo/commit/596611c8fd

[16:14] <ugexe> my @procs; my @promises; for ^1000 { .say; if @procs { @procs[*-1].kill; }; my $proc = Proc::Async.new("sleep", "20"); $proc.stdout.tap(-> $ {}); @promises.push: $proc.start; @procs.push: $proc; }; await @promises; # the code example from rt that exhaust descriptors

[16:17] <jnthn> Hm, doesn't @procs keeps all of the procs, so GC can never collect them?

[16:17] <ilmari> .oO( java.util.concurrent.atomic.AtomicInteger? )

[16:17] <jnthn> ilmari: The problem isn't that we can't do them on JVM, just that I don't have time for that yak shave right now :)

[16:18] <ilmari> jnthn: fair enough

[16:21] <Geth> ¦ nqp: 43a18f5aa6 | (Jonathan Worthington)++ | src/vm/jvm/runtime/org/perl6/nqp/sixmodel/reprs/ConcBlockingQueueInstance.java

[16:21] <Geth> ¦ nqp: Support elems on ConcBlockingQueue

[16:21] <Geth> ¦ nqp:

[16:21] <Geth> ¦ nqp: Which is needed by the new Rakudo scheduler

[16:21] <Geth> ¦ nqp: review: https://github.com/perl6/nqp/commit/43a18f5aa6

[16:22] <jnthn> Alright, that gets the JVM happier with my better-sched branch

[16:23] <ugexe> jnthn: a similar issue (also by hoelzro) shows a different example, titled "Garbage collected running Proc::Async objects dont seem to clean up their handles"

[16:23] <ugexe> if @procs.pop -> $p { $p.kill } didn't change anything for me though

[16:24] <jnthn> Hm, then looks like there perhaps is a leak somewher

[16:24] <jnthn> *somewhere

[16:24] <ugexe> i was hunting for it yesterday. no luck yet though

[16:24] * jnthn wonders where

[16:26] <jnthn> The handle is closed here: https://github.com/MoarVM/MoarVM/blob/master/src/io/procops.c#L589

[16:26] <jnthn> I'm curious if the stdout supply gets the done signal

[16:26] <ugexe> i know it get the quit signal

[16:27] <jnthn> Oh, on kill?

[16:27] <jnthn> Or on running out of handles?

[16:27] <jnthn> https://github.com/MoarVM/MoarVM/blob/master/src/io/procops.c#L607 shows a close on the quit path too

[16:28] <jnthn> I'd maybe throw printf or so in around those if you want to debug, to check if either of those closes are reached

[16:28] <ugexe> if i do quit => -> $ { } it will run through all 1000 iterations and then give the message for running out of handles

[16:28] <jnthn> Ah, ok

[16:28] <jnthn> I don't knowt hat'd be on the path we're looking at

[16:28] <jnthn> I'd see if done gets send though

[16:29] <ugexe> it fired ~22 times out of the 130 (where it gives the handle exhaustion error)

[16:29] <ugexe> done fired^

[16:31] <ugexe> this is with a ulimit of 150 as in the RT btw

[16:33] <jnthn> huh, that's stranger still

[16:33] <jnthn> Why would be only sometimes get the EOF...

[16:34] <ugexe> i thought it just started queuing more processes up towards the end before they were getting started

[16:35] <jnthn> Oh

[16:35] <jnthn> That's possible

[16:35] <jnthn> In that case, there's not a lot we can do

[16:35] <jnthn> That'd imply we're not leaking handles, just having enough processes active at once that we really do run out

[16:37] <ugexe> so its a race against nqp::procasynckill (or whatever its called)?

[16:38] <jnthn> I guess it's also possible there's an isuse there

[16:38] <jnthn> Can we ever fail to kill because the process wasn't started yet, etc.

[16:38] <ugexe> i was just wondering how i didn't get an exception for that

[16:39] <jnthn> It happens async and it seems there's no way to block on knowing the signal was sent: https://github.com/MoarVM/MoarVM/blob/master/src/io/procops.c#L882

[16:41] <jnthn> Just checked that there's no way to race between kill and the setting of ->handle on startup

[16:41] <jnthn> (There isn't)

[16:41] <jnthn> So we always have a process handle at that point

[16:42] <jnthn> Time to head home; bbl

[17:50] <Zoffix> m: role Foo { multi method x { "role" } }; class :: does Foo { multi method x { "class" } }.new.x.say

[17:50] <camelia> rakudo-moar c4043b: OUTPUT: «class␤»

[17:50] <Zoffix> m: role Foo { multi method x(:$x) { "role" } }; class :: does Foo { multi method x { "class" } }.new.x.say

[17:50] <camelia> rakudo-moar c4043b: OUTPUT: «role␤»

[17:50] <Zoffix> Kinda thought the result would be the same for both, due to implicit *%_

[17:56] <timo> might be caused by the tighter invocant constraint?

[17:57] <timo> role Foo { multi method x(:$x) { "role" } }; class :: does Foo { multi method x { "class" } }.new.^find_method('x')[0].candidates.perl.say

[17:57] <timo> m: role Foo { multi method x(:$x) { "role" } }; class :: does Foo { multi method x { "class" } }.new.^find_method('x')[0].candidates.perl.say

[17:57] <camelia> rakudo-moar c4043b: OUTPUT: «(method x (<anon|80616960> $: *%_) { #`(Method|81835040) ... }, method x (<anon|80616960> $: :$x, *%_) { #`(Method|81839448) ... })␤»

[17:57] <timo> oh, hm.

[17:57] <timo> sorry, i missed the signature in the role

[17:58] <timo> but named args only contribute to multi candidate finding as last-resolt tiebreakers?

[18:00] <Zoffix> Yeah

[18:00] <Zoffix> Also found this glitch; dunno if it's in any way related

[18:00] <Zoffix> m: role Foo { multi method x(:$x) { "role" } }; class :: does Foo { multi method x(:$) { "class" } }.new.x.say

[18:00] <camelia> rakudo-moar c4043b: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Found named parameter '(unnamed)' twice in signature :(<anon|71941360> $: $, *%_): *%_ vs $␤at <tmp>:1␤»

[18:00] <Zoffix> Pretty much any other combination of args (or not mixing a role) avoids that error

[18:02] <Zoffix> Filed it as https://rt.perl.org/Ticket/Display.html?id=132089

[18:03] <Zoffix> Oh

[18:03] <Zoffix> s/Ok//;

[18:05] <Zoffix> .ask jnthn Is this is a bug? I expected it to say "class" because methods have implicit *%_ and also named args are used only for tie breaking and there's no tie here as far as I undertstand: m: role Foo { multi method x(:$x) { "role" } }; class :: does Foo { multi method x { "class" } }.new.x.say

[18:05] <yoleaux> Zoffix: I'll pass your message to jnthn.

[18:06] <Skarsnik> m: say num.^nativesize

[18:06] <camelia> rakudo-moar c4043b: OUTPUT: «No such method 'gist' for invocant of type 'NQPMu'. Did you mean 'isa'?␤  in block <unit> at <tmp> line 1␤␤»

[18:06] <Skarsnik> Should MQPMu never be returned to the user?

[18:10] <lizmat> Skarsnik: no, that's internals leaking out

[18:13] <Skarsnik> rakudobugable, I am lazy repport this bug xD

[18:13] <Skarsnik> buggable,

[18:14] <Skarsnik> buggable, mail

[18:23] <geekosaur> huggable, rakudobug

[18:23] <huggable> geekosaur, Report bugs by emailing to [email@hidden.address] See also: https://github.com/rakudo/rakudo/wiki/rt-introduction

[18:23] <gfldex> jnthn: did the moar changed hit Rakudo HEAD yet?

[18:25] <Geth> ¦ rakudo/nom: b7ab48ee15 | (Elizabeth Mattijsen)++ | src/core/Attribute.pm

[18:25] <Geth> ¦ rakudo/nom: Attribute.required can be anything, not just int

[18:25] <Geth> ¦ rakudo/nom: review: https://github.com/rakudo/rakudo/commit/b7ab48ee15

[18:39] <Geth> ¦ rakudo/nom: edac1d6870 | (Cuong Manh Le)++ | src/core/Exception.pm

[18:39] <Geth> ¦ rakudo/nom: Supress line number if throw X::Package::Stubbed

[18:39] <Geth> ¦ rakudo/nom: review: https://github.com/rakudo/rakudo/commit/edac1d6870

[18:39] <Geth> ¦ rakudo/nom: 29691b2f83 | (Cuong Manh Le)++ | 2 files

[18:39] <Geth> ¦ rakudo/nom: Merge branch 'nom' of https://github.com/rakudo/rakudo into nom

[18:39] <Geth> ¦ rakudo/nom: review: https://github.com/rakudo/rakudo/commit/29691b2f83

[18:39] <Geth> ¦ rakudo/nom: fe719405b1 | (Zoffix Znet)++ (committed using GitHub Web editor) | src/core/Exception.pm

[18:39] <Geth> ¦ rakudo/nom: Merge pull request #1154 from Gnouc/nom

[18:39] <Geth> ¦ rakudo/nom:

[18:39] <Geth> ¦ rakudo/nom: Supress line number if throw X::Package::Stubbed

[18:39] <Geth> ¦ rakudo/nom: review: https://github.com/rakudo/rakudo/commit/fe719405b1

[18:42] <Geth> ¦ rakudo/nom: dea0a08545 | (Elizabeth Mattijsen)++ | 2 files

[18:42] <Geth> ¦ rakudo/nom: Streamline BUILDPLAN a little more

[18:42] <Geth> ¦ rakudo/nom:

[18:42] <Geth> ¦ rakudo/nom: - settable attributes with default are now handled in a single task

[18:42] <Geth> ¦ rakudo/nom:   - this saves one list with 3 entries per attribute

[18:42] <Geth> ¦ rakudo/nom:   - also has a small runtime benefit (in the order 2%)

[18:42] <Geth> ¦ rakudo/nom:   - also handles the task *without* default

[18:42] <Geth> ¦ rakudo/nom: - is required check task now emitted after each settable task without default

[18:42] <Geth> ¦ rakudo/nom: <…commit message has 6 more lines…>

[18:42] <Geth> ¦ rakudo/nom: review: https://github.com/rakudo/rakudo/commit/dea0a08545

[18:45] <gfldex> jnthn: my stresstest doesnt work at all anymore. Did buffering in Async::Proc change?

[18:46] <ugexe> i think so

[18:47] <ugexe> at least the amount it reads at a time was optimized (in addition to the regular stdout buffering stuff from a week+(?) ago)

[18:47] <Geth> ¦ nqp/profiler_extra_options: c6188dc862 | (Timo Paulssen)++ | src/vm/moar/HLL/Backend.nqp

[18:47] <Geth> ¦ nqp/profiler_extra_options: allow passing options to profiler

[18:47] <Geth> ¦ nqp/profiler_extra_options:

[18:47] <Geth> ¦ nqp/profiler_extra_options: like --profile=heap:filter=majoronly

[18:47] <Geth> ¦ nqp/profiler_extra_options: review: https://github.com/perl6/nqp/commit/c6188dc862

[18:48] <Geth> ¦ nqp/profiler_extra_options: 57516cc76c | (Timo Paulssen)++ | src/vm/moar/HLL/Backend.nqp

[18:48] <Geth> ¦ nqp/profiler_extra_options: allow passing options to profiler

[18:48] <Geth> ¦ nqp/profiler_extra_options:

[18:48] <Geth> ¦ nqp/profiler_extra_options: like --profile=heap:filter=majoronly

[18:48] <Geth> ¦ nqp/profiler_extra_options: review: https://github.com/perl6/nqp/commit/57516cc76c

[18:49] <timo> (rebased it on top of latest master)

[18:52] <gfldex> writing very short string via Async.put seam to block now

[18:52] <lizmat> that feels like a release blocker to me

[18:54] <Geth> ¦ rakudo/nom: 7ba9b7cd6f | (Zoffix Znet)++ | src/core/Exception.pm

[18:54] <Geth> ¦ rakudo/nom: Shorten signature of a method

[18:54] <Geth> ¦ rakudo/nom:

[18:54] <Geth> ¦ rakudo/nom: The actual params aren't used and aren't needed, but we still need

[18:54] <Geth> ¦ rakudo/nom: a bit of params to make the method more specific than the one

[18:54] <Geth> ¦ rakudo/nom: from the role.

[18:54] <Geth> ¦ rakudo/nom:

[18:54] <Geth> ¦ rakudo/nom: See also:

[18:54] <Geth> ¦ rakudo/nom: https://github.com/rakudo/rakudo/pull/1154

[18:54] <Geth> ¦ rakudo/nom: https://irclog.perlgeek.de/perl6-dev/2017-09-14#i_15164490

[18:54] <Geth> ¦ rakudo/nom: review: https://github.com/rakudo/rakudo/commit/7ba9b7cd6f

[18:54] * Zoffix does bumps

[18:55] <gfldex> bidirectional Async::Proc seams to be broken (still golfing)

[18:58] <gfldex> unidirectional is a lot faster now and there seams to be a new memory leak

[19:00] <timo> did you already see how using Proc::Async causes the ThreadPoolScheduler to fill up its maximum threads rather quickly?

[19:01] <timo> i think i was discussing this with Skarsnik but i'm not sure if you saw

[19:02] <Zoffix> hm

[19:02] <Zoffix> lizmat: does this pass for you? t/fudgeandrun t/spec/S02-types/int-uint.t

[19:02] <timo> hmm, stage parse 120s, what did i break to cause this ...

[19:03] <Zoffix> Fails for me and I wonder if it's the nqp/MoarVM bump or the couple of commits I pulled before doing the bumping

[19:03] <lizmat> Zoffix: yes

[19:03] <Zoffix> OK. Tis the bump then

[19:03] <nine> timo: debug build?

[19:03] <Zoffix> ZOFFLOP: t/spec/S11-modules/nested.t

[19:03] <Zoffix> ZOFFLOP: t/spec/S17-supply/interval.t

[19:03] <timo> i do have -O3 in my moarvm

[19:03] <timo> in the makefile

[19:04] <Zoffix> ZOFVM: Files=1273, Tests=144748, 138 wallclock secs (15.55 usr  2.49 sys + 2799.30 cusr 215.27 csys = 3032.61 CPU)

[19:04] <timo> haha

[19:04] <timo> i changed the nursery size to be a lot smaller

[19:04] <Zoffix> Output of failures in t/spec/S02-types/int-uint.t https://gist.github.com/zoffixznet/22f483f53f409506c4325e834772fc0d

[19:05] <Zoffix> That's on master MoarVM and master nqp

[19:05] <Geth> ¦ nqp/profiler_extra_options: 84e2f1caf8 | (Timo Paulssen)++ | src/vm/moar/HLL/Backend.nqp

[19:05] <Geth> ¦ nqp/profiler_extra_options: remove debug output

[19:05] <Geth> ¦ nqp/profiler_extra_options: review: https://github.com/perl6/nqp/commit/84e2f1caf8

[19:05] <Zoffix> And well, the commits from them. 'cause I just ran stresstest before pushing dea0a08545 and it was green

[19:07] <Zoffix> m: use Test; class Overlap is repr("CUnion") { has uint32 $.u32; has uint16 $.u16; has uint8 $.u8; }; my $overlap = Overlap.new(u32 => 1234567); is $overlap.u32, 1234567, "uint32 in union is unsigned";

[19:07] <camelia> rakudo-moar dea0a0: OUTPUT: «not ok 1 - uint32 in union is unsigned␤# Failed test 'uint32 in union is unsigned'␤# at <tmp> line 1␤# expected: '1234567'␤#      got: '1179648'␤»

[19:08] <Zoffix> c: 2017.08 use Test; class Overlap is repr("CUnion") { has uint32 $.u32; has uint16 $.u16; has uint8 $.u8; }; my $overlap = Overlap.new(u32 => 1234567); is $overlap.u32, 1234567, "uint32 in union is unsigned";

[19:08] <committable6> Zoffix, ¦2017.08: «ok 1 - uint32 in union is unsigned»

[19:08] <Zoffix> bisect: use Test; class Overlap is repr("CUnion") { has uint32 $.u32; has uint16 $.u16; has uint8 $.u8; }; my $overlap = Overlap.new(u32 => 1234567); is $overlap.u32, 1234567, "uint32 in union is unsigned";

[19:08] <bisectable6> Zoffix, Bisecting by exit code (old=2015.12 new=7ba9b7c). Old exit code: 0

[19:08] <bisectable6> Zoffix, bisect log: https://gist.github.com/5592b70c7afa73e0f182463f88889139

[19:08] <bisectable6> Zoffix, (2017-09-14) https://github.com/rakudo/rakudo/commit/dea0a08545ab172836f96ba6f5c4129734798a35

[19:08] <Zoffix> complicated stuff :)

[19:09] <Zoffix> Well, I guess it's not from the bump, so I'll push it

[19:09] <Geth> ¦ nqp: 9a2ba37548 | (Zoffix Znet)++ | tools/build/MOAR_REVISION

[19:09] <Geth> ¦ nqp: Bump MoarVM

[19:09] <Geth> ¦ nqp: review: https://github.com/perl6/nqp/commit/9a2ba37548

[19:09] <Geth> ¦ nqp: version bump brought these changes: https://github.com/MoarVM/MoarVM/compare/2017.08.1-158-g3c3a52f...2017.08.1-162-g4a7248e

[19:09] <Geth> ¦ rakudo/nom: 06e20f80c9 | (Zoffix Znet)++ | tools/build/NQP_REVISION

[19:09] <Geth> ¦ rakudo/nom: Bump NQP

[19:09] <Geth> ¦ rakudo/nom: review: https://github.com/rakudo/rakudo/commit/06e20f80c9

[19:09] <Geth> ¦ rakudo/nom: version bump brought these changes: https://github.com/perl6/nqp/compare/2017.08-62-gd35cdbdd3... No newline at end of file

[19:12] <Zoffix> m: use Test; class O is repr("CUnion") { has uint32 $.u32; has uint16 $.u16; }; my $o = O.new: u32 => 1234567; is $o.u32, 1234567;

[19:12] <camelia> rakudo-moar 7ba9b7: OUTPUT: «not ok 1 - ␤# Failed test at <tmp> line 1␤# expected: '1234567'␤#      got: '1179648'␤»

[19:13] <Zoffix> Slightly golfed.

[19:13] <gfldex> jnthn: run-this.sh shows the blocking Proc::Async, run-unidirectional.sh shows the memory leak https://github.com/gfldex/perl6-stress-moar

[19:14] <Zoffix> Oh, lizmat++ already mentioned this failing test in the commit message

[19:14] <Zoffix> lizmat: ^ does my last eval fail for you? Seems to fail on Linux

[19:15] <lizmat> ok 1 -

[19:16] <AlexDaniel> by the way

[19:16] <AlexDaniel> RT #132083 may be related

[19:16] <synopsebot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=132083

[19:17] <lizmat> AlexDaniel: the fails started to appear after *my* last BUILDPLAN related commit

[19:17] <AlexDaniel> ah, right, that's another one I guess

[19:17] <Zoffix> FWIW the other two tests for that test that test $.u16 and $.u8 are fudged. It's possible the passing test was passing by accident

[19:18] * Zoffix &

[19:23] <Geth> ¦ rakudo/nom: a8e0352b03 | (Elizabeth Mattijsen)++ | src/core/Mu.pm

[19:23] <Geth> ¦ rakudo/nom: Reorganize BUILDPLAN handling of native inits

[19:23] <Geth> ¦ rakudo/nom:

[19:23] <Geth> ¦ rakudo/nom: - move the check out of the parameter to bindattr_x

[19:23] <Geth> ¦ rakudo/nom:   - this causes one Scalar allocation less for each initialization

[19:23] <Geth> ¦ rakudo/nom: review: https://github.com/rakudo/rakudo/commit/a8e0352b03

[19:27] <timo> neat.

[20:01] <lizmat> nine: is Inline::Perl5 still using the BUILDALL(@a,%h) interface ?

[20:04] <jnthn> gfldex: Looks like the bump was done since you asked, so yeah, the socket fix should be in

[20:04] <yoleaux> 18:05Z <Zoffix> jnthn: Is this is a bug? I expected it to say "class" because methods have implicit *%_ and also named args are used only for tie breaking and there's no tie here as far as I undertstand: m: role Foo { multi method x(:$x) { "role" } }; class :: does Foo { multi method x { "class" } }.new.x.say

[20:04] <jnthn> Nothing has changed with regard to Proc::Async and buffering

[20:06] <jnthn> What changed is buffering of $*OUT and $*ERR when they're attached to a non-TTY. Proc::Async attaches pipes, and thus the buffering is enabled.

[20:08] <jnthn> This only brings Perl 6 in line with other languages.

[20:09] <jnthn> For example, try perl6 -e 'react { my $p = Proc::Async.new("perl", "-E", q/while (1) { say "x" x 1000; sleep 1; }/); whenever $p.stdout { .perl.say }; $p.start }'

[20:32] <lizmat> m: class A { has $! = 42 }; use nqp; dd nqp::getattr(A.new,A,q/$!/)  # this should probably be a compile time error

[20:32] <camelia> rakudo-moar a8e035: OUTPUT: «P6opaque: no such attribute '$!' in type A when trying to get a value␤  in block <unit> at <tmp> line 1␤␤»

[20:33] <lizmat> m: class A { has $! = 42 }; use nqp; dd nqp::getattr(A.new,A,q/$!!/)

[20:33] <camelia> rakudo-moar a8e035: OUTPUT: «Int $!! = 42␤»

[20:33] <lizmat> whee!

[20:33] <jnthn> lol!

[20:33] <jnthn> That's beautiful

[20:34] <lizmat> well, I think it needs to die  :-)

[20:34] <jnthn> m: class A { has $/ = 42 }; use nqp; dd nqp::getattr(A.new,A,q|$!/|)

[20:34] <camelia> rakudo-moar a8e035: OUTPUT: «Int $!/ = 42␤»

[20:34] <jnthn> hahahaha

[20:34] <lizmat> cause it interferes with some more nefarious opts I'm planning

[20:35] <jnthn> For anyone wondering: $/ and $! are allowed variable names. has $foo is an allowed attribute name, the compiler names the attribute $!foo and installs a lexical alias

[20:35] <lizmat> m: class A { has $. = 42 }  # planning on this type of error

[20:35] <camelia> rakudo-moar a8e035: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Unsupported use of $. variable; in Perl 6 please use the .kv method on e.g. .lines␤at <tmp>:1␤------> 3class A { has $.7⏏5 = 42 }  # planning on this type of erro␤»

[20:36] <jnthn> has $! doesn't parse as a twigil 'cus that has to have a name after it

[20:36] <jnthn> It just parses as $! like in my $!

[20:36] <jnthn> The compiler faithfully installs the attribute as $!! and a lexical alias from $! to it

[20:36] <jnthn> Which of course is shadowed in all the methods by the real $! :)

[20:37] <jnthn> Declared per method

[20:37] * jnthn wrote most of the code that does all of this, and totally didn't see this interaction coming

[20:38] <jnthn> I'm kinda proud it's robust enough that it all just works out, but kinda horrified it is allowed too ;)

[21:08] <lizmat> m: sub a(:$) { dd MY::.keys }; a |("" => 42)   # another weirdo

[21:08] <camelia> rakudo-moar a8e035: OUTPUT: «("\$_", "\$/", "\$*DISPATCHER", "\$!", "\$¢").Seq␤»

[21:11] <jnthn> That one's even covered by tests, I think :P

[21:12] <jnthn> The has $! and has $/ sure ain't though, and those truely do seem about useless

[21:15] <lizmat> but what is the use?  You can pass a values as a non-named parameter, but you can't really do anything with it inside the sub ?

[21:20] <jnthn> True, but if you slurp... :)

[21:26] * jnthn bbl

[21:31] * lizmat is too tired and goes to bed

[21:31] <Zoffix> \o

[21:35] <[Coke]> lizmat: when I wrote is required, it was just a bitflag; what else can it be?

[21:35] <[Coke]> (I think that was me)

[21:38] * [Coke] waves good night.

[22:53] <Geth> ¦ rakudo: book++ created pull request #1156: Implement pred() and succ() for the Enumeration role

[22:53] <Geth> ¦ rakudo: review: https://github.com/rakudo/rakudo/pull/1156

[22:56] <Geth> ¦ roast: skids++ created pull request #316: Add tests for RT#126426 and RT#129856

[22:56] <Geth> ¦ roast: review: https://github.com/perl6/roast/pull/316

[22:56] <synopsebot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=126426

[22:56] <synopsebot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=129856

[22:57] <Geth> ¦ roast: 69a5e0db0f | skids++ | 2 files

[22:57] <Geth> ¦ roast: Add tests for RT#126426 and RT#129856

[22:57] <Geth> ¦ roast: review: https://github.com/perl6/roast/commit/69a5e0db0f

[22:57] <Geth> ¦ roast: 6e5180e96c | skids++ (committed using GitHub Web editor) | 2 files

[22:57] <Geth> ¦ roast: Merge pull request #316 from skids/rt126426

[22:57] <synopsebot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=126426

[22:57] <synopsebot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=129856

[22:57] <Geth> ¦ roast:

[22:57] <Geth> ¦ roast: Add tests for RT#126426 and RT#129856

[22:57] <synopsebot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=126426

[22:57] <synopsebot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=129856

[22:57] <Geth> ¦ roast: review: https://github.com/perl6/roast/commit/6e5180e96c

[23:16] <Zoffix> comment on the earlier uint failure: "That test doesn't make sense to me.  1234567 is much less than 2**31 so how would it be testing for unsigned?  And yet it gets the wrong answer, so what's the real bug?"

[23:16] <Zoffix> So it's more evidence that it was passing accidentally

[23:16] <Zoffix> and should be just fudged

[23:18] <Zoffix> "more" <-- because the other piece of evidence is that u16 and u8 in that test currently don't work and are already fudged

[23:41] <Geth> ¦ rakudo/nom: 2645a1e97c | (Philippe Bruhat (BooK))++ | src/core/Enumeration.pm

[23:41] <Geth> ¦ rakudo/nom: Implement pred() and succ() for the Enumeration role

[23:41] <Geth> ¦ rakudo/nom:

[23:41] <Geth> ¦ rakudo/nom: These method will walk the enumeration in the declaration order.

[23:41] <Geth> ¦ rakudo/nom:

[23:41] <Geth> ¦ rakudo/nom: Using Order as an example:

[23:41] <Geth> ¦ rakudo/nom: - Order::Same.succ is Order::More,

[23:41] <Geth> ¦ rakudo/nom: - Order::Same.pred is Order::Less.

[23:42] <Geth> ¦ rakudo/nom:

[23:42] <Geth> ¦ rakudo/nom: Calling pred or succ on the boundaries will fail with X::OutOfBound.

[23:42] <Geth> ¦ rakudo/nom: Using the same example, Order::Less.pred fails with this X::OutOfRange:

[23:42] <Geth> ¦ rakudo/nom: "Decrement out of range. Is: Less, should be in Order::Less^..Order::More".

[23:42] <Geth> ¦ rakudo/nom: review: https://github.com/rakudo/rakudo/commit/2645a1e97c

[23:42] <Geth> ¦ rakudo/nom: 8df53f34dd | (Philippe Bruhat (BooK))++ | src/core/Enumeration.pm

[23:42] <Geth> ¦ rakudo/nom: Remove Failure from Enumeration's pred and succ

[23:42] <Geth> ¦ rakudo/nom:

[23:42] <Geth> ¦ rakudo/nom: Following this comment from Zoffix on #perl6:

[23:42] <Geth> ¦ rakudo/nom:

[23:42] <Geth> ¦ rakudo/nom:     If we make .pred go to previous element (and just return the first

[23:42] <Geth> ¦ rakudo/nom:     element if it's already at the first element) and .succ go to next

[23:42] <Geth> ¦ rakudo/nom:     element (and just return the first element if it's already at the

[23:42] <Geth> ¦ rakudo/nom: <…commit message has 5 more lines…>

[23:42] <Geth> ¦ rakudo/nom: review: https://github.com/rakudo/rakudo/commit/8df53f34dd

[23:42] <Geth> ¦ rakudo/nom: 627de78337 | (Zoffix Znet)++ (committed using GitHub Web editor) | src/core/Enumeration.pm

[23:42] <Geth> ¦ rakudo/nom: Merge pull request #1156 from book/book/enum-pred-succ

[23:42] <Geth> ¦ rakudo/nom:

[23:42] <Geth> ¦ rakudo/nom: Implement pred() and succ() for the Enumeration role

[23:42] <Geth> ¦ rakudo/nom: review: https://github.com/rakudo/rakudo/commit/627de78337

[23:57] <BenGoldberg> So I've got an idea for how to speed up perl6 startup, but I want to first make certain I fully understand how it works at present...

[23:58] <BenGoldberg> If I understand correctly, during compilation, we generate the setting programmatically, compile the setting, load the compiled setting, and finally serialize the loaded setting.
