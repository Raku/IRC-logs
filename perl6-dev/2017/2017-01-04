[02:03] <samcv> yay. optimizing moar get a 12% speed improvement slurping a 200MB text file

[02:03] <samcv> exciting

[07:53] <[Tux]> This is Rakudo version 2016.12-200-gf9ed7300f built on MoarVM version 2016.12-58-ga4fbf52e

[07:53] <[Tux]> csv-ip5xs        3.178

[07:53] <[Tux]> test            13.159

[07:53] <[Tux]> test-t           5.328

[07:53] <[Tux]> csv-parser      14.749

[08:32] <dalek> nqp: eb5881a | samcv++ | tools/build/MOAR_REVISION:

[08:32] <dalek> nqp: Bump MoarVM for 14% better performance decoding UTF-8 text

[08:32] <dalek> nqp:

[08:32] <dalek> nqp: https://github.com/MoarVM/MoarVM/commit/d0e297fd43def2832edd87a2ac30433457d8ff48

[08:32] <dalek> nqp: review: https://github.com/perl6/nqp/commit/eb5881a9b0

[08:33] <dalek> rakudo/nom: 528ec53 | samcv++ | tools/build/NQP_REVISION:

[08:33] <dalek> rakudo/nom: Bump MoarVM/NQP for 14% better performance decoding UTF-8 text

[08:33] <dalek> rakudo/nom:

[08:33] <dalek> rakudo/nom: https://github.com/MoarVM/MoarVM/commit/d0e297fd43def2832edd87a2ac30433457d8ff48

[08:33] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/528ec538d6

[08:33] <samcv> [Tux], will this help the tests you run every day?

[08:34] <[Tux]> test is already running :)

[08:34] <samcv> nice

[08:38] <brrt> samcv++ nice work

[08:38] <samcv> have more changes i'm working on but they're more about 1% or so each improvement, so thought i'd add this one in now

[08:39] <samcv> cause it goes through that codepath A LOT

[08:39] <brrt> i'm slightly scared that there'd be low-hanging fruit like this still left, but good find

[08:40] <nine> I'm glad that there's still LHF ;)

[08:40] <samcv> LHF?

[08:40] * samcv forgets that one

[08:40] <samcv> low hanging fruit ok

[08:41] <samcv> but yeah we need a faster UTF-8 decoding implementation

[08:41] <brrt> i believe that

[08:41] <brrt> not sure but i'm guessing this ties in with jnthns utf8-c8 branch?

[08:41] <samcv> (this is irrespective of UNicode in general) just the utf-8 decoding bytes into codepoints

[08:41] <samcv> unrelated

[08:42] <samcv> though i mean things still pass through both when decoding as utf8-c8

[08:42] <samcv> we first decode to codepoints from whichever format, then we put them in graphemes and determine how the characters break up and combine

[08:42] <[Tux]> This is Rakudo version 2016.12-200-gf9ed7300f built on MoarVM version 2016.12-58-ga4fbf52e

[08:42] <[Tux]> csv-ip5xs        3.165

[08:42] <[Tux]> test            13.198

[08:42] <[Tux]> test-t           5.281

[08:42] <[Tux]> csv-parser      14.026

[08:42] <[Tux]> second run was 5.367

[08:43] <[Tux]> so withing noise range

[08:43] <samcv> csv-parser looks smaller

[08:43] <samcv> it's only going to be seen if you are taking in UTF-8 data, not manipulating strings (mostly)

[08:43] <[Tux]> that is tony's

[08:43] <samcv> tony's?

[08:44] <[Tux]> https://github.com/tony-o/perl6-csv-parser <=

[08:46] <samcv> so i'm guessing it reads in utf-8 data from a file?

[08:46] <samcv> well idk what your source file is. just curious is it ascii or have mixed things

[08:50] <[Tux]> just (very) plain ASCII

[08:50] <[Tux]> sh$ for i in $(seq 1 1000000); do echo 'hello,","," ",world,"!"'; done > /tmp/hello.csv

[08:50] <[Tux]> sh$ time perl csv.pl < /tmp/hello.csv

[08:51] <[Tux]> although my tests have less records, just 10000

[08:51] * [Tux] => $work

[09:01] <samcv> it's basically this https://github.com/minimaxir/big-list-of-naughty-strings/blob/master/blns.txt but 10,000 times

[09:01] <samcv> most is ascii, but it has some weird sections. there's probably better things to test it with, buti wasn't sure what to do

[09:06] <arnsholt> Big list of naughty strings! =D

[09:18] <samcv> m: EVAL qx{curl https://raw.githubusercontent.com/minimaxir/big-list-of-naughty-strings/master/blns.txt}

[09:18] <camelia> rakudo-moar 528ec5: OUTPUT¬´===SORRY!=== Error while compiling <tmp>‚ê§EVAL is a very dangerous function!!! (use the MONKEY-SEE-NO-EVAL pragma to override this error,‚ê§but only if you're VERY sure your data contains no injection attacks)‚ê§at <tmp>:1‚ê§------> list-of-naught‚Ä¶¬ª

[09:18] <samcv> m: use MONKEY-SEE-NO-EVAL; EVAL qx{curl https://raw.githubusercontent.com/minimaxir/big-list-of-naughty-strings/master/blns.txt}

[09:18] <camelia> rakudo-moar 528ec5: OUTPUT¬´qx, qqx is disallowed in restricted setting‚ê§  in sub restricted at src/RESTRICTED.setting line 1‚ê§  in sub QX at src/RESTRICTED.setting line 11‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[09:18] <samcv> #	Scunthorpe Problem

[09:18] <samcv> #

[09:18] <samcv> #	Innocuous strings which may be blocked by profanity filters (https://en.wikipedia.org/wiki/Scunthorpe_problem)

[09:18] <samcv> hha

[09:18] <samcv> that part is funny

[09:18] <samcv> medieval erection of parapets

[09:19] <samcv> "Craig Cockburn, Software Specialist"

[09:19] <arnsholt> Ah yes, the Scunthorpe problem =D

[09:19] <samcv> "Human injection: #	Strings which may cause human to reinterpret worldview"

[09:19] <samcv> If you're reading this, you've been in a coma for almost 20 years now. We're trying a new technique. We don't know where this message will end up in your dream, but we hope it works. Please wake up, we miss you.

[09:19] <samcv> whew

[09:19] <arnsholt> Alternatively the clbuttic problem =)

[09:32] <mst> a reference so old you might call it medireview

[09:35] <samcv> .tell jnthn I found the code for QT's SIMD optimized UTF-8 decoder https://code.woboq.org/qt5/qtbase/src/corelib/codecs/qutfcodec.cpp.html thought you might like to see

[09:35] <samcv> dammit

[10:38] <samcv> anybody want to fix https://github.com/perl6/roast/blob/master/S15-normalization/test-gen.p6 to work after the GLR?

[10:38] <samcv> i was not around before that time

[10:39] <samcv> needs to be updated for Unicode 9.0

[11:08] <notviki> buggable: speed

[11:08] <buggable> notviki, ‚ñá‚ñá‚ñá‚ñà‚ñá‚ñá‚ñà‚ñá‚ñà‚ñá‚ñà‚ñà‚ñá‚ñá‚ñá‚ñà‚ñÑ‚ñÜ‚ñÖ‚ñÉ‚ñÑ‚ñÑ‚ñÇ‚ñÉ‚ñÉ‚ñÑ‚ñÇ‚ñÅ‚ñÅ‚ñÇ‚ñÉ‚ñÇ‚ñÇ‚ñÖ‚ñÇ‚ñÇ‚ñÑ‚ñÇ‚ñÉ‚ñÇ‚ñÇ‚ñÅ‚ñÜ‚ñÑ‚ñÇ‚ñÇ‚ñÉ‚ñÇ‚ñÇ‚ñÇ data for 2016-12-15‚Äì2017-01-04; range: 5.137s‚Äì6.264s

[11:37] <notviki> oh man, the "replaced content" section of that article is hilarious

[11:38] <notviki> "Several websites running rudimentary obscenity filters have replaced the word "ass" with "butt", resulting in "clbuttic" for "classic" and "buttbuttinate" for "assassinate"."

[11:41] <mst> notviki: yup

[11:42] <mst> I remember when it happened

[11:42] <mst> I mean, the clbuttic yahoo one

[11:42] <geekosaur> also inspiring the cloud-to-butt plugin :p

[12:01] <notviki> samcv: nothing strikes me as pre-glrish in that script

[12:02] <jnthn> https://github.com/perl6/roast/blob/master/S15-normalization/test-gen.p6#L43

[12:02] <jnthn> That line probably needs to be `for flat`

[12:02] <jnthn> And there's a similar one below it

[12:03] <notviki> c: pre-glr my @a = ^5; my @b = <a b c d e>; for @a Z @b -> $s, $e { dd [$s, $e ] }

[12:03] <committable6> notviki, ¬¶¬´pre-glr¬ª: $ = [0, "a"; 1, "b"]‚ê§$ = [2, "c"; 3, "d"]‚ê§Too few positionals passed; expected 2 arguments but got 1‚ê§  in block <unit> at /tmp/E6Nlqdbsdz:1‚ê§ ¬´exit code = 1¬ª

[12:03] <notviki> m: my @a = ^5; my @b = <a b c d e>; for @a Z @b -> $s, $e { dd [$s, $e ] }

[12:03] <camelia> rakudo-moar 528ec5: OUTPUT¬´[(0, "a"), (1, "b")]‚ê§[(2, "c"), (3, "d")]‚ê§Too few positionals passed; expected 2 arguments but got 1‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[12:03] <notviki> ok

[12:04] <samcv> here's the input txt it generates from notviki if you want to fix it ftp://ftp.unicode.org/Public/9.0.0/ucd/NormalizationTest.txt

[12:07] <samcv> night everybody o/

[12:10] <jnthn> 'night, samcv

[12:23] <lizmat> Files=1162, Tests=54568, 197 wallclock secs (11.74 usr  4.88 sys + 1292.46 cusr 134.21 csys = 1443.29 CPU)

[12:26] <masak> notviki: my other favorite is Reuters having some kind of automatic replacement s/the queen/Her Majesty Queen Elizabeth the Second/g -- and then they ran an article about bees: https://badbeekeepingblog.com/2016/04/21/the-queen-or-her-majesty-queen-elizabeth-the-second/

[12:27] <masak> that and "clbuttic", those two are what I usually bring up when explaining the dangers of regex match false positives to people

[12:27] <masak> "clbuttic" is also a good time to talk about \b and word boundaries

[12:28] <masak> "the queen" notably doesn't have that problem -- it's just a case where dumb textual matching does too much

[13:38] <[Coke]> dogbert2: if you want to be a bug admin, I need your RT account/email.

[13:46] <notviki> my nqp-foo isn't strong enough. A bunch of stuff I tried for .clone in Setty/Baggy is 22% faster for 3-item bags, but 26% slower for 1000-item bag when compared against just { self.new-from-pairs: self.pairs; }

[13:52] <lizmat> notviki: what we really need are object hashes at the VM level

[13:52] <lizmat> problem with that is that we would need to implement that on all backends at the same time to prevent mental meltdown

[13:57] <notviki> :(

[13:57] <jnthn> Having object hashes at the VM level is perhaps going to be trouble.

[13:57] <jnthn> REPR operations must never call back into userland code as part of their contract. But if you can't do that, how do you check if the two things are equivalent?

[13:58] <lizmat> ok, well if we can't have them at VM level, perhaps we need to think about how to make equivalence checker more optimal than eq .WHICH

[13:59] <jnthn> Yes, ObjAt needs a re-think

[13:59] <jnthn> But really we should just be dealing in integers

[13:59] <jnthn> e.g. hashing something produces an integer

[14:00] <jnthn> Which we use to look up in the hash table

[14:00] <jnthn> And then eqv to check we hit the right thing

[14:00] <dalek> rakudo/nom: 42a8c58 | lizmat++ | src/core/ (3 files):

[14:00] <dalek> rakudo/nom: Make R:I.WhateverIterator a method

[14:00] <dalek> rakudo/nom:

[14:00] <dalek> rakudo/nom: Brings it more in line with the other R:I.*iterator methods, and allows

[14:00] <dalek> rakudo/nom: some of the boilerplate to be hidden away in the method.

[14:00] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/42a8c58704

[14:00] <arnsholt> Time for a Mu.hashCode? =)

[14:02] <jnthn> That's what WHICH is for, it's just that ObjAt could do with being smarter :)

[14:03] <jnthn> Or actually less smart ;)

[14:03] <jnthn> Just an integer :)

[14:03] <jnthn> Though I think we probably want to have ways to construct ObjAt from other integers/ObjAt instances

[14:03] <jnthn> So we can factor out the hash computation

[14:04] <arnsholt> Ah, right =)

[14:05] <jnthn> And avoid the mass of StackOverflow threads C# et al. have on "how to write a good hashcode function" ;)

[14:05] <jnthn> And the resulting copy-paste of those into every non-small codebase out there :)

[14:07] <lizmat> so I guess we need some form of nqp::exists_id() ?

[14:07] * jnthn only had to fix two .t files for lexical module loading in his $dayjob codebase

[14:08] <lizmat> on an nqp::hash

[14:08] <jnthn> lizmat: I'd probably bypass nqp::hash entirely and just have an nqp::list

[14:08] <lizmat> for object hashes ?

[14:08] <jnthn> Or two

[14:08] <jnthn> Yeah

[14:08] <lizmat> works for me

[14:08] <jnthn> I mean, that's what hashes are under the hood anyway :)

[14:09] <jnthn> If we're smart then we might actually come out *ahead* of uthash

[14:09] <jnthn> On memory use

[14:09] <jnthn> Because it does things as a linked list.

[14:09] <jnthn> And so there's malloc overhead per element too

[14:09] <lizmat> how bad is nqp::splice ?  (for nqp::deletekey functionality) ?

[14:10] <jnthn> Huh?

[14:10] <jnthn> If you're asking that, then I suggest reading up on how to implement hash tables. ;_)

[14:10] <lizmat> perhaps I should  :-)

[14:10] <jnthn> (Elements never need to move.)

[14:11] <jnthn> In short, though, you take the integer hash value

[14:11] <jnthn> And then modulo it with the number of elements in your current array

[14:12] <jnthn> If that's kept to a power of 2 then that can be a bit operation

[14:12] <jnthn> And that tells which index to look in to

[14:12] <jnthn> The only problem beyond that is deciding on the strategy for collisions

[14:12] <lizmat> right

[14:12] <jnthn> A simple on being "just insert it into the next free slot"

[14:13] <jnthn> *simple one

[14:13] <jnthn> And then on lookup scan until hitting a null

[14:13] <jnthn> Also need a time to decide when to re-hash

[14:13] <jnthn> uh, not so much re-hash, but when to expand.

[14:13] <lizmat> feels to me this is something perl 5 has thought through a lot already ?

[14:14] <jnthn> Does it do object hashes?

[14:14] <lizmat> no

[14:14] <jnthn> (in core, I'm sure it's done 50 times on CPAN)

[14:14] <jnthn> Most langs have done this :)

[14:14] <jnthn> If you do the robin hood hashing, read the recent "accidentally quadratic" post about Rust's use of it

[14:15] <jnthn> It's worth reading for the nice explanations of things as well as the "what not to do" :)

[14:15] <lizmat> feels more and more like a rite of passage that's above my pay level  :-)

[14:16] <jnthn> I don't think it is, it's just a bit of background reading. :)

[14:16] <jnthn> And I'm sure others can chip in and help too :)

[14:17] <notviki> ZOFVM: Files=1211, Tests=130982, 165 wallclock secs (21.10 usr  3.39 sys + 2923.98 cusr 288.86 csys = 3237.33 CPU)

[14:17] <jnthn> I mean, I'd certainly want to give myself a refresher on the literature in the area if I was working on it. :)

[14:17] <jnthn> Nobody implements hash tables every day. :)

[14:19] <dalek> rakudo/nom: 1ee9c82 | (Zoffix Znet)++ | src/core/ (3 files):

[14:19] <dalek> rakudo/nom: Implement .clone for SetHash, BagHash, and MixHash

[14:19] <dalek> rakudo/nom:

[14:19] <dalek> rakudo/nom: I tried some nqp-foo that was faster on small baggies, but was 25%

[14:19] <dalek> rakudo/nom: slower on ones with 1000+ elements. So I just went with this.

[14:19] <dalek> rakudo/nom:

[14:19] <dalek> rakudo/nom: Fixes RT#127863: https://rt.perl.org/Ticket/Display.html?id=127863

[14:19] <synopsebot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=127863

[14:19] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/1ee9c825f8

[14:19] <dalek> roast: 37b3e12 | (Zoffix Znet)++ | S02-types/ (2 files):

[14:19] <dalek> roast: Test .clone works on SetHash, BagHash, and MixHash

[14:19] <dalek> roast:

[14:19] <dalek> roast: RT#127863: https://rt.perl.org/Ticket/Display.html?id=127863

[14:19] <dalek> roast: Rakudo fix: https://github.com/rakudo/rakudo/commit/1ee9c825f8

[14:19] <dalek> roast: review: https://github.com/perl6/roast/commit/37b3e121bb

[14:19] <synopsebot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=127863

[14:23] * jnthn tries to concentrate on $other-job for a bit

[14:24] <[Coke]> morning, everyone.

[14:24] <jnthn> o/ [Coke]

[14:33] <dalek> rakudo/nom: 8ab6e01 | lizmat++ | src/core/ (2 files):

[14:33] <dalek> rakudo/nom: Make R:I.DwimIterator a method

[14:33] <dalek> rakudo/nom:

[14:33] <dalek> rakudo/nom: Brings it more in line with the other R:I.*iterator methods, and allows

[14:33] <dalek> rakudo/nom: some of the boilerplate to be hidden away in the method.

[14:33] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/8ab6e019c6

[14:35] <dalek> nqp: 8025596 | (Pawel Murias)++ | src/vm/js/ (2 files):

[14:35] <dalek> nqp: [js] Implement nqp::throwextype.

[14:35] <dalek> nqp: review: https://github.com/perl6/nqp/commit/8025596507

[14:35] <dalek> nqp: f4e49bd | (Pawel Murias)++ | t/nqp/044-try-catch.t:

[14:35] <dalek> nqp: Test nqp::throwextype.

[14:35] <dalek> nqp: review: https://github.com/perl6/nqp/commit/f4e49bdd11

[14:35] <dalek> nqp: daef23e | (Pawel Murias)++ | src/vm/js/nqp-runtime/core.js:

[14:35] <dalek> nqp: [js] Fix error.

[14:35] <dalek> nqp: review: https://github.com/perl6/nqp/commit/daef23ed68

[14:36] <dalek> roast: 1fc7349 | (Zoffix Znet)++ | S15-normalization/test-gen.p6:

[14:36] <dalek> roast: De-bitrot pre-GLR script

[14:36] <dalek> roast: review: https://github.com/perl6/roast/commit/1fc7349f48

[14:36] <notviki> .tell samcv S15-normalization/test-gen.p6 should now work: https://github.com/perl6/roast/commit/1fc7349f48

[14:37] <notviki> .tell samcv S15-normalization/test-gen.p6 should now work: https://github.com/perl6/roast/commit/1fc7349f48

[14:37] <yoleaux2> notviki: I'll pass your message to samcv.

[14:39] <[Coke]> buggable: ?

[14:40] <[Coke]> buggable: tags

[14:40] <buggable> [Coke], Total: 1460; BUG: 941; UNTAGGED: 309; LTA: 135; NYI: 96; RFC: 61; CONC: 53; JVM: 52; REGEX: 41; SEGV: 31; PERF: 28; UNI: 27; NATIVECALL: 21; POD: 20; REGRESSION: 20; @LARRY: 19; IO: 18; TODO: 18; PRECOMP: 13; TESTNEEDED: 13; BUILD: 11; OO: 11; TESTCOMMITTED: 10; STAR: 8; BOOTSTRAP: 6; OPTIMIZER: 6; GLR: 5; MATH: 4; OSX: 4; REPL: 4; WEIRD: 3; RT: 2; SPESH: 2; WINDOWS: 2; @y: 1; CONFIGURE: 1; DOCS: 1; LIBR

[14:40] <[Coke]> notviki: why is that total 1460? (and not 1448 or 1478?)

[14:41] <notviki> There's a bug where if someone comments or tags an already resolved ticket perl6.fail will pick it up and think it's open again

[14:41] <[Coke]> also, what is "LIBR" ?

[14:41] <[Coke]> oh, maybe one of those closed tickets.

[14:41] <notviki> buggable: tag LIBRARY

[14:41] <buggable> notviki, There is 1 ticket tagged with LIBRARY; See http://perl6.fail/t/LIBRARY for details

[14:41] <notviki> I guess that, except it got cut off

[14:42] <[Coke]> ok, we don't use that value from the tag attribute anywhere else. clearing...

[14:48] <dalek> rakudo/nom: 935d6c2 | lizmat++ | src/core/ (5 files):

[14:48] <dalek> rakudo/nom: Make R:I.MappyIterator-values a method

[14:48] <dalek> rakudo/nom:

[14:48] <dalek> rakudo/nom: Brings it more in line with the other R:I.*iterator methods, and allows

[14:48] <dalek> rakudo/nom: some of the boilerplate to be hidden away in the method.

[14:48] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/935d6c25d7

[15:01] <dalek> rakudo/nom: 40d7deb | lizmat++ | src/core/Rakudo/Internals.pm:

[15:01] <dalek> rakudo/nom: Move all *Iterator methods together

[15:01] <dalek> rakudo/nom:

[15:01] <dalek> rakudo/nom: No functional change, just some code reorg for developer sanity

[15:01] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/40d7deb647

[15:07] <dalek> nqp: 0256679 | (Pawel Murias)++ | src/vm/js/nqp-runtime/bignum.js:

[15:07] <dalek> nqp: [js] Implement division by zero in nqp::div_In.

[15:07] <dalek> nqp: review: https://github.com/perl6/nqp/commit/0256679bc2

[15:07] <dalek> nqp: 24ac01e | (Pawel Murias)++ | t/nqp/060-bigint.t:

[15:07] <dalek> nqp: Test division by zero using nqp::div_In.

[15:07] <dalek> nqp: review: https://github.com/perl6/nqp/commit/24ac01ed37

[15:07] <pmurias> bartolin: I added tests for your div_In fixes.

[15:32] <ThorstenB> Jnthn, do you have a couple cycles to talk about building rakudo on WSL?

[15:40] <jnthn> Uh...yes but you just left :)

[15:41] <jnthn> ThorstenB: Hi :)

[15:41] <jnthn> I read the couple of github issues filed on that.

[15:41] <jnthn> If it's being fixed upstream in dyncall then we should be able to easily get those changes into our local copy of that

[15:43] <ThorstenB> That's all I wanted to make you aware of. It'll "take a while", dyncall devs have sensibly opted to look beyond perl6 and have found other projects that run into this as well, outside of WSL.

[15:44] <ThorstenB> As far back as January 2014, but it was never bubbled upstream instead some folk just kvetched about the dyncall assembly code and did -Wl,-z,noexecstack

[15:44] <jnthn> I think somebody else a while ago ran into the excutable stack thingy too

[15:44] <jnthn> (When building MoarVM)

[15:44] <ThorstenB> Yeah you might also see it with selinux

[15:45] <jnthn> I may well be misremembering, but I'm not sure it was tracked down to dyncall, so it's nice that at least now it is :)

[15:46] <ThorstenB> I have faith it'll get fixed. Not right this very second, people have lives and other todos to go into dyncall as well, but it'll get fixed eventually

[15:46] <jnthn> So, if I understand, we're waiting for dyncall for the moment, as a first resort? And I/somebody just needs to make sure we get that fix when it's available?

[15:47] <ThorstenB> Yes. If you don't want to wait you can force it at linktime with-Wl,-z,noexecstack in the relevant portion of the makefile

[15:47] <ThorstenB> But for now, unless this becomes more than a niche thing, just wait for upstream fix

[15:48] <jnthn> Works for me.

[15:48] <jnthn> Thanks for looking in to it.

[15:49] <ThorstenB> Thanks for being game to pull the fix when it's available

[16:04] <notviki> NeuralAnomaly: status

[16:04] <NeuralAnomaly> notviki, [‚úò] Next release will be in 2 weeks and 3 days. Since last release, there are 63 new still-open tickets (62 unreviewed and 0 blockers) and 205 unreviewed commits. See http://perl6.fail/release/stats for details

[16:05] * notviki clicks "take" on the roundrobin ticket

[16:06] <dogbert17> [Coke]: is it my BitCard username, i.e. email, that you need?

[16:30] <[Coke]> dogbert17: We can try that, sure

[16:30] <notviki> Seems Rakudo built from sauce on windows has issues with Linenoise not loading properly? https://twitter.com/sinan_unur/status/816304327761547264

[16:33] <ugexe> yeah, I suspect its because the dll doesn't expect itself to be renamed

[16:34] <notviki> Seems to work fine on my Rakudo Star install... isn't it renamed in there too?

[16:35] <stmuk> notviki: I had to revert to an earlier version in R*

[16:35] <ugexe> on OpenSSL i used a hack where it copies the installed sha1 dll to a temp directory and renames it to its original name, then uses *that*

[16:35] <ugexe> https://github.com/sergot/openssl/blob/master/lib/OpenSSL/NativeLib.pm6#L3

[16:35] <notviki> stmuk: so it's a known bug?

[16:36] <stmuk> notviki: yes and there has been recent work on it (note this is on mingw AFAIK its been broken on MSVC for a while)

[16:36] <notviki> cool

[16:37] <ugexe> i use MSVC and it works for me (in that I get the error shown)

[16:38] <stmuk> its been months since I tried MSVC maybe I'm out of date on that but there were special MSVC problems in the past

[16:39] <dalek> nqp: 365c861 | (Pawel Murias)++ | t/moar/02-qast-references.t:

[16:39] <dalek> nqp: Improve error message on failing test.

[16:39] <dalek> nqp: review: https://github.com/perl6/nqp/commit/365c8613b3

[16:39] <dalek> nqp: 47f5158 | (Pawel Murias)++ | src/vm/js/ (4 files):

[16:39] <dalek> nqp: [js] Stop putting things in nqp.op that are not exactly what the op is.

[16:39] <dalek> nqp: review: https://github.com/perl6/nqp/commit/47f5158e27

[16:39] <dalek> nqp: d8ec951 | (Pawel Murias)++ | src/vm/js/ (2 files):

[16:39] <dalek> nqp: [js] Implement nqp::getattrref_{i,n,s} and nqp::atposref_{i,n,s} ops.

[16:39] <dalek> nqp: review: https://github.com/perl6/nqp/commit/d8ec95127f

[16:39] <dalek> nqp: 1124404 | (Pawel Murias)++ | t/nqp/104-refs.t:

[16:39] <dalek> nqp: Test nqp::getattrref_{i,n,s} and nqp::atposref_{i,n,s} ops.

[16:39] <dalek> nqp: review: https://github.com/perl6/nqp/commit/112440440c

[16:40] <stmuk> maybe 46f953 works on MSVC?

[16:40] * notviki is mildly annoyed bdfoy and sinan broadcast these "buggy adventures in Perl 6" tweets, yet use bleed dev versions instead of using what we recommend users use -_-

[16:40] <stmuk> in hindsight the old versions should have had timebombs in them

[16:49] <stmuk> and maybe I should make R* exit on Fedora if the modules aren't installed :)

[16:53] <ThorstenB> Speaking of bleed, this reminds me of something that puzzled me. Rakudobrew appears to build 2016.12 right now, but the latest source tarball is 2016.11. Am I seeing things? If not, was having rakudobrew build something newer intended?

[16:56] <notviki> ThorstenB: rakudobrew isn't for regular users.

[16:56] <ugexe> https://github.com/rakudo/rakudo/archive/2016.12.tar.gz

[16:57] <notviki> ThorstenB: the latest version of user distribution is 2016.11

[16:58] <ThorstenB> Notviki: oh wow. Okay there is a possible ux issue here. When you look at rakudo.org, click download, then build from source, it starts with "the simplest way is to use rakudobrew"

[16:58] <ThorstenB> I therefore thought that was the go-to method for a regular perl6 user

[16:58] <ThorstenB> If that's not so then the documentation on that page can use a massage

[16:59] <notviki> Yeah

[16:59] <ThorstenB> The way that reads to me is "use rakudobrew and only if that is not flexible enough, install manually"

[17:00] <stmuk> maintaining rakudo.org and perl6.org is just doubling the workload

[17:01] <notviki> ThorstenB: it's just that page was written when we thought rakudobrew was awesome... but then users happened and we started receiving all these reports of problems, but they were due to people using rakudobrew but not having enough know-how to use it, so we then decided that recommending rakudobrew is a bad idea

[17:02] <notviki> And yeah, in needs some love

[17:02] <ThorstenB> I came to perl6 about a week ago with zero background in it, so I just googled and that's where I ended up ... on that rakudo.org page

[17:07] <notviki> created a ticket to improve the download page(s) https://rt.perl.org/Ticket/Display.html?id=130500

[17:09] <notviki> hum, fixing that roundrobin ticket breaks tests for a previous ticket that complained about the opposite issue :S

[17:10] <notviki> m: say roundrobin $(1, 2), <a b c>

[17:10] <camelia> rakudo-moar 40d7de: OUTPUT¬´(((1 2) a) (b) (c))‚ê§¬ª

[17:10] <notviki> cpan@perlbuild2~/CPANPRC/rakudo (nom)$ ./perl6 -e 'say roundrobin $(1, 2), <a b c>'

[17:10] <notviki> ((1 a) (2 b) (c))

[17:10] <notviki> :(

[17:15] <notviki> well crap... Seems the two ideas are entirely contradictory

[17:23] <notviki> .ask jnthn would you have any comments for RT#130498? Fixing it breaks tests for another ticket you fixed that makes these routines treat itemized lists as single items... so, I guess this isn't a bug at all?

[17:23] <yoleaux2> notviki: I'll pass your message to jnthn.

[17:23] <synopsebot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=130498

[18:07] <timotimo> samcv: if you were expecting the performance of csv to improve because of your changes, we'll have to wait for a moar + nqp bump first

[18:10] <notviki> timotimo: it was bumped (based on what I see in the backlog)

[18:10] <timotimo> oh?

[18:10] <notviki> https://irclog.perlgeek.de/perl6-dev/2017-01-04#i_13851359

[18:10] <timotimo> i didn't notice, but yeah

[18:10] <timotimo> good catch

[18:13] <jnthn> .

[18:13] <yoleaux2> 17:23Z <notviki> jnthn: would you have any comments for RT#130498? Fixing it breaks tests for another ticket you fixed that makes these routines treat itemized lists as single items... so, I guess this isn't a bug at all?

[18:13] <synopsebot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=130498

[18:15] <jnthn> notviki: This is one of the consequences of an Array being a bunch of *items*, yes.

[18:15] <notviki> ok, so notabug then

[18:16] <jnthn> m: my @l = (0,1,2),(3,4,5),(6,7); say roundrobin(@l>>.list);

[18:16] <camelia> rakudo-moar 40d7de: OUTPUT¬´(((0 1 2)) ((3 4 5)) ((6 7)))‚ê§¬ª

[18:16] <notviki> m: my @l = (0,1,2),(3,4,5),(6,7); say roundrobin(@l¬ª.List);

[18:16] <camelia> rakudo-moar 40d7de: OUTPUT¬´(((0 1 2)) ((3 4 5)) ((6 7)))‚ê§¬ª

[18:16] <notviki> m: my @l = (0,1,2),(3,4,5),(6,7); say roundrobin(|@l¬ª.List);

[18:16] <camelia> rakudo-moar 40d7de: OUTPUT¬´((0 3 6) (1 4 7) (2 5))‚ê§¬ª

[18:16] <notviki> there

[18:16] <jnthn> ah, needed | too

[18:16] <jnthn> m: my @l = (0,1,2),(3,4,5),(6,7); say roundrobin(|@l¬ª.list);

[18:16] <camelia> rakudo-moar 40d7de: OUTPUT¬´((0 3 6) (1 4 7) (2 5))‚ê§¬ª

[18:17] <jnthn> .list removes itemization which is sufficient (and cheaper than .List)

[18:17] <notviki> cool

[18:17] <jnthn> Now, what shall I use my next hour to look at...

[18:18] <jnthn> Ah, right, I valgrund RT #130494 last night before bed

[18:18] <synopsebot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=130494

[18:23] <AlexDaniel> m: my @l = (0,1,2),(3,4,5),(6,7); say roundrobin(|@l);

[18:23] <camelia> rakudo-moar 40d7de: OUTPUT¬´(((0 1 2) (3 4 5) (6 7)))‚ê§¬ª

[18:23] <AlexDaniel> m: my @l = (0,1,2),(3,4,5),(6,7); say roundrobin(|@l.List);

[18:23] <camelia> rakudo-moar 40d7de: OUTPUT¬´((0 3 6) (1 4 7) (2 5))‚ê§¬ª

[18:23] <AlexDaniel> why ¬ª not sure

[18:24] <jnthn> Oh, .List also deconts the elements...

[18:24] * jnthn always forgets that, it's a really odd thing for an upcast to not return self, even if this behavior can be useful

[18:25] * AlexDaniel will never be able to remember the difference between .list and .List

[18:25] * jnthn kinda wishes we'd given the useful behavior Array.List has a nice name.

[18:25] <jnthn> :733

[18:25] <jnthn> oops

[18:26] <AlexDaniel> so .list does nothing and .List does something useful‚Ä¶ hmm

[18:26] <notviki> a: [], 'list', \()

[18:26] <notviki> s: [], 'list', \()

[18:26] <SourceBaby> notviki, Sauce is at https://github.com/rakudo/rakudo/blob/40d7deb/src/core/List.pm#L769

[18:26] <notviki> s: [], 'List', \()

[18:26] <SourceBaby> notviki, Sauce is at https://github.com/rakudo/rakudo/blob/40d7deb/src/core/Array.pm#L290

[18:27] <jnthn> .list removes the itemization of the thing you call it on, in this case

[18:27] <AlexDaniel> ?

[18:27] <notviki> Weird, 'cause the code just returns { self }

[18:28] <jnthn> Yes, and self isn't an item

[18:28] <notviki> ah self is deconted.. is that why?

[18:28] <jnthn> Right

[18:28] <notviki> k :)

[18:28] <AlexDaniel> hm‚Ä¶ what would be the example to show the effect?

[18:28] <jnthn> m: say 131072000 / 2000

[18:28] <notviki> m: my $l = (1, 2, 3); dd $l

[18:28] <camelia> rakudo-moar 40d7de: OUTPUT¬´65536‚ê§¬ª

[18:28] <camelia> rakudo-moar 40d7de: OUTPUT¬´List $l = $(1, 2, 3)‚ê§¬ª

[18:28] <notviki> m: my $l = (1, 2, 3); dd $l; dd $l.List

[18:28] <camelia> rakudo-moar 40d7de: OUTPUT¬´List $l = $(1, 2, 3)‚ê§(1, 2, 3)‚ê§¬ª

[18:29] <AlexDaniel> m: my $l = (1, 2, 3); dd $l; dd $l.list

[18:29] <camelia> rakudo-moar 40d7de: OUTPUT¬´List $l = $(1, 2, 3)‚ê§(1, 2, 3)‚ê§¬ª

[18:29] <AlexDaniel> ahh,okay

[18:29] <notviki> m: my $l = (1, 2, 3); dd $l X (1, 2, 3); dd $l.List X (1, 2, 3)

[18:29] <camelia> rakudo-moar 40d7de: OUTPUT¬´(($(1, 2, 3), 1), ($(1, 2, 3), 2), ($(1, 2, 3), 3)).Seq‚ê§((1, 1), (1, 2), (1, 3), (2, 1), (2, 2), (2, 3), (3, 1), (3, 2), (3, 3)).Seq‚ê§¬ª

[18:43] <jnthn> > count objects type="Buf[uint8]"

[18:43] <jnthn> 501

[18:44] <jnthn> About the leak, the reason there's so much leaked is because libuv suggests we allocate a 64KB buffer for each line, then gives us something much smaller

[18:44] <jnthn> The leak doesn't appear to be at C level, but rather than all the Bufs live on once they make it Perl 6 side.

[18:45] <jnthn> (I did 500 iterations of the loop, this snapshot is near the end of the program, after 16 GC runs had chance to nom some of them)

[18:45] <timotimo> 64 kb o_O

[18:45] <jnthn> Also

[18:45] * jnthn <3 maor-ha

[18:45] <jnthn> *moar-ha, heh, can't even type it

[18:46] <timotimo> so should we take the extra work to copy into a smaller buffer if we notice it's less than 10% full?

[18:46] <timotimo> OSLT?

[18:46] <jnthn> We could just realloc since it was malloc'd

[18:46] <timotimo> ah, good

[18:47] <jnthn> If somebody fancies giving moar-ha the ability to use readline if it's installed, that'd be super-nice ;)

[18:49] <jnthn> oh...

[18:49] <timotimo> it would be! :)

[18:50] <jnthn> I also idly wonder if we can somehow bias the BFS used for path against giving entries from the inter-gen root set

[18:50] <jnthn> Since it's the shortest path but not the most useful

[18:51] <timotimo> yes!

[18:51] <timotimo> i thought about allowing to completely throw it out; generalized to completely ignoring one specific object

[18:52] <jnthn> If I remember the code we may be able to just hack that arc to cost a load

[18:52] <jnthn> It's useful that it shows up in results

[18:52] <jnthn> If it's the only thing keeping it alive

[18:53] <timotimo> aye

[18:54] <jnthn> grr, yeah, I think fixing that now is going to be faster than trying 500 object IDs with path to find one not in the inter-gen set

[18:55] <jnthn> Block (Object) (475739) --[ Unknown ]-->

[18:55] <jnthn> Wonder why htat's Unknown

[19:01] <timotimo> it's a secret to everybody

[19:03] <dalek> rakudo/nom: d9c735f | (Zoffix Znet)++ | README.md:

[19:03] <dalek> rakudo/nom: Include URL to https://twitter.com/perl6org

[19:03] <dalek> rakudo/nom:

[19:03] <dalek> rakudo/nom: (the original @rakudoperl seems to be a dead account)

[19:03] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/d9c735f6b1

[19:07] <jnthn> Righty, let's see if my change works...

[19:22] <jnthn> Um, no but... :)

[19:27] <jnthn> So I busted it. But in such a way that it didn't visit the inter-gens at all. And then the things didn't show a path to them

[19:28] <jnthn> So they really are only in the inter-gen set

[19:29] <jnthn> Well, they aren't

[19:29] <jnthn> They're ref'd by an object that's in that set

[19:29] <jnthn> That in turn may be (about to check) that we never do a full collect

[19:29] <jnthn> Because we don't track the memory pressure sufficiently to trigger one

[19:29] <jnthn> Because of the buffer size iffiness

[19:48] <jnthn> Hm, might be worse than that.

[20:12] <AlexDaniel> can somebody help me with this one?

[20:12] <AlexDaniel> m: class I { method pull-one { IterationEnd } }; role Foo { also does Positional; also does Iterable; method iterator { I.new } }; say ("bar" but Foo) ~~ /a/

[20:12] <camelia> rakudo-moar d9c735: OUTPUT¬´Type check failed in binding to iter; expected Iterator but got I (I.new)‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[20:12] <AlexDaniel> mc: class I { method pull-one { IterationEnd } }; role Foo { also does Positional; also does Iterable; method iterator { I.new } }; say ("bar" but Foo) ~~ /a/

[20:12] <committable6> AlexDaniel, ¬¶¬´2015.12¬ª: Nil

[20:12] <AlexDaniel> bisectable points to https://github.com/rakudo/rakudo/commit/e4dc8b6ed1f9b3b4846f0e371c9b8e0569b798c5

[20:14] <AlexDaniel> actually, forget that, it's more complicated than this‚Ä¶

[20:15] <timotimo> why isn't I "is Iterator"?

[20:16] <AlexDaniel> I‚Ä¶ don't know? Not my code

[20:17] <AlexDaniel> m: class I is Iterator { method pull-one { IterationEnd } }; role Foo { also does Positional; also does Iterable; method iterator { I.new } }; say ("bar" but Foo) ~~ /a/

[20:17] <camelia> rakudo-moar d9c735: OUTPUT¬´===SORRY!=== Error while compiling <tmp>‚ê§Method 'pull-one' must be implemented by Iterator because it is required by roles: Iterator.‚ê§at <tmp>:1‚ê§¬ª

[20:17] <AlexDaniel> mc: class I is Iterator { method pull-one { IterationEnd } }; role Foo { also does Positional; also does Iterable; method iterator { I.new } }; say ("bar" but Foo) ~~ /a/

[20:17] <committable6> AlexDaniel, ¬¶¬´2015.12¬ª: ===SORRY!=== Error while compiling /tmp/G9bOXew4mr‚ê§Method 'pull-one' must be implemented by Iterator because it is required by a role‚ê§at /tmp/G9bOXew4mr:1 ¬´exit code = 1¬ª

[20:18] <lizmat> does Iterator

[20:19] <AlexDaniel> m: class I does Iterator { method pull-one { IterationEnd } }; role Foo { also does Positional; also does Iterable; method iterator { I.new } }; say ("bar" but Foo) ~~ /a/

[20:19] <camelia> rakudo-moar d9c735: OUTPUT¬´Nil‚ê§¬ª

[20:20] <timotimo> ah, sorry, does Iterator, not is Iterator

[20:20] <timotimo> but you already noticed

[20:21] <timotimo> i mean liz noticed

[20:39] <dalek> rakudo/nom: 6920dad | lizmat++ | src/core/ (2 files):

[20:39] <dalek> rakudo/nom: Make single element Z a bit faster

[20:39] <dalek> rakudo/nom:

[20:39] <dalek> rakudo/nom: By using the UnendingValueIterator instead of the WhateverIterator.

[20:39] <dalek> rakudo/nom: Main reason is that we don't need to check for Whatever, or keep

[20:39] <dalek> rakudo/nom: remembering values, as there is only one value to remember.

[20:39] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/6920dad16f

[21:19] <gfldex> jnthn: could you have a look at the following please? https://github.com/perl6/doc/issues/1111

[21:19] <samcv> morning perl6!

[21:19] <yoleaux2> 14:37Z <notviki> samcv: S15-normalization/test-gen.p6 should now work: https://github.com/perl6/roast/commit/1fc7349f48

[21:19] <samcv> yay!

[21:24] <dalek> rakudo/nom: dbe3e0e | lizmat++ | src/core/Rakudo/Internals.pm:

[21:24] <dalek> rakudo/nom: Introducing R:I.RandomizeOrderIterator

[21:24] <dalek> rakudo/nom:

[21:24] <dalek> rakudo/nom: An iterator that will semi-randomize the order of the values of a

[21:24] <dalek> rakudo/nom: given iterator.  It does this by randomly fetching 2..5 values from

[21:24] <dalek> rakudo/nom: the iterator, and supplying them in reverse order.  Rince. Repeat.

[21:24] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/dbe3e0eaa3

[21:36] <dalek> roast: be3385d | samcv++ | S15-normalization/ (45 files):

[21:36] <dalek> roast: Update S15-normalization tests for Unicode 9.0

[21:36] <dalek> roast: review: https://github.com/perl6/roast/commit/be3385d17e

[21:52] <jnthn> gfldex: Left a comment

[21:52] * jnthn is too tired for more leak hunt today, or anything else much useful for that matter...

[21:53] <jnthn> Probably gone for the night o/

[21:53] <moritz> \o

[22:06] <dalek> roast: 284be4e | samcv++ | S15-nfg/emoji-test (2 files):

[22:06] <dalek> roast: Add Emoji grapheme tests

[22:06] <dalek> roast:

[22:06] <dalek> roast: Generated from Emoji version 4.0

[22:06] <dalek> roast: These are seperate from the other Grapheme break tests, in being

[22:06] <dalek> roast: an optional part of the Unicode standard.

[22:06] <dalek> roast: review: https://github.com/perl6/roast/commit/284be4e2fd

[22:06] <dalek> roast: 587a426 | samcv++ | S15-nfg/emoji-test.t:

[22:06] <dalek> roast: Fudge failing Emoji tests

[22:06] <dalek> roast: review: https://github.com/perl6/roast/commit/587a426367

[22:09] <dalek> rakudo/nom: 18793d1 | samcv++ | t/spectest.data:

[22:09] <dalek> rakudo/nom: Add emoji-test.t to spectest.data

[22:09] <dalek> rakudo/nom:

[22:09] <dalek> rakudo/nom: See roast commit:

[22:09] <dalek> rakudo/nom: https://github.com/perl6/roast/commit/284be4e2fdc3364cd597afd64381f8b67fb898aa

[22:09] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/18793d17fc

[22:18] <samcv> lizmat, you broke some of the Zip operator tests

[22:19] <lizmat> ah?

[22:19] <samcv> yea

[22:19] <samcv> t/spec/S03-metaops/zip.t failed 4

[22:19] * lizmat checks

[22:22] <lizmat> samcv: you're right, but odd that I didn't see that  :-(

[22:22] <lizmat> guess it's 6920dad16f5

[22:22] * lizmat checks

[22:25] <dalek> rakudo/nom: bd03adb | lizmat++ | src/core/ (2 files):

[22:25] <dalek> rakudo/nom: Revert "Make single element Z a bit faster"

[22:25] <dalek> rakudo/nom:

[22:25] <dalek> rakudo/nom: This reverts commit 6920dad16f59b0de314bb0fae5027b8039e9847b.

[22:25] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/bd03adb1fe

[22:25] <lizmat> samcv++  # spotting the error of my ways  :-)

[22:25] <bartolin> pmurias: thanks! the first time I looked, I didn't find the

[22:25] <lizmat> I'm starting to look at optimizing hypers

[22:25] <bartolin> pmurias: thanks! the first time I looked, I didn't find the right way to write those tests.

[22:26] <bartolin> pmurias: I think I understand it now :-)

[22:47] <dalek> rakudo/nom: 0f25d83 | lizmat++ | src/core/metaops.pm:

[22:47] <dalek> rakudo/nom: Make is nodal check a bit faster

[22:47] <dalek> rakudo/nom:

[22:47] <dalek> rakudo/nom: The existence of the method is enough to mark nodality.  No need to

[22:47] <dalek> rakudo/nom: call it to find out.

[22:47] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/0f25d83a4c

[23:07] <dalek> rakudo/nom: 516e527 | lizmat++ | src/core/Capture.pm:

[23:07] <dalek> rakudo/nom: Make Capture.Bool about 3x as fast

[23:07] <dalek> rakudo/nom:

[23:07] <dalek> rakudo/nom: It wasn't much to begin with, but it appears to be checked a lot.

[23:07] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/516e527682

[23:16] <timotimo> neat

[23:20] <dalek> rakudo/nom: 996ab6a | lizmat++ | src/core/Mu.pm:

[23:20] <dalek> rakudo/nom: Streamline "hyper" nodality test a bit

[23:20] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/996ab6a040

[23:40] <dalek> roast: 0349626 | flussence++ | S19-command-line/arguments.t:

[23:40] <dalek> roast: Add command line test for UTF-8 decoding of @*ARGS (#215)

[23:40] <dalek> roast:

[23:40] <dalek> roast: Github issue ref: MoarVM/MoarVM#482

[23:40] <dalek> roast: review: https://github.com/perl6/roast/commit/0349626512
