[00:02] <samcv> maybe i just need to make my function faster. that is part of it at least.hm

[00:04] <samcv> timotimo, do you know if it cache's the result of nqp::fc and returns the same fc string if i repeatedly request the foldcase version for the same string?

[00:07] <timotimo> no, it won't cache that

[00:07] <timotimo> i'll be playing vidya game with a friend now :)

[00:08] <samcv> ok

[00:12] <timotimo> and after that probably sleep

[00:38] <samcv> \o/ ok i got it. woo

[00:41] <samcv> only about 16% slower than nqp::index

[00:41] <samcv> from initial estimates

[00:43] <samcv> and the speed of worst-case caseinsensitive matching goes from 2.26970566 to 1.2345366s

[00:43] <samcv> comparing from a release a month or two ago

[01:32] <timotimo> samcv: is that a fake number? 1.234? :)

[01:37] <samcv> no

[01:38] <samcv> real number :)

[01:38] <samcv> but if i made up a number it could very well be that. heh

[05:49] <Geth> ¦ roast: 389db59ff9 | (Samantha McVey)++ | S03-operators/repeat.t

[05:49] <Geth> ¦ roast: [unfudge] Huge repeat counts become neg. numbers RT #128035

[05:49] <Geth> ¦ roast: review: https://github.com/perl6/roast/commit/389db59ff9

[05:49] <synopsebot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=128035

[06:08] <Geth> ¦ nqp/foldcase: 4 commits pushed by (Samantha McVey)++

[06:08] <Geth> ¦ nqp/foldcase: 37d4fa06e7 | [moar] Use foldcase in one more place of QASTRegexCompilier

[06:08] <Geth> ¦ nqp/foldcase: 81e9a0ee4f | Add/remove more

[06:08] <Geth> ¦ nqp/foldcase: bc85a32fca | Remove things because why not?

[06:08] <Geth> ¦ nqp/foldcase: a0ea08bd9e | removing things is fun

[06:08] <Geth> ¦ nqp/foldcase: review: https://github.com/perl6/nqp/compare/0000000000...a0ea08bd9e

[06:10] <samcv> nqp-jvm: use NQPHLL;say(nqp::getcomp('jvm').language)

[06:10] <camelia> nqp-jvm: OUTPUT: «Error occurred during initialization of VM␤Could not allocate metaspace: 1073741824 bytes␤»

[06:10] <samcv> nqp: use NQPHLL;say(nqp::getcomp('jvm').language)

[06:10] <camelia> nqp-moarvm: OUTPUT: «Cannot call method 'language' on a null object␤   at <tmp>:1  (<ephemeral file>:<mainline>)␤ from gen/moar/stage2/NQPHLL.nqp:1587  (/home/camelia/rakudo-m-inst-2/share/nqp/lib/NQPHLL.moarvm:eval)␤ from gen/moar/stage2/NQPHLL.nqp:1790  (/home/camelia/rakudo…»

[06:10] <samcv> nqp: use NQPHLL;say(nqp::getcomp('moar').language)

[06:10] <camelia> nqp-moarvm: OUTPUT: «moar␤»

[06:18] <[TuxCM]> This is Rakudo version 2017.03-53-g5ca924df2 built on MoarVM version 2017.03-31-g8f9325b8

[06:18] <[TuxCM]> csv-ip5xs        3.069

[06:18] <[TuxCM]> test            12.619

[06:18] <[TuxCM]> test-t           4.897 - 4.928

[06:18] <[TuxCM]> csv-parser      12.989

[06:18] <samcv> o/ [TuxCM]

[06:19] <[TuxCM]> o/

[06:19] <samcv> [TuxCM], is there a way i can dl yoru perl6 test and bench it locally

[06:19] <samcv> hopefully i can bump that speed up with 1.7x :i speed boost coming very soon

[06:19] <samcv> also would like to just profile it in general

[06:19] <[TuxCM]> all url's have been posted here repeatedly

[06:20] <[TuxCM]> http://modules.perl6.org/

[06:20] <[TuxCM]> https://github.com/Tux/CSV

[06:20] <samcv> the test you actually run though. i know those url's

[06:20] <samcv> but the benchmarks

[06:20] <samcv> the actual thing you run or whatever

[06:20] <[TuxCM]> there is a README.speed

[06:21] <samcv> ok thanks you. will read that

[07:36] <lizmat> Files=1181, Tests=55992, 196 wallclock secs (11.64 usr  4.68 sys + 1159.57 cusr 112.20 csys = 1288.09 CPU)

[08:35] <lizmat> https://www.flickr.com/photos/wendyga/33655590366/in/album-72157678619026503/   # Camelia on stage in Brussels at ARW concert

[08:36] <lizmat> https://www.flickr.com/photos/wendyga/33312481450/in/album-72157678619026503/  # closeup

[08:55] <masak> :)

[08:55] <masak> camelia is entering into her rock phase...

[10:05] <Zoffix> huggable: csv

[10:05] <huggable> Zoffix, https://github.com/Tux/CSV (see `bench csv` for how to run bench)

[10:05] <Zoffix> huggable: bench csv

[10:05] <huggable> Zoffix, export PATH=`pwd`/install/bin:$PATH; cd CSV; for i in $(seq 1 10000); do echo 'hello,","," ",world,"!"'; done > /tmp/hello.csv; time perl6 -Ilib -MText::CSV test-t.pl </tmp/hello.csv

[10:06] <Zoffix> samcv: ^ that's it. You can ignore the export path part

[10:13] <Zoffix> NeuralAnomaly: status

[10:13] <NeuralAnomaly> Zoffix, [✘] Next release will be in 2 weeks and 4 days. Since last release, there are 13 new still-open tickets (13 unreviewed and 0 blockers) and 56 unreviewed commits. See http://perl6.fail/release/stats for details

[10:13] <Zoffix> Damn time flies.

[10:15] * jnthn swats a time fly

[10:19] <Zoffix> I wanna cram all the IO updates into 2017.04 release and somehow thought there were still 4 weeks until the release :)

[10:47] <Zoffix> So 6.d is additive, but can we replace entire classes, say with `class IO::Path {…}` or will it cry about redeclaration?

[10:47] <Zoffix> guess I can try and see...

[10:50] <Zoffix> (not gonna do it, but pondering whether I can write `FastIO` module that ditches $*SPEC with the assumption that it can later be just copy-pasted into 6.d or whatever language)

[10:53] <lizmat> my question is really: what do we need $*SPEC for?

[10:53] <lizmat> basically preprocessing paths before you get an absolute path that you can feed to the OS

[10:53] <Geth> ¦ rakudo/nom: 42f34fb8ae | (Pawel Murias)++ | 2 files

[10:53] <Geth> ¦ rakudo/nom: Move tests for is_approx to a separate file

[10:53] <Geth> ¦ rakudo/nom:

[10:53] <Geth> ¦ rakudo/nom: It's deprecated so it's tested separately.

[10:53] <Geth> ¦ rakudo/nom: review: https://github.com/rakudo/rakudo/commit/42f34fb8ae

[10:57] <Zoffix> lizmat: but also to stringify them

[10:57] <Zoffix> m: "../".IO.relative("/tmp/foo/bar").say

[10:57] <camelia> rakudo-moar 5ca924: OUTPUT: «../../../home/camelia/..␤»

[10:58] <Zoffix> m: "../".IO.relative("/tmp/foo/bar").resolve.say

[10:58] <camelia> rakudo-moar 5ca924: OUTPUT: «No such method 'resolve' for invocant of type 'Str'␤  in block <unit> at <tmp> line 1␤␤»

[10:58] <Zoffix> m: "../".IO.relative("/tmp/foo/bar").IO.resolve.relative.say

[10:58] <camelia> rakudo-moar 5ca924: OUTPUT: «..␤»

[10:58] <Zoffix> And modify them... .child/.parent/.concat-wtih

[10:59] <Zoffix> m: my $*SPEC = IO::Spec::Win32; "../".IO.relative("/tmp/foo/bar").say

[10:59] <camelia> rakudo-moar 5ca924: OUTPUT: «..\..\..\home\camelia\..␤»

[11:00] <Zoffix> My biggest worry is switching to unorthodox path separators on Windows. Sure they work with the OS, but people will also feed them to all sorts of stuff.

[11:01] <geekosaur> define "unorthodox"

[11:01] <Zoffix> And the headlines that will follow: "Slow ass Perl 6 optimized by using wrong Windows paths and now it broke XYZ"

[11:02] * Zoffix needs to get ready to work

[11:02] <lizmat> Zoffix: my approach to this was: from outside s/\\/\//  :-)

[11:02] <lizmat> and on output, if Win, then change all / to \

[11:03] <lizmat> output like shelling out

[11:04] <geekosaur> well. there's the "orthodox" that says that all paths shall be unixlike, and there's the "orthodox" that says that Windows paths use \ as the separator and / is compatibility shim

[11:05] <geekosaur> and you can;t win with the "using wrong Windows paths" because half the programs you run into will only work right with one or the other

[11:05] <geekosaur> so no matter which you use, you will be wrong some of the time

[11:05] <geekosaur> "wrong"

[11:06] * lizmat goes afk again

[11:18] <Zoffix> m: '/tmp/foo3\lulz2'.IO.mkdir; say grep *.contains('lulz2'), dir '/tmp/'

[11:18] <camelia> rakudo-moar 42f34f: OUTPUT: «("/tmp/foo3\lulz2".IO)␤»

[11:19] <Zoffix> And on Windows that'd be a folder within a folder

[11:22] <geekosaur> yes?

[11:23] * Zoffix doesn't understand the question

[11:23] * geekosaur doesn;t udnerstand your point unless it's "but it mixed path separators we must hide this from the little kids"

[11:24] <geekosaur> ...if it confuses them then perhaops they should not use an OS which treats them both the same *usually*

[11:26] <Zoffix> No, my point was that if abandoning $*SPEC and preprocess paths the same on all OSes, the above case is problematic

[11:27] <Zoffix> calling .parent() on it should give different results on Windows and *nix

[11:28] * geekosaur scans back to see what that's about

[11:28] <geekosaur> uh

[11:28] <geekosaur> no, getting rid of $*SPEC for *buggy* speed up is terrible idea

[11:29] <geekosaur> do NOT do this

[11:29] <geekosaur> or do it and stop advertising Windows compatibility

[11:29] <Zoffix> Right

[11:31] <Zoffix> But there's still a lot we can gain by making SPEC internal and getting rid of the dynvar and all the methods that just return '.', '..'

[11:33] <Zoffix> Which I'll attempt to do in a module

[11:36] <Geth> ¦ roast: cc5ee3d7f0 | (Pawel Murias)++ | S24-testing/10-is-approx.t

[11:36] <Geth> ¦ roast: Test is-approx.

[11:36] <Geth> ¦ roast: review: https://github.com/perl6/roast/commit/cc5ee3d7f0

[11:37] <geekosaur> the dynvar maybe. I'd be careful about the others unless you are certain Perl 6 will never be ported to an OS with different conventions

[11:37] <geekosaur> yes, I'm sure it's faster, just like it would be to ignore how path separators work on Windows

[11:39] <Zoffix> The port would take care of adding back the . and .. :)

[11:40] <geekosaur> ...what?

[11:41] <geekosaur> (this looks worrisome anyway, how do you deal with ... uh, which OS used a sequence of // to back up instead of a .. ?)

[11:41] <Zoffix> People porting to such an OS would add support for it.

[11:42] <Zoffix> Just like now they'd have to add a specific ::Spec::* module for it

[12:18] <Woodi> I totally don't get that problems with paths... a) during VM compile time, installation and precompilation require *correct* paths from current OS;  b) in runtime user should provide correct paths...  what is missing ?

[12:21] <Zoffix> Woodi: "/tmp/foo3\lulz2" is *correct* path on both Linux and Windows. But that `\` in it has different meaning depending on the OS.

[12:23] <geekosaur> which is confused by the fact that the CLI pretty much requires you to use \ on Windows, but the OS API accepts either (because the CLI considers / the start of a command line option)

[12:29] <Woodi> then only one thing can be done: stick to common case && provide specialised "use Windows::Quirks;"

[12:31] <geekosaur> what is the "common case"?

[12:31] <geekosaur> (hint: there is no correct answer. you don't get to force one on Windows.)

[12:32] <Woodi> '\' on *nix, '/' on Win, ':' on Mac ? and user need to provide sensible paths

[12:32] <geekosaur> er?

[12:32] <geekosaur> that's completely wrong...

[12:32] <Woodi> what ? yes, '/' on Unix :)

[12:33] <geekosaur> ':' was only used in MacOS 9 and earlier

[12:33] <Woodi> geekosaur: now you are lost in details

[12:33] <Woodi> afk

[12:33] <geekosaur> uh

[12:33] <geekosaur> again, you don;t get to assert that

[12:33] <Zoffix> :)

[12:34] <geekosaur> an OS X API will not parse ':' as a path separator. you don't get to assert otherwise unless you want to give up compatibility with anything else

[12:35] <geekosaur> and, Windows APIs accept either / or \. again, you don;t get to assert otherwise. the OS gets to assert it, and it does assert it; you must comply, not try to argue otherwise

[12:35] <Zoffix> .oO( resistance is futile... )

[12:48] <stmuk_> wibble

[13:12] <Woodi> b.  I'm proposing limiting user input to common cases. in case someone want more complicated things he needs to use Pro:SpecificOS module. same story as with object-relational mappers - at some level of control you need to drop sugar.

[13:13] <Zoffix> he?

[13:13] <Zoffix> I'm not sure how you plan on limiting the presence of 'foo\bar' directory when doing `dir` for example

[13:15] <Woodi> but details: on Linux/Unix if someone provide  "/tmp/foo3\lulz2".mkdir - not a problem. on Windows  "/tmp/foo3/lulz2".mkdir is error, "\tmp\foo3\lulz2".mkdir is ok. on windows,  "/tmp/foo3\lulz2".mkdir is error - command starts with switches

[13:16] <Woodi> do we plan to support case when user do not know what os he use ?

[13:16] <Zoffix> And it seems to come from a viewpoint that the user manually types up all the paths into their code, when more often than not, the paths would come from somewhere else. So what you'd have is most people writing programs that crash on certain input and more skilled programmers always including Pro::SpecificOS modules simply to prevent those crashes.

[13:16] <Zoffix> Woodi: we already do :/

[13:17] <Woodi> Zoffix: require Pro::Virtualos :)

[13:17] <geekosaur> woodi, so you want perl 6 not to accept paths that other programs can legally produce on Windows?

[13:18] <geekosaur> but it sounds like this will have to be a learning experience because multiple people think this somehow makes sense.

[13:18] <Woodi> geekosaur: if path are invalid for subsystem we use internally then yes.

[13:18] <geekosaur> the path is not invalid for Windows

[13:19] <Woodi> geekosaur: but it's nor "common case". and it is resolved by including Pro:: :)

[13:19] <geekosaur> the path is invalid for a cheerful charlie path parser that deliberately violates the platform specification in the name of speed

[13:19] <geekosaur> this is not acceptable

[13:19] <geekosaur> and again, you do not get to say what the common case is

[13:19] <geekosaur> the actual common case on Windows? you don;t normally get paths that *mix* them, but you will often get paths that use one or the other

[13:20] <Woodi> cc is: *nix path separator is '/', on Windows '/'.

[13:20] <perlpilot> .oO( the "common case" is fubar :) )

[13:20] <geekosaur> but even so, I think you do not get to declare "common case" unless you want to not interoperate with other Windows programs

[13:20] <Woodi> you know what on Window :)

[13:20] <geekosaur> which is your call, I guess, if you like telling Windows users to go away

[13:21] <Woodi> geekosaur: if someone want to operate he include Pro::Windows

[13:21] <geekosaur> no

[13:21] <geekosaur> oh never mind

[13:21] <geekosaur> yes, please do that

[13:21] <Zoffix> heh

[13:21] <Zoffix> That's not gonna happen./

[13:21] <geekosaur> you will evidently need to learn the hard way what is acceptable to Windows users

[13:21] <geekosaur> so yes, please do that

[13:22] <Woodi> geekosaur: "Windows user" is Explorer user by definition - he use path picker :)

[13:22] <geekosaur> ...

[13:22] <geekosaur> I'm out. please do what you want.

[13:23] <Woodi> geekosaur: I would go, you pls stay, seriously

[13:23] <geekosaur> no, I am out of this conversation. you want to dictate to Windows users what is correct, you dictate to Windows users what is correct.

[13:24] <geekosaur> you find out how fare it gets yuou, *then* we can consider having this conversation.

[13:27] <perlpilot> This whole "common case" thing reminds me of character encodings.   Either you know what encoding you need to use or you guess.  The "common case" here sounds like guessing.   And, of course, guessing is rife with pain and suffering.

[13:28] <Woodi> just dividing problem space on cases. I do not say what's correct becouse it would deny the reality

[13:28] <Zoffix> lizmat: so how did camelia manage to get on stage of a concert?

[13:29] <Zoffix> lizmat: also is that picture private or can I tweet it?

[13:31] <Zoffix> C:\temp>perl6 -e "say dir 'foo/bar'"

[13:31] <Zoffix> ("foo/bar\ber".IO "foo/bar\meow".IO)

[13:32] * Zoffix is disappointed with those path separator mixage in output :()

[13:32] <Zoffix> Especially since it's double-quoted and wrong

[13:33] <Zoffix> At least .perl is right

[13:33] <timotimo> good catch on the backslashes there

[13:35] <perlpilot> Zoffix: pretty sure woolfy posted on FB about how they gave a camelia to each of ARW before their show in Brussels

[13:35] <Zoffix> Ah, now I see it :)

[13:36] <timotimo> i don't know who ARW are :|

[13:36] <perlpilot> timotimo: Yes 2.0

[13:36] * Zoffix doesn't know who either are :)

[13:37] <geekosaur> wouldn't this be something like 5.0?

[13:37] <perlpilot> whatever, I can't keep track of how many incarnations their are/were  :)

[13:37] <geekosaur> :)

[13:38] <geekosaur> https://en.wikipedia.org/wiki/Yes_(band) and it looks like 4.0

[13:39] <geekosaur> Yes, ABWH, Cinema/"Yes 2.0", ARW

[13:39] <timotimo> yes, yes.

[13:39] <perlpilot> Also, https://en.wikipedia.org/wiki/Anderson,_Rabin_and_Wakeman

[13:39] * Zoffix is amused https://en.wikipedia.org/wiki/No_(band) is not a 404 :)

[14:01] <SmokeMachine> Zoffix, lizmat: what %hash{"exists", "does not exist" ; "exists", "does not exist"}:exists should return? (True, False, False) or (True, False, False, False)? I mean: once I found that the first level doesn't exists, should I return False and finish, or should I return 1 False for each key on the next levels?

[14:07] <Zoffix> Wouldn't that be (False, False)?

[14:07] <Zoffix> m: my %h = a => { c => 42 }; b => { c => 42 }; dd %h{"a", "b"; "b", "b"}

[14:07] <camelia> rakudo-moar 42f34f: OUTPUT: «WARNINGS for <tmp>:␤Useless use of "b => { c => 42 }" in sink context (line 1)␤(Any, Any, Any, Any)␤»

[14:07] <Zoffix> m: my %h = a => { c => 42 }, b => { c => 42 }; dd %h{"a", "b"; "b", "b"}

[14:07] <camelia> rakudo-moar 42f34f: OUTPUT: «(Any, Any, Any, Any)␤»

[14:07] <Zoffix> Oh

[14:08] <Zoffix> I already forgot how these are parsed :)

[14:08] <Zoffix> m: my %h = a => { c => 42 }, b => { c => 42 }; dd %h{"a", "a"; "c", "c"}

[14:08] <camelia> rakudo-moar 42f34f: OUTPUT: «(42, 42, 42, 42)␤»

[14:08] <Zoffix> m: my %h = a => { c => 42 }, b => { c => 42 }; dd %h{"a", "a"; "c", "b"}

[14:08] <camelia> rakudo-moar 42f34f: OUTPUT: «(42, Any, 42, Any)␤»

[14:08] <Zoffix> m: my %h = a => { c => 42 }, b => { c => 42 }; dd %h{"a", "a"; "b", "b"}

[14:08] <camelia> rakudo-moar 42f34f: OUTPUT: «(Any, Any, Any, Any)␤»

[14:08] <Zoffix> Oh, ok.

[14:09] <Zoffix> SmokeMachine: so I'd think it'd be (False, False, False, False)

[14:09] <SmokeMachine> iy would try: %a{"exists", "exists"}, %a{"exists", "do not exists"}, %a{"do notexists", "exists"}, %a{"do not exists", "do not exists"}

[14:09] <SmokeMachine> s/,/;/g

[14:09] <Zoffix> Basically mirror the output of normal lookup.

[14:09] <Zoffix> m: my %h = 42 ZR=> <a b c d e>; dd %h<a b c z>:exists

[14:09] <camelia> rakudo-moar 42f34f: OUTPUT: «(Bool::True, Bool::False, Bool::False, Bool::False)␤»

[14:10] <Zoffix> huh

[14:10] <Zoffix> m: my %h = 42 ZR=> <a b c d e>; dd %h<a b c z>

[14:10] <camelia> rakudo-moar 42f34f: OUTPUT: «(42, Any, Any, Any)␤»

[14:10] <Zoffix> m: my %h = 42 XR=> <a b c d e>; dd %h<a b c z>:exists

[14:10] <camelia> rakudo-moar 42f34f: OUTPUT: «(Bool::True, Bool::True, Bool::True, Bool::False)␤»

[14:10] <Zoffix> Right

[14:14] <lizmat> Zoffix: Wendy and I were at a Meet & Greet with Jon Anderson, Rick Wakeman and Trevor Rubin.  We each gave them a Camelia.  Trevor apparently put his on his monitor.  The rest is history

[14:14] <timotimo> cool

[14:14] <lizmat> Zoffix: it's a public picture, you can tweet it  :)

[14:14] <SmokeMachine> Zoffix: another thing is this:

[14:14] <lizmat> Rabin

[14:14] <lizmat> argh

[14:15] * lizmat is not awake yet

[14:15] <SmokeMachine> m: my %a{List} = (1, 2) => 42; my $l = List.new: 1,2; say %a{$l} # should it work?

[14:15] <camelia> rakudo-moar 42f34f: OUTPUT: «(Any)␤»

[14:17] <Zoffix> m: my $l = (1, 2); my %a{List} = $l => 42; say %a{$l}

[14:17] <camelia> rakudo-moar 42f34f: OUTPUT: «42␤»

[14:19] <Zoffix> m: my %a{List} = (1, 2) => 42; my $l = (1, 2); dd %a.keys[0].WHICH; dd $l.WHICH

[14:19] <camelia> rakudo-moar 42f34f: OUTPUT: «ObjAt.new("List|69236784")␤ObjAt.new("List|69237696")␤»

[14:19] <Zoffix> SmokeMachine: don't think so, 'cause it uses .WHICH doesn't it?

[14:19] <Zoffix> And when it is the same object, the lookup works fine.

[14:19] <lizmat> SmokeMachine: it should mirror the datastructure returned without :exists

[14:20] <lizmat> is what I think  :-)

[14:20] <Zoffix> m: my %a{List} = [1, 2] => 42; my $l = [1, 2]; say %a{$l}

[14:20] <camelia> rakudo-moar 42f34f: OUTPUT: «(Any)␤»

[14:20] <Zoffix> m: my $l = [1, 2]; my %a{List} = $l => 42; say %a{$l}

[14:20] <camelia> rakudo-moar 42f34f: OUTPUT: «42␤»

[14:21] <SmokeMachine> m: my $l = [1, 2]; my %a{List} = $l => 42; say %a{1;2}

[14:21] <camelia> rakudo-moar 42f34f: OUTPUT: «Type check failed in binding to 'key'; expected List but got Int (1)␤  in block <unit> at <tmp> line 1␤␤»

[14:21] <lizmat> afk again&

[14:31] <Zoffix> awww dammit

[14:31] <Zoffix> my awesomely twittable example is hitting a bug

[14:31] <Zoffix> Or is it...

[14:31] <Zoffix> m: https://gist.github.com/zoffixznet/0823179cea9508b1ba07baa08a1ca914

[14:31] <camelia> rakudo-moar 42f34f: OUTPUT: «[["Make", "R::I::SET_LINE_ENDING_ON_HANDLE", "4.1x", "Faster"], Mu, Mu]␤[["Make", "IO::Spec::Unix.catdir", "3.9x", "Faster"], Mu, Mu]␤[["Make", "IO::Spec::Unix.split", "36x", "Faster"], Mu, Mu]␤[["Make", "IO::Spec::Unix.rel2abs", "35\%", "faster"],…»

[14:32] <Zoffix> Why are those Mus there? Why are $type and $speedup aren't set?

[14:32] <Zoffix> Making them with:     my ($sha, $, $, *@rest ($, $type, $speedup, $)) := \ |.words;

[14:33] <Zoffix> Works fine if I make it a sub's signature, so I guess it is indeed a bug :(

[14:34] <Zoffix> m: sub ($sha, $, $, *@rest ($, $type, $speedup, $)) {dd [ @rest, $type, $speedup ];}(|'fa9aa47 [io grant] Make R::I::SET_LINE_ENDING_ON_HANDLE 4.1x Faster'.words)

[14:34] <camelia> rakudo-moar 42f34f: OUTPUT: «[["Make", "R::I::SET_LINE_ENDING_ON_HANDLE", "4.1x", "Faster"], "R::I::SET_LINE_ENDING_ON_HANDLE", "4.1x"]␤»

[14:34] <Zoffix> m: my ($sha, $, $, *@rest ($, $type, $speedup, $)) := \ |'fa9aa47 [io grant] Make R::I::SET_LINE_ENDING_ON_HANDLE 4.1x Faster'.words; dd [ @rest, $type, $speedup ];

[14:34] <camelia> rakudo-moar 42f34f: OUTPUT: «[["Make", "R::I::SET_LINE_ENDING_ON_HANDLE", "4.1x", "Faster"], Mu, Mu]␤»

[14:38] <Zoffix> Rakudobugged: https://rt.perl.org/Ticket/Display.html?id=131071

[14:51] <Zoffix> And another issue is hitting another example :/

[14:51] <Zoffix> Perl 6 isn't lovin' me today

[14:52] <Zoffix> m: my %h .= push: a => 42, a => 72; dd %h;

[14:52] <camelia> rakudo-moar 42f34f: OUTPUT: «Hash %h = {}␤»

[14:53] <Zoffix> why is it empty?

[14:53] <Zoffix> m: my %h; %h .= push: a => 42, a => 72; dd %h;

[14:53] <camelia> rakudo-moar 42f34f: OUTPUT: «Hash %h = {}␤»

[14:53] <Zoffix> m: my %h; %h .= push: $_ for a => 42, a => 72; dd %h;

[14:53] <camelia> rakudo-moar 42f34f: OUTPUT: «Hash %h = {:a($[42, 72])}␤»

[14:56] <Zoffix> Ah

[14:56] <Zoffix> m: my %h .= append: "a" => 42, "a" => 72; dd %h;

[14:56] <camelia> rakudo-moar 42f34f: OUTPUT: «Hash %h = {:a($[42, 72])}␤»

[14:57] <Zoffix> But still doesn't work in this form

[14:57] <Zoffix> m: https://gist.github.com/zoffixznet/92d0cf7abcb5e877486ab08f699dd91b

[14:57] <camelia> rakudo-moar 42f34f: OUTPUT: «Hash %h = {:Bar($["1.2", "4.2", "10.2"]), :Foo($["4.1", "1.3"]), :Meow("1.3")}␤»

[14:57] <Zoffix> ...

[14:57] <Zoffix> I guess my perl6 is too old

[14:58] <Zoffix> And I bet it's lizmat++'s fix to the %h = %h, %blah that fixed it

[15:00] <Zoffix> And I can't tweet this example either 'cause the fix is in 2017.03 but everyone's on 2017.01 Rakudo Star :P

[15:00] <Zoffix> Unlucky day for me

[15:00] * Zoffix tweets it anyway

[15:27] <Zoffix> u: ⍨

[15:27] <unicodable6> Zoffix, U+2368 APL FUNCTIONAL SYMBOL TILDE DIAERESIS [So] (⍨)

[15:27] <Zoffix> That gotta be made into an op :P

[15:28] <[Coke]> I vote we call it "the moustache"

[15:30] <Zoffix> I'm working on my March grant report ATM. Will publish it in ~4 hours

[15:37] <Zoffix> [Coke]: how do you publish it on TPF's site? Do you just scrape the HTML page? 'cause I got all of these reports in Markdown format, if that makes things easier

[15:37] <[Coke]> hokay.

[15:37] <[Coke]> I just scrape the HTML. I am not sure if I can use the markdown, but I'm happy to try

[15:38] <Zoffix> OK

[16:03] <dogbert17> .tell AlexDaniel if possible could you add https://gist.github.com/dogbert17/3eb15ea55019d93590e8ea1d4966f7b2 to RT #131003

[16:03] <synopsebot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=131003

[16:03] <yoleaux2> dogbert17: I'll pass your message to AlexDaniel.

[16:25] <nine> .oO(Will UNIX conventions still be in use in 100 years?)

[16:25] * nine read a bit of the backlog

[16:27] <Zoffix> Perl 6 IO TPF Grant: Monthly Report (March, 2017): http://blogs.perl.org/users/zoffix_znet/2017/03/perl-6-io-tpf-grant-monthly-report-march-2017.html

[16:34] <[Coke]> Zoffix++

[17:01] <Zoffix> .oO( s/Seqqy/Sequential/ )

[17:03] <TimToady> .oO( class HyperSeq does Things )

[17:03] <Zoffix> This reminds me what I wanted to ask TimToady

[17:04] <timotimo> my $dog will WORK(:4food)

[17:04] * TimToady sips coffee and hopes it will help

[17:04] <timotimo> Zoffix: report looks good! i haven't read the previous one, though :(

[17:04] <Zoffix> m: Seq.new: class :: does Iterator { method pull-one {}; method sink-all { say "sank" } }.new

[17:04] <camelia> rakudo-moar 42f34f: OUTPUT: «sank␤»

[17:04] <Zoffix> m: my $x = Seq.new: class :: does Iterator { method pull-one {}; method sink-all { say "sank" } }.new; $x

[17:04] <camelia> rakudo-moar 42f34f: OUTPUT: «WARNINGS for <tmp>:␤Useless use of $x in sink context (line 1)␤»

[17:04] <Zoffix> m: my $x = Seq.new: class :: does Iterator { method pull-one {}; method sink-all { say "sank" } }.new; sink $x

[17:04] <camelia> rakudo-moar 42f34f: OUTPUT: «WARNINGS for <tmp>:␤Useless use of $x in sink context (line 1)␤sank␤»

[17:05] <Zoffix> m: my $x = Seq.new: class :: does Iterator { method pull-one {}; method sink-all { say "sank" } }.new; $x.sink

[17:05] <camelia> rakudo-moar 42f34f: OUTPUT: «sank␤»

[17:05] <jnthn> Well, as previously mentioned, Sequential isn't the best name for something that might work in parallel and produces results out of sequence. :-)

[17:05] * TimToady suggested Batchable earlier, if you consider Seq to be a single batch

[17:05] <jnthn> Hmm

[17:06] <jnthn> I wonder whether HyperSeq and RaceSeq should even have Seq in their name also :)

[17:06] <Zoffix> TimToady: ^ is that by design that a class in a variable doesn't get sunk? Makes sink-all kinda not as useful. I first noticed that with IO::Handle's iterators where such a call on sinkage would cause the handle's closing....

[17:06] <TimToady> but I was semi-serious with "Things", in the sense of "ThingsToDoNotNecessarilyInOrder"

[17:06] <jnthn> haha...does Things :P

[17:07] <jnthn> But yeah, it kinda works I guess :)

[17:07] <jnthn> It's better than Seqqy :P

[17:07] <TimToady> does WorkPolicy maybe

[17:07] <Zoffix> jnthn: in that case clearly the name should be uenSeqtial

[17:08] <TimToady> does Consequential :)

[17:08] <Zoffix> "Seque: A Programming Language for Manipulating Sequences"

[17:08] <Zoffix> From http://www.dictionary.com/browse/seque

[17:09] <TimToady> maybe they should be named Don'tCheat, CheatButGetAwayWithIt, CheatAndDon'tCare

[17:11] <TimToady> .oO(Cordia, Concordia, Discordia)

[17:13] * Zoffix is done skimming through https://gist.github.com/jnthn/6a80a9712fb38b32537f9f0e46fca6d7

[17:13] <Zoffix> Over my head :) I think poor name suggestions is all I got :)

[17:16] <perlpilot> Zoffix++ (just read your report)

[17:17] <TimToady> .oO( class HyperSeq does WhatNow )

[17:18] <TimToady> .oO( class HyperSeq does HowNow )

[17:18] <TimToady> .oO( class BrownCow does HowNow )

[17:18] * TimToady should be forbidden from free-association this early in the day...

[17:21] <TimToady> .oO(we could redefine "Parallax" to mean how far you relax things in the parallel direction...)

[17:21] <Zoffix> :o

[17:22] <TimToady> .oO(and justify it because it tells you how far away the other end of the work is :)

[17:23] * TimToady goes back to backlogging hoping his brane follows along after

[17:28] * TimToady 's brane is still far too gleeful about the antisociality of bending yet another existing word into a perletzel

[17:46] <TimToady> Zoffix: re https://irclog.perlgeek.de/perl6-dev/2017-03-26#i_14324664 I would say that callwith/nextwith work like 'next' in the middle of a loop (the dispatcher's loop, as it were, so continues the current dispatch cascade), while samewith is a complete redispatch, more like restarting the entire loop with different arguments, as I understand it

[17:49] <TimToady> m: multi fact(0) { 1 }; multi fact($n) { $n * samewith $n - 1 }; say fact(42)

[17:49] <camelia> rakudo-moar 42f34f: OUTPUT: «1405006117752879898543142606244511569936384000000000␤»

[17:49] <TimToady> m: multi fact(0) { 1 }; multi fact($n) { $n * callwith $n - 1 }; say fact(42)

[17:49] <camelia> rakudo-moar 42f34f: OUTPUT: «Use of Nil in numeric context␤  in sub fact at <tmp> line 1␤0␤»

[17:49] <TimToady> samewith gets back to the 0 case successfully due to the redispatch

[17:50] <TimToady> callwith/nextwith cannot get back to the 0 case because it's already been rejected in the current dispatch

[17:51] <Zoffix> Then what's the difference between callwith/nextwith?

[17:51] <TimToady> nextwith doesn't come back to this function, like a tail call

[17:52] <Zoffix> oh

[17:52] <TimToady> makes no difference here, since it's the last statement

[17:52] <jnthn> nextwith is like return callwith

[17:52] <TimToady> but hopefully optimized

[17:52] <Zoffix> I'm now confused about which ones I was confused about :)

[17:54] <TimToady> m: multi fact(0) { 1 }; multi fact($n) { samewith($n - 1) * $n }; say fact(42)

[17:54] <camelia> rakudo-moar 42f34f: OUTPUT: «1405006117752879898543142606244511569936384000000000␤»

[17:54] <TimToady> samewith is not a tail call, but could be considered a strong hint to do TCO if it's last

[17:55] <TimToady> nextwith is a forced tail call, but only of the rest of the current dispatch

[17:55] <TimToady> we don't really have a way to force a tail-call redispatch yet

[17:55] <Zoffix> [callwith] with new args, call from scratch and return here;

[17:55] <Zoffix> [callsame] with same args, call from scratch and return here;

[17:55] <Zoffix> [samewith] with new args, use the same dispatch chain to make a call and return here;

[17:56] <Zoffix> [nextwith] with new args, use the same dispatch chain to make a call and don't return here;

[17:56] <Zoffix> [nextsame] with same args, use the same dispatch chain to make a call and don't return here;

[17:56] <Zoffix> I think I got it :)

[17:56] <TimToady> uh no

[17:56] <Zoffix> bah :D

[17:56] <TimToady> call* reuse the current dispatch chain

[17:57] <TimToady> samewith creates a new dispatch chain

[17:57] <TimToady> "reuse" in the sense of using the rest of the current chain, not in the sense of a restart

[17:58] <TimToady> or equivalently, samewith can reuse the current chain but only by starting again from the front, which is probably what really happens

[17:58] <TimToady> but I think of it as a fresh dispatch

[17:59] <TimToady> call* and next* can only complete the current dispatch

[17:59] <Zoffix> OK, after playing with some code I think I got it.

[17:59] <Zoffix> I need to write a blog post about it :)

[18:02] <Geth> ¦ rakudo/nom: 19eeddbf35 | (Elizabeth Mattijsen)++ | t/spectest.data

[18:02] <Geth> ¦ rakudo/nom: Mark integration/eval-and-threads.t as slow

[18:02] <Geth> ¦ rakudo/nom:

[18:02] <Geth> ¦ rakudo/nom: So it won't affect the total wallclock time as much as it did before.

[18:02] <Geth> ¦ rakudo/nom: review: https://github.com/rakudo/rakudo/commit/19eeddbf35

[18:04] <Zoffix> m: foo (Any [$x]) {dd $x}([42])

[18:04] <camelia> rakudo-moar 42f34f: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Missing infix inside []␤at <tmp>:1␤------> 3foo (Any [7⏏5$x]) {dd $x}([42])␤    expecting any of:␤        bracketed infix␤        infix␤        infix stopper␤»

[18:04] <Zoffix> It complains about the sig, right?

[18:04] <Zoffix> m: multi foo (Int $x) { say "Int [$x]"; foo Any }; multi foo(Cool $x) { say "Cool [$x]"; nextsame; say "were back!" }; multi foo(Any [$x]) { say "Any [$x]" }; foo "x"

[18:04] <camelia> rakudo-moar 42f34f: OUTPUT: «Cool [x]␤»

[18:04] <Zoffix> But not in this case...

[18:07] <TimToady> your first one was just a syntax error, missing 'sub'

[18:09] <Zoffix> Ah. OK. Thanks.

[18:09] <TimToady> m: sub foo (Any [$x]) {dd $x}([42])

[18:09] <camelia> rakudo-moar 42f34f: OUTPUT: «Int $x = 42␤»

[18:09] <Zoffix> Now I got it: *with = use these new args;  *same = just use the same args;  call* = call next candidate and return;   next* = call next candidate and don't return;   same* = restart from scratch

[18:09] <Zoffix> We're clearly missing samesame :)

[18:10] <TimToady> yes, we clearly are :P

[18:10] <TimToady> loop {} works better for that though

[18:11] <[Coke]> there's more than same way to same it.

[18:11] <TimToady> same old, same new...

[18:15] <TimToady> lizmat: re https://irclog.perlgeek.de/perl6-dev/2017-03-26#i_14325105 but then what about phasers that might return their value, or might also just be used for a side effect?

[18:15] <TimToady> m: say { 42; ENTER say "bye" }()

[18:15] <camelia> rakudo-moar 19eedd: OUTPUT: «WARNINGS for <tmp>:␤Useless use of constant integer 42 in sink context (line 1)␤bye␤True␤»

[18:15] <TimToady> m: say { 42; ENTER "bye" }()

[18:15] <camelia> rakudo-moar 19eedd: OUTPUT: «WARNINGS for <tmp>:␤Useless use of constant string "bye" in sink context (line 1)␤Useless use of constant integer 42 in sink context (line 1)␤bye␤»

[18:16] <TimToady> huh, I guess that's a useless use of useless use, at least for "bye"

[18:17] * TimToady found hisself a buggy!

[18:18] <TimToady> m: say { INIT "bye" }()

[18:18] <camelia> rakudo-moar 19eedd: OUTPUT: «WARNINGS for <tmp>:␤Useless use of constant string "bye" in sink context (line 1)␤bye␤»

[18:19] <TimToady> m: say { BEGIN "And yet I live!" }()

[18:19] <camelia> rakudo-moar 19eedd: OUTPUT: «And yet I live!␤»

[18:19] <TimToady> m: say { CHECK "And yet I live!" }()

[18:19] <camelia> rakudo-moar 19eedd: OUTPUT: «And yet I live!␤»

[18:19] <TimToady> m: say { INIT "And yet I live!" }()

[18:19] <camelia> rakudo-moar 19eedd: OUTPUT: «WARNINGS for <tmp>:␤Useless use of constant string "And yet I live!" in sink context (line 1)␤And yet I live!␤»

[18:19] <TimToady> curious

[18:20] <TimToady> m: say { INIT now }()

[18:20] <camelia> rakudo-moar 19eedd: OUTPUT: «Instant:1490725251.568083␤»

[18:20] <TimToady> I guess we'd've discovered this bug earlier if we carped about 'now' in sink context

[18:21] <TimToady> m: now; now; now;

[18:21] <camelia> rakudo-moar 19eedd: ( no output )

[18:21] <TimToady> m: pi; pi; pi;

[18:21] <camelia> rakudo-moar 19eedd: OUTPUT: «WARNINGS for <tmp>:␤Useless use of constant value pi in sink context (lines 1, 1, 1)␤»

[18:21] <Zoffix> m: rand; rand; rand;

[18:21] <camelia> rakudo-moar 19eedd: ( no output )

[18:21] <TimToady> well, obviously 'now' updates the clock, just as 'rand' updates the RNG :P

[18:23] <TimToady> if nobody ever asked "What time is it?", time would just quit...

[18:25] * TimToady wonders if someone can construct such a clock from trees falling in the forest that no one hears...

[18:27] <Zoffix> Yes, but no one would hear when its alarm goes off...

[18:33] <lizmat> m: my $a; { $a = LEAVE 42 }; say $a   # TimToady: clearly, not all phasers are created equal

[18:33] <camelia> rakudo-moar 19eedd: OUTPUT: «WARNINGS for <tmp>:␤Useless use of constant integer 42 in sink context (line 1)␤(Any)␤»

[18:34] <lizmat> m: my $a; { $a = ENTER 42 }; say $a

[18:34] <camelia> rakudo-moar 19eedd: OUTPUT: «WARNINGS for <tmp>:␤Useless use of constant integer 42 in sink context (line 1)␤42␤»

[18:34] <TimToady> m: my $a; { $a := LEAVE 42 }; say $a

[18:34] <camelia> rakudo-moar 19eedd: OUTPUT: «WARNINGS for <tmp>:␤Useless use of constant integer 42 in sink context (line 1)␤Nil␤»

[18:35] <TimToady> but yes, clearly some phasers are better at time travel than others :)

[18:36] <lizmat> m: my $a; for ^1 { $a = FIRST 42 }; say $a   # indeed

[18:36] <camelia> rakudo-moar 19eedd: OUTPUT: «WARNINGS for <tmp>:␤Useless use of constant integer 42 in sink context (line 1)␤(Any)␤»

[18:39] <TimToady> that one just looks like a bug to me, assuming FIRST is an ENTERoid

[18:39] <TimToady> m: for ^1 { say "HERE"; FIRST say "THERE" }

[18:39] <camelia> rakudo-moar 19eedd: OUTPUT: «THERE␤HERE␤»

[18:39] <TimToady> which it is

[18:40] <lizmat> back to schlepping&

[19:01] <Zoffix> Hm. Quitting drinking has sure dulled my writing skills...

[19:01] <Zoffix> I guess I can find solace in my sharpened programming skills...

[19:20] <samcv> hello everyone

[19:20] <Zoffix> \o

[19:27] <Zoffix> m: multi foo (Int  $x) { say "Int  [$x]"; $x.flip }; multi foo (Cool $x) { say "Cool [$x]"; my $v = callwith Mu; say "We're back! The return value is $v"; $x.flip }; multi foo (Any  $x) { say "Any  [$x]"; $x.flip }; foo "I ♥ Perl 6!";

[19:27] <camelia> rakudo-moar 19eedd: OUTPUT: «Cool [I ♥ Perl 6!]␤Type check failed in binding to '$x'; expected Any but got Mu (Mu)␤  in sub foo at <tmp> line 1␤  in sub foo at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[19:27] <Zoffix> Is it a bug that it crashes?

[19:28] <timotimo> there's no candidate that would accept Mu, why would you expect callwith Mu to give anything but an exception?

[19:30] <Zoffix> m: multi foo (Int  $x) { say "Int  [$x]"; $x.flip }; multi foo (Cool $x) { say "Cool [$x]"; my $v = callwith Mu; say "We're back! The return value is $v"; $x.flip }; multi foo (Date  $x) { say "Any  [$x]"; $x.flip }; foo "I ♥ Perl 6!";

[19:30] <camelia> rakudo-moar 19eedd: OUTPUT: «Cool [I ♥ Perl 6!]␤Use of uninitialized value $v of type Any in string context.␤Methods .^name, .perl, .gist, or .say can be used to stringify it to something meaningful.␤  in sub foo at <tmp> line 1␤We're back! The return value is ␤»

[19:30] <jnthn> If you use callwith, it's on you to ensure that the argument types are acceptable

[19:30] <Zoffix> But there's no ^ candidate there now and it doesn't crash.

[19:30] <jnthn> Sure, then there's isn't a candidate

[19:31] <jnthn> So there's nothing to fail to bind

[19:31] <Zoffix> So it just tries the *next* next not the next matching?

[19:31] <jnthn> Yes

[19:31] <Zoffix> Oh

[19:31] <jnthn> You are iterating a predestined (based on original arguments) set of candidates

[19:31] <jnthn> callwith and nextwith don't cause that candidate set to be reevaluated.

[19:32] <TimToady> (that's what samewith is for)

[19:32] <jnthn> Indeed.

[19:33] <TimToady> nextwith is useful only when you know you have a more generic candidate later in the list

[19:33] <jnthn> Heh, probably "predetermined" woulda been a better word :)

[19:34] <TimToady> I often have determination to get to my destination.

[19:36] <Zoffix> m: class A is Int {}; class B is A {}; multi foo (A) { say "A"; nextsame }; multi foo (B) { say "B"; }; multi foo (Int) { say "Int" };  foo A;

[19:36] <camelia> rakudo-moar 19eedd: OUTPUT: «A␤Int␤»

[19:36] <Zoffix> How come that didn't go to "B"? :/

[19:37] <jnthn> Because B is narrower than A

[19:37] <Zoffix> Oh doh

[19:38] <Zoffix> m: multi foo (IntStr) { say "IntStr"; nextwith "x" }; multi foo (Int) { say "Int"; }; multi foo (Cool) { say "Cool" };  foo <42>;

[19:38] <camelia> rakudo-moar 19eedd: OUTPUT: «IntStr␤Type check failed in binding to '<anon>'; expected Int but got Str ("x")␤  in sub foo at <tmp> line 1␤  in sub foo at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[19:38] <Zoffix> OK. Now I get it :D

[19:38] <Zoffix> jnthn++ thanks

[19:41] <samcv> Zoffix, do you find HARNESS6 faster than harness5?

[19:41] <samcv> i have not timed them. but am curious

[19:46] <Zoffix> samcv: nope

[19:48] <Zoffix> Don't see my timings for HARNESS6 in the logs, but it's a lot slower and seems to be missing some tests.

[19:48] <Zoffix> I think it's like 300-400 seconds for the stresstest, while the stresstest on harness5 runs in ~120 seconds

[19:49] <Zoffix> That's on 24-core box with the rakudo's max threads var bumped to something higher than normal.

[19:53] <samcv> what's the normal max thread var?

[19:56] <jnthn> Bumping Rakudo's max threads higher will probably only hurt performance for stresstest6

[19:56] <jnthn> samcv: It defaults to 16

[19:56] <jnthn> Thing is, the thread scheduler is none too smart so will quickly end up with the maximum number of threads

[19:57] <jnthn> But harness6 doesn't really need that many

[19:57] <jnthn> Even if your TEST_JOBS is far higher

[19:58] <timotimo> i have here a test in the spec tests that has been eating a full cpu core for many minutes now

[19:59] <timotimo> t/spec/S19-command-line/repl.rakudo.moar  (Wstat: 256 Tests: 13 Failed: 1)

[19:59] <timotimo> Failed tests:  10

[19:59] <timotimo> TODO passed:  7

[20:06] <Zoffix> jnthn: doesn't TESTJOBS affect how many tests it runs at the same time? So if max threads is 16 and your TESTJOBS is 30, how can it do all of them?

[20:07] <Zoffix> timotimo, does that test hang normally? I noticed Proc::Async.kill that doesn't-hang uses sometimes doesn't kill

[20:08] <timotimo> yeah, when i run it i get a test failure and then it hangs

[20:08] <timotimo> ok 9 - variables persist across multiple lines of input  - its subtest "stdout is correct" fails, the "stderr is correct" succeeds, and then it hangs

[20:08] <timotimo> when run without a harness, that is

[20:09] <Zoffix> I'll take a look in ~1hr

[20:10] <[Coke]> multi-threaded tests don't play nice with a high TEST_JOBS, right.

[20:10] <jnthn> Zoffix: It uses Proc::Async, so it's non-blocking

[20:11] <jnthn> Zoffix: Tests are run as subproccesses

[20:11] <Zoffix> Ah. OK.

[20:11] <jnthn> Zoffix: So one thread in the harness can service a bunch of running spectests

[20:11] <Zoffix> cool

[20:11] * jnthn bbl

[20:12] <Geth> ¦ rakudo/nom: 27f546907a | TimToady++ | src/Perl6/Actions.nqp

[20:12] <Geth> ¦ rakudo/nom: suppress useless use on INIT/ENTER/FIRST

[20:12] <Geth> ¦ rakudo/nom:

[20:12] <Geth> ¦ rakudo/nom: Would be nice to determine this in 2nd pass, but for now, it's

[20:12] <Geth> ¦ rakudo/nom: better to allow false negatives than false positives.

[20:12] <Geth> ¦ rakudo/nom: review: https://github.com/rakudo/rakudo/commit/27f546907a

[20:12] <Geth> ¦ rakudo/nom: 41ac4b4a3d | TimToady++ | src/Perl6/Actions.nqp

[20:12] <Geth> ¦ rakudo/nom: Catch useless use of 'now' now, now...

[20:12] <Geth> ¦ rakudo/nom: review: https://github.com/rakudo/rakudo/commit/41ac4b4a3d

[20:34] <Zoffix> timotimo: does it hand when you type the code manually in repl? It runs string "my \$x = 42;\nsay qq/The value is \$x/;\n",

[20:34] <Zoffix> remove backslashes and \n s are separate lines

[20:35] <Zoffix> Well, I lied. I'm too tired to look at it today, so maybe fudge it for now?

[20:36] <timotimo> doesn't hang

[20:36] * Zoffix is off for rest of night

[20:37] <timotimo> gnite Zoffix :)
