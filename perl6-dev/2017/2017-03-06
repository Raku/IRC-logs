[02:22] <MasterDuke> IOninja: message for you in #moarvm

[04:36] <samcv> MasterDuke, gonna fix that right now

[04:36] <samcv> getstrfromname in parse-names

[04:43] <MasterDuke> samcv++

[04:46] <samcv> MasterDuke, for bonus points we can implement the op in java https://gist.github.com/samcv/f385f19111df9ad282472a6d3610fc6f

[04:46] <samcv> there is already some groundwork done on that. mostly just look at the comment. the gist itself was just to show arnsholt what the function in perl 6 would be written as

[04:47] <samcv> might take a look at that tonight if i have time

[04:47] <samcv> though i've never addad java ops before, only minor edits to other parts

[04:48] <MasterDuke> i've never done it either, good luck! but i'm off to sleep now, later...

[04:50] <Geth> ¦ rakudo/nom: b1444c8a1b | (Samantha McVey)++ | src/core/Str.pm

[04:50] <Geth> ¦ rakudo/nom: get JVM compiling again. parse-names workaround

[04:50] <Geth> ¦ rakudo/nom:

[04:50] <Geth> ¦ rakudo/nom: JVM does not have getstrfromname, so we call chr and codepointfromname

[04:50] <Geth> ¦ rakudo/nom: instead.

[04:50] <Geth> ¦ rakudo/nom: review: https://github.com/rakudo/rakudo/commit/b1444c8a1b

[05:48] <Geth> ¦ nqp: 358931c824 | (Samantha McVey)++ | 2 files

[05:48] <Geth> ¦ nqp: Implement getstrfromname on JVM

[05:48] <Geth> ¦ nqp: review: https://github.com/perl6/nqp/commit/358931c824

[07:08] <[Tux]> This is Rakudo version 2017.02-178-gb1444c8a1 built on MoarVM version 2017.02-20-g773711e1

[07:08] <[Tux]> csv-ip5xs        2.755

[07:08] <[Tux]> test            12.830

[07:08] <[Tux]> test-t           5.029 - 5.121

[07:08] <[Tux]> csv-parser      13.065

[07:38] <samcv> should be able to remove the #?if on jvm that uses nqp::codepointfromname to use getstrfromname. hope you have been well [Tux]

[07:38] <[Tux]> I have. I think :)

[07:38] <samcv> thinking is half the battle

[10:19] <Geth> ¦ nqp: 37543adf73 | (Bart Wiegmans)++ | t/moar/51-jit-div_i.t

[10:19] <Geth> ¦ nqp: Add testcase for div_i in JIT

[10:19] <Geth> ¦ nqp:

[10:19] <Geth> ¦ nqp: Apparently has a negative number bug

[10:19] <Geth> ¦ nqp: review: https://github.com/perl6/nqp/commit/37543adf73

[10:22] <travis-ci> NQP build failed. Bart Wiegmans 'Add testcase for div_i in JIT

[10:22] <travis-ci> https://travis-ci.org/perl6/nqp/builds/208143370 https://github.com/perl6/nqp/compare/358931c82495...37543adf7333

[10:22] <timotimo> t/moar/51-jit-div_i.t .................. Failed 1/1 subtests  -  oh no, that's an unexpected result of adding that test!

[10:45] <IOninja> lol, that's only cause the test is wrong

[10:46] <IOninja> m: say -1 / 10

[10:46] <camelia> rakudo-moar b1444c: OUTPUT: «-0.1␤»

[10:46] <dogbert17_> RT #130925 looks like a blocker :)

[10:46] <synopsebot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=130925

[10:46] <IOninja> and it moves it down to -1

[10:47] <timotimo> m: say -1 div 10

[10:47] <camelia> rakudo-moar b1444c: OUTPUT: «-1␤»

[10:47] <jnthn> dogbert17_: Think it evaded the spam blocker...

[10:47] * jnthn marks it as spam

[10:47] <IOninja> too late

[10:48] <dogbert17_> that was fast :)

[10:51] <jnthn> If only all bugs just needed clicking an S to fix! :)

[10:51] <IOninja> timotimo: oh, sorry... Just woke up. I do see it now it tests for != -1 as as a failure mode

[10:52] <IOninja> m: use nqp; for ^100_000 { my $y = nqp::div_i(-1, 10); die "$_" if $y != -1 }

[10:52] <camelia> rakudo-moar b1444c: OUTPUT: «207␤  in block <unit> at <tmp> line 1␤␤»

[10:52] <IOninja> It's same bug that MasterDuke exposed when changing something to div_i innit?

[10:53] <timotimo> looks just like

[11:15] <samcv> how do you guys generate those nqp bump logs

[11:15] <samcv> i want the fancy too

[11:17] <IOninja> git log --oneline 2017.02-gwhatever HEAD

[11:17] <IOninja> where the whatever is the current version used

[11:17] <samcv> nice

[11:18] <timotimo> you don't need to put a .. there?

[11:19] <IOninja> oh maybe

[11:19] <IOninja> could be ... too

[11:19] <lizmat> moritz IOninja: http://www.0racle.info/articles/matplotlib_in_p6_intro   # tweetable ?

[11:20] <IOninja> twetted (from my account; don't have access to the P6Feed one)

[11:21] <samcv> IOninja, that didn't work

[11:22] <samcv> I did `git log --oneline 2017.02-39-g2780ed7` and the list contains hundreds of commits instead of just between

[11:22] <samcv> oh oops

[11:23] <samcv> maybe have to have `git log --oneline HEAD 2017.02-39-g2780ed7`?

[11:25] <moritz> IOninja: do you want access to the perl6org account?

[11:26] <moritz> anyway, retweeted for now

[11:26] <moritz> twitter helpfully offers to "Translate from Swedish" :-)

[11:28] <IOninja> moritz: not really :)

[11:28] <IOninja> My own account is plenty distractive :)

[11:29] <samcv> oh it needs a `..` that's what you guys were meaning by that :) would have been nice if git log -h was more informative

[11:30] <IOninja> git log --oneline 2017.02-39-g2780ed7...HEAD   will probably work

[11:32] <samcv> yeah that does work

[11:33] <DrForr> I got Polish with one of my remarks.

[11:34] <timotimo> oops?

[11:35] <DrForr> "Yep. jgoff!bvc!{uiowa,grinnell}!edu" # Translate from Polish

[11:35] <Geth> ¦ rakudo/nom: 2125d4d304 | (Samantha McVey)++ | 2 files

[11:35] <Geth> ¦ rakudo/nom: Have Emoji_Modifier_Base return Bool instead of int with uniprop

[11:35] <Geth> ¦ rakudo/nom: review: https://github.com/rakudo/rakudo/commit/2125d4d304

[11:35] <Geth> ¦ rakudo/nom: version bump brought these changes: https://github.com/perl6/nqp/compare/2017.02-39-g2780ed7...2017.02-58-g37543adf

[11:35] <Geth> ¦ rakudo/nom: dc198924ff | (Samantha McVey)++ | tools/build/NQP_REVISION

[11:35] <Geth> ¦ rakudo/nom: Bump NQP to get nqp::getstrfromname on JVM and changes since

[11:35] <Geth> ¦ rakudo/nom:

[11:36] <Geth> ¦ rakudo/nom: Changes pulled in:

[11:36] <Geth> ¦ rakudo/nom: 37543adf Add testcase for div_i in JIT

[11:36] <Geth> ¦ rakudo/nom: 358931c8 Implement getstrfromname on JVM

[11:36] <Geth> ¦ rakudo/nom: f749428e [js] Remove rest of our bitrotted CPS coroutine implementation.

[11:36] <Geth> ¦ rakudo/nom: 028c91f8 [js] Remove ChunkCPS, a leftover from our bitrotted CPS transform style code emitting.

[11:36] <Geth> ¦ rakudo/nom: <…commit message has 15 more lines…>

[11:36] <Geth> ¦ rakudo/nom: review: https://github.com/rakudo/rakudo/commit/dc198924ff

[11:36] <Geth> ¦ rakudo/nom: version bump brought these changes: https://github.com/perl6/nqp/compare/2017.02-39-g2780ed7...2017.02-58-g37543adf

[12:13] <Geth> ¦ rakudo/nom: 9da50e352f | (Elizabeth Mattijsen)++ | src/core/IO/Handle.pm

[12:13] <Geth> ¦ rakudo/nom: Introducing IO::Handle.iterator

[12:13] <Geth> ¦ rakudo/nom:

[12:13] <Geth> ¦ rakudo/nom: - makes IO::Handle.lines about 10% faster, specifically for larger files

[12:13] <Geth> ¦ rakudo/nom: - creates dedicated iterators for using IO::Handle internals if possible

[12:13] <Geth> ¦ rakudo/nom: - reverts back to old "get" method for subclasses

[12:13] <Geth> ¦ rakudo/nom: - dedicated sink-all will just close, or seek to end

[12:13] <Geth> ¦ rakudo/nom: review: https://github.com/rakudo/rakudo/commit/9da50e352f

[12:16] <MasterDuke> lizmat++ would the same thing work for IO::ArgFiles?

[12:16] <lizmat> probably, but I'm not touching IO::ArgFiles while IOninja is working in that area

[12:17] <lizmat> also: this sorta conflicts with IO::CatPath and IO::CatHandle

[12:17] <lizmat> I see IO::ArgFiles as a special case of IO::CatPath/CatHandle really

[12:18] <MasterDuke> ah, interesting

[12:28] <dogbert17_> m: my $foo = '42'; $foo.subst-mutate: /^'ba'/ # oldie

[12:28] <camelia> rakudo-moar dc1989: OUTPUT: «(timeout)»

[12:29] <dogbert17_> RT #127135 if anyone is interested

[12:29] <synopsebot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=127135

[12:32] <IOninja> s: '', 'subst-mutate', \()

[12:32] <SourceBaby> IOninja, Something's wrong: ␤ERR: Could not find candidate that can do \()␤  in sub sourcery at /home/zoffix/services/lib/CoreHackers-Sourcery/lib/CoreHackers/Sourcery.pm6 (CoreHackers::Sourcery) line 29␤  in block <unit> at -e line 6␤␤

[12:32] <IOninja> s: '', 'subst-mutate'

[12:32] <SourceBaby> IOninja, Sauce is at https://github.com/rakudo/rakudo/blob/9da50e3/src/core/Cool.pm#L193

[12:32] <IOninja> s: '', 'subst-mutate', \(/^/, '')

[12:32] <SourceBaby> IOninja, Something's wrong: ␤ERR: Could not find candidate that can do \(/^/, "")␤  in sub sourcery at /home/zoffix/services/lib/CoreHackers-Sourcery/lib/CoreHackers/Sourcery.pm6 (CoreHackers::Sourcery) line 29␤  in block <unit> at -e line 6␤␤

[12:34] <IOninja> dogbert17_: that's cause Cool candidate is a multi. Move proto to Str and make Cool candidate an only method: https://github.com/rakudo/rakudo/blob/9da50e3/src/core/Cool.pm#L193-L197

[12:34] <dogbert17_> IOninja: must be a regression

[12:35] <IOninja> mc: 42.subst-mutate <a>

[12:35] <committable6> IOninja, https://gist.github.com/7b7982694fd5218756fa6a1bcac091bd

[12:35] <IOninja> mc: 42.subst-mutate: <a>

[12:35] <committable6> IOninja, ¦2015.12: «Cannot call subst-mutate(Int: Str); none of these signatures match:␤    ($self is rw: |c is raw)␤  in block <unit> at /tmp/0nqYCt6GWb line 1␤ «exit code = 1»»

[12:36] <dogbert17_> I can look at it later today unless someone beats me to it :)

[12:43] <MasterDuke> m: my @f; @f[0,0].map({$_ += 1}); say @f

[12:43] <camelia> rakudo-moar 9da50e: OUTPUT: «[1]␤»

[12:43] <MasterDuke> m: my @f = 0; @f[0,0].map({$_ += 1}); say @f

[12:43] <camelia> rakudo-moar 9da50e: OUTPUT: «[2]␤»

[12:43] <MasterDuke> m: my @f; @f[0].map({$_ += 1}); say @f

[12:43] <camelia> rakudo-moar 9da50e: OUTPUT: «Cannot assign to an immutable value␤  in block <unit> at <tmp> line 1␤␤»

[12:44] <IOninja> lizmat: what's IO::CatPath and IO::CatHandle? I don't see them: https://gist.github.com/zoffixznet/7d93b0c0a56d8cd1ce54f4bd77eda180

[12:44] <MasterDuke> those first two are RT #83280

[12:44] <synopsebot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=83280

[12:45] <MasterDuke> IOninja: pretty sure they're in/from her newio branch

[12:45] <lizmat> https://github.com/rakudo/rakudo/commit/a28270f009e15baa04ce76e   # the demise of IO::CatPath/CatHandle

[12:45] <lizmat> no, not part of newio branch

[12:45] <IOninja> Thanks.

[12:46] <IOninja> MasterDuke: that's what I was grepping.

[12:46] <MasterDuke> doh

[12:51] <IOninja> Haha.

[12:51] * IOninja is amused to see ≤,  ≥, ≠  being discussed the same day when CatPath was removed: https://irclog.perlgeek.de/perl6/2016-01-09#i_11860216

[12:52] <IOninja> There must be a temporal link between ≤,  ≥, ≠  and CatPaths :P

[12:53] * IOninja spots a Zoffix in the log

[12:53] <IOninja> Huh, so they were removed after 6.c release? :o

[12:56] <lizmat> yes, but before 2016.01

[12:56] <lizmat> so it wouldn't be in a Rakudo * or an official release

[12:57] <IOninja> ah

[13:03] <lizmat> I think we need a way to tell an iterator we're done, even when it's not exhausted

[13:03] <lizmat> $ 6 'my $h = open("words"); my @a = $h.lines(:close).head(5); dd @a, $h.opened'

[13:03] <lizmat> Array @a = ["A", "a", "aa", "aal", "aalii"]

[13:03] <lizmat> Bool::True

[13:04] <jnthn> .lines has a :close?

[13:04] <lizmat> so, even though I told .lines to close the handle, it will not do so, because it never gets exhausted

[13:04] * jnthn thought that was only on .slurp-rest

[13:04] <lizmat> well, it is actually internally to be used by IO::Path.lines

[13:04] <lizmat> but that may be the source issue I guess

[13:06] <lizmat> but even for the IO::Path case: it opens the path, and creates a Seq which will close the handle when it is exhausted

[13:06] <lizmat> except it will never be when chained with something like .head

[13:06] <lizmat> or [0..$limit-1] for that matter

[13:07] <lizmat> so I was thinking: maybe the Iterator class needs a "done" method

[13:07] <lizmat> by default that would be a null op

[13:07] <jnthn> This'll end in tears, I suspect

[13:07] <lizmat> ok

[13:08] <jnthn> Can always put a DESTROY in the Iterator

[13:08] <lizmat> so do you have another suggestion for handling "words".IO.lines.head(5) ?

[13:08] <lizmat> 6 'for ^1000 { my @a = open("words").lines(10,:close) }'

[13:08] <lizmat> Failed to open file /Users/liz/Github/rakudo.moar/words: too many open files

[13:09] <lizmat> ^^ probably won't fix that

[13:09] <lizmat> but it would help

[13:10] <jnthn> Note that any kind of close operation would need to be transitive also

[13:11] <moritz> for ^1000 { my @a = given open("words") { LEAVE .close; .lines.head(5) } }

[13:11] <jnthn> On error cases as well as success cases

[13:11] <jnthn> .close would be the right name for this, if we were to add it

[13:12] <lizmat> on the Iterator role you mean ?

[13:12] <jnthn> But it...just goes against the general spirit of iterators, which is that when you lose interest you just stop iterating

[13:12] <jnthn> Yes

[13:12] <lizmat> well, then we shouldn't use iterators on file handles / sockets  :-)

[13:13] <jnthn> Well, it's fine if you're not trying to use the iterator for resource management too :)

[13:13] <jnthn> There's just so many places for this to "leak" though

[13:14] <jnthn> I mean, for map it feels easy enough: you'd just do .close on the thing you're iterating if there's a last

[13:14] <jnthn> But then it also needs doing if there's an exception

[13:15] <jnthn> Every map would have to pay for the extra bit of logic/exception handler

[13:15] <jnthn> And similar for grep, head, and...well, anything else that iterates

[13:15] <jnthn> But even with all that

[13:16] <jnthn> my \foo = gather { for $foo.IO.lines { .take } }; say foo.head(5) # oops

[13:16] <jnthn> To fix *that* you'd need gather to track every single nested iteration

[13:17] <jnthn> Note that supply/react do track every whenever inside of them for this very reason

[13:18] <jnthn> But supplies were built from the ground up with explicit resource management in mind, because you *can't* leave reactive things to the GC: the arrows point from soruce to sink, not sink to source like in iterators.

[13:18] <jnthn> *source

[13:20] <lizmat> hmmm... perhaps iterators iterating over other iterators should just call "sink-all" if they don't exhaust the source iterator ?

[13:20] <lizmat> if an iterator needs to do resource management, then it should be in the sink-all anyway

[13:21] <lizmat> jnthn: or do you feel that's conflating too many things into one ?

[13:21] <jnthn> I'm saying that I don't think we can accurately/reliably convey lost interest

[13:22] <IOninja> m: (1...Inf).iterator.sink-all

[13:22] <jnthn> And yes, I was just about to ask what about infinite things

[13:22] <camelia> rakudo-moar 9da50e: OUTPUT: «(timeout)»

[13:28] <jnthn> API design is just generally really hard, because it's not just "will this work for the obvious use case" but "will it compose well with a bunch of other things"

[13:29] <lizmat> yeah, gotcha  :-)

[13:29] <jnthn> So adding something like .IO.lines looks really useful, 'cus it saves the open/close

[13:29] <lizmat> except we can't close if we don't consume the Seq

[13:30] <lizmat> completely

[13:30] <lizmat> :-(

[13:30] <jnthn> But composing it with .head(5) shows up the leak in the abstraction

[13:30] <lizmat> actually [^5] has the same issue

[13:30] <jnthn> Sadly, that case probably shows the problem as even more intractable

[13:31] <lizmat> hmnmm...  it doesn't at the moment ?

[13:31] <jnthn> my \lines = $foo.IO.lines; say lines[^5]; say "---"; say lines[5..10];

[13:31] <jnthn> You can't know it's time to close after the first indexing operation

[13:32] <jnthn> Oh, one other thing to note with the DESTROY suggestion: we already do close handles that get GC'd

[13:32] <jnthn> So that may not actually help

[13:32] <jnthn> In fact it may make it worse by keeping the handle alive longer to call .close on :S

[13:34] <[Coke]> (swear jar) that could be a dollar donated to the core fund, that's not a horrible idea.

[13:35] <IOninja> huggable: swear jar

[13:35] <huggable> IOninja, Help Perl 6. Donate (specify "Perl 6 fund" in purpose field): https://donate.perlfoundation.org/

[13:35] <IOninja> Way ahead of you.

[13:35] <|Tux|> This is Rakudo version 2017.02-181-g9da50e352 built on MoarVM version 2017.02-20-g773711e1

[13:35] <|Tux|> csv-ip5xs        2.806

[13:35] <|Tux|> test            12.407

[13:35] <|Tux|> test-t           5.062 - 5.077

[13:35] <|Tux|> csv-parser      12.784

[13:35] <[Coke]> IOninja++

[13:35] <[Coke]> well, fuck.

[13:35] <jnthn> Does this mean I should try to make people swear more to get funded? :)

[13:36] <IOninja> :)

[13:36] <MasterDuke> instead of a karma bot, we need a bot to track how much you owe?

[13:36] <IOninja> Haha. :D

[13:37] <[Coke]> there is another donation page somewhere. Digging.

[13:38] <MasterDuke> taxable?

[13:39] <dogbert17_> IOninja: should the status for https://rt.perl.org/Public/Bug/Display.html?id=128717 be changed?

[13:40] <IOninja> m: react whenever Supply.interval: 1 { .say }

[13:40] <camelia> rakudo-moar 9da50e: OUTPUT: «(timeout)0␤1␤2␤3␤4␤5␤6␤7␤8␤9␤10␤11␤12␤13␤14␤15␤16␤17␤18␤19␤20␤21␤»

[13:41] <IOninja> dogbert17_: I guess. Couldn't hurt to have a test

[13:43] <dogbert17_> where?

[13:44] <dogbert17_> S17-supply/syntax.t ?

[13:45] <dogbert17_> I guess that I can cobble something together

[13:48] <dogbert17_> [Coke] RT #122471 and RT #122470 seems to have been fixed

[13:48] <synopsebot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=122471

[13:48] <synopsebot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=122470

[13:51] <nine> Re-posting for a larger audience: Given module A which requires module B. Should after "require A; ::('B')" actually find B?

[13:51] <moritz> no

[13:51] <lizmat> hmmm... my first guess would have been yes

[13:52] <moritz> though we probably need some way to make it accessible

[13:52] <lizmat> moritz: why  not?

[13:52] <nine> Note that if A "use"s B, B is already not available.

[13:52] <moritz> rummaging around in GLOBAL maybeß

[13:52] <moritz> s/ß/?/

[13:52] <nine> in A's user that is

[13:52] <moritz> lizmat: because require A; only imports symbol A

[13:52] <lizmat> moritz: a, good point  :-)

[13:53] <moritz> lizmat: and lexpads are immutable at runtime, so we can't just shove other stuff in there

[13:57] <Geth> ¦ roast/lexical_require: 6885143ff6 | (Stefan Seifert)++ | S11-modules/require.t

[13:57] <Geth> ¦ roast/lexical_require: No longer transitively expose require'd symbols.

[13:57] <Geth> ¦ roast/lexical_require:

[13:57] <Geth> ¦ roast/lexical_require: Given:

[13:57] <Geth> ¦ roast/lexical_require: unit class A;

[13:57] <Geth> ¦ roast/lexical_require: method load() { require B; }

[13:57] <Geth> ¦ roast/lexical_require:

[13:57] <Geth> ¦ roast/lexical_require: And test.pl6:

[13:57] <Geth> ¦ roast/lexical_require: <…commit message has 6 more lines…>

[13:57] <Geth> ¦ roast/lexical_require: review: https://github.com/perl6/roast/commit/6885143ff6

[13:57] <nine> Ok, whith this the lexical_require branch is ready for review

[13:58] <[Coke]> dogbert17_: ok

[14:30] <Woodi_> iterator is just "walker", wiki: "object that traverse container" - something in memory (or prepared in DB memory). it don't do .open or .close part. with .lines we probably flattened synatctic sugar into concrete functionality. with infinite/generated things we can just be lazy. or maybe lazy thingies can have iterator API (.next, hasNext)

[15:08] <Woodi_> ...where words like "is", "don't do" should be understood like NEED or MUST in rfc documents... it's just pattern not exact clone

[15:21] <IOninja> We already have .next (.pull-one/.pull-at-least). And currently, receiving IterationEnd implies the iterator is exhausted, which is really the same thing as `hasNext` with a singular check (the receiver checks for IterationEnd) instead of possibly multiple checks (receiver checks for .hasNext before making a call and generator checks for end of its supply before setting .hasNext and generator's supplier

[15:21] <IOninja> checks for end before setting .hasNext and so on)

[15:23] <DrForr> nine: I'm going to be playing a little more intensely with Inine::Python this week. Hopefully I won't find bugs, but ya never know.

[15:24] <IOninja> And .lines does the open thing and returns a sequence whose iterator pulls out lines one by one. So, yes, it (the seq's iterator) don't do .open/.close and that's part of the problem

[15:25] * DrForr needs to get Perl6::Parser to use a proper iterator; terminating the loop is a little awkward at the moment.

[15:27] <IOninja> Actually, it does do .close; the problem is when it's not exhausted

[15:43] <Woodi_> IOninja: I think in .lines case problem is that it do both container part and container iterator part. it's was nice all-in-one so far

[15:46] <IOninja> FWIW, for ^1000 { for ^20 { $ = "lines".IO.lines[^2] } } doesn't have the issue. So, it'd be interesting to see a real-world case failure.

[15:46] <IOninja> maybe opening a ton of different files in same scope and reading just the leading lines?

[16:10] <timotimo> jnthn: would the "too many open files" problem be defeatable with a bit of logic to put pressure on the nursery whenever we consume a file handler?

[16:11] <timotimo> i mean, i expect it would, but i'm not sure if we want to do it that way

[16:14] <jnthn> timotimo: I don't think we should be solving language design bugs in the VM

[16:15] <timotimo> we don't want our users to put LEAVE absolutely everywhere, though?

[16:16] <timotimo> hmm. "close" or maybe even "discard"?

[16:16] * timotimo skipped reading that the first time around

[16:17] <IOninja> jnthn: is there any reason there's no nqp::stat(...ALL) thing that would return all the stat info in one call instead of requiring a call per item of info?

[16:18] <IOninja> Having measured anything, but someone said stat call is expensive and I'm wondering if we can get an improvement by adding an nqp::stat(ALL) thing, since some of the IO::Path methods (e.g. .rwx) end up doing like 4 stat calls per method call

[16:18] <jnthn> IOninja: Well, in the immediate because when Rakudo was ported to MoarVM/JVM it didn't use such a thing, and we just implemented what was needed. :)

[16:18] <IOninja> *Haven't measured

[16:19] <IOninja> Alright. Will see if I can measure something up to see if it's worth it.

[16:19] <jnthn> Yeah, I've heared "stat is expensive" a decent bit too ;)

[16:19] <jnthn> One thing to keep in mind, though

[16:19] <IOninja> boxing all the info  may be more expensive? :)

[16:20] <jnthn> On platforms where stat is not the native thing (and so emulated), it's quite costly to construct it out of many API calls

[16:20] <IOninja> Ah

[16:20] <jnthn> And then disreard most of the info

[16:20] <jnthn> But yeah, .rwx doing three calls is LTA

[16:20] <timotimo> also racy, no?

[16:20] <jnthn> *disregard

[16:21] <jnthn> Yeah, in the sense that everything you do with a filesystem is :)

[16:21] <timotimo> yeah, though if you have a regular stat syscall it's atomic i expect

[16:21] <jnthn> I mean, if $x.IO.w { open $x } is racey :)

[16:21] <timotimo> aye

[16:21] <timotimo> look-before-you-leap would be the answer here

[16:21] <timotimo> er

[16:22] <timotimo> i meant the exact opposite

[16:22] <jnthn> But yeah, I agree we should ideally we doing a single stat call for .rwx

[16:22] <timotimo> go me!

[16:22] <jnthn> Yeah, it's better to just do things and cope with the fallout, because you have to to be robust anyway

[16:27] <nine> Note:  For  performance  and simplicity reasons, different fields in the stat structure may contain state information from different moments during the execution of the system call.  For example, if st_mode or st_uid is changed by another process by calling chmod(2) or chown(2), stat() might return the old st_mode together with the new st_uid, or the old st_uid together with the new st_mode.

[16:28] * dogbert17_ at stat call on his $work machine (Xeon proc) take 2.40276e-07 seconds on avarage

[16:28] <jnthn> nine: Interesting; thanks :)

[16:30] * dogbert17_ tested with code from http://docstore.mik.ua/orelly/weblinux2/modperl/ch11_06.htm

[16:32] <timotimo> :D

[16:32] <timotimo> that's rather terrible :D

[16:32] <timotimo> but also: we're off the hook in this regard ;)

[16:35] <nine> I guess instead of an ALL, being able to communicate the interesting fields to the VM would allow for better optimization on different platforms. Also there have already been several attempts for more fine grained stat syscalls on Linux.

[16:36] <IOninja> true

[16:37] <nine> https://lwn.net/Articles/707602/

[17:55] <Geth> ¦ roast: dogbert17++ created pull request #250: Test for RT 128717

[17:55] <Geth> ¦ roast: review: https://github.com/perl6/roast/pull/250

[17:56] <Geth> ¦ roast: 1da17b7cbf | dogbert17++ | S17-supply/syntax.t

[17:56] <Geth> ¦ roast: Test for RT 128717 (#250)

[17:56] <Geth> ¦ roast: review: https://github.com/perl6/roast/commit/1da17b7cbf

[18:50] <nine> You know you've done too much rakudo debugging when you type nqp::sayfh(nqp::getstderr(), $compunit.dump) if nqp::existskey(nqp::getenvhash(), 'DUMP'); straight without thinking or typo.

[18:54] <IOninja> :)

[18:55] * geekosaur would be hacking up a macro system or preprocessor on top of that by now...

[18:58] <geekosaur> probably add nqp:: to every sub unless it started with :, and no-args stuff shorthanded as $*name -> nqp::name()

[18:58] <geekosaur> or nqp::get<name>()

[18:59] * geekosaur thinks that's what the computer's there for

[19:14] <MasterDuke> m: my @f; @f[2,2,2].map({$_ += 1}); say @f

[19:14] <camelia> rakudo-moar 9da50e: OUTPUT: «[(Any) (Any) 1]␤»

[19:14] <MasterDuke> m: my @f = 0; @f[2,2,2].map({$_ += 1}); say @f

[19:14] <camelia> rakudo-moar 9da50e: OUTPUT: «[0 (Any) 1]␤»

[19:14] <MasterDuke> m: my @f; @f[0,0,0].map({$_ += 1}); say @f

[19:14] <camelia> rakudo-moar 9da50e: OUTPUT: «[1]␤»

[19:15] <MasterDuke> m: my @f = 4; @f[0,0,0].map({$_ += 1}); say @f

[19:15] <camelia> rakudo-moar 9da50e: OUTPUT: «[7]␤»

[19:15] <MasterDuke> this is RT #83280, but i'm not entirely sure it's a bug

[19:15] <synopsebot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=83280

[19:20] <MasterDuke> as i understand what's going on, `my @f; @f[0,0,0].map({$_ += 1}); say @f` is creating a 3-element list of what's int @f[0], and then mapping over that list and mutating the results

[19:21] <MasterDuke> so in the auto-viv case, @f[0,0,0] is 3 Any's, each one gets incremented to 1, and that one gets stored back in @f[0]

[19:24] <IOninja> m: my @f; my $a := @f[2]; ($a, $a, $a).map({$_ += 1}); say @f

[19:24] <camelia> rakudo-moar 9da50e: OUTPUT: «[(Any) (Any) 3]␤»

[19:24] <MasterDuke> in the pre-assigned case, @f[0,0,0] is 3 copies of the container in @f[0], it gets incremented 3 times, so ends up its pre-existing value + 3

[19:26] <IOninja> s: [], 'AT-KEY', \(Any:U: 42)

[19:26] <SourceBaby> IOninja, Something's wrong: ␤ERR: ===SORRY!=== Error while compiling -e␤Confused␤at -e:6␤------>     put sourcery( [], 'AT-KEY', \(Any:U:<HERE> 42) )[1];␤    expecting any of:␤        colon pair␤

[19:26] <IOninja> s: Any, 'AT-KEY', \(42)

[19:26] <SourceBaby> IOninja, Sauce is at https://github.com/rakudo/rakudo/blob/9da50e3/src/core/Any.pm#L398

[19:28] <IOninja> m: my @f; @f[0,0,0].map({.WHICH}).say

[19:28] <camelia> rakudo-moar 9da50e: OUTPUT: «(Any|U31282552 Any|U31282552 Any|U31282552)␤»

[19:28] <IOninja> m: my @f; say [===] @f[0,0,0]

[19:28] <camelia> rakudo-moar 9da50e: OUTPUT: «True␤»

[19:29] <IOninja> m: use nqp; my @f; @f[0,0,0].map({nqp::getattr($_, Scalar, '$!whence').WHICH}).say

[19:29] <camelia> rakudo-moar 9da50e: OUTPUT: «(Block|66537888 Block|66538968 Block|66539040)␤»

[19:30] <IOninja> Don't get why the first which gave the same object :S

[19:31] <IOninja> m: sub foo { my $x }; say foo.WHICH xx 3

[19:31] <camelia> rakudo-moar 9da50e: OUTPUT: «(Any|U31446392 Any|U31446392 Any|U31446392)␤»

[19:32] <MasterDuke> huh

[19:32] <IOninja> Ah, OK. It just our .WHICH sucks and it doesn't see difference in $!whence or something.

[19:34] <IOninja> MasterDuke: but yeah, the @f[2,2,2] is a slice of three different containers, they all are Any:U and update @f[2] to 1, but only the update of the (last) one sticks around.

[19:34] <timotimo> nine: nqp has a "note" sub! \o/

[19:35] <IOninja> m: my @f; @f[2,2,2].map({$_ += ++$}); say @f

[19:35] <camelia> rakudo-moar 9da50e: OUTPUT: «[(Any) (Any) 3]␤»

[19:35] <IOninja> m: my @f; @f[2,2,2].reverse.map({$_ += ++$}); say @f

[19:35] <camelia> rakudo-moar 9da50e: OUTPUT: «[(Any) (Any) 3]␤»

[19:35] <IOninja> m: my @f; @f[2,2,2].map({say $_ += rand}); say @f

[19:35] <camelia> rakudo-moar 9da50e: OUTPUT: «0.912432216585864␤0.312091973617792␤0.756353937191424␤[(Any) (Any) 0.756353937191424]␤»

[19:35] <IOninja> m: my @f; @f[2,2,2].reverse.map({say $_ += rand}); say @f

[19:35] <camelia> rakudo-moar 9da50e: OUTPUT: «0.635016544973122␤0.872707273829507␤0.698843535049793␤[(Any) (Any) 0.698843535049793]␤»

[19:35] <IOninja> Right.

[19:37] <IOninja> I'll reply and reject it. I know $!whence is supposed to be removed at some point, but at least currently the behaviour makes sense to me.

[19:39] <MasterDuke> yeah, it took looking at it for a little while, but it seemed less bug-like the more i thought about it

[19:50] <IOninja> Hm, the more I try to explain it, the more it feels like a bug

[19:50] <IOninja> Or more precicely: a shortcomming of the $!whence thing

[19:50] <IOninja> m: my @f; my $a := @f[0]; my $b := @f[0]; $a = 42; say $b

[19:50] <camelia> rakudo-moar 9da50e: OUTPUT: «(Any)␤»

[19:50] <IOninja> m: my $z; my $a := $z; my $b := $z; $a = 42; say $b

[19:50] <camelia> rakudo-moar 9da50e: OUTPUT: «42␤»

[19:50] <lizmat> IOninja: yes, $!whence has its shortcomings

[19:51] <IOninja> lizmat: so would you say it's a bug (and the ticket should be left open)?

[19:51] <IOninja> m: my @f; @f[0,0,0].map({$_ += 1}); say @f

[19:51] <camelia> rakudo-moar 9da50e: OUTPUT: «[1]␤»

[19:51] <IOninja> m: my @f = 0; @f[0,0,0].map({$_ += 1}); say @f

[19:51] <camelia> rakudo-moar 9da50e: OUTPUT: «[3]␤»

[19:51] <IOninja> ^ this I mean

[19:51] <IOninja> The fact that the two don't generate same output

[19:52] <lizmat> yeah, that's a bug I probably introduced

[19:52] <IOninja> hehe

[19:52] <IOninja> The original is from 2011 or something :)

[19:52] <lizmat> m: my @f = (); @f[0,0,0].map({$_ += 1}); say @f

[19:52] <camelia> rakudo-moar 9da50e: OUTPUT: «[1]␤»

[19:52] <IOninja> The Any:U.AT-KEY returns a new scalar on each call

[19:53] <IOninja> And its whence gets triggered.

[19:53] <MasterDuke> committable6: all my @f; @f[0,0,0].map({$_ += 1}); say @f

[19:53] <IOninja> Hm.... wonder if we can solve it with state $scalar = whencebusiness...; $scalar

[19:53] <IOninja> And then all the calls will return the same whence?

[19:53] <committable6> MasterDuke, https://gist.github.com/7a3d1c4a740879bd7a3fbb343a05bf59

[19:54] <MasterDuke> committable6: all my @f = 0; @f[0,0,0].map({$_ += 1}); say @f

[19:54] <committable6> MasterDuke, https://gist.github.com/4838076a8e4114b586e3287336b9184d

[19:54] <lizmat> m: my %h; my $a := %h<a><a>; %h<a> = 42; dd %h; $a = 666; dd %h   # is this correct behaviour, or should the assignment to $b die ?

[19:54] <camelia> rakudo-moar 9da50e: OUTPUT: «Hash %h = {:a(42)}␤Hash %h = {:a(${:a(666)})}␤»

[19:55] <IOninja> o.O

[20:01] <jnthn> We could try to catch that case, though it'd require an extra existskey check on every single hash assignment

[20:01] <jnthn> So far as I'm concerned, it's a DIHWIDT

[20:36] <Geth> ¦ rakudo/lexical_require: bb87aff465 | (Stefan Seifert)++ | src/core/operators.pm

[20:36] <Geth> ¦ rakudo/lexical_require: Fix "require" with statement prefix phasers.

[20:36] <Geth> ¦ rakudo/lexical_require:

[20:36] <Geth> ¦ rakudo/lexical_require: BEGIN require Test; failed with "Lexical with name 'Test' does not exist in

[20:36] <Geth> ¦ rakudo/lexical_require: this frame". A similar error message would come for symbols in the import

[20:36] <Geth> ¦ rakudo/lexical_require: list.

[20:36] <Geth> ¦ rakudo/lexical_require: The reason was that the statement prefix would actually lead to a QAST::Block

[20:36] <Geth> ¦ rakudo/lexical_require: being generated for the statement while the lexical stubs for the module name

[20:36] <Geth> ¦ rakudo/lexical_require: and the imported symbols were created in the block containing the phased

[20:36] <Geth> ¦ rakudo/lexical_require: statement. The highly specific lookup in REQUIRE_IMPORT (OUTER::CALLER::) did

[20:36] <Geth> ¦ rakudo/lexical_require: not find the stubs. Fix by looking in the caller's outer lexical scope, too.

[20:36] <Geth> ¦ rakudo/lexical_require: review: https://github.com/rakudo/rakudo/commit/bb87aff465

[20:36] <Geth> ¦ roast/lexical_require: 34cbe4a5ed | (Stefan Seifert)++ | S11-modules/require.t

[20:36] <Geth> ¦ roast/lexical_require: RT #127538 is fixed, can run these tests now.

[20:36] <Geth> ¦ roast/lexical_require: review: https://github.com/perl6/roast/commit/34cbe4a5ed

[20:36] <synopsebot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=127538

[20:37] <nine> I'm not sure how useful BEGIN require Foo; is, but the bug actually affected all phasers.

[20:40] <nine> Does anyone want to look at the branch first or should I just merge?

[20:41] <IOninja> .oO( just merge... )

[20:41] <lizmat> +1

[21:07] <Geth> ¦ rakudo/nom: 4 commits pushed by (Stefan Seifert)++

[21:07] <Geth> ¦ rakudo/nom: 63cf5cac00 | Import symbols from 'require'd modules lexically

[21:07] <Geth> ¦ rakudo/nom: 3e86d0fa9a | Create lexical stub package for 'require'd module.

[21:07] <Geth> ¦ rakudo/nom: 5b98caa35a | Create lexical stub package for nested required module.

[21:07] <Geth> ¦ rakudo/nom: 6771deefa4 | Fix "require" with statement prefix phasers.

[21:07] <Geth> ¦ rakudo/nom: review: https://github.com/rakudo/rakudo/compare/9da50e352f...6771deefa4

[21:07] <Geth> ¦ roast: 15b57e4361 | (Stefan Seifert)++ | S11-modules/require.t

[21:07] <Geth> ¦ roast: Create lexical stubs for require'd packages

[21:07] <Geth> ¦ roast:

[21:07] <Geth> ¦ roast: "use" and "need" already put the loaded packages in lexical scope.

[21:07] <Geth> ¦ roast: Fixing #125083 brings "require" in line with them.

[21:07] <Geth> ¦ roast: review: https://github.com/perl6/roast/commit/15b57e4361

[21:07] <Geth> ¦ roast: 729ecee014 | (Stefan Seifert)++ | S11-modules/require.t

[21:07] <synopsebot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=125083

[21:07] <Geth> ¦ roast: No longer transitively expose require'd symbols.

[21:07] <Geth> ¦ roast:

[21:07] <Geth> ¦ roast: Given:

[21:07] <Geth> ¦ roast: unit class A;

[21:07] <Geth> ¦ roast: method load() { require B; }

[21:07] <Geth> ¦ roast:

[21:07] <Geth> ¦ roast: And test.pl6:

[21:07] <Geth> ¦ roast: <…commit message has 6 more lines…>

[21:07] <Geth> ¦ roast: review: https://github.com/perl6/roast/commit/729ecee014

[21:07] <Geth> ¦ roast: 073a95fa6d | (Stefan Seifert)++ | S11-modules/require.t

[21:08] <Geth> ¦ roast: RT #127538 is fixed, can run these tests now.

[21:08] <synopsebot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=127538

[21:08] <Geth> ¦ roast: review: https://github.com/perl6/roast/commit/073a95fa6d

[21:25] <nine> lizmat: this branch got us rid of #125083, #125084, #125951, #126658, #127538 and #130535 :)

[21:25] <synopsebot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=125083

[21:25] <synopsebot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=125084

[21:25] <synopsebot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=125951

[21:25] <synopsebot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=126658

[21:25] <synopsebot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=127538

[21:25] <synopsebot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=130535

[21:26] <lizmat> cool!

[21:26] <timotimo> i wonder if synopsebot should consolidate multiple links into fewer messages?

[21:27] <perlpilot> How often is someone likely to mention many RTs in a single message?

[21:27] <timotimo> *shrug*

[21:27] <perlpilot> I wouldn't bother with it (unless nine makes this a habit ;)

[21:29] <lizmat> even then  :-)

[21:34] <IOninja> dogbert17_: looked closer at 130940... there's a whole ton of hanging methods. I stopped looking for more after finding 7. Basically the hang is due to the args being accepted by the Cool candidate but rejected by the Str (or whatever type Cool coerces to) candidate. That rejection loops it back to the Cool candidate and so it infiniloops. So we need to check all the Cool methods and fix it for all of

[21:34] <IOninja> them. It's like... 3rd time now this bug occurs in a different method :(

[21:36] <ugexe> i think TAP.pm6 is broken with the new require fixes

[21:37] <IOninja> it has one require in it: https://github.com/rakudo/rakudo/blob/nom/lib/TAP.pm6#L257

[21:38] <IOninja> nine++ fixing a ton of tickets

[21:38] <ugexe> its that or zefs plugin for it is broke

[21:41] <nine> ugexe: oh, that's the one tricky case for which I don't have a good solution. The "try" prefix compiles to a block, which messes with the lexicalness.

[21:42] <nine> my $deserialized = do { require YAMLish; YAMLish::load-yaml("---\n$serialized...") }; should work

[21:42] <IOninja> hm...

[21:42] <nine> Err... my $deserialized = do { require YAMLish; YAMLish::load-yaml("---\n$serialized..."); CATCH { default { } }  };

[21:42] <IOninja> try require is pretty common tho :/

[21:42] <IOninja> I guess here it's already fixed: https://github.com/zoffixznet/perl6-IRC-Client/blob/master/lib/IRC/Client.pm6#L28-L30

[21:43] <nine> IOninja: yes

[21:44] <nine> This is also still ok: my $Foo = try require Foo; $Foo.new;

[21:44] <IOninja> Ohhh. OK :)

[21:45] <IOninja> Here's a grep of `try require` on ecosystem: https://gist.github.com/zoffixznet/bb95df0ab2b8943d449f18c540c05774

[21:45] <nine> Maybe we could detect that the QAST::Block is created for the try prefix and instead put the symbols to the outer block.

[21:45] <IOninja> oh, but `if try require Foo { Foo.new }` won't work?

[21:46] <nine> Phaser statement prefixes do the same already

[21:46] <IOninja> or `if (try require Foo) { Foo.new }`

[21:46] <jnthn> nine: We also know that thunks have type Code while blocks have type Block, fwiw

[21:46] <nine> Read that as if try { require Foo } { Foo.new }

[21:46] <jnthn> nine: I think we should be getting that consistently right

[21:47] <ugexe> https://github.com/ugexe/zef/commit/daf26870d10fa3585b0cd61b09a45ea3e4c61bef # Fixed in zef here

[21:47] <IOninja> And this is now broken too? https://github.com/perl6/perl6-lwp-simple/blob/master/lib/LWP/Simple.pm#L53-L54

[22:00] <nine> May actually be a one line fix :)

[22:00] <nine> Sorry, two lines

[22:04] <IOninja> :D

[22:08] <RabidGravy> I'll test all the things tomorrow

[22:08] <IOninja> \o/

[22:10] <lizmat> And another Perl 6 Weekly hits the Net: https://p6weekly.wordpress.com/2017/03/06/2017-10-≤-its-all-relative-≥/

[22:10] <lizmat> brb

[22:11] <Geth> ¦ rakudo/nom: 9da6de4678 | (Stefan Seifert)++ | src/Perl6/Actions.nqp

[22:11] <Geth> ¦ rakudo/nom: Fix try require Foo; Foo.new;

[22:11] <Geth> ¦ rakudo/nom:

[22:11] <Geth> ¦ rakudo/nom: The try statement prefix compiles to a QAST::Block which would swallow the

[22:11] <Geth> ¦ rakudo/nom: lexical symbols we created for the required package and the import list.

[22:11] <Geth> ¦ rakudo/nom: We now detect this situation and make sure the symbols make it into the

[22:11] <Geth> ¦ rakudo/nom: acutal code block containing the statement.

[22:11] <Geth> ¦ rakudo/nom: review: https://github.com/rakudo/rakudo/commit/9da6de4678

[22:13] <jnthn> lizmat: Where did Lib::LibSSH come from, ooc? (Should be SSH::LibSSH, but I can't spot where I did it wrong...)

[22:14] <jnthn> lizmat++ # weekly

[22:14] <jnthn> Also, it wsa Proc::Async that got the newline translation treatement; it was already the case for file handles. :)

[22:18] <lizmat> fixed xx 2

[22:36] <lizmat> jnthn: I'm considering making IO::Path.lines be eager in the sense that it will read the whole file in memory, and then produce lines from that

[22:36] <lizmat> jnthn: aka "words".IO.slurp.lines

[22:36] <lizmat> jnthn: and then remove the :close param from IO::Handle.lines

[22:37] <IOninja> :o

[22:37] <IOninja> That kinda sucks. Currently you can process files gigabytes in size line-by-line without issues.

[22:37] <lizmat> jnthn: so that we're clear on that IO::Handle.lines will never close the handle

[22:37] <lizmat> IOninja: and you still can

[22:38] <lizmat> open("words").lines will do that

[22:38] <lizmat> "words".IO.lines will not

[22:38] <IOninja> OK

[22:38] <lizmat> is my proposal

[22:38] <lizmat> "words".IO.lines will never leak handles, open("words").lines will

[22:39] <lizmat> my $handle will leave .close = open("words"); for $handle.lines { }  # will not leak

[22:39] <lizmat> *.close

[22:40] <IOninja> Makes sense.

[22:40] <IOninja> No comments then :D

[22:41] <lizmat> hmmm... 'will leave *.close' doesn't parse  :-(

[22:41] <lizmat> will leave { .close } does

[22:42] * gfldex .oO( { .close } enough )

[22:42] <lizmat> yeah, but seems counterintuitive not allowing whatevercode in that case

[22:43] <lizmat> also, would be nice if somehow "open" could apply the "will leave { .close }' on the variable  :-)

[23:03] <geekosaur> will leave is kinda the wrong semantic, I'd say

[23:04] <geekosaur> you want the handle to be closed when its last reference goes away, which *usually* means whatever you stored it into went out of scope... but not always, because it may have stuffed it elsewhere as well

[23:04] <geekosaur> and I would be Grumpy if I stowed it in a hash but it got closed on return from what did the open

[23:09] <lizmat> yeah,   :-(

[23:38] <samcv> good *

[23:38] <samcv> i need to finish and submit my grant proposal today. finish up the inch stone section

[23:39] <lizmat> samcv++

[23:39] <IOninja> \o/

[23:43] <Geth> ¦ rakudo/nom: 0083c4ff25 | (Elizabeth Mattijsen)++ | src/core/IO/Path.pm

[23:43] <Geth> ¦ rakudo/nom: Always close the handle on IO::Path.lines

[23:43] <Geth> ¦ rakudo/nom: review: https://github.com/rakudo/rakudo/commit/0083c4ff25

[23:43] <Geth> ¦ rakudo/nom: 2a2e460b1e | (Elizabeth Mattijsen)++ | src/core/IO/Path.pm

[23:43] <Geth> ¦ rakudo/nom: Make the default for limit Whatever

[23:43] <Geth> ¦ rakudo/nom:

[23:43] <Geth> ¦ rakudo/nom: so that it matches on the cheap first condition, instead of on the

[23:43] <Geth> ¦ rakudo/nom: expensive second condition

[23:43] <Geth> ¦ rakudo/nom: review: https://github.com/rakudo/rakudo/commit/2a2e460b1e

[23:44] <lizmat> and that concludes my hacking for today

[23:44] <lizmat> good night, #perl6-dev!

[23:46] <IOninja> night
