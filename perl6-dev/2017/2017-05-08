[00:44] <Geth> ¦ rakudo: LLFourn++ created pull request #1079: Revert "Fix stuck precomp on osx"

[00:44] <Geth> ¦ rakudo: review: https://github.com/rakudo/rakudo/pull/1079

[00:46] <Geth> ¦ rakudo/nom: b7bed98c6d | (Lloyd Fournier)++ (committed using GitHub Web editor) | src/core/CompUnit/PrecompilationRepository.pm

[00:46] <Geth> ¦ rakudo/nom: Revert "Fix stuck precomp on osx"

[00:46] <Geth> ¦ rakudo/nom: review: https://github.com/rakudo/rakudo/commit/b7bed98c6d

[00:46] <Geth> ¦ rakudo/nom: 31903fd458 | (Nick Logan)++ (committed using GitHub Web editor) | src/core/CompUnit/PrecompilationRepository.pm

[00:46] <Geth> ¦ rakudo/nom: Merge pull request #1079 from LLFourn/revert-1076-bugfix/osx-unstuck-precomp

[00:46] <Geth> ¦ rakudo/nom:

[00:46] <Geth> ¦ rakudo/nom: Revert "Fix stuck precomp on osx"

[00:46] <Geth> ¦ rakudo/nom: review: https://github.com/rakudo/rakudo/commit/31903fd458

[00:49] <ugexe> llfourn: so does that mean spitsh is filling stdout during precomp instead of stderr?

[00:50] <llfourn> ugexe: that could be it because rakudo precomp writes to STDOUT right?

[00:50] <llfourn> Spit is huge so a lot of modules get loaded

[00:51] <ugexe> yeah

[01:28] <Geth> ¦ nqp: MasterDuke17++ created pull request #359: Convert substr+eq to eqat

[01:28] <Geth> ¦ nqp: review: https://github.com/perl6/nqp/pull/359

[01:29] <Zoffix> You do have a commit bit...

[01:52] <MasterDuke_> yep, and i'll merge after a while if nobody has any comment or objections

[01:53] <Zoffix> cool

[02:02] * Zoffix sets Kitten on fire

[02:04] <Zoffix> Just realized it has a special case that, say Kitten.new(<fo o>).words has a special has where after returning word `foo`, my approach would still end up returning `''` at the end, because it has no clue whether we're at the end of the work queue (so return IterationEnd) or just freshly started and Kitten is an empty string (so return '')

[02:04] <Zoffix> s/special has/special case/

[02:05] <Zoffix> So my approach of making some seq-in-the-middle generalized iterator won't work :(

[02:06] <Zoffix> Well, good news. All of a sudden I freed all this time to work on finishing IO grant. Bad news is I don't have the proper tool to make .words/.lines/.comb/.split work right; especially on IO::CatHandle

[02:08] <Zoffix> Radical idea: make them all line-based; even .comb and .split

[02:09] <Zoffix> Radicaler idea: remove them

[02:10] <Zoffix> They're aching to be removed

[02:10] <Zoffix> them = .comb/.split

[02:14] <Zoffix> Or... make them eagerly slurp. This will minimize (or eliminate) fallout

[02:15] <Zoffix> But would make them LTA in IO::CatHandle ('cause they'll slurp all the files/wait for STDIN to terminate before returning anything)

[02:16] <Zoffix> Maybe that isn't all that fatal. It won't have to stay that way forever; only until someone smarter than me makes a proper Cat.

[02:18] <Zoffix> m: say 583-193

[02:18] <camelia> rakudo-moar 31903f: OUTPUT: «390␤»

[02:18] <Zoffix> I hope the person who wrote original code isn't too attached to it, 'cause it'll be about 360 nixed lines.

[02:25] <Zoffix> m: "".words.iterator.pull-one.perl.say

[02:25] <camelia> rakudo-moar 31903f: OUTPUT: «IterationEnd␤»

[02:25] <Zoffix> oh

[02:26] <Zoffix> I don't have a special case. Never mind. Back on track with Kitten heh

[02:28] <Zoffix> oh wait, yeah, there still is a special case; not with words but with .comb/.split

[02:28] <Zoffix> m: "foo".comb(/^./).perl.say

[02:28] <camelia> rakudo-moar 31903f: OUTPUT: «("f",)␤»

[02:28] <Zoffix> with Kitten that would end up giving <f o o>

[02:28] * Zoffix goes to bed

[07:32] <[Tux]> Inline::Perl5(

[07:32] <[Tux]> *fetch stage failed for Inline::Perl5: Unable to handle source 'http://www.cpan.org/authors/id/N/NI/NINE/Perl6/Inline-Perl5-0.26.tar.gz')

[07:36] <[Tux]> This is Rakudo version 2017.04.3-193-g31903fd45 built on MoarVM version 2017.04-57-g8d8a09b9

[07:36] <[Tux]> csv-ip5xs        3.071

[07:36] <[Tux]> test            12.679

[07:36] <[Tux]> test-t           4.247 - 4.277

[07:36] <[Tux]> csv-parser      13.465

[07:39] <nine> [Tux]: are you using panda or zef?

[07:40] <[Tux]> zef and panda

[07:40] <[Tux]> for the real install I now use zef, but I still build and test panda

[07:40] <nine> Does zef update fix it?

[07:41] <[Tux]> zef update does nothing but showing some statistics

[07:43] <nine> And the error persists after the zef update?

[07:45] <[Tux]> $ zef install Inline::Perl5

[07:45] <[Tux]> All candidates are currently installed

[07:45] <[Tux]> No reason to proceed. Use --force to continue anyway

[08:28] <Geth> ¦ nqp: 5e9403a1fe | MasterDuke17++ | 11 files

[08:28] <Geth> ¦ nqp: Convert substr+eq to eqat

[08:28] <Geth> ¦ nqp:

[08:28] <Geth> ¦ nqp: nqp::eqat is much faster than doing a substr+eq.

[08:28] <Geth> ¦ nqp: review: https://github.com/perl6/nqp/commit/5e9403a1fe

[08:28] <Geth> ¦ nqp: 50a05bb472 | lizmat++ (committed using GitHub Web editor) | 11 files

[08:28] <Geth> ¦ nqp: Merge pull request #359 from MasterDuke17/convert_substr_plus_eq_to_eqat

[08:28] <Geth> ¦ nqp:

[08:28] <Geth> ¦ nqp: Convert substr+eq to eqat

[08:28] <Geth> ¦ nqp: review: https://github.com/perl6/nqp/commit/50a05bb472

[08:37] <Geth> ¦ rakudo/nom: 3f7d1334dc | (Elizabeth Mattijsen)++ | tools/build/NQP_REVISION

[08:37] <Geth> ¦ rakudo/nom: Bump NQP to get MasterDuke's eqat fixes

[08:37] <Geth> ¦ rakudo/nom: review: https://github.com/rakudo/rakudo/commit/3f7d1334dc

[08:37] <Geth> ¦ rakudo/nom: version bump brought these changes: https://github.com/perl6/nqp/compare/2017.04-72-gc60df1e...2017.04-92-g50a05bb

[08:37] <lizmat> afk again&

[10:23] <Geth> ¦ nqp: b63e734d3f | (Pawel Murias)++ | src/vm/js/nqp-runtime/io.js

[10:23] <Geth> ¦ nqp: [js] Fix nqp::filereadable, nqp::filewritable, nqp::fileexecutable

[10:23] <Geth> ¦ nqp: review: https://github.com/perl6/nqp/commit/b63e734d3f

[11:42] <Geth> ¦ nqp: 66eae599ad | (Pawel Murias)++ | src/vm/js/nqp-runtime/multicache.js

[11:42] <Geth> ¦ nqp: [js] Remove debugging leftover

[11:42] <Geth> ¦ nqp: review: https://github.com/perl6/nqp/commit/66eae599ad

[11:42] <Geth> ¦ nqp: 674cb40a88 | (Pawel Murias)++ | src/vm/js/nqp-runtime/io.js

[11:42] <Geth> ¦ nqp: [js] Handle all the modes that can be passed to nqp::open

[11:42] <Geth> ¦ nqp: review: https://github.com/perl6/nqp/commit/674cb40a88

[12:16] <Zoffix> awwww. Realized Kitten don't got special cases I mentioned above and despite being dog slow would work... until I hit another roadblock: generic iter don't know how much string to cut off: " bar foo".words cuts it as "r foo" because the chunk is "bar" so it thinks it needs to cut off 3 chars from the head :/

[12:16] * Zoffix gives up with it for good

[12:18] <Zoffix> and gonna make .split/.comb on IO::Handle full-slurp for now; until we have proper Cat

[12:23] <Woodi_> Cat is lazy slurp ?

[12:23] <Woodi_> can't find doc for it...

[12:24] <Zoffix> Cat is lazy string

[12:41] <Zoffix> "Can't open perl script "Configure.pl": No such file or directory" :/

[12:41] <Zoffix> great

[12:41] <Zoffix> ah. It'd help if I ran `build-rakudo` in correct directory

[12:41] <timotimo> :D

[12:41] <Zoffix> ZofBot: moar coffee plz!

[12:41] <ZofBot> Zoffix, See <http://jnthn

[12:42] <jnthn> o.O :)

[12:45] * MasterDuke_ didn't realize jnthn was as cool as Sting, Prince, Bono, etc.. must be pretty important to get a single name url!

[13:07] <Zoffix> m: dd "xfoo".comb: ""

[13:07] <camelia> rakudo-moar 3f7d13: OUTPUT: «("", "", "", "", "").Seq␤»

[13:08] <Zoffix> Is that supposed to be this way?

[13:08] <Zoffix> Or more specifically:

[13:08] <Zoffix> m: dd "".comb: ""

[13:08] <camelia> rakudo-moar 3f7d13: OUTPUT: «("",).Seq␤»

[13:08] <Zoffix> ^ that that is 1 el list and not an empty Seq

[13:08] <Zoffix> There's a test for IO::Handle.comb that tests it to be empty,

[13:10] <timotimo> but the empty string matches the empty file!

[13:12] * Zoffix makes "".comb: "" return ().Seq to see if we test for that case

[13:12] <timotimo> m: say +"foobar".comb(""); say "foobar".graphs;

[13:12] <camelia> rakudo-moar 3f7d13: OUTPUT: «7␤No such method 'graphs' for invocant of type 'Str'␤  in block <unit> at <tmp> line 1␤␤»

[13:12] <timotimo> m: say +"foobar".comb(""); say "foobar".chars;

[13:12] <camelia> rakudo-moar 3f7d13: OUTPUT: «7␤6␤»

[13:12] <timotimo> hmm.

[13:12] <timotimo> not my new favourite idiom for "how long is this string"

[13:13] <Zoffix> it kinda makes sense if you assume chars are surrounded by empty strings :P

[13:14] <timotimo> :D

[13:15] <tadzik> . o O ( we're surrounded by nothingness )

[13:15] <timotimo> yo tadzik

[13:16] <tadzik> \o/

[13:16] <tadzik> hey hey

[13:16] <timotimo> if imgur weren't over capacity i'd show you a screenshot of my TUI profiler

[13:16] <tadzik> oo

[13:17] <Zoffix> m: dd "xfoo".comb(0)

[13:17] <camelia> rakudo-moar 3f7d13: OUTPUT: «("x", "f", "o", "o").Seq␤»

[13:17] <Zoffix> m: dd "xfoo".comb(0) eqv "xfoo".comb: 1

[13:17] <camelia> rakudo-moar 3f7d13: OUTPUT: «Bool::True␤»

[13:17] <Zoffix> m: dd "xfoo".comb: -42

[13:17] <camelia> rakudo-moar 3f7d13: OUTPUT: «("x", "f", "o", "o").Seq␤»

[13:17] <tadzik> do want

[13:17] <timotimo> it's very early in development

[13:18] <timotimo> you can't control it yet, so all it does is output a not-fully-expanded call graph

[13:20] <timotimo> it knows to expand only up to things that have multiple children

[13:20] <timotimo> because the call graphs usually start with <unit-outer> -> <unit> -> <something>

[13:20] <Zoffix> Well, no Str tests fail but more IO comb tests fail

[13:20] <Zoffix> m: dd "abcd".comb: ""

[13:20] <camelia> rakudo-moar 3f7d13: OUTPUT: «("", "", "", "", "").Seq␤»

[13:21] <Zoffix> 'cause it expects ^ that to be... um, well 5 els

[13:21] <Zoffix> So dd "".comb: "" is 0 els, but "abcd".comb: "" is 5 els :/

[13:21] <timotimo> those tests don't seem all that great

[13:21] <Zoffix> Yeah

[13:22] <Zoffix> Gonna change it. Because I basically made IO::Handle.comb do exact same thing as Str.comb

[13:23] <MasterDuke_> oh hey, anybody mind merging https://github.com/rakudo/rakudo/pull/1077?

[13:24] <Geth> ¦ roast: b803879a6d | (Zoffix Znet)++ | S16-io/comb.t

[13:24] <Geth> ¦ roast: Make test description better

[13:24] <Geth> ¦ roast:

[13:24] <Geth> ¦ roast: by making it dump .perl of args Capture rather than just type.

[13:24] <Geth> ¦ roast: Very hard to figure out which test is failing otherwise.

[13:24] <Geth> ¦ roast: review: https://github.com/perl6/roast/commit/b803879a6d

[13:25] <Geth> ¦ rakudo/nom: 4 commits pushed by MasterDuke17++, (Zoffix Znet)++

[13:25] <Geth> ¦ rakudo/nom: fc5698bd58 | Improve error messages for feed operator problems

[13:25] <Geth> ¦ rakudo/nom: 1cf7ccba98 | Point out which stage in a feed has a problem

[13:25] <Geth> ¦ rakudo/nom: 07c7ce185c | Test code object in feeds suggests calling routine

[13:25] <Geth> ¦ rakudo/nom: 10e9d0c2f1 | Merge pull request #1077 from MasterDuke17/make_feed_compile_errors_better

[13:25] <Geth> ¦ rakudo/nom: review: https://github.com/rakudo/rakudo/compare/3f7d1334dc...10e9d0c2f1

[13:26] <MasterDuke_> Zoffix++ thanks

[13:26] <timotimo> marvellous

[13:30] <dogbert11> m: use Test; is (0, 1e-1 ... * >= 1).gist, "(0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 1.1)", "(oops)" # isn't it a bit suspicious to compare Nums like this ?

[13:30] <camelia> rakudo-moar 3f7d13: OUTPUT: «ok 1 - (oops)␤»

[13:31] <dogbert11> it's more or less pure luck that this test passes

[13:32] <dogbert11> m: say (6, 1e-1 ... * >= 7).gist

[13:32] <camelia> rakudo-moar 10e9d0: OUTPUT: «(6 0.0999999999999996 -5.8 -11.7 -17.6 -23.5 -29.4 -35.3 -41.2 -47.1 -53 -58.9 -64.8 -70.7 -76.6 -82.5 -88.4 -94.3 -100.2 -106.1 -112 -117.9 -123.8 -129.7 -135.6 -141.5 -147.4 -153.3 -159.2 -165.1 -171 -176.9 -182.8 -188.7 -194.6 -200.5 -206.4 -212.3 -21…»

[13:34] <Zoffix> :S

[13:34] <Zoffix> m: say 6 - 1e-1

[13:34] <camelia> rakudo-moar 10e9d0: OUTPUT: «5.9␤»

[13:34] <Zoffix> m: say 1e-1

[13:34] <camelia> rakudo-moar 10e9d0: OUTPUT: «0.1␤»

[13:34] <dogbert11> the second sequence was a bit of a fail :)

[13:34] <timotimo> yeah, of course it goes negative when you go from 6 to 0.1 :)

[13:34] <dogbert11> but the original test looks a bit shaky to me

[13:35] <Zoffix> what's up with 0.0999999999999996 tho?

[13:35] <Zoffix> There's no noise in 1e-1

[13:35] <timotimo> are you sure?

[13:35] <Zoffix> s: 1e-1, 'gist', \()

[13:35] <SourceBaby> Zoffix, Sauce is at https://github.com/rakudo/rakudo/blob/3f7d133/src/core/Numeric.pm#L28

[13:36] <dogbert11> m: say (0, 1e-1  ... * >= 7).gist

[13:36] <camelia> rakudo-moar 10e9d0: OUTPUT: «(0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 1.1 1.2 1.3 1.4 1.5 1.6 1.7 1.8 1.9 2 2.1 2.2 2.3 2.4 2.5 2.6 2.7 2.8 2.9 3 3.1 3.2 3.3 3.4 3.5 3.6 3.7 3.8 3.9 4 4.1 4.2 4.3 4.4 4.5 4.6 4.7 4.8 4.9 5 5.1 5.2 5.3 5.4 5.5 5.6 5.7 5.8 5.9 5.99999999999999 6.099999…»

[13:36] <Zoffix> s: 1e-1, 'Str', \()

[13:36] <SourceBaby> Zoffix, Sauce is at https://github.com/rakudo/rakudo/blob/3f7d133/src/core/Num.pm#L97

[13:36] <timotimo> i think 0.1 isn't possible as a floating point number

[13:36] <dogbert11> m: say (0, 0.1  ... * >= 7).gist # Rat

[13:36] <camelia> rakudo-moar 10e9d0: OUTPUT: «(0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 1.1 1.2 1.3 1.4 1.5 1.6 1.7 1.8 1.9 2 2.1 2.2 2.3 2.4 2.5 2.6 2.7 2.8 2.9 3 3.1 3.2 3.3 3.4 3.5 3.6 3.7 3.8 3.9 4 4.1 4.2 4.3 4.4 4.5 4.6 4.7 4.8 4.9 5 5.1 5.2 5.3 5.4 5.5 5.6 5.7 5.8 5.9 6 6.1 6.2 6.3 6.4 6.5 6.6…»

[13:36] <Zoffix> huh?

[13:37] * Zoffix refocuses on IO

[13:39] <dogbert11> I was looking at the pi bug we discussed the other day, changing snprintf from "%.15g" to "%.16g" makes one test fail in t/spec/integration/advent2013-day15.t

[13:40] <dogbert11> and the test is    'is (0, 1e-1 ... * >= 1).gist, "(0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 1.1)", "(oops)"'

[13:41] <MasterDuke_> how does it fail?

[13:42] * timotimo BBL

[13:42] <dogbert11> well, the result suddenly contains a lot of decimals

[13:43] <dogbert11> like (0 0.1 0.2 0.299999999 ...)

[13:44] <Zoffix> dogbert11: it should be changed.  One thing I can think of is `ok (so all (0, 1e-1 ... * >= 1) »≅« (0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1, 1.1)), "blah blah"`

[13:45] <dogbert11> »≅« nifty

[13:47] <dogbert11> MasterDuke_: I tried to fix RT #127184 by changing a "%.15g" to a "%.16g"

[13:47] <synopsebot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=127184

[13:48] <dogbert11> two spectests failed, the one above and t/spec/S32-exceptions/misc.rakudo.moar

[13:49] <dogbert11> in addition to that I stumbled upon another bug/feature whereas the number e was suddenly printed out as 2.718281828459046, i.e. the last digit was incorrect

[13:51] <dogbert11> which was particularly interesting since e is defined (in src/core/Num.pm) as being 2.71828_18284_59045_235e0

[13:51] <[Coke]> .

[13:53] <dogbert11> the 'fix' for the 'e' problem was to remove the underscores from the definition, i.e. 2.718281828459045235e0 instead of 2.71828_18284_59045_235e0 !?!

[13:53] <MasterDuke_> !!

[13:55] <dogbert11> the question is, what do I do now, pursue the problem by adjusting the 'broken' tests and trying to figure out what's happening when printing 'e'

[13:55] <Zoffix> dogbert11: that sounds like the grammar is doing math to end up with the final number and it's overflowing or whatever before it gets a chance to end up with the final number

[13:56] <dogbert11> Zoffix: that could very well be the case

[13:56] <Zoffix> bisect: say 1.1e308

[13:56] <bisectable6> Zoffix, Bisecting by output (old=2015.12 new=10e9d0c) because on both starting points the exit code is 0

[13:56] <bisectable6> Zoffix, bisect log: https://gist.github.com/15da5046f7657e3757f09fc342975803

[13:56] <bisectable6> Zoffix, (2016-11-08) https://github.com/rakudo/rakudo/commit/729d7e34124827a4e0b772b049be95cf911dd7cf

[13:56] <Zoffix> dogbert11: ^ similar to that bug

[13:58] <dogbert11> Zoffix: looks like it

[14:02] * dogbert11 IEEE 754 is tricky business

[14:08] <Zoffix> ZOFFLOP: t/spec/S11-modules/require.t

[14:11] <Zoffix> m: dd "abc".comb: 0

[14:11] <camelia> rakudo-moar 10e9d0: OUTPUT: «("a", "b", "c").Seq␤»

[14:11] <Zoffix> m: dd "abc".comb: 0, 42

[14:11] <camelia> rakudo-moar 10e9d0: OUTPUT: «("b", "c").Seq␤»

[14:11] <Zoffix> *sigh*

[14:14] * Zoffix journeys deeper down the rabbit hole

[14:14] <Zoffix> ZofBot: why is it called a rabbit hole if I'm chasing after bugs?

[14:14] <ZofBot> Zoffix, We are not turning Perl into any other existing language

[14:16] <dogbert11> Zoffix: can you see what happens during the ZOFFLOP, is anything logged to the console?

[14:16] <[Coke]> rabbit hole, bug hunt, yak shaving.

[14:24] <Zoffix> t/spec/S11-modules/require.t ...................................... Dubious, test returned 1 (wstat 256, 0x100)

[14:24] <Zoffix> No subtests run

[14:24] <Zoffix> t/spec/S11-modules/require.t                                    (Wstat: 256 Tests: 0 Failed: 0)

[14:24] <Zoffix> Non-zero exit status: 1

[14:24] <Zoffix> Parse errors: No plan found in TAP output

[14:24] <Zoffix> dogbert11: that's it

[14:24] <Zoffix> ZOFVM: Files=1242, Tests=133881, 115 wallclock secs (21.68 usr  3.22 sys + 2368.46 cusr 137.55 csys = 2530.91 CPU)

[14:26] <dogbert11> interesting, I'll try to reproduce it, are you running the perl5 harness?

[14:27] <Zoffix> Yes

[14:29] <nine> Well we can say that it's a compile time issue as there are 0 tests run

[14:35] <Geth> ¦ rakudo/nom: a995966617 | (Zoffix Znet)++ | src/core/Str.pm

[14:35] <Geth> ¦ rakudo/nom: Fix Str.comb(Int, $limit) for <1 combers

[14:35] <Geth> ¦ rakudo/nom:

[14:35] <Geth> ¦ rakudo/nom: We already equate such combers to `1`, but only did so if $limit was

[14:35] <Geth> ¦ rakudo/nom: effectively Inf.

[14:35] <Geth> ¦ rakudo/nom:

[14:35] <Geth> ¦ rakudo/nom: Add same behaviour for other $limits

[14:35] <Geth> ¦ rakudo/nom: review: https://github.com/rakudo/rakudo/commit/a995966617

[14:35] <Geth> ¦ rakudo/nom: aa711c1460 | (Zoffix Znet)++ | src/core/Str.pm

[14:35] <Geth> ¦ rakudo/nom: Fix Str.comb with empty-string comber

[14:35] <Geth> ¦ rakudo/nom:

[14:35] <Geth> ¦ rakudo/nom: - Make behave same as `1` comber

[14:35] <Geth> ¦ rakudo/nom: - We already do the same for <1 Int combers

[14:35] <Geth> ¦ rakudo/nom: - We already do the same for IO::Handle.comb

[14:35] <Geth> ¦ rakudo/nom: review: https://github.com/rakudo/rakudo/commit/aa711c1460

[14:36] <Geth> ¦ roast: a75a24c1e2 | (Zoffix Znet)++ | S32-str/comb.t

[14:36] <Geth> ¦ roast: Remove trailing whitespace

[14:36] <Geth> ¦ roast: review: https://github.com/perl6/roast/commit/a75a24c1e2

[14:36] <Geth> ¦ roast: b72f37f344 | (Zoffix Znet)++ | S32-str/comb.t

[14:36] <Geth> ¦ roast: Define Str.comb for empty-string Str / <1 Int combers

[14:36] <Geth> ¦ roast:

[14:36] <Geth> ¦ roast: - Equate to `1` as comber; that is split the string into characters

[14:36] <Geth> ¦ roast: - We already tested for this behaviour for empty-string Str in IO::Handle.comb

[14:36] <Geth> ¦ roast:   6.c-errata tests. This merely expands the tests to Str.comb and Int combers

[14:36] <Geth> ¦ roast: review: https://github.com/perl6/roast/commit/b72f37f344

[14:44] <Woodi> Zoffix: IO::Handle.comb is like: int fd = open(); fd.comb ? very strange if yes...

[14:46] <Zoffix> what?

[14:47] <Geth> ¦ rakudo/nom: 973338a6b7 | (Zoffix Znet)++ | src/core/IO/Handle.pm

[14:47] <Geth> ¦ rakudo/nom: [io grant] Fix IO::Handle.comb/.split; make them .slurp

[14:47] <Geth> ¦ rakudo/nom:

[14:47] <Geth> ¦ rakudo/nom: The current implementation has the following issues:

[14:47] <Geth> ¦ rakudo/nom: - The features of the two methods do not match those of Str versions

[14:47] <Geth> ¦ rakudo/nom: - Incorrect results are produced when the chunk to be produced overlaps

[14:47] <Geth> ¦ rakudo/nom:     the $*DEFAULT-READ-ELEMS boundary; e.g. .comb(65546) will return

[14:48] <Geth> ¦ rakudo/nom:     a 2-element list for a file with a `"x" x 65546` string in it; one

[14:48] <Geth> ¦ rakudo/nom: <…commit message has 14 more lines…>

[14:48] <Geth> ¦ rakudo/nom: review: https://github.com/rakudo/rakudo/commit/973338a6b7

[14:49] <Geth> ¦ roast: 2dac218a24 | (Zoffix Znet)++ | S32-io/io-handle.t

[14:49] <Geth> ¦ roast: Cover chunked-read issue in IO::Handle iter-producing read methods

[14:49] <Geth> ¦ roast:

[14:49] <Geth> ¦ roast: Rakudo fix and bug description in:

[14:49] <Geth> ¦ roast: https://github.com/rakudo/rakudo/commit/973338a6b7

[14:49] <Geth> ¦ roast: review: https://github.com/perl6/roast/commit/2dac218a24

[14:49] <Zoffix> Woodi: IO::Handle.comb is now IO::Handle.slurp.comb; it used to be similar to that except without .slurp and with bugs

[14:53] <Zoffix> And for IO::CatHandle I think I'll just throw as NYI in .comb/.split. IO::ArgFiles don't do those anyway, and implicitly .slurping all of files sounds like a recipe for disaster

[15:21] <Zoffix> ZOFFLOP: t/spec/S32-io/IO-Socket-INET.t  # doesn't so much flop, but starts hanging after I used the box for long enough time to have run 15+ stresstests

[15:25] <Zoffix> s/hanging/waiting for an already-taken port, I'd guess/

[15:25] <Woodi> Zoffix: IMO .comb and .split should be removed from Handle. and similiar. becouse they should operate on strings not file descriptors

[15:28] <timotimo> i'd expect an already taken port to cause an exception rather than a wait

[15:30] <Zoffix> ZOFFLOP: t/spec/S11-modules/nested.t

[15:30] <Zoffix> t/spec/S11-modules/nested.t .. Use of uninitialized value $repo-id of type Any in string context.

[15:30] <Zoffix> Methods .^name, .perl, .gist, or .say can be used to stringify it to something meaningful.

[15:30] <Zoffix> in any statement_control at ./blib/Perl6/Grammar.moarvm line 1

[15:30] <Zoffix> Use of uninitialized value $repo-id of type Any in string context.

[15:30] <Zoffix> Methods .^name, .perl, .gist, or .say can be used to stringify it to something meaningful.

[15:30] <Zoffix> in any statement_control at ./blib/Perl6/Grammar.moarvm line 1

[15:30] <Zoffix> ^ that output showed up after I re-ran the test

[15:31] <Zoffix> And does not show up again on further re-runs

[15:32] <Geth> ¦ rakudo/nom: 0bd39de255 | (Zoffix Znet)++ | src/core/Exception.pm

[15:32] <Geth> ¦ rakudo/nom: Make method name optional in X::Invalid::ComputedValue

[15:32] <Geth> ¦ rakudo/nom:

[15:32] <Geth> ¦ rakudo/nom: Sometimes we don't know what the user-facing method was used.

[15:32] <Geth> ¦ rakudo/nom: review: https://github.com/rakudo/rakudo/commit/0bd39de255

[15:33] <Geth> ¦ rakudo/nom: 60f898194f | (Zoffix Znet)++ | src/core/Baggy.pm

[15:33] <Geth> ¦ rakudo/nom: Throw on NaN values to Baggy.roll/.pick/.grab

[15:33] <Geth> ¦ rakudo/nom:

[15:33] <Geth> ¦ rakudo/nom: Fixes RT#131270: https://rt.perl.org/Ticket/Display.html?id=131270

[15:33] <Geth> ¦ rakudo/nom: review: https://github.com/rakudo/rakudo/commit/60f898194f

[15:33] <synopsebot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=131270

[15:34] <Geth> ¦ roast: b6073e1782 | (Zoffix Znet)++ | S02-types/baggy.t

[15:34] <Geth> ¦ roast: Test NaN is rejected in Baggy.pick/.grab/.roll

[15:34] <Geth> ¦ roast:

[15:34] <Geth> ¦ roast: RT#131270: https://rt.perl.org/Ticket/Display.html?id=131270

[15:34] <Geth> ¦ roast: Rakudo fix: https://rt.perl.org/rt3/Public/Bug/Display.html?id=131270

[15:34] <synopsebot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=131270

[15:34] <Geth> ¦ roast: review: https://github.com/perl6/roast/commit/b6073e1782

[15:35] <Zoffix> Woodi: says who?

[15:38] <dogbert11> Zoffix: wrt the ZOFFLOPS, could you be running out of some resource, e.g. FD's, memory or the like?

[15:39] <Zoffix> dogbert11: definitely not memory. FDs... dunno maybe

[15:39] <Zoffix> Probably not tho

[15:40] <Zoffix> I'm running with TEST_JOBS=30

[15:40] <dogbert11> my initial attempts to reproduce you errors have failed although that doesn't prove much

[15:41] <dogbert11> how much memory do you have, 32 gig?

[15:42] * Zoffix tries to repro with while t/fudgeandrun t/spec/S11-modules/require.t; do true; done

[15:42] * dogbert11 relocates &

[15:42] <Zoffix> dogbert11: 24GB

[15:42] <Zoffix> And when I had ~100GB or so, I got a google notice saying I never use that much and my VM can do with 21GB

[15:43] <Zoffix> I'd figure that's not the minimum RAM I could do with

[15:46] <perlpilot> Woodi: I dunno ... a file can be seen as a strange kind of string :)

[15:47] <Zoffix> By that logic we should also remove .lines and .words and force the user to do reads manually, because that's the way people did things in 1980s

[15:48] <perlpilot> Woodi: though ... why don't we have indexing on strings like we do on listy things?  That's probably most analogous to your opinion.

[15:48] <Woodi> perlpilot: my concern are string methods on file descriptor...

[15:48] <Zoffix> Because then the auto-1-item-list idiom breaks down and does the wrong thing any time you have a Str

[15:49] <Woodi> but I just map *NIX into here

[15:49] <Zoffix> Woodi: what's the concern tho?

[15:49] <Zoffix> You say they shouldn't be there without ever stating a reason.

[15:50] <Woodi> in C: int fd = open(...); strtok(fd);

[15:50] <perlpilot> that would be awesome.

[15:50] <Woodi> perlpilot: :)

[15:51] <Woodi> but IO::Handle is our low-level-ish module ?

[15:51] <Zoffix> It's normal-level

[15:59] <Zoffix> m: 1[1]

[15:59] <camelia> rakudo-moar 60f898: OUTPUT: «Index out of range. Is: 1, should be in 0..0␤  in block <unit> at <tmp> line 1␤␤Actually thrown at:␤  in block <unit> at <tmp> line 1␤␤»

[15:59] <Zoffix> m: dd (1,)[1]

[15:59] <camelia> rakudo-moar 60f898: OUTPUT: «Nil␤»

[15:59] <Zoffix> Feels discontinuous. I'd expect the two cases to be equivalent.

[16:07] <Zoffix> dogbert11: well, it's been running all this time and I didn't get any failures

[16:10] <Zoffix> dogbert11: I see both S11-modules/runtime.t and S11-modules/nested.t have `use lib 't/spec/packages/S11-modules';` maybe some issue with precomping some modules in it or something? 'cause IIRC some tests modify the module files in-situ. The fix might ivolve simply copying the files into `make-temp-dir` (from Test::Util) and performing the test there

[16:15] <geekosaur> while seeing what Woodi wants (and C does *not* provide), I think that's actually more on the level of the as yet unimplemented Cat?

[16:23] <Woodi> geekosaur: I provided C example of what I do not see in IO::Handle :)  but I loooong time ago proposed to have UNIX::read/write/printf/strncmp implemented via NativeCall :)  and for other OSes. then IO::Handle could be whatever we want :)  better streams then fread/fwrite from stdio.h ! better then C++ too !! ;)

[16:24] <Woodi> probably s/UNIX/Posix/

[16:27] <Zoffix> Woodi: so what does strtok do?

[16:27] <Woodi> exploits ;)

[16:27] <Woodi> man strtok_r

[16:28] * Zoffix shrugs

[16:28] <geekosaur> well, except we're not using stdio, we're using libuv

[16:28] <Zoffix> We do have .split. I don't see the difference

[16:28] <geekosaur> strtok is as close as C gets to parsing

[16:29] <geekosaur> which isn't very

[16:29] <geekosaur> it's also kinda disgusting, but then it's C >.>

[16:30] <Zoffix> And you say we don't have anything to in IO::Handle to split, right after saying that .comb and .split should be removed because they should operate on strings and not handles

[16:31] <geekosaur> Woodi wants an abstraction over anything that can produce strings, and the low level stuff in that view to be hidden low level stuff

[16:31] <geekosaur> my experience is you don't hide those, you need them too much. adding an additional higher level view has its place but you can't live off of it, you run into too many edge cases

[16:32] <geekosaur> one of those neat ideas that only works in a subset of real world situations in practice

[16:35] <Woodi> geekosaur: not me, perlpilot. and Zoffix :)

[16:35] <Zoffix> I wouldn't have added .split and .comb to IO::Handle without a Cat, but it's too late now

[16:35] <Zoffix> Well, even with Cat.

[16:36] <Zoffix> Due to the whole data loss thing

[16:37] <Zoffix> with "foo".IO.open { say .words.head; say .lines.head; } would loose data and give wrong .lines.head because .words reads more than it needs

[16:39] <Zoffix> Would have another class on top of IO::Handle that keeps the read data in some buffer on which all the methods operate, so no loss is done.

[16:39] <Zoffix> Though it's still crap due to iterators and laziness

[16:39] <Zoffix> ZofBot: it's a giant mess

[16:39] <ZofBot> Zoffix, Subroutines (keyword: "sub") are non-inheritable routines with parameter lists

[16:40] <Zoffix> But... there's always module space :)

[16:40] <geekosaur> that was one of the things I was hinting at, yes

[16:41] <geekosaur> Woodi more or less wants Haskell's conduit / pipes abstraction. that should likely be module space

[16:41] <Woodi> Zoffix: if thing is specced that way then oki. but I think IO::Handle is just our fat file descriptor so string methods not fit into it. .x .rw are for fd

[16:42] <geekosaur> right you want conduit/pipes.

[16:42] <Woodi> like in good old OOP :)

[16:42] <geekosaur> don't build that into the core

[16:43] <Zoffix> Woodi: we don't have .x .rw on handles though. Only IO::Paths

[16:43] <Woodi> geekosaur: ok, so what IO::Handle is ?

[16:43] <geekosaur> you've already claoimed what it is is a thing that never has any reason to exist so I guess that is unanswerable

[16:43] <Woodi> Zoffix: that is mistake too, we talk this few weeks ago

[16:43] <geekosaur> since, you seem to think perl 6 should be so high level that low level is nonexistent

[16:43] <geekosaur> my claim is that nobody is at that level, for a reason

[16:44] <Zoffix> Woodi: it's only a mistake because you want IO::Handle be the same thing as whatever C does

[16:44] <geekosaur> C does not do this

[16:44] <geekosaur> Woodi wants ultra high level to be the only level. C doesnt do high level much less ultra high level

[16:44] <Zoffix> File handles have modes in C, don't they

[16:45] <Zoffix> read write whateverf

[16:45] <geekosaur> Woodi is saying those belong to file descriptors, and the only level above that is a magical String abstraction

[16:45] <Woodi> Zoffix: I want clear distinction, what IO::Handle is responsible for. file descriptor is so far moust sensible functionality. but not saying it *must* be same as in low level space

[16:45] <geekosaur> which is pipes/conduit in Haskell, or emulated with lazy I/O (getContrnts and friends) which are a constant source of bugs

[16:47] <Woodi> I *realy* thinked we have IO already specced :)

[16:47] <Zoffix> Woodi: there's really no file descriptors in Perl 6. There's a method you can get a number from, but you can't do anything with them. So saying IO::Handle is file descriptor is kinda meh

[16:47] <geekosaur> oh, also you keep talking about how it should be based on POSIX

[16:47] <geekosaur> should we discontinue Windows support?

[16:48] <geekosaur> (also POSIX does not spec the things you asked for)

[16:48] <Woodi> geekosaur: *nix is just example. but in other os'es it's exactly the same: file description, read write etc :)

[16:48] <Zoffix> Woodi: IO::Handle let's you read/write data from files and pipes. That's all the description it needs IMO

[16:49] <geekosaur> Woodi, on Windows a socket is not a file descriptor

[16:49] <geekosaur> there is a horrible and extremely fragile hack that tries to pretend that it is

[16:49] <Woodi> Zoffix: still looks like abstraction over file descriptor :)

[16:49] <Zoffix> I don't care what *nix/C can do with file descriptors. It's not IO::Handle"s concern

[16:49] <Zoffix> Nor do I care what a "file descriptor" or "strtok" is.

[16:50] <perlpilot> Perl 6 does quite a bit to blur distinctions so that things Just Work.

[16:51] <perlpilot> I mean that's one of the reasons we don't normally make the programmer think about the details of how numbers are implemented (for instance), they're just numbers in the mathematical sense.

[16:51] <perlpilot> or why the idea of "hashref" has given way to just "hash"

[16:52] * Zoffix is getting distracted again by IRC

[16:52] <Zoffix> We need #perl6-dev-dev... like #perl6-dev but queter

[16:52] <Zoffix> :)

[16:53] <Woodi> Zoffix: you should care becouse you delegate to them via libuv. and libuv is just universal abstraction over OSes raw functionalities. to me, so far, IO::Handle is just another wrapper with few additions

[16:54] <geekosaur> no

[16:54] <geekosaur> or, perhaps, now you want to kill off jvm and javascript backends?

[16:54] <Zoffix> Woodi: I don't delegate anything to libuv. I'm using nqp ops

[16:55] <Woodi> ok, I just skipped on layer :)  still not spec what IO::Handle do

[16:55] <Zoffix> We have a decent spec in roast and docs.

[16:56] <Woodi> looking...

[16:56] <geekosaur> it abstracts over multiple possible lower levels, not all of which are your file-descriptor-which-is-clearly-always-there even though I just pointed out a case on Windows where it is not

[16:56] <Zoffix> This feels like faffing about.

[16:56] <geekosaur> apparently speccing a wrapper over an implementation detail is wasteful and pointless, so we should pick one backend and code to it only

[16:56] <Zoffix> Just talk about removing methods or something missing in IO Handle and no specs, without anything doable or concrete.

[16:57] * Zoffix places this conversation on ignore...

[17:01] <Woodi> ok, https://docs.perl6.org/type/IO::Handle do exactly what "file descriptor" :)  off too.

[17:06] <geekosaur> right, abstractions are evil

[17:07] <geekosaur> code to the bare metal, specific bare metal since you can't have evil backends that let you support some other hardware. perfect

[17:07] <Woodi> geekosaur: you just assume too much

[17:07] <geekosaur> you want to know what IO::Handle is

[17:07] <geekosaur> I told you

[17:08] <geekosaur> you rejected it

[17:08] <geekosaur> I can only see one reason to reject it: you don't care about abstraction over different backends, you want IO::Handle to either be the backend or get out of the way. therefore abstraction is obviously pointless and wrong

[17:11] <Woodi> geekosaur: no. I want nice abstraction too. you assume I want bare metal. but thing is that current IO::Handle *is* bare metal wrapped 4 times :) + a) .split; b) .comb :)

[17:11] <geekosaur> no, it is not

[17:11] <geekosaur> or.

[17:11] <Woodi> https://docs.perl6.org/type/IO::Handle

[17:11] <geekosaur> and ity has been pointed out that they don;t belong there

[17:12] <Woodi> we still don't started that nice abstraction. it's raw fd functionality

[17:12] <geekosaur> mpo, split and comb don;t work on file descriptors in any language

[17:12] <geekosaur> *no,

[17:12] <geekosaur> your C example was nonsense

[17:12] <Woodi> geekosaur: by design !!!!

[17:12] <geekosaur> and split and comb don't belong on IO::Handle althoygh I bet someone put it there as an optimization (a bad one)

[17:13] <geekosaur> and you still think file descriptors are the only backend when I pointed out a case where they are not

[17:14] <geekosaur> which you conveniently ignored, possibly because so many things insist on using the fundamentally broken winsock wrapper that makes sockets almost look like file descriptors as long as you don;t breathe around them

[17:14] <geekosaur> (Haskell ditched that wrapper entirely because it's so fragile and unworkable)

[17:15] <Woodi> geekosaur: I know *nix and win only... so in my situation I didn't ignore anything :)

[17:15] <geekosaur> but, you've made up your mind. enjoy the breakage

[17:16] <geekosaur> you don;t know win if you think file descriptors are *the* backend

[17:16] <geekosaur> in partivcular you;ve never worked seriously with winsock except through wrappers that hide the breakage from you

[17:16] <geekosaur> *wrappers*

[17:16] <geekosaur> the things you think are pointless and should go away

[17:18] <Woodi> geekosaur: pleas stop... you said  "split and comb don't belong on IO::Handle" and that is what I say from the start. some strange circles here

[17:19] <Woodi> and every body wants nice abstraction but so far we have fd wrapped x times

[17:19] <geekosaur> and uypu just repeated the completely wrong again

[17:19] <[Coke]> I can't even follow at this point what geekosaur's position is.

[17:19] <geekosaur> figures

[17:20] <[Coke]> Can you state it for me?

[17:20] <geekosaur> yes, fine, fuilke descriptor is the perfect abstraction layer, it is never broken especially on winsock where it is fundamentally broken but no it is never broken

[17:20] <Woodi> geekosaur: we have libuv only + jvm, right ?

[17:21] <[Coke]> Woodi: also a partial js.

[17:21] <MasterDuke_> wasn't libuv written for Node.js?

[17:22] <Woodi> ok, probably we should add more .comb and .split like Zoffix++ proposed and we will have some abstraction over fd :)

[17:22] <geekosaur> ...

[17:22] <geekosaur> I have been talking abotu how file descriptrs ARE BROKEN

[17:22] <geekosaur> this is 100% ignored

[17:22] <geekosaur> I guess that's my answer

[17:23] <Woodi> geekosaur: I think not-Haskellers don't know this. where I can read about that ?

[17:24] <geekosaur> https://msdn.microsoft.com/en-us/library/windows/desktop/ms740516(v=vs.85).aspx

[17:24] <geekosaur> firrst thing it says: IS NOT A FILE DESCRIPTOR

[17:25] <geekosaur> windows stdio (ONLY STDIO NOT LOWER LEVELS) will try to pretend for you, up to the point where it breaks

[17:25] <[Coke]> geekosaur: are you upset because people are using sloppy (and/or incorrect) terminology? Or that we should be changing our implementation? Or that someone has proposed something you feel is technically inappropriate?

[17:25] <[Coke]> I get that you're frustrated, but it's hard for me to see what exactly is the frustrating bit here.

[17:26] <geekosaur> Woodi either wants raw file descriptors or something like Haksell pipes/condduit, anything in between is pointless wrapping

[17:26] <[Coke]> please don't characterize what woodi wants. I'm asking you what you want.

[17:26] <geekosaur> I pointed out file descriptors don;t work for everything even if you limit to win/unix, and only now is *maybe* that being acknowledged. Maybe.

[17:27] <geekosaur> I pointed out that wrapping is necessary because of bugs that need to be worked around, this is ignored still

[17:27] <geekosaur> I pointed out that different backends offer different things and not all of them are "file descriptor"-like, this is ignored still

[17:28] <[Coke]> geekosaur: ignored by whom?

[17:28] <geekosaur> [08 17:11:14] <Woodi> geekosaur: no. I want nice abstraction too. you assume I want bare metal. but thing is that current IO::Handle *is* bare metal wrapped 4 times :) + a) .split; b) .comb :)

[17:29] <geekosaur> this AFTER I pointed these things out, they're obviously not enough reason for wrapping the file descriptor that is defined as the only correct abstraction even though I had already pointed out it was wrong

[17:29] <Woodi> yes, didn't thinked about network :)

[17:30] <geekosaur> I am not continuing this. I consider myself answered and will be looking out for breakage from now on

[17:30] <Woodi> geekosaur: but read this again: a)  <Woodi> geekosaur: no. I want nice abstraction too.  b)  but thing is that current IO::Handle *is* bare metal wrapped 4 times :   in I described reality

[17:33] <[Coke]> I don't read woodi's send as ignoring your comment at all. he doesn't even mention FDs in the first one you quote.

[17:34] <[Coke]> I think perhaps stepping away for a bit as you suggest is a good idea, yes.

[17:34] * [Coke] drifts away back to $dayjob

[18:10] <MasterDuke_> nqp: my %h := nqp::hash("a", "b", "c", "d"); say(nqp::atpos(%h, 0))

[18:10] <camelia> nqp-moarvm: OUTPUT: «This representation (VMHash) does not support positional access (for type BOOTHash)␤   at <tmp>:1  (<ephemeral file>:<mainline>)␤ from gen/moar/stage2/NQPHLL.nqp:1588  (/home/camelia/rakudo-m-inst-1/share/nqp/lib/NQPHLL.moarvm:eval)␤ from gen/moar/stage2/N…»

[18:11] <MasterDuke_> lizmat: locally i have a patch for MoarVM such that ^^^ returns `b`, is that what you wanted?

[18:12] <lizmat> MasterDuke_: yeah, just about  :-)

[18:12] <yoleaux> 13:12Z <AlexDaniel> lizmat: MasterDuke said that you may be interested in RT #131270

[18:12] <synopsebot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=131270

[18:14] <AlexDaniel> m: say ^5 .BagHash.pick(2.5)

[18:14] <camelia> rakudo-moar 60f898: OUTPUT: «count computed to 2.5, which cannot be used␤  in block <unit> at <tmp> line 1␤␤»

[18:14] <MasterDuke_> lizmat: cool, anything else in particular or should i PR it?

[18:15] <AlexDaniel> it's interesting that in some places we .Int-ify stuff, and in others it just refuses to work

[18:15] <lizmat> MasterDuke_ : please PR it so that jnthn can have a look at it

[18:15] <AlexDaniel> m: say ^5 .BagHash.pick(2)'

[18:15] <camelia> rakudo-moar 60f898: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Two terms in a row␤at <tmp>:1␤------> 3say ^5 .BagHash.pick(2)7⏏5'␤    expecting any of:␤        infix␤        infix stopper␤        postfix␤        statement end␤        statement mo…»

[18:15] <AlexDaniel> m: say ^5 .BagHash.pick(2)

[18:15] <camelia> rakudo-moar 60f898: OUTPUT: «(4 2)␤»

[18:15] <AlexDaniel> m: say ^5 .BagHash.pickpairs(2)

[18:15] <camelia> rakudo-moar 60f898: OUTPUT: «(2 => 1 0 => 1)␤»

[18:15] <AlexDaniel> m: say ^5 .BagHash.pickpairs(2.5)

[18:15] <camelia> rakudo-moar 60f898: OUTPUT: «(3 => 1 1 => 1)␤»

[18:15] <AlexDaniel> m: say ^5 .BagHash.pick(2.5)

[18:15] <camelia> rakudo-moar 60f898: OUTPUT: «count computed to 2.5, which cannot be used␤  in block <unit> at <tmp> line 1␤␤»

[18:16] <AlexDaniel> :|

[18:24] <MasterDuke_> lizmat: PR'ed

[18:24] <lizmat> MasterDuke_++

[18:26] <AlexDaniel> screw it. RT #131272

[18:26] <synopsebot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=131272

[18:45] <Geth> ¦ rakudo/nom: 31be51284e | (Elizabeth Mattijsen)++ | src/core/Baggy.pm

[18:45] <Geth> ¦ rakudo/nom: Better fix for RT #131270, fixes RT #131272

[18:45] <Geth> ¦ rakudo/nom:

[18:45] <Geth> ¦ rakudo/nom: This breaks the latest added too specific tests for RT #131270.

[18:45] <Geth> ¦ rakudo/nom: review: https://github.com/rakudo/rakudo/commit/31be51284e

[18:45] <synopsebot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=131270

[18:45] <synopsebot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=131272

[18:45] <synopsebot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=131270

[18:56] <AlexDaniel> so what's the rule of thumb?

[18:56] <AlexDaniel> “if a non-int argument makes no sense, it is intified”?

[18:57] <AlexDaniel> e: say ^5 .BagHash.pick(2.5)

[18:57] <evalable6> AlexDaniel, rakudo-moar 31be51284: OUTPUT: «(1 0)»

[18:57] <AlexDaniel> e: say ^5 .BagHash.pick(-2.5)

[18:57] <evalable6> AlexDaniel, rakudo-moar 31be51284: OUTPUT: «(3 0 1 4 2)»

[18:57] <AlexDaniel> e: say ^5 .BagHash.pickpairs(-2.5)

[18:57] <evalable6> AlexDaniel, rakudo-moar 31be51284: OUTPUT: «(exit code 1) Unable to allocate an array of 18446744073709551614 elements␤  in block <unit> at /tmp/p5a9fTqCqs line 1␤»

[18:57] <AlexDaniel> what the f

[18:58] <AlexDaniel> c: HEAD~100 say ^5 .BagHash.pickpairs(-2.5)

[18:58] <committable6> AlexDaniel, ¦HEAD~100: «Coercion to UInt out of range. Is: -2, should be in 0..^Inf␤  in block <unit> at /tmp/YU1w1WC3Ky line 1␤␤Actually thrown at:␤  in block <unit> at /tmp/YU1w1WC3Ky line 1␤ «exit code = 1»»

[18:58] <lizmat> AlexDaniel: oooh wow

[18:58] <AlexDaniel> bisect: good=HEAD~100 say ^5 .BagHash.pickpairs(-2.5)

[18:58] <bisectable6> AlexDaniel, Bisecting by output (old=HEAD~100 new=31be512) because on both starting points the exit code is 1

[18:58] <bisectable6> AlexDaniel, bisect log: https://gist.github.com/9098a03c04deb2a2004724e40cf5c63e

[18:58] <bisectable6> AlexDaniel, (2017-05-07) https://github.com/rakudo/rakudo/commit/0f21f511c5631545293c3d8812f8dcf5addd988f

[18:58] * lizmat looks

[19:02] <AlexDaniel> lizmat: don't really have time to follow it, so I thought I'll file a ticket just in case: RT #131273

[19:02] <synopsebot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=131273

[19:06] <AlexDaniel> buggable: tag REGRESSION

[19:06] <buggable> AlexDaniel, There are 18 tickets tagged with REGRESSION; See http://perl6.fail/t/REGRESSION for details

[19:08] <Geth> ¦ rakudo/nom: 08b5c1019f | (Elizabeth Mattijsen)++ | src/core/Rakudo/QuantHash.pm

[19:08] <Geth> ¦ rakudo/nom: Fix for RT #131273

[19:08] <Geth> ¦ rakudo/nom: review: https://github.com/rakudo/rakudo/commit/08b5c1019f

[19:08] <synopsebot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=131273

[19:08] <AlexDaniel> as long as I am stumbling upon these before users, I think everything is great :)

[19:09] <lizmat> :-)

[19:10] <AlexDaniel> I have some lovely ideas for regressionable bot, but this won't happen before June :(

[19:17] <Geth> ¦ rakudo/nom: 20cfd6b7c6 | (Elizabeth Mattijsen)++ | src/core/Rakudo/QuantHash.pm

[19:17] <Geth> ¦ rakudo/nom: Move count validity check to PICK-N

[19:17] <Geth> ¦ rakudo/nom:

[19:17] <Geth> ¦ rakudo/nom: So we won't have to repeat that in the future

[19:17] <Geth> ¦ rakudo/nom: review: https://github.com/rakudo/rakudo/commit/20cfd6b7c6

[19:33] <Zoffix> split and comb fit nicely into IO::Handle if we have Cat

[19:34] * Zoffix boggles at screenfulls of mindless bickering abou it

[19:35] <samcv> morning o/

[19:35] <Zoffix> \o

[19:48] <Geth> ¦ roast: 42a4bc6112 | (Zoffix Znet)++ | S02-types/baggy.t

[19:48] <Geth> ¦ roast: Adjust exception looked for by tests

[19:48] <Geth> ¦ roast:

[19:48] <Geth> ¦ roast: To accomodate https://github.com/rakudo/rakudo/commit/31be51284e

[19:48] <Geth> ¦ roast:

[19:48] <Geth> ¦ roast: The tests went in a few hours ago and are not part of 6.c-errata

[19:48] <Geth> ¦ roast: review: https://github.com/perl6/roast/commit/42a4bc6112

[19:50] <MasterDuke_> google offers $ rewards for integrating with their free fuzzing tool https://opensource.googleblog.com/2017/05/oss-fuzz-five-months-later-and.html

[20:22] <Zoffix> ZofBot: IT'S A TRAP!

[20:22] <ZofBot> Zoffix, Str); }; say now - INIT now rakudo-moar 6f3de6: OUTPUT: «5040␤0

[20:49] <Zoffix> m: dd "foo".comb: "o"

[20:49] <camelia> rakudo-moar 20cfd6: OUTPUT: «("o", "o").Seq␤»

[20:49] <Zoffix> m: dd "foo".comb: /o/

[20:49] <camelia> rakudo-moar 20cfd6: OUTPUT: «("o", "o")␤»

[20:50] <timotimo> not a seq?

[20:50] <Zoffix> No

[20:51] * Zoffix is mildly annoyed by that inconsistency

[20:51] <Zoffix> 'cause I'm documenting IO::Path.comb and now I can't put the `--> Foo` and indicate what it returnes, like I do for all other methods :/

[20:52] <MasterDuke_> is that explicitly tested behavior?

[20:53] <Zoffix> Doubt it, since IIRC this got changed some time in october/november and tests didn't pick it up

[20:54] <lizmat> Zoffix: fwiw, I think it should be a Seq, so please RT it

[20:54] <Zoffix> OK

[20:55] <MasterDuke_> changing topics, would anybody object to also making `dd` a method? and wouldn't it make more sense in Mu.pm?

[20:55] * moritz objects

[20:55] <moritz> we already have .perl as a method

[20:55] <lizmat> FWIW, this came up last week at the Amsterdam PM meeting

[20:55] <moritz> and shouldn't add short method to Mu

[20:55] <lizmat> and I agree with moritz

[20:56] <lizmat> dd is a debugging aid

[20:56] * Zoffix objects to dd as method

[20:56] <MasterDuke_> moritz: "shouldn't add short method to Mu"? short in name?

[20:57] <moritz> MasterDuke_: yes

[20:57] <MasterDuke_> why would the length of the name matter?

[20:58] <moritz> (we should also be careful with adding more method to Mu at all, but especially with short names)

[20:58] <moritz> MasterDuke_: because they have a bigger potential to collide with user-supplied methods/attributes

[20:58] <Zoffix> It's an unspecced debugging routine whose presence that doesn't affect anything and is easy to change in subsequent language versions. It as a method would make it present in all objects, will interefere with augmentations, would show up in .^methods(:all), and is hard to change between language versions.

[21:00] <moritz> also stuff that prints directly to $*OUT/$*ERR is much less extensible than methods that just return something

[21:00] <moritz> which why we have .perl as a method in Mu, but not .dd

[21:03] <Zoffix> m: say WHAT "foo".match: /o/, :x(42)

[21:03] <camelia> rakudo-moar 20cfd6: OUTPUT: «(Slip)␤»

[21:03] <Zoffix> m: say WHAT "foo".match: /o/, :x(1)

[21:03] <camelia> rakudo-moar 20cfd6: OUTPUT: «(List)␤»

[21:04] <Zoffix> Well, .comb returns a List for that one case because it uses .match and match returns a List

[21:08] <Zoffix> m: with (1, 2, 3).Seq { .join; .join }

[21:08] <camelia> rakudo-moar 20cfd6: OUTPUT: «This Seq has already been iterated, and its values consumed␤(you might solve this by adding .cache on usages of the Seq, or␤by assigning the Seq into an array)␤  in block <unit> at <tmp> line 1␤␤»

[21:10] <Zoffix> Wonder if Seqs made from Lists can be pre-cached. 'cause it's already got a List invovled. We could just shove it into Seq.$!list and have all the things the same, except you'd get cache too, no?

[21:10] <lizmat> sounds like a plan to me

[21:15] * Zoffix tries

[21:33] <jnthn> I'm not sure it's entirely wise

[21:34] <Zoffix> jnthn: how come?

[21:34] <jnthn> It will break .Seq consistently giving you something that you can iterate once, unless you use .cache on it

[21:34] <timotimo> right, accidentally rely on it and boom, you're done

[21:35] <jnthn> I can imagine somebody writing code that passes its tests because the test has a hard-coded list of test data, then explodes in real use when it's given a Seq from some other source

[21:35] <Zoffix> jnthn: I recall you saying the throwage due to iterating a non-cachede Seq twice isn't meant to be realied upon

[21:36] <Zoffix> And it's very easy to indirectly end up with a cached seq

[21:36] <Zoffix> m: with (1, 2, 3).Seq { .[0]; .join; .join }

[21:36] <camelia> rakudo-moar 20cfd6: ( no output )

[21:36] <Zoffix> There are 11 test failures tho... so the discussion may be moot.

[21:37] <jnthn> I wasn't intending the end result to be a "feature" that makes producing reliable code harder. :S

[21:38] <Zoffix> Right now it's a feature that duplicates data

[21:39] <Zoffix> Well, not

[21:39] <Zoffix> It is duplicated if you cache a seq made from list

[21:39] <jnthn> I don't buy that. If code is written to explicitly take a Seq, then in all likelihood it's going to be doing something pipeline-y with it

[21:39] <jnthn> And if it's not written to explicitly take a Seq, jsut some Iterable or Positional, you'd not have been doing a .Seq coercion in the first place.

[21:40] <jnthn> Just passing it the original thing.

[21:41] * jnthn struggles to remember a case where he wrote .Seq in code that wasn't test code...

[21:42] <Zoffix> I have it as my HEAD. Coercing List returned by Str.match to .Seq to keep consistent Seq-y interface of .comb

[21:44] <jnthn> Str.match with :g ?

[21:44] <Zoffix> Yeah

[21:45] * jnthn is mildy surprised that doesn't return Seq :)

[21:46] <jnthn> If we already have factored it so .match with :g calls down to some internal thing, though, perhaps that could just produce an Iterator, and .match can form a List from it, and comb a Seq.

[21:48] <jnthn> Yeah, looks like self!match-list is worth taking a look at

[21:48] <jnthn> heh

[21:48] <jnthn> Inside of there it's making a Seq and then .list-ing it :P

[21:51] <Zoffix> That's probably because during Great Match Refactor there was the same inconsistency with Str.match as with Str.comb right now, where some combination of args returned a List while another a Seq

[21:53] <lizmat> and another Perl 6 Weekly hits the Net: https://p6weekly.wordpress.com/2017/05/08/2017-19-albatross_i/

[21:54] <Zoffix> OK. All test failures were my mess up. They're green now, with the exception of non-6.c-errata test for RT#127492

[21:54] <synopsebot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=127492

[21:54] <Zoffix> jnthn: so no, I should not push it?

[21:54] <jnthn> Indeed...I think making List.Seq magically cache is probably a bit of a big hammer to fix .comb efficiently, though. Seems a more local refactoring would be preferable.

[21:54] <Zoffix> it = List.Seq autocaching

[21:55] <jnthn> I'd prefer not; it feels like a rough edge people will hurt themselves on every so often, and it will be a pain to debug.

[21:56] <Zoffix> OK

[21:57] <Zoffix> lizmat++ # good weekly

[21:57] <jnthn> lizmat++

[21:58] <jnthn> Always see some things I've missed in the weekly :)

[22:22] <cog_> lizmat++

[22:25] <cog_> about telemeh. How can one read number of cycles? Probably should read the branch to know

[22:25] <timotimo> search for rdtscp

[22:26] <timotimo> that's an x86 instruction that reads a performance counter

[22:26] <cog_> thx, nice

[22:26] <timotimo> it's cool

[22:26] <timotimo> it's also a nightmare to figure out how to correctly complie or refuse to compile stuff based on the running (or target) system

[22:27] <cog_> cuz people here are knowledgeable and cool

[22:28] <cog_> yea, it must be very architecture dependant

[23:03] <Zoffix> method { 'foo' } shows up in bench with some time, but method (--> 'foo') {} always shows 0%

[23:05] <timotimo> Zoffix: wow, not even inlining can do that!

[23:05] <timotimo> unless it actually can?!

[23:06] <timotimo> i mean, if the body of the function is so short that two consecutive calls to "get time from the clock please" just gives the same number for accuracy or caching reasons or something?

[23:06] <Zoffix> I was thinking more along the lines of the bench doesn't catch the run?

[23:06] <Zoffix> Because it got empty body and all the "work" is in the signature?

[23:10] <Zoffix> Profiled this now and the --> 'foo' form is ~7 percentage points faster, but I dunno if that's real or not :)

[23:12] <timotimo> hm. i don't think the static optimizer can throw method calls away. only private methods because it can resolve those at compile time, right?

[23:13] <timotimo> i *think* if you turn on spesh logging with the profiler active it'll actually show you the places where the profiler emits its "log a call starting here" and "log the call ending here" things

[23:13] <timotimo> it also makes those for inlined things

[23:17] <timotimo> for something to appear in the call graph at all, i believe it has to hit those, i don't think there's another way for that to happen

[23:17] <timotimo> does the number of entries match up with your expectations?

[23:18] <Zoffix> The number is 1, so yeah.

[23:19] <Zoffix> This is what I profiled: https://gist.github.com/zoffixznet/de80ca68549982c6b453bd4e60e8e64a

[23:19] <timotimo> maybe we're just rounding it not-too-well? but i think i saw like 0.1% entries or something?

[23:19] <timotimo> huh, i wouldn't expect a bench that short to give reasonable results

[23:20] <Zoffix> and if I stick method calls into subs (e.g. sub x { Foo.spurt2 }), then the signature method consistently gives ~6 percentage points smaller time, but I don't know if that's real or not.

[23:20] <Zoffix> timotimo: so it has to iterate multiple times, just like when we do `now - INIT now` thing?

[23:21] <timotimo> hmm. i wouldn't say it has to, but i wouldn't trust a measurement with N=1

[23:21] <Zoffix> OK

[23:21] <timotimo> anyway, to figure out stuff such as this i'd generally turn on spesh logging and make sure the functions i'm looking at get moderately ho

[23:21] <timotimo> hot*

[23:21] <timotimo> because then you'll see the bytecode we'll actually end up running

[23:22] <timotimo> omg the cat is being adorable right next to me

[23:22] <timotimo> away from keyboard, engaging kitty cuddles mode

[23:23] <Zoffix> Well, I don't execute these methods 100_000 times in my code; just a few times, so they probably don't get speshied or wahteverr

[23:24] <Zoffix> And if I do 1000_000 iterations, 99.46% ends up for sink and both my methods are 0% :/

[23:37] <timotimo> hmm

[23:37] <timotimo> feel free to xz the spesh log and toss it over

[23:38] * Zoffix is too tired to do anything today

[23:40] <timotimo> no prob

[23:40] <timotimo> i'll go to bed soon, too
