[00:26] <travis-ci> Rakudo build passed. Elizabeth Mattijsen 'Don't use private method for AT-KEY-CONTAINER

[00:26] <travis-ci> https://travis-ci.org/rakudo/rakudo/builds/359300928 https://github.com/rakudo/rakudo/compare/8e2ee64e48fe...29b7f464e670

[01:05] <Geth> ¬¶ nqp: e82bf8a97c | (Jeremy Studer)++ | src/vm/moar/profiler/template.html

[01:05] <Geth> ¬¶ nqp: Profiler Template: Sort by time Instead of Pct

[01:05] <Geth> ¬¶ nqp:

[01:05] <Geth> ¬¶ nqp: Have the code in the profiler page sort by InclusiveTime/ExclusiveTime

[01:05] <Geth> ¬¶ nqp: values instead of percent. Fixes subtle misordering of routines.

[01:05] <Geth> ¬¶ nqp: review: https://github.com/perl6/nqp/commit/e82bf8a97c

[02:22] <Geth> ¬¶ nqp: b73a9b60bc | (Zoffix Znet)++ | tools/build/MOAR_REVISION

[02:22] <Geth> ¬¶ nqp: [MoarVM Bump] Brings 4 commits

[02:22] <Geth> ¬¶ nqp:

[02:22] <Geth> ¬¶ nqp: MoarVM bump brought: https://github.com/MoarVM/MoarVM/compare/2018.03-31-gfdb5e4d6b...2018.03-35-gafdcad4

[02:22] <Geth> ¬¶ nqp: afdcad4 Use char* for pointer addition to please MSVC

[02:22] <Geth> ¬¶ nqp: 32d66d5 Speed up index 50% for flat haystack and diff type needle

[02:22] <Geth> ¬¶ nqp: 15b4b9f Fix compiler warning by explicitly casting to MVMuint8*

[02:22] <Geth> ¬¶ nqp: fc7da5c fix bytecodedump to understand inlines

[02:22] <Geth> ¬¶ nqp: review: https://github.com/perl6/nqp/commit/b73a9b60bc

[02:22] <Geth> ¬¶ nqp: version bump brought these changes: https://github.com/MoarVM/MoarVM/compare/2018.03-31-gfdb5e4d6b...2018.03-35-gafdcad4

[02:22] <Geth> ¬¶ rakudo: 23af1f4aae | (Zoffix Znet)++ | tools/build/NQP_REVISION

[02:22] <Geth> ¬¶ rakudo: [NQP Bump] Brings 3 commits

[02:22] <Geth> ¬¶ rakudo:

[02:22] <Geth> ¬¶ rakudo: NQP bump brought: https://github.com/perl6/nqp/compare/2018.03-37-g833364342...2018.03-40-gb73a9b6

[02:22] <Geth> ¬¶ rakudo: b73a9b6 [MoarVM Bump] Brings 4 commits

[02:22] <Geth> ¬¶ rakudo: e82bf8a Profiler Template: Sort by time Instead of Pct

[02:22] <Geth> ¬¶ rakudo: 0736a0c [JVM] Adjust 'getrusage' to fix rakudo build

[02:22] <Geth> ¬¶ rakudo:

[02:22] <Geth> ¬¶ rakudo: <‚Ä¶commit message has 5 more lines‚Ä¶>

[02:22] <Geth> ¬¶ rakudo: review: https://github.com/rakudo/rakudo/commit/23af1f4aae

[02:22] <Geth> ¬¶ rakudo: version bump brought these changes: https://github.com/perl6/nqp/compare/2018.03-37-g833364342...2018.03-40-gb73a9b6

[02:46] <travis-ci> Rakudo build passed. Zoffix Znet 'Ignore whole /gen

[02:46] <travis-ci> https://travis-ci.org/rakudo/rakudo/builds/359348726 https://github.com/rakudo/rakudo/compare/1fff4f106ade...68a576e62e64

[03:23] <travis-ci> Rakudo build passed. Elizabeth Mattijsen 'Implement Array.grab, as discussed in GH R#1658'

[03:23] <travis-ci> https://travis-ci.org/rakudo/rakudo/builds/359406934 https://github.com/rakudo/rakudo/compare/82a0e706537d...a0e5e880580c

[03:23] <synopsebot> R#1658 [open]: https://github.com/rakudo/rakudo/issues/1658 [@LARRY][NYI][testneeded] Why do Array / Hash not have .grab like QuantHashes do?

[03:58] <travis-ci> Rakudo build passed. Elizabeth Mattijsen 'Merge pull request #1664 from rakudo/fails-like

[03:58] <travis-ci> https://travis-ci.org/rakudo/rakudo/builds/359414496 https://github.com/rakudo/rakudo/compare/68a576e62e64...82a0e706537d

[04:37] <travis-ci> Rakudo build passed. Elizabeth Mattijsen 'Remove some leftover code

[04:37] <travis-ci> https://travis-ci.org/rakudo/rakudo/builds/359433086 https://github.com/rakudo/rakudo/compare/a0e5e880580c...ce82292562a4

[06:57] <samcv> i think i've decreased the runtime by 1/2 of that script

[06:57] <samcv> if everything is going fine :) got it down to 6 seconds from 11.5 to get to 256kb

[07:04] <travis-ci> Rakudo build passed. Elizabeth Mattijsen 'Move proto method splice: Mu -> Any

[07:04] <travis-ci> https://travis-ci.org/rakudo/rakudo/builds/359589156 https://github.com/rakudo/rakudo/compare/f97398cfb8cf...88d61bd94527

[07:12] <[Tux]> Rakudo version 2018.03-122-g23af1f4aa - MoarVM version 2018.03-35-gafdcad424

[07:12] <[Tux]> csv-test-xs-20      0.467 -  0.504

[07:12] <[Tux]> csv-ip5xs           0.911 -  1.002

[07:12] <[Tux]> test-t --race       1.030 -  1.108

[07:12] <[Tux]> test-t              2.510 -  2.587

[07:12] <[Tux]> csv-ip5xs-20        8.790 -  9.000

[07:12] <[Tux]> test                9.201 -  9.475

[07:12] <[Tux]> test-t-20 --race   15.505 - 18.882

[07:12] <[Tux]> csv-parser         37.820 - 39.399

[07:12] <[Tux]> test-t-20          46.053 - 46.464

[07:39] <lizmat> Files=1238, Tests=76257, 310 wallclock secs (14.69 usr  5.26 sys + 2124.06 cusr 206.65 csys = 2350.66 CPU)

[07:43] <samcv> since this is such a common codepath i tried really hard to get as many tight loops as possible. even though i may need many more loops and fallthroughs

[07:46] <travis-ci> Rakudo build passed. usev6 '[JVM] Work around problem with native arrays

[07:46] <travis-ci> https://travis-ci.org/rakudo/rakudo/builds/359591592 https://github.com/rakudo/rakudo/compare/88d61bd94527...aaacc5a4537c

[07:58] <Geth> ¬¶ rakudo: 05816139ea | (Elizabeth Mattijsen)++ | src/core/Proc.pm6

[07:58] <Geth> ¬¶ rakudo: Implement Proc.pid

[07:58] <Geth> ¬¶ rakudo: review: https://github.com/rakudo/rakudo/commit/05816139ea

[08:05] <Geth> ¬¶ rakudo: 5ad102ea76 | (Elizabeth Mattijsen)++ | src/core/Proc.pm6

[08:05] <Geth> ¬¶ rakudo: Make sure Proc.pid is Nil if we didn't run yet

[08:05] <Geth> ¬¶ rakudo: review: https://github.com/rakudo/rakudo/commit/5ad102ea76

[08:26] <Geth> ¬¶ rakudo/js: 58f577a1b1 | pmurias++ | src/Perl6/Metamodel/BOOTSTRAP.nqp

[08:26] <Geth> ¬¶ rakudo/js: [js] Enable phasers cloning code on js backend too

[08:26] <Geth> ¬¶ rakudo/js: review: https://github.com/rakudo/rakudo/commit/58f577a1b1

[08:26] <Geth> ¬¶ rakudo/js: 8a999990d3 | pmurias++ | src/core/traits.pm6

[08:26] <Geth> ¬¶ rakudo/js: Revert "Revert "Fix 'is export' on constants assigned to routines""

[08:26] <Geth> ¬¶ rakudo/js:

[08:26] <Geth> ¬¶ rakudo/js: This reverts commit c5383a1cf3685016e324b03e63da020ba18cb30f.

[08:26] <Geth> ¬¶ rakudo/js: review: https://github.com/rakudo/rakudo/commit/8a999990d3

[08:34] <lizmat> .ask jnthn how do you feel about if a producer of a fixed data size would change the batchsize so that each :degree would only get 1 batch to process

[08:34] <yoleaux> lizmat: I'll pass your message to jnthn.

[08:35] <lizmat> afk for a few hours&

[09:32] <AlexDaniel`> samcv: sounds awesome

[09:35] <samcv> AlexDaniel`: i also got a loop to vectorize into SSE or AVX instructions. which is neat. not sure how much faster that is, but i'll have to test it later

[09:36] <AlexDaniel`> 6 seconds is not that far from 1-2s :)

[09:37] <samcv> but i'd think that'd be many times faster. though sadly we check each grapheme to make sure it fits in 8 bits, so that section can't vecorize. but i did a lot of work to get the loop as tight as possible. and it made a big difference in addition to more loops. basically i first iterate over each strand, looping as long as there's room in the result to copy the whole strand

[09:38] <samcv> so if the strand is 8bit it uses memcpy. if it's not it uses a tight loop that goes for the length of he strand, if i encouners a 32 bit grapheme then i use a goto statement

[09:38] <timotimo> hm, say ...

[09:38] <timotimo> how about we go through whole bunches of graphemes at a time to do the 8bit bounds checks?

[09:38] <samcv> yeah i thought about that as well

[09:38] <timotimo> maybe a quick check against a bit mask could help

[09:38] <samcv> heh we think alike

[09:39] <samcv> #define can_fit_into_8bit_unsafe(g) (!((((g) & 0xffffff80) + 0x80) & (0xffffff80-1)))

[09:39] <timotimo> %)

[09:39] <samcv> it's not faster than an if condition but i figure we could remove the if condition and just do a batch of graphemes

[09:39] <samcv> then after that check the value

[09:39] <timotimo> yeah

[09:40] <timotimo> maybe go through four or five cache lines worth of data at a time with a check, then copy

[09:40] <timotimo> the earlier we notice we'll have to abort and do 32 instead, the better we'll be off, too

[09:41] <samcv> i'd think that checking a fair number at a time, then copying that many

[09:41] <samcv> and then the copy would be able to be vectorized

[09:41] <timotimo> *nod*

[09:46] <samcv> timotimo: you can pass -Rpass=loop-vectorize to clang and it'll tell you which loops were vectorized and the vectorization width

[09:46] <timotimo> on, nice

[09:46] <samcv> and -Rpass-analysis=loop-vectorize will tell you why loops were'n't vectorized

[09:47] <timotimo> right. cool.

[09:47] <timotimo> we could have monitoring for that, too %)

[09:47] <samcv> (will dump out a lot of things)

[09:47] <timotimo> for sure

[09:47] <samcv> most not too useful

[09:47] <samcv> since a lot of things aren't good candidates

[09:51] <timotimo> just to see that things that were once vectorized don't get unvectorized without us knowing about it?

[09:52] <timotimo> looks like gcc has -fopt-info-vec-missed; not sure if -ftree-vectorize is necessary

[09:56] <samcv> hmm yeah could be useful once i play around with it some more

[10:53] <jnthn> .tell Zoffix ecosystem fallout from the addition of `fails-like`: https://travis-ci.org/croservices/cro-http/jobs/359777808#L1459

[10:53] <yoleaux> 08:34Z <lizmat> jnthn: how do you feel about if a producer of a fixed data size would change the batchsize so that each :degree would only get 1 batch to process

[10:53] <yoleaux> jnthn: I'll pass your message to Zoffix.

[10:53] <jnthn> lizmat: Depends entirely on if the user specified :batch or not

[10:53] <jnthn> If they didn't, or only specified :degree but not batch, sure. If they did, then we should honor that

[10:54] <lizmat> ok, so basically, setting the default in .hyper/.race is too early

[10:54] <jnthn> But when :batch and/or :degree are not set, that's our invitation to try and apply what heuristics we can to pick someting good

[10:54] <jnthn> Yes

[10:54] <lizmat> ok, I'll run with that

[10:55] <Zoffix> jnthn: are methods safe to callstatic once resolved to a Method object? https://github.com/rakudo/rakudo/pull/1665

[10:55] <jnthn> Funnily enough, the ecosystem fallout pretty much speaks in favor of `fails-like` being provided :P

[10:56] <jnthn> Zoffix: I'm confused what on earth code that is generating, to be honest :)

[10:56] <jnthn> In that I thought callstatic fell back to call in the non-named case, but since you spot a difference, I want to know what it's doing :)

[10:57] <Zoffix> Ohhh

[10:57] <jnthn> (Which means I need to look at the output bytecode, which I didn't get time to do yet)

[10:57] <Zoffix> greppable6: fails\-like

[10:57] <greppable6> Zoffix, 12 lines, 2 modules: https://gist.github.com/0f201f5100fdfeb6fb4a73cc548e59f5

[10:58] <Zoffix> Wonder why Cro's not in the list...

[10:59] <jnthn> Zoffix: The ecosystem fallout isn't in Cro itself, it's in a module Cro depends on

[10:59] <Zoffix> Ooohh

[10:59] <Zoffix> Easy to fix, since it's my module :P

[10:59] <jnthn> IO::Path::ChildSecure

[10:59] <jnthn> yes ;)

[11:01] <Zoffix> Fix pushed

[11:02] <dogbert17> Zoffix: FYI, the NQP program you supplied in G#1667 crashes on 32 bit systems (at least on mine :)

[11:03] <Zoffix> R#1667

[11:03] <synopsebot> R#1667 [open]: https://github.com/rakudo/rakudo/issues/1667 [perf] Some string benchmark

[11:03] <dogbert17> gah, I always get that wrong :(

[11:03] <Zoffix> dogbert17: and non-NQP doesn't crash? That's weird, because I copy-pasted the guts of .subst

[11:04] <dogbert17> the crash is an out of memory one

[11:04] <dogbert17> MoarVM panic: Memory allocation failed; could not allocate 691840 bytes

[11:05] <Zoffix> Ah

[11:05] <Zoffix> |90d see if we can improve sum algo: https://en.wikipedia.org/wiki/Kahan_summation_algorithm#Further_enhancements https://twitter.com/johnmyleswhite/status/977521876904882178

[11:05] <ZofBot> Zoffix, Will remind you on 2018-06-27T07:05:54.184636-04:00 about see if we can improve sum algo: https://en.wikipedia.org/wiki/Kahan_summation_algorithm#Further_enhancements https://twitter.com/johnmyleswhite/status/977521876904882178

[11:06] <dogbert17> it eats through memory like there's no tomorrow :)

[11:14] <timotimo> eating memory really, really, really fast is often an infinite recursion

[11:16] <lizmat> So I'm looking at why the null-line of the supervisor loop is still calling List.sink 3 times every iteration

[11:19] <lizmat> (which now comes to something like 1% overhead and additional BootHash allocations

[11:20] <lizmat> suggestions?

[11:22] <pmurias> do we have data/graph how the numbers of spectest the jvm backend is passing progressess?

[11:58] <Geth> ¬¶ rakudo: ae91db887b | (Elizabeth Mattijsen)++ | src/core/ThreadPoolScheduler.pm6

[11:58] <Geth> ¬¶ rakudo: Replace .elems by nqp::elems() in scheduler

[11:58] <Geth> ¬¶ rakudo:

[11:58] <Geth> ¬¶ rakudo: Reduces CPU usage of idling supervisor by 5%, and reduces the number of

[11:58] <Geth> ¬¶ rakudo: Int and BOOTHash allocations siginificantly.

[11:58] <Geth> ¬¶ rakudo: review: https://github.com/rakudo/rakudo/commit/ae91db887b

[12:23] <Geth> ¬¶ rakudo: f8c441642c | (Elizabeth Mattijsen)++ | src/core/ThreadPoolScheduler.pm6

[12:23] <Geth> ¬¶ rakudo: Only check affinity-workers if there are any

[12:23] <Geth> ¬¶ rakudo:

[12:23] <Geth> ¬¶ rakudo: Shaves off another 2% of CPU usage of the idle supervisor loop

[12:23] <Geth> ¬¶ rakudo: review: https://github.com/rakudo/rakudo/commit/f8c441642c

[12:28] <lizmat> [Tux]: updated Text::CSV with "is default" on the attributes

[12:29] <|Tux|> lizmat++

[12:30] <lizmat> afk for a bit&

[12:45] <samcv> |Tux|: this seems to show some drop https://tux.nl/Talks/CSV6/images/test-t-d10.png

[12:45] <samcv> since the mvm change i made today

[12:46] <|Tux|> samv, you were looking too quickly :)

[12:46] <|Tux|> this might be due to lizmat's change. I just re-ran the tests:

[12:46] <|Tux|> Rakudo version 2018.03-122-g23af1f4aa - MoarVM version 2018.03-35-gafdcad424

[12:46] <|Tux|> csv-test-xs-20      0.448 -  0.456

[12:46] <|Tux|> csv-ip5xs           0.893 -  0.897

[12:46] <|Tux|> test-t --race       1.005 -  1.026

[12:46] <|Tux|> test-t              2.372 -  2.379

[12:46] <|Tux|> csv-ip5xs-20        8.592 -  8.631

[12:46] <|Tux|> test                8.891 -  8.955

[12:46] <|Tux|> test-t-20 --race   14.929 - 15.409

[12:46] <|Tux|> csv-parser         36.272 - 36.762

[12:46] <|Tux|> test-t-20          41.926 - 42.787

[12:47] <samcv> oh

[12:47] <|Tux|> üëç

[12:47] <samcv> the threadpool scheduler or another |Tux|

[12:48] <|Tux|> ?

[12:48] <samcv> i just made a big change to the string indexing code https://github.com/MoarVM/MoarVM/commit/32d66d568376a2ce346bb60339674df92f98c689 i got 0.5x to 3x speed improvement i even saw

[12:51] <samcv> went from  2.0685436 to 0.3240215s on this test https://gist.github.com/samcv/adc8d50df303e457ed7cb6b85b66e94e#file-strand-speed-test-p6-L15-L25

[12:52] <samcv> the commit description should give info on the change

[12:57] <[Coke]> samcv: so, I read 3x speed improvement as "runs in 1/3 the time"... if *that's* right, then 0.5 would mean in twice the time.

[12:57] <[Coke]> Can you explain 0.5x to 3x improvement?

[12:58] <[Coke]> (not how you did it, just what those numbers mean?)

[13:03] <samcv> sorry ignore my wording. it's confusing saying 0.5x faster. i mean 1.5x the speed as before or it takes 2/3 to 1/4 the time

[13:05] <samcv> and technically in that one test it completed in 1/6 the time, but aside from that. the math i was using was 50% faster: original_time * 100/(100+50) = original_time * 2/3

[13:06] <samcv> though that's not on that test, it's just an overall thing i observed so picked a conservative amount. since not all things complete in 1/6 the time like that one test

[16:03] <jnthn> grrr, https://github.com/rakudo/rakudo/issues/1660 seems to be some memory corruption issue...but no luck getting valgrind to show it up

[16:07] <jnthn> Hurrah, ASAN finds it

[16:08] <jnthn> Not that the output immediately makes clear what's up

[16:09] <dogbert17> +jnthn+

[16:29] <dogbert17> jnthn: managed to trip my ASAN as well: MVM_fixed_size_alloc src/core/fixedsizealloc.c:188

[16:29] <dogbert17> did you get the same?

[16:36] <jnthn> Yeah, but it makes...not a huge amount of sense

[16:36] <jnthn> I did spot something problematic and fixed it, but it didn't help

[16:37] <dogbert17> perhaps it fixes some other problem though

[16:38] <Geth> ¬¶ rakudo: a12ea10690 | (Moritz Lenz)++ | CONTRIBUTING.md

[16:38] <Geth> ¬¶ rakudo: Fix grammar error in CONTRIBUTING.md

[16:38] <Geth> ¬¶ rakudo: review: https://github.com/rakudo/rakudo/commit/a12ea10690

[16:38] <moritz> the sentence still reads awkwardly, IMHO

[16:38] <jnthn> dogbert17: perhaps, yes

[16:40] <dogbert17> jnthn: I got a better ASAN barf: https://gist.github.com/dogbert17/dfcb5716be03f68cfe2acf4348b27e9c

[16:41] <jnthn> o.O

[16:45] <jnthn> Well, that one does make sense

[16:45] <jnthn> And I've probably got a fix for that too

[16:45] <jnthn> But it doesn't help with the original ASAN trace I see

[16:47] <dogbert17> argh

[16:48] <dogbert17> so multiple problems then

[16:49] <jnthn> Multiple fixes too :P

[16:49] <jnthn> Just not to the primary issue

[16:49] <jnthn> AddressSanitizer can not describe address in more detail (wild memory access suspected).

[16:49] <jnthn> SUMMARY: AddressSanitizer: heap-buffer-overflow src/gc/collect.c:367 MVM_gc_mark_collectable

[16:49] <jnthn> That about sums it up...there's a comletely nuts SC index in there

[16:51] <dogbert17> and valgrind doesn't want to play ball either :(

[17:24] <jnthn> Well, it ain't giving up its secrets easily

[17:31] <jnthn> Really weird. I'm looking at something that looks like a frame, but with a wildly bogus SC index, but the bogus indices are in a union with the pointer it uses to chain STables for cleanup

[17:31] <jnthn> And that is a valid pointer to an STable

[17:31] <jnthn> Which can't be just down to chance

[17:33] <jnthn> But only an ST can ever be put onto that linked list, and I don't see how that bit could be going wrong

[17:35] <jnthn> Ah well, will continue tomorrow

[17:44] <dogbert17> jnthn: got this: https://gist.github.com/dogbert17/08b377bf09dea5c335bb6a4697ad0820

[18:44] <Geth> ¬¶ rakudo: 924310c5ff | usev6++ | src/core/ThreadPoolScheduler.pm6

[18:44] <Geth> ¬¶ rakudo: [JVM] Remove superfluous call to .shift

[18:44] <Geth> ¬¶ rakudo:

[18:44] <Geth> ¬¶ rakudo: Leftover from https://github.com/rakudo/rakudo/commit/4ef28a7bcb

[18:44] <Geth> ¬¶ rakudo: review: https://github.com/rakudo/rakudo/commit/924310c5ff

[18:59] <bartolin> for some reasons the following test has started to fail on the JVM backend:

[18:59] <bartolin> r: use Test; is (^10).grep(Int, :!kv), [^10]

[18:59] <camelia> rakudo-moar 924310c5f, rakudo-jvm a92950fb4: OUTPUT: ¬´ok 1 - ‚ê§¬ª

[18:59] <bartolin> r: dd (^10).grep(Int, :!kv); dd [^10]

[18:59] <camelia> rakudo-moar 924310c5f, rakudo-jvm a92950fb4: OUTPUT: ¬´(0, 1, 2, 3, 4, 5, 6, 7, 8, 9).Seq‚ê§[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]‚ê§¬ª

[19:01] <bartolin> it's from S32-list/grep-kv.t: https://github.com/perl6/roast/blob/4c1a52d7555ecbf8a13af0dbfdcc6ae99f0e97ca/S32-list/grep-kv.t#L73

[19:02] <bartolin> would it make sense to change the test to use is-deeply, like this?

[19:02] <bartolin> r: use Test; is-deeply (^10).grep(Int, :!kv), [^10].Seq

[19:02] <camelia> rakudo-moar 924310c5f, rakudo-jvm a92950fb4: OUTPUT: ¬´ok 1 - ‚ê§¬ª

[19:02] <bartolin> (that still passes with HEAD on rakudo-j

[19:17] <Zoffix> bartolin: yeah, `is` is a completely inappropriate routine in this case as (1, (2, (3, ...) and all sorts of other variations would pass... But what does the failure look like?

[19:20] <bartolin> Zoffix: oops, I just run it standalone and it passes. I'm afraid I raised a false alarm -- probably I messed something up.

[19:21] <bartolin> sorry, it looks like I mis-read the output from running the test file. it was another test that failed -- and that failure is for real

[19:21] * bartolin should head to bed, obviously

[19:22] <Zoffix> Ah

[19:35] <Geth> ¬¶ rakudo: 7572983a41 | (Jonathan Worthington)++ | src/core/Supply.pm6

[19:35] <Geth> ¬¶ rakudo: Make Supply.interval a serial Supply

[19:35] <Geth> ¬¶ rakudo:

[19:35] <Geth> ¬¶ rakudo: Previously, it was non-serial, and relied on something downstream

[19:35] <Geth> ¬¶ rakudo: calling `.serialize`. The `whenever` construct would do exactly that,

[19:35] <Geth> ¬¶ rakudo: so the only way to observe this was a `.tap` on the interval `Supply`

[19:35] <Geth> ¬¶ rakudo: directly.

[19:35] <Geth> ¬¶ rakudo:

[19:35] <Geth> ¬¶ rakudo: <‚Ä¶commit message has 19 more lines‚Ä¶>

[19:35] <Geth> ¬¶ rakudo: review: https://github.com/rakudo/rakudo/commit/7572983a41

[19:42] <Geth> ¬¶ 6.d-prep: ed472e08e3 | (Zoffix Znet)++ (committed using GitHub Web editor) | TODO/FEATURES.md

[19:42] <Geth> ¬¶ 6.d-prep: List Str.subst-mutate for deprecation and removal

[19:42] <Geth> ¬¶ 6.d-prep: review: https://github.com/perl6/6.d-prep/commit/ed472e08e3

[19:45] <Geth> ¬¶ 6.d-prep: 138e73aab8 | (Zoffix Znet)++ (committed using GitHub Web editor) | TODO/FEATURES.md

[19:45] <Geth> ¬¶ 6.d-prep: Remove `Make `.?` safecall actually safe`

[19:45] <Geth> ¬¶ 6.d-prep:

[19:45] <Geth> ¬¶ 6.d-prep: I no longer think that's the right path to follow, so as the Stakeholder,

[19:45] <Geth> ¬¶ 6.d-prep: I'm tossing the entire proposal.

[19:45] <Geth> ¬¶ 6.d-prep:

[19:45] <Geth> ¬¶ 6.d-prep: The .? safety will be significantly improved once the :D calls on Nil are fixed up

[19:45] <Geth> ¬¶ 6.d-prep: review: https://github.com/perl6/6.d-prep/commit/138e73aab8

[20:29] <nine> LOL I wrote a make in NQP in an evening and it builds rakudo

[20:30] <tadzik> :D

[20:30] <tadzik> damn, that's good :)

[20:30] <tadzik> . o O ( not quite make )

[20:37] <dogbert17> nine++: perhaps you should call it nmake :)

[20:37] <jnthn> .oO( nine make? :D )

[20:44] <lizmat> NQM ?

[20:45] <nine> Just shy of 250 LOC and it makes it through make install. Really fun coding exercise :)

[20:46] <nine> https://gist.github.com/niner/a959cb893820446bfb7177392d4c16cb for the curious

[20:48] <jnthn> That's amaziong :D

[20:48] <lizmat> notable6 weekly: https://gist.github.com/niner/a959cb893820446bfb7177392d4c16cb

[20:49] <AlexDaniel> : or ,

[20:49] <AlexDaniel> well‚Ä¶

[20:49] <lizmat> notable6 weekly, https://gist.github.com/niner/a959cb893820446bfb7177392d4c16cb

[20:49] <AlexDaniel> weekly: https://gist.github.com/niner/a959cb893820446bfb7177392d4c16cb

[20:49] <notable6> AlexDaniel, Noted!

[20:49] <lizmat> argh ok

[20:49] <AlexDaniel> alternatively ‚Äúnotable6: weekly https‚Ä¶‚Ä¶‚Ä¶‚Äù

[20:49] <lizmat> understood

[21:41] <Kaiepi> for rakudo's Configure.pl, i'm wondering if adding a --moar-options flag that lets you pass multiple flags at once would be a good idea

[21:42] <Kaiepi> like this is a lot of typing: ./Configure.pl --gen-moar --moar-option=--has-dyncall --moar-option=--cc=egcc --moar-option=--telemeh --moar-option=--optimize=0 --moar-option=--debug=3 --prefix=$HOME/.perl6

[21:42] <Kaiepi> or modify --moar-option so that that'd work

[21:43] <Kaiepi> so instead --moar-option(s?)='--has-dyncall --cc=egcc --telemeh --optimize=0 --debug=3' would work

[22:03] <AlexDaniel> Kaiepi: can't you just concat them all?

[22:04] <AlexDaniel> hm maybe not, but I thought you can‚Ä¶

[22:04] <AlexDaniel> like '--moar-option==--foo --bar ‚Ä¶'

[22:13] <Kaiepi> Unknown option: cc-egcc --has-dyncall _

[22:14] <Kaiepi> oh typo

[22:14] <Kaiepi> yeah that works

[22:14] <Kaiepi> i feel it's not very obvious though

[22:15] <Kaiepi> wait

[22:15] <Kaiepi> egcc: error: unrecognized command line option '--has-dyncall'

[22:15] <Kaiepi> nope, doesn't work

[22:26] <AlexDaniel> did you quote it correctly? :)

[22:26] <AlexDaniel> but yeah, maybe it doesn't work

[22:29] <Kaiepi> i did '--moar-option='--cc=egcc --has-dyncall _'

[22:29] <Kaiepi> * '--moar-option=--cc=egcc --has-dyncall _'

[22:36] <Kaiepi> also, i might throw up a couple more bots like BeastieBot/PufferBot in vms on my system

[22:36] <Kaiepi> i only have the ram to feasibly run two atm though

[22:36] <Kaiepi> what systems desperately need testing?

[22:37] <Kaiepi> i was thinking netbsd and solaris, but i'm wondering about systems on other architectures

[22:42] <Kaiepi> like maybe testing for arm on debian

[23:46] <Kaiepi> one thing i've noticed is the stage parse parts of building rakudo take much longer on openbsd compared to other systems

[23:47] <Kaiepi> like ~70s compared to ~30s in an alpine vm

[23:47] <Kaiepi> i know there's overhead from the additional security features openbsd has, but i'm wondering if there are ways to help optimize it

[23:47] <Kaiepi> like using pledge in moarvm

[23:47] <MasterDuke> your vm must be pretty beefy, i get 80s stage parse not in a vm

[23:50] <Kaiepi> i use moar, if that's what you mean

[23:51] <MasterDuke> same here
